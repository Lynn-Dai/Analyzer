,hash,filename,change_type,diff,added_lines,deleted_lines,changed_methods
0,d337b2780d86dc714c937797d61e4ac6dc6a6b38,LockSettingsService.java,ModificationType.MODIFY,"@@ -1179,7 +1179,7 @@ public class LockSettingsService extends ILockSettings.Stub {
          */
        if (checkCryptKeeperPermissions())
             mContext.enforceCallingOrSelfPermission(
-                    android.Manifest.permission.MANAGE_DEVICE_ADMINS,
+                    android.Manifest.permission.ACCESS_KEYGUARD_SECURE_STORAGE,
                     ""no crypt_keeper or admin permission to get the password"");
 
        return mSavePassword;
",1,1,LockSettingsService::getPassword
1,453cc9ba78a8a0171e3cfeb0f5553610d3dd6430,NotificationInterruptionStateProvider.java,ModificationType.MODIFY,"@@ -23,6 +23,7 @@ import android.app.NotificationManager;
 import android.content.Context;
 import android.database.ContentObserver;
 import android.hardware.display.AmbientDisplayConfiguration;
+import android.os.Build;
 import android.os.PowerManager;
 import android.os.RemoteException;
 import android.os.ServiceManager;
@@ -53,7 +54,7 @@ public class NotificationInterruptionStateProvider {
 
     private static final String TAG = ""InterruptionStateProvider"";
     private static final boolean DEBUG = false;
-    private static final boolean DEBUG_HEADS_UP = true;
+    private static final boolean DEBUG_HEADS_UP = Build.IS_ENG;
     private static final boolean ENABLE_HEADS_UP = true;
     private static final String SETTING_HEADS_UP_TICKER = ""ticker_gets_heads_up"";
 
",2,1,
2,16403880f67e4cd4120ad0d878b54130b55ae3c7,BatteryService.java,ModificationType.MODIFY,"@@ -165,6 +165,7 @@ public final class BatteryService extends SystemService {
     private int mLastInvalidCharger;
 
     private int mLowBatteryWarningLevel;
+    private int mLastLowBatteryWarningLevel;
     private int mLowBatteryCloseWarningLevel;
     private int mShutdownBatteryTemperature;
 
@@ -325,6 +326,7 @@ public final class BatteryService extends SystemService {
         final ContentResolver resolver = mContext.getContentResolver();
         int defWarnLevel = mContext.getResources().getInteger(
                 com.android.internal.R.integer.config_lowBatteryWarningLevel);
+        mLastLowBatteryWarningLevel = mLowBatteryWarningLevel;
         mLowBatteryWarningLevel = Settings.Global.getInt(resolver,
                 Settings.Global.LOW_POWER_MODE_TRIGGER_LEVEL, defWarnLevel);
         if (mLowBatteryWarningLevel == 0) {
@@ -369,7 +371,8 @@ public final class BatteryService extends SystemService {
         return !plugged
                 && mHealthInfo.batteryStatus != BatteryManager.BATTERY_STATUS_UNKNOWN
                 && mHealthInfo.batteryLevel <= mLowBatteryWarningLevel
-                && (oldPlugged || mLastBatteryLevel > mLowBatteryWarningLevel);
+                && (oldPlugged || mLastBatteryLevel > mLowBatteryWarningLevel
+                    || mHealthInfo.batteryLevel > mLastLowBatteryWarningLevel);
     }
 
     private boolean shouldShutdownLocked() {
",4,1,"BatteryService::updateBatteryWarningLevelLocked, BatteryService::shouldSendBatteryLowLocked"
3,c3773a8967b689b9cf932499129a51f325e103a2,BluetoothDevice.java,ModificationType.MODIFY,"@@ -1014,7 +1014,11 @@ public final class BluetoothDevice implements Parcelable {
         try {
             String name = service.getRemoteName(this);
             if (name != null) {
-                return name.replaceAll(""[\\t\\n\\r]+"", "" "");
+                // remove whitespace characters from the name
+                return name
+                        .replace('\t', ' ')
+                        .replace('\n', ' ')
+                        .replace('\r', ' ');
             }
             return null;
         } catch (RemoteException e) {
",5,1,BluetoothDevice::getName
4,b86730393e42901b8fb5784bc8481c48938693d5,MediaCodec.java,ModificationType.MODIFY,"@@ -1703,20 +1703,22 @@ final public class MediaCodec {
                     break;
                 }
                 case EVENT_FRAME_RENDERED:
-                    synchronized (mListenerLock) {
-                        Map<String, Object> map = (Map<String, Object>)msg.obj;
-                        for (int i = 0; ; ++i) {
-                            Object mediaTimeUs = map.get(i + ""-media-time-us"");
-                            Object systemNano = map.get(i + ""-system-nano"");
-                            if (mediaTimeUs == null || systemNano == null
-                                    || mOnFrameRenderedListener == null) {
-                                break;
-                            }
-                            mOnFrameRenderedListener.onFrameRendered(
-                                    mCodec, (long)mediaTimeUs, (long)systemNano);
+                    Map<String, Object> map = (Map<String, Object>)msg.obj;
+                    for (int i = 0; ; ++i) {
+                        Object mediaTimeUs = map.get(i + ""-media-time-us"");
+                        Object systemNano = map.get(i + ""-system-nano"");
+                        OnFrameRenderedListener onFrameRenderedListener;
+                        synchronized (mListenerLock) {
+                            onFrameRenderedListener = mOnFrameRenderedListener;
                         }
-                        break;
+                        if (mediaTimeUs == null || systemNano == null
+                                || onFrameRenderedListener == null) {
+                            break;
+                        }
+                        onFrameRenderedListener.onFrameRendered(
+                                mCodec, (long)mediaTimeUs, (long)systemNano);
                     }
+                    break;
                 default:
                 {
                     break;
",14,12,MediaCodec::EventHandler::handleMessage
5,0208b9bd26eba0f2b376a08c45613a7945a5e86d,AlarmManagerService.java,ModificationType.MODIFY,"@@ -1673,6 +1673,7 @@ class AlarmManagerService extends SystemService {
             Intent intent = new Intent(Intent.ACTION_TIMEZONE_CHANGED);
             intent.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING
                     | Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND
+                    | Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT
                     | Intent.FLAG_RECEIVER_VISIBLE_TO_INSTANT_APPS);
             intent.putExtra(""time-zone"", zone.getID());
             getContext().sendBroadcastAsUser(intent, UserHandle.ALL);
",1,0,AlarmManagerService::setTimeZoneImpl
6,5bb0d517d6a8dad7588a1850b32892c56b125f55,EdgeBackGestureHandler.java,ModificationType.MODIFY,"@@ -19,6 +19,8 @@ import static android.view.Display.INVALID_DISPLAY;
 import static android.view.View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY;
 import static android.view.View.NAVIGATION_BAR_TRANSIENT;
 
+import static org.lineageos.internal.util.DeviceKeysConstants.Action;
+
 import android.content.Context;
 import android.content.pm.ParceledListSlice;
 import android.content.res.Resources;
@@ -60,6 +62,9 @@ import com.android.systemui.bubbles.BubbleController;
 import com.android.systemui.recents.OverviewProxyService;
 import com.android.systemui.shared.system.QuickStepContract;
 import com.android.systemui.shared.system.WindowManagerWrapper;
+import com.android.systemui.tuner.TunerService;
+
+import lineageos.providers.LineageSettings;
 
 import java.io.PrintWriter;
 import java.util.concurrent.Executor;
@@ -67,12 +72,15 @@ import java.util.concurrent.Executor;
 /**
  * Utility class to handle edge swipes for back gesture
  */
-public class EdgeBackGestureHandler implements DisplayListener {
+public class EdgeBackGestureHandler implements DisplayListener, TunerService.Tunable {
 
     private static final String TAG = ""EdgeBackGestureHandler"";
     private static final int MAX_LONG_PRESS_TIMEOUT = SystemProperties.getInt(
             ""gestures.back_timeout"", 250);
 
+    private static final String KEY_EDGE_LONG_SWIPE_ACTION =
+            ""lineagesystem:"" + LineageSettings.System.KEY_EDGE_LONG_SWIPE_ACTION;
+
     private final IPinnedStackListener.Stub mImeChangedListener = new IPinnedStackListener.Stub() {
         @Override
         public void onListenerRegistered(IPinnedStackController controller) {
@@ -157,6 +165,7 @@ public class EdgeBackGestureHandler implements DisplayListener {
     private boolean mIsGesturalModeEnabled;
     private boolean mIsEnabled;
     private boolean mIsInTransientImmersiveStickyState;
+    private boolean mIsLongSwipeEnabled;
 
     private InputMonitor mInputMonitor;
     private InputEventReceiver mInputEventReceiver;
@@ -169,6 +178,7 @@ public class EdgeBackGestureHandler implements DisplayListener {
     private RegionSamplingHelper mRegionSamplingHelper;
     private int mLeftInset;
     private int mRightInset;
+    private float mLongSwipeWidth;
 
     public EdgeBackGestureHandler(Context context, OverviewProxyService overviewProxyService) {
         final Resources res = context.getResources();
@@ -178,6 +188,9 @@ public class EdgeBackGestureHandler implements DisplayListener {
         mWm = context.getSystemService(WindowManager.class);
         mOverviewProxyService = overviewProxyService;
 
+        final TunerService tunerService = Dependency.get(TunerService.class);
+        tunerService.addTunable(this, KEY_EDGE_LONG_SWIPE_ACTION);
+
         // Reduce the default touch slop to ensure that we can intercept the gesture
         // before the app starts to react to it.
         // TODO(b/130352502) Tune this value and extract into a constant
@@ -301,6 +314,7 @@ public class EdgeBackGestureHandler implements DisplayListener {
             mEdgePanelLp.accessibilityTitle = mContext.getString(R.string.nav_bar_edge_panel);
             mEdgePanelLp.windowAnimations = 0;
             mEdgePanel.setLayoutParams(mEdgePanelLp);
+            updateLongSwipeWidth();
             mWm.addView(mEdgePanel, mEdgePanelLp);
             mRegionSamplingHelper = new RegionSamplingHelper(mEdgePanel,
                     new RegionSamplingHelper.SamplingCallback() {
@@ -418,11 +432,19 @@ public class EdgeBackGestureHandler implements DisplayListener {
             boolean isUp = action == MotionEvent.ACTION_UP;
             if (isUp) {
                 boolean performAction = mEdgePanel.shouldTriggerBack();
-                if (performAction) {
+                boolean performLongSwipe = mEdgePanel.shouldTriggerLongSwipe();
+                if (performLongSwipe) {
+                    // Perform long swipe action
+                    sendEvent(KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_BACK,
+                            KeyEvent.FLAG_LONG_PRESS);
+                    sendEvent(KeyEvent.ACTION_UP, KeyEvent.KEYCODE_BACK,
+                            KeyEvent.FLAG_LONG_PRESS);
+                } else if (performAction) {
                     // Perform back
                     sendEvent(KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_BACK);
                     sendEvent(KeyEvent.ACTION_UP, KeyEvent.KEYCODE_BACK);
                 }
+                performAction = performAction || performLongSwipe;
                 mOverviewProxyService.notifyBackAction(performAction, (int) mDownPoint.x,
                         (int) mDownPoint.y, false /* isButton */, !mIsOnLeftEdge);
                 int backtype = performAction ? (mInRejectedExclusion
@@ -460,6 +482,17 @@ public class EdgeBackGestureHandler implements DisplayListener {
         mEdgePanel.adjustRectToBoundingBox(mSamplingRect);
     }
 
+    private void updateLongSwipeWidth() {
+        if (mIsEnabled && mEdgePanel != null) {
+            if (mIsLongSwipeEnabled) {
+                mLongSwipeWidth = MathUtils.min(mDisplaySize.x * 0.5f, mEdgePanelLp.width * 2.5f);
+                mEdgePanel.setLongSwipeThreshold(mLongSwipeWidth);
+            } else {
+                mEdgePanel.setLongSwipeThreshold(0.0f);
+            }
+        }
+    }
+
     @Override
     public void onDisplayAdded(int displayId) { }
 
@@ -477,13 +510,27 @@ public class EdgeBackGestureHandler implements DisplayListener {
         mContext.getSystemService(DisplayManager.class)
                 .getDisplay(mDisplayId)
                 .getRealSize(mDisplaySize);
+        updateLongSwipeWidth();
+    }
+
+    @Override
+    public void onTuningChanged(String key, String newValue) {
+        if (KEY_EDGE_LONG_SWIPE_ACTION.equals(key)) {
+            mIsLongSwipeEnabled = newValue != null
+                    && Action.fromIntSafe(Integer.parseInt(newValue)) != Action.NOTHING;
+            updateLongSwipeWidth();
+        }
     }
 
     private void sendEvent(int action, int code) {
+        sendEvent(action, code, 0);
+    }
+
+    private void sendEvent(int action, int code, int flags) {
         long when = SystemClock.uptimeMillis();
         final KeyEvent ev = new KeyEvent(when, when, action, code, 0 /* repeat */,
                 0 /* metaState */, KeyCharacterMap.VIRTUAL_KEYBOARD, 0 /* scancode */,
-                KeyEvent.FLAG_FROM_SYSTEM | KeyEvent.FLAG_VIRTUAL_HARD_KEY,
+                flags | KeyEvent.FLAG_FROM_SYSTEM | KeyEvent.FLAG_VIRTUAL_HARD_KEY,
                 InputDevice.SOURCE_KEYBOARD);
 
         // Bubble controller will give us a valid display id if it should get the back event
",50,3,"EdgeBackGestureHandler::EdgeBackGestureHandler, EdgeBackGestureHandler::onMotionEvent, EdgeBackGestureHandler::sendEvent, EdgeBackGestureHandler::updateLongSwipeWidth, EdgeBackGestureHandler::updateIsEnabled, EdgeBackGestureHandler::updateDisplaySize, EdgeBackGestureHandler::onTuningChanged, EdgeBackGestureHandler::sendEvent"
7,5bb0d517d6a8dad7588a1850b32892c56b125f55,NavigationBarEdgePanel.java,ModificationType.MODIFY,"@@ -179,7 +179,9 @@ public class NavigationBarEdgePanel extends View {
     private boolean mDragSlopPassed;
     private boolean mArrowsPointLeft;
     private float mMaxTranslation;
+    private float mLongSwipeThreshold;
     private boolean mTriggerBack;
+    private boolean mTriggerLongSwipe;
     private float mPreviousTouchTranslation;
     private float mTotalTouchDelta;
     private float mVerticalTranslation;
@@ -192,6 +194,8 @@ public class NavigationBarEdgePanel extends View {
     private long mVibrationTime;
     private int mScreenSize;
 
+    private boolean mIsLongSwipeEnabled;
+
     private DynamicAnimation.OnAnimationEndListener mSetGoneEndListener
             = new DynamicAnimation.OnAnimationEndListener() {
         @Override
@@ -328,6 +332,10 @@ public class NavigationBarEdgePanel extends View {
         return mTriggerBack;
     }
 
+    public boolean shouldTriggerLongSwipe() {
+        return mTriggerLongSwipe;
+    }
+
     public void setIsDark(boolean isDark, boolean animate) {
         mIsDark = isDark;
         updateIsDark(animate);
@@ -342,6 +350,12 @@ public class NavigationBarEdgePanel extends View {
         mIsLeftPanel = isLeftPanel;
     }
 
+    public void setLongSwipeThreshold(float longSwipeThreshold) {
+        mLongSwipeThreshold = longSwipeThreshold;
+        mIsLongSwipeEnabled = mLongSwipeThreshold > 0;
+        setTriggerLongSwipe(mIsLongSwipeEnabled && mTriggerLongSwipe, false /* animated */);
+    }
+
     /**
      * Adjust the rect to conform the the actual visible bounding box of the arrow.
      *
@@ -436,6 +450,11 @@ public class NavigationBarEdgePanel extends View {
         float x = (polarToCartX(mCurrentAngle) * mArrowLength);
         float y = (polarToCartY(mCurrentAngle) * mArrowLength);
         Path arrowPath = calculatePath(x,y);
+        if (mTriggerLongSwipe) {
+            arrowPath.addPath(calculatePath(x,y),
+                    mArrowThickness * 2.0f * (mIsLeftPanel ? 1 : -1), 0.0f);
+        }
+
         if (mShowProtection) {
             canvas.drawPath(arrowPath, mProtectionPaint);
         }
@@ -586,6 +605,7 @@ public class NavigationBarEdgePanel extends View {
         mTranslationAnimation.setSpring(mRegularTranslationSpring);
         // Reset the arrow to the side
         setTriggerBack(false /* triggerBack */, false /* animated */);
+        setTriggerLongSwipe(false /* triggerLongSwipe */, false /* animated */);
         setDesiredTranslation(0, false /* animated */);
         setCurrentTranslation(0);
         updateAngle(false /* animate */);
@@ -609,6 +629,7 @@ public class NavigationBarEdgePanel extends View {
             }
         }
         mPreviousTouchTranslation = touchTranslation;
+        boolean isLongSwipe = touchTranslation > mLongSwipeThreshold;
 
         // Apply a haptic on drag slop passed
         if (!mDragSlopPassed && touchTranslation > mSwipeThreshold) {
@@ -660,6 +681,12 @@ public class NavigationBarEdgePanel extends View {
         if (Math.abs(yOffset) > Math.abs(x - mStartX) * 2) {
             triggerBack = false;
         }
+
+        if (mIsLongSwipeEnabled) {
+            boolean triggerLongSwipe = triggerBack && isLongSwipe;
+            setTriggerLongSwipe(triggerLongSwipe, true /* animated */);
+        }
+
         setTriggerBack(triggerBack, true /* animated */);
 
         if (!mTriggerBack) {
@@ -730,6 +757,18 @@ public class NavigationBarEdgePanel extends View {
         }
     }
 
+    private void setTriggerLongSwipe(boolean triggerLongSwipe, boolean animated) {
+        if (mTriggerLongSwipe != triggerLongSwipe) {
+            mTriggerLongSwipe = triggerLongSwipe;
+            mVibratorHelper.vibrate(VibrationEffect.EFFECT_CLICK);
+            mAngleAnimation.cancel();
+            updateAngle(animated);
+            // Whenever the trigger back state changes the existing translation animation should be
+            // cancelled
+            mTranslationAnimation.cancel();
+        }
+    }
+
     private void updateAngle(boolean animated) {
         float newAngle = mTriggerBack ? ARROW_ANGLE_WHEN_EXTENDED_DEGREES + mAngleOffset : 90;
         if (newAngle != mDesiredAngle) {
",39,0,"NavigationBarEdgePanel::onDraw, NavigationBarEdgePanel::setTriggerLongSwipe, NavigationBarEdgePanel::shouldTriggerLongSwipe, NavigationBarEdgePanel::handleMoveEvent, NavigationBarEdgePanel::setLongSwipeThreshold, NavigationBarEdgePanel::resetOnDown"
8,5bb0d517d6a8dad7588a1850b32892c56b125f55,PhoneWindowManager.java,ModificationType.MODIFY,"@@ -582,6 +582,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
     private Action mAssistLongPressAction;
     private Action mAppSwitchPressAction;
     private Action mAppSwitchLongPressAction;
+    private Action mEdgeLongSwipeAction;
 
     // support for activating the lock screen while the screen is on
     private HashSet<Integer> mAllowLockscreenWhenOnDisplays = new HashSet<>();
@@ -732,6 +733,10 @@ public class PhoneWindowManager implements WindowManagerPolicy {
     private int mTorchTimeout;
     private PendingIntent mTorchOffPendingIntent;
 
+    private boolean mLongSwipeDown;
+    private static final int LONG_SWIPE_FLAGS = KeyEvent.FLAG_LONG_PRESS
+            | KeyEvent.FLAG_FROM_SYSTEM | KeyEvent.FLAG_VIRTUAL_HARD_KEY;
+
     private LineageHardwareManager mLineageHardware;
 
     private class PolicyHandler extends Handler {
@@ -932,6 +937,9 @@ public class PhoneWindowManager implements WindowManagerPolicy {
             resolver.registerContentObserver(LineageSettings.System.getUriFor(
                     LineageSettings.System.KEY_APP_SWITCH_LONG_PRESS_ACTION), false, this,
                     UserHandle.USER_ALL);
+            resolver.registerContentObserver(LineageSettings.System.getUriFor(
+                    LineageSettings.System.KEY_EDGE_LONG_SWIPE_ACTION), false, this,
+                    UserHandle.USER_ALL);
             resolver.registerContentObserver(LineageSettings.System.getUriFor(
                     LineageSettings.System.HOME_WAKE_SCREEN), false, this,
                     UserHandle.USER_ALL);
@@ -2310,6 +2318,8 @@ public class PhoneWindowManager implements WindowManagerPolicy {
         mAppSwitchLongPressAction = Action.fromIntSafe(res.getInteger(
                 org.lineageos.platform.internal.R.integer.config_longPressOnAppSwitchBehavior));
 
+        mEdgeLongSwipeAction = Action.NOTHING;
+
         mHomeLongPressAction = Action.fromIntSafe(res.getInteger(
                 org.lineageos.platform.internal.R.integer.config_longPressOnHomeBehavior));
         if (mHomeLongPressAction.ordinal() > Action.SLEEP.ordinal()) {
@@ -2354,6 +2364,10 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                 LineageSettings.System.KEY_APP_SWITCH_LONG_PRESS_ACTION,
                 mAppSwitchLongPressAction);
 
+        mEdgeLongSwipeAction = Action.fromSettings(resolver,
+                LineageSettings.System.KEY_EDGE_LONG_SWIPE_ACTION,
+                mEdgeLongSwipeAction);
+
         mShortPressOnWindowBehavior = SHORT_PRESS_WINDOW_NOTHING;
         if (mContext.getPackageManager().hasSystemFeature(FEATURE_PICTURE_IN_PICTURE)) {
             mShortPressOnWindowBehavior = SHORT_PRESS_WINDOW_PICTURE_IN_PICTURE;
@@ -4311,6 +4325,23 @@ public class PhoneWindowManager implements WindowManagerPolicy {
         // Handle special keys.
         switch (keyCode) {
             case KeyEvent.KEYCODE_BACK: {
+                boolean isLongSwipe = (event.getFlags() & LONG_SWIPE_FLAGS) == LONG_SWIPE_FLAGS;
+                if (mLongSwipeDown && isLongSwipe && !down) {
+                    // Trigger long swipe action
+                    performKeyAction(mEdgeLongSwipeAction, event);
+                    // Reset long swipe state
+                    mLongSwipeDown = false;
+                    // Don't pass back press to app
+                    result &= ~ACTION_PASS_TO_USER;
+                    break;
+                }
+                mLongSwipeDown = isLongSwipe && down;
+                if (mLongSwipeDown) {
+                    // Don't pass back press to app
+                    result &= ~ACTION_PASS_TO_USER;
+                    break;
+                }
+
                 if (down) {
                     interceptBackKeyDown();
                 } else {
",31,0,"PhoneWindowManager::interceptKeyBeforeQueueing, PhoneWindowManager::SettingsObserver::observe, PhoneWindowManager::updateKeyAssignments"
9,b18c28dfc7a52c8e459956381ac9de54040a0937,BatteryStatsImpl.java,ModificationType.MODIFY,"@@ -5417,7 +5417,7 @@ public class BatteryStatsImpl extends BatteryStats {
         if (mVideoOnNesting > 0) {
             final long elapsedRealtime = mClocks.elapsedRealtime();
             final long uptime = mClocks.uptimeMillis();
-            mAudioOnNesting = 0;
+            mVideoOnNesting = 0;
             mHistoryCur.states2 &= ~HistoryItem.STATE2_VIDEO_ON_FLAG;
             if (DEBUG_HISTORY) Slog.v(TAG, ""Video off to: ""
                     + Integer.toHexString(mHistoryCur.states));
",1,1,BatteryStatsImpl::noteResetVideoLocked
10,eb9da316198f93c04f564ebc90defac2c857aa04,Visualizer.java,ModificationType.MODIFY,"@@ -20,9 +20,10 @@ import android.annotation.UnsupportedAppUsage;
 import android.app.ActivityThread;
 import android.os.Handler;
 import android.os.Looper;
-import android.os.Message;
 import android.util.Log;
 
+import com.android.internal.annotations.GuardedBy;
+
 import java.lang.ref.WeakReference;
 
 /**
@@ -158,6 +159,7 @@ public class Visualizer {
     /**
      * Indicates the state of the Visualizer instance
      */
+    @GuardedBy(""mStateLock"")
     private int mState = STATE_UNINITIALIZED;
     /**
      * Lock to synchronize access to mState
@@ -166,6 +168,7 @@ public class Visualizer {
     /**
      * System wide unique Identifier of the visualizer engine used by this Visualizer instance
      */
+    @GuardedBy(""mStateLock"")
     @UnsupportedAppUsage
     private int mId;
 
@@ -176,19 +179,24 @@ public class Visualizer {
     /**
      * Handler for events coming from the native code
      */
-    private NativeEventHandler mNativeEventHandler = null;
+    @GuardedBy(""mListenerLock"")
+    private Handler mNativeEventHandler = null;
     /**
      *  PCM and FFT capture listener registered by client
      */
+    @GuardedBy(""mListenerLock"")
     private OnDataCaptureListener mCaptureListener = null;
     /**
      *  Server Died listener registered by client
      */
+    @GuardedBy(""mListenerLock"")
     private OnServerDiedListener mServerDiedListener = null;
 
     // accessed by native methods
-    private long mNativeVisualizer;
-    private long mJniData;
+    private long mNativeVisualizer;  // guarded by a static lock in native code
+    private long mJniData;  // set in native_setup, _release;
+                            // get in native_release, _setEnabled, _setPeriodicCapture
+                            // thus, effectively guarded by mStateLock
 
     //--------------------------------------------------------------------------
     // Constructor, Finalize
@@ -244,7 +252,9 @@ public class Visualizer {
 
     @Override
     protected void finalize() {
-        native_finalize();
+        synchronized (mStateLock) {
+            native_finalize();
+        }
     }
 
     /**
@@ -601,25 +611,28 @@ public class Visualizer {
      */
     public int setDataCaptureListener(OnDataCaptureListener listener,
             int rate, boolean waveform, boolean fft) {
-        synchronized (mListenerLock) {
-            mCaptureListener = listener;
-        }
         if (listener == null) {
             // make sure capture callback is stopped in native code
             waveform = false;
             fft = false;
         }
-        int status = native_setPeriodicCapture(rate, waveform, fft);
+        int status;
+        synchronized (mStateLock) {
+            status = native_setPeriodicCapture(rate, waveform, fft);
+        }
         if (status == SUCCESS) {
-            if ((listener != null) && (mNativeEventHandler == null)) {
-                Looper looper;
-                if ((looper = Looper.myLooper()) != null) {
-                    mNativeEventHandler = new NativeEventHandler(this, looper);
-                } else if ((looper = Looper.getMainLooper()) != null) {
-                    mNativeEventHandler = new NativeEventHandler(this, looper);
-                } else {
-                    mNativeEventHandler = null;
-                    status = ERROR_NO_INIT;
+            synchronized (mListenerLock) {
+                mCaptureListener = listener;
+                if ((listener != null) && (mNativeEventHandler == null)) {
+                    Looper looper;
+                    if ((looper = Looper.myLooper()) != null) {
+                        mNativeEventHandler = new Handler(looper);
+                    } else if ((looper = Looper.getMainLooper()) != null) {
+                        mNativeEventHandler = new Handler(looper);
+                    } else {
+                        mNativeEventHandler = null;
+                        status = ERROR_NO_INIT;
+                    }
                 }
             }
         }
@@ -663,112 +676,61 @@ public class Visualizer {
         return SUCCESS;
     }
 
-    /**
-     * Helper class to handle the forwarding of native events to the appropriate listeners
-     */
-    private class NativeEventHandler extends Handler
-    {
-        private Visualizer mVisualizer;
-
-        public NativeEventHandler(Visualizer v, Looper looper) {
-            super(looper);
-            mVisualizer = v;
-        }
-
-        private void handleCaptureMessage(Message msg) {
-            OnDataCaptureListener l = null;
-            synchronized (mListenerLock) {
-                l = mVisualizer.mCaptureListener;
-            }
-
-            if (l != null) {
-                byte[] data = (byte[])msg.obj;
-                int samplingRate = msg.arg1;
-
-                switch(msg.what) {
-                case NATIVE_EVENT_PCM_CAPTURE:
-                    l.onWaveFormDataCapture(mVisualizer, data, samplingRate);
-                    break;
-                case NATIVE_EVENT_FFT_CAPTURE:
-                    l.onFftDataCapture(mVisualizer, data, samplingRate);
-                    break;
-                default:
-                    Log.e(TAG,""Unknown native event in handleCaptureMessge: ""+msg.what);
-                    break;
-                }
-            }
-        }
-
-        private void handleServerDiedMessage(Message msg) {
-            OnServerDiedListener l = null;
-            synchronized (mListenerLock) {
-                l = mVisualizer.mServerDiedListener;
-            }
-
-            if (l != null)
-                l.onServerDied();
-        }
-
-        @Override
-        public void handleMessage(Message msg) {
-            if (mVisualizer == null) {
-                return;
-            }
-
-            switch(msg.what) {
-            case NATIVE_EVENT_PCM_CAPTURE:
-            case NATIVE_EVENT_FFT_CAPTURE:
-                handleCaptureMessage(msg);
-                break;
-            case NATIVE_EVENT_SERVER_DIED:
-                handleServerDiedMessage(msg);
-                break;
-            default:
-                Log.e(TAG,""Unknown native event: ""+msg.what);
-                break;
-            }
-        }
-    }
-
     //---------------------------------------------------------
     // Interface definitions
     //--------------------
 
     private static native final void native_init();
 
+    @GuardedBy(""mStateLock"")
     private native final int native_setup(Object audioeffect_this,
                                           int audioSession,
                                           int[] id,
                                           String opPackageName);
 
+    @GuardedBy(""mStateLock"")
     private native final void native_finalize();
 
+    @GuardedBy(""mStateLock"")
     private native final void native_release();
 
+    @GuardedBy(""mStateLock"")
     private native final int native_setEnabled(boolean enabled);
 
+    @GuardedBy(""mStateLock"")
     private native final boolean native_getEnabled();
 
+    @GuardedBy(""mStateLock"")
     private native final int native_setCaptureSize(int size);
 
+    @GuardedBy(""mStateLock"")
     private native final int native_getCaptureSize();
 
+    @GuardedBy(""mStateLock"")
     private native final int native_setScalingMode(int mode);
 
+    @GuardedBy(""mStateLock"")
     private native final int native_getScalingMode();
 
+    @GuardedBy(""mStateLock"")
     private native final int native_setMeasurementMode(int mode);
 
+    @GuardedBy(""mStateLock"")
     private native final int native_getMeasurementMode();
 
+    @GuardedBy(""mStateLock"")
     private native final int native_getSamplingRate();
 
+    @GuardedBy(""mStateLock"")
     private native final int native_getWaveForm(byte[] waveform);
 
+    @GuardedBy(""mStateLock"")
     private native final int native_getFft(byte[] fft);
 
+    @GuardedBy(""mStateLock"")
     private native final int native_getPeakRms(MeasurementPeakRms measurement);
 
+    @GuardedBy(""mStateLock"")
     private native final int native_setPeriodicCapture(int rate, boolean waveForm, boolean fft);
 
     //---------------------------------------------------------
@@ -776,17 +738,47 @@ public class Visualizer {
     //--------------------
     @SuppressWarnings(""unused"")
     private static void postEventFromNative(Object effect_ref,
-            int what, int arg1, int arg2, Object obj) {
-        Visualizer visu = (Visualizer)((WeakReference)effect_ref).get();
-        if (visu == null) {
-            return;
-        }
+            int what, int samplingRate, byte[] data) {
+        final Visualizer visualizer = (Visualizer) ((WeakReference) effect_ref).get();
+        if (visualizer == null) return;
 
-        if (visu.mNativeEventHandler != null) {
-            Message m = visu.mNativeEventHandler.obtainMessage(what, arg1, arg2, obj);
-            visu.mNativeEventHandler.sendMessage(m);
+        final Handler handler;
+        synchronized (visualizer.mListenerLock) {
+            handler = visualizer.mNativeEventHandler;
         }
+        if (handler == null) return;
 
+        switch (what) {
+            case NATIVE_EVENT_PCM_CAPTURE:
+            case NATIVE_EVENT_FFT_CAPTURE:
+                handler.post(() -> {
+                    final OnDataCaptureListener l;
+                    synchronized (visualizer.mListenerLock) {
+                        l = visualizer.mCaptureListener;
+                    }
+                    if (l != null) {
+                        if (what == NATIVE_EVENT_PCM_CAPTURE) {
+                            l.onWaveFormDataCapture(visualizer, data, samplingRate);
+                        } else { // what == NATIVE_EVENT_FFT_CAPTURE
+                            l.onFftDataCapture(visualizer, data, samplingRate);
+                        }
+                    }
+                });
+                break;
+            case NATIVE_EVENT_SERVER_DIED:
+                handler.post(() -> {
+                    final OnServerDiedListener l;
+                    synchronized (visualizer.mListenerLock) {
+                        l = visualizer.mServerDiedListener;
+                    }
+                    if (l != null) {
+                        l.onServerDied();
+                    }
+                });
+                break;
+            default:
+                Log.e(TAG, ""Unknown native event in postEventFromNative: "" + what);
+                break;
+        }
     }
 }
-
",86,94,"Visualizer::postEventFromNative, Visualizer::NativeEventHandler::NativeEventHandler, Visualizer::NativeEventHandler::handleMessage, Visualizer::postEventFromNative, Visualizer::finalize, Visualizer::setDataCaptureListener, Visualizer::NativeEventHandler::handleServerDiedMessage, Visualizer::NativeEventHandler::handleCaptureMessage"
11,a4c2978ee15d607a219bddf11dd518f1dfec6dc4,DisplayContent.java,ModificationType.MODIFY,"@@ -343,7 +343,7 @@ class DisplayContent extends WindowContainer<DisplayContent.DisplayChildWindowCo
      */
     final DisplayMetrics mRealDisplayMetrics = new DisplayMetrics();
 
-    /** @see #computeCompatSmallestWidth(boolean, int, int, int, DisplayCutout) */
+    /** @see #computeCompatSmallestWidth(boolean, int, int, int) */
     private final DisplayMetrics mTmpDisplayMetrics = new DisplayMetrics();
 
     /**
@@ -1715,7 +1715,7 @@ class DisplayContent extends WindowContainer<DisplayContent.DisplayChildWindowCo
         config.compatScreenWidthDp = (int)(config.screenWidthDp / mCompatibleScreenScale);
         config.compatScreenHeightDp = (int)(config.screenHeightDp / mCompatibleScreenScale);
         config.compatSmallestScreenWidthDp = computeCompatSmallestWidth(rotated, config.uiMode, dw,
-                dh, displayInfo.displayCutout);
+                dh);
         config.densityDpi = displayInfo.logicalDensityDpi;
 
         config.colorMode =
@@ -1800,8 +1800,7 @@ class DisplayContent extends WindowContainer<DisplayContent.DisplayChildWindowCo
         mWmService.mPolicy.adjustConfigurationLw(config, keyboardPresence, navigationPresence);
     }
 
-    private int computeCompatSmallestWidth(boolean rotated, int uiMode, int dw, int dh,
-            DisplayCutout displayCutout) {
+    private int computeCompatSmallestWidth(boolean rotated, int uiMode, int dw, int dh) {
         mTmpDisplayMetrics.setTo(mDisplayMetrics);
         final DisplayMetrics tmpDm = mTmpDisplayMetrics;
         final int unrotDw, unrotDh;
@@ -1812,19 +1811,21 @@ class DisplayContent extends WindowContainer<DisplayContent.DisplayChildWindowCo
             unrotDw = dw;
             unrotDh = dh;
         }
-        int sw = reduceCompatConfigWidthSize(0, Surface.ROTATION_0, uiMode, tmpDm, unrotDw, unrotDh,
-                displayCutout);
-        sw = reduceCompatConfigWidthSize(sw, Surface.ROTATION_90, uiMode, tmpDm, unrotDh, unrotDw,
-                displayCutout);
-        sw = reduceCompatConfigWidthSize(sw, Surface.ROTATION_180, uiMode, tmpDm, unrotDw, unrotDh,
-                displayCutout);
-        sw = reduceCompatConfigWidthSize(sw, Surface.ROTATION_270, uiMode, tmpDm, unrotDh, unrotDw,
-                displayCutout);
+        int sw = reduceCompatConfigWidthSize(0, Surface.ROTATION_0, uiMode, tmpDm, unrotDw,
+                unrotDh);
+        sw = reduceCompatConfigWidthSize(sw, Surface.ROTATION_90, uiMode, tmpDm, unrotDh,
+                unrotDw);
+        sw = reduceCompatConfigWidthSize(sw, Surface.ROTATION_180, uiMode, tmpDm, unrotDw,
+                unrotDh);
+        sw = reduceCompatConfigWidthSize(sw, Surface.ROTATION_270, uiMode, tmpDm, unrotDh,
+                unrotDw);
         return sw;
     }
 
     private int reduceCompatConfigWidthSize(int curSize, int rotation, int uiMode,
-            DisplayMetrics dm, int dw, int dh, DisplayCutout displayCutout) {
+            DisplayMetrics dm, int dw, int dh) {
+        final DisplayCutout displayCutout = calculateDisplayCutoutForRotation(
+                rotation).getDisplayCutout();
         dm.noncompatWidthPixels = mDisplayPolicy.getNonDecorDisplayWidth(dw, dh, rotation, uiMode,
                 displayCutout);
         dm.noncompatHeightPixels = mDisplayPolicy.getNonDecorDisplayHeight(dw, dh, rotation, uiMode,
@@ -1865,20 +1866,20 @@ class DisplayContent extends WindowContainer<DisplayContent.DisplayChildWindowCo
             return;
         }
         int sl = Configuration.resetScreenLayout(outConfig.screenLayout);
-        sl = reduceConfigLayout(sl, Surface.ROTATION_0, density, unrotDw, unrotDh, uiMode,
-                displayInfo.displayCutout);
-        sl = reduceConfigLayout(sl, Surface.ROTATION_90, density, unrotDh, unrotDw, uiMode,
-                displayInfo.displayCutout);
-        sl = reduceConfigLayout(sl, Surface.ROTATION_180, density, unrotDw, unrotDh, uiMode,
-                displayInfo.displayCutout);
-        sl = reduceConfigLayout(sl, Surface.ROTATION_270, density, unrotDh, unrotDw, uiMode,
-                displayInfo.displayCutout);
+        sl = reduceConfigLayout(sl, Surface.ROTATION_0, density, unrotDw, unrotDh, uiMode);
+        sl = reduceConfigLayout(sl, Surface.ROTATION_90, density, unrotDh, unrotDw, uiMode);
+        sl = reduceConfigLayout(sl, Surface.ROTATION_180, density, unrotDw, unrotDh, uiMode);
+        sl = reduceConfigLayout(sl, Surface.ROTATION_270, density, unrotDh, unrotDw, uiMode);
         outConfig.smallestScreenWidthDp = (int)(displayInfo.smallestNominalAppWidth / density);
         outConfig.screenLayout = sl;
     }
 
     private int reduceConfigLayout(int curLayout, int rotation, float density, int dw, int dh,
-            int uiMode, DisplayCutout displayCutout) {
+            int uiMode) {
+        // Get the display cutout at this rotation.
+        final DisplayCutout displayCutout = calculateDisplayCutoutForRotation(
+                rotation).getDisplayCutout();
+
         // Get the app screen size at this rotation.
         int w = mDisplayPolicy.getNonDecorDisplayWidth(dw, dh, rotation, uiMode, displayCutout);
         int h = mDisplayPolicy.getNonDecorDisplayHeight(dw, dh, rotation, uiMode, displayCutout);
",23,22,"DisplayContent::computeSizeRangesAndScreenLayout, DisplayContent::computeCompatSmallestWidth, DisplayContent::reduceCompatConfigWidthSize, DisplayContent::computeScreenConfiguration, DisplayContent::reduceCompatConfigWidthSize, DisplayContent::reduceConfigLayout, DisplayContent::reduceConfigLayout, DisplayContent::computeCompatSmallestWidth"
12,49934cc6b26987129c1d2cd4ae03d37e2039c5aa,DiskInfo.java,ModificationType.MODIFY,"@@ -50,6 +50,8 @@ public class DiskInfo implements Parcelable {
     public static final int FLAG_DEFAULT_PRIMARY = 1 << 1;
     public static final int FLAG_SD = 1 << 2;
     public static final int FLAG_USB = 1 << 3;
+    public static final int FLAG_EMMC = 1 << 4;
+    public static final int FLAG_UFS_CARD = 1 << 5;
 
     public final String id;
     @UnsupportedAppUsage
",2,0,
13,49934cc6b26987129c1d2cd4ae03d37e2039c5aa,PackageManagerService.java,ModificationType.MODIFY,"@@ -22725,7 +22725,7 @@ public class PackageManagerService extends IPackageManager.Stub
         final UserManager um = mContext.getSystemService(UserManager.class);
         UserManagerInternal umInternal = getUserManagerInternal();
         for (UserInfo user : um.getUsers()) {
-            final int flags;
+            int flags = 0;
             if (umInternal.isUserUnlockingOrUnlocked(user.id)) {
                 flags = StorageManager.FLAG_STORAGE_DE | StorageManager.FLAG_STORAGE_CE;
             } else if (umInternal.isUserRunning(user.id)) {
@@ -22733,9 +22733,12 @@ public class PackageManagerService extends IPackageManager.Stub
             } else {
                 continue;
             }
-
+            if ((vol.disk.flags & DiskInfo.FLAG_UFS_CARD) == DiskInfo.FLAG_UFS_CARD) {
+                flags = flags | DiskInfo.FLAG_UFS_CARD;
+            }
+            final int pflags = flags;
             try {
-                sm.prepareUserStorage(volumeUuid, user.id, user.serialNumber, flags);
+                sm.prepareUserStorage(volumeUuid, user.id, user.serialNumber, pflags);
                 synchronized (mInstallLock) {
                     reconcileAppsDataLI(volumeUuid, user.id, flags, true /* migrateAppData */);
                 }
",6,3,PackageManagerService::loadPrivatePackagesInner
14,2bca0d50c0551de775f94432e5d07e1822e52923,MediaMetadataRetriever.java,ModificationType.MODIFY,"@@ -800,7 +800,7 @@ public class MediaMetadataRetriever implements AutoCloseable {
      */
     public static final int METADATA_KEY_YEAR            = 8;
     /**
-     * The metadata key to retrieve the playback duration of the data source.
+     * The metadata key to retrieve the playback duration (in ms) of the data source.
      */
     public static final int METADATA_KEY_DURATION        = 9;
     /**
",1,1,
15,2bca0d50c0551de775f94432e5d07e1822e52923,ThumbnailUtils.java,ModificationType.MODIFY,"@@ -356,19 +356,21 @@ public class ThumbnailUtils {
                 return ImageDecoder.decodeBitmap(ImageDecoder.createSource(raw), resizer);
             }
 
-            // Fall back to middle of video
             final int width = Integer.parseInt(mmr.extractMetadata(METADATA_KEY_VIDEO_WIDTH));
             final int height = Integer.parseInt(mmr.extractMetadata(METADATA_KEY_VIDEO_HEIGHT));
-            final long duration = Long.parseLong(mmr.extractMetadata(METADATA_KEY_DURATION));
+            // Fall back to middle of video
+            // Note: METADATA_KEY_DURATION unit is in ms, not us.
+            final long thumbnailTimeUs =
+                    Long.parseLong(mmr.extractMetadata(METADATA_KEY_DURATION)) * 1000 / 2;
 
             // If we're okay with something larger than native format, just
             // return a frame without up-scaling it
             if (size.getWidth() > width && size.getHeight() > height) {
                 return Objects.requireNonNull(
-                        mmr.getFrameAtTime(duration / 2, OPTION_CLOSEST_SYNC));
+                        mmr.getFrameAtTime(thumbnailTimeUs, OPTION_CLOSEST_SYNC));
             } else {
                 return Objects.requireNonNull(
-                        mmr.getScaledFrameAtTime(duration / 2, OPTION_CLOSEST_SYNC,
+                        mmr.getScaledFrameAtTime(thumbnailTimeUs, OPTION_CLOSEST_SYNC,
                         size.getWidth(), size.getHeight()));
             }
         } catch (RuntimeException e) {
",6,4,ThumbnailUtils::createVideoThumbnail
16,5523940d7c2c630fd21af4ae1c11c2e3a165e9bf,TokenCache.java,ModificationType.MODIFY,"@@ -148,7 +148,7 @@ import java.util.Objects;
                 accountEvictor = new Evictor();
             }
             accountEvictor.add(k);
-            mAccountEvictors.put(k.account, tokenEvictor);
+            mAccountEvictors.put(k.account, accountEvictor);
 
             // Only cache the token once we can remove it directly or by account.
             put(k, v);
",1,1,TokenCache::TokenLruCache::putToken
17,0c8853114de7dfb1921fc183857a341b40c4b20e,ZenModeHelper.java,ModificationType.MODIFY,"@@ -844,13 +844,13 @@ public class ZenModeHelper {
             final boolean policyChanged = !Objects.equals(getNotificationPolicy(mConfig),
                     getNotificationPolicy(config));
             if (!config.equals(mConfig)) {
+                mConfig = config;
                 dispatchOnConfigChanged();
                 updateConsolidatedPolicy(reason);
             }
             if (policyChanged) {
                 dispatchOnPolicyChanged();
             }
-            mConfig = config;
             mHandler.postApplyConfig(config, reason, triggeringComponent, setRingerMode);
             return true;
         } catch (SecurityException e) {
",1,1,ZenModeHelper::setConfigLocked
18,dc6f3b25921c9f1055d5786cdf74359e436ec402,GlobalKeyManager.java,ModificationType.MODIFY,"@@ -74,7 +74,7 @@ final class GlobalKeyManager {
                 Intent intent = new Intent(Intent.ACTION_GLOBAL_BUTTON)
                         .setComponent(component)
                         .setFlags(Intent.FLAG_RECEIVER_FOREGROUND)
-                        .putExtra(Intent.EXTRA_KEY_EVENT, event);
+                        .putExtra(Intent.EXTRA_KEY_EVENT, new KeyEvent(event));
                 context.sendBroadcastAsUser(intent, UserHandle.CURRENT, null);
                 return true;
             }
",1,1,GlobalKeyManager::handleGlobalKey
19,4f91f5ea5c34073866cc01d280de96e77db92088,LoadedApk.java,ModificationType.MODIFY,"@@ -784,6 +784,11 @@ public final class LoadedApk {
         makePaths(mActivityThread, isBundledApp, mApplicationInfo, zipPaths, libPaths);
 
         String libraryPermittedPath = mDataDir;
+        if (mActivityThread == null) {
+            // In a zygote context where mActivityThread is null we can't access the app data dir
+            // and including this in libraryPermittedPath would cause SELinux denials.
+            libraryPermittedPath = """";
+        }
 
         if (isBundledApp) {
             // For bundled apps, add the base directory of the app (e.g.,
",5,0,LoadedApk::createOrUpdateClassLoaderLocked
20,2a66020b1ba671454c45ed04ff7e252466470caa,BatteryStatsImpl.java,ModificationType.MODIFY,"@@ -4753,11 +4753,11 @@ public class BatteryStatsImpl extends BatteryStats {
             final long uptime = mClocks.uptimeMillis();
 
             boolean updateHistory = false;
-            if (isScreenDoze(state)) {
+            if (isScreenDoze(state) && !isScreenDoze(oldState)) {
                 mHistoryCur.states |= HistoryItem.STATE_SCREEN_DOZE_FLAG;
                 mScreenDozeTimer.startRunningLocked(elapsedRealtime);
                 updateHistory = true;
-            } else if (isScreenDoze(oldState)) {
+            } else if (isScreenDoze(oldState) && !isScreenDoze(state)) {
                 mHistoryCur.states &= ~HistoryItem.STATE_SCREEN_DOZE_FLAG;
                 mScreenDozeTimer.stopRunningLocked(elapsedRealtime);
                 updateHistory = true;
",2,2,BatteryStatsImpl::noteScreenStateLocked
21,46eb98913b4a1b7fd7ae24ed828cdc19069db0e9,SettingsStringUtil.java,ModificationType.MODIFY,"@@ -126,7 +126,7 @@ public class SettingsStringUtil {
 
         @Override
         protected String itemToString(ComponentName item) {
-            return item.flattenToString();
+            return item != null ? item.flattenToString() : ""null"";
         }
 
         public static String add(String delimitedElements, ComponentName element) {
",1,1,SettingsStringUtil::ComponentNameSet::itemToString
22,46eb98913b4a1b7fd7ae24ed828cdc19069db0e9,AccessibilityManagerService.java,ModificationType.MODIFY,"@@ -82,8 +82,6 @@ import android.os.UserHandle;
 import android.os.UserManager;
 import android.os.UserManagerInternal;
 import android.provider.Settings;
-import android.provider.SettingsStringUtil;
-import android.provider.SettingsStringUtil.ComponentNameSet;
 import android.provider.SettingsStringUtil.SettingStringHelper;
 import android.text.TextUtils;
 import android.text.TextUtils.SimpleStringSplitter;
@@ -2440,12 +2438,12 @@ public class AccessibilityManagerService extends IAccessibilityManager.Stub
      * Enables accessibility service specified by {@param componentName} for the {@param userId}.
      */
     private void enableAccessibilityServiceLocked(ComponentName componentName, int userId) {
-        final SettingStringHelper setting =
-                new SettingStringHelper(
-                        mContext.getContentResolver(),
-                        Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES,
-                        userId);
-        setting.write(ComponentNameSet.add(setting.read(), componentName));
+        mTempComponentNameSet.clear();
+        readComponentNamesFromSettingLocked(Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES,
+                userId, mTempComponentNameSet);
+        mTempComponentNameSet.add(componentName);
+        persistComponentNamesToSettingLocked(Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES,
+                mTempComponentNameSet, userId);
 
         UserState userState = getUserStateLocked(userId);
         if (userState.mEnabledServices.add(componentName)) {
@@ -2457,12 +2455,12 @@ public class AccessibilityManagerService extends IAccessibilityManager.Stub
      * Disables accessibility service specified by {@param componentName} for the {@param userId}.
      */
     private void disableAccessibilityServiceLocked(ComponentName componentName, int userId) {
-        final SettingsStringUtil.SettingStringHelper setting =
-                new SettingStringHelper(
-                        mContext.getContentResolver(),
-                        Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES,
-                        userId);
-        setting.write(ComponentNameSet.remove(setting.read(), componentName));
+        mTempComponentNameSet.clear();
+        readComponentNamesFromSettingLocked(Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES,
+                userId, mTempComponentNameSet);
+        mTempComponentNameSet.remove(componentName);
+        persistComponentNamesToSettingLocked(Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES,
+                mTempComponentNameSet, userId);
 
         UserState userState = getUserStateLocked(userId);
         if (userState.mEnabledServices.remove(componentName)) {
",12,14,"AccessibilityManagerService::enableAccessibilityServiceLocked, AccessibilityManagerService::disableAccessibilityServiceLocked"
23,93796da5ab8e32bf3efb19cf49a72659ae68d01b,AudioService.java,ModificationType.MODIFY,"@@ -6607,7 +6607,7 @@ public class AudioService extends IAudioService.Stub
                 return false;
             }
             boolean suppress = false;
-            if (resolvedStream == DEFAULT_VOL_STREAM_NO_PLAYBACK && mController != null) {
+            if (resolvedStream != AudioSystem.STREAM_MUSIC && mController != null) {
                 final long now = SystemClock.uptimeMillis();
                 if ((flags & AudioManager.FLAG_SHOW_UI) != 0 && !mVisible) {
                     // ui will become visible
",1,1,AudioService::VolumeController::suppressAdjustment
24,7c2677486c5520feaab48ebe63f95bb9d8b91183,DisplayPolicy.java,ModificationType.MODIFY,"@@ -624,6 +624,9 @@ public class DisplayPolicy {
             } else if (""0"".equals(navBarOverride)) {
                 mHasNavigationBar = true;
             }
+
+            // Register content observer only for main display
+            mSettingsObserver = new SettingsObserver(mHandler);
         } else {
             mHasStatusBar = false;
             mHasNavigationBar = mDisplayContent.supportsSystemDecorations();
@@ -632,8 +635,6 @@ public class DisplayPolicy {
         mRefreshRatePolicy = new RefreshRatePolicy(mService,
                 mDisplayContent.getDisplayInfo(),
                 mService.mHighRefreshRateBlacklist);
-
-        mSettingsObserver = new SettingsObserver(mHandler);
     }
 
     void systemReady() {
",3,2,DisplayPolicy::DisplayPolicy
25,126092da2761bb6f3857d990acb2a5a07b312984,AudioSystem.java,ModificationType.MODIFY,"@@ -1077,6 +1077,12 @@ public class AudioSystem
      */
     public static native boolean isHapticPlaybackSupported();
 
+    /**
+     * Send audio HAL server process pids to native audioserver process for use
+     * when generating audio HAL servers tombstones
+     */
+    public static native int setAudioHalPids(int[] pids);
+
     // Items shared with audio service
 
     /**
",6,0,
26,126092da2761bb6f3857d990acb2a5a07b312984,AudioService.java,ModificationType.MODIFY,"@@ -62,6 +62,7 @@ import android.hardware.hdmi.HdmiControlManager;
 import android.hardware.hdmi.HdmiPlaybackClient;
 import android.hardware.hdmi.HdmiTvClient;
 import android.hardware.usb.UsbManager;
+import android.hidl.manager.V1_0.IServiceManager;
 import android.media.AudioAttributes;
 import android.media.AudioFocusInfo;
 import android.media.AudioFocusRequest;
@@ -158,10 +159,12 @@ import java.lang.reflect.Field;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
+import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.NoSuchElementException;
 import java.util.Objects;
+import java.util.Set;
 import java.util.concurrent.Executor;
 import java.util.concurrent.atomic.AtomicBoolean;
 
@@ -751,6 +754,8 @@ public class AudioService extends IAudioService.Stub
 
         AudioSystem.setErrorCallback(mAudioSystemCallback);
 
+        updateAudioHalPids();
+
         boolean cameraSoundForced = readCameraSoundForced();
         mCameraSoundForced = new Boolean(cameraSoundForced);
         sendMsg(mAudioHandler,
@@ -977,6 +982,8 @@ public class AudioService extends IAudioService.Stub
         }
         Log.e(TAG, ""Audioserver started."");
 
+        updateAudioHalPids();
+
         // indicate to audio HAL that we start the reconfiguration phase after a media
         // server crash
         // Note that we only execute this when the media server
@@ -7628,6 +7635,41 @@ public class AudioService extends IAudioService.Stub
         return (AudioSystem.checkAudioFlinger() == AudioSystem.AUDIO_STATUS_OK);
     }
 
+    //======================
+    // Audio HAL process dump
+    //======================
+
+    private static final String AUDIO_HAL_SERVICE_PREFIX = ""android.hardware.audio"";
+
+    private Set<Integer> getAudioHalPids() {
+        try {
+            IServiceManager serviceManager = IServiceManager.getService();
+            ArrayList<IServiceManager.InstanceDebugInfo> dump =
+                    serviceManager.debugDump();
+            HashSet<Integer> pids = new HashSet<>();
+            for (IServiceManager.InstanceDebugInfo info : dump) {
+                if (info.pid != IServiceManager.PidConstant.NO_PID
+                        && info.interfaceName != null
+                        && info.interfaceName.startsWith(AUDIO_HAL_SERVICE_PREFIX)) {
+                    pids.add(info.pid);
+                }
+            }
+            return pids;
+        } catch (RemoteException e) {
+            return new HashSet<Integer>();
+        }
+    }
+
+    private void updateAudioHalPids() {
+        Set<Integer> pidsSet = getAudioHalPids();
+        if (pidsSet.isEmpty()) {
+            Slog.w(TAG, ""Could not retrieve audio HAL service pids"");
+            return;
+        }
+        int[] pidsArray = pidsSet.stream().mapToInt(Integer::intValue).toArray();
+        AudioSystem.setAudioHalPids(pidsArray);
+    }
+
     //======================
     // misc
     //======================
",42,0,"AudioService::onAudioServerDied, AudioService::getAudioHalPids, AudioService::updateAudioHalPids, AudioService::AudioService"
27,804ed1c7d445dbcf3289ddee8bc1c69ac78d3af5,EdgeBackGestureHandler.java,ModificationType.MODIFY,"@@ -78,7 +78,7 @@ public class EdgeBackGestureHandler implements DisplayListener, TunerService.Tun
     private static final int MAX_LONG_PRESS_TIMEOUT = SystemProperties.getInt(
             ""gestures.back_timeout"", 250);
 
-    private static final String KEY_EDGE_LONG_SWIPE_ACTION =
+    public static final String KEY_EDGE_LONG_SWIPE_ACTION =
             ""lineagesystem:"" + LineageSettings.System.KEY_EDGE_LONG_SWIPE_ACTION;
 
     private final IPinnedStackListener.Stub mImeChangedListener = new IPinnedStackListener.Stub() {
",1,1,
28,804ed1c7d445dbcf3289ddee8bc1c69ac78d3af5,TunerServiceImpl.java,ModificationType.MODIFY,"@@ -40,6 +40,7 @@ import com.android.systemui.DemoMode;
 import com.android.systemui.qs.QSTileHost;
 import com.android.systemui.settings.CurrentUserTracker;
 import com.android.systemui.statusbar.phone.ClockController;
+import com.android.systemui.statusbar.phone.EdgeBackGestureHandler;
 import com.android.systemui.statusbar.phone.NavigationBarView;
 import com.android.systemui.statusbar.phone.NotificationPanelView;
 import com.android.systemui.statusbar.phone.StatusBarIconController;
@@ -74,6 +75,7 @@ public class TunerServiceImpl extends TunerService {
             BatteryMeterView.STATUS_BAR_BATTERY_STYLE,
             Clock.CLOCK_STYLE,
             ClockController.CLOCK_POSITION,
+            EdgeBackGestureHandler.KEY_EDGE_LONG_SWIPE_ACTION,
             NavigationBarView.NAVIGATION_BAR_MENU_ARROW_KEYS,
             NotificationPanelView.DOUBLE_TAP_SLEEP_GESTURE,
             NotificationPanelView.STATUS_BAR_QUICK_QS_PULLDOWN,
",2,0,
29,03a8f7ac30443939ff01345ba8b034b14bd01a71,FODCircleView.java,ModificationType.MODIFY,"@@ -321,6 +321,8 @@ public class FODCircleView extends ImageView {
 
         mIsShowing = true;
 
+        updatePosition();
+
         dispatchShow();
         setVisibility(View.VISIBLE);
     }
",2,0,FODCircleView::show
30,c6a7585c84e853d8775aacb3c3f6f5b7d959b6d3,HandlerThread.java,ModificationType.MODIFY,"@@ -71,23 +71,35 @@ public class HandlerThread extends Thread {
     /**
      * This method returns the Looper associated with this thread. If this thread not been started
      * or for any reason isAlive() returns false, this method will return null. If this thread
-     * has been started, this method will block until the looper has been initialized.  
+     * has been started, this method will block until the looper has been initialized.
      * @return The looper.
      */
     public Looper getLooper() {
         if (!isAlive()) {
             return null;
         }
-        
+
+        boolean wasInterrupted = false;
+
         // If the thread has been started, wait until the looper has been created.
         synchronized (this) {
             while (isAlive() && mLooper == null) {
                 try {
                     wait();
                 } catch (InterruptedException e) {
+                    wasInterrupted = true;
                 }
             }
         }
+
+        /*
+         * We may need to restore the thread's interrupted flag, because it may
+         * have been cleared above since we eat InterruptedExceptions
+         */
+        if (wasInterrupted) {
+            Thread.currentThread().interrupt();
+        }
+
         return mLooper;
     }
 
",14,2,HandlerThread::getLooper
31,f75b3a3aa7cd3be209957d1593f80da00a554576,NotificationMediaManager.java,ModificationType.MODIFY,"@@ -534,7 +534,7 @@ public class NotificationMediaManager implements Dumpable, TunerService.Tunable
     private void finishUpdateMediaMetaData(boolean metaDataChanged, boolean allowEnterAnimation,
             @Nullable Bitmap bmp) {
         Drawable artworkDrawable = null;
-        if (bmp != null) {
+        if (bmp != null && (mShowMediaMetadata || !ENABLE_LOCKSCREEN_WALLPAPER)) {
             artworkDrawable = new BitmapDrawable(mBackdropBack.getResources(), bmp);
         }
         boolean hasMediaArtwork = artworkDrawable != null;
@@ -555,7 +555,7 @@ public class NotificationMediaManager implements Dumpable, TunerService.Tunable
         StatusBarWindowController windowController = mStatusBarWindowController.get();
         boolean hideBecauseOccluded = shadeController != null && shadeController.isOccluded();
 
-        final boolean hasArtwork = mShowMediaMetadata && artworkDrawable != null;
+        final boolean hasArtwork = artworkDrawable != null;
         mColorExtractor.setHasMediaArtwork(hasMediaArtwork);
         if (mScrimController != null) {
             mScrimController.setHasBackdrop(hasArtwork);
",2,2,NotificationMediaManager::finishUpdateMediaMetaData
32,27bc8293363e16323bfb3548433bd700319f4f08,KeyguardIndicationController.java,ModificationType.MODIFY,"@@ -428,14 +428,7 @@ public class KeyguardIndicationController implements StateListener,
                 mTextView.switchIndication(com.android.internal.R.string.lockscreen_storage_locked);
                 mTextView.setTextColor(mInitialTextColorState);
             } else if (!TextUtils.isEmpty(mTransientIndication)) {
-                if (powerIndication != null) {
-                    String indication = mContext.getResources().getString(
-                            R.string.keyguard_indication_trust_unlocked_plugged_in,
-                            mTransientIndication, powerIndication);
-                    mTextView.switchIndication(indication);
-                } else {
-                    mTextView.switchIndication(mTransientIndication);
-                }
+                mTextView.switchIndication(mTransientIndication);
                 mTextView.setTextColor(mTransientTextColorState);
             } else if (!TextUtils.isEmpty(trustGrantedIndication)
                     && mKeyguardUpdateMonitor.getUserHasTrust(userId)) {
",1,8,KeyguardIndicationController::updateIndication
33,a36beab2c139b2fad38f4bce3d04529ec3fa27fc,ActivityStackSupervisor.java,ModificationType.MODIFY,"@@ -1930,8 +1930,14 @@ public class ActivityStackSupervisor implements RecentTasks.Callbacks {
         if (wasTrimmed) {
             // Task was trimmed from the recent tasks list -- remove the active task record as well
             // since the user won't really be able to go back to it
-            removeTaskByIdLocked(task.taskId, killProcess, false /* removeFromRecents */,
+            boolean res = removeTaskByIdLocked(task.taskId, killProcess,
+                    false /* removeFromRecents */,
                     !PAUSE_IMMEDIATELY, ""recent-task-trimmed"");
+
+            // Notify task stack changes for the non-existent task
+            if (!res) {
+                mService.getTaskChangeNotificationController().notifyTaskStackChanged();
+            }
         }
         task.removedFromRecents();
     }
",7,1,ActivityStackSupervisor::onRecentTaskRemoved
34,aa8afca1a8229062a2b259d266d7ab11903e8593,DataSaverTile.java,ModificationType.MODIFY,"@@ -70,11 +70,13 @@ public class DataSaverTile extends QSTileImpl<BooleanState> implements
         dialog.setTitle(com.android.internal.R.string.data_saver_enable_title);
         dialog.setMessage(com.android.internal.R.string.data_saver_description);
         dialog.setPositiveButton(com.android.internal.R.string.data_saver_enable_button,
-                (OnClickListener) (dialogInterface, which) -> toggleDataSaver());
+                (OnClickListener) (dialogInterface, which) -> {
+                    toggleDataSaver();
+                    Prefs.putBoolean(mContext, Prefs.Key.QS_DATA_SAVER_DIALOG_SHOWN, true);
+                });
         dialog.setNegativeButton(com.android.internal.R.string.cancel, null);
         dialog.setShowForAllUsers(true);
         dialog.show();
-        Prefs.putBoolean(mContext, Prefs.Key.QS_DATA_SAVER_DIALOG_SHOWN, true);
     }
 
     private void toggleDataSaver() {
",4,2,DataSaverTile::handleClick
35,5c9d2e88f5977f98f342b71e6561d3b2433ddd6e,GlobalScreenshot.java,ModificationType.MODIFY,"@@ -85,6 +85,7 @@ import android.util.Slog;
 import android.view.Display;
 import android.view.LayoutInflater;
 import android.view.MotionEvent;
+import android.view.Surface;
 import android.view.SurfaceControl;
 import android.view.View;
 import android.view.ViewGroup;
@@ -814,6 +815,45 @@ class GlobalScreenshot {
         }
     }
 
+    Rect getRotationAdjustedRect(Rect rect) {
+        Display defaultDisplay = mWindowManager.getDefaultDisplay();
+        Rect adjustedRect = new Rect(rect);
+
+        mDisplay.getRealMetrics(mDisplayMetrics);
+        int rotation = defaultDisplay.getRotation();
+        switch (rotation) {
+            case Surface.ROTATION_0:
+                // properly rotated
+                break;
+            case Surface.ROTATION_90:
+                adjustedRect.top = mDisplayMetrics.heightPixels - rect.bottom;
+                adjustedRect.bottom = mDisplayMetrics.heightPixels - rect.top;
+                break;
+            case Surface.ROTATION_180:
+                adjustedRect.left = mDisplayMetrics.widthPixels - rect.right;
+                adjustedRect.top = mDisplayMetrics.heightPixels - rect.bottom;
+                adjustedRect.right = mDisplayMetrics.widthPixels - rect.left;
+                adjustedRect.bottom = mDisplayMetrics.heightPixels - rect.top;
+                break;
+            case Surface.ROTATION_270:
+                adjustedRect.left = mDisplayMetrics.widthPixels - rect.right;
+                adjustedRect.right = mDisplayMetrics.widthPixels - rect.left;
+                break;
+            default:
+                throw new IllegalArgumentException(""Unknown rotation: "" + rotation);
+        }
+
+        return adjustedRect;
+    }
+
+    void setLockedScreenOrientation(boolean locked) {
+        if (locked) {
+            mWindowLayoutParams.screenOrientation = ActivityInfo.SCREEN_ORIENTATION_LOCKED;
+        } else {
+            mWindowLayoutParams.screenOrientation = ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED;
+        }
+    }
+
     /**
      * Displays a screenshot selector
      */
@@ -825,6 +865,7 @@ class GlobalScreenshot {
         }
 
         setBlockedGesturalNavigation(true);
+        setLockedScreenOrientation(true);
         mWindowManager.addView(mScreenshotLayout, mWindowLayoutParams);
         mScreenshotSelectorView.setSelectionListener(
                 new ScreenshotSelectorView.OnSelectionListener() {
@@ -849,7 +890,8 @@ class GlobalScreenshot {
         mCaptureButton.setOnClickListener(new View.OnClickListener() {
             @Override
             public void onClick(View v) {
-                final Rect rect = mScreenshotSelectorView.getSelectionRect();
+                Rect rect = mScreenshotSelectorView.getSelectionRect();
+                final Rect adjustedRect = getRotationAdjustedRect(rect);
                 LayoutTransition layoutTransition = mScreenshotButtonsLayout.getLayoutTransition();
                 layoutTransition.addTransitionListener(new TransitionListener() {
                     @Override
@@ -860,7 +902,7 @@ class GlobalScreenshot {
                     @Override
                     public void endTransition(LayoutTransition transition, ViewGroup container,
                             View view, int transitionType) {
-                        takeScreenshot(finisher, statusBarVisible, navBarVisible, rect);
+                        takeScreenshot(finisher, statusBarVisible, navBarVisible, adjustedRect);
                         transition.removeTransitionListener(this);
                     }
                 });
@@ -874,6 +916,7 @@ class GlobalScreenshot {
     }
 
     void hideScreenshotSelector() {
+        setLockedScreenOrientation(false);
         mWindowManager.removeView(mScreenshotLayout);
         mScreenshotSelectorView.stopSelection();
         mScreenshotSelectorView.setVisibility(View.GONE);
@@ -886,12 +929,9 @@ class GlobalScreenshot {
      */
     void stopScreenshot() {
         // If the selector layer still presents on screen, we remove it and resets its state.
-        if (mScreenshotSelectorView.getSelectionRect() != null) {
-            mWindowManager.removeView(mScreenshotLayout);
-            mScreenshotSelectorView.stopSelection();
+        if (mScreenshotLayout.getParent() != null) {
+            hideScreenshotSelector();
         }
-
-        setBlockedGesturalNavigation(false);
     }
 
     /**
",47,7,"GlobalScreenshot::hideScreenshotSelector, GlobalScreenshot::stopScreenshot, GlobalScreenshot::getRotationAdjustedRect, GlobalScreenshot::takeScreenshotPartial, GlobalScreenshot::setLockedScreenOrientation"
36,ffefb88ce94d0343fbf6bc875879bf07f93afa54,BatteryMeterView.java,ModificationType.MODIFY,"@@ -408,8 +408,10 @@ public class BatteryMeterView extends LinearLayout implements
         final boolean showing = mBatteryPercentView != null;
         final int showBatteryPercent = LineageSettings.System.getIntForUser(
                 getContext().getContentResolver(), STATUS_BAR_SHOW_BATTERY_PERCENT, 0, mUser);
-        final boolean drawPercentInside = showBatteryPercent == 1;
-        final boolean drawPercentOnly = showBatteryPercent == 2;
+        final boolean drawPercentInside = mShowPercentMode == MODE_DEFAULT &&
+                showBatteryPercent == 1;
+        final boolean drawPercentOnly = mShowPercentMode == MODE_ESTIMATE ||
+                showBatteryPercent == 2;
         if (drawPercentOnly && (!drawPercentInside || mCharging) ||
                 mBatteryStyle == BATTERY_STYLE_TEXT) {
             mCircleDrawable.setShowPercent(false);
",4,2,BatteryMeterView::updateShowPercent
37,ffefb88ce94d0343fbf6bc875879bf07f93afa54,QuickStatusBarHeader.java,ModificationType.MODIFY,"@@ -249,7 +249,9 @@ public class QuickStatusBarHeader extends RelativeLayout implements
 
         // Tint for the battery icons are handled in setupHost()
         mBatteryRemainingIcon = findViewById(R.id.batteryRemainingIcon);
-
+        // QS will always show the estimate, and BatteryMeterView handles the case where
+        // it's unavailable or charging
+        mBatteryRemainingIcon.setPercentShowMode(BatteryMeterView.MODE_ESTIMATE);
         mRingerModeTextView.setSelected(true);
         mNextAlarmTextView.setSelected(true);
 
",3,1,QuickStatusBarHeader::onFinishInflate
38,54c58a5649b3d73fc89c068908cfe8215d8b0819,NetworkPolicyManager.java,ModificationType.MODIFY,"@@ -56,6 +56,12 @@ public class NetworkPolicyManager {
     public static final int POLICY_REJECT_METERED_BACKGROUND = 0x1;
     /** Allow metered network use in the background even when in data usage save mode. */
     public static final int POLICY_ALLOW_METERED_BACKGROUND = 0x4;
+    /** Reject network usage on cellular network */
+    public static final int POLICY_REJECT_ON_DATA = 0x10000;
+    /** Reject network usage on virtual private network */
+    public static final int POLICY_REJECT_ON_VPN = 0x20000;
+    /** Reject network usage on wifi network */
+    public static final int POLICY_REJECT_ON_WLAN = 0x8000;
 
     /*
      * Rules defining whether an uid has access to a network given its type (metered / non-metered).
",6,0,
39,54c58a5649b3d73fc89c068908cfe8215d8b0819,NetworkManagementService.java,ModificationType.MODIFY,"@@ -37,6 +37,7 @@ import static android.net.NetworkStats.STATS_PER_UID;
 import static android.net.NetworkStats.TAG_ALL;
 import static android.net.NetworkStats.TAG_NONE;
 import static android.net.TrafficStats.UID_TETHERING;
+import static android.system.OsConstants.ENETDOWN;
 
 import static com.android.server.NetworkManagementSocketTagger.PROP_QTAGUID_ENABLED;
 
@@ -53,8 +54,11 @@ import android.net.InterfaceConfiguration;
 import android.net.InterfaceConfigurationParcel;
 import android.net.IpPrefix;
 import android.net.LinkAddress;
+import android.net.LinkProperties;
 import android.net.Network;
+import android.net.NetworkCapabilities;
 import android.net.NetworkPolicyManager;
+import android.net.NetworkRequest;
 import android.net.NetworkStats;
 import android.net.NetworkUtils;
 import android.net.RouteInfo;
@@ -247,6 +251,51 @@ public class NetworkManagementService extends INetworkManagementService.Stub {
             new RemoteCallbackList<>();
     private boolean mNetworkActive;
 
+    /* map keys used by netd to keep per app interface restrictions
+     * separate for each use case.
+     */
+    private static final String RESTRICT_USECASE_DATA = ""data"";
+    private static final String RESTRICT_USECASE_VPN  = ""vpn"";
+    private static final String RESTRICT_USECASE_WLAN = ""wlan"";
+
+    // Helper class for managing per uid interface blacklists.
+    private static class RestrictIf {
+        // Use case string
+        public String useCase;
+        // Interface name
+        public String ifName;
+        // NetworkCapabilities transport type used for this blacklist
+        public int transport;
+        // Active uid blacklist
+        public SparseBooleanArray active;
+        // Desired uid blacklist changes
+        public SparseBooleanArray pending;
+
+        RestrictIf(String useCase, int transport) {
+            this.useCase = useCase;
+            this.ifName = null;
+            this.transport = transport;
+            this.active = new SparseBooleanArray();
+            this.pending = new SparseBooleanArray();
+        }
+    }
+
+    @GuardedBy(""mQuotaLock"")
+    private RestrictIf[] mRestrictIf = {
+            new RestrictIf(RESTRICT_USECASE_DATA, NetworkCapabilities.TRANSPORT_CELLULAR),
+            new RestrictIf(RESTRICT_USECASE_VPN, NetworkCapabilities.TRANSPORT_VPN),
+            new RestrictIf(RESTRICT_USECASE_WLAN, NetworkCapabilities.TRANSPORT_WIFI),
+    };
+
+    private RestrictIf getUseCaseRestrictIf(String useCase) {
+        for (RestrictIf restrictIf : mRestrictIf) {
+            if (restrictIf.useCase.equals(useCase)) {
+                return restrictIf;
+            }
+        }
+        throw new IllegalStateException(""Unknown interface restriction"");
+    }
+
     /**
      * Constructs a new NetworkManagementService instance
      *
@@ -292,6 +341,44 @@ public class NetworkManagementService extends INetworkManagementService.Stub {
     }
 
     public void systemReady() {
+        final ConnectivityManager mConnectivityManager =
+                mContext.getSystemService(ConnectivityManager.class);
+
+        final NetworkRequest.Builder builder = new NetworkRequest.Builder()
+                .removeCapability(NetworkCapabilities.NET_CAPABILITY_NOT_VPN);
+        for (RestrictIf restrictIf : mRestrictIf) {
+            builder.addTransportType(restrictIf.transport);
+        }
+        final NetworkRequest request = builder.build();
+
+        final ConnectivityManager.NetworkCallback mNetworkCallback =
+                new ConnectivityManager.NetworkCallback() {
+            @Override
+            public void onLinkPropertiesChanged(Network network, LinkProperties linkProperties) {
+                NetworkCapabilities nc = mConnectivityManager.getNetworkCapabilities(network);
+                RestrictIf matchedRestrictIf = null;
+                for (RestrictIf restrictIf : mRestrictIf) {
+                    if (nc.hasTransport(restrictIf.transport)) {
+                        matchedRestrictIf = restrictIf;
+                    }
+                }
+                if (matchedRestrictIf == null) {
+                    return;
+                }
+                final String iface = linkProperties.getInterfaceName();
+                if (TextUtils.isEmpty(iface)) {
+                    return;
+                }
+                // The post below requires final arguments so
+                final RestrictIf finalRestrictIf = matchedRestrictIf;
+                // Exit the callback ASAP and move further work onto daemon thread
+                mDaemonHandler.post(() ->
+                        updateAppOnInterfaceCallback(finalRestrictIf, iface));
+            }
+        };
+
+        mConnectivityManager.registerNetworkCallback(request, mNetworkCallback);
+
         if (DBG) {
             final long start = System.currentTimeMillis();
             prepareNativeDaemon();
@@ -1458,6 +1545,95 @@ public class NetworkManagementService extends INetworkManagementService.Stub {
         return stableRanges;
     }
 
+    private void updateAppOnInterfaceCallback(RestrictIf restrictIf, String newIface) {
+        synchronized (mQuotaLock) {
+            if (TextUtils.isEmpty(restrictIf.ifName)) {
+                restrictIf.ifName = newIface;
+            } else if (!restrictIf.ifName.equals(newIface)) { // interface name has changed
+                // Prevent new incoming requests colliding with an update in progress
+                for (int i = 0; i < restrictIf.active.size(); i++) {
+                    final int uid = restrictIf.active.keyAt(i);
+                    final boolean restrict = restrictIf.active.valueAt(i);
+                    // Only remove/readd if a restriction is currently in place
+                    if (!restrict) {
+                        continue;
+                    }
+                    setAppOnInterfaceLocked(restrictIf.useCase, restrictIf.ifName, uid, false);
+                    // Use pending list to queue re-add.
+                    // (Prefer keeping existing pending status if it exists.)
+                    if (restrictIf.pending.indexOfKey(uid) < 0) {
+                        restrictIf.pending.put(uid, true);
+                    }
+                }
+                restrictIf.ifName = newIface;
+            }
+            processPendingAppOnInterfaceLocked(restrictIf);
+        }
+    }
+
+    @Override
+    public void restrictAppOnInterface(String useCase, int uid, boolean restrict) {
+        mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
+        synchronized (mQuotaLock) {
+            restrictAppOnInterfaceLocked(getUseCaseRestrictIf(useCase), uid, restrict);
+        }
+    }
+
+    private void restrictAppOnInterfaceLocked(RestrictIf restrictIf, int uid, boolean restrict) {
+        if (TextUtils.isEmpty(restrictIf.ifName)) {
+            // We don't have an interface name yet so queue
+            // the request for when it comes up
+            restrictIf.pending.put(uid, restrict);
+            return;
+        }
+
+        boolean oldValue = restrictIf.active.get(uid, false);
+        if (oldValue == restrict) {
+            return;
+        }
+
+        if (setAppOnInterfaceLocked(restrictIf.useCase, restrictIf.ifName, uid, restrict)) {
+            restrictIf.active.put(uid, restrict);
+        } else {
+            // Perhaps the interface was down, queue to retry after receipt
+            // of the next network callback for this network.
+            restrictIf.pending.put(uid, true);
+        }
+    }
+
+    private boolean setAppOnInterfaceLocked(String useCase, String ifName, int uid,
+            boolean restrict) {
+        boolean ok = true;
+        try {
+            if (restrict) {
+                mNetdService.bandwidthAddRestrictAppOnInterface(useCase, ifName, uid);
+            } else {
+                mNetdService.bandwidthRemoveRestrictAppOnInterface(useCase, ifName, uid);
+            }
+        } catch (RemoteException e) {
+            throw new IllegalStateException(e);
+        } catch (ServiceSpecificException e) {
+            // ENETDOWN is returned when the interface cannot be resolved to an index.
+            // (and is only returned by bandwidthAdd... call)
+            if (e.errorCode == ENETDOWN) {
+                ok = false;
+            } else {
+                throw new IllegalStateException(e);
+            }
+        }
+        return ok;
+    }
+
+    private void processPendingAppOnInterfaceLocked(RestrictIf restrictIf) {
+        // Work on a copy of the pending list since failed add requests
+        // get put back on.
+        SparseBooleanArray pendingList = restrictIf.pending.clone();
+        restrictIf.pending = new SparseBooleanArray();
+        for (int i = 0; i < pendingList.size(); i++) {
+            restrictAppOnInterfaceLocked(restrictIf, pendingList.keyAt(i), pendingList.valueAt(i));
+        }
+    }
+
     @Override
     public void setAllowOnlyVpnForUids(boolean add, UidRange[] uidRanges)
             throws ServiceSpecificException {
",176,0,"NetworkManagementService::processPendingAppOnInterfaceLocked, NetworkManagementService::setAppOnInterfaceLocked, NetworkManagementService::updateAppOnInterfaceCallback, NetworkManagementService::systemReady, NetworkManagementService::getUseCaseRestrictIf, NetworkManagementService::restrictAppOnInterface, NetworkManagementService::RestrictIf::RestrictIf, NetworkManagementService::restrictAppOnInterfaceLocked"
40,54c58a5649b3d73fc89c068908cfe8215d8b0819,NetworkPolicyManagerService.java,ModificationType.MODIFY,"@@ -56,6 +56,9 @@ import static android.net.NetworkPolicyManager.MASK_METERED_NETWORKS;
 import static android.net.NetworkPolicyManager.POLICY_ALLOW_METERED_BACKGROUND;
 import static android.net.NetworkPolicyManager.POLICY_NONE;
 import static android.net.NetworkPolicyManager.POLICY_REJECT_METERED_BACKGROUND;
+import static android.net.NetworkPolicyManager.POLICY_REJECT_ON_DATA;
+import static android.net.NetworkPolicyManager.POLICY_REJECT_ON_VPN;
+import static android.net.NetworkPolicyManager.POLICY_REJECT_ON_WLAN;
 import static android.net.NetworkPolicyManager.RULE_ALLOW_ALL;
 import static android.net.NetworkPolicyManager.RULE_ALLOW_METERED;
 import static android.net.NetworkPolicyManager.RULE_NONE;
@@ -4167,6 +4170,17 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {
         final int oldRule = oldUidRules & MASK_METERED_NETWORKS;
         int newRule = RULE_NONE;
 
+        try {
+            mNetworkManager.restrictAppOnInterface(""data"", uid,
+                    (uidPolicy & POLICY_REJECT_ON_DATA) != 0);
+            mNetworkManager.restrictAppOnInterface(""vpn"", uid,
+                    (uidPolicy & POLICY_REJECT_ON_VPN) != 0);
+            mNetworkManager.restrictAppOnInterface(""wlan"", uid,
+                    (uidPolicy & POLICY_REJECT_ON_WLAN) != 0);
+        } catch (RemoteException e) {
+            // ignored; service lives in system_server
+        }
+
         // First step: define the new rule based on user restrictions and foreground state.
         if (isRestrictedByAdmin) {
             newRule = RULE_REJECT_METERED;
",14,0,NetworkPolicyManagerService::updateRulesForDataUsageRestrictionsULInner
41,91e38ca43d523feb333f954a2c376c119f8c5811,AudioService.java,ModificationType.MODIFY,"@@ -3317,7 +3317,15 @@ public class AudioService extends IAudioService.Stub
                 hdlr = h;
                 // Remove from client list so that it is re-inserted at top of list
                 iter.remove();
-                hdlr.getBinder().unlinkToDeath(hdlr, 0);
+                try {
+                    hdlr.getBinder().unlinkToDeath(hdlr, 0);
+                    if (cb != hdlr.getBinder()){
+                        hdlr = null;
+                    }
+                } catch (NoSuchElementException e) {
+                    hdlr = null;
+                    Log.w(TAG, ""link does not exist ..."");
+                }
                 break;
             }
         }
",9,1,AudioService::setModeInt
42,5ca333100e7d4a18a9bd4805a327016ddbf6931e,NotificationManagerService.java,ModificationType.MODIFY,"@@ -6125,6 +6125,10 @@ public class NotificationManagerService extends SystemService {
         if (record.sbn.isGroup() && record.getNotification().suppressAlertingDueToGrouping()) {
             return false;
         }
+        // check current user
+        if (!isNotificationForCurrentUser(record)) {
+            return false;
+        }
 
         return true;
     }
",4,0,NotificationManagerService::canShowLightsLocked
43,5ca333100e7d4a18a9bd4805a327016ddbf6931e,BuzzBeepBlinkTest.java,ModificationType.MODIFY,"@@ -1291,6 +1291,22 @@ public class BuzzBeepBlinkTest extends UiServiceTestCase {
         assertEquals(-1, group.getLastAudiblyAlertedMs());
     }
 
+    @Test
+    public void testLightsCheckCurrentUser() {
+        final Notification n = new Builder(getContext(), ""test"")
+                .setSmallIcon(android.R.drawable.sym_def_app_icon).build();
+        int userId = mUser.getIdentifier() + 10;
+        StatusBarNotification sbn = new StatusBarNotification(mPkg, mPkg, 0, mTag, mUid,
+                mPid, n, UserHandle.of(userId), null, System.currentTimeMillis());
+        NotificationRecord r = new NotificationRecord(getContext(), sbn,
+                new NotificationChannel(""test"", ""test"", IMPORTANCE_HIGH));
+
+        mService.buzzBeepBlinkLocked(r);
+        verifyNeverLights();
+        assertFalse(r.isInterruptive());
+        assertEquals(-1, r.getLastAudiblyAlertedMs());
+    }
+
     @Test
     public void testListenerHintCall() throws Exception {
         NotificationRecord r = getCallRecord(1, true);
",16,0,BuzzBeepBlinkTest::testLightsCheckCurrentUser
44,227c4ee74cbc6d3c469640b4071a8afbd393aa27,ReadingModeTile.java,ModificationType.MODIFY,"@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2018 The LineageOS Project
+ * Copyright (C) 2018-2020 The LineageOS Project
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
@@ -25,6 +25,7 @@ import com.android.systemui.qs.tileimpl.QSTileImpl;
 import com.android.systemui.R;
 
 import org.lineageos.internal.logging.LineageMetricsLogger;
+import org.lineageos.internal.util.PackageManagerUtils;
 
 import lineageos.hardware.LineageHardwareManager;
 import lineageos.providers.LineageSettings;
@@ -65,7 +66,8 @@ public class ReadingModeTile extends QSTileImpl<BooleanState> {
 
     @Override
     public boolean isAvailable() {
-        return mHardware.isSupported(LineageHardwareManager.FEATURE_READING_ENHANCEMENT);
+        return !isWellbeingEnabled() &&
+                mHardware.isSupported(LineageHardwareManager.FEATURE_READING_ENHANCEMENT);
     }
 
     @Override
@@ -112,4 +114,9 @@ public class ReadingModeTile extends QSTileImpl<BooleanState> {
     private boolean isReadingModeEnabled() {
         return mHardware.get(LineageHardwareManager.FEATURE_READING_ENHANCEMENT);
     }
+
+    private boolean isWellbeingEnabled() {
+        return PackageManagerUtils.isAppEnabled(mContext,
+                mContext.getString(com.android.internal.R.string.config_defaultWellbeingPackage));
+    }
 }
",9,2,"ReadingModeTile::isAvailable, ReadingModeTile::isWellbeingEnabled"
45,4b04f74e5dff859d7e80a5f1532679adbf649e2f,QSFactoryImpl.java,ModificationType.MODIFY,"@@ -27,6 +27,7 @@ import com.android.systemui.plugins.qs.QSTile;
 import com.android.systemui.plugins.qs.QSTileView;
 import com.android.systemui.qs.QSTileHost;
 import com.android.systemui.qs.external.CustomTile;
+import com.android.systemui.qs.tiles.AODTile;
 import com.android.systemui.qs.tiles.AdbOverNetworkTile;
 import com.android.systemui.qs.tiles.AirplaneModeTile;
 import com.android.systemui.qs.tiles.AmbientDisplayTile;
@@ -92,6 +93,7 @@ public class QSFactoryImpl implements QSFactory {
     private final Provider<CaffeineTile> mCaffeineTileProvider;
     private final Provider<HeadsUpTile> mHeadsUpTileProvider;
     private final Provider<LiveDisplayTile> mLiveDisplayTileProvider;
+    private final Provider<AODTile> mAODTileProvider;
     private final Provider<ProfilesTile> mProfilesTileProvider;
     private final Provider<ReadingModeTile> mReadingModeTileProvider;
     private final Provider<SyncTile> mSyncTileProvider;
@@ -131,7 +133,8 @@ public class QSFactoryImpl implements QSFactory {
             Provider<SyncTile> syncTileProvider,
             Provider<UsbTetherTile> usbTetherTileProvider,
             Provider<VolumeTile> volumeTileProvider,
-            Provider<VpnTile> vpnTileProvider) {
+            Provider<VpnTile> vpnTileProvider,
+            Provider<AODTile> aodTileProvider) {
         mWifiTileProvider = wifiTileProvider;
         mBluetoothTileProvider = bluetoothTileProvider;
         mCellularTileProvider = cellularTileProvider;
@@ -156,6 +159,7 @@ public class QSFactoryImpl implements QSFactory {
         mCaffeineTileProvider = caffeineTileProvider;
         mHeadsUpTileProvider = headsUpTileProvider;
         mLiveDisplayTileProvider = liveDisplayTileProvider;
+        mAODTileProvider = aodTileProvider;
         mProfilesTileProvider = profilesTileProvider;
         mReadingModeTileProvider = readingModeTileProvider;
         mSyncTileProvider = syncTileProvider;
@@ -226,6 +230,8 @@ public class QSFactoryImpl implements QSFactory {
                 return mHeadsUpTileProvider.get();
             case ""livedisplay"":
                 return mLiveDisplayTileProvider.get();
+            case ""aod"":
+                return mAODTileProvider.get();
             case ""profiles"":
                 return mProfilesTileProvider.get();
             case ""reading_mode"":
",7,1,"QSFactoryImpl::createTileInternal, QSFactoryImpl::QSFactoryImpl, QSFactoryImpl::QSFactoryImpl"
46,4b04f74e5dff859d7e80a5f1532679adbf649e2f,AODTile.java,ModificationType.ADD,"@@ -0,0 +1,97 @@
+/*
+ * Copyright (C) 2018 The OmniROM Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.systemui.qs.tiles;
+
+import android.content.Intent;
+import android.provider.Settings;
+import android.service.quicksettings.Tile;
+
+import com.android.systemui.R;
+import com.android.systemui.plugins.qs.QSTile.BooleanState;
+import com.android.systemui.qs.QSHost;
+import com.android.systemui.qs.tileimpl.QSTileImpl;
+
+import org.lineageos.internal.logging.LineageMetricsLogger;
+
+import javax.inject.Inject;
+
+public class AODTile extends QSTileImpl<BooleanState> {
+    private boolean mAodDisabled;
+    private final Icon mIcon = ResourceIcon.get(R.drawable.ic_qs_aod);
+
+    @Inject
+    public AODTile(QSHost host) {
+        super(host);
+        mAodDisabled = Settings.Secure.getInt(mContext.getContentResolver(),
+                Settings.Secure.DOZE_ALWAYS_ON, 1) == 0;
+    }
+
+    @Override
+    public boolean isAvailable() {
+        return mContext.getResources().getBoolean(
+                com.android.internal.R.bool.config_dozeAlwaysOnDisplayAvailable);
+    }
+
+    @Override
+    public BooleanState newTileState() {
+        return new BooleanState();
+    }
+
+    @Override
+    public void handleClick() {
+        mAodDisabled = !mAodDisabled;
+        Settings.Secure.putInt(mContext.getContentResolver(),
+                Settings.Secure.DOZE_ALWAYS_ON,
+                mAodDisabled ? 0 : 1);
+        refreshState();
+    }
+
+    @Override
+    public Intent getLongClickIntent() {
+        return null;
+    }
+
+    @Override
+    public CharSequence getTileLabel() {
+        return mContext.getString(R.string.quick_settings_aod_label);
+    }
+
+    @Override
+    protected void handleUpdateState(BooleanState state, Object arg) {
+        if (state.slash == null) {
+            state.slash = new SlashState();
+        }
+        state.icon = mIcon;
+        state.value = mAodDisabled;
+        state.slash.isSlashed = state.value;
+        state.label = mContext.getString(R.string.quick_settings_aod_label);
+        if (mAodDisabled) {
+            state.state = Tile.STATE_INACTIVE;
+        } else {
+            state.state = Tile.STATE_ACTIVE;
+        }
+    }
+
+    @Override
+    public int getMetricsCategory() {
+        return LineageMetricsLogger.TILE_AOD;
+    }
+
+    @Override
+    public void handleSetListening(boolean listening) {
+    }
+}
",97,0,"AODTile::getMetricsCategory, AODTile::AODTile, AODTile::isAvailable, AODTile::handleSetListening, AODTile::getLongClickIntent, AODTile::handleClick, AODTile::getTileLabel, AODTile::newTileState, AODTile::handleUpdateState"
47,f9fe8c36c51fd0b6f011eb2297ddf30337467de6,AODTile.java,ModificationType.MODIFY,"@@ -24,20 +24,31 @@ import com.android.systemui.R;
 import com.android.systemui.plugins.qs.QSTile.BooleanState;
 import com.android.systemui.qs.QSHost;
 import com.android.systemui.qs.tileimpl.QSTileImpl;
+import com.android.systemui.statusbar.policy.BatteryController;
 
 import org.lineageos.internal.logging.LineageMetricsLogger;
 
 import javax.inject.Inject;
 
-public class AODTile extends QSTileImpl<BooleanState> {
+public class AODTile extends QSTileImpl<BooleanState> implements
+        BatteryController.BatteryStateChangeCallback {
     private boolean mAodDisabled;
     private final Icon mIcon = ResourceIcon.get(R.drawable.ic_qs_aod);
+    private final BatteryController mBatteryController;
 
     @Inject
-    public AODTile(QSHost host) {
+    public AODTile(QSHost host, BatteryController batteryController) {
         super(host);
         mAodDisabled = Settings.Secure.getInt(mContext.getContentResolver(),
                 Settings.Secure.DOZE_ALWAYS_ON, 1) == 0;
+
+        mBatteryController = batteryController;
+        batteryController.observe(getLifecycle(), this);
+    }
+
+    @Override
+    public void onPowerSaveChanged(boolean isPowerSave) {
+        refreshState();
     }
 
     @Override
@@ -67,6 +78,9 @@ public class AODTile extends QSTileImpl<BooleanState> {
 
     @Override
     public CharSequence getTileLabel() {
+        if (mBatteryController.isAodPowerSave()) {
+            return mContext.getString(R.string.quick_settings_aod_off_powersave_label);
+        }
         return mContext.getString(R.string.quick_settings_aod_label);
     }
 
@@ -79,7 +93,9 @@ public class AODTile extends QSTileImpl<BooleanState> {
         state.value = mAodDisabled;
         state.slash.isSlashed = state.value;
         state.label = mContext.getString(R.string.quick_settings_aod_label);
-        if (mAodDisabled) {
+        if (mBatteryController.isAodPowerSave()) {
+            state.state = Tile.STATE_UNAVAILABLE;
+        } else if (mAodDisabled) {
             state.state = Tile.STATE_INACTIVE;
         } else {
             state.state = Tile.STATE_ACTIVE;
",19,3,"AODTile::onPowerSaveChanged, AODTile::AODTile, AODTile::getTileLabel, AODTile::AODTile, AODTile::handleUpdateState"
48,371d17bae73fafa02aa91310903cca526b39c006,AODTile.java,ModificationType.MODIFY,"@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2018 The OmniROM Project
+ *               2020 The LineageOS Project
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
@@ -59,7 +60,9 @@ public class AODTile extends QSTileImpl<BooleanState> implements
 
     @Override
     public BooleanState newTileState() {
-        return new BooleanState();
+        BooleanState state = new BooleanState();
+        state.handlesLongClick = false;
+        return state;
     }
 
     @Override
",4,1,AODTile::newTileState
49,556dccaf241c491feda454e93d3d4cff0de569a5,Installer.java,ModificationType.MODIFY,"@@ -85,6 +85,9 @@ public class Installer extends SystemService {
     public static final int FLAG_USE_QUOTA = IInstalld.FLAG_USE_QUOTA;
     public static final int FLAG_FORCE = IInstalld.FLAG_FORCE;
 
+    public static final int FLAG_CLEAR_APP_DATA_KEEP_ART_PROFILES =
+            IInstalld.FLAG_CLEAR_APP_DATA_KEEP_ART_PROFILES;
+
     private final boolean mIsolated;
 
     private volatile IInstalld mInstalld;
",3,0,
50,556dccaf241c491feda454e93d3d4cff0de569a5,PackageManagerService.java,ModificationType.MODIFY,"@@ -3282,7 +3282,8 @@ public class PackageManagerService extends IPackageManager.Stub
                         // No apps are running this early, so no need to freeze
                         clearAppDataLIF(ps.pkg, UserHandle.USER_ALL,
                                 FLAG_STORAGE_DE | FLAG_STORAGE_CE | FLAG_STORAGE_EXTERNAL
-                                        | Installer.FLAG_CLEAR_CODE_CACHE_ONLY);
+                                        | Installer.FLAG_CLEAR_CODE_CACHE_ONLY
+                                        | Installer.FLAG_CLEAR_APP_DATA_KEEP_ART_PROFILES);
                     }
                 }
                 ver.fingerprint = Build.DATE;
@@ -10394,7 +10395,9 @@ public class PackageManagerService extends IPackageManager.Stub
             clearAppDataLeafLIF(pkg.childPackages.get(i), userId, flags);
         }
 
-        clearAppProfilesLIF(pkg, UserHandle.USER_ALL);
+        if ((flags & Installer.FLAG_CLEAR_APP_DATA_KEEP_ART_PROFILES) == 0) {
+            clearAppProfilesLIF(pkg, UserHandle.USER_ALL);
+        }
     }
 
     private void clearAppDataLeafLIF(PackageParser.Package pkg, int userId, int flags) {
@@ -22737,7 +22740,8 @@ public class PackageManagerService extends IPackageManager.Stub
 
                 if (!Build.DATE.equals(ver.fingerprint)) {
                     clearAppDataLIF(ps.pkg, UserHandle.USER_ALL, FLAG_STORAGE_DE | FLAG_STORAGE_CE
-                            | FLAG_STORAGE_EXTERNAL | Installer.FLAG_CLEAR_CODE_CACHE_ONLY);
+                            | FLAG_STORAGE_EXTERNAL | Installer.FLAG_CLEAR_CODE_CACHE_ONLY
+                            | Installer.FLAG_CLEAR_APP_DATA_KEEP_ART_PROFILES);
                 }
             }
         }
",7,3,"PackageManagerService::loadPrivatePackagesInner, PackageManagerService::PackageManagerService, PackageManagerService::clearAppDataLIF"
51,412aa18be5ae6603eea9f1485f487399410b921e,NetworkManagementService.java,ModificationType.MODIFY,"@@ -282,8 +282,10 @@ public class NetworkManagementService extends INetworkManagementService.Stub {
 
     @GuardedBy(""mQuotaLock"")
     private RestrictIf[] mRestrictIf = {
-            new RestrictIf(RESTRICT_USECASE_DATA, NetworkCapabilities.TRANSPORT_CELLULAR),
+            // Ordered by match preference (in the event we get a callback with
+            // multiple transports).
             new RestrictIf(RESTRICT_USECASE_VPN, NetworkCapabilities.TRANSPORT_VPN),
+            new RestrictIf(RESTRICT_USECASE_DATA, NetworkCapabilities.TRANSPORT_CELLULAR),
             new RestrictIf(RESTRICT_USECASE_WLAN, NetworkCapabilities.TRANSPORT_WIFI),
     };
 
@@ -360,6 +362,7 @@ public class NetworkManagementService extends INetworkManagementService.Stub {
                 for (RestrictIf restrictIf : mRestrictIf) {
                     if (nc.hasTransport(restrictIf.transport)) {
                         matchedRestrictIf = restrictIf;
+                        break;
                     }
                 }
                 if (matchedRestrictIf == null) {
@@ -1559,6 +1562,7 @@ public class NetworkManagementService extends INetworkManagementService.Stub {
                         continue;
                     }
                     setAppOnInterfaceLocked(restrictIf.useCase, restrictIf.ifName, uid, false);
+                    restrictIf.active.setValueAt(i, false);
                     // Use pending list to queue re-add.
                     // (Prefer keeping existing pending status if it exists.)
                     if (restrictIf.pending.indexOfKey(uid) < 0) {
",5,1,"NetworkManagementService::systemReady, NetworkManagementService::updateAppOnInterfaceCallback"
52,fca7fac0dd891edbc1cffec39b9dd40c3a290aed,LocationTile.java,ModificationType.MODIFY,"@@ -1,7 +1,5 @@
 /*
  * Copyright (C) 2014 The Android Open Source Project
- * Copyright (C) 2016 The ParanoidAndroid Project
- * Copyright (C) 2017 The LineageOS Project
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
@@ -18,32 +16,21 @@
 
 package com.android.systemui.qs.tiles;
 
-import android.content.Context;
 import android.content.Intent;
 import android.os.UserManager;
 import android.provider.Settings;
 import android.service.quicksettings.Tile;
-import android.view.LayoutInflater;
-import android.view.View;
-import android.view.ViewGroup;
-import android.widget.LinearLayout;
 import android.widget.Switch;
-import android.widget.TextView;
 
-import com.android.internal.logging.MetricsLogger;
 import com.android.internal.logging.nano.MetricsProto.MetricsEvent;
 import com.android.systemui.R;
 import com.android.systemui.plugins.ActivityStarter;
-import com.android.systemui.plugins.qs.DetailAdapter;
 import com.android.systemui.plugins.qs.QSTile.BooleanState;
 import com.android.systemui.qs.QSHost;
 import com.android.systemui.qs.tileimpl.QSTileImpl;
 import com.android.systemui.statusbar.policy.KeyguardMonitor;
 import com.android.systemui.statusbar.policy.LocationController;
 import com.android.systemui.statusbar.policy.LocationController.LocationChangeCallback;
-import com.android.systemui.volume.SegmentedButtons;
-
-import org.lineageos.internal.logging.LineageMetricsLogger;
 
 import javax.inject.Inject;
 
@@ -52,15 +39,10 @@ public class LocationTile extends QSTileImpl<BooleanState> {
 
     private final Icon mIcon = ResourceIcon.get(R.drawable.ic_location);
 
-    private static final Intent LOCATION_SETTINGS_INTENT =
-            new Intent(Settings.ACTION_LOCATION_SOURCE_SETTINGS);
-
     private final LocationController mController;
-    private final LocationDetailAdapter mDetailAdapter;
     private final KeyguardMonitor mKeyguard;
     private final ActivityStarter mActivityStarter;
     private final Callback mCallback = new Callback();
-    private int mLastState;
 
     @Inject
     public LocationTile(QSHost host, LocationController locationController,
@@ -71,7 +53,6 @@ public class LocationTile extends QSTileImpl<BooleanState> {
         mActivityStarter = activityStarter;
         mController.observe(this, mCallback);
         mKeyguard.observe(this, mCallback);
-        mDetailAdapter = (LocationDetailAdapter) createDetailAdapter();
     }
 
     @Override
@@ -79,17 +60,6 @@ public class LocationTile extends QSTileImpl<BooleanState> {
         return new BooleanState();
     }
 
-    @Override
-    public DetailAdapter getDetailAdapter() {
-        return mDetailAdapter;
-    }
-
-    @Override
-    protected DetailAdapter createDetailAdapter() {
-        return new LocationDetailAdapter();
-    }
-
-
     @Override
     public void handleSetListening(boolean listening) {
     }
@@ -101,13 +71,6 @@ public class LocationTile extends QSTileImpl<BooleanState> {
 
     @Override
     protected void handleClick() {
-        final boolean wasEnabled = mState.value;
-        MetricsLogger.action(mContext, getMetricsCategory(), !wasEnabled);
-        mController.setLocationEnabled(!wasEnabled);
-    }
-
-    @Override
-    protected void handleSecondaryClick() {
         if (mKeyguard.isSecure() && mKeyguard.isShowing()) {
             mActivityStarter.postQSRunnableDismissingKeyguard(() -> {
                 final boolean wasEnabled = mState.value;
@@ -117,10 +80,7 @@ public class LocationTile extends QSTileImpl<BooleanState> {
             return;
         }
         final boolean wasEnabled = mState.value;
-        if (!wasEnabled) {
-            mController.setLocationEnabled(!wasEnabled);
-        }
-        showDetail(true);
+        mController.setLocationEnabled(!wasEnabled);
     }
 
     @Override
@@ -133,70 +93,31 @@ public class LocationTile extends QSTileImpl<BooleanState> {
         if (state.slash == null) {
             state.slash = new SlashState();
         }
-        int currentState = arg instanceof Integer ? (Integer) arg :
-                mController.getLocationCurrentState();
-        final boolean newValue = currentState != Settings.Secure.LOCATION_MODE_OFF;
-        final boolean valueChanged = state.value != newValue;
+        final boolean locationEnabled =  mController.isLocationEnabled();
 
         // Work around for bug 15916487: don't show location tile on top of lock screen. After the
         // bug is fixed, this should be reverted to only hiding it on secure lock screens:
         // state.visible = !(mKeyguard.isSecure() && mKeyguard.isShowing());
-        state.value = newValue;
-        state.dualTarget = true;
+        state.value = locationEnabled;
         checkIfRestrictionEnforcedByAdminOnly(state, UserManager.DISALLOW_SHARE_LOCATION);
         if (state.disabledByPolicy == false) {
             checkIfRestrictionEnforcedByAdminOnly(state, UserManager.DISALLOW_CONFIG_LOCATION);
         }
-        state.label = mContext.getString(getStateLabelRes(currentState));
-        state.slash.isSlashed = currentState == Settings.Secure.LOCATION_MODE_OFF;
-        switch (currentState) {
-            case Settings.Secure.LOCATION_MODE_OFF:
-                state.contentDescription = mContext.getString(
-                        R.string.accessibility_quick_settings_location_off);
-                state.icon = mIcon;
-                break;
-            case Settings.Secure.LOCATION_MODE_HIGH_ACCURACY:
-                state.contentDescription = mContext.getString(
-                        R.string.accessibility_quick_settings_location_high_accuracy);
-                state.icon = mIcon;
-                break;
-            case Settings.Secure.LOCATION_MODE_BATTERY_SAVING:
-                state.contentDescription = mContext.getString(
-                        R.string.accessibility_quick_settings_location_battery_saving);
-                state.icon = ResourceIcon.get(R.drawable.ic_qs_location_battery_saving);
-                break;
-            case Settings.Secure.LOCATION_MODE_SENSORS_ONLY:
-                state.contentDescription = mContext.getString(
-                        R.string.accessibility_quick_settings_location_gps_only);
-                state.icon = ResourceIcon.get(R.drawable.ic_qs_location_sensors_only);
-                break;
-            default:
-                state.contentDescription = mContext.getString(
-                        R.string.accessibility_quick_settings_location_on);
-                state.icon = mIcon;
-        }
-        if (valueChanged) {
-            fireToggleStateChanged(state.value);
+        state.icon = mIcon;
+        state.slash.isSlashed = !state.value;
+        if (locationEnabled) {
+            state.label = mContext.getString(R.string.quick_settings_location_label);
+            state.contentDescription = mContext.getString(
+                    R.string.accessibility_quick_settings_location_on);
+        } else {
+            state.label = mContext.getString(R.string.quick_settings_location_label);
+            state.contentDescription = mContext.getString(
+                    R.string.accessibility_quick_settings_location_off);
         }
         state.state = state.value ? Tile.STATE_ACTIVE : Tile.STATE_INACTIVE;
         state.expandedAccessibilityClassName = Switch.class.getName();
     }
 
-    private int getStateLabelRes(int currentState) {
-        switch (currentState) {
-            case Settings.Secure.LOCATION_MODE_OFF:
-                return R.string.quick_settings_location_off_label;
-            case Settings.Secure.LOCATION_MODE_HIGH_ACCURACY:
-                return R.string.quick_settings_location_high_accuracy_label;
-            case Settings.Secure.LOCATION_MODE_BATTERY_SAVING:
-                return R.string.quick_settings_location_battery_saving_label;
-            case Settings.Secure.LOCATION_MODE_SENSORS_ONLY:
-                return R.string.quick_settings_location_gps_only_label;
-            default:
-                return R.string.quick_settings_location_label;
-        }
-    }
-
     @Override
     public int getMetricsCategory() {
         return MetricsEvent.QS_LOCATION;
@@ -223,111 +144,4 @@ public class LocationTile extends QSTileImpl<BooleanState> {
             refreshState();
         }
     };
-
-    private class LocationDetailAdapter implements DetailAdapter {
-
-        private SegmentedButtons mButtons;
-        private ViewGroup mMessageContainer;
-        private TextView mMessageText;
-
-        @Override
-        public int getMetricsCategory() {
-            return LineageMetricsLogger.TILE_LOCATION_DETAIL;
-        }
-
-        @Override
-        public CharSequence getTitle() {
-            return mContext.getString(R.string.quick_settings_location_detail_title);
-        }
-
-        @Override
-        public Boolean getToggleState() {
-            return mState.value;
-        }
-
-        @Override
-        public Intent getSettingsIntent() {
-            return LOCATION_SETTINGS_INTENT;
-        }
-
-        @Override
-        public void setToggleState(boolean state) {
-            MetricsLogger.action(mContext, MetricsEvent.QS_DND_TOGGLE, state);
-            if (!state) {
-                mController.setLocationEnabled(state);
-                showDetail(false);
-            }
-        }
-
-        @Override
-        public View createDetailView(Context context, View convertView, ViewGroup parent) {
-            final LinearLayout details = convertView != null ? (LinearLayout) convertView
-                    : (LinearLayout) LayoutInflater.from(context).inflate(
-                            R.layout.location_mode_panel, parent, false);
-
-            mLastState = mController.getLocationCurrentState();
-
-            if (convertView == null) {
-                mButtons = (SegmentedButtons) details.findViewById(R.id.location_buttons);
-                mButtons.addButton(R.string.quick_settings_location_high_accuracy_label_twoline,
-                        R.string.quick_settings_location_high_accuracy_label,
-                        Settings.Secure.LOCATION_MODE_HIGH_ACCURACY);
-                mButtons.addButton(R.string.quick_settings_location_battery_saving_label_twoline,
-                        R.string.quick_settings_location_battery_saving_label,
-                        Settings.Secure.LOCATION_MODE_BATTERY_SAVING);
-                mButtons.addButton(R.string.quick_settings_location_gps_only_label_twoline,
-                        R.string.quick_settings_location_gps_only_label,
-                        Settings.Secure.LOCATION_MODE_SENSORS_ONLY);
-                mButtons.setCallback(mButtonsCallback);
-                mMessageContainer = (ViewGroup) details.findViewById(R.id.location_introduction);
-                mMessageText = (TextView) details.findViewById(R.id.location_introduction_message);
-            }
-
-            mButtons.setSelectedValue(mLastState, false /* fromClick */);
-            refresh(mLastState);
-
-            return details;
-        }
-
-        private void refresh(int state) {
-            switch (state) {
-                case Settings.Secure.LOCATION_MODE_HIGH_ACCURACY:
-                    mMessageText.setText(mContext.getString(
-                            R.string.quick_settings_location_detail_mode_high_accuracy_description));
-                    mMessageContainer.setVisibility(View.VISIBLE);
-                    break;
-                case Settings.Secure.LOCATION_MODE_BATTERY_SAVING:
-                    mMessageText.setText(mContext.getString(
-                            R.string.quick_settings_location_detail_mode_battery_saving_description));
-                    mMessageContainer.setVisibility(View.VISIBLE);
-                    break;
-                case Settings.Secure.LOCATION_MODE_SENSORS_ONLY:
-                    mMessageText.setText(mContext.getString(
-                            R.string.quick_settings_location_detail_mode_sensors_only_description));
-                    mMessageContainer.setVisibility(View.VISIBLE);
-                    break;
-                default:
-                    mMessageContainer.setVisibility(View.GONE);
-                    break;
-            }
-        }
-
-        private final SegmentedButtons.Callback mButtonsCallback = new SegmentedButtons.Callback() {
-            @Override
-            public void onSelected(final Object value, boolean fromClick) {
-                if (value != null && mButtons.isShown()) {
-                    mLastState = (Integer) value;
-                    if (fromClick) {
-                        MetricsLogger.action(mContext, MetricsEvent.QS_LOCATION, mLastState);
-                        mController.setLocationMode(mLastState);
-                        refresh(mLastState);
-                    }
-                }
-            }
-
-            @Override
-            public void onInteraction() {
-            }
-        };
-    }
 }
",13,199,"LocationTile::LocationDetailAdapter::createDetailView, LocationTile::handleSecondaryClick, LocationTile::LocationDetailAdapter::getSettingsIntent, LocationTile::handleClick, LocationTile::getStateLabelRes, LocationTile::LocationDetailAdapter::setToggleState, LocationTile::LocationDetailAdapter::getTitle, LocationTile::LocationDetailAdapter::getToggleState, LocationTile::createDetailAdapter, LocationTile::LocationDetailAdapter::Callback, LocationTile::handleUpdateState, LocationTile::LocationTile, LocationTile::getDetailAdapter, LocationTile::LocationDetailAdapter::getMetricsCategory, LocationTile::LocationDetailAdapter::refresh"
53,fca7fac0dd891edbc1cffec39b9dd40c3a290aed,LocationController.java,ModificationType.MODIFY,"@@ -22,8 +22,6 @@ public interface LocationController extends CallbackController<LocationChangeCal
     boolean isLocationActive();
     boolean isLocationEnabled();
     boolean setLocationEnabled(boolean enabled);
-    boolean setLocationMode(int mode);
-    int getLocationCurrentState();
 
     /**
      * A callback for change in location settings (the user has enabled/disabled location).
",0,2,
54,fca7fac0dd891edbc1cffec39b9dd40c3a290aed,LocationControllerImpl.java,ModificationType.MODIFY,"@@ -23,7 +23,6 @@ import android.app.ActivityManager;
 import android.app.AppOpsManager;
 import android.app.StatusBarManager;
 import android.content.BroadcastReceiver;
-import android.content.ContentResolver;
 import android.content.Context;
 import android.content.Intent;
 import android.content.IntentFilter;
@@ -121,43 +120,6 @@ public class LocationControllerImpl extends BroadcastReceiver implements Locatio
         return true;
     }
 
-    /**
-     * Enable or disable location in settings to a specific mode.
-     *
-     * <p>This will attempt to enable/disable every type of location setting
-     * (e.g. high and balanced power).
-     *
-     * <p>If enabling, a user consent dialog will pop up prompting the user to accept.
-     * If the user doesn't accept, network location won't be enabled.
-     *
-     * @return true if attempt to change setting was successful.
-     */
-    public boolean setLocationMode(int mode) {
-        int currentUserId = ActivityManager.getCurrentUser();
-        if (isUserLocationRestricted(currentUserId)) {
-            return false;
-        }
-        final ContentResolver cr = mContext.getContentResolver();
-        // When enabling location, a user consent dialog will pop up, and the
-        // setting won't be fully enabled until the user accepts the agreement.
-        // QuickSettings always runs as the owner, so specifically set the settings
-        // for the current foreground user.
-        return Settings.Secure.putIntForUser(cr, Settings.Secure.LOCATION_MODE, mode, currentUserId);
-    }
-
-    /**
-     * Returns int corresponding to current location mode in settings.
-     */
-    public int getLocationCurrentState() {
-        int currentUserId = ActivityManager.getCurrentUser();
-        if (isUserLocationRestricted(currentUserId)) {
-            return Settings.Secure.LOCATION_MODE_OFF;
-        }
-        final ContentResolver cr = mContext.getContentResolver();
-        return Settings.Secure.getIntForUser(cr, Settings.Secure.LOCATION_MODE,
-                Settings.Secure.LOCATION_MODE_OFF, currentUserId);
-    }
-
     /**
      * Returns true if location is enabled in settings.
      */
",0,38,"LocationControllerImpl::setLocationMode, LocationControllerImpl::getLocationCurrentState"
55,5bb14d69ab191dc62b7c511036e85f7718b0f9bc,NavigationBarView.java,ModificationType.MODIFY,"@@ -639,20 +639,25 @@ public class NavigationBarView extends FrameLayout implements
 
         updateRecentsIcon();
 
-        final boolean isImeShown =
-                (mNavigationIconHints & StatusBarManager.NAVIGATION_HINT_IME_SHOWN) != 0;
-        final boolean showCursorKeys = mShowCursorKeys
+        boolean showCursorKeys = mShowCursorKeys
                 && (mNavigationIconHints & StatusBarManager.NAVIGATION_HINT_BACK_ALT) != 0;
-        final boolean showImeSwitcher = isImeShown
+        final boolean showImeSwitcher = mImeVisible &&
+                // IME switcher can be shown while gestural mode is enabled because
+                // the cursor keys must be hidden anyway
+                (isGesturalMode(mNavBarMode) ||
                 // IME switcher in 3-button mode and cursor keys take the same spot in
                 // the view, so one can only use one or the other
-                && (!isLegacyMode(mNavBarMode) || !showCursorKeys);
+                (!isLegacyMode(mNavBarMode) || !showCursorKeys));
 
         // Update IME button visibility, a11y and rotate button always overrides the appearance
         mContextualButtonGroup.setButtonVisibility(R.id.ime_switcher, showImeSwitcher);
 
         mBarTransitions.reapplyDarkIntensity();
 
+        if (isGesturalMode(mNavBarMode)) {
+            // With gestural mode enabled, ensure that cursor keys are not shown if IME is visible
+            showCursorKeys &= !mImeVisible;
+        }
         final int cursorKeyVisibility = showCursorKeys ? View.VISIBLE : View.INVISIBLE;
 
         getCursorLeftButton().setVisibility(cursorKeyVisibility);
",10,5,NavigationBarView::updateNavButtonIcons
56,2f01d7f604adb0d814cdbf79021ce75f53ae2243,Notifier.java,ModificationType.MODIFY,"@@ -61,6 +61,8 @@ import com.android.server.inputmethod.InputMethodManagerInternal;
 import com.android.server.policy.WindowManagerPolicy;
 import com.android.server.statusbar.StatusBarManagerInternal;
 
+import lineageos.providers.LineageSettings;
+
 /**
  * Sends broadcasts about important power state changes.
  * <p>
@@ -94,6 +96,7 @@ public class Notifier {
     private static final int MSG_SCREEN_BRIGHTNESS_BOOST_CHANGED = 4;
     private static final int MSG_PROFILE_TIMED_OUT = 5;
     private static final int MSG_WIRED_CHARGING_STARTED = 6;
+    private static final int MSG_WIRED_CHARGING_DISCONNECTED = 7;
 
     private static final long[] WIRELESS_VIBRATION_TIME = {
             40, 40, 40, 40, 40, 40, 40, 40, 40, // ramp-up sampling rate = 40ms
@@ -123,6 +126,7 @@ public class Notifier {
     @Nullable private final StatusBarManagerInternal mStatusBarManagerInternal;
     private final TrustManager mTrustManager;
     private final Vibrator mVibrator;
+    private final AudioManager mAudioManager;
 
     private final NotifierHandler mHandler;
     private final Intent mScreenOnIntent;
@@ -171,6 +175,7 @@ public class Notifier {
         mStatusBarManagerInternal = LocalServices.getService(StatusBarManagerInternal.class);
         mTrustManager = mContext.getSystemService(TrustManager.class);
         mVibrator = mContext.getSystemService(Vibrator.class);
+        mAudioManager = mContext.getSystemService(AudioManager.class);
 
         mHandler = new NotifierHandler(looper);
         mScreenOnIntent = new Intent(Intent.ACTION_SCREEN_ON);
@@ -659,6 +664,21 @@ public class Notifier {
         mHandler.sendMessage(msg);
     }
 
+    /**
+     * Called when wired charging has been disconnected so as to provide user feedback
+     */
+    public void onWiredChargingDisconnected(@UserIdInt int userId) {
+        if (DEBUG) {
+            Slog.d(TAG, ""onWiredChargingDisconnected"");
+        }
+
+        mSuspendBlocker.acquire();
+        Message msg = mHandler.obtainMessage(MSG_WIRED_CHARGING_DISCONNECTED);
+        msg.setAsynchronous(true);
+        msg.arg1 = userId;
+        mHandler.sendMessage(msg);
+    }
+
     private void updatePendingBroadcastLocked() {
         if (!mBroadcastInProgress
                 && mPendingInteractiveState != INTERACTIVE_STATE_UNKNOWN
@@ -796,10 +816,10 @@ public class Notifier {
      */
     private void playChargingStartedFeedback(@UserIdInt int userId) {
         playChargingStartedVibration(userId);
-        final String soundPath = Settings.Global.getString(mContext.getContentResolver(),
-                Settings.Global.CHARGING_STARTED_SOUND);
-        if (isChargingFeedbackEnabled(userId) && soundPath != null) {
-            final Uri soundUri = Uri.parse(""file://"" + soundPath);
+        final String soundPath = LineageSettings.Global.getString(mContext.getContentResolver(),
+                LineageSettings.Global.POWER_NOTIFICATIONS_RINGTONE);
+        if (isChargingFeedbackEnabled(userId) && soundPath != null && !soundPath.equals(""silent"")) {
+            final Uri soundUri = Uri.parse(soundPath);
             if (soundUri != null) {
                 final Ringtone sfx = RingtoneManager.getRingtone(mContext, soundUri);
                 if (sfx != null) {
@@ -828,8 +848,8 @@ public class Notifier {
     }
 
     private void playChargingStartedVibration(@UserIdInt int userId) {
-        final boolean vibrateEnabled = Settings.Secure.getIntForUser(mContext.getContentResolver(),
-                Settings.Secure.CHARGING_VIBRATION_ENABLED, 1, userId) != 0;
+        final boolean vibrateEnabled = LineageSettings.Global.getInt(mContext.getContentResolver(),
+                LineageSettings.Global.POWER_NOTIFICATIONS_VIBRATE, 0) == 1;
         if (vibrateEnabled && isChargingFeedbackEnabled(userId)) {
             mVibrator.vibrate(WIRELESS_CHARGING_VIBRATION_EFFECT, VIBRATION_ATTRIBUTES);
         }
@@ -841,7 +861,9 @@ public class Notifier {
         final boolean dndOff = Settings.Global.getInt(mContext.getContentResolver(),
                 Settings.Global.ZEN_MODE, Settings.Global.ZEN_MODE_IMPORTANT_INTERRUPTIONS)
                 == Settings.Global.ZEN_MODE_OFF;
-        return enabled && dndOff;
+        final boolean silentMode = mAudioManager.getRingerModeInternal()
+                == AudioManager.RINGER_MODE_SILENT;
+        return enabled && dndOff && !silentMode;
     }
 
     private final class NotifierHandler extends Handler {
@@ -868,6 +890,7 @@ public class Notifier {
                     lockProfile(msg.arg1);
                     break;
                 case MSG_WIRED_CHARGING_STARTED:
+                case MSG_WIRED_CHARGING_DISCONNECTED:
                     showWiredChargingStarted(msg.arg1);
                     break;
             }
",30,7,"Notifier::onWiredChargingDisconnected, Notifier::playChargingStartedVibration, Notifier::Notifier, Notifier::NotifierHandler::handleMessage, Notifier::isChargingFeedbackEnabled, Notifier::playChargingStartedFeedback"
57,2f01d7f604adb0d814cdbf79021ce75f53ae2243,PowerManagerService.java,ModificationType.MODIFY,"@@ -1901,6 +1901,8 @@ public final class PowerManagerService extends SystemService
                     if (mIsPowered && !BatteryManager.isPlugWired(oldPlugType)
                             && BatteryManager.isPlugWired(mPlugType)) {
                         mNotifier.onWiredChargingStarted(mForegroundProfile);
+                    } else if (wasPowered && !mIsPowered && !dockedOnWirelessCharger) {
+                        mNotifier.onWiredChargingDisconnected(mForegroundProfile);
                     } else if (dockedOnWirelessCharger) {
                         mNotifier.onWirelessChargingStarted(mBatteryLevel, mForegroundProfile);
                     }
",2,0,PowerManagerService::updateIsPoweredLocked
58,2184236cdd579df840cb144dea60265a0986ec95,NotificationStackScrollLayout.java,ModificationType.MODIFY,"@@ -142,6 +142,8 @@ import com.android.systemui.statusbar.policy.ScrollAdapter;
 import com.android.systemui.tuner.TunerService;
 import com.android.systemui.util.Assert;
 
+import lineageos.providers.LineageSettings;
+
 import java.io.FileDescriptor;
 import java.io.PrintWriter;
 import java.lang.annotation.Retention;
@@ -162,6 +164,10 @@ public class NotificationStackScrollLayout extends ViewGroup implements ScrollAd
         NotificationListContainer, ConfigurationListener, Dumpable,
         DynamicPrivacyController.Listener {
 
+    public static final String LOCKSCREEN_TRANSLUCENT_NOTIFICATIONS_BG_ENABLED =
+            ""lineagesecure:"" +
+            LineageSettings.Secure.LOCKSCREEN_TRANSLUCENT_NOTIFICATIONS_BG_ENABLED;
+
     public static final float BACKGROUND_ALPHA_DIMMED = 0.7f;
     private static final String TAG = ""StackScroller"";
     private static final boolean DEBUG = false;
@@ -186,7 +192,7 @@ public class NotificationStackScrollLayout extends ViewGroup implements ScrollAd
     private final NotificationSwipeHelper mSwipeHelper;
     private int mCurrentStackHeight = Integer.MAX_VALUE;
     private final Paint mBackgroundPaint = new Paint();
-    private final boolean mShouldDrawNotificationBackground;
+    private boolean mShouldDrawNotificationBackground;
     private boolean mHighPriorityBeforeSpeedBump;
     private final boolean mAllowLongPress;
     private boolean mDismissRtl;
@@ -559,8 +565,6 @@ public class NotificationStackScrollLayout extends ViewGroup implements ScrollAd
                 getContext(), mMenuEventListener, mFalsingManager);
         mStackScrollAlgorithm = createStackScrollAlgorithm(context);
         initView(context);
-        mShouldDrawNotificationBackground =
-                res.getBoolean(R.bool.config_drawNotificationBackground);
         mFadeNotificationsOnDismiss =
                 res.getBoolean(R.bool.config_fadeNotificationsOnDismiss);
         mRoundnessManager.setAnimatedChildren(mChildrenToAddAnimated);
@@ -575,8 +579,6 @@ public class NotificationStackScrollLayout extends ViewGroup implements ScrollAd
             blockingHelperManager.setNotificationShadeExpanded(height);
         });
 
-        boolean willDraw = mShouldDrawNotificationBackground || DEBUG;
-        setWillNotDraw(!willDraw);
         mBackgroundPaint.setAntiAlias(true);
         if (DEBUG) {
             mDebugPaint = new Paint();
@@ -593,8 +595,12 @@ public class NotificationStackScrollLayout extends ViewGroup implements ScrollAd
                 mHighPriorityBeforeSpeedBump = ""1"".equals(newValue);
             } else if (key.equals(Settings.Secure.NOTIFICATION_DISMISS_RTL)) {
                 updateDismissRtlSetting(""1"".equals(newValue));
+            } else if (key.equals(LOCKSCREEN_TRANSLUCENT_NOTIFICATIONS_BG_ENABLED)) {
+                mShouldDrawNotificationBackground = !""1"".equals(newValue);
+                setWillNotDraw(!mShouldDrawNotificationBackground);
             }
-        }, HIGH_PRIORITY, Settings.Secure.NOTIFICATION_DISMISS_RTL);
+        }, HIGH_PRIORITY, Settings.Secure.NOTIFICATION_DISMISS_RTL,
+                LOCKSCREEN_TRANSLUCENT_NOTIFICATIONS_BG_ENABLED);
 
         mEntryManager.addNotificationEntryListener(new NotificationEntryListener() {
             @Override
@@ -609,6 +615,9 @@ public class NotificationStackScrollLayout extends ViewGroup implements ScrollAd
         dynamicPrivacyController.addListener(this);
         mDynamicPrivacyController = dynamicPrivacyController;
         mStatusbarStateController = (SysuiStatusBarStateController) statusBarStateController;
+
+        boolean willDraw = mShouldDrawNotificationBackground || DEBUG;
+        setWillNotDraw(!willDraw);
     }
 
     private void updateDismissRtlSetting(boolean dismissRtl) {
",15,6,NotificationStackScrollLayout::NotificationStackScrollLayout
59,2184236cdd579df840cb144dea60265a0986ec95,TunerServiceImpl.java,ModificationType.MODIFY,"@@ -39,6 +39,7 @@ import com.android.systemui.BatteryMeterView;
 import com.android.systemui.DemoMode;
 import com.android.systemui.qs.QSTileHost;
 import com.android.systemui.settings.CurrentUserTracker;
+import com.android.systemui.statusbar.notification.stack.NotificationStackScrollLayout;
 import com.android.systemui.statusbar.phone.ClockController;
 import com.android.systemui.statusbar.phone.EdgeBackGestureHandler;
 import com.android.systemui.statusbar.phone.NavigationBarView;
@@ -79,6 +80,7 @@ public class TunerServiceImpl extends TunerService {
             NavigationBarView.NAVIGATION_BAR_MENU_ARROW_KEYS,
             NotificationPanelView.DOUBLE_TAP_SLEEP_GESTURE,
             NotificationPanelView.STATUS_BAR_QUICK_QS_PULLDOWN,
+            NotificationStackScrollLayout.LOCKSCREEN_TRANSLUCENT_NOTIFICATIONS_BG_ENABLED,
             QSTileHost.TILES_SETTING,
             Settings.Secure.DOZE_ALWAYS_ON,
             StatusBar.FORCE_SHOW_NAVBAR,
",2,0,
60,6be17174d01864d96b889ca142302a7a1d327050,NotificationStackScrollLayout.java,ModificationType.MODIFY,"@@ -597,7 +597,7 @@ public class NotificationStackScrollLayout extends ViewGroup implements ScrollAd
                 updateDismissRtlSetting(""1"".equals(newValue));
             } else if (key.equals(LOCKSCREEN_TRANSLUCENT_NOTIFICATIONS_BG_ENABLED)) {
                 mShouldDrawNotificationBackground = !""1"".equals(newValue);
-                setWillNotDraw(!mShouldDrawNotificationBackground);
+                setWillNotDraw(!mShouldDrawNotificationBackground && onKeyguard());
             }
         }, HIGH_PRIORITY, Settings.Secure.NOTIFICATION_DISMISS_RTL,
                 LOCKSCREEN_TRANSLUCENT_NOTIFICATIONS_BG_ENABLED);
@@ -615,9 +615,6 @@ public class NotificationStackScrollLayout extends ViewGroup implements ScrollAd
         dynamicPrivacyController.addListener(this);
         mDynamicPrivacyController = dynamicPrivacyController;
         mStatusbarStateController = (SysuiStatusBarStateController) statusBarStateController;
-
-        boolean willDraw = mShouldDrawNotificationBackground || DEBUG;
-        setWillNotDraw(!willDraw);
     }
 
     private void updateDismissRtlSetting(boolean dismissRtl) {
@@ -780,7 +777,7 @@ public class NotificationStackScrollLayout extends ViewGroup implements ScrollAd
 
     @ShadeViewRefactor(RefactorComponent.DECORATOR)
     protected void onDraw(Canvas canvas) {
-        if (mShouldDrawNotificationBackground
+        if ((mShouldDrawNotificationBackground || !onKeyguard())
                 && (mSections[0].getCurrentBounds().top
                 < mSections[NUM_SECTIONS - 1].getCurrentBounds().bottom
                 || mAmbientState.isDozing())) {
@@ -954,7 +951,7 @@ public class NotificationStackScrollLayout extends ViewGroup implements ScrollAd
     @ShadeViewRefactor(RefactorComponent.SHADE_VIEW)
     private void updateBackgroundDimming() {
         // No need to update the background color if it's not being drawn.
-        if (!mShouldDrawNotificationBackground) {
+        if (!mShouldDrawNotificationBackground && onKeyguard()) {
             return;
         }
 
@@ -2478,7 +2475,7 @@ public class NotificationStackScrollLayout extends ViewGroup implements ScrollAd
     @ShadeViewRefactor(RefactorComponent.SHADE_VIEW)
     private void updateBackground() {
         // No need to update the background color if it's not being drawn.
-        if (!mShouldDrawNotificationBackground) {
+        if (!mShouldDrawNotificationBackground && onKeyguard()) {
             return;
         }
 
@@ -5329,6 +5326,8 @@ public class NotificationStackScrollLayout extends ViewGroup implements ScrollAd
 
         mEntryManager.updateNotifications();
         updateVisibility();
+
+        setWillNotDraw(!mShouldDrawNotificationBackground && onKeyguard);
     }
 
     @ShadeViewRefactor(RefactorComponent.SHADE_VIEW)
",6,7,"NotificationStackScrollLayout::onDraw, NotificationStackScrollLayout::NotificationStackScrollLayout, NotificationStackScrollLayout::updateBackgroundDimming, NotificationStackScrollLayout::updateBackground, NotificationStackScrollLayout::onStatePostChange"
61,6e7483b7eea2681de3c509450f2f561c97cea3e7,KeyguardSecurityContainer.java,ModificationType.MODIFY,"@@ -329,8 +329,11 @@ public class KeyguardSecurityContainer extends FrameLayout implements KeyguardSe
 
     @Override
     protected boolean fitSystemWindows(Rect insets) {
+        int minBottomMargin = getResources().getDimensionPixelSize(
+                R.dimen.kg_security_container_min_bottom_margin);
         // Consume bottom insets because we're setting the padding locally (for IME and navbar.)
-        setPadding(getPaddingLeft(), getPaddingTop(), getPaddingRight(), insets.bottom);
+        setPadding(getPaddingLeft(), getPaddingTop(), getPaddingRight(),
+                minBottomMargin > insets.bottom ? minBottomMargin : insets.bottom);
         insets.bottom = 0;
         return false;
     }
",4,1,KeyguardSecurityContainer::fitSystemWindows
62,6e7483b7eea2681de3c509450f2f561c97cea3e7,FODCircleView.java,ModificationType.MODIFY,"@@ -16,6 +16,7 @@
 
 package com.android.systemui.biometrics;
 
+import android.app.admin.DevicePolicyManager;
 import android.content.Context;
 import android.content.res.Configuration;
 import android.content.res.Resources;
@@ -36,6 +37,8 @@ import android.view.View;
 import android.view.WindowManager;
 import android.widget.ImageView;
 
+import com.android.internal.widget.LockPatternUtils;
+import com.android.keyguard.KeyguardSecurityModel.SecurityMode;
 import com.android.keyguard.KeyguardUpdateMonitor;
 import com.android.keyguard.KeyguardUpdateMonitorCallback;
 import com.android.systemui.R;
@@ -75,6 +78,8 @@ public class FODCircleView extends ImageView {
 
     private Handler mHandler;
 
+    private LockPatternUtils mLockPatternUtils;
+
     private Timer mBurnInProtectionTimer;
 
     private IFingerprintInscreenCallback mFingerprintInscreenCallback =
@@ -109,11 +114,14 @@ public class FODCircleView extends ImageView {
         @Override
         public void onKeyguardBouncerChanged(boolean isBouncer) {
             mIsBouncer = isBouncer;
-
-            if (isBouncer) {
+            if (mUpdateMonitor.isFingerprintDetectionRunning()) {
+                if (isPinOrPattern(mUpdateMonitor.getCurrentUser()) || !isBouncer) {
+                    show();
+                } else {
+                    hide();
+                }
+            } else {
                 hide();
-            } else if (mUpdateMonitor.isFingerprintDetectionRunning()) {
-                show();
             }
         }
 
@@ -182,6 +190,8 @@ public class FODCircleView extends ImageView {
         updatePosition();
         hide();
 
+        mLockPatternUtils = new LockPatternUtils(mContext);
+
         mUpdateMonitor = KeyguardUpdateMonitor.getInstance(context);
         mUpdateMonitor.registerCallback(mMonitorCallback);
 
@@ -405,6 +415,20 @@ public class FODCircleView extends ImageView {
         mWindowManager.updateViewLayout(this, mParams);
     }
 
+    private boolean isPinOrPattern(int userId) {
+        int passwordQuality = mLockPatternUtils.getActivePasswordQuality(userId);
+        switch (passwordQuality) {
+            // PIN
+            case DevicePolicyManager.PASSWORD_QUALITY_NUMERIC:
+            case DevicePolicyManager.PASSWORD_QUALITY_NUMERIC_COMPLEX:
+            // Pattern
+            case DevicePolicyManager.PASSWORD_QUALITY_SOMETHING:
+                return true;
+        }
+
+        return false;
+    }
+
     private class BurnInProtectionTask extends TimerTask {
         @Override
         public void run() {
",28,4,"FODCircleView::isPinOrPattern, FODCircleView::KeyguardUpdateMonitorCallback, FODCircleView::FODCircleView"
63,ed3177bbfc2f2a5fcfff4647d2cc6f97d7e6d5f0,StatusBarKeyguardViewManager.java,ModificationType.MODIFY,"@@ -756,6 +756,7 @@ public class StatusBarKeyguardViewManager implements RemoteInputController.Callb
             mStatusBar.endAffordanceLaunch();
             // The second condition is for SIM card locked bouncer
             if (mBouncer.isScrimmed() && !mBouncer.needsFullscreenBouncer()) {
+                mStatusBar.showKeyguard();
                 hideBouncer(false);
                 updateStates();
             } else {
",1,0,StatusBarKeyguardViewManager::onBackPressed
64,723432d0570703b0d720916ed8c87a1b25de4ab5,Window.java,ModificationType.MODIFY,"@@ -1155,7 +1155,7 @@ public abstract class Window {
 
     private void setPrivateFlags(int flags, int mask) {
         if ((flags & mask & WindowManager.LayoutParams.PRIVATE_FLAG_PREVENT_POWER_KEY) != 0) {
-            mContext.enforceCallingOrSelfPermission(""android.permission.PREVENT_POWER_KEY"",
+            mContext.enforceCallingOrSelfPermission(""lineage.permission.PREVENT_POWER_KEY"",
                     ""No permission to prevent power key"");
         }
         final WindowManager.LayoutParams attrs = getAttributes();
",1,1,Window::setPrivateFlags
65,c2be13913466f884675e872706503733f5622650,CaptivePortalLoginActivity.java,ModificationType.MODIFY,"@@ -108,6 +108,7 @@ public class CaptivePortalLoginActivity extends Activity {
         webSettings.setSupportZoom(true);
         webSettings.setBuiltInZoomControls(true);
         webSettings.setDomStorageEnabled(true);
+        webSettings.setAllowFileAccess(false);
         mWebViewClient = new MyWebViewClient();
         mWebView.setWebViewClient(mWebViewClient);
         mWebView.setWebChromeClient(new MyWebChromeClient());
",1,0,CaptivePortalLoginActivity::onCreate
66,5fa02eab60af8fccded11911391eedb3f3d20299,FODCircleView.java,ModificationType.MODIFY,"@@ -324,8 +324,8 @@ public class FODCircleView extends ImageView {
             return;
         }
 
-        if (mIsBouncer) {
-            // Ignore show calls when Keyguard pin screen is being shown
+        if (mIsBouncer && !isPinOrPattern(mUpdateMonitor.getCurrentUser())) {
+            // Ignore show calls when Keyguard password screen is being shown
             return;
         }
 
",2,2,FODCircleView::show
67,2dc61091f4c2622fbf0599da2bb7eec3658d2a0c,QSFactoryImpl.java,ModificationType.MODIFY,"@@ -47,6 +47,7 @@ import com.android.systemui.qs.tiles.LiveDisplayTile;
 import com.android.systemui.qs.tiles.LocationTile;
 import com.android.systemui.qs.tiles.NfcTile;
 import com.android.systemui.qs.tiles.NightDisplayTile;
+import com.android.systemui.qs.tiles.PowerShareTile;
 import com.android.systemui.qs.tiles.ProfilesTile;
 import com.android.systemui.qs.tiles.ReadingModeTile;
 import com.android.systemui.qs.tiles.RotationLockTile;
@@ -94,6 +95,7 @@ public class QSFactoryImpl implements QSFactory {
     private final Provider<HeadsUpTile> mHeadsUpTileProvider;
     private final Provider<LiveDisplayTile> mLiveDisplayTileProvider;
     private final Provider<AODTile> mAODTileProvider;
+    private final Provider<PowerShareTile> mPowerShareTileProvider;
     private final Provider<ProfilesTile> mProfilesTileProvider;
     private final Provider<ReadingModeTile> mReadingModeTileProvider;
     private final Provider<SyncTile> mSyncTileProvider;
@@ -128,6 +130,7 @@ public class QSFactoryImpl implements QSFactory {
             Provider<CaffeineTile> caffeineTileProvider,
             Provider<HeadsUpTile> headsUpTileProvider,
             Provider<LiveDisplayTile> liveDisplayTileProvider,
+            Provider<PowerShareTile> powerShareTileProvider,
             Provider<ProfilesTile> profilesTileProvider,
             Provider<ReadingModeTile> readingModeTileProvider,
             Provider<SyncTile> syncTileProvider,
@@ -160,6 +163,7 @@ public class QSFactoryImpl implements QSFactory {
         mHeadsUpTileProvider = headsUpTileProvider;
         mLiveDisplayTileProvider = liveDisplayTileProvider;
         mAODTileProvider = aodTileProvider;
+        mPowerShareTileProvider = powerShareTileProvider;
         mProfilesTileProvider = profilesTileProvider;
         mReadingModeTileProvider = readingModeTileProvider;
         mSyncTileProvider = syncTileProvider;
@@ -232,6 +236,8 @@ public class QSFactoryImpl implements QSFactory {
                 return mLiveDisplayTileProvider.get();
             case ""aod"":
                 return mAODTileProvider.get();
+            case ""powershare"":
+                return mPowerShareTileProvider.get();
             case ""profiles"":
                 return mProfilesTileProvider.get();
             case ""reading_mode"":
",6,0,"QSFactoryImpl::QSFactoryImpl, QSFactoryImpl::createTileInternal"
68,2dc61091f4c2622fbf0599da2bb7eec3658d2a0c,PowerShareTile.java,ModificationType.ADD,"@@ -0,0 +1,222 @@
+/*
+ * Copyright (C) 2020 The LineageOS Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.systemui.qs.tiles;
+
+import android.app.Notification;
+import android.app.NotificationChannel;
+import android.app.NotificationManager;
+import android.content.Intent;
+import android.os.BatteryManager;
+import android.os.RemoteException;
+import android.service.quicksettings.Tile;
+
+import com.android.systemui.R;
+import com.android.systemui.plugins.qs.QSTile.BooleanState;
+import com.android.systemui.qs.QSHost;
+import com.android.systemui.qs.tileimpl.QSTileImpl;
+import com.android.systemui.statusbar.policy.BatteryController;
+
+import org.lineageos.internal.logging.LineageMetricsLogger;
+
+import vendor.lineage.powershare.V1_0.IPowerShare;
+
+import java.util.NoSuchElementException;
+
+import javax.inject.Inject;
+
+public class PowerShareTile extends QSTileImpl<BooleanState>
+        implements BatteryController.BatteryStateChangeCallback {
+
+    private IPowerShare mPowerShare;
+    private BatteryController mBatteryController;
+    private NotificationManager mNotificationManager;
+    private Notification mNotification;
+    private static final String CHANNEL_ID = ""powershare"";
+    private static final int NOTIFICATION_ID = 273298;
+
+    @Inject
+    public PowerShareTile(QSHost host, BatteryController batteryController) {
+        super(host);
+        mPowerShare = getPowerShare();
+        if (mPowerShare == null) {
+            return;
+        }
+
+        mBatteryController = batteryController;
+
+        batteryController.addCallback(this);
+
+        mNotificationManager = mContext.getSystemService(NotificationManager.class);
+
+        NotificationChannel notificationChannel = new NotificationChannel(CHANNEL_ID,
+                mContext.getString(R.string.quick_settings_powershare_label),
+                NotificationManager.IMPORTANCE_DEFAULT);
+        mNotificationManager.createNotificationChannel(notificationChannel);
+
+        Notification.Builder builder = new Notification.Builder(mContext, CHANNEL_ID);
+        builder.setContentTitle(
+                mContext.getString(R.string.quick_settings_powershare_enabled_label));
+        builder.setSmallIcon(R.drawable.ic_qs_powershare);
+        mNotification = builder.build();
+        mNotification.flags |= Notification.FLAG_NO_CLEAR | Notification.FLAG_ONGOING_EVENT;
+        mNotification.visibility = Notification.VISIBILITY_PUBLIC;
+    }
+
+    @Override
+    public void onPowerSaveChanged(boolean isPowerSave) {
+        refreshState();
+    }
+
+    @Override
+    public void refreshState() {
+        updatePowerShareState();
+
+        super.refreshState();
+    }
+
+    private void updatePowerShareState() {
+        if (!isAvailable()) {
+            return;
+        }
+
+        if (mBatteryController.isPowerSave()) {
+            try {
+                mPowerShare.setEnabled(false);
+            } catch (RemoteException ex) {
+                ex.printStackTrace();
+            }
+        }
+
+        try {
+            if (mPowerShare.isEnabled()) {
+                mNotificationManager.notify(NOTIFICATION_ID, mNotification);
+            } else {
+                mNotificationManager.cancel(NOTIFICATION_ID);
+            }
+        } catch (RemoteException ex) {
+            ex.printStackTrace();
+        }
+    }
+
+    @Override
+    public boolean isAvailable() {
+        return mPowerShare != null;
+    }
+
+    @Override
+    public BooleanState newTileState() {
+        BooleanState state = new BooleanState();
+        state.handlesLongClick = false;
+        return state;
+    }
+
+    @Override
+    public void handleClick() {
+        try {
+            boolean powerShareEnabled = mPowerShare.isEnabled();
+
+            if (mPowerShare.setEnabled(!powerShareEnabled) != powerShareEnabled) {
+                refreshState();
+            }
+        } catch (RemoteException ex) {
+            ex.printStackTrace();
+        }
+    }
+
+    @Override
+    public Intent getLongClickIntent() {
+        return null;
+    }
+
+    @Override
+    public CharSequence getTileLabel() {
+        if (mBatteryController.isPowerSave()) {
+            return mContext.getString(R.string.quick_settings_powershare_off_powersave_label);
+        } else {
+            if (getBatteryLevel() < getMinBatteryLevel()) {
+                return mContext.getString(R.string.quick_settings_powershare_off_low_battery_label);
+            }
+        }
+
+        return mContext.getString(R.string.quick_settings_powershare_label);
+    }
+
+    @Override
+    protected void handleUpdateState(BooleanState state, Object arg) {
+        if (!isAvailable()) {
+            return;
+        }
+
+        if (state.slash == null) {
+            state.slash = new SlashState();
+        }
+
+        state.icon = ResourceIcon.get(R.drawable.ic_qs_powershare);
+        try {
+            state.value = mPowerShare.isEnabled();
+        } catch (RemoteException ex) {
+            state.value = false;
+            ex.printStackTrace();
+        }
+        state.slash.isSlashed = state.value;
+        state.label = mContext.getString(R.string.quick_settings_powershare_label);
+
+        if (mBatteryController.isPowerSave() || getBatteryLevel() < getMinBatteryLevel()) {
+            state.state = Tile.STATE_UNAVAILABLE;
+        } else if (!state.value) {
+            state.state = Tile.STATE_INACTIVE;
+        } else {
+            state.state = Tile.STATE_ACTIVE;
+        }
+    }
+
+    @Override
+    public int getMetricsCategory() {
+        return LineageMetricsLogger.TILE_POWERSHARE;
+    }
+
+    @Override
+    public void handleSetListening(boolean listening) {
+    }
+
+    private synchronized IPowerShare getPowerShare() {
+        try {
+            return IPowerShare.getService();
+        } catch (RemoteException ex) {
+            ex.printStackTrace();
+        } catch (NoSuchElementException ex) {
+            // service not available
+        }
+
+        return null;
+    }
+
+    private int getMinBatteryLevel() {
+        try {
+            return mPowerShare.getMinBattery();
+        } catch (RemoteException ex) {
+            ex.printStackTrace();
+        }
+
+        return 0;
+    }
+
+    private int getBatteryLevel() {
+        BatteryManager bm = mContext.getSystemService(BatteryManager.class);
+        return bm.getIntProperty(BatteryManager.BATTERY_PROPERTY_CAPACITY);
+    }
+}
",222,0,"PowerShareTile::getBatteryLevel, PowerShareTile::isAvailable, PowerShareTile::getMetricsCategory, PowerShareTile::refreshState, PowerShareTile::onPowerSaveChanged, PowerShareTile::updatePowerShareState, PowerShareTile::newTileState, PowerShareTile::PowerShareTile, PowerShareTile::handleSetListening, PowerShareTile::handleClick, PowerShareTile::handleUpdateState, PowerShareTile::getLongClickIntent, PowerShareTile::getPowerShare, PowerShareTile::getMinBatteryLevel, PowerShareTile::getTileLabel"
69,03e246c00812ba4bd7f0ccd4cc3f83de88c07872,GlobalActionsDialog.java,ModificationType.MODIFY,"@@ -51,7 +51,6 @@ import android.graphics.Shader;
 import android.graphics.drawable.BitmapDrawable;
 import android.graphics.drawable.Drawable;
 import android.media.AudioManager;
-import android.net.ConnectivityManager;
 import android.os.Binder;
 import android.os.Handler;
 import android.os.IBinder;
@@ -68,6 +67,8 @@ import android.service.dreams.DreamService;
 import android.service.dreams.IDreamManager;
 import android.telephony.PhoneStateListener;
 import android.telephony.ServiceState;
+import android.telephony.SubscriptionInfo;
+import android.telephony.SubscriptionManager;
 import android.telephony.TelephonyManager;
 import android.text.TextUtils;
 import android.util.ArraySet;
@@ -122,7 +123,10 @@ import lineageos.providers.LineageSettings;
 import org.lineageos.internal.util.PowerMenuUtils;
 
 import java.util.ArrayList;
+import java.util.BitSet;
+import java.util.Hashtable;
 import java.util.List;
+import java.util.Set;
 
 /**
  * Helper to show the global actions dialog.  Each item is an {@link Action} that
@@ -178,6 +182,10 @@ public class GlobalActionsDialog implements DialogInterface.OnDismissListener,
     private String[] mCurrentMenuActions;
     private boolean mIsRestartMenu;
 
+    private BitSet mAirplaneModeBits;
+    private final Hashtable<Integer, PhoneStateListener> mPhoneStateListeners =
+            new Hashtable<Integer, PhoneStateListener>();
+
     /**
      * @param context everything needs a context :(
      */
@@ -200,14 +208,16 @@ public class GlobalActionsDialog implements DialogInterface.OnDismissListener,
         filter.addAction(TelephonyIntents.ACTION_EMERGENCY_CALLBACK_MODE_CHANGED);
         context.registerReceiver(mBroadcastReceiver, filter);
 
-        ConnectivityManager cm = (ConnectivityManager)
-                context.getSystemService(Context.CONNECTIVITY_SERVICE);
-        mHasTelephony = cm.isNetworkSupported(ConnectivityManager.TYPE_MOBILE);
-
         // get notified of phone state changes
-        TelephonyManager telephonyManager =
-                (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);
-        telephonyManager.listen(mPhoneStateListener, PhoneStateListener.LISTEN_SERVICE_STATE);
+        SubscriptionManager.from(mContext).addOnSubscriptionsChangedListener(
+                new SubscriptionManager.OnSubscriptionsChangedListener() {
+            @Override
+            public void onSubscriptionsChanged() {
+                super.onSubscriptionsChanged();
+                setupAirplaneModeListeners();
+            }
+        });
+        setupAirplaneModeListeners();
         mContext.getContentResolver().registerContentObserver(
                 Settings.Global.getUriFor(Settings.Global.AIRPLANE_MODE_ON), true,
                 mAirplaneModeObserver);
@@ -243,6 +253,58 @@ public class GlobalActionsDialog implements DialogInterface.OnDismissListener,
         updatePowerMenuActions();
     }
 
+    /**
+     * Since there are two ways of handling airplane mode (with telephony, we depend on the internal
+     * device telephony state), and MSIM devices do not report phone state for missing SIMs, we
+     * need to dynamically setup listeners based on subscription changes.
+     *
+     * So if there is _any_ active SIM in the device, we can depend on the phone state,
+     * otherwise fall back to {@link Settings.Global#AIRPLANE_MODE_ON}.
+     */
+    private void setupAirplaneModeListeners() {
+        TelephonyManager telephonyManager = mContext.getSystemService(TelephonyManager.class);
+        Set<Integer> keys = mPhoneStateListeners.keySet();
+        for (int subId : keys) {
+            PhoneStateListener listener = (PhoneStateListener) mPhoneStateListeners.get(subId);
+            telephonyManager.createForSubscriptionId(subId).listen(listener,
+                    PhoneStateListener.LISTEN_NONE);
+        }
+        mPhoneStateListeners.clear();
+        final List<SubscriptionInfo> subInfoList = SubscriptionManager.from(mContext)
+                .getActiveSubscriptionInfoList();
+        if (subInfoList != null) {
+            mHasTelephony = true;
+            mAirplaneModeBits = new BitSet(subInfoList.size());
+            for (int i = 0; i < subInfoList.size(); i++) {
+                // we need the current index inside the listener, so make it final
+                final int subIndex = i;
+                int subId = subInfoList.get(subIndex).getSubscriptionId();
+                PhoneStateListener subListener = new PhoneStateListener() {
+                    @Override
+                    public void onServiceStateChanged(ServiceState serviceState) {
+                        final boolean inAirplaneMode = serviceState.getState()
+                                == ServiceState.STATE_POWER_OFF;
+                        mAirplaneModeBits.set(subIndex, inAirplaneMode);
+                        // we're in airplane mode if _any_ of the subscriptions say we are
+                        mAirplaneState = mAirplaneModeBits.cardinality() > 0
+                                ? ToggleAction.State.On : ToggleAction.State.Off;
+                        mAirplaneModeOn.updateState(mAirplaneState);
+                        if (mAdapter != null) {
+                            mAdapter.notifyDataSetChanged();
+                        }
+                    }
+                };
+                mPhoneStateListeners.put(subId, subListener);
+                telephonyManager.createForSubscriptionId(subId).listen(subListener,
+                        PhoneStateListener.LISTEN_SERVICE_STATE);
+            }
+        } else {
+            mHasTelephony = false;
+        }
+        // Set the initial status of airplane mode toggle
+        mAirplaneState = getUpdatedAirplaneToggleState();
+    }
+
     /**
      * Show the global actions dialog (creating if necessary)
      *
@@ -1606,17 +1668,6 @@ public class GlobalActionsDialog implements DialogInterface.OnDismissListener,
         }
     };
 
-    PhoneStateListener mPhoneStateListener = new PhoneStateListener() {
-        @Override
-        public void onServiceStateChanged(ServiceState serviceState) {
-            if (!mHasTelephony) return;
-            final boolean inAirplaneMode = serviceState.getState() == ServiceState.STATE_POWER_OFF;
-            mAirplaneState = inAirplaneMode ? ToggleAction.State.On : ToggleAction.State.Off;
-            mAirplaneModeOn.updateState(mAirplaneState);
-            mAdapter.notifyDataSetChanged();
-        }
-    };
-
     protected void updatePowerMenuActions() {
         ContentResolver resolver = mContext.getContentResolver();
         final String powerMenuActions = LineageSettings.Secure.getStringForUser(resolver,
@@ -1675,15 +1726,18 @@ public class GlobalActionsDialog implements DialogInterface.OnDismissListener,
         }
     };
 
+    private ToggleAction.State getUpdatedAirplaneToggleState() {
+        return Settings.Global.getInt(mContext.getContentResolver(),
+                Settings.Global.AIRPLANE_MODE_ON, 0) == 1
+                    ? ToggleAction.State.On
+                    : ToggleAction.State.Off;
+    }
+
     private void onAirplaneModeChanged() {
         // Let the service state callbacks handle the state.
         if (mHasTelephony) return;
 
-        boolean airplaneModeOn = Settings.Global.getInt(
-                mContext.getContentResolver(),
-                Settings.Global.AIRPLANE_MODE_ON,
-                0) == 1;
-        mAirplaneState = airplaneModeOn ? ToggleAction.State.On : ToggleAction.State.Off;
+        mAirplaneState = getUpdatedAirplaneToggleState();
         mAirplaneModeOn.updateState(mAirplaneState);
     }
 
",78,24,"GlobalActionsDialog::GlobalActionsDialog, GlobalActionsDialog::getUpdatedAirplaneToggleState, GlobalActionsDialog::PhoneStateListener, GlobalActionsDialog::setupAirplaneModeListeners, GlobalActionsDialog::onAirplaneModeChanged"
70,54c4dd59d4aa6d981a0907b378026fd6c24bb1ec,TelephonyManager.java,ModificationType.MODIFY,"@@ -3123,6 +3123,30 @@ public class TelephonyManager {
         }
     }
 
+    /**
+     * Returns true if the specified type of application (e.g. {@link #APPTYPE_CSIM} is present
+     * on the UICC card.
+     *
+     * Requires that the calling app has READ_PRIVILEGED_PHONE_STATE permission
+     *
+     * @param appType the uicc app type like {@link APPTYPE_CSIM}
+     * @return true if the specified type of application in UICC CARD or false if no uicc or error.
+     * @hide
+     */
+    @SystemApi
+    @RequiresPermission(android.Manifest.permission.READ_PRIVILEGED_PHONE_STATE)
+    public boolean isApplicationOnUicc(@UiccAppType int appType) {
+        try {
+            ITelephony service = getITelephony();
+            if (service != null) {
+                return service.isApplicationOnUicc(getSubId(), appType);
+            }
+        } catch (RemoteException e) {
+            Log.e(TAG, ""Error calling ITelephony#isApplicationOnUicc"", e);
+        }
+        return false;
+    }
+
     /**
      * Returns a constant indicating the state of the device SIM card in a slot.
      *
",24,0,TelephonyManager::isApplicationOnUicc
71,635d92897f8332179b18175cc65d19baaaa10cd5,PowerShareTile.java,ModificationType.MODIFY,"@@ -57,9 +57,6 @@ public class PowerShareTile extends QSTileImpl<BooleanState>
         }
 
         mBatteryController = batteryController;
-
-        batteryController.addCallback(this);
-
         mNotificationManager = mContext.getSystemService(NotificationManager.class);
 
         NotificationChannel notificationChannel = new NotificationChannel(CHANNEL_ID,
@@ -74,6 +71,8 @@ public class PowerShareTile extends QSTileImpl<BooleanState>
         mNotification = builder.build();
         mNotification.flags |= Notification.FLAG_NO_CLEAR | Notification.FLAG_ONGOING_EVENT;
         mNotification.visibility = Notification.VISIBILITY_PUBLIC;
+
+        batteryController.addCallback(this);
     }
 
     @Override
",2,3,PowerShareTile::PowerShareTile
72,42d4788a9e1f66d81e18f0d97f6adea75ee8a48b,NetworkManagementService.java,ModificationType.MODIFY,"@@ -298,6 +298,8 @@ public class NetworkManagementService extends INetworkManagementService.Stub {
         throw new IllegalStateException(""Unknown interface restriction"");
     }
 
+    private final HashMap<Network, NetworkCapabilities> mNetworkCapabilitiesMap = new HashMap<>();
+
     /**
      * Constructs a new NetworkManagementService instance
      *
@@ -355,9 +357,24 @@ public class NetworkManagementService extends INetworkManagementService.Stub {
 
         final ConnectivityManager.NetworkCallback mNetworkCallback =
                 new ConnectivityManager.NetworkCallback() {
+            @Override
+            public void onCapabilitiesChanged(Network network,
+                    NetworkCapabilities networkCapabilities) {
+                mNetworkCapabilitiesMap.put(network, networkCapabilities);
+            }
+
             @Override
             public void onLinkPropertiesChanged(Network network, LinkProperties linkProperties) {
-                NetworkCapabilities nc = mConnectivityManager.getNetworkCapabilities(network);
+                // Callback ordering in Oreo+ is documented to be:
+                // onCapabilitiesChanged, onLinkPropertiesChanged
+                // At this point, we should always find the network in our
+                // local map but guard anyway.
+                NetworkCapabilities nc = mNetworkCapabilitiesMap.get(network);
+                if (nc == null) {
+                    Slog.e(TAG, ""onLinkPropertiesChanged: network was not in map: ""
+                            + ""network="" + network + "" linkProperties="" + linkProperties);
+                    return;
+                }
                 RestrictIf matchedRestrictIf = null;
                 for (RestrictIf restrictIf : mRestrictIf) {
                     if (nc.hasTransport(restrictIf.transport)) {
@@ -378,6 +395,11 @@ public class NetworkManagementService extends INetworkManagementService.Stub {
                 mDaemonHandler.post(() ->
                         updateAppOnInterfaceCallback(finalRestrictIf, iface));
             }
+
+            @Override
+            public void onLost(Network network) {
+                mNetworkCapabilitiesMap.remove(network);
+            }
         };
 
         mConnectivityManager.registerNetworkCallback(request, mNetworkCallback);
",23,1,NetworkManagementService::systemReady
73,ee817c5efdeac0d925c1cce60ded7c629c0baa94,AdbOverNetworkTile.java,ModificationType.MODIFY,"@@ -1,6 +1,6 @@
 /*
  * Copyright (C) 2015 The CyanogenMod Project
- * Copyright (C) 2017-2019 The LineageOS Project
+ * Copyright (C) 2017-2020 The LineageOS Project
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
@@ -17,11 +17,11 @@
 
 package com.android.systemui.qs.tiles;
 
-import android.content.Context;
 import android.content.Intent;
 import android.database.ContentObserver;
 import android.net.ConnectivityManager;
 import android.net.LinkAddress;
+import android.net.LinkProperties;
 import android.net.Network;
 import android.net.Uri;
 import android.os.UserHandle;
@@ -29,11 +29,11 @@ import android.provider.Settings;
 import android.service.quicksettings.Tile;
 
 import com.android.systemui.Dependency;
+import com.android.systemui.R;
 import com.android.systemui.plugins.ActivityStarter;
 import com.android.systemui.plugins.qs.QSTile.BooleanState;
 import com.android.systemui.qs.QSHost;
 import com.android.systemui.qs.tileimpl.QSTileImpl;
-import com.android.systemui.R;
 import com.android.systemui.statusbar.phone.UnlockMethodCache;
 import com.android.systemui.statusbar.policy.KeyguardMonitor;
 
@@ -43,7 +43,6 @@ import org.lineageos.internal.logging.LineageMetricsLogger;
 import java.net.Inet4Address;
 import java.net.Inet6Address;
 import java.net.InetAddress;
-import java.util.List;
 
 import javax.inject.Inject;
 
@@ -182,13 +181,11 @@ public class AdbOverNetworkTile extends QSTileImpl<BooleanState> {
     private ConnectivityManager.NetworkCallback mNetworkCallback =
             new ConnectivityManager.NetworkCallback() {
         @Override
-        public void onAvailable(Network network) {
-            List<LinkAddress> linkAddresses =
-                    mConnectivityManager.getLinkProperties(network).getLinkAddresses();
+        public void onLinkPropertiesChanged(Network network, LinkProperties linkProperties) {
             // Determine local network address.
             // Use first IPv4 address if available, otherwise use first IPv6.
             String ipv4 = null, ipv6 = null;
-            for (LinkAddress la : linkAddresses) {
+            for (LinkAddress la : linkProperties.getLinkAddresses()) {
                 final InetAddress addr = la.getAddress();
                 if (ipv4 == null && addr instanceof Inet4Address) {
                     ipv4 = addr.getHostAddress();
",5,8,AdbOverNetworkTile::NetworkCallback
74,e145f0c086b5ce24951f0efca167d48333cae9aa,ServiceState.java,ModificationType.MODIFY,"@@ -1383,15 +1383,16 @@ public class ServiceState implements Parcelable {
 
     /** @hide */
     public boolean isUsingCarrierAggregation() {
+        boolean isUsingCa = false;
         NetworkRegistrationInfo nri = getNetworkRegistrationInfo(
                 NetworkRegistrationInfo.DOMAIN_PS, AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
         if (nri != null) {
             DataSpecificRegistrationInfo dsri = nri.getDataSpecificInfo();
             if (dsri != null) {
-                return dsri.isUsingCarrierAggregation();
+                isUsingCa = dsri.isUsingCarrierAggregation();
             }
         }
-        return false;
+        return isUsingCa || getCellBandwidths().length > 1;
     }
 
     /** @hide */
",3,2,ServiceState::isUsingCarrierAggregation
75,d65af6e1c790417a766a1cb65d45eb487a3d3277,Camera.java,ModificationType.MODIFY,"@@ -39,6 +39,7 @@ import android.os.Message;
 import android.os.Process;
 import android.os.RemoteException;
 import android.os.ServiceManager;
+import android.os.SystemProperties;
 import android.renderscript.Allocation;
 import android.renderscript.Element;
 import android.renderscript.RSIllegalArgumentException;
@@ -56,6 +57,7 @@ import com.android.internal.app.IAppOpsService;
 import java.io.IOException;
 import java.lang.ref.WeakReference;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.LinkedHashMap;
 import java.util.List;
 
@@ -277,6 +279,23 @@ public class Camera {
      */
     private static final int CAMERA_FACE_DETECTION_SW = 1;
 
+    /**
+     * @hide
+     */
+    public static boolean shouldExposeAuxCamera() {
+        /**
+         * Force to expose only two cameras
+         * if the package name does not falls in this bucket
+         */
+        String packageName = ActivityThread.currentOpPackageName();
+        List<String> packageList = Arrays.asList(
+                SystemProperties.get(""vendor.camera.aux.packagelist"", packageName).split("",""));
+        List<String> packageBlacklist = Arrays.asList(
+                SystemProperties.get(""vendor.camera.aux.packageblacklist"", """").split("",""));
+
+        return packageList.contains(packageName) && !packageBlacklist.contains(packageName);
+    }
+
     /**
      * Returns the number of physical cameras available on this device.
      * The return value of this method might change dynamically if the device
@@ -292,7 +311,20 @@ public class Camera {
      * @return total number of accessible camera devices, or 0 if there are no
      *   cameras or an error was encountered enumerating them.
      */
-    public native static int getNumberOfCameras();
+    public static int getNumberOfCameras() {
+        int numberOfCameras = _getNumberOfCameras();
+        if (!shouldExposeAuxCamera() && numberOfCameras > 2) {
+            numberOfCameras = 2;
+        }
+        return numberOfCameras;
+    }
+
+    /**
+     * Returns the number of physical cameras available on this device.
+     *
+     * @hide
+     */
+    public native static int _getNumberOfCameras();
 
     /**
      * Returns the information about a particular camera.
@@ -303,6 +335,9 @@ public class Camera {
      *    low-level failure).
      */
     public static void getCameraInfo(int cameraId, CameraInfo cameraInfo) {
+        if (cameraId >= getNumberOfCameras()) {
+            throw new RuntimeException(""Unknown camera ID"");
+        }
         _getCameraInfo(cameraId, cameraInfo);
         IBinder b = ServiceManager.getService(Context.AUDIO_SERVICE);
         IAudioService audioService = IAudioService.Stub.asInterface(b);
@@ -575,6 +610,9 @@ public class Camera {
 
     /** used by Camera#open, Camera#open(int) */
     Camera(int cameraId) {
+        if (cameraId >= getNumberOfCameras()) {
+            throw new RuntimeException(""Unknown camera ID"");
+        }
         int err = cameraInitNormal(cameraId);
         if (checkInitErrors(err)) {
             if (err == -EACCES) {
",39,1,"Camera::getCameraInfo, Camera::getNumberOfCameras, Camera::Camera, Camera::shouldExposeAuxCamera"
76,d65af6e1c790417a766a1cb65d45eb487a3d3277,CameraManager.java,ModificationType.MODIFY,"@@ -22,6 +22,7 @@ import android.annotation.Nullable;
 import android.annotation.RequiresPermission;
 import android.annotation.SystemService;
 import android.content.Context;
+import android.hardware.Camera;
 import android.hardware.CameraInfo;
 import android.hardware.CameraStatus;
 import android.hardware.ICameraService;
@@ -1006,8 +1007,10 @@ public final class CameraManager {
                 // Try to make sure we have an up-to-date list of camera devices.
                 connectCameraServiceLocked();
 
+                boolean exposeAuxCamera = Camera.shouldExposeAuxCamera();
                 int idCount = 0;
                 for (int i = 0; i < mDeviceStatus.size(); i++) {
+                    if (!exposeAuxCamera && i == 2) break;
                     int status = mDeviceStatus.valueAt(i);
                     if (status == ICameraServiceListener.STATUS_NOT_PRESENT ||
                             status == ICameraServiceListener.STATUS_ENUMERATING) continue;
@@ -1016,6 +1019,7 @@ public final class CameraManager {
                 cameraIds = new String[idCount];
                 idCount = 0;
                 for (int i = 0; i < mDeviceStatus.size(); i++) {
+                    if (!exposeAuxCamera && i == 2) break;
                     int status = mDeviceStatus.valueAt(i);
                     if (status == ICameraServiceListener.STATUS_NOT_PRESENT ||
                             status == ICameraServiceListener.STATUS_ENUMERATING) continue;
@@ -1213,6 +1217,11 @@ public final class CameraManager {
         }
 
         private void onStatusChangedLocked(int status, String id) {
+            if (!Camera.shouldExposeAuxCamera() && Integer.parseInt(id) >= 2) {
+                Log.w(TAG, ""[soar.cts] ignore the status update of camera: "" + id);
+                return;
+            }
+
             if (DEBUG) {
                 Log.v(TAG,
                         String.format(""Camera id %s has status changed to 0x%x"", id, status));
",9,0,"CameraManager::CameraManagerGlobal::onStatusChangedLocked, CameraManager::CameraManagerGlobal::getCameraIdList"
77,3e7e3cdcdf02aadee8c75f5a1313bc15764cd335,ScreenPinningRequest.java,ModificationType.MODIFY,"@@ -33,9 +33,11 @@ import android.os.Binder;
 import android.os.RemoteException;
 import android.util.DisplayMetrics;
 import android.view.Gravity;
+import android.view.IWindowManager;
 import android.view.View;
 import android.view.ViewGroup;
 import android.view.WindowManager;
+import android.view.WindowManagerGlobal;
 import android.view.accessibility.AccessibilityManager;
 import android.view.animation.DecelerateInterpolator;
 import android.widget.Button;
@@ -264,16 +266,20 @@ public class ScreenPinningRequest implements View.OnClickListener,
                 mLayout.findViewById(R.id.screen_pinning_recents_group).setVisibility(VISIBLE);
                 mLayout.findViewById(R.id.screen_pinning_home_bg_light).setVisibility(INVISIBLE);
                 mLayout.findViewById(R.id.screen_pinning_home_bg).setVisibility(INVISIBLE);
-                descriptionStringResId = touchExplorationEnabled
-                        ? R.string.screen_pinning_description_accessible
-                        : R.string.screen_pinning_description;
+                descriptionStringResId = !hasNavigationBar()
+                        ? R.string.screen_pinning_description_no_navbar
+                        : touchExplorationEnabled
+                                ? R.string.screen_pinning_description_accessible
+                                : R.string.screen_pinning_description;
             } else {
                 mLayout.findViewById(R.id.screen_pinning_recents_group).setVisibility(INVISIBLE);
                 mLayout.findViewById(R.id.screen_pinning_home_bg_light).setVisibility(VISIBLE);
                 mLayout.findViewById(R.id.screen_pinning_home_bg).setVisibility(VISIBLE);
-                descriptionStringResId = touchExplorationEnabled
-                        ? R.string.screen_pinning_description_recents_invisible_accessible
-                        : R.string.screen_pinning_description_recents_invisible;
+                descriptionStringResId = !hasNavigationBar()
+                        ? R.string.screen_pinning_description_no_navbar
+                        : touchExplorationEnabled
+                                ? R.string.screen_pinning_description_recents_invisible_accessible
+                                : R.string.screen_pinning_description_recents_invisible;
             }
 
             if (navigationBarView != null) {
@@ -311,6 +317,16 @@ public class ScreenPinningRequest implements View.OnClickListener,
             }
         }
 
+        private boolean hasNavigationBar() {
+            IWindowManager windowManagerService = WindowManagerGlobal.getWindowManagerService();
+            try {
+                return windowManagerService.hasNavigationBar(mContext.getDisplayId());
+            } catch (RemoteException e) {
+                // ignore
+            }
+            return false;
+        }
+
         @Override
         public void onDetachedFromWindow() {
             mContext.unregisterReceiver(mReceiver);
",22,6,"ScreenPinningRequest::RequestWindowView::hasNavigationBar, ScreenPinningRequest::RequestWindowView::inflateView"
78,3e7e3cdcdf02aadee8c75f5a1313bc15764cd335,ScreenPinningNotify.java,ModificationType.MODIFY,"@@ -17,8 +17,12 @@
 package com.android.systemui.statusbar.phone;
 
 import android.content.Context;
+import android.os.RemoteException;
 import android.os.SystemClock;
 import android.util.Slog;
+import android.view.IWindowManager;
+import android.view.WindowManager;
+import android.view.WindowManagerGlobal;
 import android.widget.Toast;
 
 import com.android.systemui.R;
@@ -60,11 +64,13 @@ public class ScreenPinningNotify {
         if (mLastToast != null) {
             mLastToast.cancel();
         }
-        mLastToast = makeAllUserToastAndShow(isGestureNavEnabled
-                ? R.string.screen_pinning_toast_gesture_nav
-                : isRecentsButtonVisible
-                        ? R.string.screen_pinning_toast
-                        : R.string.screen_pinning_toast_recents_invisible);
+        mLastToast = makeAllUserToastAndShow(!hasNavigationBar()
+                ? R.string.screen_pinning_toast_no_navbar
+                : isGestureNavEnabled
+                        ? R.string.screen_pinning_toast_gesture_nav
+                        : isRecentsButtonVisible
+                                ? R.string.screen_pinning_toast
+                                : R.string.screen_pinning_toast_recents_invisible);
         mLastShowToastTime = showToastTime;
     }
 
@@ -73,4 +79,14 @@ public class ScreenPinningNotify {
         toast.show();
         return toast;
     }
+
+    private boolean hasNavigationBar() {
+        IWindowManager windowManagerService = WindowManagerGlobal.getWindowManagerService();
+        try {
+            return windowManagerService.hasNavigationBar(mContext.getDisplayId());
+        } catch (RemoteException e) {
+            // ignore
+        }
+        return false;
+     }
 }
",21,5,"ScreenPinningNotify::showEscapeToast, ScreenPinningNotify::hasNavigationBar"
79,3e7e3cdcdf02aadee8c75f5a1313bc15764cd335,PhoneWindowManager.java,ModificationType.MODIFY,"@@ -1661,6 +1661,10 @@ public class PhoneWindowManager implements WindowManagerPolicy {
     private final Runnable mBackLongPress = new Runnable() {
         @Override
         public void run() {
+            if (unpinActivity(false)) {
+                return;
+            }
+
             if (ActionUtils.killForegroundApp(mContext, mCurrentUserId)) {
                 performHapticFeedback(HapticFeedbackConstants.LONG_PRESS, false,
                         ""Back - Long Press"");
@@ -3415,7 +3419,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
             }
             return -1;
         } else if (keyCode == KeyEvent.KEYCODE_BACK) {
-            if (mKillAppLongpressBack) {
+            if (mKillAppLongpressBack || unpinActivity(true)) {
                 if (down && repeatCount == 0) {
                     mHandler.postDelayed(mBackLongPress, mBackKillTimeout);
                 }
@@ -3658,6 +3662,22 @@ public class PhoneWindowManager implements WindowManagerPolicy {
         return false;
     }
 
+    private boolean unpinActivity(boolean checkOnly) {
+        if (!hasNavigationBar()) {
+            try {
+                if (ActivityTaskManager.getService().isInLockTaskMode()) {
+                    if (!checkOnly) {
+                        ActivityTaskManager.getService().stopSystemLockTaskMode();
+                    }
+                    return true;
+                }
+            } catch (RemoteException e) {
+                // ignore
+            }
+        }
+        return false;
+    }
+
     // TODO(b/117479243): handle it in InputPolicy
     /** {@inheritDoc} */
     @Override
",21,1,"PhoneWindowManager::Runnable, PhoneWindowManager::interceptKeyBeforeDispatchingInner, PhoneWindowManager::unpinActivity"
80,688435f2badaf4c55e10fb2057896bba422d506c,StatusBarKeyguardViewManager.java,ModificationType.MODIFY,"@@ -756,7 +756,7 @@ public class StatusBarKeyguardViewManager implements RemoteInputController.Callb
             mStatusBar.endAffordanceLaunch();
             // The second condition is for SIM card locked bouncer
             if (mBouncer.isScrimmed() && !mBouncer.needsFullscreenBouncer()) {
-                mStatusBar.showKeyguard();
+                mStatusBar.showKeyguardImpl();
                 hideBouncer(false);
                 updateStates();
             } else {
",1,1,StatusBarKeyguardViewManager::onBackPressed
81,71c8538752a5f1dc5ad2068593f83d88b78d8798,KeyguardViewMediator.java,ModificationType.MODIFY,"@@ -836,8 +836,9 @@ public class KeyguardViewMediator extends SystemUI {
                 }
             } else if (mShowing) {
                 mPendingReset = true;
-            } else if ((why == WindowManagerPolicyConstants.OFF_BECAUSE_OF_TIMEOUT && timeout > 0)
-                    || (why == WindowManagerPolicyConstants.OFF_BECAUSE_OF_USER && !lockImmediately)) {
+            } else if (((why == WindowManagerPolicyConstants.OFF_BECAUSE_OF_TIMEOUT && timeout > 0)
+                    || why == WindowManagerPolicyConstants.OFF_BECAUSE_OF_USER) &&
+                    !lockImmediately) {
                 doKeyguardLaterLocked(timeout);
                 mLockLater = true;
             } else if (!mLockPatternUtils.isLockScreenDisabled(currentUser)) {
",3,2,KeyguardViewMediator::onStartedGoingToSleep
82,d359088b59569eff83a6988960719367481f6bf2,TunerServiceImpl.java,ModificationType.MODIFY,"@@ -164,6 +164,10 @@ public class TunerServiceImpl extends TunerService {
         setValue(TUNER_VERSION, newVersion);
     }
 
+    private boolean isLineageSetting(String key) {
+        return isLineageGlobal(key) || isLineageSystem(key) || isLineageSecure(key);
+    }
+
     private boolean isLineageGlobal(String key) {
         return key.startsWith(""lineageglobal:"");
     }
@@ -370,7 +374,7 @@ public class TunerServiceImpl extends TunerService {
         mContext.sendBroadcast(intent);
 
         for (String key : mTunableLookup.keySet()) {
-            if (ArrayUtils.contains(RESET_BLACKLIST, key)) {
+            if (ArrayUtils.contains(RESET_BLACKLIST, key) || isLineageSetting(key)) {
                 continue;
             }
             setValue(key, null);
",5,1,"TunerServiceImpl::isLineageSetting, TunerServiceImpl::clearAllFromUser"
83,97769432dcd66b9f92d69f0c9b7a1c7065f6a8f3,BatteryMeterView.java,ModificationType.MODIFY,"@@ -75,7 +75,7 @@ import java.text.NumberFormat;
 public class BatteryMeterView extends LinearLayout implements
         BatteryStateChangeCallback, Tunable, DarkReceiver, ConfigurationListener {
 
-    public static final String STATUS_BAR_BATTERY_STYLE =
+    private static final String STATUS_BAR_BATTERY_STYLE =
             ""lineagesystem:"" + LineageSettings.System.STATUS_BAR_BATTERY_STYLE;
 
     private static final int BATTERY_STYLE_PORTRAIT = 0;
",1,1,
84,97769432dcd66b9f92d69f0c9b7a1c7065f6a8f3,NotificationStackScrollLayout.java,ModificationType.MODIFY,"@@ -164,11 +164,12 @@ public class NotificationStackScrollLayout extends ViewGroup implements ScrollAd
         NotificationListContainer, ConfigurationListener, Dumpable,
         DynamicPrivacyController.Listener {
 
-    public static final String LOCKSCREEN_TRANSLUCENT_NOTIFICATIONS_BG_ENABLED =
+    public static final float BACKGROUND_ALPHA_DIMMED = 0.7f;
+
+    private static final String LOCKSCREEN_TRANSLUCENT_NOTIFICATIONS_BG_ENABLED =
             ""lineagesecure:"" +
             LineageSettings.Secure.LOCKSCREEN_TRANSLUCENT_NOTIFICATIONS_BG_ENABLED;
 
-    public static final float BACKGROUND_ALPHA_DIMMED = 0.7f;
     private static final String TAG = ""StackScroller"";
     private static final boolean DEBUG = false;
     private static final float RUBBER_BAND_FACTOR_NORMAL = 0.35f;
",3,2,
85,97769432dcd66b9f92d69f0c9b7a1c7065f6a8f3,ClockController.java,ModificationType.MODIFY,"@@ -33,7 +33,7 @@ public class ClockController implements TunerService.Tunable {
     private static final int CLOCK_POSITION_CENTER = 1;
     private static final int CLOCK_POSITION_LEFT = 2;
 
-    public static final String CLOCK_POSITION = ""lineagesystem:status_bar_clock"";
+    private static final String CLOCK_POSITION = ""lineagesystem:status_bar_clock"";
 
     private Clock mActiveClock, mCenterClock, mLeftClock, mRightClock;
 
",1,1,
86,97769432dcd66b9f92d69f0c9b7a1c7065f6a8f3,EdgeBackGestureHandler.java,ModificationType.MODIFY,"@@ -78,7 +78,7 @@ public class EdgeBackGestureHandler implements DisplayListener, TunerService.Tun
     private static final int MAX_LONG_PRESS_TIMEOUT = SystemProperties.getInt(
             ""gestures.back_timeout"", 250);
 
-    public static final String KEY_EDGE_LONG_SWIPE_ACTION =
+    private static final String KEY_EDGE_LONG_SWIPE_ACTION =
             ""lineagesystem:"" + LineageSettings.System.KEY_EDGE_LONG_SWIPE_ACTION;
 
     private final IPinnedStackListener.Stub mImeChangedListener = new IPinnedStackListener.Stub() {
",1,1,
87,97769432dcd66b9f92d69f0c9b7a1c7065f6a8f3,NavigationBarView.java,ModificationType.MODIFY,"@@ -90,7 +90,7 @@ public class NavigationBarView extends FrameLayout implements
     final static boolean DEBUG = false;
     final static String TAG = ""StatusBar/NavBarView"";
 
-    public static final String NAVIGATION_BAR_MENU_ARROW_KEYS =
+    private static final String NAVIGATION_BAR_MENU_ARROW_KEYS =
             ""lineagesystem:"" + LineageSettings.System.NAVIGATION_BAR_MENU_ARROW_KEYS;
 
     // slippery nav bar when everything is disabled, e.g. during setup
",1,1,
88,97769432dcd66b9f92d69f0c9b7a1c7065f6a8f3,NotificationPanelView.java,ModificationType.MODIFY,"@@ -157,9 +157,9 @@ public class NotificationPanelView extends PanelView implements
     static final String COUNTER_PANEL_OPEN_QS = ""panel_open_qs"";
     private static final String COUNTER_PANEL_OPEN_PEEK = ""panel_open_peek"";
 
-    public static final String STATUS_BAR_QUICK_QS_PULLDOWN =
+    private static final String STATUS_BAR_QUICK_QS_PULLDOWN =
             ""lineagesystem:"" + LineageSettings.System.STATUS_BAR_QUICK_QS_PULLDOWN;
-    public static final String DOUBLE_TAP_SLEEP_GESTURE =
+    private static final String DOUBLE_TAP_SLEEP_GESTURE =
             ""lineagesystem:"" + LineageSettings.System.DOUBLE_TAP_SLEEP_GESTURE;
 
     private static final Rect mDummyDirtyRect = new Rect(0, 0, 1, 1);
",2,2,
89,97769432dcd66b9f92d69f0c9b7a1c7065f6a8f3,StatusBar.java,ModificationType.MODIFY,"@@ -278,10 +278,11 @@ public class StatusBar extends SystemUI implements DemoMode,
 
     public static final String SCREEN_BRIGHTNESS_MODE =
             ""system:"" + Settings.System.SCREEN_BRIGHTNESS_MODE;
-    public static final String STATUS_BAR_BRIGHTNESS_CONTROL =
+
+    private static final String STATUS_BAR_BRIGHTNESS_CONTROL =
             ""lineagesystem:"" + LineageSettings.System.STATUS_BAR_BRIGHTNESS_CONTROL;
 
-    public static final String FORCE_SHOW_NAVBAR =
+    private static final String FORCE_SHOW_NAVBAR =
             ""lineagesystem:"" + LineageSettings.System.FORCE_SHOW_NAVBAR;
 
     private static final String BANNER_ACTION_CANCEL =
",3,2,
90,97769432dcd66b9f92d69f0c9b7a1c7065f6a8f3,Clock.java,ModificationType.MODIFY,"@@ -66,8 +66,8 @@ public class Clock extends TextView implements DemoMode, Tunable, CommandQueue.C
         DarkReceiver, ConfigurationListener {
 
     public static final String CLOCK_SECONDS = ""clock_seconds"";
-    public static final String CLOCK_STYLE = ""lineagesystem:status_bar_am_pm"";
 
+    private static final String CLOCK_STYLE = ""lineagesystem:status_bar_am_pm"";
     private static final String CLOCK_SUPER_PARCELABLE = ""clock_super_parcelable"";
     private static final String CURRENT_USER_ID = ""current_user_id"";
     private static final String VISIBLE_BY_POLICY = ""visible_by_policy"";
",1,1,
91,97769432dcd66b9f92d69f0c9b7a1c7065f6a8f3,TunerServiceImpl.java,ModificationType.MODIFY,"@@ -72,21 +72,11 @@ public class TunerServiceImpl extends TunerService {
 
     // Things that use the tunable infrastructure but are now real user settings and
     // shouldn't be reset with tuner settings.
+    // Do not add Lineage specific keys here as they are blacklisted automatically
     private static final String[] RESET_BLACKLIST = new String[] {
-            BatteryMeterView.STATUS_BAR_BATTERY_STYLE,
-            Clock.CLOCK_STYLE,
-            ClockController.CLOCK_POSITION,
-            EdgeBackGestureHandler.KEY_EDGE_LONG_SWIPE_ACTION,
-            NavigationBarView.NAVIGATION_BAR_MENU_ARROW_KEYS,
-            NotificationPanelView.DOUBLE_TAP_SLEEP_GESTURE,
-            NotificationPanelView.STATUS_BAR_QUICK_QS_PULLDOWN,
-            NotificationStackScrollLayout.LOCKSCREEN_TRANSLUCENT_NOTIFICATIONS_BG_ENABLED,
             QSTileHost.TILES_SETTING,
             Settings.Secure.DOZE_ALWAYS_ON,
-            StatusBar.FORCE_SHOW_NAVBAR,
             StatusBar.SCREEN_BRIGHTNESS_MODE,
-            StatusBar.STATUS_BAR_BRIGHTNESS_CONTROL,
-            VolumeDialogImpl.SETTING_VOLUME_PANEL_ON_LEFT,
     };
 
     private final Observer mObserver = new Observer();
",1,11,
92,97769432dcd66b9f92d69f0c9b7a1c7065f6a8f3,VolumeDialogImpl.java,ModificationType.MODIFY,"@@ -120,7 +120,7 @@ public class VolumeDialogImpl implements VolumeDialog,
     private static final long USER_ATTEMPT_GRACE_PERIOD = 1000;
     private static final int UPDATE_ANIMATION_DURATION = 80;
 
-    public static final String SETTING_VOLUME_PANEL_ON_LEFT =
+    private static final String SETTING_VOLUME_PANEL_ON_LEFT =
             ""lineagesecure:"" + LineageSettings.Secure.VOLUME_PANEL_ON_LEFT;
 
     static final int DIALOG_TIMEOUT_MILLIS = 3000;
",1,1,
93,5a3899b2fe276b148b8f57ef8d3040436b7966dc,QSPanel.java,ModificationType.MODIFY,"@@ -104,6 +104,7 @@ public class QSPanel extends LinearLayout implements Tunable, Callback, Brightne
     private Record mDetailRecord;
 
     private BrightnessMirrorController mBrightnessMirrorController;
+    private ImageView mMirrorAutoBrightnessView;
     private View mDivider;
 
     public QSPanel(Context context) {
@@ -232,6 +233,7 @@ public class QSPanel extends LinearLayout implements Tunable, Callback, Brightne
             updateViewVisibilityForTuningValue(mAutoBrightnessView, newValue);
         } else if (QS_SHOW_BRIGHTNESS_SLIDER.equals(key)) {
             updateViewVisibilityForTuningValue(mBrightnessView, newValue);
+            updateViewVisibilityForBrightnessMirrorIcon(newValue);
         }
     }
 
@@ -239,6 +241,18 @@ public class QSPanel extends LinearLayout implements Tunable, Callback, Brightne
         view.setVisibility(TunerService.parseIntegerSwitch(newValue, true) ? VISIBLE : GONE);
     }
 
+    private void updateViewVisibilityForBrightnessMirrorIcon(@Nullable String newValue) {
+        if (mMirrorAutoBrightnessView != null) {
+            mMirrorAutoBrightnessView.setVisibility(
+                    TunerService.parseIntegerSwitch(newValue, true) ? INVISIBLE : GONE);
+        } else if (mBrightnessMirrorController != null) {
+            mMirrorAutoBrightnessView = mBrightnessMirrorController.getMirror()
+                    .findViewById(R.id.brightness_icon);
+            mMirrorAutoBrightnessView.setVisibility(mAutoBrightnessView.getVisibility()
+                    == VISIBLE ? INVISIBLE : GONE);
+        }
+    }
+
     public void openDetails(String subPanel) {
         QSTile tile = getTile(subPanel);
         // If there's no tile with that name (as defined in QSFactoryImpl or other QSFactory),
@@ -266,6 +280,7 @@ public class QSPanel extends LinearLayout implements Tunable, Callback, Brightne
             mBrightnessMirrorController.addCallback(this);
         }
         updateBrightnessMirror();
+        updateViewVisibilityForBrightnessMirrorIcon(null);
     }
 
     @Override
",15,0,"QSPanel::onTuningChanged, QSPanel::setBrightnessMirror, QSPanel::updateViewVisibilityForBrightnessMirrorIcon"
94,e952e58aabea968dc6dde2f70f6cdc593ff0a442,LightsService.java,ModificationType.MODIFY,"@@ -76,6 +76,7 @@ public class LightsService extends SystemService {
                 // right now we just fall back to the old path through Lights brightessMode is
                 // anything but USER or the device shouldBeInLowPersistenceMode().
                 if (brightnessMode == BRIGHTNESS_MODE_USER && !shouldBeInLowPersistenceMode()
+                        && mId == LightsManager.LIGHT_ID_BACKLIGHT
                         && mSurfaceControlMaximumBrightness == 255) {
                     // TODO: the last check should be mSurfaceControlMaximumBrightness != 0; the
                     // reason we enforce 255 right now is to stay consistent with the old path. In
",1,0,LightsService::LightImpl::setBrightness
95,9d42c48c16bba2fcc836cbb68e2979ed9c0d1b23,QSPanel.java,ModificationType.MODIFY,"@@ -104,7 +104,6 @@ public class QSPanel extends LinearLayout implements Tunable, Callback, Brightne
     private Record mDetailRecord;
 
     private BrightnessMirrorController mBrightnessMirrorController;
-    private ImageView mMirrorAutoBrightnessView;
     private View mDivider;
 
     public QSPanel(Context context) {
@@ -233,7 +232,6 @@ public class QSPanel extends LinearLayout implements Tunable, Callback, Brightne
             updateViewVisibilityForTuningValue(mAutoBrightnessView, newValue);
         } else if (QS_SHOW_BRIGHTNESS_SLIDER.equals(key)) {
             updateViewVisibilityForTuningValue(mBrightnessView, newValue);
-            updateViewVisibilityForBrightnessMirrorIcon(newValue);
         }
     }
 
@@ -241,18 +239,6 @@ public class QSPanel extends LinearLayout implements Tunable, Callback, Brightne
         view.setVisibility(TunerService.parseIntegerSwitch(newValue, true) ? VISIBLE : GONE);
     }
 
-    private void updateViewVisibilityForBrightnessMirrorIcon(@Nullable String newValue) {
-        if (mMirrorAutoBrightnessView != null) {
-            mMirrorAutoBrightnessView.setVisibility(
-                    TunerService.parseIntegerSwitch(newValue, true) ? INVISIBLE : GONE);
-        } else if (mBrightnessMirrorController != null) {
-            mMirrorAutoBrightnessView = mBrightnessMirrorController.getMirror()
-                    .findViewById(R.id.brightness_icon);
-            mMirrorAutoBrightnessView.setVisibility(mAutoBrightnessView.getVisibility()
-                    == VISIBLE ? INVISIBLE : GONE);
-        }
-    }
-
     public void openDetails(String subPanel) {
         QSTile tile = getTile(subPanel);
         // If there's no tile with that name (as defined in QSFactoryImpl or other QSFactory),
@@ -280,7 +266,6 @@ public class QSPanel extends LinearLayout implements Tunable, Callback, Brightne
             mBrightnessMirrorController.addCallback(this);
         }
         updateBrightnessMirror();
-        updateViewVisibilityForBrightnessMirrorIcon(null);
     }
 
     @Override
",0,15,"QSPanel::onTuningChanged, QSPanel::setBrightnessMirror, QSPanel::updateViewVisibilityForBrightnessMirrorIcon"
96,9d42c48c16bba2fcc836cbb68e2979ed9c0d1b23,BrightnessMirrorController.java,ModificationType.MODIFY,"@@ -18,10 +18,13 @@ package com.android.systemui.statusbar.policy;
 
 import android.annotation.NonNull;
 import android.content.res.Resources;
+import android.os.UserHandle;
+import android.provider.Settings;
 import android.util.ArraySet;
 import android.view.LayoutInflater;
 import android.view.View;
 import android.widget.FrameLayout;
+import android.widget.ImageView;
 
 import com.android.internal.util.Preconditions;
 import com.android.systemui.R;
@@ -58,6 +61,7 @@ public class BrightnessMirrorController
         mBrightnessMirror.setVisibility(View.VISIBLE);
         mVisibilityCallback.accept(true);
         mNotificationPanel.setPanelAlpha(0, true /* animate */);
+        updateIcon();
     }
 
     public void hideMirror() {
@@ -133,4 +137,22 @@ public class BrightnessMirrorController
     public interface BrightnessMirrorListener {
         void onBrightnessMirrorReinflated(View brightnessMirror);
     }
+
+    private void updateIcon() {
+        ImageView iv = mBrightnessMirror.findViewById(R.id.brightness_icon);
+        boolean autoBrightnessAvailable = mBrightnessMirror.getContext().getResources().getBoolean(
+                com.android.internal.R.bool.config_automatic_brightness_available);
+        if (autoBrightnessAvailable) {
+            int automatic = Settings.System.getIntForUser(mBrightnessMirror.getContext()
+                            .getContentResolver(),
+                    Settings.System.SCREEN_BRIGHTNESS_MODE,
+                    Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL,
+                    UserHandle.USER_CURRENT);
+            boolean isAutomatic = automatic != Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL;
+            iv.setImageResource(isAutomatic
+                    ? com.android.systemui.R.drawable.ic_qs_brightness_auto_on
+                    : com.android.systemui.R.drawable.ic_qs_brightness_auto_off);
+            iv.setVisibility(View.VISIBLE);
+        }
+    }
 }
",22,0,"BrightnessMirrorController::updateIcon, BrightnessMirrorController::showMirror"
97,195653afa7a4b10c53184751b0ea20467cd24a8c,EdgeBackGestureHandler.java,ModificationType.MODIFY,"@@ -81,6 +81,9 @@ public class EdgeBackGestureHandler implements DisplayListener, TunerService.Tun
     private static final String KEY_EDGE_LONG_SWIPE_ACTION =
             ""lineagesystem:"" + LineageSettings.System.KEY_EDGE_LONG_SWIPE_ACTION;
 
+    private static final String KEY_GESTURE_BACK_EXCLUDE_TOP =
+            ""lineagesecure:"" + LineageSettings.Secure.GESTURE_BACK_EXCLUDE_TOP;
+
     private final IPinnedStackListener.Stub mImeChangedListener = new IPinnedStackListener.Stub() {
         @Override
         public void onListenerRegistered(IPinnedStackController controller) {
@@ -152,6 +155,8 @@ public class EdgeBackGestureHandler implements DisplayListener, TunerService.Tun
 
 
     private final int mNavBarHeight;
+    // User-limited area
+    private int mUserExclude;
 
     private final PointF mDownPoint = new PointF();
     private boolean mThresholdCrossed = false;
@@ -190,6 +195,7 @@ public class EdgeBackGestureHandler implements DisplayListener, TunerService.Tun
 
         final TunerService tunerService = Dependency.get(TunerService.class);
         tunerService.addTunable(this, KEY_EDGE_LONG_SWIPE_ACTION);
+        tunerService.addTunable(this, KEY_GESTURE_BACK_EXCLUDE_TOP);
 
         // Reduce the default touch slop to ensure that we can intercept the gesture
         // before the app starts to react to it.
@@ -338,8 +344,14 @@ public class EdgeBackGestureHandler implements DisplayListener, TunerService.Tun
     }
 
     private boolean isWithinTouchRegion(int x, int y) {
+        final int baseY = mDisplaySize.y - Math.max(mImeHeight, mNavBarHeight);
         // Disallow if over the IME
-        if (y > (mDisplaySize.y - Math.max(mImeHeight, mNavBarHeight))) {
+        if (y > baseY) {
+            return false;
+        }
+
+        // Disallow if over user exclusion area
+        if (mUserExclude > 0 && y < baseY - mUserExclude) {
             return false;
         }
 
@@ -511,6 +523,7 @@ public class EdgeBackGestureHandler implements DisplayListener, TunerService.Tun
                 .getDisplay(mDisplayId)
                 .getRealSize(mDisplaySize);
         updateLongSwipeWidth();
+        loadUserExclusion();
     }
 
     @Override
@@ -519,6 +532,8 @@ public class EdgeBackGestureHandler implements DisplayListener, TunerService.Tun
             mIsLongSwipeEnabled = newValue != null
                     && Action.fromIntSafe(Integer.parseInt(newValue)) != Action.NOTHING;
             updateLongSwipeWidth();
+        } else if (KEY_GESTURE_BACK_EXCLUDE_TOP.equals(key)) {
+            loadUserExclusion();
         }
     }
 
@@ -542,6 +557,19 @@ public class EdgeBackGestureHandler implements DisplayListener, TunerService.Tun
         InputManager.getInstance().injectInputEvent(ev, InputManager.INJECT_INPUT_EVENT_MODE_ASYNC);
     }
 
+    private void loadUserExclusion() {
+        if (mDisplaySize == null) return;
+
+        final int excludedPercentage = LineageSettings.Secure.getInt(mContext.getContentResolver(),
+                LineageSettings.Secure.GESTURE_BACK_EXCLUDE_TOP, 0);
+        if (excludedPercentage != 0) {
+            // Exclude a part of the top of the vertical display size
+            mUserExclude = mDisplaySize.y - mDisplaySize.y * excludedPercentage / 100;
+        } else {
+            mUserExclude = 0;
+        }
+    }
+
     public void setInsets(int leftInset, int rightInset) {
         mLeftInset = leftInset;
         mRightInset = rightInset;
",29,1,"EdgeBackGestureHandler::onTuningChanged, EdgeBackGestureHandler::EdgeBackGestureHandler, EdgeBackGestureHandler::loadUserExclusion, EdgeBackGestureHandler::isWithinTouchRegion, EdgeBackGestureHandler::updateDisplaySize"
98,a10c52e019722a6036aa4fc8028858807dcf07f8,ThemeOverlayController.java,ModificationType.MODIFY,"@@ -36,9 +36,12 @@ import android.util.Log;
 import com.android.systemui.Dependency;
 import com.android.systemui.R;
 import com.android.systemui.SystemUI;
+import com.android.systemui.tuner.TunerService;
 
 import com.google.android.collect.Sets;
 
+import lineageos.providers.LineageSettings;
+
 import org.json.JSONException;
 import org.json.JSONObject;
 
@@ -61,6 +64,36 @@ public class ThemeOverlayController extends SystemUI {
     private ThemeOverlayManager mThemeManager;
     private UserManager mUserManager;
 
+    static final String KEY_BERRY_BLACK_THEME =
+            ""lineagesystem:"" + LineageSettings.System.BERRY_BLACK_THEME;
+    static final String OVERLAY_BERRY_BLACK_THEME =
+            ""org.lineageos.overlay.customization.blacktheme"";
+    private final TunerService.Tunable mTunable =
+            new TunerService.Tunable() {
+                @Override
+                public void onTuningChanged(String key, String newValue) {
+                    if (KEY_BERRY_BLACK_THEME.equals(key)) {
+                        applyBlackTheme(TunerService.parseIntegerSwitch(newValue, false));
+                    }
+                }
+            };
+
+    private OverlayManager mOverlayManager;
+
+    private void applyBlackTheme(boolean state) {
+        UserHandle userId = UserHandle.of(ActivityManager.getCurrentUser());
+        try {
+            mOverlayManager.setEnabled(OVERLAY_BERRY_BLACK_THEME, state, userId);
+            if (DEBUG) {
+                Log.d(TAG, ""applyBlackTheme: overlayPackage=""
+                        + OVERLAY_BERRY_BLACK_THEME + "" userId="" + userId);
+            }
+        } catch (Exception e) {
+            Log.e(TAG, ""Failed to "" + (state ? ""enable"" : ""disable"")
+                    + "" overlay "" + OVERLAY_BERRY_BLACK_THEME + "" for user "" + userId);
+        }
+    }
+
     @Override
     public void start() {
         if (DEBUG) Log.d(TAG, ""Start"");
@@ -94,6 +127,8 @@ public class ThemeOverlayController extends SystemUI {
                     }
                 },
                 UserHandle.USER_ALL);
+        mOverlayManager = mContext.getSystemService(OverlayManager.class);
+        Dependency.get(TunerService.class).addTunable(mTunable, KEY_BERRY_BLACK_THEME);
     }
 
     private void updateThemeOverlays() {
",35,0,"ThemeOverlayController::Tunable, ThemeOverlayController::start, ThemeOverlayController::applyBlackTheme"
99,783a129386d1374e5cc280cb7809e035a8b1edaf,GlobalScreenshot.java,ModificationType.MODIFY,"@@ -112,7 +112,6 @@ import libcore.io.IoUtils;
 
 import java.io.IOException;
 import java.io.OutputStream;
-import java.io.UnsupportedEncodingException;
 import java.text.DateFormat;
 import java.text.SimpleDateFormat;
 import java.util.ArrayList;
@@ -203,18 +202,8 @@ class SaveImageInBackgroundTask extends AsyncTask<Void, Void, Void> {
         CharSequence appName = getRunningActivityName(context);
         boolean onKeyguard = context.getSystemService(KeyguardManager.class).isKeyguardLocked();
         if (!onKeyguard && appName != null) {
-            String appNameString = appName.toString();
-            try {
-                // With some languages like Virgin Islands English, the Settings app gets a weird
-                // long name and some special voodoo chars, so we convert the string to utf-8 to get
-                // a  char instead, easy to remove it then
-                final String temp = new String(appNameString.getBytes(""ISO-8859-15""), ""UTF-8"");
-                appNameString = temp.replaceAll(""[]+"", """");
-            } catch (UnsupportedEncodingException e) {
-                // Do nothing
-            }
-            // Now replace all spaces and special chars with an underscore
-            appNameString = appNameString.replaceAll(""[\\\\/:*?\""<>|\\s]+"", ""_"");
+            // Replace all spaces and special chars with an underscore
+            String appNameString = appName.toString().replaceAll(""[\\\\/:*?\""<>|\\s]+"", ""_"");
             mImageFileName = String.format(SCREENSHOT_FILE_NAME_TEMPLATE_APPNAME,
                     imageDate, appNameString);
         } else {
",2,13,SaveImageInBackgroundTask::SaveImageInBackgroundTask
100,4dcd7d21bd1cc81f7f9db7e196d4de2300bb88bf,NavigationBarInflaterView.java,ModificationType.MODIFY,"@@ -16,11 +16,15 @@ package com.android.systemui.statusbar.phone;
 
 import static android.view.ViewGroup.LayoutParams.MATCH_PARENT;
 import static android.view.WindowManagerPolicyConstants.NAV_BAR_MODE_3BUTTON;
+import static android.view.WindowManagerPolicyConstants.NAV_BAR_MODE_GESTURAL;
 
 import android.annotation.Nullable;
+import android.app.ActivityManager;
 import android.content.Context;
+import android.content.om.OverlayManager;
 import android.content.res.Configuration;
 import android.graphics.drawable.Icon;
+import android.os.UserHandle;
 import android.util.AttributeSet;
 import android.util.Log;
 import android.util.SparseArray;
@@ -41,6 +45,8 @@ import com.android.systemui.statusbar.phone.ReverseLinearLayout.ReverseRelativeL
 import com.android.systemui.statusbar.policy.KeyButtonView;
 import com.android.systemui.tuner.TunerService;
 
+import lineageos.providers.LineageSettings;
+
 import java.util.Objects;
 
 public class NavigationBarInflaterView extends FrameLayout
@@ -80,6 +86,11 @@ public class NavigationBarInflaterView extends FrameLayout
     private static final String ABSOLUTE_SUFFIX = ""A"";
     private static final String ABSOLUTE_VERTICAL_CENTERED_SUFFIX = ""C"";
 
+    private static final String KEY_NAVIGATION_HINT =
+            ""lineagesystem:"" + LineageSettings.System.NAVIGATION_BAR_HINT;
+    private static final String OVERLAY_NAVIGATION_HIDE_HINT =
+            ""org.lineageos.overlay.customization.navbar.nohint"";
+
     protected LayoutInflater mLayoutInflater;
     protected LayoutInflater mLandscapeInflater;
 
@@ -101,6 +112,7 @@ public class NavigationBarInflaterView extends FrameLayout
     private int mNavBarMode = NAV_BAR_MODE_3BUTTON;
 
     private boolean mInverseLayout;
+    private boolean mIsHintEnabled;
 
     public NavigationBarInflaterView(Context context, AttributeSet attrs) {
         super(context, attrs);
@@ -143,12 +155,16 @@ public class NavigationBarInflaterView extends FrameLayout
                 : mOverviewProxyService.shouldShowSwipeUpUI()
                         ? R.string.config_navBarLayoutQuickstep
                         : R.string.config_navBarLayout;
+        if (!mIsHintEnabled && defaultResource == R.string.config_navBarLayoutHandle) {
+            return getContext().getString(defaultResource).replace(""home_handle"", """");
+        }
         return getContext().getString(defaultResource);
     }
 
     @Override
     public void onNavigationModeChanged(int mode) {
         mNavBarMode = mode;
+        updateHint();
         onLikelyDefaultLayoutChange();
     }
 
@@ -156,6 +172,7 @@ public class NavigationBarInflaterView extends FrameLayout
     protected void onAttachedToWindow() {
         super.onAttachedToWindow();
         Dependency.get(TunerService.class).addTunable(this, NAV_BAR_INVERSE);
+        Dependency.get(TunerService.class).addTunable(this, KEY_NAVIGATION_HINT);
     }
 
     @Override
@@ -170,6 +187,10 @@ public class NavigationBarInflaterView extends FrameLayout
         if (NAV_BAR_INVERSE.equals(key)) {
             mInverseLayout = TunerService.parseIntegerSwitch(newValue, false);
             updateLayoutInversion();
+        } else if (KEY_NAVIGATION_HINT.equals(key)) {
+            mIsHintEnabled = TunerService.parseIntegerSwitch(newValue, true);
+            updateHint();
+            onLikelyDefaultLayoutChange();
         }
     }
 
@@ -242,6 +263,18 @@ public class NavigationBarInflaterView extends FrameLayout
         }
     }
 
+    private void updateHint() {
+        final boolean state = mNavBarMode == NAV_BAR_MODE_GESTURAL && !mIsHintEnabled;
+        UserHandle userId = UserHandle.of(ActivityManager.getCurrentUser());
+        try {
+            mContext.getSystemService(OverlayManager.class).setEnabled(
+                    OVERLAY_NAVIGATION_HIDE_HINT, state, userId);
+        } catch (Exception e) {
+            Log.e(TAG, ""Failed to "" + (state ? ""enable"" : ""disable"")
+                    + "" overlay "" + OVERLAY_NAVIGATION_HIDE_HINT + "" for user "" + userId);
+        }
+    }
+
     private void initiallyFill(ButtonDispatcher buttonDispatcher) {
         addAll(buttonDispatcher, mHorizontal.findViewById(R.id.ends_group));
         addAll(buttonDispatcher, mHorizontal.findViewById(R.id.center_group));
",33,0,"NavigationBarInflaterView::onTuningChanged, NavigationBarInflaterView::onAttachedToWindow, NavigationBarInflaterView::getDefaultLayout, NavigationBarInflaterView::updateHint, NavigationBarInflaterView::onNavigationModeChanged"
101,7439406bbfef0327ec4f7df2411b69564ddb7074,ProgressBar.java,ModificationType.MODIFY,"@@ -16,6 +16,8 @@
 
 package android.widget;
 
+import android.animation.Animator;
+import android.animation.AnimatorListenerAdapter;
 import android.animation.ObjectAnimator;
 import android.annotation.InterpolatorRes;
 import android.annotation.NonNull;
@@ -246,6 +248,8 @@ public class ProgressBar extends View {
 
     private AccessibilityEventSender mAccessibilityEventSender;
 
+    private ObjectAnimator mLastProgressAnimator;
+
     /**
      * Create a new progress bar with range 0...100 and initial progress of 0.
      * @param context the application environment
@@ -1544,8 +1548,19 @@ public class ProgressBar extends View {
             animator.setAutoCancel(true);
             animator.setDuration(PROGRESS_ANIM_DURATION);
             animator.setInterpolator(PROGRESS_ANIM_INTERPOLATOR);
+            animator.addListener(new AnimatorListenerAdapter() {
+                @Override
+                public void onAnimationEnd(Animator animation) {
+                    mLastProgressAnimator = null;
+                }
+            });
             animator.start();
+            mLastProgressAnimator = animator;
         } else {
+            if (isPrimary && mLastProgressAnimator != null) {
+                mLastProgressAnimator.cancel();
+                mLastProgressAnimator = null;
+            }
             setVisualProgress(id, scale);
         }
 
",15,0,ProgressBar::doRefreshProgress
102,13433cc6925eced1f369d07b214540a2685822ce,TaskSnapshotPersister.java,ModificationType.MODIFY,"@@ -28,12 +28,14 @@ import android.graphics.Bitmap;
 import android.graphics.Bitmap.Config;
 import android.os.Process;
 import android.os.SystemClock;
+import android.os.UserManagerInternal;
 import android.util.ArraySet;
 import android.util.Slog;
 
 import com.android.internal.annotations.GuardedBy;
 import com.android.internal.annotations.VisibleForTesting;
 import com.android.internal.os.AtomicFile;
+import com.android.server.LocalServices;
 import com.android.server.wm.nano.WindowManagerProtos.TaskSnapshotProto;
 
 import java.io.File;
@@ -73,6 +75,7 @@ class TaskSnapshotPersister {
     private boolean mStarted;
     private final Object mLock = new Object();
     private final DirectoryResolver mDirectoryResolver;
+    private final UserManagerInternal mUserManagerInternal;
     private final float mReducedScale;
 
     /**
@@ -84,6 +87,7 @@ class TaskSnapshotPersister {
 
     TaskSnapshotPersister(WindowManagerService service, DirectoryResolver resolver) {
         mDirectoryResolver = resolver;
+        mUserManagerInternal = LocalServices.getService(UserManagerInternal.class);
         if (service.mLowRamTaskSnapshotsAndRecents) {
             // Use very low res snapshots if we are using Go version of recents.
             mReducedScale = LOW_RAM_RECENTS_REDUCED_SCALE;
@@ -172,7 +176,7 @@ class TaskSnapshotPersister {
                     return;
                 }
             }
-            SystemClock.sleep(100);
+            SystemClock.sleep(DELAY_MS);
         }
     }
 
@@ -218,7 +222,7 @@ class TaskSnapshotPersister {
 
     private boolean createDirectory(int userId) {
         final File dir = getDirectory(userId);
-        return dir.exists() || dir.mkdirs();
+        return dir.exists() || dir.mkdir();
     }
 
     private void deleteSnapshot(int taskId, int userId) {
@@ -243,18 +247,26 @@ class TaskSnapshotPersister {
             android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
             while (true) {
                 WriteQueueItem next;
+                boolean isReadyToWrite = false;
                 synchronized (mLock) {
                     if (mPaused) {
                         next = null;
                     } else {
                         next = mWriteQueue.poll();
                         if (next != null) {
-                            next.onDequeuedLocked();
+                            if (next.isReady()) {
+                                isReadyToWrite = true;
+                                next.onDequeuedLocked();
+                            } else {
+                                mWriteQueue.addLast(next);
+                            }
                         }
                     }
                 }
                 if (next != null) {
-                    next.write();
+                    if (isReadyToWrite) {
+                        next.write();
+                    }
                     SystemClock.sleep(DELAY_MS);
                 }
                 synchronized (mLock) {
@@ -274,6 +286,13 @@ class TaskSnapshotPersister {
     };
 
     private abstract class WriteQueueItem {
+        /**
+         * @return {@code true} if item is ready to have {@link WriteQueueItem#write} called
+         */
+        boolean isReady() {
+            return true;
+        }
+
         abstract void write();
 
         /**
@@ -312,6 +331,11 @@ class TaskSnapshotPersister {
             mStoreQueueItems.remove(this);
         }
 
+        @Override
+        boolean isReady() {
+            return mUserManagerInternal.isUserUnlocked(mUserId);
+        }
+
         @Override
         void write() {
             if (!createDirectory(mUserId)) {
",28,4,"TaskSnapshotPersister::TaskSnapshotPersister, TaskSnapshotPersister::createDirectory, TaskSnapshotPersister::StoreWriteQueueItem::isReady, TaskSnapshotPersister::WriteQueueItem::isReady, TaskSnapshotPersister::Thread, TaskSnapshotPersister::waitForQueueEmpty"
103,13433cc6925eced1f369d07b214540a2685822ce,TaskSnapshotPersisterTestBase.java,ModificationType.MODIFY,"@@ -23,6 +23,9 @@ import static android.graphics.GraphicBuffer.USAGE_SW_READ_RARELY;
 
 import static androidx.test.platform.app.InstrumentationRegistry.getInstrumentation;
 
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
 import android.app.ActivityManager.TaskSnapshot;
 import android.content.ComponentName;
 import android.graphics.Canvas;
@@ -32,9 +35,14 @@ import android.graphics.GraphicBuffer;
 import android.graphics.PixelFormat;
 import android.graphics.Rect;
 import android.os.UserManager;
+import android.os.UserManagerInternal;
+
+import com.android.server.LocalServices;
 
 import org.junit.After;
+import org.junit.AfterClass;
 import org.junit.Before;
+import org.junit.BeforeClass;
 
 import java.io.File;
 
@@ -50,10 +58,26 @@ class TaskSnapshotPersisterTestBase extends WindowTestsBase {
     TaskSnapshotLoader mLoader;
     int mTestUserId;
 
+    @BeforeClass
+    public static void setUpOnce() {
+        final UserManagerInternal userManager = mock(UserManagerInternal.class);
+        LocalServices.addService(UserManagerInternal.class, userManager);
+    }
+
+    @AfterClass
+    public static void tearDownOnce() {
+        LocalServices.removeServiceForTest(UserManagerInternal.class);
+    }
+
     @Before
     public void setUp() {
         final UserManager um = UserManager.get(getInstrumentation().getTargetContext());
         mTestUserId = um.getUserHandle();
+
+        final UserManagerInternal userManagerInternal =
+                LocalServices.getService(UserManagerInternal.class);
+        when(userManagerInternal.isUserUnlocked(mTestUserId)).thenReturn(true);
+
         mPersister = new TaskSnapshotPersister(mWm, userId -> FILES_DIR);
         mLoader = new TaskSnapshotLoader(mPersister);
         mPersister.start();
",24,0,"TaskSnapshotPersisterTestBase::tearDownOnce, TaskSnapshotPersisterTestBase::setUp, TaskSnapshotPersisterTestBase::setUpOnce"
104,3527645dbad25b71875060e17dfa4571ffa7c222,BrightnessMirrorController.java,ModificationType.MODIFY,"@@ -27,9 +27,13 @@ import android.widget.FrameLayout;
 import android.widget.ImageView;
 
 import com.android.internal.util.Preconditions;
+import com.android.systemui.Dependency;
 import com.android.systemui.R;
 import com.android.systemui.statusbar.phone.NotificationPanelView;
 import com.android.systemui.statusbar.phone.StatusBarWindowView;
+import com.android.systemui.tuner.TunerService;
+
+import lineageos.providers.LineageSettings;
 
 import java.util.function.Consumer;
 
@@ -39,12 +43,26 @@ import java.util.function.Consumer;
 public class BrightnessMirrorController
         implements CallbackController<BrightnessMirrorController.BrightnessMirrorListener> {
 
+    private static final String QS_SHOW_AUTO_BRIGHTNESS =
+            ""lineagesecure:"" + LineageSettings.Secure.QS_SHOW_AUTO_BRIGHTNESS;
+
     private final StatusBarWindowView mStatusBarWindow;
     private final Consumer<Boolean> mVisibilityCallback;
     private final NotificationPanelView mNotificationPanel;
     private final ArraySet<BrightnessMirrorListener> mBrightnessMirrorListeners = new ArraySet<>();
     private final int[] mInt2Cache = new int[2];
     private View mBrightnessMirror;
+    private boolean mShouldShowAutoBrightness;
+
+    private final TunerService.Tunable mTunable = new TunerService.Tunable() {
+            @Override
+            public void onTuningChanged(String key, String newValue) {
+                if (QS_SHOW_AUTO_BRIGHTNESS.equals(key)) {
+                    mShouldShowAutoBrightness = TunerService.parseIntegerSwitch(newValue, true);
+                    updateIcon();
+                }
+            }
+        };
 
     public BrightnessMirrorController(StatusBarWindowView statusBarWindow,
             @NonNull Consumer<Boolean> visibilityCallback) {
@@ -55,6 +73,8 @@ public class BrightnessMirrorController
             mBrightnessMirror.setVisibility(View.INVISIBLE);
         });
         mVisibilityCallback = visibilityCallback;
+
+        Dependency.get(TunerService.class).addTunable(mTunable, QS_SHOW_AUTO_BRIGHTNESS);
     }
 
     public void showMirror() {
@@ -142,7 +162,7 @@ public class BrightnessMirrorController
         ImageView iv = mBrightnessMirror.findViewById(R.id.brightness_icon);
         boolean autoBrightnessAvailable = mBrightnessMirror.getContext().getResources().getBoolean(
                 com.android.internal.R.bool.config_automatic_brightness_available);
-        if (autoBrightnessAvailable) {
+        if (autoBrightnessAvailable && mShouldShowAutoBrightness) {
             int automatic = Settings.System.getIntForUser(mBrightnessMirror.getContext()
                             .getContentResolver(),
                     Settings.System.SCREEN_BRIGHTNESS_MODE,
@@ -153,6 +173,8 @@ public class BrightnessMirrorController
                     ? com.android.systemui.R.drawable.ic_qs_brightness_auto_on
                     : com.android.systemui.R.drawable.ic_qs_brightness_auto_off);
             iv.setVisibility(View.VISIBLE);
+        } else {
+            iv.setVisibility(View.GONE);
         }
     }
 }
",23,1,"BrightnessMirrorController::Tunable, BrightnessMirrorController::BrightnessMirrorController, BrightnessMirrorController::updateIcon"
105,969002a1193a17dc88abe5ab9ad6fcfbe3f4c9a3,MtpStorage.java,ModificationType.MODIFY,"@@ -37,7 +37,7 @@ public class MtpStorage {
 
     public MtpStorage(StorageVolume volume, int storageId) {
         mStorageId = storageId;
-        mPath = volume.getInternalPath();
+        mPath = volume.getPath();
         mDescription = volume.getDescription(null);
         mRemovable = volume.isRemovable();
         mMaxFileSize = volume.getMaxFileSize();
",1,1,MtpStorage::MtpStorage
106,0dcd7fee60e41f937c8b52753279f8d70b2e0748,FODCircleView.java,ModificationType.MODIFY,"@@ -74,8 +74,6 @@ public class FODCircleView extends ImageView {
     private boolean mIsShowing;
     private boolean mIsCircleShowing;
 
-    private float mCurrentDimAmount = 0.0f;
-
     private Handler mHandler;
 
     private LockPatternUtils mLockPatternUtils;
@@ -194,16 +192,6 @@ public class FODCircleView extends ImageView {
 
         mUpdateMonitor = KeyguardUpdateMonitor.getInstance(context);
         mUpdateMonitor.registerCallback(mMonitorCallback);
-
-        getViewTreeObserver().addOnGlobalLayoutListener(() -> {
-            float drawingDimAmount = mParams.dimAmount;
-            if (mCurrentDimAmount == 0.0f && drawingDimAmount > 0.0f) {
-                dispatchPress();
-                mCurrentDimAmount = drawingDimAmount;
-            } else if (mCurrentDimAmount > 0.0f && drawingDimAmount == 0.0f) {
-                mCurrentDimAmount = drawingDimAmount;
-            }
-        });
     }
 
     @Override
@@ -297,6 +285,7 @@ public class FODCircleView extends ImageView {
 
         setDim(true);
         updateAlpha();
+        dispatchPress();
 
         mPaintFingerprint.setColor(mColor);
         setImageDrawable(null);
",1,12,"FODCircleView::showCircle, FODCircleView::FODCircleView"
107,dcfcf1f5078f4adb8aac984a48011955872bbc3a,FODCircleView.java,ModificationType.MODIFY,"@@ -57,8 +57,10 @@ public class FODCircleView extends ImageView {
     private final int mDreamingMaxOffset;
     private final int mNavigationBarSize;
     private final boolean mShouldBoostBrightness;
+    private final Paint mPaintFingerprintBackground = new Paint();
     private final Paint mPaintFingerprint = new Paint();
     private final WindowManager.LayoutParams mParams = new WindowManager.LayoutParams();
+    private final WindowManager.LayoutParams mPressedParams = new WindowManager.LayoutParams();
     private final WindowManager mWindowManager;
 
     private IFingerprintInscreen mFingerprintInscreenDaemon;
@@ -71,11 +73,12 @@ public class FODCircleView extends ImageView {
 
     private boolean mIsBouncer;
     private boolean mIsDreaming;
-    private boolean mIsShowing;
     private boolean mIsCircleShowing;
 
     private Handler mHandler;
 
+    private final ImageView mPressedView;
+
     private LockPatternUtils mLockPatternUtils;
 
     private Timer mBurnInProtectionTimer;
@@ -158,10 +161,12 @@ public class FODCircleView extends ImageView {
         Resources res = context.getResources();
 
         mColor = res.getColor(R.color.config_fodColor);
-        mColorBackground = res.getColor(R.color.config_fodColorBackground);
-
+        mPaintFingerprint.setColor(mColor);
         mPaintFingerprint.setAntiAlias(true);
-        mPaintFingerprint.setColor(mColorBackground);
+
+        mColorBackground = res.getColor(R.color.config_fodColorBackground);
+        mPaintFingerprintBackground.setColor(mColorBackground);
+        mPaintFingerprintBackground.setAntiAlias(true);
 
         mWindowManager = context.getSystemService(WindowManager.class);
 
@@ -175,14 +180,28 @@ public class FODCircleView extends ImageView {
         mParams.width = mSize;
         mParams.format = PixelFormat.TRANSLUCENT;
 
-        mParams.setTitle(""Fingerprint on display"");
         mParams.packageName = ""android"";
         mParams.type = WindowManager.LayoutParams.TYPE_DISPLAY_OVERLAY;
         mParams.flags = WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE |
-                WindowManager.LayoutParams.FLAG_DIM_BEHIND |
                 WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN;
         mParams.gravity = Gravity.TOP | Gravity.LEFT;
 
+        mPressedParams.copyFrom(mParams);
+        mPressedParams.flags |= WindowManager.LayoutParams.FLAG_DIM_BEHIND;
+
+        mParams.setTitle(""Fingerprint on display"");
+        mPressedParams.setTitle(""Fingerprint on display.touched"");
+
+        mPressedView = new ImageView(context)  {
+            @Override
+            protected void onDraw(Canvas canvas) {
+                if (mIsCircleShowing) {
+                    canvas.drawCircle(mSize / 2, mSize / 2, mSize / 2.0f, mPaintFingerprint);
+                }
+                super.onDraw(canvas);
+            }
+        };
+
         mWindowManager.addView(this, mParams);
 
         updatePosition();
@@ -196,7 +215,9 @@ public class FODCircleView extends ImageView {
 
     @Override
     protected void onDraw(Canvas canvas) {
-        canvas.drawCircle(mSize / 2, mSize / 2, mSize / 2.0f, mPaintFingerprint);
+        if (!mIsCircleShowing) {
+            canvas.drawCircle(mSize / 2, mSize / 2, mSize / 2.0f, mPaintFingerprintBackground);
+        }
         super.onDraw(canvas);
     }
 
@@ -284,10 +305,8 @@ public class FODCircleView extends ImageView {
         setKeepScreenOn(true);
 
         setDim(true);
-        updateAlpha();
         dispatchPress();
 
-        mPaintFingerprint.setColor(mColor);
         setImageDrawable(null);
         invalidate();
     }
@@ -295,14 +314,11 @@ public class FODCircleView extends ImageView {
     public void hideCircle() {
         mIsCircleShowing = false;
 
-        mPaintFingerprint.setColor(mColorBackground);
         setImageResource(R.drawable.fod_icon_default);
         invalidate();
 
         dispatchRelease();
-
         setDim(false);
-        updateAlpha();
 
         setKeepScreenOn(false);
     }
@@ -318,8 +334,6 @@ public class FODCircleView extends ImageView {
             return;
         }
 
-        mIsShowing = true;
-
         updatePosition();
 
         dispatchShow();
@@ -327,19 +341,13 @@ public class FODCircleView extends ImageView {
     }
 
     public void hide() {
-        mIsShowing = false;
-
         setVisibility(View.GONE);
         hideCircle();
         dispatchHide();
     }
 
     private void updateAlpha() {
-        if (mIsCircleShowing) {
-            setAlpha(1.0f);
-        } else {
-            setAlpha(mIsDreaming ? 0.5f : 1.0f);
-        }
+        setAlpha(mIsDreaming ? 0.5f : 1.0f);
     }
 
     private void updatePosition() {
@@ -349,33 +357,41 @@ public class FODCircleView extends ImageView {
         defaultDisplay.getRealSize(size);
 
         int rotation = defaultDisplay.getRotation();
+        int x, y;
         switch (rotation) {
             case Surface.ROTATION_0:
-                mParams.x = mPositionX;
-                mParams.y = mPositionY;
+                x = mPositionX;
+                y = mPositionY;
                 break;
             case Surface.ROTATION_90:
-                mParams.x = mPositionY;
-                mParams.y = mPositionX;
+                x = mPositionY;
+                y = mPositionX;
                 break;
             case Surface.ROTATION_180:
-                mParams.x = mPositionX;
-                mParams.y = size.y - mPositionY - mSize;
+                x = mPositionX;
+                y = size.y - mPositionY - mSize;
                 break;
             case Surface.ROTATION_270:
-                mParams.x = size.x - mPositionY - mSize - mNavigationBarSize;
-                mParams.y = mPositionX;
+                x = size.x - mPositionY - mSize - mNavigationBarSize;
+                y = mPositionX;
                 break;
             default:
                 throw new IllegalArgumentException(""Unknown rotation: "" + rotation);
         }
 
+        mPressedParams.x = mParams.x = x;
+        mPressedParams.y = mParams.y = y;
+
         if (mIsDreaming) {
             mParams.x += mDreamingOffsetX;
             mParams.y += mDreamingOffsetY;
         }
 
         mWindowManager.updateViewLayout(this, mParams);
+
+        if (mPressedView.getParent() != null) {
+            mWindowManager.updateViewLayout(mPressedView, mPressedParams);
+        }
     }
 
     private void setDim(boolean dim) {
@@ -392,16 +408,22 @@ public class FODCircleView extends ImageView {
             }
 
             if (mShouldBoostBrightness) {
-                mParams.screenBrightness = 1.0f;
+                mPressedParams.screenBrightness = 1.0f;
             }
 
-            mParams.dimAmount = dimAmount / 255.0f;
+            mPressedParams.dimAmount = dimAmount / 255.0f;
+            if (mPressedView.getParent() == null) {
+                mWindowManager.addView(mPressedView, mPressedParams);
+            } else {
+                mWindowManager.updateViewLayout(mPressedView, mPressedParams);
+            }
         } else {
-            mParams.screenBrightness = 0.0f;
-            mParams.dimAmount = 0.0f;
+            mPressedParams.screenBrightness = 0.0f;
+            mPressedParams.dimAmount = 0.0f;
+            if (mPressedView.getParent() != null) {
+                mWindowManager.removeView(mPressedView);
+            }
         }
-
-        mWindowManager.updateViewLayout(this, mParams);
     }
 
     private boolean isPinOrPattern(int userId) {
",57,35,"FODCircleView::updateAlpha, FODCircleView::updatePosition, FODCircleView::hideCircle, FODCircleView::hide, FODCircleView::showCircle, FODCircleView::setDim, FODCircleView::show, FODCircleView::onDraw, FODCircleView::FODCircleView"
108,db6a24b3d61dd7fc9f3ebf4587f143ff8f242b50,QSAnimator.java,ModificationType.MODIFY,"@@ -31,6 +31,8 @@ import com.android.systemui.qs.TouchAnimator.Listener;
 import com.android.systemui.tuner.TunerService;
 import com.android.systemui.tuner.TunerService.Tunable;
 
+import lineageos.providers.LineageSettings;
+
 import java.util.ArrayList;
 import java.util.Collection;
 
@@ -44,6 +46,8 @@ public class QSAnimator implements Callback, PageListener, Listener, OnLayoutCha
 
     public static final float EXPANDED_TILE_DELAY = .86f;
 
+    private static final String QS_SHOW_BRIGHTNESS_SLIDER =
+            ""lineagesecure:"" + LineageSettings.Secure.QS_SHOW_BRIGHTNESS_SLIDER;
 
     private final ArrayList<View> mAllViews = new ArrayList<>();
     /**
@@ -75,6 +79,8 @@ public class QSAnimator implements Callback, PageListener, Listener, OnLayoutCha
     private QSTileHost mHost;
     private boolean mShowCollapsedOnKeyguard;
 
+    private boolean mIsQuickQsBrightnessEnabled;
+
     public QSAnimator(QS qs, QuickQSPanel quickPanel, QSPanel panel) {
         mQs = qs;
         mQuickQsPanel = quickPanel;
@@ -135,6 +141,7 @@ public class QSAnimator implements Callback, PageListener, Listener, OnLayoutCha
     public void onViewAttachedToWindow(View v) {
         Dependency.get(TunerService.class).addTunable(this, ALLOW_FANCY_ANIMATION,
                 MOVE_FULL_ROWS, QuickQSPanel.NUM_QUICK_TILES);
+        Dependency.get(TunerService.class).addTunable(this, QS_SHOW_BRIGHTNESS_SLIDER);
     }
 
     @Override
@@ -157,6 +164,13 @@ public class QSAnimator implements Callback, PageListener, Listener, OnLayoutCha
         } else if (QuickQSPanel.NUM_QUICK_TILES.equals(key)) {
             mNumQuickTiles = mQuickQsPanel.getNumQuickTiles(mQs.getContext());
             clearAnimationState();
+        } else if (QS_SHOW_BRIGHTNESS_SLIDER.equals(key)) {
+            try {
+                mIsQuickQsBrightnessEnabled = Integer.parseInt(newValue) > 1;
+            } catch (NumberFormatException e) {
+                // Catches exception as newValue may be null or malformed.
+                mIsQuickQsBrightnessEnabled = false;
+            }
         }
         updateAnimators();
     }
@@ -273,7 +287,7 @@ public class QSAnimator implements Callback, PageListener, Listener, OnLayoutCha
             if (brightness != null) {
                 firstPageBuilder.addFloat(brightness, ""translationY"", heightDiff, 0);
                 mBrightnessAnimator = new TouchAnimator.Builder()
-                        .addFloat(brightness, ""alpha"", 0, 1)
+                        .addFloat(brightness, ""alpha"", mIsQuickQsBrightnessEnabled ? 1 : 0, 1)
                         .setStartDelay(.5f)
                         .build();
                 mAllViews.add(brightness);
",15,1,"QSAnimator::onViewAttachedToWindow, QSAnimator::onTuningChanged, QSAnimator::updateAnimators"
109,db6a24b3d61dd7fc9f3ebf4587f143ff8f242b50,QuickStatusBarHeader.java,ModificationType.MODIFY,"@@ -70,6 +70,7 @@ import com.android.systemui.privacy.PrivacyItem;
 import com.android.systemui.privacy.PrivacyItemController;
 import com.android.systemui.privacy.PrivacyItemControllerKt;
 import com.android.systemui.qs.QSDetail.Callback;
+import com.android.systemui.settings.BrightnessController;
 import com.android.systemui.statusbar.phone.PhoneStatusBarView;
 import com.android.systemui.statusbar.phone.StatusBarIconController;
 import com.android.systemui.statusbar.phone.StatusBarIconController.TintedIconManager;
@@ -80,6 +81,8 @@ import com.android.systemui.statusbar.policy.NextAlarmController;
 import com.android.systemui.statusbar.policy.ZenModeController;
 import com.android.systemui.tuner.TunerService;
 
+import lineageos.providers.LineageSettings;
+
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Locale;
@@ -105,6 +108,11 @@ public class QuickStatusBarHeader extends RelativeLayout implements
     private static final int TOOLTIP_NOT_YET_SHOWN_COUNT = 0;
     public static final int MAX_TOOLTIP_SHOWN_COUNT = 2;
 
+    private static final String QS_SHOW_AUTO_BRIGHTNESS =
+            ""lineagesecure:"" + LineageSettings.Secure.QS_SHOW_AUTO_BRIGHTNESS;
+    private static final String QS_SHOW_BRIGHTNESS_SLIDER =
+            ""lineagesecure:"" + LineageSettings.Secure.QS_SHOW_BRIGHTNESS_SLIDER;
+
     private final Handler mHandler = new Handler();
     private final NextAlarmController mAlarmController;
     private final ZenModeController mZenController;
@@ -148,6 +156,11 @@ public class QuickStatusBarHeader extends RelativeLayout implements
     private BatteryMeterView mBatteryRemainingIcon;
     private boolean mPermissionsHubEnabled;
 
+    private View mQuickQsBrightness;
+    private BrightnessController mBrightnessController;
+    private boolean mIsQuickQsBrightnessEnabled;
+    private boolean mIsQsAutoBrightnessEnabled;
+
     private PrivacyItemController mPrivacyItemController;
 
     private final BroadcastReceiver mRingerReceiver = new BroadcastReceiver() {
@@ -210,6 +223,11 @@ public class QuickStatusBarHeader extends RelativeLayout implements
         iconContainer.setShouldRestrictIcons(false);
         mIconManager = new TintedIconManager(iconContainer);
 
+        mQuickQsBrightness = findViewById(R.id.quick_qs_brightness_bar);
+        mBrightnessController = new BrightnessController(getContext(),
+                mQuickQsBrightness.findViewById(R.id.brightness_icon),
+                mQuickQsBrightness.findViewById(R.id.brightness_slider));
+
         // Views corresponding to the header info section (e.g. ringer and next alarm).
         mHeaderTextContainerView = findViewById(R.id.header_text_container);
         mStatusSeparator = findViewById(R.id.status_separator);
@@ -261,7 +279,8 @@ public class QuickStatusBarHeader extends RelativeLayout implements
                 mContext.getMainExecutor(), mPropertyListener);
 
         Dependency.get(TunerService.class).addTunable(this,
-                StatusBarIconController.ICON_BLACKLIST);
+                StatusBarIconController.ICON_BLACKLIST,
+                QS_SHOW_AUTO_BRIGHTNESS, QS_SHOW_BRIGHTNESS_SLIDER);
     }
 
     private List<String> getIgnoredIconSlots() {
@@ -380,6 +399,13 @@ public class QuickStatusBarHeader extends RelativeLayout implements
         int qqsHeight = mContext.getResources().getDimensionPixelSize(
                 R.dimen.qs_quick_header_panel_height);
 
+        if (mIsQuickQsBrightnessEnabled) {
+            qqsHeight += mContext.getResources().getDimensionPixelSize(
+                    R.dimen.brightness_mirror_height)
+                    + mContext.getResources().getDimensionPixelSize(
+                    R.dimen.qs_tile_margin_top);
+        }
+
         setMinimumHeight(sbHeight + qqsHeight);
     }
 
@@ -396,6 +422,28 @@ public class QuickStatusBarHeader extends RelativeLayout implements
                 com.android.internal.R.dimen.quick_qs_offset_height);
         mSystemIconsView.setLayoutParams(mSystemIconsView.getLayoutParams());
 
+        if (mIsQuickQsBrightnessEnabled) {
+            // Offset container margin to align quick QS brightness bar with QS brightness bar.
+            RelativeLayout.LayoutParams lpQuickQsBrightness = (RelativeLayout.LayoutParams)
+                    mQuickQsBrightness.getLayoutParams();
+            lpQuickQsBrightness.setMargins(
+                    resources.getDimensionPixelSize(R.dimen.notification_side_paddings)
+                            - resources.getDimensionPixelSize(R.dimen.status_bar_padding_start),
+                    0, resources.getDimensionPixelSize(R.dimen.notification_side_paddings)
+                            - resources.getDimensionPixelSize(R.dimen.status_bar_padding_end),
+                    0);
+            mQuickQsBrightness.setLayoutParams(lpQuickQsBrightness);
+            if (mIsQsAutoBrightnessEnabled && resources.getBoolean(
+                    com.android.internal.R.bool.config_automatic_brightness_available)) {
+                mQuickQsBrightness.findViewById(R.id.brightness_icon).setVisibility(View.VISIBLE);
+            } else {
+                mQuickQsBrightness.findViewById(R.id.brightness_icon).setVisibility(View.GONE);
+            }
+            mQuickQsBrightness.setVisibility(View.VISIBLE);
+        } else {
+            mQuickQsBrightness.setVisibility(View.GONE);
+        }
+
         FrameLayout.LayoutParams lp = (FrameLayout.LayoutParams) getLayoutParams();
         if (mQsDisabled) {
             lp.height = resources.getDimensionPixelSize(
@@ -473,6 +521,14 @@ public class QuickStatusBarHeader extends RelativeLayout implements
             mPrivacyChip.setExpanded(expansionFraction > 0.5);
             mPrivacyChipAlphaAnimator.setPosition(keyguardExpansionFraction);
         }
+
+        if (mIsQuickQsBrightnessEnabled) {
+            if (keyguardExpansionFraction > 0) {
+                mQuickQsBrightness.setVisibility(INVISIBLE);
+            } else {
+                mQuickQsBrightness.setVisibility(VISIBLE);
+            }
+        }
     }
 
     public void disable(int state1, int state2, boolean animate) {
@@ -482,6 +538,7 @@ public class QuickStatusBarHeader extends RelativeLayout implements
         mHeaderQsPanel.setDisabledByPolicy(disabled);
         mHeaderTextContainerView.setVisibility(mQsDisabled ? View.GONE : View.VISIBLE);
         mQuickQsStatusIcons.setVisibility(mQsDisabled ? View.GONE : View.VISIBLE);
+        mQuickQsBrightness.setVisibility(mQsDisabled ? View.GONE : View.VISIBLE);
         updateResources();
     }
 
@@ -545,11 +602,13 @@ public class QuickStatusBarHeader extends RelativeLayout implements
             mContext.registerReceiver(mRingerReceiver,
                     new IntentFilter(AudioManager.INTERNAL_RINGER_MODE_CHANGED_ACTION));
             mPrivacyItemController.addCallback(mPICCallback);
+            mBrightnessController.registerCallbacks();
         } else {
             mZenController.removeCallback(this);
             mAlarmController.removeCallback(this);
             mPrivacyItemController.removeCallback(mPICCallback);
             mContext.unregisterReceiver(mRingerReceiver);
+            mBrightnessController.unregisterCallbacks();
             mPrivacyChipLogged = false;
         }
     }
@@ -662,7 +721,20 @@ public class QuickStatusBarHeader extends RelativeLayout implements
 
     @Override
     public void onTuningChanged(String key, String newValue) {
-        mClockView.setClockVisibleByUser(!StatusBarIconController.getIconBlacklist(newValue)
-                .contains(""clock""));
+        if (QS_SHOW_BRIGHTNESS_SLIDER.equals(key)) {
+            try {
+                mIsQuickQsBrightnessEnabled = Integer.parseInt(newValue) > 1;
+            } catch (NumberFormatException e) {
+                // Catches exception as newValue may be null or malformed.
+                mIsQuickQsBrightnessEnabled = false;
+            }
+            updateResources();
+        } else if (QS_SHOW_AUTO_BRIGHTNESS.equals(key)) {
+            mIsQsAutoBrightnessEnabled = TunerService.parseIntegerSwitch(newValue, true);
+            updateResources();
+        } else if (StatusBarIconController.ICON_BLACKLIST.equals(key)) {
+            mClockView.setClockVisibleByUser(!StatusBarIconController.getIconBlacklist(newValue)
+                    .contains(""clock""));
+        }
     }
 }
",75,3,"QuickStatusBarHeader::disable, QuickStatusBarHeader::onFinishInflate, QuickStatusBarHeader::onTuningChanged, QuickStatusBarHeader::setListening, QuickStatusBarHeader::updateResources, QuickStatusBarHeader::setExpansion, QuickStatusBarHeader::updateMinimumHeight"
110,9edf5fe24f521ed7d046249cacbab4673a777a19,ImageProcessHelper.java,ModificationType.MODIFY,"@@ -116,7 +116,8 @@ class ImageProcessHelper {
             int width = bitmap.getWidth();
             int height = bitmap.getHeight();
 
-            Bitmap grayscale = Bitmap.createBitmap(width, height, bitmap.getConfig());
+            Bitmap grayscale = Bitmap.createBitmap(width, height,
+                    bitmap.getConfig(), false, bitmap.getColorSpace());
             Canvas canvas = new Canvas(grayscale);
             ColorMatrix cm = new ColorMatrix(LUMINOSITY_MATRIX);
             Paint paint = new Paint();
",2,1,ImageProcessHelper::Threshold::toGrayscale
111,2dc4ad095d8a0792c42d7a1dbe0d7f6e37717b23,QuickStatusBarHeader.java,ModificationType.MODIFY,"@@ -423,16 +423,6 @@ public class QuickStatusBarHeader extends RelativeLayout implements
         mSystemIconsView.setLayoutParams(mSystemIconsView.getLayoutParams());
 
         if (mIsQuickQsBrightnessEnabled) {
-            // Offset container margin to align quick QS brightness bar with QS brightness bar.
-            RelativeLayout.LayoutParams lpQuickQsBrightness = (RelativeLayout.LayoutParams)
-                    mQuickQsBrightness.getLayoutParams();
-            lpQuickQsBrightness.setMargins(
-                    resources.getDimensionPixelSize(R.dimen.notification_side_paddings)
-                            - resources.getDimensionPixelSize(R.dimen.status_bar_padding_start),
-                    0, resources.getDimensionPixelSize(R.dimen.notification_side_paddings)
-                            - resources.getDimensionPixelSize(R.dimen.status_bar_padding_end),
-                    0);
-            mQuickQsBrightness.setLayoutParams(lpQuickQsBrightness);
             if (mIsQsAutoBrightnessEnabled && resources.getBoolean(
                     com.android.internal.R.bool.config_automatic_brightness_available)) {
                 mQuickQsBrightness.findViewById(R.id.brightness_icon).setVisibility(View.VISIBLE);
@@ -577,6 +567,12 @@ public class QuickStatusBarHeader extends RelativeLayout implements
         }
         mSpace.setLayoutParams(lp);
         setChipVisibility(mPrivacyChip.getVisibility() == View.VISIBLE);
+        // Offset container padding to align with QS brightness bar.
+        final int sp = getResources().getDimensionPixelSize(R.dimen.notification_side_paddings);
+        RelativeLayout.LayoutParams lpQuickQsBrightness = (RelativeLayout.LayoutParams)
+                mQuickQsBrightness.getLayoutParams();
+        lpQuickQsBrightness.setMargins(sp - mPaddingLeft, 0, sp - mPaddingRight, 0);
+        mQuickQsBrightness.setLayoutParams(lpQuickQsBrightness);
         return super.onApplyWindowInsets(insets);
     }
 
",6,10,"QuickStatusBarHeader::onApplyWindowInsets, QuickStatusBarHeader::updateResources"
112,63fc6d8c0acb37835336862674206cf001753667,CollapsedStatusBarFragment.java,ModificationType.MODIFY,"@@ -289,7 +289,8 @@ public class CollapsedStatusBarFragment extends Fragment implements CommandQueue
      */
     private int clockHiddenMode() {
         if (!mStatusBar.isClosed() && !mKeyguardMonitor.isShowing()
-                && !mStatusBarStateController.isDozing()) {
+                && !mStatusBarStateController.isDozing()
+                && mClockController.getClock().shouldBeVisible()) {
             return View.INVISIBLE;
         }
         return View.GONE;
",2,1,CollapsedStatusBarFragment::clockHiddenMode
113,63fc6d8c0acb37835336862674206cf001753667,Clock.java,ModificationType.MODIFY,"@@ -268,7 +268,7 @@ public class Clock extends TextView implements DemoMode, Tunable, CommandQueue.C
         updateClockVisibility();
     }
 
-    private boolean shouldBeVisible() {
+    public boolean shouldBeVisible() {
         return mClockVisibleByPolicy && mClockVisibleByUser;
     }
 
",1,1,Clock::shouldBeVisible
114,d10203dde46ee7f94a5ae3a65800c8a409a9a4b4,CarrierConfigManager.java,ModificationType.MODIFY,"@@ -3579,7 +3579,7 @@ public class CarrierConfigManager {
                 null);
         sDefaults.putInt(KEY_LTE_EARFCNS_RSRP_BOOST_INT, 0);
         sDefaults.putStringArray(KEY_BOOSTED_LTE_EARFCNS_STRING_ARRAY, null);
-        sDefaults.putBoolean(KEY_USE_ONLY_RSRP_FOR_LTE_SIGNAL_BAR_BOOL, false);
+        sDefaults.putBoolean(KEY_USE_ONLY_RSRP_FOR_LTE_SIGNAL_BAR_BOOL, true);
         sDefaults.putBoolean(KEY_DISABLE_VOICE_BARRING_NOTIFICATION_BOOL, false);
         sDefaults.putInt(IMSI_KEY_AVAILABILITY_INT, 0);
         sDefaults.putString(IMSI_KEY_DOWNLOAD_URL_STRING, null);
",1,1,
115,aa9fbad20ad63940358f8461879bd34ec5d216f3,GlobalScreenshot.java,ModificationType.MODIFY,"@@ -64,6 +64,7 @@ import android.graphics.Picture;
 import android.graphics.PixelFormat;
 import android.graphics.PointF;
 import android.graphics.Rect;
+import android.media.AudioManager;
 import android.media.MediaActionSound;
 import android.net.Uri;
 import android.os.AsyncTask;
@@ -77,6 +78,8 @@ import android.os.ServiceManager;
 import android.os.SystemClock;
 import android.os.UserHandle;
 import android.os.UserManager;
+import android.os.VibrationEffect;
+import android.os.Vibrator;
 import android.provider.DeviceConfig;
 import android.provider.MediaStore;
 import android.text.TextUtils;
@@ -661,6 +664,8 @@ class GlobalScreenshot {
     private AsyncTask<Void, Void, Void> mSaveInBgTask;
 
     private MediaActionSound mCameraSound;
+    private AudioManager mAudioManager;
+    private Vibrator mVibrator;
 
 
     /**
@@ -734,6 +739,10 @@ class GlobalScreenshot {
         // Setup the Camera shutter sound
         mCameraSound = new MediaActionSound();
         mCameraSound.load(MediaActionSound.SHUTTER_CLICK);
+
+        // Grab system services needed for screenshot sound
+        mAudioManager = (AudioManager) mContext.getSystemService(Context.AUDIO_SERVICE);
+        mVibrator = (Vibrator) mContext.getSystemService(Context.VIBRATOR_SERVICE);
     }
 
     /**
@@ -968,8 +977,21 @@ class GlobalScreenshot {
         mScreenshotLayout.post(new Runnable() {
             @Override
             public void run() {
-                // Play the shutter sound to notify that we've taken a screenshot
-                mCameraSound.play(MediaActionSound.SHUTTER_CLICK);
+                switch (mAudioManager.getRingerMode()) {
+                    case AudioManager.RINGER_MODE_SILENT:
+                        // do nothing
+                        break;
+                    case AudioManager.RINGER_MODE_VIBRATE:
+                        if (mVibrator != null && mVibrator.hasVibrator()) {
+                            mVibrator.vibrate(VibrationEffect.createOneShot(50,
+                                    VibrationEffect.DEFAULT_AMPLITUDE));
+                        }
+                        break;
+                    case AudioManager.RINGER_MODE_NORMAL:
+                        // Play the shutter sound to notify that we've taken a screenshot
+                        mCameraSound.play(MediaActionSound.SHUTTER_CLICK);
+                        break;
+                }
 
                 mScreenshotView.setLayerType(View.LAYER_TYPE_HARDWARE, null);
                 mScreenshotView.buildLayer();
",24,2,"GlobalScreenshot::GlobalScreenshot, GlobalScreenshot::startAnimation"
116,1e64ed2b6aa91080be86a2d85a2e206aab52b853,KeyguardClockSwitch.java,ModificationType.MODIFY,"@@ -389,7 +389,8 @@ public class KeyguardClockSwitch extends RelativeLayout {
         }
         if (Build.IS_DEBUGGABLE) {
             // Log for debugging b/130888082 (sysui waking up, but clock not updating)
-            Log.d(TAG, ""Updating clock: "" + mClockView.getText());
+            Log.d(TAG, ""Updating clock: "" + mClockView.getText().toString()
+                    .replaceAll(""[^\\x00-\\x7F]"", "":""));
         }
     }
 
",2,1,KeyguardClockSwitch::refresh
117,ac2040adcbf3ae05058d204cd1001297e065034f,CaffeineTile.java,ModificationType.MODIFY,"@@ -26,10 +26,10 @@ import android.os.PowerManager;
 import android.os.SystemClock;
 import android.service.quicksettings.Tile;
 
+import com.android.systemui.R;
+import com.android.systemui.plugins.qs.QSTile.BooleanState;
 import com.android.systemui.qs.QSHost;
 import com.android.systemui.qs.tileimpl.QSTileImpl;
-import com.android.systemui.plugins.qs.QSTile.BooleanState;
-import com.android.systemui.R;
 
 import org.lineageos.internal.logging.LineageMetricsLogger;
 
@@ -49,6 +49,7 @@ public class CaffeineTile extends QSTileImpl<BooleanState> {
         30 * 60,  // 30 min
         -1,       // infinity
     };
+    private static final int INFINITE_DURATION_INDEX = DURATIONS.length - 1;
     private CountDownTimer mCountdownTimer = null;
     public long mLastClickTime = -1;
     private final Receiver mReceiver = new Receiver();
@@ -120,6 +121,16 @@ public class CaffeineTile extends QSTileImpl<BooleanState> {
 
     @Override
     protected void handleLongClick() {
+        if (mWakeLock.isHeld()) {
+            if (mDuration == INFINITE_DURATION_INDEX) {
+                return;
+            }
+        } else {
+            mWakeLock.acquire();
+        }
+        mDuration = INFINITE_DURATION_INDEX;
+        startCountDown(DURATIONS[INFINITE_DURATION_INDEX]);
+        refreshState();
     }
 
     @Override
",13,2,CaffeineTile::handleLongClick
118,230e19d9f7719dd67e6b4e47be75ccedc23cada0,NavigationBarInflaterView.java,ModificationType.MODIFY,"@@ -21,10 +21,11 @@ import static android.view.WindowManagerPolicyConstants.NAV_BAR_MODE_GESTURAL;
 import android.annotation.Nullable;
 import android.app.ActivityManager;
 import android.content.Context;
-import android.content.om.OverlayManager;
+import android.content.om.IOverlayManager;
 import android.content.res.Configuration;
 import android.graphics.drawable.Icon;
-import android.os.UserHandle;
+import android.os.RemoteException;
+import android.os.ServiceManager;
 import android.util.AttributeSet;
 import android.util.Log;
 import android.util.SparseArray;
@@ -264,12 +265,18 @@ public class NavigationBarInflaterView extends FrameLayout
     }
 
     private void updateHint() {
+        final IOverlayManager iom = IOverlayManager.Stub.asInterface(
+                ServiceManager.getService(Context.OVERLAY_SERVICE));
         final boolean state = mNavBarMode == NAV_BAR_MODE_GESTURAL && !mIsHintEnabled;
-        UserHandle userId = UserHandle.of(ActivityManager.getCurrentUser());
+        final int userId = ActivityManager.getCurrentUser();
         try {
-            mContext.getSystemService(OverlayManager.class).setEnabled(
-                    OVERLAY_NAVIGATION_HIDE_HINT, state, userId);
-        } catch (Exception e) {
+            iom.setEnabled(OVERLAY_NAVIGATION_HIDE_HINT, state, userId);
+            if (state) {
+                // As overlays are also used to apply navigation mode, it is needed to set
+                // our customization overlay to highest priority to ensure it is applied.
+                iom.setHighestPriority(OVERLAY_NAVIGATION_HIDE_HINT, userId);
+            }
+        } catch (RemoteException e) {
             Log.e(TAG, ""Failed to "" + (state ? ""enable"" : ""disable"")
                     + "" overlay "" + OVERLAY_NAVIGATION_HIDE_HINT + "" for user "" + userId);
         }
",13,6,NavigationBarInflaterView::updateHint
119,f730abf925a48c48953eb7177af7f06cd7c76a09,AODTile.java,ModificationType.MODIFY,"@@ -24,6 +24,7 @@ import android.service.quicksettings.Tile;
 import com.android.systemui.R;
 import com.android.systemui.plugins.qs.QSTile.BooleanState;
 import com.android.systemui.qs.QSHost;
+import com.android.systemui.qs.SecureSetting;
 import com.android.systemui.qs.tileimpl.QSTileImpl;
 import com.android.systemui.statusbar.policy.BatteryController;
 
@@ -33,15 +34,22 @@ import javax.inject.Inject;
 
 public class AODTile extends QSTileImpl<BooleanState> implements
         BatteryController.BatteryStateChangeCallback {
-    private boolean mAodDisabled;
+
     private final Icon mIcon = ResourceIcon.get(R.drawable.ic_qs_aod);
     private final BatteryController mBatteryController;
 
+    private final SecureSetting mSetting;
+
     @Inject
     public AODTile(QSHost host, BatteryController batteryController) {
         super(host);
-        mAodDisabled = Settings.Secure.getInt(mContext.getContentResolver(),
-                Settings.Secure.DOZE_ALWAYS_ON, 1) == 0;
+
+        mSetting = new SecureSetting(mContext, mHandler, Settings.Secure.DOZE_ALWAYS_ON) {
+            @Override
+            protected void handleValueChanged(int value, boolean observedChange) {
+                handleRefreshState(value);
+            }
+        };
 
         mBatteryController = batteryController;
         batteryController.observe(getLifecycle(), this);
@@ -67,10 +75,7 @@ public class AODTile extends QSTileImpl<BooleanState> implements
 
     @Override
     public void handleClick() {
-        mAodDisabled = !mAodDisabled;
-        Settings.Secure.putInt(mContext.getContentResolver(),
-                Settings.Secure.DOZE_ALWAYS_ON,
-                mAodDisabled ? 0 : 1);
+        setEnabled(!mState.value);
         refreshState();
     }
 
@@ -79,6 +84,12 @@ public class AODTile extends QSTileImpl<BooleanState> implements
         return null;
     }
 
+    private void setEnabled(boolean enabled) {
+        Settings.Secure.putInt(mContext.getContentResolver(),
+                Settings.Secure.DOZE_ALWAYS_ON,
+                enabled ? 1 : 0);
+    }
+
     @Override
     public CharSequence getTileLabel() {
         if (mBatteryController.isAodPowerSave()) {
@@ -89,19 +100,19 @@ public class AODTile extends QSTileImpl<BooleanState> implements
 
     @Override
     protected void handleUpdateState(BooleanState state, Object arg) {
+        final int value = arg instanceof Integer ? (Integer) arg : mSetting.getValue();
+        final boolean enable = value != 0;
         if (state.slash == null) {
             state.slash = new SlashState();
         }
         state.icon = mIcon;
-        state.value = mAodDisabled;
+        state.value = enable;
         state.slash.isSlashed = state.value;
         state.label = mContext.getString(R.string.quick_settings_aod_label);
         if (mBatteryController.isAodPowerSave()) {
             state.state = Tile.STATE_UNAVAILABLE;
-        } else if (mAodDisabled) {
-            state.state = Tile.STATE_INACTIVE;
         } else {
-            state.state = Tile.STATE_ACTIVE;
+            state.state = enable ? Tile.STATE_ACTIVE : Tile.STATE_INACTIVE;
         }
     }
 
",22,11,"AODTile::setEnabled, AODTile::handleClick, AODTile::AODTile, AODTile::handleUpdateState"
120,257a6821cbc2802265b20c3631fdae5505cd983a,ClockManager.java,ModificationType.MODIFY,"@@ -150,6 +150,7 @@ public final class ClockManager {
         addBuiltinClock(() -> new DefaultClockController(res, layoutInflater, colorExtractor));
         addBuiltinClock(() -> new BubbleClockController(res, layoutInflater, colorExtractor));
         addBuiltinClock(() -> new AnalogClockController(res, layoutInflater, colorExtractor));
+        addBuiltinClock(() -> new LineageClockController(res, layoutInflater, colorExtractor));
 
         // Store the size of the display for generation of clock preview.
         DisplayMetrics dm = res.getDisplayMetrics();
",1,0,ClockManager::ClockManager
121,257a6821cbc2802265b20c3631fdae5505cd983a,LineageClockController.java,ModificationType.ADD,"@@ -0,0 +1,163 @@
+/*
+ * Copyright (C) 2020 The LineageOS Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.keyguard.clock;
+
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.graphics.Paint.Style;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.widget.TextClock;
+
+import com.android.systemui.R;
+import com.android.systemui.colorextraction.SysuiColorExtractor;
+import com.android.systemui.plugins.ClockPlugin;
+
+import java.util.TimeZone;
+
+/**
+ * Plugin for the default clock face used only to provide a preview.
+ */
+public class LineageClockController implements ClockPlugin {
+
+    /**
+     * Resources used to get title and thumbnail.
+     */
+    private final Resources mResources;
+
+    /**
+     * LayoutInflater used to inflate custom clock views.
+     */
+    private final LayoutInflater mLayoutInflater;
+
+    /**
+     * Renders preview from clock view.
+     */
+    private final ViewPreviewer mRenderer = new ViewPreviewer();
+
+    /**
+     * Root view of clock.
+     */
+    private ClockLayout mView;
+
+    /**
+     * Text clock in preview view hierarchy.
+     */
+    private TextClock mClock;
+
+    /**
+     * Create a DefaultClockController instance.
+     *
+     * @param res Resources contains title and thumbnail.
+     * @param inflater Inflater used to inflate custom clock views.
+     * @param colorExtractor Extracts accent color from wallpaper.
+     */
+    public LineageClockController(Resources res, LayoutInflater inflater,
+            SysuiColorExtractor colorExtractor) {
+        mResources = res;
+        mLayoutInflater = inflater;
+    }
+
+    private void createViews() {
+        mView = (ClockLayout) mLayoutInflater
+                .inflate(R.layout.lineage_clock, null);
+        mClock = (TextClock) mView.findViewById(R.id.clock);
+        mClock.setFormat12Hour(""hh\nmm"");
+        mClock.setFormat24Hour(""kk\nmm"");
+    }
+
+    @Override
+    public void onDestroyView() {
+        mView = null;
+        mClock = null;
+    }
+
+    @Override
+    public String getName() {
+        return ""lineageos"";
+    }
+
+    @Override
+    public String getTitle() {
+        return mResources.getString(R.string.clock_title_lineage);
+    }
+
+    @Override
+    public int getPreferredY(int totalHeight) {
+        return totalHeight / 3;
+    }
+
+    @Override
+    public Bitmap getThumbnail() {
+        return BitmapFactory.decodeResource(mResources, R.drawable.lineage_thumbnail);
+    }
+
+    @Override
+    public Bitmap getPreview(int width, int height) {
+
+        View previewView = getView();
+        TextClock clock = previewView.findViewById(R.id.clock);
+        clock.setFormat12Hour(""hh\nmm"");
+        clock.setFormat24Hour(""kk\nmm"");
+        onTimeTick();
+        return mRenderer.createPreview(previewView, width, height);
+    }
+
+    @Override
+    public View getView() {
+        if (mView == null) {
+            createViews();
+        }
+        return mView;
+    }
+
+    @Override
+    public View getBigClockView() {
+        return null;
+    }
+
+    @Override
+    public void setStyle(Style style) {}
+
+    @Override
+    public void setTextColor(int color) {
+        mClock.setTextColor(color);
+    }
+
+    @Override
+    public void setColorPalette(boolean supportsDarkText, int[] colorPalette) {}
+
+    @Override
+    public void onTimeTick() {
+        mView.onTimeChanged();
+        mClock.refresh();
+    }
+
+    @Override
+    public void setDarkAmount(float darkAmount) {
+        mView.setDarkAmount(darkAmount);
+    }
+
+    @Override
+    public void onTimeZoneChanged(TimeZone timeZone) {}
+
+    @Override
+    public boolean shouldShowStatusArea() {
+        return true;
+    }
+}
",163,0,"LineageClockController::getThumbnail, LineageClockController::LineageClockController, LineageClockController::getPreferredY, LineageClockController::setDarkAmount, LineageClockController::onDestroyView, LineageClockController::getView, LineageClockController::getTitle, LineageClockController::getBigClockView, LineageClockController::onTimeZoneChanged, LineageClockController::setStyle, LineageClockController::onTimeTick, LineageClockController::shouldShowStatusArea, LineageClockController::createViews, LineageClockController::getName, LineageClockController::getPreview, LineageClockController::setTextColor, LineageClockController::setColorPalette"
122,24656a53072e0a723ac27ef5f89ef3b9885deaad,QSDetail.java,ModificationType.MODIFY,"@@ -162,13 +162,13 @@ public class QSDetail extends LinearLayout {
         if (padding == null) {
             mQsDetailHeader.setPaddingRelative(
                     getResources().getDimensionPixelSize(R.dimen.qs_detail_header_padding),
-                    getPaddingTop(),
-                    getResources().getDimensionPixelSize(R.dimen.qs_detail_header_padding),
-                    getPaddingBottom()
+                    mQsDetailHeader.getPaddingTop(),
+                    getResources().getDimensionPixelSize(R.dimen.qs_panel_padding),
+                    mQsDetailHeader.getPaddingBottom()
             );
         } else {
-            mQsDetailHeader.setPadding(padding.first, getPaddingTop(),
-                    padding.second, getPaddingBottom());
+            mQsDetailHeader.setPadding(padding.first, mQsDetailHeader.getPaddingTop(),
+                    padding.second, mQsDetailHeader.getPaddingBottom());
         }
         return super.onApplyWindowInsets(insets);
     }
",5,5,QSDetail::onApplyWindowInsets
123,027d8103d43b4fde345267541103cff2266a2471,BluetoothTile.java,ModificationType.MODIFY,"@@ -252,6 +252,7 @@ public class BluetoothTile extends QSTileImpl<BooleanState> {
             refreshState();
             if (isShowingDetail()) {
                 mDetailAdapter.updateItems();
+                mDetailAdapter.setItemsVisible(true);
                 fireToggleStateChanged(mDetailAdapter.getToggleState());
             }
         }
",1,0,BluetoothTile::Callback
124,17fb496724472b49768099b22b07c36bfc0344d2,BluetoothDevice.java,ModificationType.MODIFY,"@@ -238,6 +238,13 @@ public final class BluetoothDevice implements Parcelable {
      */
     public static final String EXTRA_NAME = ""android.bluetooth.device.extra.NAME"";
 
+    /**
+     * Used as a Parcelable {@link BluetoothQualityReport} extra field in
+     * {@link #ACTION_REMOTE_ISSUE_OCCURRED} intent. It contains the {@link BluetoothQualityReport}.
+     * @hide
+     */
+    public static final String EXTRA_BQR = ""android.bluetooth.qti.extra.EXTRA_BQR"";
+
     /**
      * Used as an optional short extra field in {@link #ACTION_FOUND} intents.
      * Contains the RSSI value of the remote device as reported by the
",7,0,
125,17fb496724472b49768099b22b07c36bfc0344d2,BluetoothQualityReport.java,ModificationType.ADD,"@@ -0,0 +1,1389 @@
+/*
+ * Copyright (c) 2019, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of The Linux Foundation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED ""AS IS"" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package android.bluetooth;
+
+import android.annotation.NonNull;
+import android.content.Context;
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.util.Log;
+
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+import java.util.Arrays;
+
+/**
+ * This class provides the public APIs to access the data of BQR event reported
+ * from firmware side. Currently it supports five event types: Quality monitor event,
+ * Approaching LSTO event, A2DP choppy event, SCO choppy event and Connect fail event.
+ * To know which kind of event is wrapped in this {@link BluetoothQualityReport} object,
+ * you need to call {@link #getQualityReportId}.
+ * <ul>
+ *   <li> For Quality monitor event, you can call {@link #getBqrCommon} to get a
+ *   {@link BluetoothQualityReport.BqrCommon} object, and call {@link #getBqrVsCommon} to get a
+ *   {@link BluetoothQualityReport.BqrVsCommon} object.
+ *   <li> For Approaching LSTO event, you can call {@link #getBqrCommon} to get a
+ *   {@link BluetoothQualityReport.BqrCommon} object, and call {@link #getBqrVsCommon} to get a
+ *   {@link BluetoothQualityReport.BqrVsCommon} object, and call {@link #getBqrVsLsto} to get a
+ *   {@link BluetoothQualityReport.BqrVsLsto} object.
+ *   <li> For A2DP choppy event, you can call {@link #getBqrCommon} to get a
+ *   {@link BluetoothQualityReport.BqrCommon} object, and call {@link #getBqrVsCommon} to get a
+ *   {@link BluetoothQualityReport.BqrVsCommon} object, and call {@link #getBqrVsA2dpChoppy} to
+ *   get a {@link BluetoothQualityReport.BqrVsA2dpChoppy} object.
+ *   <li> For SCO choppy event, you can call {@link #getBqrCommon} to get a
+ *   {@link BluetoothQualityReport.BqrCommon} object, and call {@link #getBqrVsCommon} to get a
+ *   {@link BluetoothQualityReport.BqrVsCommon} object, and call {@link #getBqrVsScoChoppy} to
+ *   get a {@link BluetoothQualityReport.BqrVsScoChoppy} object.
+ *   <li> For Connect fail event, you can call {@link #getBqrCommon} to get a
+ *   {@link BluetoothQualityReport.BqrCommon} object, and call {@link #getBqrVsCommon} to get a
+ *   {@link BluetoothQualityReport.BqrVsCommon} object, and call {@link #getBqrVsConnectFail} to
+ *   get a {@link BluetoothQualityReport.BqrVsConnectFail} object.
+ * </ul>
+ *
+ * @hide
+ */
+public final class BluetoothQualityReport implements Parcelable {
+    private static final String TAG = ""BluetoothQualityReport"";
+
+    public static final int QUALITY_REPORT_ID_MONITOR = 0x01;
+    public static final int QUALITY_REPORT_ID_APPROACH_LSTO = 0x02;
+    public static final int QUALITY_REPORT_ID_A2DP_CHOPPY = 0x03;
+    public static final int QUALITY_REPORT_ID_SCO_CHOPPY = 0x04;
+    /* Vendor Specific Report IDs from 0x20 */
+    public static final int QUALITY_REPORT_ID_CONN_FAIL = 0x20;
+
+    private String mAddr;
+    private int mLmpVer;
+    private int mLmpSubVer;
+    private int mManufacturerId;
+    private String mName;
+    private int mBluetoothClass;
+
+    private BqrCommon mBqrCommon;
+
+    private BqrVsCommon mBqrVsCommon;
+    private BqrVsLsto mBqrVsLsto;
+    private BqrVsA2dpChoppy mBqrVsA2dpChoppy;
+    private BqrVsScoChoppy mBqrVsScoChoppy;
+    private BqrVsConnectFail mBqrVsConnectFail;
+
+    enum PacketType {
+        INVALID, TYPE_ID, TYPE_NULL, TYPE_POLL, TYPE_FHS, TYPE_HV1, TYPE_HV2, TYPE_HV3,
+        TYPE_DV, TYPE_EV3, TYPE_EV4, TYPE_EV5, TYPE_2EV3, TYPE_2EV5, TYPE_3EV3, TYPE_3EV5,
+        TYPE_DM1, TYPE_DH1, TYPE_DM3, TYPE_DH3, TYPE_DM5, TYPE_DH5, TYPE_AUX1, TYPE_2DH1,
+        TYPE_2DH3, TYPE_2DH5, TYPE_3DH1, TYPE_3DH3, TYPE_3DH5;
+
+        private static PacketType[] sAllValues = values();
+
+        static PacketType fromOrdinal(int n) {
+            if (n < sAllValues.length) {
+                return sAllValues[n];
+            }
+            return INVALID;
+        }
+    }
+
+    enum ConnState {
+        CONN_IDLE(0x00), CONN_ACTIVE(0x81), CONN_HOLD(0x02), CONN_SNIFF_IDLE(0x03),
+        CONN_SNIFF_ACTIVE(0x84), CONN_SNIFF_MASTER_TRANSITION(0x85), CONN_PARK(0x06),
+        CONN_PARK_PEND(0x47), CONN_UNPARK_PEND(0x08), CONN_UNPARK_ACTIVE(0x89),
+        CONN_DISCONNECT_PENDING(0x4A), CONN_PAGING(0x0B), CONN_PAGE_SCAN(0x0C),
+        CONN_LOCAL_LOOPBACK(0x0D), CONN_LE_ACTIVE(0x0E), CONN_ANT_ACTIVE(0x0F),
+        CONN_TRIGGER_SCAN(0x10), CONN_RECONNECTING(0x11), CONN_SEMI_CONN(0x12);
+
+        private int mValue;
+        private static ConnState[] sAllStates = values();
+
+        private ConnState(int val) {
+            mValue = val;
+        }
+
+        public static String getName(int val) {
+            for (ConnState state: sAllStates) {
+                if (state.mValue == val) {
+                    return state.toString();
+                }
+            }
+            return ""INVALID"";
+        }
+    }
+
+    enum LinkQuality {
+        ULTRA_HIGH, HIGH, STANDARD, MEDIUM, LOW, INVALID;
+
+        private static LinkQuality[] sAllValues = values();
+
+        static LinkQuality fromOrdinal(int n) {
+            if (n < sAllValues.length - 1) {
+                return sAllValues[n];
+            }
+            return INVALID;
+        }
+    }
+
+    enum AirMode {
+        uLaw, aLaw, CVSD, transparent_msbc, INVALID;
+
+        private static AirMode[] sAllValues = values();
+
+        static AirMode fromOrdinal(int n) {
+            if (n < sAllValues.length - 1) {
+                return sAllValues[n];
+            }
+            return INVALID;
+        }
+    }
+
+    public BluetoothQualityReport(String remoteAddr, int lmpVer, int lmpSubVer,
+            int manufacturerId, String remoteName, int remoteCoD, byte[] rawData) {
+        if (!BluetoothAdapter.checkBluetoothAddress(remoteAddr)) {
+            Log.d(TAG, ""remote addr is invalid"");
+            mAddr = ""00:00:00:00:00:00"";
+        } else {
+            mAddr = remoteAddr;
+        }
+
+        mLmpVer = lmpVer;
+        mLmpSubVer = lmpSubVer;
+        mManufacturerId = manufacturerId;
+        if (remoteName == null) {
+            Log.d(TAG, ""remote name is null"");
+            mName = """";
+        } else {
+            mName = remoteName;
+        }
+        mBluetoothClass = remoteCoD;
+
+        mBqrCommon = new BqrCommon(rawData, 0);
+
+        mBqrVsCommon = new BqrVsCommon(rawData, BqrCommon.BQR_COMMON_LEN);
+        int id = mBqrCommon.getQualityReportId();
+        if (id == QUALITY_REPORT_ID_MONITOR)
+            return;
+
+        int vsPartOffset = BqrCommon.BQR_COMMON_LEN + mBqrVsCommon.getLength();
+        if (id == QUALITY_REPORT_ID_APPROACH_LSTO) {
+            mBqrVsLsto = new BqrVsLsto(rawData, vsPartOffset);
+        } else if (id == QUALITY_REPORT_ID_A2DP_CHOPPY) {
+            mBqrVsA2dpChoppy = new BqrVsA2dpChoppy(rawData, vsPartOffset);
+        } else if (id == QUALITY_REPORT_ID_SCO_CHOPPY) {
+            mBqrVsScoChoppy = new BqrVsScoChoppy(rawData, vsPartOffset);
+        } else if (id == QUALITY_REPORT_ID_CONN_FAIL) {
+            mBqrVsConnectFail = new BqrVsConnectFail(rawData, vsPartOffset);
+        } else {
+            throw new IllegalArgumentException(TAG + "": unkown quality report id:"" + id);
+        }
+    }
+
+    private BluetoothQualityReport(Parcel in) {
+        mBqrCommon = new BqrCommon(in);
+        mAddr = in.readString();
+        mLmpVer = in.readInt();
+        mLmpSubVer = in.readInt();
+        mManufacturerId = in.readInt();
+        mName = in.readString();
+        mBluetoothClass = in.readInt();
+
+        mBqrVsCommon = new BqrVsCommon(in);
+        int id = mBqrCommon.getQualityReportId();
+        if (id == QUALITY_REPORT_ID_APPROACH_LSTO) {
+            mBqrVsLsto = new BqrVsLsto(in);
+        } else if (id == QUALITY_REPORT_ID_A2DP_CHOPPY) {
+            mBqrVsA2dpChoppy = new BqrVsA2dpChoppy(in);
+        } else if (id == QUALITY_REPORT_ID_SCO_CHOPPY) {
+            mBqrVsScoChoppy = new BqrVsScoChoppy(in);
+        } else if (id == QUALITY_REPORT_ID_CONN_FAIL) {
+            mBqrVsConnectFail = new BqrVsConnectFail(in);
+        }
+    }
+
+    /**
+     * Get the quality report id.
+     * @return the id, is one of {@link #QUALITY_REPORT_ID_MONITOR},
+     *         {@link #QUALITY_REPORT_ID_APPROACH_LSTO}, {@link #QUALITY_REPORT_ID_A2DP_CHOPPY},
+     *         {@link #QUALITY_REPORT_ID_SCO_CHOPPY}, {@link #QUALITY_REPORT_ID_CONN_FAIL}.
+     */
+    public int getQualityReportId() {
+        return mBqrCommon.getQualityReportId();
+    }
+
+    /**
+     * Get the string of the quality report id.
+     * @return the string of the id.
+     */
+    public String getQualityReportIdStr() {
+        int id = mBqrCommon.getQualityReportId();
+        switch (id) {
+            case QUALITY_REPORT_ID_MONITOR:
+                return ""Quality monitor"";
+            case QUALITY_REPORT_ID_APPROACH_LSTO:
+                return ""Approaching LSTO"";
+            case QUALITY_REPORT_ID_A2DP_CHOPPY:
+                return ""A2DP choppy"";
+            case QUALITY_REPORT_ID_SCO_CHOPPY:
+                return ""SCO choppy"";
+            case QUALITY_REPORT_ID_CONN_FAIL:
+                return ""Connect fail"";
+            default:
+                return ""INVALID"";
+        }
+    }
+
+    /**
+     * Get bluetooth address of remote device in this report.
+     * @return bluetooth address of remote device.
+     */
+    public String getAddress() {
+        return mAddr;
+    }
+
+    /**
+     * Get LMP version of remote device in this report.
+     * @return LMP version of remote device.
+     */
+    public int getLmpVersion() {
+        return mLmpVer;
+    }
+
+    /**
+     * Get LMP subVersion of remote device in this report.
+     * @return LMP subVersion of remote device.
+     */
+    public int getLmpSubVersion() {
+        return mLmpSubVer;
+    }
+
+    /**
+     * Get manufacturer id of remote device in this report.
+     * @return manufacturer id of remote device.
+     */
+    public int getManufacturerId() {
+        return mManufacturerId;
+    }
+
+    /**
+     * Get the name of remote device in this report.
+     * @return the name of remote device.
+     */
+    public String getName() {
+        return mName;
+    }
+
+    /**
+     * Get the class of remote device in this report.
+     * @return the class of remote device.
+     */
+    public int getBluetoothClass() {
+        return mBluetoothClass;
+    }
+
+    /**
+     * Get the {@link BluetoothQualityReport.BqrCommon} object.
+     * @return the {@link BluetoothQualityReport.BqrCommon} object.
+     */
+    public BqrCommon getBqrCommon() {
+        return mBqrCommon;
+    }
+
+    /**
+     * Get the {@link BluetoothQualityReport.BqrVsCommon} object.
+     * @return the {@link BluetoothQualityReport.BqrVsCommon} object.
+     */
+    public BqrVsCommon getBqrVsCommon() {
+        return mBqrVsCommon;
+    }
+
+    /**
+     * Get the {@link BluetoothQualityReport.BqrVsLsto} object.
+     * @return the {@link BluetoothQualityReport.BqrVsLsto} object
+     *         or null if report id is not {@link #QUALITY_REPORT_ID_APPROACH_LSTO}.
+     */
+    public BqrVsLsto getBqrVsLsto() {
+        return mBqrVsLsto;
+    }
+
+    /**
+     * Get the {@link BluetoothQualityReport.BqrVsA2dpChoppy} object.
+     * @return the {@link BluetoothQualityReport.BqrVsA2dpChoppy} object
+     *         or null if report id is not {@link #QUALITY_REPORT_ID_A2DP_CHOPPY}.
+     */
+    public BqrVsA2dpChoppy getBqrVsA2dpChoppy() {
+        return mBqrVsA2dpChoppy;
+    }
+
+    /**
+     * Get the {@link BluetoothQualityReport.BqrVsScoChoppy} object.
+     * @return the {@link BluetoothQualityReport.BqrVsScoChoppy} object
+     *         or null if report id is not {@link #QUALITY_REPORT_ID_SCO_CHOPPY}.
+     */
+    public BqrVsScoChoppy getBqrVsScoChoppy() {
+        return mBqrVsScoChoppy;
+    }
+
+    /**
+     * Get the {@link BluetoothQualityReport.BqrVsConnectFail} object.
+     * @return the {@link BluetoothQualityReport.BqrVsConnectFail} object
+     *         or null if report id is not {@link #QUALITY_REPORT_ID_CONN_FAIL}.
+     */
+    public BqrVsConnectFail getBqrVsConnectFail() {
+        return mBqrVsConnectFail;
+    }
+
+    public static final @android.annotation.NonNull Parcelable.Creator<BluetoothQualityReport> CREATOR =
+        new Parcelable.Creator<BluetoothQualityReport>() {
+            public BluetoothQualityReport createFromParcel(Parcel in) {
+                return new BluetoothQualityReport(in);
+            }
+
+            public BluetoothQualityReport[] newArray(int size) {
+                return new BluetoothQualityReport[size];
+            }
+        };
+
+    public int describeContents() {
+        return 0;
+    }
+
+    @Override
+    public void writeToParcel(Parcel out, int flags) {
+        mBqrCommon.writeToParcel(out, flags);
+        out.writeString(mAddr);
+        out.writeInt(mLmpVer);
+        out.writeInt(mLmpSubVer);
+        out.writeInt(mManufacturerId);
+        out.writeString(mName);
+        out.writeInt(mBluetoothClass);
+        mBqrVsCommon.writeToParcel(out, flags);
+        int id = mBqrCommon.getQualityReportId();
+        if (id == QUALITY_REPORT_ID_APPROACH_LSTO) {
+            mBqrVsLsto.writeToParcel(out, flags);
+        } else if (id == QUALITY_REPORT_ID_A2DP_CHOPPY) {
+            mBqrVsA2dpChoppy.writeToParcel(out, flags);
+        } else if (id == QUALITY_REPORT_ID_SCO_CHOPPY) {
+            mBqrVsScoChoppy.writeToParcel(out, flags);
+        } else if (id == QUALITY_REPORT_ID_CONN_FAIL) {
+            mBqrVsConnectFail.writeToParcel(out, flags);
+        }
+    }
+
+    @Override
+    public String toString() {
+        String str;
+        str =  ""BQR: {\n""
+             + ""  mAddr: "" + mAddr
+             + "", mLmpVer: "" + String.format(""0x%02X"", mLmpVer)
+             + "", mLmpSubVer: "" + String.format(""0x%04X"", mLmpSubVer)
+             + "", mManufacturerId: "" + String.format(""0x%04X"", mManufacturerId)
+             + "", mName: "" + mName
+             + "", mBluetoothClass: "" + String.format(""0x%X"", mBluetoothClass)
+             + "",\n""
+             + mBqrCommon + ""\n""
+             + mBqrVsCommon + ""\n"";
+
+        int id = mBqrCommon.getQualityReportId();
+        if (id == QUALITY_REPORT_ID_APPROACH_LSTO) {
+            str += mBqrVsLsto + ""\n}"";
+        } else if (id == QUALITY_REPORT_ID_A2DP_CHOPPY) {
+            str += mBqrVsA2dpChoppy + ""\n}"";
+        } else if (id == QUALITY_REPORT_ID_SCO_CHOPPY) {
+            str += mBqrVsScoChoppy + ""\n}"";
+        } else if (id == QUALITY_REPORT_ID_CONN_FAIL) {
+            str += mBqrVsConnectFail + ""\n}"";
+        } else if (id == QUALITY_REPORT_ID_MONITOR) {
+            str += ""}"";
+        }
+
+        return str;
+    }
+
+    /**
+     * This class provides the public APIs to access the common part of BQR event.
+     */
+    public class BqrCommon implements Parcelable {
+        private static final String TAG = BluetoothQualityReport.TAG + "".BqrCommon"";
+        static final int BQR_COMMON_LEN = 48;
+
+        private int mQualityReportId;
+        private int mPacketType;
+        private int mConnectionHandle;
+        private int mConnectionRole;
+        private int mTxPowerLevel;
+        private int mRssi;
+        private int mSnr;
+        private int mUnusedAfhChannelCount;
+        private int mAfhSelectUnidealChannelCount;
+        private int mLsto;
+        private long mPiconetClock;
+        private long mRetransmissionCount;
+        private long mNoRxCount;
+        private long mNakCount;
+        private long mLastTxAckTimestamp;
+        private long mFlowOffCount;
+        private long mLastFlowOnTimestamp;
+        private long mOverflowCount;
+        private long mUnderflowCount;
+
+        private BqrCommon(byte[] rawData, int offset) {
+            if (rawData == null || rawData.length < offset + BQR_COMMON_LEN) {
+                throw new IllegalArgumentException(TAG + "": BQR raw data length is abnormal."");
+            }
+
+            ByteBuffer bqrBuf = ByteBuffer.wrap(rawData, offset, rawData.length - offset)
+                                          .asReadOnlyBuffer();
+            bqrBuf.order(ByteOrder.LITTLE_ENDIAN);
+
+            mQualityReportId = bqrBuf.get() & 0xFF;
+            mPacketType = bqrBuf.get() & 0xFF;
+            mConnectionHandle = bqrBuf.getShort() & 0xFFFF;
+            mConnectionRole = bqrBuf.get() & 0xFF;
+            mTxPowerLevel = bqrBuf.get() & 0xFF;
+            mRssi = bqrBuf.get();
+            mSnr = bqrBuf.get();
+            mUnusedAfhChannelCount = bqrBuf.get() & 0xFF;
+            mAfhSelectUnidealChannelCount = bqrBuf.get() & 0xFF;
+            mLsto = bqrBuf.getShort() & 0xFFFF;
+            mPiconetClock = bqrBuf.getInt() & 0xFFFFFFFFL;
+            mRetransmissionCount = bqrBuf.getInt() & 0xFFFFFFFFL;
+            mNoRxCount = bqrBuf.getInt() & 0xFFFFFFFFL;
+            mNakCount = bqrBuf.getInt() & 0xFFFFFFFFL;
+            mLastTxAckTimestamp = bqrBuf.getInt() & 0xFFFFFFFFL;
+            mFlowOffCount = bqrBuf.getInt() & 0xFFFFFFFFL;
+            mLastFlowOnTimestamp = bqrBuf.getInt() & 0xFFFFFFFFL;
+            mOverflowCount = bqrBuf.getInt() & 0xFFFFFFFFL;
+            mUnderflowCount = bqrBuf.getInt() & 0xFFFFFFFFL;
+        }
+
+        private BqrCommon(Parcel in) {
+            mQualityReportId = in.readInt();
+            mPacketType = in.readInt();
+            mConnectionHandle = in.readInt();
+            mConnectionRole = in.readInt();
+            mTxPowerLevel = in.readInt();
+            mRssi = in.readInt();
+            mSnr = in.readInt();
+            mUnusedAfhChannelCount = in.readInt();
+            mAfhSelectUnidealChannelCount = in.readInt();
+            mLsto = in.readInt();
+            mPiconetClock = in.readLong();
+            mRetransmissionCount = in.readLong();
+            mNoRxCount = in.readLong();
+            mNakCount = in.readLong();
+            mLastTxAckTimestamp = in.readLong();
+            mFlowOffCount = in.readLong();
+            mLastFlowOnTimestamp = in.readLong();
+            mOverflowCount = in.readLong();
+            mUnderflowCount = in.readLong();
+        }
+
+        int getQualityReportId() {
+            return mQualityReportId;
+        }
+
+        /**
+         * Get the packet type of the connection.
+         * @return the packet type.
+         */
+        public int getPacketType() {
+            return mPacketType;
+        }
+
+        /**
+         * Get the string of packet type
+         * @return the string of packet type.
+         */
+        public String getPacketTypeStr() {
+            PacketType type = PacketType.fromOrdinal(mPacketType);
+            return type.toString();
+        }
+
+        /**
+         * Get the connecton handle of the connection
+         * @return the connecton handle.
+         */
+        public int getConnectionHandle() {
+            return mConnectionHandle;
+        }
+
+        /**
+         * Get the connecton Role of the connection, ""Master"" or ""Slave"".
+         * @return the connecton Role.
+         */
+        public String getConnectionRole() {
+            if (mConnectionRole == 0) {
+                return ""Master"";
+            } else if (mConnectionRole == 1) {
+                return ""Slave"";
+            } else {
+                return ""INVALID:"" + mConnectionRole;
+            }
+        }
+
+        /**
+         * Get the current transmit power level for the connection.
+         * @return the TX power level.
+         */
+        public int getTxPowerLevel() {
+            return mTxPowerLevel;
+        }
+
+        /**
+         * Get the Received Signal Strength Indication (RSSI) value for the connection.
+         * @return the RSSI.
+         */
+        public int getRssi() {
+            return mRssi;
+        }
+
+        /**
+         * get the Signal-to-Noise Ratio (SNR) value for the connection.
+         * @return the SNR.
+         */
+        public int getSnr() {
+            return mSnr;
+        }
+
+        /**
+         * Get the number of unused channels in AFH_channel_map.
+         * @return the number of unused channels.
+         */
+        public int getUnusedAfhChannelCount() {
+            return mUnusedAfhChannelCount;
+        }
+
+        /**
+         * Get the number of the channels which are interfered and quality is
+         * bad but are still selected for AFH.
+         * @return the number of the selected unideal channels.
+         */
+        public int getAfhSelectUnidealChannelCount() {
+            return mAfhSelectUnidealChannelCount;
+        }
+
+        /**
+         * Get the current link supervision timeout setting.
+         * time_ms: N * 0.625 ms (1 slot).
+         * @return link supervision timeout value.
+         */
+        public int getLsto() {
+            return mLsto;
+        }
+
+        /**
+         * Get the piconet clock for the specified Connection_Handle.
+         * time_ms: N * 0.3125 ms (1 Bluetooth Clock).
+         * @return the piconet clock.
+         */
+        public long getPiconetClock() {
+            return mPiconetClock;
+        }
+
+        /**
+         * Get the count of retransmission.
+         * @return the count of retransmission.
+         */
+        public long getRetransmissionCount() {
+            return mRetransmissionCount;
+        }
+
+        /**
+         * Get the count of no RX.
+         * @return the count of no RX.
+         */
+        public long getNoRxCount() {
+            return mNoRxCount;
+        }
+
+        /**
+         * Get the count of NAK(Negative Acknowledge).
+         * @return the count of NAK.
+         */
+        public long getNakCount() {
+            return mNakCount;
+        }
+
+        /**
+         * Get the timestamp of last TX ACK.
+         * time_ms: N * 0.3125 ms (1 Bluetooth Clock).
+         * @return the timestamp of last TX ACK.
+         */
+        public long getLastTxAckTimestamp() {
+            return mLastTxAckTimestamp;
+        }
+
+        /**
+         * Get the count of flow-off.
+         * @return the count of flow-off.
+         */
+        public long getFlowOffCount() {
+            return mFlowOffCount;
+        }
+
+        /**
+         * Get the timestamp of last flow-on.
+         * @return the timestamp of last flow-on.
+         */
+        public long getLastFlowOnTimestamp() {
+            return mLastFlowOnTimestamp;
+        }
+
+        /**
+         * Get the buffer overflow count (how many bytes of TX data are dropped) since the
+         * last event.
+         * @return the buffer overflow count.
+         */
+        public long getOverflowCount() {
+            return mOverflowCount;
+        }
+
+        /**
+         * Get the buffer underflow count (in byte).
+         * @return the buffer underflow count.
+         */
+        public long getUnderflowCount() {
+            return mUnderflowCount;
+        }
+
+        public int describeContents() {
+            return 0;
+        }
+
+        @Override
+        public void writeToParcel(Parcel dest, int flags) {
+            dest.writeInt(mQualityReportId);
+            dest.writeInt(mPacketType);
+            dest.writeInt(mConnectionHandle);
+            dest.writeInt(mConnectionRole);
+            dest.writeInt(mTxPowerLevel);
+            dest.writeInt(mRssi);
+            dest.writeInt(mSnr);
+            dest.writeInt(mUnusedAfhChannelCount);
+            dest.writeInt(mAfhSelectUnidealChannelCount);
+            dest.writeInt(mLsto);
+            dest.writeLong(mPiconetClock);
+            dest.writeLong(mRetransmissionCount);
+            dest.writeLong(mNoRxCount);
+            dest.writeLong(mNakCount);
+            dest.writeLong(mLastTxAckTimestamp);
+            dest.writeLong(mFlowOffCount);
+            dest.writeLong(mLastFlowOnTimestamp);
+            dest.writeLong(mOverflowCount);
+            dest.writeLong(mUnderflowCount);
+        }
+
+        @Override
+        public String toString() {
+            String str;
+            str =  ""  BqrCommon: {\n""
+                 + ""    mQualityReportId: "" + BluetoothQualityReport.this.getQualityReportIdStr()
+                                            + ""("" + String.format(""0x%02X"", mQualityReportId) + "")""
+                 + "", mPacketType: "" + getPacketTypeStr()
+                                     + ""("" + String.format(""0x%02X"", mPacketType) + "")""
+                 + "", mConnectionHandle: "" + String.format(""0x%04X"", mConnectionHandle)
+                 + "", mConnectionRole: "" + getConnectionRole() + ""("" + mConnectionRole + "")""
+                 + "", mTxPowerLevel: "" + mTxPowerLevel
+                 + "", mRssi: "" + mRssi
+                 + "", mSnr: "" + mSnr
+                 + "", mUnusedAfhChannelCount: "" + mUnusedAfhChannelCount
+                 + "",\n""
+                 + ""    mAfhSelectUnidealChannelCount: "" + mAfhSelectUnidealChannelCount
+                 + "", mLsto: "" + mLsto
+                 + "", mPiconetClock: "" + String.format(""0x%08X"", mPiconetClock)
+                 + "", mRetransmissionCount: "" + mRetransmissionCount
+                 + "", mNoRxCount: "" + mNoRxCount
+                 + "", mNakCount: "" + mNakCount
+                 + "", mLastTxAckTimestamp: "" + String.format(""0x%08X"", mLastTxAckTimestamp)
+                 + "", mFlowOffCount: "" + mFlowOffCount
+                 + "",\n""
+                 + ""    mLastFlowOnTimestamp: "" + String.format(""0x%08X"", mLastFlowOnTimestamp)
+                 + "", mOverflowCount: "" + mOverflowCount
+                 + "", mUnderflowCount: "" + mUnderflowCount
+                 + ""\n  }"";
+
+            return str;
+        }
+
+    }
+
+    /**
+     * This class provides the public APIs to access the vendor specific common part of
+     * BQR event.
+     */
+    public class BqrVsCommon implements Parcelable {
+        private static final String TAG = BluetoothQualityReport.TAG + "".BqrVsCommon"";
+        private static final int BQR_VS_COMMON_LEN = 6 + 1;
+
+        private String mAddr;
+        private int mCalFailedItemCount;
+
+        private BqrVsCommon(byte[] rawData, int offset) {
+            if (rawData == null || rawData.length < offset + BQR_VS_COMMON_LEN) {
+                throw new IllegalArgumentException(TAG + "": BQR raw data length is abnormal."");
+            }
+
+            ByteBuffer bqrBuf = ByteBuffer.wrap(rawData, offset, rawData.length - offset)
+                                          .asReadOnlyBuffer();
+            bqrBuf.order(ByteOrder.LITTLE_ENDIAN);
+
+            mAddr = String.format(""%02X:%02X:%02X:%02X:%02X:%02X"", bqrBuf.get(offset+5),
+                    bqrBuf.get(offset+4), bqrBuf.get(offset+3), bqrBuf.get(offset+2),
+                    bqrBuf.get(offset+1), bqrBuf.get(offset+0));
+            bqrBuf.position(offset+6);
+            mCalFailedItemCount = bqrBuf.get() & 0xFF;
+        }
+
+        private BqrVsCommon(Parcel in) {
+            mAddr = in.readString();
+            mCalFailedItemCount = in.readInt();
+        }
+
+        /**
+         * Get the count of calibration failed items.
+         * @return the count of calibration failure.
+         */
+        public int getCalFailedItemCount() {
+            return mCalFailedItemCount;
+        }
+
+        int getLength() {
+            return BQR_VS_COMMON_LEN;
+        }
+
+        public int describeContents() {
+            return 0;
+        }
+
+        @Override
+        public void writeToParcel(Parcel dest, int flags) {
+            dest.writeString(mAddr);
+            dest.writeInt(mCalFailedItemCount);
+        }
+
+        @Override
+        public String toString() {
+            String str;
+            str =  ""  BqrVsCommon: {\n""
+                 + ""    mAddr: "" + mAddr
+                 + "", mCalFailedItemCount: "" + mCalFailedItemCount
+                 + ""\n  }"";
+
+            return str;
+        }
+    }
+
+    /**
+     * This class provides the public APIs to access the vendor specific part of
+     * Approaching LSTO event.
+     */
+    public class BqrVsLsto implements Parcelable {
+        private static final String TAG = BluetoothQualityReport.TAG + "".BqrVsLsto"";
+
+        private int mConnState;
+        private long mBasebandStats;
+        private long mSlotsUsed;
+        private int mCxmDenials;
+        private int mTxSkipped;
+        private int mRfLoss;
+        private long mNativeClock;
+        private long mLastTxAckTimestamp;
+
+        private BqrVsLsto(byte[] rawData, int offset) {
+            if (rawData == null || rawData.length <= offset) {
+                throw new IllegalArgumentException(TAG + "": BQR raw data length is abnormal."");
+            }
+
+            ByteBuffer bqrBuf = ByteBuffer.wrap(rawData, offset, rawData.length - offset)
+                                          .asReadOnlyBuffer();
+            bqrBuf.order(ByteOrder.LITTLE_ENDIAN);
+
+            mConnState = bqrBuf.get() & 0xFF;
+            mBasebandStats = bqrBuf.getInt() & 0xFFFFFFFFL;
+            mSlotsUsed = bqrBuf.getInt() & 0xFFFFFFFFL;
+            mCxmDenials = bqrBuf.getShort() & 0xFFFF;
+            mTxSkipped = bqrBuf.getShort() & 0xFFFF;
+            mRfLoss = bqrBuf.getShort() & 0xFFFF;
+            mNativeClock = bqrBuf.getInt() & 0xFFFFFFFFL;
+            mLastTxAckTimestamp = bqrBuf.getInt() & 0xFFFFFFFFL;
+        }
+
+        private BqrVsLsto(Parcel in) {
+            mConnState = in.readInt();
+            mBasebandStats = in.readLong();
+            mSlotsUsed = in.readLong();
+            mCxmDenials = in.readInt();
+            mTxSkipped = in.readInt();
+            mRfLoss = in.readInt();
+            mNativeClock = in.readLong();
+            mLastTxAckTimestamp = in.readLong();
+        }
+
+        /**
+         * Get the conn state of sco.
+         * @return the conn state.
+         */
+        public int getConnState() {
+            return mConnState;
+        }
+
+        /**
+         * Get the string of conn state of sco.
+         * @return the string of conn state.
+         */
+        public String getConnStateStr() {
+            return ConnState.getName(mConnState);
+        }
+
+        /**
+         * Get the baseband statistics.
+         * @return the baseband statistics.
+         */
+        public long getBasebandStats() {
+            return mBasebandStats;
+        }
+
+        /**
+         * Get the count of slots allocated for current connection.
+         * @return the count of slots allocated for current connection.
+         */
+        public long getSlotsUsed() {
+            return mSlotsUsed;
+        }
+
+        /**
+         * Get the count of Coex denials.
+         * @return the count of CXM denials.
+         */
+        public int getCxmDenials() {
+            return mCxmDenials;
+        }
+
+        /**
+         * Get the count of TX skipped when no poll from remote device.
+         * @return the count of TX skipped.
+         */
+        public int getTxSkipped() {
+            return mTxSkipped;
+        }
+
+        /**
+         * Get the count of RF loss.
+         * @return the count of RF loss.
+         */
+        public int getRfLoss() {
+            return mRfLoss;
+        }
+
+        /**
+         * Get the timestamp when issue happened.
+         * time_ms: N * 0.3125 ms (1 Bluetooth Clock).
+         * @return the timestamp when issue happened.
+         */
+        public long getNativeClock() {
+            return mNativeClock;
+        }
+
+        /**
+         * Get the timestamp of last TX ACK.
+         * time_ms: N * 0.3125 ms (1 Bluetooth Clock).
+         * @return the timestamp of last TX ACK.
+         */
+        public long getLastTxAckTimestamp() {
+            return mLastTxAckTimestamp;
+        }
+
+        public int describeContents() {
+            return 0;
+        }
+
+        @Override
+        public void writeToParcel(Parcel dest, int flags) {
+            dest.writeInt(mConnState);
+            dest.writeLong(mBasebandStats);
+            dest.writeLong(mSlotsUsed);
+            dest.writeInt(mCxmDenials);
+            dest.writeInt(mTxSkipped);
+            dest.writeInt(mRfLoss);
+            dest.writeLong(mNativeClock);
+            dest.writeLong(mLastTxAckTimestamp);
+        }
+
+        @Override
+        public String toString() {
+            String str;
+            str =  ""  BqrVsLsto: {\n""
+                 + ""    mConnState: "" + getConnStateStr()
+                                      + ""("" + String.format(""0x%02X"", mConnState) + "")""
+                 + "", mBasebandStats: "" + String.format(""0x%08X"", mBasebandStats)
+                 + "", mSlotsUsed: "" + mSlotsUsed
+                 + "", mCxmDenials: "" + mCxmDenials
+                 + "", mTxSkipped: "" + mTxSkipped
+                 + "", mRfLoss: "" + mRfLoss
+                 + "", mNativeClock: "" + String.format(""0x%08X"", mNativeClock)
+                 + "", mLastTxAckTimestamp: "" + String.format(""0x%08X"", mLastTxAckTimestamp)
+                 + ""\n  }"";
+
+            return str;
+        }
+    }
+
+    /**
+     * This class provides the public APIs to access the vendor specific part of
+     * A2dp choppy event.
+     */
+    public class BqrVsA2dpChoppy implements Parcelable {
+        private static final String TAG = BluetoothQualityReport.TAG + "".BqrVsA2dpChoppy"";
+
+        private long mArrivalTime;
+        private long mScheduleTime;
+        private int mGlitchCount;
+        private int mTxCxmDenials;
+        private int mRxCxmDenials;
+        private int mAclTxQueueLength;
+        private int mLinkQuality;
+
+        private BqrVsA2dpChoppy(byte[] rawData, int offset) {
+            if (rawData == null || rawData.length <= offset) {
+                throw new IllegalArgumentException(TAG + "": BQR raw data length is abnormal."");
+            }
+
+            ByteBuffer bqrBuf = ByteBuffer.wrap(rawData, offset, rawData.length - offset)
+                                          .asReadOnlyBuffer();
+            bqrBuf.order(ByteOrder.LITTLE_ENDIAN);
+
+            mArrivalTime = bqrBuf.getInt() & 0xFFFFFFFFL;
+            mScheduleTime = bqrBuf.getInt() & 0xFFFFFFFFL;
+            mGlitchCount = bqrBuf.getShort() & 0xFFFF;
+            mTxCxmDenials = bqrBuf.getShort() & 0xFFFF;
+            mRxCxmDenials = bqrBuf.getShort() & 0xFFFF;
+            mAclTxQueueLength = bqrBuf.get() & 0xFF;
+            mLinkQuality = bqrBuf.get() & 0xFF;
+        }
+
+        private BqrVsA2dpChoppy(Parcel in) {
+            mArrivalTime = in.readLong();
+            mScheduleTime = in.readLong();
+            mGlitchCount = in.readInt();
+            mTxCxmDenials = in.readInt();
+            mRxCxmDenials = in.readInt();
+            mAclTxQueueLength = in.readInt();
+            mLinkQuality = in.readInt();
+        }
+
+        /**
+         * Get the timestamp of a2dp packet arrived.
+         * time_ms: N * 0.3125 ms (1 Bluetooth Clock).
+         * @return the timestamp of a2dp packet arrived.
+         */
+        public long getArrivalTime() {
+            return mArrivalTime;
+        }
+
+        /**
+         * Get the timestamp of a2dp packet scheduled.
+         * time_ms: N * 0.3125 ms (1 Bluetooth Clock).
+         * @return the timestamp of a2dp packet scheduled.
+         */
+        public long getScheduleTime() {
+            return mScheduleTime;
+        }
+
+        /**
+         * Get the a2dp glitch count since the last event.
+         * @return the a2dp glitch count.
+         */
+        public int getGlitchCount() {
+            return mGlitchCount;
+        }
+
+        /**
+         * Get the count of Coex TX denials.
+         * @return the count of Coex TX denials.
+         */
+        public int getTxCxmDenials() {
+            return mTxCxmDenials;
+        }
+
+        /**
+         * Get the count of Coex RX denials.
+         * @return the count of Coex RX denials.
+         */
+        public int getRxCxmDenials() {
+            return mRxCxmDenials;
+        }
+
+        /**
+         * Get the ACL queue length which are pending TX in FW.
+         * @return the ACL queue length.
+         */
+        public int getAclTxQueueLength() {
+            return mAclTxQueueLength;
+        }
+
+        /**
+         * Get the link quality for the current connection.
+         * @return the link quality.
+         */
+        public int getLinkQuality() {
+            return mLinkQuality;
+        }
+
+        /**
+         * Get the string of link quality for the current connection.
+         * @return the string of link quality.
+         */
+        public String getLinkQualityStr() {
+            LinkQuality q = LinkQuality.fromOrdinal(mLinkQuality);
+            return q.toString();
+        }
+
+        public int describeContents() {
+            return 0;
+        }
+
+        @Override
+        public void writeToParcel(Parcel dest, int flags) {
+            dest.writeLong(mArrivalTime);
+            dest.writeLong(mScheduleTime);
+            dest.writeInt(mGlitchCount);
+            dest.writeInt(mTxCxmDenials);
+            dest.writeInt(mRxCxmDenials);
+            dest.writeInt(mAclTxQueueLength);
+            dest.writeInt(mLinkQuality);
+        }
+
+        @Override
+        public String toString() {
+            String str;
+            str =  ""  BqrVsA2dpChoppy: {\n""
+                 + ""    mArrivalTime: "" + String.format(""0x%08X"", mArrivalTime)
+                 + "", mScheduleTime: "" + String.format(""0x%08X"", mScheduleTime)
+                 + "", mGlitchCount: "" + mGlitchCount
+                 + "", mTxCxmDenials: "" + mTxCxmDenials
+                 + "", mRxCxmDenials: "" + mRxCxmDenials
+                 + "", mAclTxQueueLength: "" + mAclTxQueueLength
+                 + "", mLinkQuality: "" + getLinkQualityStr()
+                                      + ""("" + String.format(""0x%02X"", mLinkQuality) + "")""
+                 + ""\n  }"";
+
+            return str;
+        }
+
+    }
+
+    /**
+     * This class provides the public APIs to access the vendor specific part of
+     * SCO choppy event.
+     */
+    public class BqrVsScoChoppy implements Parcelable {
+        private static final String TAG = BluetoothQualityReport.TAG + "".BqrVsScoChoppy"";
+
+        private int mGlitchCount;
+        private int mIntervalEsco;
+        private int mWindowEsco;
+        private int mAirFormat;
+        private int mInstanceCount;
+        private int mTxCxmDenials;
+        private int mRxCxmDenials;
+        private int mTxAbortCount;
+        private int mLateDispatch;
+        private int mMicIntrMiss;
+        private int mLpaIntrMiss;
+        private int mSprIntrMiss;
+        private int mPlcFillCount;
+        private int mPlcDiscardCount;
+
+        private BqrVsScoChoppy(byte[] rawData, int offset) {
+            if (rawData == null || rawData.length <= offset) {
+                throw new IllegalArgumentException(TAG + "": BQR raw data length is abnormal."");
+            }
+
+            ByteBuffer bqrBuf = ByteBuffer.wrap(rawData, offset, rawData.length - offset)
+                                          .asReadOnlyBuffer();
+            bqrBuf.order(ByteOrder.LITTLE_ENDIAN);
+
+            mGlitchCount = bqrBuf.getShort() & 0xFFFF;
+            mIntervalEsco = bqrBuf.get() & 0xFF;
+            mWindowEsco = bqrBuf.get() & 0xFF;
+            mAirFormat = bqrBuf.get() & 0xFF;
+            mInstanceCount = bqrBuf.getShort() & 0xFFFF;
+            mTxCxmDenials = bqrBuf.getShort() & 0xFFFF;
+            mRxCxmDenials = bqrBuf.getShort() & 0xFFFF;
+            mTxAbortCount = bqrBuf.getShort() & 0xFFFF;
+            mLateDispatch = bqrBuf.getShort() & 0xFFFF;
+            mMicIntrMiss = bqrBuf.getShort() & 0xFFFF;
+            mLpaIntrMiss = bqrBuf.getShort() & 0xFFFF;
+            mSprIntrMiss = bqrBuf.getShort() & 0xFFFF;
+            mPlcFillCount = bqrBuf.getShort() & 0xFFFF;
+            mPlcDiscardCount = bqrBuf.getShort() & 0xFFFF;
+        }
+
+        private BqrVsScoChoppy(Parcel in) {
+            mGlitchCount = in.readInt();
+            mIntervalEsco = in.readInt();
+            mWindowEsco = in.readInt();
+            mAirFormat = in.readInt();
+            mInstanceCount = in.readInt();
+            mTxCxmDenials = in.readInt();
+            mRxCxmDenials = in.readInt();
+            mTxAbortCount = in.readInt();
+            mLateDispatch = in.readInt();
+            mMicIntrMiss = in.readInt();
+            mLpaIntrMiss = in.readInt();
+            mSprIntrMiss = in.readInt();
+            mPlcFillCount = in.readInt();
+            mPlcDiscardCount = in.readInt();
+        }
+
+        /**
+         * Get the sco glitch count since the last event.
+         * @return the sco glitch count.
+         */
+        public int getGlitchCount() {
+            return mGlitchCount;
+        }
+
+        /**
+         * Get ESCO interval in slots. It is the value of Transmission_Interval parameter in
+         * Synchronous Connection Complete event.
+         * @return ESCO interval in slots.
+         */
+        public int getIntervalEsco() {
+            return mIntervalEsco;
+        }
+
+        /**
+         * Get ESCO window in slots. It is the value of Retransmission Window parameter in
+         * Synchronous Connection Complete event.
+         * @return ESCO window in slots.
+         */
+        public int getWindowEsco() {
+            return mWindowEsco;
+        }
+
+        /**
+         * Get the air mode. It is the value of Air Mode parameter in
+         * Synchronous Connection Complete event.
+         * @return the air mode.
+         */
+        public int getAirFormat() {
+            return mAirFormat;
+        }
+
+        /**
+         * Get the string of air mode.
+         * @return the string of air mode.
+         */
+        public String getAirFormatStr() {
+            AirMode m = AirMode.fromOrdinal(mAirFormat);
+            return m.toString();
+        }
+
+        /**
+         * Get the xSCO instance count.
+         * @return the xSCO instance count.
+         */
+        public int getInstanceCount() {
+            return mInstanceCount;
+        }
+
+        /**
+         * Get the count of Coex TX denials.
+         * @return the count of Coex TX denials.
+         */
+        public int getTxCxmDenials() {
+            return mTxCxmDenials;
+        }
+
+        /**
+         * Get the count of Coex RX denials.
+         * @return the count of Coex RX denials.
+         */
+        public int getRxCxmDenials() {
+            return mRxCxmDenials;
+        }
+
+        /**
+         * Get the count of sco packets aborted.
+         * @return the count of sco packets aborted.
+         */
+        public int getTxAbortCount() {
+            return mTxAbortCount;
+        }
+
+        /**
+         * Get the count of sco packets dispatched late.
+         * @return the count of sco packets dispatched late.
+         */
+        public int getLateDispatch() {
+            return mLateDispatch;
+        }
+
+        /**
+         * Get the count of missed Mic interrrupts.
+         * @return the count of missed Mic interrrupts.
+         */
+        public int getMicIntrMiss() {
+            return mMicIntrMiss;
+        }
+
+        /**
+         * Get the count of missed LPA interrrupts.
+         * @return the count of missed LPA interrrupts.
+         */
+        public int getLpaIntrMiss() {
+            return mLpaIntrMiss;
+        }
+
+        /**
+         * Get the count of missed Speaker interrrupts.
+         * @return the count of missed Speaker interrrupts.
+         */
+        public int getSprIntrMiss() {
+            return mSprIntrMiss;
+        }
+
+        /**
+         * Get the count of packet loss concealment filled.
+         * @return the count of packet loss concealment filled.
+         */
+        public int getPlcFillCount() {
+            return mPlcFillCount;
+        }
+
+        /**
+         * Get the count of packet loss concealment discarded.
+         * @return the count of packet loss concealment discarded.
+         */
+        public int getPlcDiscardCount() {
+            return mPlcDiscardCount;
+        }
+
+        public int describeContents() {
+            return 0;
+        }
+
+        @Override
+        public void writeToParcel(Parcel dest, int flags) {
+            dest.writeInt(mGlitchCount);
+            dest.writeInt(mIntervalEsco);
+            dest.writeInt(mWindowEsco);
+            dest.writeInt(mAirFormat);
+            dest.writeInt(mInstanceCount);
+            dest.writeInt(mTxCxmDenials);
+            dest.writeInt(mRxCxmDenials);
+            dest.writeInt(mTxAbortCount);
+            dest.writeInt(mLateDispatch);
+            dest.writeInt(mMicIntrMiss);
+            dest.writeInt(mLpaIntrMiss);
+            dest.writeInt(mSprIntrMiss);
+            dest.writeInt(mPlcFillCount);
+            dest.writeInt(mPlcDiscardCount);
+        }
+
+        @Override
+        public String toString() {
+            String str;
+            str =  ""  BqrVsScoChoppy: {\n""
+                 + ""    mGlitchCount: "" + mGlitchCount
+                 + "", mIntervalEsco: "" + mIntervalEsco
+                 + "", mWindowEsco: "" + mWindowEsco
+                 + "", mAirFormat: "" + getAirFormatStr()
+                                    + ""("" + String.format(""0x%02X"", mAirFormat) + "")""
+                 + "", mInstanceCount: "" + mInstanceCount
+                 + "", mTxCxmDenials: "" + mTxCxmDenials
+                 + "", mRxCxmDenials: "" + mRxCxmDenials
+                 + "", mTxAbortCount: "" + mTxAbortCount
+                 + "",\n""
+                 + ""    mLateDispatch: "" + mLateDispatch
+                 + "", mMicIntrMiss: "" + mMicIntrMiss
+                 + "", mLpaIntrMiss: "" + mLpaIntrMiss
+                 + "", mSprIntrMiss: "" + mSprIntrMiss
+                 + "", mPlcFillCount: "" + mPlcFillCount
+                 + "", mPlcDiscardCount: "" + mPlcDiscardCount
+                 + ""\n  }"";
+
+            return str;
+        }
+
+    }
+
+    /**
+     * This class provides the public APIs to access the vendor specific part of
+     * Connect fail event.
+     */
+    public class BqrVsConnectFail implements Parcelable {
+        private static final String TAG = BluetoothQualityReport.TAG + "".BqrVsConnectFail"";
+
+        private int mFailReason;
+
+        private BqrVsConnectFail(byte[] rawData, int offset) {
+            if (rawData == null || rawData.length <= offset) {
+                throw new IllegalArgumentException(TAG + "": BQR raw data length is abnormal."");
+            }
+
+            ByteBuffer bqrBuf = ByteBuffer.wrap(rawData, offset, rawData.length - offset)
+                                          .asReadOnlyBuffer();
+            bqrBuf.order(ByteOrder.LITTLE_ENDIAN);
+
+            mFailReason = bqrBuf.get() & 0xFF;
+        }
+
+        private BqrVsConnectFail(Parcel in) {
+            mFailReason = in.readInt();
+        }
+
+        /**
+         * Get the fail reason.
+         * @return the fail reason.
+         */
+        public int getFailReason() {
+            return mFailReason;
+        }
+
+        public int describeContents() {
+            return 0;
+        }
+
+        @Override
+        public void writeToParcel(Parcel dest, int flags) {
+            dest.writeInt(mFailReason);
+        }
+
+        @Override
+        public String toString() {
+            String str;
+            str =  ""  BqrVsConnectFail: {\n""
+                 + ""    mFailReason: "" + String.format(""0x%02X"", mFailReason)
+                 + ""\n  }"";
+
+            return str;
+        }
+    }
+
+}
",1389,0,"BluetoothQualityReport::BqrVsA2dpChoppy::BqrVsA2dpChoppy, BluetoothQualityReport::BqrVsScoChoppy::getMicIntrMiss, BluetoothQualityReport::BqrVsLsto::toString, BluetoothQualityReport::BqrVsCommon::writeToParcel, BluetoothQualityReport::BqrVsLsto::getConnState, BluetoothQualityReport::BqrCommon::getUnusedAfhChannelCount, BluetoothQualityReport::getBqrCommon, BluetoothQualityReport::BqrVsLsto::BqrVsLsto, BluetoothQualityReport::BqrCommon::getFlowOffCount, BluetoothQualityReport::BqrCommon::getOverflowCount, BluetoothQualityReport::BqrCommon::BqrCommon, BluetoothQualityReport::BqrVsLsto::getLastTxAckTimestamp, BluetoothQualityReport::BqrCommon::getNakCount, BluetoothQualityReport::BqrVsA2dpChoppy::toString, BluetoothQualityReport::BqrCommon::writeToParcel, BluetoothQualityReport::BqrVsA2dpChoppy::getAclTxQueueLength, BluetoothQualityReport::BqrVsA2dpChoppy::getLinkQuality, BluetoothQualityReport::getBqrVsLsto, BluetoothQualityReport::BqrVsA2dpChoppy::getRxCxmDenials, BluetoothQualityReport::getBqrVsA2dpChoppy, BluetoothQualityReport::BqrVsScoChoppy::getGlitchCount, BluetoothQualityReport::BqrVsCommon::getLength, BluetoothQualityReport::BqrCommon::toString, BluetoothQualityReport::BqrVsLsto::getRfLoss, BluetoothQualityReport::BqrVsLsto::describeContents, BluetoothQualityReport::BqrVsScoChoppy::getLateDispatch, BluetoothQualityReport::BqrCommon::getLastFlowOnTimestamp, BluetoothQualityReport::BqrVsCommon::BqrVsCommon, BluetoothQualityReport::BqrVsLsto::getCxmDenials, BluetoothQualityReport::describeContents, BluetoothQualityReport::BqrVsLsto::getBasebandStats, BluetoothQualityReport::BqrVsScoChoppy::describeContents, BluetoothQualityReport::BqrVsScoChoppy::getTxCxmDenials, BluetoothQualityReport::BluetoothQualityReport, BluetoothQualityReport::BqrCommon::getConnectionRole, BluetoothQualityReport::BqrVsLsto::BqrVsLsto, BluetoothQualityReport::BqrCommon::getConnectionHandle, BluetoothQualityReport::BqrVsScoChoppy::getRxCxmDenials, BluetoothQualityReport::BqrVsConnectFail::BqrVsConnectFail, BluetoothQualityReport::fromOrdinal, BluetoothQualityReport::getLmpSubVersion, BluetoothQualityReport::BqrVsA2dpChoppy::getGlitchCount, BluetoothQualityReport::BqrCommon::getUnderflowCount, BluetoothQualityReport::BqrVsScoChoppy::getAirFormat, BluetoothQualityReport::BqrCommon::getNoRxCount, BluetoothQualityReport::BqrVsLsto::getTxSkipped, BluetoothQualityReport::BqrVsA2dpChoppy::getTxCxmDenials, BluetoothQualityReport::BqrVsScoChoppy::getIntervalEsco, BluetoothQualityReport::BqrVsScoChoppy::toString, BluetoothQualityReport::BqrVsConnectFail::getFailReason, BluetoothQualityReport::BqrVsConnectFail::BqrVsConnectFail, BluetoothQualityReport::BqrVsA2dpChoppy::BqrVsA2dpChoppy, BluetoothQualityReport::BqrVsLsto::getSlotsUsed, BluetoothQualityReport::BqrVsConnectFail::toString, BluetoothQualityReport::getManufacturerId, BluetoothQualityReport::BqrVsConnectFail::writeToParcel, BluetoothQualityReport::BqrCommon::BqrCommon, BluetoothQualityReport::BluetoothQualityReport, BluetoothQualityReport::getBqrVsCommon, BluetoothQualityReport::BqrCommon::getPacketType, BluetoothQualityReport::BqrVsCommon::toString, BluetoothQualityReport::BqrCommon::getAfhSelectUnidealChannelCount, BluetoothQualityReport::BqrVsA2dpChoppy::describeContents, BluetoothQualityReport::BqrVsScoChoppy::getLpaIntrMiss, BluetoothQualityReport::BqrVsScoChoppy::getSprIntrMiss, BluetoothQualityReport::BqrVsCommon::BqrVsCommon, BluetoothQualityReport::BqrVsA2dpChoppy::writeToParcel, BluetoothQualityReport::BqrCommon::describeContents, BluetoothQualityReport::BqrVsScoChoppy::BqrVsScoChoppy, BluetoothQualityReport::getAddress, BluetoothQualityReport::BqrVsCommon::getCalFailedItemCount, BluetoothQualityReport::getBqrVsScoChoppy, BluetoothQualityReport::BqrCommon::getPiconetClock, BluetoothQualityReport::BqrVsScoChoppy::getPlcFillCount, BluetoothQualityReport::BqrVsLsto::writeToParcel, BluetoothQualityReport::getBluetoothClass, BluetoothQualityReport::BqrCommon::getRssi, BluetoothQualityReport::getName, BluetoothQualityReport::BqrVsScoChoppy::BqrVsScoChoppy, BluetoothQualityReport::getQualityReportId, BluetoothQualityReport::BqrCommon::getLastTxAckTimestamp, BluetoothQualityReport::writeToParcel, BluetoothQualityReport::BqrCommon::getSnr, BluetoothQualityReport::getLmpVersion, BluetoothQualityReport::BqrVsA2dpChoppy::getLinkQualityStr, BluetoothQualityReport::getName, BluetoothQualityReport::toString, BluetoothQualityReport::BqrCommon::getLsto, BluetoothQualityReport::BqrVsScoChoppy::getAirFormatStr, BluetoothQualityReport::BqrCommon::getPacketTypeStr, BluetoothQualityReport::BqrVsScoChoppy::getPlcDiscardCount, BluetoothQualityReport::getQualityReportIdStr, BluetoothQualityReport::ConnState, BluetoothQualityReport::getBqrVsConnectFail, BluetoothQualityReport::BqrVsA2dpChoppy::getScheduleTime, BluetoothQualityReport::BqrVsLsto::getNativeClock, BluetoothQualityReport::BqrVsScoChoppy::getInstanceCount, BluetoothQualityReport::BqrVsA2dpChoppy::getArrivalTime, BluetoothQualityReport::BqrVsScoChoppy::writeToParcel, BluetoothQualityReport::BqrCommon::getTxPowerLevel, BluetoothQualityReport::BqrVsLsto::getConnStateStr, BluetoothQualityReport::BqrVsCommon::describeContents, BluetoothQualityReport::BqrVsConnectFail::describeContents, BluetoothQualityReport::BqrVsScoChoppy::getTxAbortCount, BluetoothQualityReport::Creator<BluetoothQualityReport>, BluetoothQualityReport::BqrVsScoChoppy::getWindowEsco, BluetoothQualityReport::BqrCommon::getRetransmissionCount, BluetoothQualityReport::BqrCommon::getQualityReportId"
126,690a4c98f2fbd56a1533429f6f02b7b59cb2fb12,BluetoothCodecConfig.java,ModificationType.MODIFY,"@@ -42,9 +42,11 @@ public final class BluetoothCodecConfig implements Parcelable {
     @UnsupportedAppUsage
     public static final int SOURCE_CODEC_TYPE_APTX_HD = 3;
     @UnsupportedAppUsage
-    public static final int SOURCE_CODEC_TYPE_LDAC = 4;
+    public static final int SOURCE_CODEC_TYPE_APTX_ADAPTIVE = 4;
     @UnsupportedAppUsage
-    public static final int SOURCE_CODEC_TYPE_MAX = 5;
+    public static final int SOURCE_CODEC_TYPE_LDAC = 5;
+    @UnsupportedAppUsage
+    public static final int SOURCE_CODEC_TYPE_MAX = 6;
 
     @UnsupportedAppUsage
     public static final int SOURCE_CODEC_TYPE_INVALID = 1000 * 1000;
@@ -301,6 +303,8 @@ public final class BluetoothCodecConfig implements Parcelable {
                 return ""aptX HD"";
             case SOURCE_CODEC_TYPE_LDAC:
                 return ""LDAC"";
+            case SOURCE_CODEC_TYPE_APTX_ADAPTIVE:
+                return ""aptX Adaptive"";
             case SOURCE_CODEC_TYPE_INVALID:
                 return ""INVALID CODEC"";
             default:
",6,2,BluetoothCodecConfig::getCodecName
127,690a4c98f2fbd56a1533429f6f02b7b59cb2fb12,A2dpProfile.java,ModificationType.MODIFY,"@@ -291,6 +291,9 @@ public class A2dpProfile implements LocalBluetoothProfile {
            case BluetoothCodecConfig.SOURCE_CODEC_TYPE_LDAC:
                index = 5;
                break;
+           case BluetoothCodecConfig.SOURCE_CODEC_TYPE_APTX_ADAPTIVE:
+               index = 6;
+               break;
            }
 
         if (index < 0) {
",3,0,A2dpProfile::getHighQualityAudioOptionLabel
128,690a4c98f2fbd56a1533429f6f02b7b59cb2fb12,A2dpProfileTest.java,ModificationType.MODIFY,"@@ -129,7 +129,7 @@ public class A2dpProfileTest {
     private static String KNOWN_CODEC_LABEL = ""Use high quality audio: %1$s"";
     private static String UNKNOWN_CODEC_LABEL = ""Use high quality audio"";
     private static String[] CODEC_NAMES =
-            new String[]{""Default"", ""SBC"", ""AAC"", ""aptX"", ""aptX HD"", ""LDAC""};
+            new String[]{""Default"", ""SBC"", ""AAC"", ""aptX"", ""aptX HD"", ""LDAC"", ""aptX Adaptive""};
 
     /**
      * Helper for setting up several tests of getHighQualityAudioOptionLabel
",1,1,
129,b9f99a203d5474757510439d11e3db07ccc312e4,BluetoothCodecConfig.java,ModificationType.MODIFY,"@@ -46,7 +46,14 @@ public final class BluetoothCodecConfig implements Parcelable {
     @UnsupportedAppUsage
     public static final int SOURCE_CODEC_TYPE_LDAC = 5;
     @UnsupportedAppUsage
-    public static final int SOURCE_CODEC_TYPE_MAX = 6;
+    public static final int SOURCE_CODEC_TYPE_APTX_TWSP = 6;
+    @UnsupportedAppUsage
+    public static final int SOURCE_CODEC_TYPE_MAX = 7;
+    /* CELT is not an A2DP Codec and only used to fetch encoder
+    ** format for BA usecase, moving out of a2dp codec value list
+    */
+    @UnsupportedAppUsage
+    public static final int SOURCE_CODEC_TYPE_CELT = 8;
 
     @UnsupportedAppUsage
     public static final int SOURCE_CODEC_TYPE_INVALID = 1000 * 1000;
@@ -305,6 +312,8 @@ public final class BluetoothCodecConfig implements Parcelable {
                 return ""LDAC"";
             case SOURCE_CODEC_TYPE_APTX_ADAPTIVE:
                 return ""aptX Adaptive"";
+            case SOURCE_CODEC_TYPE_APTX_TWSP:
+                return ""aptX TWS+"";
             case SOURCE_CODEC_TYPE_INVALID:
                 return ""INVALID CODEC"";
             default:
",10,1,BluetoothCodecConfig::getCodecName
130,b9f99a203d5474757510439d11e3db07ccc312e4,A2dpProfile.java,ModificationType.MODIFY,"@@ -294,6 +294,9 @@ public class A2dpProfile implements LocalBluetoothProfile {
            case BluetoothCodecConfig.SOURCE_CODEC_TYPE_APTX_ADAPTIVE:
                index = 6;
                break;
+           case BluetoothCodecConfig.SOURCE_CODEC_TYPE_APTX_TWSP:
+               index = 7;
+               break;
            }
 
         if (index < 0) {
",3,0,A2dpProfile::getHighQualityAudioOptionLabel
131,b9f99a203d5474757510439d11e3db07ccc312e4,A2dpProfileTest.java,ModificationType.MODIFY,"@@ -129,7 +129,7 @@ public class A2dpProfileTest {
     private static String KNOWN_CODEC_LABEL = ""Use high quality audio: %1$s"";
     private static String UNKNOWN_CODEC_LABEL = ""Use high quality audio"";
     private static String[] CODEC_NAMES =
-            new String[]{""Default"", ""SBC"", ""AAC"", ""aptX"", ""aptX HD"", ""LDAC"", ""aptX Adaptive""};
+            new String[]{""Default"", ""SBC"", ""AAC"", ""aptX"", ""aptX HD"", ""LDAC"", ""aptX Adaptive"", ""aptX TWS+""};
 
     /**
      * Helper for setting up several tests of getHighQualityAudioOptionLabel
",1,1,
132,0798107a5790e5501478889d1d7188dcd1ae8116,AudioManager.java,ModificationType.MODIFY,"@@ -4280,6 +4280,38 @@ public class AudioManager {
         }
     }
 
+     /**
+     * Indicate A2DP source or sink active device change and eventually suppress
+     * the {@link AudioManager.ACTION_AUDIO_BECOMING_NOISY} intent.
+     * This operation is asynchronous but its execution will still be sequentially scheduled
+     * relative to calls to {@link #setBluetoothHearingAidDeviceConnectionState(BluetoothDevice,
+     * int, boolean, int)} and
+     * {@link #handleBluetoothA2dpDeviceConfigChange(BluetoothDevice)}.
+     * @param device Bluetooth device connected/disconnected
+     * @param state  new connection state (BluetoothProfile.STATE_xxx)
+     * @param profile profile for the A2DP device
+     * (either {@link android.bluetooth.BluetoothProfile.A2DP} or
+     * {@link android.bluetooth.BluetoothProfile.A2DP_SINK})
+     * @param a2dpVolume New volume for the connecting device. Does nothing if
+     * disconnecting. Pass value -1 in case you want this field to be ignored
+     * @param suppressNoisyIntent if true the
+     * {@link AudioManager.ACTION_AUDIO_BECOMING_NOISY} intent will not be sent.
+     * @return a delay in ms that the caller should wait before broadcasting
+     * BluetoothA2dp.ACTION_CONNECTION_STATE_CHANGED intent.
+     * {@hide}
+     */
+    public void handleBluetoothA2dpActiveDeviceChange(
+                BluetoothDevice device, int state, int profile,
+                boolean suppressNoisyIntent, int a2dpVolume) {
+         final IAudioService service = getService();
+         try {
+             service.handleBluetoothA2dpActiveDeviceChange(device,
+                   state, profile, suppressNoisyIntent, a2dpVolume);
+         } catch (RemoteException e) {
+             throw e.rethrowFromSystemServer();
+         }
+    }
+
     /** {@hide} */
     public IRingtonePlayer getRingtonePlayer() {
         try {
",32,0,AudioManager::handleBluetoothA2dpActiveDeviceChange
133,0798107a5790e5501478889d1d7188dcd1ae8116,AudioDeviceBroker.java,ModificationType.MODIFY,"@@ -280,6 +280,15 @@ import com.android.internal.annotations.GuardedBy;
                 device);
     }
 
+    /*package*/ void postBluetoothA2dpDeviceConfigChangeExt(
+            @NonNull BluetoothDevice device,
+            @AudioService.BtProfileConnectionState int state, int profile,
+            boolean suppressNoisyIntent, int a2dpVolume) {
+         final BtDeviceConnectionInfo info = new BtDeviceConnectionInfo(device, state, profile,
+                 suppressNoisyIntent, a2dpVolume);
+         sendLMsgNoDelay(MSG_L_A2DP_ACTIVE_DEVICE_CHANGE_EXT, SENDMSG_QUEUE, info);
+    }
+
     private static final class HearingAidDeviceConnectionInfo {
         final @NonNull BluetoothDevice mDevice;
         final @AudioService.BtProfileConnectionState int mState;
@@ -879,6 +888,22 @@ import com.android.internal.annotations.GuardedBy;
                                 info.mDevice, info.mState, info.mSupprNoisy, info.mMusicDevice);
                     }
                 } break;
+                case MSG_L_A2DP_ACTIVE_DEVICE_CHANGE_EXT: {
+                    final BtDeviceConnectionInfo info = (BtDeviceConnectionInfo) msg.obj;
+                    AudioService.sDeviceLogger.log((new AudioEventLogger.StringEvent(
+                    ""handleBluetoothA2dpActiveDeviceChangeExt ""
+                           + "" state="" + info.mState
+                           // only querying address as this is the only readily available
+                           // field on the device
+                           + "" addr="" + info.mDevice.getAddress()
+                           + "" prof="" + info.mProfile + "" supprNoisy="" + info.mSupprNoisy
+                           + "" vol="" + info.mVolume)).printLog(TAG));
+                    synchronized (mDeviceStateLock) {
+                        mDeviceInventory.handleBluetoothA2dpActiveDeviceChangeExt(
+                                info.mDevice, info.mState, info.mProfile,
+                                info.mSupprNoisy, info.mVolume);
+                    }
+                } break;
                 default:
                     Log.wtf(TAG, ""Invalid message "" + msg.what);
             }
@@ -928,8 +953,10 @@ import com.android.internal.annotations.GuardedBy;
     private static final int MSG_L_A2DP_DEVICE_CONNECTION_CHANGE_EXT_DISCONNECTION = 30;
     // process external command to (dis)connect a hearing aid device
     private static final int MSG_L_HEARING_AID_DEVICE_CONNECTION_CHANGE_EXT = 31;
+    // process external command to (dis)connect or change active A2DP device
+    private static final int MSG_L_A2DP_ACTIVE_DEVICE_CHANGE_EXT = 32;
     // a ScoClient died in BtHelper
-    private static final int MSG_L_SCOCLIENT_DIED = 32;
+    private static final int MSG_L_SCOCLIENT_DIED = 33;
 
 
     private static boolean isMessageHandledUnderWakelock(int msgId) {
@@ -946,6 +973,7 @@ import com.android.internal.annotations.GuardedBy;
             case MSG_L_A2DP_DEVICE_CONNECTION_CHANGE_EXT_CONNECTION:
             case MSG_L_A2DP_DEVICE_CONNECTION_CHANGE_EXT_DISCONNECTION:
             case MSG_L_HEARING_AID_DEVICE_CONNECTION_CHANGE_EXT:
+            case MSG_L_A2DP_ACTIVE_DEVICE_CHANGE_EXT:
                 return true;
             default:
                 return false;
",29,1,"AudioDeviceBroker::isMessageHandledUnderWakelock, AudioDeviceBroker::BrokerHandler::handleMessage, AudioDeviceBroker::postBluetoothA2dpDeviceConfigChangeExt"
134,0798107a5790e5501478889d1d7188dcd1ae8116,AudioDeviceInventory.java,ModificationType.MODIFY,"@@ -604,6 +604,49 @@ public class AudioDeviceInventory {
         }
     }
 
+    /*package*/ void handleBluetoothA2dpActiveDeviceChangeExt(
+            @NonNull BluetoothDevice device,
+            @AudioService.BtProfileConnectionState int state, int profile,
+            boolean suppressNoisyIntent, int a2dpVolume) {
+          if (state == BluetoothProfile.STATE_DISCONNECTED) {
+              mDeviceBroker.postBluetoothA2dpDeviceConnectionStateSuppressNoisyIntent(
+                             device, state, profile, suppressNoisyIntent, a2dpVolume);
+              return;
+          }
+          // state == BluetoothProfile.STATE_CONNECTED
+          synchronized (mConnectedDevices) {
+                 final String address = device.getAddress();
+                 final int a2dpCodec = mDeviceBroker.getA2dpCodec(device);
+                 final String deviceKey = DeviceInfo.makeDeviceListKey(
+                                AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP, address);
+                 DeviceInfo deviceInfo = mConnectedDevices.get(deviceKey);
+                 if (deviceInfo != null) {
+                     // Device config change for matching A2DP device
+                     mDeviceBroker.postBluetoothA2dpDeviceConfigChange(device);
+                     return;
+                 }
+                 for (int i = 0; i < mConnectedDevices.size(); i++) {
+                      deviceInfo = mConnectedDevices.valueAt(i);
+                      if (deviceInfo.mDeviceType != AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP) {
+                          continue;
+                      }
+                      // A2DP device exists, handle active device change
+                      final String existingDevicekey = mConnectedDevices.keyAt(i);
+                      mConnectedDevices.remove(existingDevicekey);
+                      mConnectedDevices.put(deviceKey, new DeviceInfo(
+                                 AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP, BtHelper.getName(device),
+                                 address, a2dpCodec));
+                      mDeviceBroker.postA2dpActiveDeviceChange(
+                                 new BtHelper.BluetoothA2dpDeviceInfo(
+                                     device, a2dpVolume, a2dpCodec));
+                      return;
+                 }
+          }
+          // New A2DP device connection
+          mDeviceBroker.postBluetoothA2dpDeviceConnectionStateSuppressNoisyIntent(
+                             device, state, profile, suppressNoisyIntent, a2dpVolume);
+    }
+
     /*package*/ int setWiredDeviceConnectionState(int type, @AudioService.ConnectionState int state,
                                                   String address, String name, String caller) {
         synchronized (mConnectedDevices) {
",43,0,AudioDeviceInventory::handleBluetoothA2dpActiveDeviceChangeExt
135,0798107a5790e5501478889d1d7188dcd1ae8116,AudioService.java,ModificationType.MODIFY,"@@ -4515,6 +4515,27 @@ public class AudioService extends IAudioService.Stub
         mDeviceBroker.postBluetoothA2dpDeviceConfigChange(device);
     }
 
+    /**
+     * @see AudioManager#handleBluetoothA2dpActiveDeviceChange(BluetoothDevice, int, int,
+     *                                                        boolean, int)
+     */
+    public void handleBluetoothA2dpActiveDeviceChange(
+            BluetoothDevice device, int state, int profile, boolean suppressNoisyIntent,
+            int a2dpVolume) {
+        if (device == null) {
+                throw new IllegalArgumentException(""Illegal null device"");
+        }
+        if (profile != BluetoothProfile.A2DP && profile != BluetoothProfile.A2DP_SINK) {
+            throw new IllegalArgumentException(""invalid profile "" + profile);
+        }
+        if (state != BluetoothProfile.STATE_CONNECTED
+                && state != BluetoothProfile.STATE_DISCONNECTED) {
+            throw new IllegalArgumentException(""Invalid state "" + state);
+        }
+        mDeviceBroker.postBluetoothA2dpDeviceConfigChangeExt(device, state, profile,
+                suppressNoisyIntent, a2dpVolume);
+    }
+
     private static final int DEVICE_MEDIA_UNMUTED_ON_PLUG =
             AudioSystem.DEVICE_OUT_WIRED_HEADSET | AudioSystem.DEVICE_OUT_WIRED_HEADPHONE |
             AudioSystem.DEVICE_OUT_LINE |
",21,0,AudioService::handleBluetoothA2dpActiveDeviceChange
136,493111a2e9281c2bde1bc62cfc309744b5850809,BluetoothDevice.java,ModificationType.MODIFY,"@@ -1,3 +1,38 @@
+/*
+ * Copyright (C) 2017, The Linux Foundation. All rights reserved.
+ * Not a Contribution.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted (subject to the limitations in the
+ * disclaimer below) provided that the following conditions are met:
+ *
+ * * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *
+ * * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *
+ * * Neither the name of The Linux Foundation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE
+ * GRANTED BY THIS LICENSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT
+ * HOLDERS AND CONTRIBUTORS ""AS IS"" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
+ * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
 /*
  * Copyright (C) 2009 The Android Open Source Project
  *
@@ -225,6 +260,17 @@ public final class BluetoothDevice implements Parcelable {
      */
     public static final int BATTERY_LEVEL_UNKNOWN = -1;
 
+    /**
+     * Broadcast Action: Indicates the remote devices are TWS plus earbuds pair.
+     * <p>Always contains the extra fields {@link #EXTRA_TWS_PLUS_DEVICE1},
+     * {@link #EXTRA_TWS_PLUS_DEVICE2}.
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH} to receive.
+     * @hide
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_TWS_PLUS_DEVICE_PAIR =
+            ""android.bluetooth.device.action.TWS_PLUS_DEVICE_PAIR"";
+
     /**
      * Used as a Parcelable {@link BluetoothDevice} extra field in every intent
      * broadcast by this class. It contains the {@link BluetoothDevice} that
@@ -277,6 +323,23 @@ public final class BluetoothDevice implements Parcelable {
      */
     public static final String EXTRA_PREVIOUS_BOND_STATE =
             ""android.bluetooth.device.extra.PREVIOUS_BOND_STATE"";
+
+    /**
+     * Used as a String extra field in {@link #ACTION_TWS+_DEVICE_PAIR}
+     * intents. It contains the first TWS+ earbud address of pair.
+     * @hide
+     */
+    public static final String EXTRA_TWS_PLUS_DEVICE1 =
+            ""android.bluetooth.device.extra.EXTRA_TWS_PLUS_DEVICE1"";
+
+    /**
+     * Used as a String extra field in {@link #ACTION_TWS+_DEVICE_PAIR}
+     * intents. It contains the second TWS+ earbud address of pair.
+     * @hide
+     */
+    public static final String EXTRA_TWS_PLUS_DEVICE2 =
+            ""android.bluetooth.device.extra.EXTRA_TWS_PLUS_DEVICE2"";
+
     /**
      * Indicates the remote device is not bonded (paired).
      * <p>There is no shared link key with the remote device, so communication
@@ -1515,6 +1578,41 @@ public final class BluetoothDevice implements Parcelable {
         return false;
     }
 
+    /**
+     * Returns whether if the device is TWS+ device.
+     *
+     * @return True if the devcie is TWS+ device.
+     * @hide
+     */
+    public boolean isTwsPlusDevice() {
+         if (sService == null) {
+             Log.e(TAG, ""BT not enabled. Cannot query remote device sdp records"");
+             return false;
+         }
+         try {
+             return sService.isTwsPlusDevice(this);
+         } catch (RemoteException e) {Log.e(TAG, """", e);}
+         return false;
+    }
+
+    /**
+     * Get the TWS+ peer address of the remote device.
+     *
+     * @return the TWS+ peer address of the remote device if available, otherwise
+     * null.
+     * @hide
+     */
+    public String getTwsPlusPeerAddress() {
+        if (sService == null) {
+            Log.e(TAG, ""BT not enabled. Cannot get Remote Device name"");
+            return null;
+        }
+        try {
+            return sService.getTwsPlusPeerAddress(this);
+        } catch (RemoteException e) {Log.e(TAG, """", e);}
+        return null;
+    }
+
     /**
      * Set the pin during pairing when the pairing method is {@link #PAIRING_VARIANT_PIN}
      * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}.
",98,0,"BluetoothDevice::isTwsPlusDevice, BluetoothDevice::getTwsPlusPeerAddress"
137,864e6dcb2e4e92a0bf22fe16543c1c41338c07d5,CachedBluetoothDevice.java,ModificationType.MODIFY,"@@ -26,6 +26,7 @@ import android.content.Context;
 import android.content.SharedPreferences;
 import android.os.ParcelUuid;
 import android.os.SystemClock;
+import android.os.SystemProperties;
 import android.text.TextUtils;
 import android.util.EventLog;
 import android.util.Log;
@@ -103,6 +104,22 @@ public class CachedBluetoothDevice implements Comparable<CachedBluetoothDevice>
         mHiSyncId = BluetoothHearingAid.HI_SYNC_ID_INVALID;
     }
 
+    /* Gets Device for seondary TWS device
+     * @param mDevice Primary TWS device  to get secondary
+     * @return Description of the device
+     */
+
+    private BluetoothDevice getTwsPeerDevice() {
+      BluetoothAdapter bluetoothAdapter;
+      BluetoothDevice peerDevice = null;
+      if (mDevice.isTwsPlusDevice()) {
+        bluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
+        String peerAddress = mDevice.getTwsPlusPeerAddress();
+        peerDevice = bluetoothAdapter.getRemoteDevice(peerAddress);
+      }
+      return peerDevice;
+    }
+
     /**
      * Describes the current device and profile for logging.
      *
@@ -320,6 +337,17 @@ public class CachedBluetoothDevice implements Comparable<CachedBluetoothDevice>
 
         if (state != BluetoothDevice.BOND_NONE) {
             final BluetoothDevice dev = mDevice;
+            if (mDevice.isTwsPlusDevice()) {
+               BluetoothDevice peerDevice = getTwsPeerDevice();
+               if (peerDevice != null) {
+                   final boolean peersuccessful = peerDevice.removeBond();
+                   if (peersuccessful) {
+                       if (Utils.D) {
+                           Log.d(TAG, ""Command sent successfully:REMOVE_BOND "" + peerDevice.getName());
+                       }
+                   }
+                }
+            }
             if (dev != null) {
                 final boolean successful = dev.removeBond();
                 if (successful) {
@@ -648,6 +676,11 @@ public class CachedBluetoothDevice implements Comparable<CachedBluetoothDevice>
         if (bondState == BluetoothDevice.BOND_BONDED) {
             if (mDevice.isBluetoothDock()) {
                 onBondingDockConnect();
+            } else if (SystemProperties.getBoolean(""persist.vendor.bt.connect.peer_earbud"", true)) {
+                Log.d(TAG, ""Initiating connection to"" + mDevice);
+                if (mDevice.isBondingInitiatedLocally() || mDevice.isTwsPlusDevice()) {
+                    connect(false);
+                }
             } else if (mDevice.isBondingInitiatedLocally()) {
                 connect(false);
             }
",33,0,"CachedBluetoothDevice::onBondingStateChanged, CachedBluetoothDevice::unpair, CachedBluetoothDevice::getTwsPeerDevice"
138,e0d7401448d7edacd9f26bdfc395a3f1cbfa8de7,CachedBluetoothDevice.java,ModificationType.MODIFY,"@@ -676,7 +676,7 @@ public class CachedBluetoothDevice implements Comparable<CachedBluetoothDevice>
         if (bondState == BluetoothDevice.BOND_BONDED) {
             if (mDevice.isBluetoothDock()) {
                 onBondingDockConnect();
-            } else if (SystemProperties.getBoolean(""persist.vendor.bt.connect.peer_earbud"", true)) {
+            } else if (SystemProperties.getBoolean(""persist.vendor.btstack.connect.peer_earbud"", true)) {
                 Log.d(TAG, ""Initiating connection to"" + mDevice);
                 if (mDevice.isBondingInitiatedLocally() || mDevice.isTwsPlusDevice()) {
                     connect(false);
",1,1,CachedBluetoothDevice::onBondingStateChanged
139,5df11006ff3c6d835acc74ae2b8fa59279cc9567,CachedBluetoothDevice.java,ModificationType.MODIFY,"@@ -676,7 +676,7 @@ public class CachedBluetoothDevice implements Comparable<CachedBluetoothDevice>
         if (bondState == BluetoothDevice.BOND_BONDED) {
             if (mDevice.isBluetoothDock()) {
                 onBondingDockConnect();
-            } else if (SystemProperties.getBoolean(""persist.vendor.btstack.connect.peer_earbud"", true)) {
+            } else if (SystemProperties.getBoolean(""persist.vendor.btstack.connect.peer_earbud"", false)) {
                 Log.d(TAG, ""Initiating connection to"" + mDevice);
                 if (mDevice.isBondingInitiatedLocally() || mDevice.isTwsPlusDevice()) {
                     connect(false);
",1,1,CachedBluetoothDevice::onBondingStateChanged
140,76947fb73e414fa9c108f2572c3a6ec64fc5e032,CachedBluetoothDevice.java,ModificationType.MODIFY,"@@ -26,7 +26,6 @@ import android.content.Context;
 import android.content.SharedPreferences;
 import android.os.ParcelUuid;
 import android.os.SystemClock;
-import android.os.SystemProperties;
 import android.text.TextUtils;
 import android.util.EventLog;
 import android.util.Log;
@@ -56,6 +55,7 @@ public class CachedBluetoothDevice implements Comparable<CachedBluetoothDevice>
     // Some Hearing Aids (especially the 2nd device) needs more time to do service discovery
     private static final long MAX_HEARING_AIDS_DELAY_FOR_AUTO_CONNECT = 15000;
     private static final long MAX_HOGP_DELAY_FOR_AUTO_CONNECT = 30000;
+    private static final boolean mIsTwsConnectEnabled = false;
 
     private final Context mContext;
     private final BluetoothAdapter mLocalAdapter;
@@ -676,7 +676,7 @@ public class CachedBluetoothDevice implements Comparable<CachedBluetoothDevice>
         if (bondState == BluetoothDevice.BOND_BONDED) {
             if (mDevice.isBluetoothDock()) {
                 onBondingDockConnect();
-            } else if (SystemProperties.getBoolean(""persist.vendor.btstack.connect.peer_earbud"", false)) {
+            } else if (mIsTwsConnectEnabled) {
                 Log.d(TAG, ""Initiating connection to"" + mDevice);
                 if (mDevice.isBondingInitiatedLocally() || mDevice.isTwsPlusDevice()) {
                     connect(false);
",2,2,CachedBluetoothDevice::onBondingStateChanged
141,86c20db3b240bfc8ebe1a68e794f48b0729982e5,BluetoothDevice.java,ModificationType.MODIFY,"@@ -1321,6 +1321,22 @@ public final class BluetoothDevice implements Parcelable {
         return false;
     }
 
+    /** @hide */
+    @UnsupportedAppUsage
+    public void setBondingInitiatedLocally(boolean localInitiated) {
+        final IBluetooth service = sService;
+        if (service == null) {
+            Log.w(TAG, ""BT not enabled, setBondingInitiatedLocally failed"");
+            return;
+        }
+        try {
+            service.setBondingInitiatedLocally(this, localInitiated);
+        } catch (RemoteException e) {
+            Log.e(TAG, """", e);
+        }
+        return;
+    }
+
     /**
      * Set the Out Of Band data for a remote device to be used later
      * in the pairing mechanism. Users can obtain this data through other
",16,0,BluetoothDevice::setBondingInitiatedLocally
142,86c20db3b240bfc8ebe1a68e794f48b0729982e5,CachedBluetoothDevice.java,ModificationType.MODIFY,"@@ -674,14 +674,19 @@ public class CachedBluetoothDevice implements Comparable<CachedBluetoothDevice>
         refresh();
 
         if (bondState == BluetoothDevice.BOND_BONDED) {
+            boolean mIsBondingInitiatedLocally = mDevice.isBondingInitiatedLocally();
+            Log.w(TAG, ""mIsBondingInitiatedLocally"" + mIsBondingInitiatedLocally);
+            if (mIsBondingInitiatedLocally) {
+                mDevice.setBondingInitiatedLocally(false);
+            }
             if (mDevice.isBluetoothDock()) {
                 onBondingDockConnect();
             } else if (mIsTwsConnectEnabled) {
                 Log.d(TAG, ""Initiating connection to"" + mDevice);
-                if (mDevice.isBondingInitiatedLocally() || mDevice.isTwsPlusDevice()) {
+                if (mIsBondingInitiatedLocally || mDevice.isTwsPlusDevice()) {
                     connect(false);
                 }
-            } else if (mDevice.isBondingInitiatedLocally()) {
+            } else if (mIsBondingInitiatedLocally) {
                 connect(false);
             }
         }
",7,2,CachedBluetoothDevice::onBondingStateChanged
143,a602b8201279b0bfb645cb2cc59bf354967d2676,TelecomManager.java,ModificationType.MODIFY,"@@ -180,6 +180,17 @@ public class TelecomManager {
     public static final String ACTION_DEFAULT_DIALER_CHANGED =
             ""android.telecom.action.DEFAULT_DIALER_CHANGED"";
 
+    /**
+     *@hide Broadcast intent action indicating the call type(CS call or Non-CS call).
+     * The string extra {@link #EXTRA_CALL_TYPE_CS} will contain the
+     * boolean value true if call is CS call else false.
+     *
+     * @see #EXTRA_CALL_TYPE_CS
+     */
+    public static final String ACTION_CALL_TYPE =
+            ""codeaurora.telecom.action.CALL_TYPE"";
+
+
     /**
      * Extra value used to provide the package name for {@link #ACTION_CHANGE_DEFAULT_DIALER}.
      */
@@ -377,6 +388,12 @@ public class TelecomManager {
     public static final String EXTRA_CALL_NETWORK_TYPE =
             ""android.telecom.extra.CALL_NETWORK_TYPE"";
 
+    /**
+     *@hide  Extra value used to provide the call type for {@link #ACTION_CALL_TYPE}.
+     */
+    public static final String EXTRA_CALL_TYPE_CS =
+            ""codeaurora.telecom.extra.CALL_TYPE_CS"";
+
     /**
      * An optional {@link android.content.Intent#ACTION_CALL} intent extra denoting the
      * package name of the app specifying an alternative gateway for the call.
",17,0,
144,9d32a64594452aacf864f8ab013c4090a2577f9c,BluetoothHeadset.java,ModificationType.MODIFY,"@@ -281,6 +281,41 @@ public final class BluetoothHeadset implements BluetoothProfile {
      * {@link #ACTION_AUDIO_STATE_CHANGED} intent.
      */
 
+    /**
+     * Intent used to broadcast the Battery status of TWS+ devices
+     *
+     * <p>This intent will have 2 extras:
+     * <ul>
+     * <li> {@link #EXTRA_HF_TWSP_BATTERY_STATE} - Current Battey state of TWS+
+     *      device. 0 for Discharging, 1 for Charging
+     * <\li>
+     * <li> {@link #EXTRA_HF_TWSP_BATTERY_LEVEL} - Current Battey charging level
+     *      in percentage of TWS+ device.
+     * <\li>
+     *
+     * @hide
+     */
+    public static final String ACTION_HF_TWSP_BATTERY_STATE_CHANGED =
+            ""android.bluetooth.headset.action.HF_TWSP_BATTERY_STATE_CHANGED"";
+
+    /**
+     * A int extra field in {@link #EXTRA_HF_TWSP_BATTERY_STATE}
+     * intents that contains the battery state of TWS+ device
+     *
+     * @hide
+     */
+    public static final String EXTRA_HF_TWSP_BATTERY_STATE =
+            ""android.bluetooth.headset.extra.HF_TWSP_BATTERY_STATE"";
+
+    /**
+     * A int extra field in {@link #EXTRA_HF_TWSP_BATTERY_LEVEL}
+     * intents that contains the value of battery level in percentage for TWS+ device
+     * @hide
+     */
+    public static final String EXTRA_HF_TWSP_BATTERY_LEVEL =
+            ""android.bluetooth.headset.extra.HF_TWSP_BATTERY_LEVEL"";
+
+
     /**
      * Intent used to broadcast the headset's indicator status
      *
",35,0,
145,9d32a64594452aacf864f8ab013c4090a2577f9c,BluetoothEventManager.java,ModificationType.MODIFY,"@@ -108,6 +108,8 @@ public class BluetoothEventManager {
         addHandler(BluetoothDevice.ACTION_CLASS_CHANGED, new ClassChangedHandler());
         addHandler(BluetoothDevice.ACTION_UUID, new UuidChangedHandler());
         addHandler(BluetoothDevice.ACTION_BATTERY_LEVEL_CHANGED, new BatteryLevelChangedHandler());
+        addHandler(BluetoothHeadset.ACTION_HF_TWSP_BATTERY_STATE_CHANGED ,
+                  new TwspBatteryLevelChangedHandler());
 
         // Active device broadcasts
         addHandler(BluetoothA2dp.ACTION_ACTIVE_DEVICE_CHANGED, new ActiveDeviceChangedHandler());
@@ -420,6 +422,24 @@ public class BluetoothEventManager {
         }
     }
 
+    private class TwspBatteryLevelChangedHandler implements Handler {
+        public void onReceive(Context context, Intent intent,
+                BluetoothDevice device) {
+            CachedBluetoothDevice cachedDevice = mDeviceManager.findDevice(device);
+            if (cachedDevice != null) {
+                cachedDevice.mTwspBatteryState =
+                          intent.getIntExtra(
+                              BluetoothHeadset.EXTRA_HF_TWSP_BATTERY_STATE, -1);
+                cachedDevice.mTwspBatteryLevel =
+                          intent.getIntExtra(
+                              BluetoothHeadset.EXTRA_HF_TWSP_BATTERY_LEVEL, -1);
+                Log.i(TAG, cachedDevice + "": mTwspBatteryState: "" + cachedDevice.mTwspBatteryState
+                    + ""mTwspBatteryLevel: "" + cachedDevice.mTwspBatteryLevel);
+                cachedDevice.refresh();
+            }
+        }
+    }
+
     private class ActiveDeviceChangedHandler implements Handler {
         @Override
         public void onReceive(Context context, Intent intent, BluetoothDevice device) {
",20,0,"BluetoothEventManager::BluetoothEventManager, BluetoothEventManager::TwspBatteryLevelChangedHandler::onReceive"
146,9d32a64594452aacf864f8ab013c4090a2577f9c,CachedBluetoothDevice.java,ModificationType.MODIFY,"@@ -79,6 +79,8 @@ public class CachedBluetoothDevice implements Comparable<CachedBluetoothDevice>
 
     private final Collection<Callback> mCallbacks = new CopyOnWriteArrayList<>();
 
+    public int mTwspBatteryState;
+    public int mTwspBatteryLevel;
     /**
      * Last time a bt profile auto-connect was attempted.
      * If an ACTION_UUID intent comes in within
@@ -102,6 +104,8 @@ public class CachedBluetoothDevice implements Comparable<CachedBluetoothDevice>
         mDevice = device;
         fillData();
         mHiSyncId = BluetoothHearingAid.HI_SYNC_ID_INVALID;
+        mTwspBatteryState = -1;
+        mTwspBatteryLevel = -1;
     }
 
     /* Gets Device for seondary TWS device
@@ -173,6 +177,10 @@ public class CachedBluetoothDevice implements Comparable<CachedBluetoothDevice>
                 mProfiles.remove(profile);
                 mRemovedProfiles.add(profile);
                 mLocalNapRoleConnected = false;
+            } else if (profile instanceof HeadsetProfile
+                    && newProfileState == BluetoothProfile.STATE_DISCONNECTED) {
+                mTwspBatteryState = -1;
+                mTwspBatteryLevel = -1;
             }
         }
 
@@ -922,11 +930,28 @@ public class CachedBluetoothDevice implements Comparable<CachedBluetoothDevice>
         // BluetoothDevice.BATTERY_LEVEL_UNKNOWN, any other value should be a framework bug.
         // Thus assume here that if value is not BluetoothDevice.BATTERY_LEVEL_UNKNOWN, it must
         // be valid
-        final int batteryLevel = getBatteryLevel();
-        if (batteryLevel != BluetoothDevice.BATTERY_LEVEL_UNKNOWN) {
-            // TODO: name com.android.settingslib.bluetooth.Utils something different
-            batteryLevelPercentageString =
+
+        if (mDevice.isTwsPlusDevice() && mTwspBatteryState != -1 &&
+           mTwspBatteryLevel != -1) {
+            String s = ""TWSP: "";
+            String chargingState;
+            if (mTwspBatteryState == 1) {
+                chargingState = ""Charging, "";
+            } else {
+                chargingState = ""Discharging, "";
+            }
+            s = s.concat (chargingState);
+            s = s.concat(
+                 com.android.settingslib.Utils.formatPercentage(mTwspBatteryLevel));
+            batteryLevelPercentageString = s;
+            Log.i(TAG, ""UI string"" + batteryLevelPercentageString);
+        } else {
+            final int batteryLevel = getBatteryLevel();
+            if (batteryLevel != BluetoothDevice.BATTERY_LEVEL_UNKNOWN) {
+                // TODO: name com.android.settingslib.bluetooth.Utils something different
+                batteryLevelPercentageString =
                     com.android.settingslib.Utils.formatPercentage(batteryLevel);
+            }
         }
 
         int stringRes = R.string.bluetooth_pairing;
",29,4,"CachedBluetoothDevice::onProfileStateChanged, CachedBluetoothDevice::CachedBluetoothDevice, CachedBluetoothDevice::getConnectionSummary"
147,9d32a64594452aacf864f8ab013c4090a2577f9c,CachedBluetoothDeviceManager.java,ModificationType.MODIFY,"@@ -222,6 +222,9 @@ public class CachedBluetoothDeviceManager {
                     cachedDevice.setJustDiscovered(false);
                     mCachedDevices.remove(i);
                 }
+                //Clear if there any Tws battery info on BT turning OFF
+                cachedDevice.mTwspBatteryState = -1;
+                cachedDevice.mTwspBatteryLevel = -1;
             }
         }
     }
",3,0,CachedBluetoothDeviceManager::onBluetoothStateChanged
148,dd1eed0051ecfbfec46ac309585952e73996a3f7,AdvertiseData.java,ModificationType.MODIFY,"@@ -47,17 +47,20 @@ public final class AdvertiseData implements Parcelable {
     private final Map<ParcelUuid, byte[]> mServiceData;
     private final boolean mIncludeTxPowerLevel;
     private final boolean mIncludeDeviceName;
+    private final byte[] mTransportDiscoveryData;
 
     private AdvertiseData(List<ParcelUuid> serviceUuids,
             SparseArray<byte[]> manufacturerData,
             Map<ParcelUuid, byte[]> serviceData,
             boolean includeTxPowerLevel,
-            boolean includeDeviceName) {
+            boolean includeDeviceName,
+            byte[] transportDiscoveryData) {
         mServiceUuids = serviceUuids;
         mManufacturerSpecificData = manufacturerData;
         mServiceData = serviceData;
         mIncludeTxPowerLevel = includeTxPowerLevel;
         mIncludeDeviceName = includeDeviceName;
+        mTransportDiscoveryData = transportDiscoveryData;
     }
 
     /**
@@ -97,13 +100,21 @@ public final class AdvertiseData implements Parcelable {
         return mIncludeDeviceName;
     }
 
+    /**
+     * Returns an array of Transport Discovery data.
+     * @hide
+     */
+    public byte[] getTransportDiscoveryData() {
+        return mTransportDiscoveryData;
+    }
+
     /**
      * @hide
      */
     @Override
     public int hashCode() {
         return Objects.hash(mServiceUuids, mManufacturerSpecificData, mServiceData,
-                mIncludeDeviceName, mIncludeTxPowerLevel);
+                mIncludeDeviceName, mIncludeTxPowerLevel, mTransportDiscoveryData);
     }
 
     /**
@@ -123,7 +134,8 @@ public final class AdvertiseData implements Parcelable {
                     other.mManufacturerSpecificData)
                 && BluetoothLeUtils.equals(mServiceData, other.mServiceData)
                 && mIncludeDeviceName == other.mIncludeDeviceName
-                && mIncludeTxPowerLevel == other.mIncludeTxPowerLevel;
+                && mIncludeTxPowerLevel == other.mIncludeTxPowerLevel
+                && BluetoothLeUtils.equals(mTransportDiscoveryData, other.mTransportDiscoveryData);
     }
 
     @Override
@@ -132,7 +144,8 @@ public final class AdvertiseData implements Parcelable {
                 + BluetoothLeUtils.toString(mManufacturerSpecificData) + "", mServiceData=""
                 + BluetoothLeUtils.toString(mServiceData)
                 + "", mIncludeTxPowerLevel="" + mIncludeTxPowerLevel + "", mIncludeDeviceName=""
-                + mIncludeDeviceName + ""]"";
+                + mIncludeDeviceName + "", mTransportDiscoveryData=""
+                + BluetoothLeUtils.toString(mTransportDiscoveryData)+ ""]"";
     }
 
     @Override
@@ -157,6 +170,10 @@ public final class AdvertiseData implements Parcelable {
         }
         dest.writeByte((byte) (getIncludeTxPowerLevel() ? 1 : 0));
         dest.writeByte((byte) (getIncludeDeviceName() ? 1 : 0));
+        if(mTransportDiscoveryData != null) {
+            dest.writeInt(mTransportDiscoveryData.length);
+            dest.writeByteArray(mTransportDiscoveryData);
+        }
     }
 
     public static final @android.annotation.NonNull Parcelable.Creator<AdvertiseData> CREATOR =
@@ -188,6 +205,11 @@ public final class AdvertiseData implements Parcelable {
                     }
                     builder.setIncludeTxPowerLevel(in.readByte() == 1);
                     builder.setIncludeDeviceName(in.readByte() == 1);
+                    int transportDiscoveryDataSize = in.readInt();
+                    if (transportDiscoveryDataSize > 0) {
+                        byte[] transportDiscoveryData = in.createByteArray();
+                        builder.addTransportDiscoveryData(transportDiscoveryData);
+                    }
                     return builder.build();
                 }
             };
@@ -202,6 +224,7 @@ public final class AdvertiseData implements Parcelable {
         private Map<ParcelUuid, byte[]> mServiceData = new ArrayMap<ParcelUuid, byte[]>();
         private boolean mIncludeTxPowerLevel;
         private boolean mIncludeDeviceName;
+        private byte[] mTransportDiscoveryData;
 
         /**
          * Add a service UUID to advertise data.
@@ -275,12 +298,24 @@ public final class AdvertiseData implements Parcelable {
             return this;
         }
 
+        /**
+         * Add Transport Discovery data
+         * @hide
+         */
+        public Builder addTransportDiscoveryData(byte[] transportDiscoveryData) {
+            if ((transportDiscoveryData == null) || (transportDiscoveryData.length == 0)) {
+                throw new IllegalArgumentException(""transportDiscoveryData is null"");
+            }
+            mTransportDiscoveryData = transportDiscoveryData;
+            return this;
+        }
+
         /**
          * Build the {@link AdvertiseData}.
          */
         public AdvertiseData build() {
             return new AdvertiseData(mServiceUuids, mManufacturerSpecificData, mServiceData,
-                    mIncludeTxPowerLevel, mIncludeDeviceName);
+                    mIncludeTxPowerLevel, mIncludeDeviceName, mTransportDiscoveryData);
         }
     }
 }
",40,5,"AdvertiseData::AdvertiseData, AdvertiseData::equals, AdvertiseData::Creator<AdvertiseData>, AdvertiseData::getTransportDiscoveryData, AdvertiseData::writeToParcel, AdvertiseData::AdvertiseData, AdvertiseData::toString, AdvertiseData::hashCode, AdvertiseData::Builder::addTransportDiscoveryData, AdvertiseData::Builder::build"
149,dd1eed0051ecfbfec46ac309585952e73996a3f7,BluetoothLeUtils.java,ModificationType.MODIFY,"@@ -76,6 +76,28 @@ public class BluetoothLeUtils {
         return buffer.toString();
     }
 
+    /**
+     * Returns a string composed from a byte array.
+     */
+    static <T> String toString(byte[] data) {
+        if (data == null) {
+            return ""null"";
+        }
+        if (data.length == 0) {
+            return ""{}"";
+        }
+        StringBuilder buffer = new StringBuilder();
+        buffer.append('{');
+        for(int i=0; i < data.length; i++) {
+            buffer.append(data[i]);
+            if ((i+1) < data.length) {
+                buffer.append("", "");
+            }
+        }
+        buffer.append('}');
+        return buffer.toString();
+    }
+
     /**
      * Check whether two {@link SparseArray} equal.
      */
@@ -125,6 +147,25 @@ public class BluetoothLeUtils {
         return true;
     }
 
+    /**
+     * Check whether two byte arrays are equal.
+     */
+    static <T> boolean equals(byte[] data, byte[] otherData) {
+        if (data == otherData) {
+            return true;
+        }
+        if (data == null || otherData == null) {
+            return false;
+        }
+        if (data.length != otherData.length) {
+            return false;
+        }
+        if (!Objects.deepEquals(data, otherData)) {
+            return false;
+        }
+        return true;
+    }
+
     /**
      * Ensure Bluetooth is turned on.
      *
",41,0,"BluetoothLeUtils::toString, BluetoothLeUtils::equals"
150,59855ff1db2d059f60729f4bd5a85e2502e2a3d9,BluetoothLeScanner.java,ModificationType.MODIFY,"@@ -33,6 +33,7 @@ import android.os.RemoteException;
 import android.os.WorkSource;
 import android.util.Log;
 
+import java.util.Arrays;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
@@ -228,6 +229,13 @@ public final class BluetoothLeScanner {
             if (gatt == null) {
                 return postCallbackErrorOrReturn(callback, ScanCallback.SCAN_FAILED_INTERNAL_ERROR);
             }
+
+            if ((settings.getCallbackType() == ScanSettings.CALLBACK_TYPE_SENSOR_ROUTING)
+                    && (filters == null || filters.isEmpty())) {
+                ScanFilter filter = (new ScanFilter.Builder()).build();
+                filters = Arrays.asList(filter);
+            }
+
             if (!isSettingsConfigAllowedForScan(settings)) {
                 return postCallbackErrorOrReturn(callback,
                         ScanCallback.SCAN_FAILED_FEATURE_UNSUPPORTED);
@@ -240,6 +248,10 @@ public final class BluetoothLeScanner {
                 return postCallbackErrorOrReturn(callback,
                         ScanCallback.SCAN_FAILED_FEATURE_UNSUPPORTED);
             }
+            if (!isRoutingAllowedForScan(settings)) {
+                return postCallbackErrorOrReturn(callback,
+                        ScanCallback.SCAN_FAILED_FEATURE_UNSUPPORTED);
+            }
             if (callback != null) {
                 BleScanCallbackWrapper wrapper = new BleScanCallbackWrapper(gatt, filters,
                         settings, workSource, callback, resultStorages);
@@ -599,4 +611,14 @@ public final class BluetoothLeScanner {
         }
         return true;
     }
+
+    private boolean isRoutingAllowedForScan(ScanSettings settings) {
+        final int callbackType = settings.getCallbackType();
+
+        if (callbackType == ScanSettings.CALLBACK_TYPE_SENSOR_ROUTING
+                && settings.getScanMode() == ScanSettings.SCAN_MODE_OPPORTUNISTIC) {
+            return false;
+        }
+        return true;
+    }
 }
",22,0,"BluetoothLeScanner::isRoutingAllowedForScan, BluetoothLeScanner::startScan"
151,59855ff1db2d059f60729f4bd5a85e2502e2a3d9,ScanSettings.java,ModificationType.MODIFY,"@@ -69,6 +69,12 @@ public final class ScanSettings implements Parcelable {
      */
     public static final int CALLBACK_TYPE_MATCH_LOST = 4;
 
+    /**
+     * Provide results to sensor router instead of the apps processor
+     * @hide
+     */
+    public static final int CALLBACK_TYPE_SENSOR_ROUTING = 8;
+
 
     /**
      * Determines how many advertisements to match per filter, as this is scarce hw resource
@@ -302,7 +308,8 @@ public final class ScanSettings implements Parcelable {
         private boolean isValidCallbackType(int callbackType) {
             if (callbackType == CALLBACK_TYPE_ALL_MATCHES
                     || callbackType == CALLBACK_TYPE_FIRST_MATCH
-                    || callbackType == CALLBACK_TYPE_MATCH_LOST) {
+                    || callbackType == CALLBACK_TYPE_MATCH_LOST
+                    || callbackType == CALLBACK_TYPE_SENSOR_ROUTING) {
                 return true;
             }
             return callbackType == (CALLBACK_TYPE_FIRST_MATCH | CALLBACK_TYPE_MATCH_LOST);
",8,1,ScanSettings::Builder::isValidCallbackType
152,3c915e4299c89d1aafdbe9755f5b2c4eb0b9ac14,ScanFilter.java,ModificationType.MODIFY,"@@ -47,6 +47,12 @@ import java.util.UUID;
  */
 public final class ScanFilter implements Parcelable {
 
+    /**
+    * Provide TDS data scan results for WiFi Alliance Org id
+    * @hide
+    */
+    public static final int WIFI_ALLIANCE_ORG_ID = 2;
+
     @Nullable
     private final String mDeviceName;
 
@@ -76,6 +82,11 @@ public final class ScanFilter implements Parcelable {
     @Nullable
     private final byte[] mManufacturerDataMask;
 
+    private final int mOrgId;
+    private final int mTDSFlags;
+    private final int mTDSFlagsMask;
+    private final byte[] mWifiNANHash;
+
     /** @hide */
     public static final ScanFilter EMPTY = new ScanFilter.Builder().build();
 
@@ -84,7 +95,8 @@ public final class ScanFilter implements Parcelable {
             ParcelUuid uuidMask, ParcelUuid solicitationUuid,
             ParcelUuid solicitationUuidMask, ParcelUuid serviceDataUuid,
             byte[] serviceData, byte[] serviceDataMask,
-            int manufacturerId, byte[] manufacturerData, byte[] manufacturerDataMask) {
+            int manufacturerId, byte[] manufacturerData, byte[] manufacturerDataMask,
+            int orgId, int TDSFlags, int TDSFlagsMask, byte[] wifiNANHash) {
         mDeviceName = name;
         mServiceUuid = uuid;
         mServiceUuidMask = uuidMask;
@@ -97,6 +109,10 @@ public final class ScanFilter implements Parcelable {
         mManufacturerId = manufacturerId;
         mManufacturerData = manufacturerData;
         mManufacturerDataMask = manufacturerDataMask;
+        mOrgId = orgId;
+        mTDSFlags = TDSFlags;
+        mTDSFlagsMask = TDSFlagsMask;
+        mWifiNANHash = wifiNANHash;
     }
 
     @Override
@@ -157,6 +173,14 @@ public final class ScanFilter implements Parcelable {
                 dest.writeByteArray(mManufacturerDataMask);
             }
         }
+        dest.writeInt(mOrgId);
+        dest.writeInt(mTDSFlags);
+        dest.writeInt(mTDSFlagsMask);
+        dest.writeInt(mWifiNANHash == null ? 0 : 1);
+        if (mWifiNANHash != null) {
+            dest.writeInt(mWifiNANHash.length);
+            dest.writeByteArray(mWifiNANHash);
+        }
     }
 
     /**
@@ -234,6 +258,20 @@ public final class ScanFilter implements Parcelable {
                 }
             }
 
+            int orgId = in.readInt();
+            int TDSFlags = in.readInt();
+            int TDSFlagsMask = in.readInt();
+            if (in.readInt() == 1) {
+                int wifiNANHashLength = in.readInt();
+                byte[] wifiNanHash = new byte[wifiNANHashLength];
+                in.readByteArray(wifiNanHash);
+                builder.setTransportDiscoveryData(orgId, TDSFlags, TDSFlagsMask,
+                        wifiNanHash);
+            }
+            else {
+                builder.setTransportDiscoveryData(orgId, TDSFlags, TDSFlagsMask, null);
+            }
+
             return builder.build();
         }
     };
@@ -312,6 +350,37 @@ public final class ScanFilter implements Parcelable {
         return mManufacturerDataMask;
     }
 
+    /**
+     * @hide
+     * Returns the organization id. -1 if the organization id is not set.
+     */
+    public int getOrgId() {
+        return mOrgId;
+    }
+
+    /**
+     * @hide
+     * Returns the TDS flags. -1 if TDS flags is not set.
+     */
+    public int getTDSFlags() {
+        return mTDSFlags;
+    }
+
+    /**
+     * @hide
+     * Returns the TDS flags mask. -1 if TDS flags mask is not set.
+     */
+    public int getTDSFlagsMask() {
+        return mTDSFlagsMask;
+    }
+
+    /**
+     * @hide
+     */
+    public byte[] getWifiNANHash() {
+        return mWifiNANHash;
+    }
+
     /**
      * Check if the scan filter matches a {@code scanResult}. A scan result is considered as a match
      * if it matches all the field filters.
@@ -369,6 +438,18 @@ public final class ScanFilter implements Parcelable {
                 return false;
             }
         }
+
+        //Transport Discovery data match
+        if(mOrgId >= 0) {
+            byte[] tdsData = scanRecord.getTDSData();
+            if ((tdsData != null) && (tdsData.length > 0)) {
+                if ((mOrgId != tdsData[0]) ||
+                    ((mTDSFlags & mTDSFlagsMask) != (tdsData[1] & mTDSFlagsMask))) {
+                    return false;
+                }
+            }
+        }
+
         // All filters match.
         return true;
     }
@@ -463,7 +544,10 @@ public final class ScanFilter implements Parcelable {
                 + Arrays.toString(mServiceData) + "", mServiceDataMask=""
                 + Arrays.toString(mServiceDataMask) + "", mManufacturerId="" + mManufacturerId
                 + "", mManufacturerData="" + Arrays.toString(mManufacturerData)
-                + "", mManufacturerDataMask="" + Arrays.toString(mManufacturerDataMask) + ""]"";
+                + "", mManufacturerDataMask="" + Arrays.toString(mManufacturerDataMask)
+                + "", mOrganizationId="" + mOrgId + "", mTDSFlags="" + mTDSFlags
+                + "", mTDSFlagsMask="" + mTDSFlagsMask
+                + "", mWifiNANHash="" + Arrays.toString(mWifiNANHash) +""]"";
     }
 
     @Override
@@ -475,7 +559,8 @@ public final class ScanFilter implements Parcelable {
                 Arrays.hashCode(mServiceData),
                 Arrays.hashCode(mServiceDataMask),
                 mServiceUuid, mServiceUuidMask,
-                mServiceSolicitationUuid, mServiceSolicitationUuidMask);
+                mServiceSolicitationUuid, mServiceSolicitationUuidMask,
+                mOrgId, mTDSFlags, mTDSFlagsMask, Arrays.hashCode(mWifiNANHash));
     }
 
     @Override
@@ -499,7 +584,11 @@ public final class ScanFilter implements Parcelable {
                 && Objects.equals(mServiceUuidMask, other.mServiceUuidMask)
                 && Objects.equals(mServiceSolicitationUuid, other.mServiceSolicitationUuid)
                 && Objects.equals(mServiceSolicitationUuidMask,
-                        other.mServiceSolicitationUuidMask);
+                        other.mServiceSolicitationUuidMask)
+                && mOrgId == other.mOrgId
+                && mTDSFlags == other.mTDSFlags
+                && mTDSFlagsMask == other.mTDSFlagsMask
+                && Objects.deepEquals(mWifiNANHash, other.mWifiNANHash);
     }
 
     /**
@@ -533,6 +622,11 @@ public final class ScanFilter implements Parcelable {
         private byte[] mManufacturerData;
         private byte[] mManufacturerDataMask;
 
+        private int mOrgId = -1;
+        private int mTDSFlags = -1;
+        private int mTDSFlagsMask = -1;
+        private byte[] mWifiNANHash;
+
         /**
          * Set filter on device name.
          */
@@ -717,6 +811,27 @@ public final class ScanFilter implements Parcelable {
             return this;
         }
 
+
+        /**
+         * @hide
+         * Set filter on transport discovery data.
+         * @throws IllegalArgumentException If the {@code orgId} is invalid or {@code
+         * wifiNANhash} is not null while {@code orgId} is non-Wifi.
+         */
+        public Builder setTransportDiscoveryData(int orgId, int TDSFlags, int TDSFlagsMask,
+                byte[] wifiNANHash) {
+            if (orgId < 0) {
+                throw new IllegalArgumentException(""invalid organization id"");
+            }
+            if ((orgId != WIFI_ALLIANCE_ORG_ID) && (wifiNANHash != null)) {
+                throw new IllegalArgumentException(""Wifi NAN Hash is not null for non-Wifi Org Id"");
+            }
+            mOrgId = orgId;
+            mTDSFlags = TDSFlags;
+            mTDSFlagsMask = TDSFlagsMask;
+            mWifiNANHash = wifiNANHash;
+            return this;
+        }
         /**
          * Build {@link ScanFilter}.
          *
@@ -727,7 +842,8 @@ public final class ScanFilter implements Parcelable {
                     mServiceUuid, mUuidMask, mServiceSolicitationUuid,
                     mServiceSolicitationUuidMask,
                     mServiceDataUuid, mServiceData, mServiceDataMask,
-                    mManufacturerId, mManufacturerData, mManufacturerDataMask);
+                    mManufacturerId, mManufacturerData, mManufacturerDataMask,
+                    mOrgId, mTDSFlags, mTDSFlagsMask, mWifiNANHash);
         }
     }
 }
",121,5,"ScanFilter::getTDSFlags, ScanFilter::toString, ScanFilter::Builder::setTransportDiscoveryData, ScanFilter::Builder::build, ScanFilter::getWifiNANHash, ScanFilter::hashCode, ScanFilter::ScanFilter, ScanFilter::getTDSFlagsMask, ScanFilter::matches, ScanFilter::getOrgId, ScanFilter::equals, ScanFilter::ScanFilter, ScanFilter::Creator<ScanFilter>, ScanFilter::writeToParcel"
153,3c915e4299c89d1aafdbe9755f5b2c4eb0b9ac14,ScanRecord.java,ModificationType.MODIFY,"@@ -56,6 +56,7 @@ public final class ScanRecord {
     private static final int DATA_TYPE_SERVICE_SOLICITATION_UUIDS_32_BIT = 0x1F;
     private static final int DATA_TYPE_SERVICE_SOLICITATION_UUIDS_128_BIT = 0x15;
     private static final int DATA_TYPE_MANUFACTURER_SPECIFIC_DATA = 0xFF;
+    private static final int DATA_TYPE_TRANSPORT_DISCOVERY_DATA = 0x26;
 
     // Flags of the advertising data.
     private final int mAdvertiseFlags;
@@ -78,6 +79,9 @@ public final class ScanRecord {
     // Raw bytes of scan record.
     private final byte[] mBytes;
 
+    // Transport Discovery data.
+    private final byte[] mTDSData;
+
     /**
      * Returns the advertising flags indicating the discoverable mode and capability of the device.
      * Returns -1 if the flag field is not set.
@@ -161,6 +165,14 @@ public final class ScanRecord {
         return mDeviceName;
     }
 
+    /**
+     * @hide
+     * Returns Transport Discovery data
+     */
+    public byte[] getTDSData() {
+        return mTDSData;
+    }
+
     /**
      * Returns raw bytes of scan record.
      */
@@ -173,7 +185,7 @@ public final class ScanRecord {
             SparseArray<byte[]> manufacturerData,
             Map<ParcelUuid, byte[]> serviceData,
             int advertiseFlags, int txPowerLevel,
-            String localName, byte[] bytes) {
+            String localName, byte[] tdsData, byte[] bytes) {
         mServiceSolicitationUuids = serviceSolicitationUuids;
         mServiceUuids = serviceUuids;
         mManufacturerSpecificData = manufacturerData;
@@ -181,6 +193,7 @@ public final class ScanRecord {
         mDeviceName = localName;
         mAdvertiseFlags = advertiseFlags;
         mTxPowerLevel = txPowerLevel;
+        mTDSData = tdsData;
         mBytes = bytes;
     }
 
@@ -211,6 +224,8 @@ public final class ScanRecord {
         SparseArray<byte[]> manufacturerData = new SparseArray<byte[]>();
         Map<ParcelUuid, byte[]> serviceData = new ArrayMap<ParcelUuid, byte[]>();
 
+        byte[] tdsData = null;
+
         try {
             while (currentPos < scanRecord.length) {
                 // length is unsigned int.
@@ -288,6 +303,9 @@ public final class ScanRecord {
                                 dataLength - 2);
                         manufacturerData.put(manufacturerId, manufacturerDataBytes);
                         break;
+                    case DATA_TYPE_TRANSPORT_DISCOVERY_DATA:
+                        tdsData = extractBytes(scanRecord, currentPos, dataLength);
+                        break;
                     default:
                         // Just ignore, we don't handle such data type.
                         break;
@@ -299,12 +317,12 @@ public final class ScanRecord {
                 serviceUuids = null;
             }
             return new ScanRecord(serviceUuids, serviceSolicitationUuids, manufacturerData,
-                    serviceData, advertiseFlag, txPowerLevel, localName, scanRecord);
+                    serviceData, advertiseFlag, txPowerLevel, localName, tdsData, scanRecord);
         } catch (Exception e) {
             Log.e(TAG, ""unable to parse scan record: "" + Arrays.toString(scanRecord));
             // As the record is invalid, ignore all the parsed results for this packet
             // and return an empty record with raw scanRecord bytes in results
-            return new ScanRecord(null, null, null, null, -1, Integer.MIN_VALUE, null, scanRecord);
+            return new ScanRecord(null, null, null, null, -1, Integer.MIN_VALUE, null, null, scanRecord);
         }
     }
 
@@ -315,7 +333,8 @@ public final class ScanRecord {
                 + "", mManufacturerSpecificData="" + BluetoothLeUtils.toString(
                 mManufacturerSpecificData)
                 + "", mServiceData="" + BluetoothLeUtils.toString(mServiceData)
-                + "", mTxPowerLevel="" + mTxPowerLevel + "", mDeviceName="" + mDeviceName + ""]"";
+                + "", mTxPowerLevel="" + mTxPowerLevel + "", mDeviceName="" + mDeviceName +
+                "", mTDSData="" + BluetoothLeUtils.toString(mTDSData) +""]"";
     }
 
     // Parse service UUIDs.
",23,4,"ScanRecord::ScanRecord, ScanRecord::getTDSData, ScanRecord::toString, ScanRecord::ScanRecord, ScanRecord::parseFromBytes"
154,e78e62de0f659d3a9f2ab0fcfd40b5316e00fd0f,ClientOperation.java,ModificationType.MODIFY,"@@ -50,7 +50,7 @@ import android.util.Log;
  */
 public final class ClientOperation implements Operation, BaseStream {
 
-    private static final String TAG = ""ClientOperation"";
+    private static final String TAG = ""ObexClientOperation"";
 
     private static final boolean V = ObexHelper.VDBG;
 
",1,1,
155,e78e62de0f659d3a9f2ab0fcfd40b5316e00fd0f,ClientSession.java,ModificationType.MODIFY,"@@ -47,7 +47,7 @@ import android.util.Log;
  */
 public final class ClientSession extends ObexSession {
 
-    private static final String TAG = ""ClientSession"";
+    private static final String TAG = ""ObexClientSession"";
 
     private boolean mOpen;
 
",1,1,
156,e78e62de0f659d3a9f2ab0fcfd40b5316e00fd0f,ObexHelper.java,ModificationType.MODIFY,"@@ -52,7 +52,8 @@ import android.util.Log;
 public final class ObexHelper {
 
     private static final String TAG = ""ObexHelper"";
-    public static final boolean VDBG = false;
+    public static final String LOG_TAG = ""BluetoothObex"";
+    public static final boolean VDBG = Log.isLoggable(LOG_TAG, Log.VERBOSE);
     /**
      * Defines the basic packet length used by OBEX. Every OBEX packet has the
      * same basic format:<BR>
@@ -89,6 +90,8 @@ public final class ObexHelper {
      */
     public static final int MAX_CLIENT_PACKET_SIZE = 0xFC00;
 
+    public static final int A2DP_SCO_OBEX_MAX_CLIENT_PACKET_SIZE = 0x2000;
+
     public static final int OBEX_OPCODE_FINAL_BIT_MASK = 0x80;
 
     public static final int OBEX_OPCODE_CONNECT = 0x80;
@@ -193,6 +196,7 @@ public final class ObexHelper {
         try {
             while (index < headerArray.length) {
                 headerID = 0xFF & headerArray[index];
+                if (VDBG) Log.v(TAG,""updateHeaderSet headerID = "" + headerID);
                 switch (headerID & (0xC0)) {
 
                     /*
@@ -211,9 +215,9 @@ public final class ObexHelper {
                         length = ((0xFF & headerArray[index]) << 8) +
                                  (0xFF & headerArray[index + 1]);
                         index += 2;
-                        if (length <= OBEX_BYTE_SEQ_HEADER_LEN) {
+                        if (length < OBEX_BYTE_SEQ_HEADER_LEN) {
                             Log.e(TAG, ""Remote sent an OBEX packet with "" +
-                                  ""incorrect header length = "" + length);
+                                  ""incorrect header length : "" + length);
                             break;
                         }
                         length -= OBEX_BYTE_SEQ_HEADER_LEN;
@@ -381,8 +385,9 @@ public final class ObexHelper {
              * Determine if there is a connection ID to send.  If there is,
              * then it should be the first header in the packet.
              */
+            if (VDBG) Log.v(TAG,""createHeader = "" + head);
             if ((headImpl.mConnectionID != null) && (headImpl.getHeader(HeaderSet.TARGET) == null)) {
-
+                if (VDBG) Log.v(TAG,"" Add Header = "" + HeaderSet.CONNECTION_ID);
                 out.write((byte)HeaderSet.CONNECTION_ID);
                 out.write(headImpl.mConnectionID);
             }
@@ -390,6 +395,7 @@ public final class ObexHelper {
             // Count Header
             intHeader = (Long)headImpl.getHeader(HeaderSet.COUNT);
             if (intHeader != null) {
+                if (VDBG) Log.v(TAG,"" Add Header = "" + HeaderSet.COUNT);
                 out.write((byte)HeaderSet.COUNT);
                 value = ObexHelper.convertToByteArray(intHeader.longValue());
                 out.write(value);
@@ -401,6 +407,7 @@ public final class ObexHelper {
             // Name Header
             stringHeader = (String)headImpl.getHeader(HeaderSet.NAME);
             if (stringHeader != null) {
+                if (VDBG) Log.v(TAG,"" Add Header = "" + HeaderSet.NAME);
                 out.write((byte)HeaderSet.NAME);
                 value = ObexHelper.convertToUnicodeByteArray(stringHeader);
                 length = value.length + 3;
@@ -421,6 +428,7 @@ public final class ObexHelper {
             // Type Header
             stringHeader = (String)headImpl.getHeader(HeaderSet.TYPE);
             if (stringHeader != null) {
+                if (VDBG) Log.v(TAG,"" Add Header = "" + HeaderSet.TYPE);
                 out.write((byte)HeaderSet.TYPE);
                 try {
                     value = stringHeader.getBytes(""ISO8859_1"");
@@ -442,6 +450,7 @@ public final class ObexHelper {
             // Length Header
             intHeader = (Long)headImpl.getHeader(HeaderSet.LENGTH);
             if (intHeader != null) {
+                if (VDBG) Log.v(TAG,"" Add Header = "" + HeaderSet.LENGTH);
                 out.write((byte)HeaderSet.LENGTH);
                 value = ObexHelper.convertToByteArray(intHeader.longValue());
                 out.write(value);
@@ -453,7 +462,7 @@ public final class ObexHelper {
             // Time ISO Header
             dateHeader = (Calendar)headImpl.getHeader(HeaderSet.TIME_ISO_8601);
             if (dateHeader != null) {
-
+                if (VDBG) Log.v(TAG,"" Add dateHeader = "" + HeaderSet.TIME_ISO_8601);
                 /*
                  * The ISO Header should take the form YYYYMMDDTHHMMSSZ.  The
                  * 'Z' will only be included if it is a UTC time.
@@ -515,6 +524,7 @@ public final class ObexHelper {
             // Time 4 Byte Header
             dateHeader = (Calendar)headImpl.getHeader(HeaderSet.TIME_4_BYTE);
             if (dateHeader != null) {
+                if (VDBG) Log.v(TAG,"" Add dateHeader = "" + HeaderSet.TIME_4_BYTE);
                 out.write(HeaderSet.TIME_4_BYTE);
 
                 /*
@@ -549,6 +559,7 @@ public final class ObexHelper {
             // Target Header
             value = (byte[])headImpl.getHeader(HeaderSet.TARGET);
             if (value != null) {
+                if (VDBG) Log.v(TAG,"" Add Header = "" + HeaderSet.TARGET);
                 out.write((byte)HeaderSet.TARGET);
                 length = value.length + 3;
                 lengthArray[0] = (byte)(255 & (length >> 8));
@@ -577,6 +588,7 @@ public final class ObexHelper {
             // Who Header
             value = (byte[])headImpl.getHeader(HeaderSet.WHO);
             if (value != null) {
+                if (VDBG) Log.v(TAG,"" Add Header = "" + HeaderSet.WHO);
                 out.write((byte)HeaderSet.WHO);
                 length = value.length + 3;
                 lengthArray[0] = (byte)(255 & (length >> 8));
@@ -591,6 +603,7 @@ public final class ObexHelper {
             // Connection ID Header
             value = (byte[])headImpl.getHeader(HeaderSet.APPLICATION_PARAMETER);
             if (value != null) {
+                if (VDBG) Log.v(TAG,"" Add APP PARAM Header = "" + HeaderSet.APPLICATION_PARAMETER);
                 out.write((byte)HeaderSet.APPLICATION_PARAMETER);
                 length = value.length + 3;
                 lengthArray[0] = (byte)(255 & (length >> 8));
@@ -629,6 +642,7 @@ public final class ObexHelper {
                     lengthArray[1] = (byte)(255 & length);
                     out.write(lengthArray);
                     out.write(value);
+                    if (VDBG) Log.v(TAG,"" Add Unicode String value = "" + value);
                     if (nullOut) {
                         headImpl.setHeader(i + 0x30, null);
                     }
@@ -643,6 +657,7 @@ public final class ObexHelper {
                     lengthArray[1] = (byte)(255 & length);
                     out.write(lengthArray);
                     out.write(value);
+                    if (VDBG) Log.v(TAG,"" Add ByteSeq value = "" + value);
                     if (nullOut) {
                         headImpl.setHeader(i + 0x70, null);
                     }
@@ -653,6 +668,7 @@ public final class ObexHelper {
                 if (byteHeader != null) {
                     out.write((byte)i + 0xB0);
                     out.write(byteHeader.byteValue());
+                    if (VDBG) Log.v(TAG,"" Add ByteHeader value = "" + byteHeader.byteValue());
                     if (nullOut) {
                         headImpl.setHeader(i + 0xB0, null);
                     }
@@ -663,6 +679,7 @@ public final class ObexHelper {
                 if (intHeader != null) {
                     out.write((byte)i + 0xF0);
                     out.write(ObexHelper.convertToByteArray(intHeader.longValue()));
+                    if (VDBG) Log.v(TAG,"" Add Int value = "" + intHeader.longValue());
                     if (nullOut) {
                         headImpl.setHeader(i + 0xF0, null);
                     }
@@ -677,6 +694,7 @@ public final class ObexHelper {
                 lengthArray[1] = (byte)(255 & length);
                 out.write(lengthArray);
                 out.write(headImpl.mAuthChall);
+                if (VDBG) Log.v(TAG,"" Add mAuthChall value = "" + headImpl.mAuthChall);
                 if (nullOut) {
                     headImpl.mAuthChall = null;
                 }
@@ -690,6 +708,7 @@ public final class ObexHelper {
                 lengthArray[1] = (byte)(255 & length);
                 out.write(lengthArray);
                 out.write(headImpl.mAuthResp);
+                if (VDBG) Log.v(TAG,"" Add mAuthChall value = "" + headImpl.mAuthResp);
                 if (nullOut) {
                     headImpl.mAuthResp = null;
                 }
@@ -705,8 +724,10 @@ public final class ObexHelper {
             // Add the SRM header
             byteHeader = (Byte)headImpl.getHeader(HeaderSet.SINGLE_RESPONSE_MODE);
             if (byteHeader != null) {
+                if (VDBG) Log.v(TAG,"" Add SRM Header = "" + HeaderSet.SINGLE_RESPONSE_MODE);
                 out.write((byte)HeaderSet.SINGLE_RESPONSE_MODE);
                 out.write(byteHeader.byteValue());
+                if (VDBG) Log.v(TAG,"" Add SRM value = "" + byteHeader.byteValue());
                 if (nullOut) {
                     headImpl.setHeader(HeaderSet.SINGLE_RESPONSE_MODE, null);
                 }
@@ -715,6 +736,7 @@ public final class ObexHelper {
             // Add the SRM parameter header
             byteHeader = (Byte)headImpl.getHeader(HeaderSet.SINGLE_RESPONSE_MODE_PARAMETER);
             if (byteHeader != null) {
+                if (VDBG) Log.v(TAG,"" Add Header = "" + HeaderSet.SINGLE_RESPONSE_MODE_PARAMETER);
                 out.write((byte)HeaderSet.SINGLE_RESPONSE_MODE_PARAMETER);
                 out.write(byteHeader.byteValue());
                 if (nullOut) {
",27,5,"ObexHelper::createHeader, ObexHelper::updateHeaderSet"
157,e78e62de0f659d3a9f2ab0fcfd40b5316e00fd0f,ServerOperation.java,ModificationType.MODIFY,"@@ -57,7 +57,7 @@ import android.util.Log;
  */
 public final class ServerOperation implements Operation, BaseStream {
 
-    private static final String TAG = ""ServerOperation"";
+    private static final String TAG = ""ObexServerOperation"";
 
     private static final boolean V = ObexHelper.VDBG; // Verbose debugging
 
@@ -124,6 +124,7 @@ public final class ServerOperation implements Operation, BaseStream {
      */
     public ServerOperation(ServerSession p, InputStream in, int request, int maxSize,
             ServerRequestHandler listen) throws IOException {
+        if (V)  Log.v(TAG, ""ServerOperation"");
 
         isAborted = false;
         mParent = p;
@@ -340,14 +341,17 @@ public final class ServerOperation implements Operation, BaseStream {
      */
     public synchronized boolean continueOperation(boolean sendEmpty, boolean inStream)
             throws IOException {
+        if (V) Log.v(TAG, ""continueOperation"");
         if (!mGetOperation) {
             if (!finalBitSet) {
                 if (sendEmpty) {
                     sendReply(ResponseCodes.OBEX_HTTP_CONTINUE);
+                    if (V) Log.v(TAG, ""continueOperation:ServerSet SRM sendEmpty clause"");
                     return true;
                 } else {
                     if ((mResponseSize > 3) || (mPrivateOutput.size() > 0)) {
                         sendReply(ResponseCodes.OBEX_HTTP_CONTINUE);
+                        if (V) Log.v(TAG, ""continueOperation: Server setting SRM"");
                         return true;
                     } else {
                         return false;
@@ -357,6 +361,7 @@ public final class ServerOperation implements Operation, BaseStream {
                 return false;
             }
         } else {
+            if (V) Log.v(TAG, ""Get continueOperation "");
             sendReply(ResponseCodes.OBEX_HTTP_CONTINUE);
             return true;
         }
@@ -405,6 +410,8 @@ public final class ServerOperation implements Operation, BaseStream {
             bodyLength = mPrivateOutput.size();
             orginalBodyLength = bodyLength;
         }
+        if(V) Log.v(TAG, ""mMaxPcKLen :"" + mMaxPacketLength + "" headerArryLen :""
+                      + headerArray.length);
 
         if ((ObexHelper.BASE_PACKET_LENGTH + headerArray.length) > mMaxPacketLength) {
 
",8,1,"ServerOperation::ServerOperation, ServerOperation::continueOperation, ServerOperation::sendReply"
158,e78e62de0f659d3a9f2ab0fcfd40b5316e00fd0f,ServerSession.java,ModificationType.MODIFY,"@@ -63,6 +63,12 @@ public final class ServerSession extends ObexSession implements Runnable {
 
     private boolean mClosed;
 
+    private boolean setMTU = false;
+
+    private boolean updateMtu = false;
+
+    private int updatedMtuSize = 0;
+
     /**
      * Creates new ServerSession.
      * @param trans the connection to the client
@@ -85,6 +91,25 @@ public final class ServerSession extends ObexSession implements Runnable {
         mProcessThread.start();
     }
 
+    public void setMaxPacketSize(int size) {
+        if (V)  Log.v(TAG, ""setMaxPacketSize"" + size);
+        mMaxPacketLength = size;
+    }
+
+    public int getMaxPacketSize() {
+       return mMaxPacketLength;
+    }
+
+    public void reduceMTU(boolean enable) {
+        setMTU = enable;
+   }
+
+   public void updateMTU(int mtuSize) {
+        updateMtu = true;
+        updatedMtuSize = mtuSize;
+        Log.i(TAG,""updateMTU: "" + mtuSize);
+   }
+
     /**
      * Processes requests made to the server and forwards them to the
      * appropriate event listener.
@@ -124,6 +149,7 @@ public final class ServerSession extends ObexSession implements Runnable {
                         break;
 
                     case -1:
+                        Log.d(TAG, ""Read request returned -1, exiting from loop"");
                         done = true;
                         break;
 
@@ -194,6 +220,7 @@ public final class ServerSession extends ObexSession implements Runnable {
      * @throws IOException if an error occurred at the transport layer
      */
     private void handlePutRequest(int type) throws IOException {
+        if (V)  Log.v(TAG, ""handlePutRequest"");
         ServerOperation op = new ServerOperation(this, mInput, type, mMaxPacketLength, mListener);
         try {
             int response = -1;
@@ -205,10 +232,12 @@ public final class ServerSession extends ObexSession implements Runnable {
                 response = validateResponseCode(mListener.onPut(op));
             }
             if (response != ResponseCodes.OBEX_HTTP_OK && !op.isAborted) {
+                if (V) Log.v(TAG, ""handlePutRequest pre != HTTP_OK sendReply"");
                 op.sendReply(response);
             } else if (!op.isAborted) {
                 // wait for the final bit
                 while (!op.finalBitSet) {
+                    if (V) Log.v(TAG, ""handlePutRequest pre looped sendReply"");
                     op.sendReply(ResponseCodes.OBEX_HTTP_CONTINUE);
                 }
                 op.sendReply(response);
@@ -240,6 +269,7 @@ public final class ServerSession extends ObexSession implements Runnable {
      * @throws IOException if an error occurred at the transport layer
      */
     private void handleGetRequest(int type) throws IOException {
+        if (V)  Log.v(TAG, ""handleGetRequest"");
         ServerOperation op = new ServerOperation(this, mInput, type, mMaxPacketLength, mListener);
         try {
             int response = validateResponseCode(mListener.onGet(op));
@@ -262,6 +292,7 @@ public final class ServerSession extends ObexSession implements Runnable {
     public void sendResponse(int code, byte[] header) throws IOException {
         int totalLength = 3;
         byte[] data = null;
+        if (V) Log.v(TAG,""sendResponse code "" + code + "" header : "" + header);
         OutputStream op = mOutput;
         if (op == null) {
             return;
@@ -269,6 +300,7 @@ public final class ServerSession extends ObexSession implements Runnable {
 
         if (header != null) {
             totalLength += header.length;
+            if (V) Log.v(TAG, ""header != null totalLength = "" + totalLength);
             data = new byte[totalLength];
             data[0] = (byte)code;
             data[1] = (byte)(totalLength >> 8);
@@ -558,9 +590,19 @@ public final class ServerSession extends ObexSession implements Runnable {
                 + "" MaxLength: "" + mMaxPacketLength + "" flags: "" + flags);
 
         // should we check it?
-        if (mMaxPacketLength > ObexHelper.MAX_PACKET_SIZE_INT) {
+        if (setMTU) {
+            mMaxPacketLength = ObexHelper.A2DP_SCO_OBEX_MAX_CLIENT_PACKET_SIZE;
+            setMTU = false;
+        } else if (updateMtu) {
+            Log.d(TAG, ""mMaxPacketLength: "" + mMaxPacketLength +
+                    "", updatedMtuSize: "" + updatedMtuSize);
+            if (mMaxPacketLength > updatedMtuSize)
+                mMaxPacketLength = updatedMtuSize;
+            updateMtu = false;
+        } else if (mMaxPacketLength > ObexHelper.MAX_PACKET_SIZE_INT) {
             mMaxPacketLength = ObexHelper.MAX_PACKET_SIZE_INT;
         }
+        Log.d(TAG,""handleConnectRequest() - Updated MaxPacketLengh: "" + mMaxPacketLength);
 
         if(mMaxPacketLength > ObexHelper.getMaxTxPacketSize(mTransport)) {
             Log.w(TAG, ""Requested MaxObexPacketSize "" + mMaxPacketLength
",43,1,"ServerSession::getMaxPacketSize, ServerSession::handlePutRequest, ServerSession::handleGetRequest, ServerSession::setMaxPacketSize, ServerSession::run, ServerSession::sendResponse, ServerSession::reduceMTU, ServerSession::handleConnectRequest, ServerSession::updateMTU"
159,2f5026c1922db28882c121e0bcead647e2b1e2d1,CachedBluetoothDevice.java,ModificationType.MODIFY,"@@ -217,6 +217,7 @@ public class CachedBluetoothDevice implements Comparable<CachedBluetoothDevice>
         }
 
         mConnectAttempted = SystemClock.elapsedRealtime();
+        Log.d(TAG, ""connect: mConnectAttempted = "" + mConnectAttempted);
         connectWithoutResettingTimer(connectAllProfiles);
     }
 
@@ -255,7 +256,13 @@ public class CachedBluetoothDevice implements Comparable<CachedBluetoothDevice>
                 Log.d(TAG, ""No profiles. Maybe we will connect later for device "" + mDevice);
                 return;
             }
-
+            // BondingInitiatedLocally flag should be reset in onBondingStateChanged
+            // But Settings executing onBondingStateChanged twice and its lead to auto connection
+            // failure. this flag will be moved from here once settings issue fixed.
+            if (mDevice.isBondingInitiatedLocally()) {
+                Log.w(TAG, ""reset BondingInitiatedLocally flag"");
+                mDevice.setBondingInitiatedLocally(false);
+            }
             int preferredProfiles = 0;
             for (LocalBluetoothProfile profile : mProfiles) {
                 if (connectAllProfiles ? profile.accessProfileEnabled()
@@ -661,8 +668,8 @@ public class CachedBluetoothDevice implements Comparable<CachedBluetoothDevice>
          * If a connect was attempted earlier without any UUID, we will do the connect now.
          * Otherwise, allow the connect on UUID change.
          */
-        if (!mProfiles.isEmpty()
-                && ((mConnectAttempted + timeout) > SystemClock.elapsedRealtime())) {
+        if ((mConnectAttempted + timeout) > SystemClock.elapsedRealtime()) {
+            Log.d(TAG, ""onUuidChanged: triggering connectWithoutResettingTimer"");
             connectWithoutResettingTimer(false);
         }
 
@@ -684,9 +691,6 @@ public class CachedBluetoothDevice implements Comparable<CachedBluetoothDevice>
         if (bondState == BluetoothDevice.BOND_BONDED) {
             boolean mIsBondingInitiatedLocally = mDevice.isBondingInitiatedLocally();
             Log.w(TAG, ""mIsBondingInitiatedLocally"" + mIsBondingInitiatedLocally);
-            if (mIsBondingInitiatedLocally) {
-                mDevice.setBondingInitiatedLocally(false);
-            }
             if (mDevice.isBluetoothDock()) {
                 onBondingDockConnect();
             } else if (mIsTwsConnectEnabled) {
",10,6,"CachedBluetoothDevice::onBondingStateChanged, CachedBluetoothDevice::connect, CachedBluetoothDevice::connectWithoutResettingTimer, CachedBluetoothDevice::onUuidChanged"
160,e79b237d8b644d9e8ba65f68ff550850cdc19ad5,CachedBluetoothDevice.java,ModificationType.MODIFY,"@@ -357,7 +357,7 @@ public class CachedBluetoothDevice implements Comparable<CachedBluetoothDevice>
                if (peerDevice != null) {
                    final boolean peersuccessful = peerDevice.removeBond();
                    if (peersuccessful) {
-                       if (Utils.D) {
+                       if (BluetoothUtils.D) {
                            Log.d(TAG, ""Command sent successfully:REMOVE_BOND "" + peerDevice.getName());
                        }
                    }
",1,1,CachedBluetoothDevice::unpair
161,99db3abd25cc16a6ece93f0b99175d531544dbbc,AudioSystem.java,ModificationType.MODIFY,"@@ -151,6 +151,8 @@ public class AudioSystem
     public static final int AUDIO_FORMAT_APTX           = 0x20000000;
     public static final int AUDIO_FORMAT_APTX_HD        = 0x21000000;
     public static final int AUDIO_FORMAT_LDAC           = 0x23000000;
+    public static final int AUDIO_FORMAT_CELT           = 0x26000000;
+    public static final int AUDIO_FORMAT_APTX_ADAPTIVE  = 0x27000000;
 
     /**
      * Convert audio format enum values to Bluetooth codec values
@@ -162,6 +164,9 @@ public class AudioSystem
             case AUDIO_FORMAT_APTX: return BluetoothCodecConfig.SOURCE_CODEC_TYPE_APTX;
             case AUDIO_FORMAT_APTX_HD: return BluetoothCodecConfig.SOURCE_CODEC_TYPE_APTX_HD;
             case AUDIO_FORMAT_LDAC: return BluetoothCodecConfig.SOURCE_CODEC_TYPE_LDAC;
+            case AUDIO_FORMAT_CELT: return BluetoothCodecConfig.SOURCE_CODEC_TYPE_CELT;
+            case AUDIO_FORMAT_APTX_ADAPTIVE:
+                     return BluetoothCodecConfig.SOURCE_CODEC_TYPE_APTX_ADAPTIVE;
             default: return BluetoothCodecConfig.SOURCE_CODEC_TYPE_INVALID;
         }
     }
",5,0,AudioSystem::audioFormatToBluetoothSourceCodec
162,99db3abd25cc16a6ece93f0b99175d531544dbbc,BtHelper.java,ModificationType.MODIFY,"@@ -1005,6 +1005,10 @@ public class BtHelper {
                 return AudioSystem.AUDIO_FORMAT_APTX_HD;
             case BluetoothCodecConfig.SOURCE_CODEC_TYPE_LDAC:
                 return AudioSystem.AUDIO_FORMAT_LDAC;
+            case BluetoothCodecConfig.SOURCE_CODEC_TYPE_CELT:
+                return AudioSystem.AUDIO_FORMAT_CELT;
+            case BluetoothCodecConfig.SOURCE_CODEC_TYPE_APTX_ADAPTIVE:
+                return AudioSystem.AUDIO_FORMAT_APTX_ADAPTIVE;
             default:
                 return AudioSystem.AUDIO_FORMAT_DEFAULT;
         }
",4,0,BtHelper::mapBluetoothCodecToAudioFormat
163,e824b902a8e0bcc1bfa897891ef86ae369b2c30b,AudioSystem.java,ModificationType.MODIFY,"@@ -153,6 +153,7 @@ public class AudioSystem
     public static final int AUDIO_FORMAT_LDAC           = 0x23000000;
     public static final int AUDIO_FORMAT_CELT           = 0x26000000;
     public static final int AUDIO_FORMAT_APTX_ADAPTIVE  = 0x27000000;
+    public static final int AUDIO_FORMAT_APTX_TWSP      = 0x2A000000;
 
     /**
      * Convert audio format enum values to Bluetooth codec values
@@ -167,6 +168,8 @@ public class AudioSystem
             case AUDIO_FORMAT_CELT: return BluetoothCodecConfig.SOURCE_CODEC_TYPE_CELT;
             case AUDIO_FORMAT_APTX_ADAPTIVE:
                      return BluetoothCodecConfig.SOURCE_CODEC_TYPE_APTX_ADAPTIVE;
+            case AUDIO_FORMAT_APTX_TWSP:
+                     return BluetoothCodecConfig.SOURCE_CODEC_TYPE_APTX_TWSP;
             default: return BluetoothCodecConfig.SOURCE_CODEC_TYPE_INVALID;
         }
     }
",3,0,AudioSystem::audioFormatToBluetoothSourceCodec
164,e824b902a8e0bcc1bfa897891ef86ae369b2c30b,BtHelper.java,ModificationType.MODIFY,"@@ -1009,6 +1009,8 @@ public class BtHelper {
                 return AudioSystem.AUDIO_FORMAT_CELT;
             case BluetoothCodecConfig.SOURCE_CODEC_TYPE_APTX_ADAPTIVE:
                 return AudioSystem.AUDIO_FORMAT_APTX_ADAPTIVE;
+            case BluetoothCodecConfig.SOURCE_CODEC_TYPE_APTX_TWSP:
+                return AudioSystem.AUDIO_FORMAT_APTX_TWSP;
             default:
                 return AudioSystem.AUDIO_FORMAT_DEFAULT;
         }
",2,0,BtHelper::mapBluetoothCodecToAudioFormat
165,8fbf21ed1f153f82b41ad704d651b60ca3782dbb,AudioDeviceInventory.java,ModificationType.MODIFY,"@@ -636,6 +636,12 @@ public class AudioDeviceInventory {
                       mConnectedDevices.put(deviceKey, new DeviceInfo(
                                  AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP, BtHelper.getName(device),
                                  address, a2dpCodec));
+                      if (BtHelper.isTwsPlusSwitch(device, deviceInfo.mDeviceAddress)) {
+                          if (AudioService.DEBUG_DEVICES) {
+                              Log.d(TAG,""TWS+ device switch"");
+                          }
+                          return;
+                      }
                       mDeviceBroker.postA2dpActiveDeviceChange(
                                  new BtHelper.BluetoothA2dpDeviceInfo(
                                      device, a2dpVolume, a2dpCodec));
",6,0,AudioDeviceInventory::handleBluetoothA2dpActiveDeviceChangeExt
166,8fbf21ed1f153f82b41ad704d651b60ca3782dbb,BtHelper.java,ModificationType.MODIFY,"@@ -168,6 +168,21 @@ public class BtHelper {
         return deviceName;
     }
 
+    /*packages*/ @NonNull static boolean isTwsPlusSwitch(@NonNull BluetoothDevice device,
+                                                                 String address) {
+        BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
+        if (device == null || adapter.getRemoteDevice(address) == null ||
+            device.getTwsPlusPeerAddress() == null) {
+            return false;
+        }
+        if (device.isTwsPlusDevice() &&
+            adapter.getRemoteDevice(address).isTwsPlusDevice() &&
+            device.getTwsPlusPeerAddress().equals(address)) {
+            Log.i(TAG,""isTwsPlusSwitch true"");
+            return true;
+         }
+         return false;
+    }
     //----------------------------------------------------------------------
     // Interface for AudioDeviceBroker
 
",15,0,BtHelper::isTwsPlusSwitch
167,22b31dd8e94c98d5bba427425b47099628e767b5,BtHelper.java,ModificationType.MODIFY,"@@ -69,7 +69,7 @@ public class BtHelper {
     private @Nullable BluetoothHearingAid mHearingAid;
 
     // Reference to BluetoothA2dp to query for AbsoluteVolume.
-    private @Nullable BluetoothA2dp mA2dp;
+    static private @Nullable BluetoothA2dp mA2dp;
 
     // If absolute volume is supported in AVRCP device
     private boolean mAvrcpAbsVolSupported = false;
@@ -171,13 +171,18 @@ public class BtHelper {
     /*packages*/ @NonNull static boolean isTwsPlusSwitch(@NonNull BluetoothDevice device,
                                                                  String address) {
         BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
-        if (device == null || adapter.getRemoteDevice(address) == null ||
+        BluetoothDevice connDevice = adapter.getRemoteDevice(address);
+        if (device == null || connDevice == null ||
             device.getTwsPlusPeerAddress() == null) {
             return false;
         }
         if (device.isTwsPlusDevice() &&
-            adapter.getRemoteDevice(address).isTwsPlusDevice() &&
+            connDevice.isTwsPlusDevice() &&
             device.getTwsPlusPeerAddress().equals(address)) {
+            if(mA2dp.getConnectionState(connDevice) != BluetoothProfile.STATE_CONNECTED) {
+                Log.w(TAG,""Active earbud is already disconnected"");
+                return false;
+            }
             Log.i(TAG,""isTwsPlusSwitch true"");
             return true;
          }
",8,3,BtHelper::isTwsPlusSwitch
168,fb2370e990a2caa8b72af073415e73182e6f77dc,BluetoothDevice.java,ModificationType.MODIFY,"@@ -229,6 +229,18 @@ public final class BluetoothDevice implements Parcelable {
     public static final String ACTION_BOND_STATE_CHANGED =
             ""android.bluetooth.device.action.BOND_STATE_CHANGED"";
 
+     /**
+     * Broadcast Action: Broadcast details of IOT device when an IOT
+     * related issue is observed.
+     * <p>Always contains the extra fields {@link #EXTRA_NAME}.
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH} to receive.
+     * @hide
+     **/
+
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_REMOTE_ISSUE_OCCURRED  =
+            ""org.codeaurora.intent.bluetooth.action.REMOTE_ISSUE_OCCURRED"";
+
     /**
      * Broadcast Action: Indicates the battery level of a remote device has
      * been retrieved for the first time, or changed since the last retrieval
@@ -291,6 +303,69 @@ public final class BluetoothDevice implements Parcelable {
      */
     public static final String EXTRA_BQR = ""android.bluetooth.qti.extra.EXTRA_BQR"";
 
+    /**
+     * Used as a String extra field in {@link #ACTION_REMOTE_ISSUE_OCCURRED}
+     * intents. It contains the type of IOT issue that occurred.
+     * @hide
+     */
+    public static final String EXTRA_ISSUE_TYPE = ""android.bluetooth.qti.extra.ERROR_TYPE"";
+
+    /**
+     * Used as a String extra field in {@link #ACTION_REMOTE_ISSUE_OCCURRED} intents.
+     * It contains the details of details of the issue.
+     * @hide
+     */
+    public static final String EXTRA_ERROR_CODE = ""android.bluetooth.qti.extra.ERROR_CODE"";
+
+    /**
+     * Used as a String extra field in {@link #ACTION_REMOTE_ISSUE_OCCURRED} intents.
+     * It contains the SoC event mask when issue occurred.
+     * @hide
+     */
+    public static final String EXTRA_ERROR_EVENT_MASK = ""android.bluetooth.qti.extra.ERROR_EVENT_MASK"";
+
+    /**
+     * Used as a String extra field in {@link #ACTION_REMOTE_ISSUE_OCCURRED} intents.
+     * It contains the LMP Version of IOT device.
+     * @hide
+     */
+    public static final String EXTRA_LMP_VERSION = ""android.bluetooth.qti.extra.EXTRA_LMP_VERSION"";
+
+    /**
+     * Used as a String extra field in {@link #ACTION_REMOTE_ISSUE_OCCURRED} intents.
+     * It contains the LMP Sub Version of IOT device.
+     * @hide
+     */
+    public static final String EXTRA_LMP_SUBVER = ""android.bluetooth.qti.extra.EXTRA_LMP_SUBVER"";
+
+    /**
+     * Used as a String extra field in {@link #ACTION_REMOTE_ISSUE_OCCURRED} intents.
+     * It contains the Manufacturer ID of IOT device.
+     * @hide
+     */
+    public static final String EXTRA_MANUFACTURER = ""android.bluetooth.qti.extra.EXTRA_MANUFACTURER"";
+
+    /**
+     * Used as a String extra field in {@link #ACTION_REMOTE_ISSUE_OCCURRED} intents.
+     * It contains the Power level.
+     * @hide
+     */
+    public static final String EXTRA_POWER_LEVEL = ""android.bluetooth.qti.extra.EXTRA_POWER_LEVEL"";
+
+    /**
+     * Used as a String extra field in {@link #ACTION_REMOTE_ISSUE_OCCURRED} intents.
+     * It contains the Link Quality of the connection.
+     * @hide
+     */
+    public static final String EXTRA_LINK_QUALITY = ""android.bluetooth.qti.extra.EXTRA_LINK_QUALITY"";
+
+    /**
+     * Used as a String extra field in {@link #ACTION_REMOTE_ISSUE_OCCURRED} intents.
+     * It contains the coutnt of glitches occured since last broadcast.
+     * @hide
+     */
+    public static final String EXTRA_GLITCH_COUNT = ""android.bluetooth.qti.extra.EXTRA_GLITCH_COUNT"";
+
     /**
      * Used as an optional short extra field in {@link #ACTION_FOUND} intents.
      * Contains the RSSI value of the remote device as reported by the
",75,0,
169,e77b3a0304ef0d2de85a2fab42a36e92dcb5b430,BluetoothAdapter.java,ModificationType.MODIFY,"@@ -2800,6 +2800,22 @@ public final class BluetoothAdapter {
         }
     }
 
+    /**
+     * @hide
+     */
+    public void unregisterAdapter() {
+        try {
+            //mServiceLock.writeLock().lock();
+            if (mManagerService != null){
+                mManagerService.unregisterAdapter(mManagerCallback);
+            }
+        } catch (RemoteException e) {
+            Log.e(TAG, """", e);
+        } finally {
+            //mServiceLock.writeLock().unlock();
+        }
+    }
+
     private Set<BluetoothDevice> toDeviceSet(BluetoothDevice[] devices) {
         Set<BluetoothDevice> deviceSet = new HashSet<BluetoothDevice>(Arrays.asList(devices));
         return Collections.unmodifiableSet(deviceSet);
",16,0,BluetoothAdapter::unregisterAdapter
170,e77b3a0304ef0d2de85a2fab42a36e92dcb5b430,BluetoothHeadset.java,ModificationType.MODIFY,"@@ -452,6 +452,10 @@ public final class BluetoothHeadset implements BluetoothProfile {
         doUnbind();
     }
 
+    public void finalize() {
+        close();
+    }
+
     /**
      * Initiate connection to a profile of the remote bluetooth device.
      *
",4,0,BluetoothHeadset::finalize
171,0c1bc0ceb48fbc3ef1a74581e7384ac6172120fa,BluetoothHeadset.java,ModificationType.MODIFY,"@@ -452,7 +452,7 @@ public final class BluetoothHeadset implements BluetoothProfile {
         doUnbind();
     }
 
-    public void finalize() {
+    protected void finalize() {
         close();
     }
 
",1,1,BluetoothHeadset::finalize
172,d5d48fa7c9d75f4de0ebbe418a612c900ea239ba,A2dpProfile.java,ModificationType.MODIFY,"@@ -35,6 +35,7 @@ import java.util.List;
 
 public class A2dpProfile implements LocalBluetoothProfile {
     private static final String TAG = ""A2dpProfile"";
+    private static boolean V = true;
 
     private Context mContext;
 
@@ -210,11 +211,21 @@ public class A2dpProfile implements LocalBluetoothProfile {
     }
 
     public boolean supportsHighQualityAudio(BluetoothDevice device) {
+        if (V) Log.d(TAG, "" execute supportsHighQualityAudio()"");
+        if (mService == null) {
+            if (V) Log.d(TAG,""mService is null."");
+            return false;
+        }
         int support = mService.supportsOptionalCodecs(device);
         return support == BluetoothA2dp.OPTIONAL_CODECS_SUPPORTED;
     }
 
     public boolean isHighQualityAudioEnabled(BluetoothDevice device) {
+        if (V) Log.d(TAG, "" execute isHighQualityAudioEnabled()"");
+        if (mService == null) {
+            if (V) Log.d(TAG,""mService is null."");
+            return false;
+        }
         int enabled = mService.getOptionalCodecsEnabled(device);
         if (enabled != BluetoothA2dp.OPTIONAL_CODECS_PREF_UNKNOWN) {
             return enabled == BluetoothA2dp.OPTIONAL_CODECS_PREF_ENABLED;
@@ -237,9 +248,14 @@ public class A2dpProfile implements LocalBluetoothProfile {
     }
 
     public void setHighQualityAudioEnabled(BluetoothDevice device, boolean enabled) {
+        if (V) Log.d(TAG, "" execute setHighQualityAudioEnabled()"");
         int prefValue = enabled
                 ? BluetoothA2dp.OPTIONAL_CODECS_PREF_ENABLED
                 : BluetoothA2dp.OPTIONAL_CODECS_PREF_DISABLED;
+        if (mService == null) {
+            if (V) Log.d(TAG,""mService is null."");
+            return;
+        }
         mService.setOptionalCodecsEnabled(device, prefValue);
         if (getConnectionStatus(device) != BluetoothProfile.STATE_CONNECTED) {
             return;
@@ -252,6 +268,7 @@ public class A2dpProfile implements LocalBluetoothProfile {
     }
 
     public String getHighQualityAudioOptionLabel(BluetoothDevice device) {
+        if (V) Log.d(TAG, "" execute getHighQualityAudioOptionLabel()"");
         int unknownCodecId = R.string.bluetooth_profile_a2dp_high_quality_unknown_codec;
         if (!supportsHighQualityAudio(device)
                 || getConnectionStatus(device) != BluetoothProfile.STATE_CONNECTED) {
@@ -260,7 +277,7 @@ public class A2dpProfile implements LocalBluetoothProfile {
         // We want to get the highest priority codec, since that's the one that will be used with
         // this device, and see if it is high-quality (ie non-mandatory).
         BluetoothCodecConfig[] selectable = null;
-        if (mService.getCodecStatus(device) != null) {
+        if (mService != null && mService.getCodecStatus(device) != null) {
             selectable = mService.getCodecStatus(device).getCodecsSelectableCapabilities();
             // To get the highest priority, we sort in reverse.
             Arrays.sort(selectable,
",18,1,"A2dpProfile::setHighQualityAudioEnabled, A2dpProfile::getHighQualityAudioOptionLabel, A2dpProfile::supportsHighQualityAudio, A2dpProfile::isHighQualityAudioEnabled"
173,937b57425c8c703c3ba39b9b27f212f79a20089b,BluetoothCodecConfig.java,ModificationType.MODIFY,"@@ -550,6 +550,10 @@ public final class BluetoothCodecConfig implements Parcelable {
                 if (mCodecSpecific1 != other.mCodecSpecific1) {
                     return false;
                 }
+            case SOURCE_CODEC_TYPE_APTX_ADAPTIVE:
+                if (other.mCodecSpecific4 > 0) {
+                    return false;
+                }
                 // fall through
             default:
                 return true;
",4,0,BluetoothCodecConfig::sameCodecSpecificParameters
174,a39f9f4a17659bad46fc1310ba53fa1558b5be4f,A2dpProfile.java,ModificationType.MODIFY,"@@ -320,7 +320,7 @@ public class A2dpProfile implements LocalBluetoothProfile {
             return mContext.getString(unknownCodecId);
         }
         return mContext.getString(R.string.bluetooth_profile_a2dp_high_quality,
-                mContext.getResources().getStringArray(R.array.bluetooth_a2dp_codec_titles)[index]);
+                mContext.getResources().getStringArray(R.array.bluetooth_a2dp_codec_titles_cm)[index]);
     }
 
     public String toString() {
",1,1,A2dpProfile::getHighQualityAudioOptionLabel
175,a39f9f4a17659bad46fc1310ba53fa1558b5be4f,A2dpProfileTest.java,ModificationType.MODIFY,"@@ -146,7 +146,7 @@ public class A2dpProfileTest {
 
         final Resources res = mock(Resources.class);
         when(mContext.getResources()).thenReturn(res);
-        when(res.getStringArray(eq(R.array.bluetooth_a2dp_codec_titles)))
+        when(res.getStringArray(eq(R.array.bluetooth_a2dp_codec_titles_cm)))
                 .thenReturn(CODEC_NAMES);
 
         // Most tests want to simulate optional codecs being supported by the device, so do that
",1,1,A2dpProfileTest::setupLabelTest
176,3cc0fee66b4a995c1bea730b784c97b32a0584e1,ScanFilter.java,ModificationType.MODIFY,"@@ -174,12 +174,15 @@ public final class ScanFilter implements Parcelable {
             }
         }
         dest.writeInt(mOrgId);
-        dest.writeInt(mTDSFlags);
-        dest.writeInt(mTDSFlagsMask);
-        dest.writeInt(mWifiNANHash == null ? 0 : 1);
-        if (mWifiNANHash != null) {
-            dest.writeInt(mWifiNANHash.length);
-            dest.writeByteArray(mWifiNANHash);
+        dest.writeInt(mOrgId < 0 ? 0 : 1);
+        if(mOrgId >= 0) {
+            dest.writeInt(mTDSFlags);
+            dest.writeInt(mTDSFlagsMask);
+            dest.writeInt(mWifiNANHash == null ? 0 : 1);
+            if (mWifiNANHash != null) {
+                dest.writeInt(mWifiNANHash.length);
+                dest.writeByteArray(mWifiNANHash);
+            }
         }
     }
 
@@ -259,17 +262,19 @@ public final class ScanFilter implements Parcelable {
             }
 
             int orgId = in.readInt();
-            int TDSFlags = in.readInt();
-            int TDSFlagsMask = in.readInt();
-            if (in.readInt() == 1) {
-                int wifiNANHashLength = in.readInt();
-                byte[] wifiNanHash = new byte[wifiNANHashLength];
-                in.readByteArray(wifiNanHash);
-                builder.setTransportDiscoveryData(orgId, TDSFlags, TDSFlagsMask,
-                        wifiNanHash);
-            }
-            else {
-                builder.setTransportDiscoveryData(orgId, TDSFlags, TDSFlagsMask, null);
+            if(in.readInt() == 1) {
+                int tdsFlags = in.readInt();
+                int tdsFlagsMask = in.readInt();
+                if (in.readInt() == 1) {
+                    int wifiNANHashLength = in.readInt();
+                    byte[] wifiNanHash = new byte[wifiNANHashLength];
+                    in.readByteArray(wifiNanHash);
+                    builder.setTransportDiscoveryData(orgId, tdsFlags, tdsFlagsMask,
+                            wifiNanHash);
+                }
+                else {
+                    builder.setTransportDiscoveryData(orgId, tdsFlags, tdsFlagsMask, null);
+                }
             }
 
             return builder.build();
",22,17,"ScanFilter::Creator<ScanFilter>, ScanFilter::writeToParcel"
177,898eec20c08aeb4712666fd2335fb3327b9ff396,BluetoothHeadset.java,ModificationType.MODIFY,"@@ -452,7 +452,7 @@ public final class BluetoothHeadset implements BluetoothProfile {
         doUnbind();
     }
 
-    protected void finalize() {
+    protected void finalize() throws Throwable {
         close();
     }
 
",1,1,BluetoothHeadset::finalize
178,214db7e2853bc51c3d10d01da0cf4e138531091d,AdvertiseData.java,ModificationType.MODIFY,"@@ -170,8 +170,8 @@ public final class AdvertiseData implements Parcelable {
         }
         dest.writeByte((byte) (getIncludeTxPowerLevel() ? 1 : 0));
         dest.writeByte((byte) (getIncludeDeviceName() ? 1 : 0));
-        if(mTransportDiscoveryData != null) {
-            dest.writeInt(mTransportDiscoveryData.length);
+        dest.writeInt(mTransportDiscoveryData != null ? mTransportDiscoveryData.length : 0);
+        if (mTransportDiscoveryData != null) {
             dest.writeByteArray(mTransportDiscoveryData);
         }
     }
",2,2,AdvertiseData::writeToParcel
179,668c9d1e3c0df50c5a8e01b0efe39cf4bbd82cec,PowerShareTile.java,ModificationType.MODIFY,"@@ -68,6 +68,7 @@ public class PowerShareTile extends QSTileImpl<BooleanState>
         builder.setContentTitle(
                 mContext.getString(R.string.quick_settings_powershare_enabled_label));
         builder.setSmallIcon(R.drawable.ic_qs_powershare);
+        builder.setOnlyAlertOnce(true);
         mNotification = builder.build();
         mNotification.flags |= Notification.FLAG_NO_CLEAR | Notification.FLAG_ONGOING_EVENT;
         mNotification.visibility = Notification.VISIBILITY_PUBLIC;
",1,0,PowerShareTile::PowerShareTile
180,0edff236baa28df99695195f001ae5b56b598de9,SelectionActionModeHelper.java,ModificationType.MODIFY,"@@ -104,17 +104,44 @@ public final class SelectionActionModeHelper {
         }
     }
 
+    /**
+     * Swap the selection index if the start index is greater than end index.
+     *
+     * @return the swap result, index 0 is the start index and index 1 is the end index.
+     */
+    private static int[] sortSelctionIndices(int selectionStart, int selectionEnd) {
+        if (selectionStart < selectionEnd) {
+            return new int[]{selectionStart, selectionEnd};
+        }
+        return new int[]{selectionEnd, selectionStart};
+    }
+
+    /**
+     * The {@link TextView} selection start and end index may not be sorted, this method will swap
+     * the {@link TextView} selection index if the start index is greater than end index.
+     *
+     * @param textView the selected TextView.
+     * @return the swap result, index 0 is the start index and index 1 is the end index.
+     */
+    private static int[] sortSelctionIndicesFromTextView(TextView textView) {
+        int selectionStart = textView.getSelectionStart();
+        int selectionEnd = textView.getSelectionEnd();
+
+        return sortSelctionIndices(selectionStart, selectionEnd);
+    }
+
     /**
      * Starts Selection ActionMode.
      */
     public void startSelectionActionModeAsync(boolean adjustSelection) {
         // Check if the smart selection should run for editable text.
         adjustSelection &= getTextClassificationSettings().isSmartSelectionEnabled();
+        int[] sortedSelectionIndices = sortSelctionIndicesFromTextView(mTextView);
 
         mSelectionTracker.onOriginalSelection(
                 getText(mTextView),
-                mTextView.getSelectionStart(),
-                mTextView.getSelectionEnd(),
+                sortedSelectionIndices[0],
+                sortedSelectionIndices[1],
                 false /*isLink*/);
         cancelAsyncTask();
         if (skipTextClassification()) {
@@ -139,12 +166,14 @@ public final class SelectionActionModeHelper {
      * Starts Link ActionMode.
      */
     public void startLinkActionModeAsync(int start, int end) {
-        mSelectionTracker.onOriginalSelection(getText(mTextView), start, end, true /*isLink*/);
+        int[] indexResult = sortSelctionIndices(start, end);
+        mSelectionTracker.onOriginalSelection(getText(mTextView), indexResult[0], indexResult[1],
+                true /*isLink*/);
         cancelAsyncTask();
         if (skipTextClassification()) {
             startLinkActionMode(null);
         } else {
-            resetTextClassificationHelper(start, end);
+            resetTextClassificationHelper(indexResult[0], indexResult[1]);
             mTextClassificationAsyncTask = new TextClassificationAsyncTask(
                     mTextView,
                     mTextClassificationHelper.getTimeoutDuration(),
@@ -173,19 +202,23 @@ public final class SelectionActionModeHelper {
 
     /** Reports a selection action event. */
     public void onSelectionAction(int menuItemId, @Nullable String actionLabel) {
+        int[] sortedSelectionIndices = sortSelctionIndicesFromTextView(mTextView);
         mSelectionTracker.onSelectionAction(
-                mTextView.getSelectionStart(), mTextView.getSelectionEnd(),
+                sortedSelectionIndices[0], sortedSelectionIndices[1],
                 getActionType(menuItemId), actionLabel, mTextClassification);
     }
 
     public void onSelectionDrag() {
+        int[] sortedSelectionIndices = sortSelctionIndicesFromTextView(mTextView);
         mSelectionTracker.onSelectionAction(
-                mTextView.getSelectionStart(), mTextView.getSelectionEnd(),
+                sortedSelectionIndices[0], sortedSelectionIndices[1],
                 SelectionEvent.ACTION_DRAG, /* actionLabel= */ null, mTextClassification);
     }
 
     public void onTextChanged(int start, int end) {
-        mSelectionTracker.onTextChanged(start, end, mTextClassification);
+        int[] sortedSelectionIndices = sortSelctionIndices(start, end);
+        mSelectionTracker.onTextChanged(sortedSelectionIndices[0], sortedSelectionIndices[1],
+                mTextClassification);
     }
 
     public boolean resetSelection(int textIndex) {
@@ -302,9 +335,10 @@ public final class SelectionActionModeHelper {
             startSelectionActionMode(startSelectionResult);
         };
         // TODO do not trigger the animation if the change included only non-printable characters
+        int[] sortedSelectionIndices = sortSelctionIndicesFromTextView(mTextView);
         final boolean didSelectionChange =
-                result != null && (mTextView.getSelectionStart() != result.mStart
-                        || mTextView.getSelectionEnd() != result.mEnd);
+                result != null && (sortedSelectionIndices[0] != result.mStart
+                        || sortedSelectionIndices[1] != result.mEnd);
 
         if (!didSelectionChange) {
             onAnimationEndCallback.run();
@@ -454,16 +488,18 @@ public final class SelectionActionModeHelper {
         if (actionMode != null) {
             actionMode.invalidate();
         }
+        final int[] sortedSelectionIndices = sortSelctionIndicesFromTextView(mTextView);
         mSelectionTracker.onSelectionUpdated(
-                mTextView.getSelectionStart(), mTextView.getSelectionEnd(), mTextClassification);
+                sortedSelectionIndices[0], sortedSelectionIndices[1], mTextClassification);
         mTextClassificationAsyncTask = null;
     }
 
     private void resetTextClassificationHelper(int selectionStart, int selectionEnd) {
         if (selectionStart < 0 || selectionEnd < 0) {
             // Use selection indices
-            selectionStart = mTextView.getSelectionStart();
-            selectionEnd = mTextView.getSelectionEnd();
+            int[] sortedSelectionIndices = sortSelctionIndicesFromTextView(mTextView);
+            selectionStart = sortedSelectionIndices[0];
+            selectionEnd = sortedSelectionIndices[1];
         }
         mTextClassificationHelper.init(
                 mTextView::getTextClassifier,
@@ -603,10 +639,11 @@ public final class SelectionActionModeHelper {
                 mAllowReset = false;
                 boolean selected = editor.selectCurrentWord();
                 if (selected) {
-                    mSelectionStart = editor.getTextView().getSelectionStart();
-                    mSelectionEnd = editor.getTextView().getSelectionEnd();
+                    final int[] sortedSelectionIndices = sortSelctionIndicesFromTextView(textView);
+                    mSelectionStart = sortedSelectionIndices[0];
+                    mSelectionEnd = sortedSelectionIndices[1];
                     mLogger.logSelectionAction(
-                            textView.getSelectionStart(), textView.getSelectionEnd(),
+                            sortedSelectionIndices[0], sortedSelectionIndices[1],
                             SelectionEvent.ACTION_RESET,
                             /* actionLabel= */ null, /* classification= */ null);
                 }
@@ -1179,8 +1216,9 @@ public final class SelectionActionModeHelper {
 
         SelectionResult(int start, int end,
                 @Nullable TextClassification classification, @Nullable TextSelection selection) {
-            mStart = start;
-            mEnd = end;
+            int[] sortedIndices = sortSelctionIndices(start, end);
+            mStart = sortedIndices[0];
+            mEnd = sortedIndices[1];
             mClassification = classification;
             mSelection = selection;
         }
",55,17,"SelectionActionModeHelper::onSelectionDrag, SelectionActionModeHelper::startSelectionActionModeWithSmartSelectAnimation, SelectionActionModeHelper::resetTextClassificationHelper, SelectionActionModeHelper::sortSelctionIndicesFromTextView, SelectionActionModeHelper::onTextChanged, SelectionActionModeHelper::invalidateActionMode, SelectionActionModeHelper::SelectionTracker::resetSelection, SelectionActionModeHelper::onSelectionAction, SelectionActionModeHelper::startSelectionActionModeAsync, SelectionActionModeHelper::SelectionResult::SelectionResult, SelectionActionModeHelper::startLinkActionModeAsync, SelectionActionModeHelper::sortSelctionIndices"
181,325252f63e37e512a941e7dd25a56e02c2f3a84d,SelectionActionModeHelper.java,ModificationType.MODIFY,"@@ -109,7 +109,7 @@ public final class SelectionActionModeHelper {
      *
      * @return the swap result, index 0 is the start index and index 1 is the end index.
      */
-    private static int[] sortSelctionIndices(int selectionStart, int selectionEnd) {
+    private static int[] sortSelectionIndices(int selectionStart, int selectionEnd) {
         if (selectionStart < selectionEnd) {
             return new int[]{selectionStart, selectionEnd};
         }
@@ -123,11 +123,11 @@ public final class SelectionActionModeHelper {
      * @param textView the selected TextView.
      * @return the swap result, index 0 is the start index and index 1 is the end index.
      */
-    private static int[] sortSelctionIndicesFromTextView(TextView textView) {
+    private static int[] sortSelectionIndicesFromTextView(TextView textView) {
         int selectionStart = textView.getSelectionStart();
         int selectionEnd = textView.getSelectionEnd();
 
-        return sortSelctionIndices(selectionStart, selectionEnd);
+        return sortSelectionIndices(selectionStart, selectionEnd);
     }
 
     /**
@@ -136,7 +136,7 @@ public final class SelectionActionModeHelper {
     public void startSelectionActionModeAsync(boolean adjustSelection) {
         // Check if the smart selection should run for editable text.
         adjustSelection &= getTextClassificationSettings().isSmartSelectionEnabled();
-        int[] sortedSelectionIndices = sortSelctionIndicesFromTextView(mTextView);
+        int[] sortedSelectionIndices = sortSelectionIndicesFromTextView(mTextView);
 
         mSelectionTracker.onOriginalSelection(
                 getText(mTextView),
@@ -166,7 +166,7 @@ public final class SelectionActionModeHelper {
      * Starts Link ActionMode.
      */
     public void startLinkActionModeAsync(int start, int end) {
-        int[] indexResult = sortSelctionIndices(start, end);
+        int[] indexResult = sortSelectionIndices(start, end);
         mSelectionTracker.onOriginalSelection(getText(mTextView), indexResult[0], indexResult[1],
                 true /*isLink*/);
         cancelAsyncTask();
@@ -202,21 +202,21 @@ public final class SelectionActionModeHelper {
 
     /** Reports a selection action event. */
     public void onSelectionAction(int menuItemId, @Nullable String actionLabel) {
-        int[] sortedSelectionIndices = sortSelctionIndicesFromTextView(mTextView);
+        int[] sortedSelectionIndices = sortSelectionIndicesFromTextView(mTextView);
         mSelectionTracker.onSelectionAction(
                 sortedSelectionIndices[0], sortedSelectionIndices[1],
                 getActionType(menuItemId), actionLabel, mTextClassification);
     }
 
     public void onSelectionDrag() {
-        int[] sortedSelectionIndices = sortSelctionIndicesFromTextView(mTextView);
+        int[] sortedSelectionIndices = sortSelectionIndicesFromTextView(mTextView);
         mSelectionTracker.onSelectionAction(
                 sortedSelectionIndices[0], sortedSelectionIndices[1],
                 SelectionEvent.ACTION_DRAG, /* actionLabel= */ null, mTextClassification);
     }
 
     public void onTextChanged(int start, int end) {
-        int[] sortedSelectionIndices = sortSelctionIndices(start, end);
+        int[] sortedSelectionIndices = sortSelectionIndices(start, end);
         mSelectionTracker.onTextChanged(sortedSelectionIndices[0], sortedSelectionIndices[1],
                 mTextClassification);
     }
@@ -335,7 +335,7 @@ public final class SelectionActionModeHelper {
             startSelectionActionMode(startSelectionResult);
         };
         // TODO do not trigger the animation if the change included only non-printable characters
-        int[] sortedSelectionIndices = sortSelctionIndicesFromTextView(mTextView);
+        int[] sortedSelectionIndices = sortSelectionIndicesFromTextView(mTextView);
         final boolean didSelectionChange =
                 result != null && (sortedSelectionIndices[0] != result.mStart
                         || sortedSelectionIndices[1] != result.mEnd);
@@ -488,7 +488,7 @@ public final class SelectionActionModeHelper {
         if (actionMode != null) {
             actionMode.invalidate();
         }
-        final int[] sortedSelectionIndices = sortSelctionIndicesFromTextView(mTextView);
+        final int[] sortedSelectionIndices = sortSelectionIndicesFromTextView(mTextView);
         mSelectionTracker.onSelectionUpdated(
                 sortedSelectionIndices[0], sortedSelectionIndices[1], mTextClassification);
         mTextClassificationAsyncTask = null;
@@ -497,7 +497,7 @@ public final class SelectionActionModeHelper {
     private void resetTextClassificationHelper(int selectionStart, int selectionEnd) {
         if (selectionStart < 0 || selectionEnd < 0) {
             // Use selection indices
-            int[] sortedSelectionIndices = sortSelctionIndicesFromTextView(mTextView);
+            int[] sortedSelectionIndices = sortSelectionIndicesFromTextView(mTextView);
             selectionStart = sortedSelectionIndices[0];
             selectionEnd = sortedSelectionIndices[1];
         }
@@ -639,7 +639,7 @@ public final class SelectionActionModeHelper {
                 mAllowReset = false;
                 boolean selected = editor.selectCurrentWord();
                 if (selected) {
-                    final int[] sortedSelectionIndices = sortSelctionIndicesFromTextView(textView);
+                    final int[] sortedSelectionIndices = sortSelectionIndicesFromTextView(textView);
                     mSelectionStart = sortedSelectionIndices[0];
                     mSelectionEnd = sortedSelectionIndices[1];
                     mLogger.logSelectionAction(
@@ -1216,7 +1216,7 @@ public final class SelectionActionModeHelper {
 
         SelectionResult(int start, int end,
                 @Nullable TextClassification classification, @Nullable TextSelection selection) {
-            int[] sortedIndices = sortSelctionIndices(start, end);
+            int[] sortedIndices = sortSelectionIndices(start, end);
             mStart = sortedIndices[0];
             mEnd = sortedIndices[1];
             mClassification = classification;
",13,13,"SelectionActionModeHelper::sortSelectionIndicesFromTextView, SelectionActionModeHelper::onSelectionDrag, SelectionActionModeHelper::sortSelectionIndices, SelectionActionModeHelper::startSelectionActionModeWithSmartSelectAnimation, SelectionActionModeHelper::resetTextClassificationHelper, SelectionActionModeHelper::sortSelctionIndicesFromTextView, SelectionActionModeHelper::onTextChanged, SelectionActionModeHelper::invalidateActionMode, SelectionActionModeHelper::SelectionTracker::resetSelection, SelectionActionModeHelper::onSelectionAction, SelectionActionModeHelper::startSelectionActionModeAsync, SelectionActionModeHelper::SelectionResult::SelectionResult, SelectionActionModeHelper::startLinkActionModeAsync, SelectionActionModeHelper::sortSelctionIndices"
182,667910a42a3edf2ff505c77a16a9bed43241593e,NetworkPolicyManager.java,ModificationType.MODIFY,"@@ -63,6 +63,8 @@ public class NetworkPolicyManager {
     public static final int POLICY_REJECT_ON_VPN = 0x20000;
     /** Reject network usage on wifi network */
     public static final int POLICY_REJECT_ON_WLAN = 0x8000;
+    /** Reject network usage on all networks at all times */
+    public static final int POLICY_NETWORK_ISOLATED = 0x40000;
 
     /*
      * Rules defining whether an uid has access to a network given its type (metered / non-metered).
@@ -93,6 +95,8 @@ public class NetworkPolicyManager {
     public static final int RULE_ALLOW_ALL = 1 << 5;
     /** Reject traffic on all networks. */
     public static final int RULE_REJECT_ALL = 1 << 6;
+    /** Reject traffic on all networks at all times */
+    public static final int RULE_NETWORK_ISOLATED = 1 << 7;
     /** Mask used to get the {@code RULE_xxx_METERED} rules */
     public static final int MASK_METERED_NETWORKS = 0b00001111;
     /** Mask used to get the {@code RULE_xxx_ALL} rules */
@@ -104,6 +108,7 @@ public class NetworkPolicyManager {
     public static final String FIREWALL_CHAIN_NAME_DOZABLE = ""dozable"";
     public static final String FIREWALL_CHAIN_NAME_STANDBY = ""standby"";
     public static final String FIREWALL_CHAIN_NAME_POWERSAVE = ""powersave"";
+    public static final String FIREWALL_CHAIN_NAME_ISOLATED = ""isolated"";
 
     private static final boolean ALLOW_PLATFORM_APP_POLICY = true;
 
",5,0,
183,667910a42a3edf2ff505c77a16a9bed43241593e,ConnectivityService.java,ModificationType.MODIFY,"@@ -622,6 +622,15 @@ public class ConnectivityService extends IConnectivityManager.Stub
     @VisibleForTesting
     final MultipathPolicyTracker mMultipathPolicyTracker;
 
+    // Tracking for network isolated uids
+    //
+    @GuardedBy(""mIsolatedUids"")
+    private final SparseBooleanArray mIsolatedUids = new SparseBooleanArray();
+    // Network requests that are still active but will not receive any callbacks
+    // owing to the calling uid beging network isolated.  Only accessed on
+    // event handler thread so no locking necessary.
+    private final HashMap<NetworkRequest, NetworkRequestInfo> mDetachedRequests = new HashMap<>();
+
     /**
      * Implements support for the legacy ""one network per network type"" model.
      *
@@ -1248,6 +1257,10 @@ public class ConnectivityService extends IConnectivityManager.Stub
      */
     private boolean isNetworkWithLinkPropertiesBlocked(LinkProperties lp, int uid,
             boolean ignoreBlocked) {
+        // Network isolation should be checked first since it overrides ignore blocked status.
+        if (isUidIsolated(uid)) {
+            return true;
+        }
         // Networks aren't blocked when ignoring blocked status
         if (ignoreBlocked) {
             return false;
@@ -1417,6 +1430,11 @@ public class ConnectivityService extends IConnectivityManager.Stub
     @Override
     public NetworkInfo[] getAllNetworkInfo() {
         enforceAccessPermission();
+        if (isUidIsolated(Binder.getCallingUid())) {
+            // If a uid is network isolated, do not provide any visibility.
+            return new NetworkInfo[0];
+        }
+
         final ArrayList<NetworkInfo> result = Lists.newArrayList();
         for (int networkType = 0; networkType <= ConnectivityManager.MAX_NETWORK_TYPE;
                 networkType++) {
@@ -1442,6 +1460,10 @@ public class ConnectivityService extends IConnectivityManager.Stub
     @Override
     public Network[] getAllNetworks() {
         enforceAccessPermission();
+        if (isUidIsolated(Binder.getCallingUid())) {
+            // If a uid is network isolated, do not provide any visibility.
+            return new Network[0];
+        }
         synchronized (mNetworkForNetId) {
             final Network[] result = new Network[mNetworkForNetId.size()];
             for (int i = 0; i < mNetworkForNetId.size(); i++) {
@@ -1846,6 +1868,18 @@ public class ConnectivityService extends IConnectivityManager.Stub
         final int oldRules = mUidRules.get(uid, RULE_NONE);
         if (oldRules == newRules) return;
 
+        final boolean wasIsolated =
+                mPolicyManagerInternal.isNetworkingIsolatedByUidRules(oldRules);
+        final boolean isIsolated =
+                mPolicyManagerInternal.isNetworkingIsolatedByUidRules(newRules);
+        if (isIsolated != wasIsolated) {
+            if (isIsolated) {
+                setUidIsolated(uid);
+            } else {
+                clearUidIsolated(uid);
+            }
+        }
+
         maybeNotifyNetworkBlockedForNewUidRules(uid, newRules);
 
         if (newRules == RULE_NONE) {
@@ -1855,6 +1889,110 @@ public class ConnectivityService extends IConnectivityManager.Stub
         }
     }
 
+    private void setUidIsolated(int uid) {
+        synchronized (mIsolatedUids) {
+            mIsolatedUids.put(uid, true);
+        }
+        detachNetworkRequestsForUid(uid);
+    }
+
+    private void clearUidIsolated(int uid) {
+        synchronized (mIsolatedUids) {
+            mIsolatedUids.delete(uid);
+        }
+        reattachNetworkRequestsForUid(uid);
+    }
+
+    private boolean isUidIsolated(int uid) {
+        synchronized (mIsolatedUids) {
+            return mIsolatedUids.get(uid);
+        }
+    }
+
+    private void addDetachedRequest(NetworkRequestInfo nri) {
+        mDetachedRequests.put(nri.request, nri);
+    }
+
+    // App has died or callback is being unregistered, clean up.
+    // Match callback by PendingIntent.
+    private boolean removeDetachedNetworkRequests(PendingIntent pendingIntent, int uid) {
+        // Use same logic as findExistingNetworkRequestInfo()
+        Intent intent = pendingIntent.getIntent();
+        for (NetworkRequestInfo nri : mDetachedRequests.values()) {
+            PendingIntent existingPendingIntent = nri.mPendingIntent;
+            if (existingPendingIntent != null &&
+                    existingPendingIntent.getIntent().filterEquals(intent)) {
+                return removeDetachedNetworkRequests(nri, uid);
+            }
+        }
+        return false;
+    }
+
+    // App has died or callback is being unregistered, clean up.
+    // Match callback by NetworkRequest.
+    private boolean removeDetachedNetworkRequests(NetworkRequest request, int uid) {
+        return removeDetachedNetworkRequests(mDetachedRequests.get(request), uid);
+    }
+
+    private boolean removeDetachedNetworkRequests(NetworkRequestInfo nri, int uid) {
+        // binderDied() runs as system uid so allow clean up
+        if (nri != null && (nri.mUid == uid || uid == Process.SYSTEM_UID)) {
+            nri.unlinkDeathRecipient();
+            mDetachedRequests.remove(nri.request);
+            return true;
+        }
+        return false;
+    }
+
+    private void detachNetworkRequestsForUid(int uid) {
+        // Collect network requests for this uid
+        final List<NetworkRequestInfo> nriList = new ArrayList<>();
+        for (NetworkRequestInfo nri : mNetworkRequests.values()) {
+            if (nri != null && nri.mUid == uid) {
+                nriList.add(nri);
+            }
+        }
+        for (NetworkRequestInfo nri : nriList) {
+            if (VDBG || DDBG) {
+                Log.d(TAG, ""detaching request "" + nri);
+            }
+
+            // Trigger onLost callbacks for matching networks
+            for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
+                if (nai.isSatisfyingRequest(nri.request.requestId)) {
+                    if (VDBG || DDBG) {
+                        Log.d(TAG, ""sending onLost to "" + nri + "" for "" + nai);
+                    }
+                    callCallbackForRequest(nri, nai, ConnectivityManager.CALLBACK_LOST, 0);
+                }
+            }
+            // Remove the request from normal ConnectivityService machinery.
+            // This prevents receiving any further callbacks.
+            handleRemoveNetworkRequest(nri);
+            // Go through nri constructor to reinitialize things cleaned up
+            // by handleRemoveNetworkRequest().   eg updating per uid
+            // reference counts and setting binder linkToDeath.
+            mDetachedRequests.put(nri.request, new NetworkRequestInfo(nri));
+        }
+    }
+
+    private void reattachNetworkRequestsForUid(int uid) {
+        // Collect network requests for this uid
+        final List<NetworkRequestInfo> nriList = new ArrayList<>();
+        for (NetworkRequestInfo nri : mDetachedRequests.values()) {
+            if (nri != null && nri.mUid == uid) {
+                nriList.add(nri);
+            }
+        }
+        for (NetworkRequestInfo nri : nriList) {
+            if (VDBG || DDBG) {
+                Log.d(TAG, ""reattaching request "" + nri);
+            }
+            mDetachedRequests.remove(nri.request);
+            handleRegisterNetworkRequest(nri);
+        }
+    }
+
     void handleRestrictBackgroundChanged(boolean restrictBackground) {
         if (mRestrictBackground == restrictBackground) return;
 
@@ -3131,11 +3269,18 @@ public class ConnectivityService extends IConnectivityManager.Stub
                     + nri.request + "" because their intents matched."");
             handleReleaseNetworkRequest(existingRequest.request, getCallingUid(),
                     /* callOnUnavailable */ false);
+        } else {
+            // Remove anything on the detached list
+            removeDetachedNetworkRequests(nri.mPendingIntent, Binder.getCallingUid());
         }
         handleRegisterNetworkRequest(nri);
     }
 
     private void handleRegisterNetworkRequest(NetworkRequestInfo nri) {
+        if (isUidIsolated(nri.mUid)) {
+            addDetachedRequest(nri);
+            return;
+        }
         mNetworkRequests.put(nri.request, nri);
         mNetworkRequestInfoLogs.log(""REGISTER "" + nri);
         if (nri.request.isListen()) {
@@ -3154,6 +3299,10 @@ public class ConnectivityService extends IConnectivityManager.Stub
 
     private void handleReleaseNetworkRequestWithIntent(PendingIntent pendingIntent,
             int callingUid) {
+        if (removeDetachedNetworkRequests(pendingIntent, callingUid)) {
+            // Was already released during detach so nothing further to do.
+            return;
+        }
         NetworkRequestInfo nri = findExistingNetworkRequestInfo(pendingIntent);
         if (nri != null) {
             handleReleaseNetworkRequest(nri.request, callingUid, /* callOnUnavailable */ false);
@@ -3241,6 +3390,14 @@ public class ConnectivityService extends IConnectivityManager.Stub
 
     private void handleReleaseNetworkRequest(NetworkRequest request, int callingUid,
             boolean callOnUnavailable) {
+        if (removeDetachedNetworkRequests(request, callingUid)) {
+            // Was already released during detach so nothing further to do.
+            if (VDBG || DDBG) {
+                Log.d(TAG, ""removed detached request = "" + request + "" uid = "" + callingUid);
+            }
+            return;
+        }
+
         final NetworkRequestInfo nri =
                 getNriForAppRequest(request, callingUid, ""release NetworkRequest"");
         if (nri == null) {
@@ -5038,6 +5195,25 @@ public class ConnectivityService extends IConnectivityManager.Stub
             }
         }
 
+        // Recreate new from a previously detached request.
+        NetworkRequestInfo(NetworkRequestInfo nri) {
+            request = nri.request;
+            messenger = nri.messenger;
+            mBinder = nri.mBinder;
+            mPendingIntent = nri.mPendingIntent;
+            mPid = nri.mPid;
+            mUid = nri.mUid;
+            enforceRequestCountLimit();
+
+            if (mBinder != null) {
+                try {
+                    mBinder.linkToDeath(this, 0);
+                } catch (RemoteException e) {
+                    binderDied();
+                }
+            }
+        }
+
         private void enforceRequestCountLimit() {
             synchronized (mUidToNetworkRequestCount) {
                 int networkRequests = mUidToNetworkRequestCount.get(mUid, 0) + 1;
",176,0,"ConnectivityService::detachNetworkRequestsForUid, ConnectivityService::getAllNetworkInfo, ConnectivityService::removeDetachedNetworkRequests, ConnectivityService::handleReleaseNetworkRequestWithIntent, ConnectivityService::reattachNetworkRequestsForUid, ConnectivityService::getAllNetworks, ConnectivityService::handleUidRulesChanged, ConnectivityService::clearUidIsolated, ConnectivityService::NetworkRequestInfo::NetworkRequestInfo, ConnectivityService::handleRegisterNetworkRequest, ConnectivityService::removeDetachedNetworkRequests, ConnectivityService::handleReleaseNetworkRequest, ConnectivityService::isNetworkWithLinkPropertiesBlocked, ConnectivityService::setUidIsolated, ConnectivityService::isUidIsolated, ConnectivityService::handleRegisterNetworkRequestWithIntent, ConnectivityService::removeDetachedNetworkRequests, ConnectivityService::addDetachedRequest"
184,667910a42a3edf2ff505c77a16a9bed43241593e,NetworkManagementService.java,ModificationType.MODIFY,"@@ -22,6 +22,7 @@ import static android.Manifest.permission.NETWORK_STACK;
 import static android.Manifest.permission.SHUTDOWN;
 import static android.net.INetd.FIREWALL_BLACKLIST;
 import static android.net.INetd.FIREWALL_CHAIN_DOZABLE;
+import static android.net.INetd.FIREWALL_CHAIN_ISOLATED;
 import static android.net.INetd.FIREWALL_CHAIN_NONE;
 import static android.net.INetd.FIREWALL_CHAIN_POWERSAVE;
 import static android.net.INetd.FIREWALL_CHAIN_STANDBY;
@@ -29,6 +30,7 @@ import static android.net.INetd.FIREWALL_RULE_ALLOW;
 import static android.net.INetd.FIREWALL_RULE_DENY;
 import static android.net.INetd.FIREWALL_WHITELIST;
 import static android.net.NetworkPolicyManager.FIREWALL_CHAIN_NAME_DOZABLE;
+import static android.net.NetworkPolicyManager.FIREWALL_CHAIN_NAME_ISOLATED;
 import static android.net.NetworkPolicyManager.FIREWALL_CHAIN_NAME_POWERSAVE;
 import static android.net.NetworkPolicyManager.FIREWALL_CHAIN_NAME_STANDBY;
 import static android.net.NetworkPolicyManager.FIREWALL_RULE_DEFAULT;
@@ -219,6 +221,12 @@ public class NetworkManagementService extends INetworkManagementService.Stub {
      */
     @GuardedBy(""mRulesLock"")
     private SparseIntArray mUidFirewallPowerSaveRules = new SparseIntArray();
+    /**
+     * Set of UIDs that are to be blocked/allowed by firewall controller.  This set of Ids matches
+     * unconditionally at all times.
+     */
+    @GuardedBy(""mRulesLock"")
+    private SparseIntArray mUidFirewallIsolatedRules = new SparseIntArray();
     /** Set of states for the child firewall chains. True if the chain is active. */
     @GuardedBy(""mRulesLock"")
     final SparseBooleanArray mFirewallChainStates = new SparseBooleanArray();
@@ -714,9 +722,11 @@ public class NetworkManagementService extends INetworkManagementService.Stub {
             syncFirewallChainLocked(FIREWALL_CHAIN_STANDBY, ""standby "");
             syncFirewallChainLocked(FIREWALL_CHAIN_DOZABLE, ""dozable "");
             syncFirewallChainLocked(FIREWALL_CHAIN_POWERSAVE, ""powersave "");
+            syncFirewallChainLocked(FIREWALL_CHAIN_ISOLATED, ""isolated "");
 
             final int[] chains =
-                    {FIREWALL_CHAIN_STANDBY, FIREWALL_CHAIN_DOZABLE, FIREWALL_CHAIN_POWERSAVE};
+                    {FIREWALL_CHAIN_STANDBY, FIREWALL_CHAIN_DOZABLE, FIREWALL_CHAIN_POWERSAVE,
+                    FIREWALL_CHAIN_ISOLATED};
             for (int chain : chains) {
                 if (getFirewallChainState(chain)) {
                     setFirewallChainEnabled(chain, true);
@@ -1974,6 +1984,8 @@ public class NetworkManagementService extends INetworkManagementService.Stub {
                 return FIREWALL_CHAIN_NAME_DOZABLE;
             case FIREWALL_CHAIN_POWERSAVE:
                 return FIREWALL_CHAIN_NAME_POWERSAVE;
+            case FIREWALL_CHAIN_ISOLATED:
+                return FIREWALL_CHAIN_NAME_ISOLATED;
             default:
                 throw new IllegalArgumentException(""Bad child chain: "" + chain);
         }
@@ -1987,6 +1999,8 @@ public class NetworkManagementService extends INetworkManagementService.Stub {
                 return FIREWALL_WHITELIST;
             case FIREWALL_CHAIN_POWERSAVE:
                 return FIREWALL_WHITELIST;
+            case FIREWALL_CHAIN_ISOLATED:
+                return FIREWALL_BLACKLIST;
             default:
                 return isFirewallEnabled() ? FIREWALL_WHITELIST : FIREWALL_BLACKLIST;
         }
@@ -2031,6 +2045,9 @@ public class NetworkManagementService extends INetworkManagementService.Stub {
                     case FIREWALL_CHAIN_POWERSAVE:
                         mNetdService.firewallReplaceUidChain(""fw_powersave"", true, uids);
                         break;
+                    case FIREWALL_CHAIN_ISOLATED:
+                        mNetdService.firewallReplaceUidChain(""fw_isolated"", false, uids);
+                        break;
                     case FIREWALL_CHAIN_NONE:
                     default:
                         Slog.d(TAG, ""setFirewallUidRules() called on invalid chain: "" + chain);
@@ -2115,6 +2132,8 @@ public class NetworkManagementService extends INetworkManagementService.Stub {
                 return mUidFirewallDozableRules;
             case FIREWALL_CHAIN_POWERSAVE:
                 return mUidFirewallPowerSaveRules;
+            case FIREWALL_CHAIN_ISOLATED:
+                return mUidFirewallIsolatedRules;
             case FIREWALL_CHAIN_NONE:
                 return mUidFirewallRules;
             default:
@@ -2200,6 +2219,10 @@ public class NetworkManagementService extends INetworkManagementService.Stub {
             pw.println(""UID firewall powersave chain enabled: "" +
                     getFirewallChainState(FIREWALL_CHAIN_POWERSAVE));
             dumpUidFirewallRule(pw, FIREWALL_CHAIN_NAME_POWERSAVE, mUidFirewallPowerSaveRules);
+
+            pw.println(""UID firewall isolated chain enabled: "" +
+                    getFirewallChainState(FIREWALL_CHAIN_ISOLATED));
+            dumpUidFirewallRule(pw, FIREWALL_CHAIN_NAME_ISOLATED, mUidFirewallIsolatedRules);
         }
 
         synchronized (mIdleTimerLock) {
@@ -2395,6 +2418,11 @@ public class NetworkManagementService extends INetworkManagementService.Stub {
 
     private boolean isNetworkRestrictedInternal(int uid) {
         synchronized (mRulesLock) {
+            if (getFirewallChainState(FIREWALL_CHAIN_ISOLATED)
+                    && mUidFirewallIsolatedRules.get(uid) == FIREWALL_RULE_DENY) {
+                if (DBG) Slog.d(TAG, ""Uid "" + uid + "" restricted because of isolated mode"");
+                return true;
+            }
             if (getFirewallChainState(FIREWALL_CHAIN_STANDBY)
                     && mUidFirewallStandbyRules.get(uid) == FIREWALL_RULE_DENY) {
                 if (DBG) Slog.d(TAG, ""Uid "" + uid + "" restricted because of app standby mode"");
@@ -2480,7 +2508,8 @@ public class NetworkManagementService extends INetworkManagementService.Stub {
                 final int[] chains = {
                         FIREWALL_CHAIN_DOZABLE,
                         FIREWALL_CHAIN_STANDBY,
-                        FIREWALL_CHAIN_POWERSAVE
+                        FIREWALL_CHAIN_POWERSAVE,
+                        FIREWALL_CHAIN_ISOLATED
                 };
                 for (int chain : chains) {
                     setFirewallChainState(chain, false);
",31,2,"NetworkManagementService::prepareNativeDaemon, NetworkManagementService::getUidFirewallRulesLR, NetworkManagementService::dump, NetworkManagementService::isNetworkRestrictedInternal, NetworkManagementService::Injector::reset, NetworkManagementService::setFirewallUidRules, NetworkManagementService::getFirewallChainName, NetworkManagementService::getFirewallType"
185,667910a42a3edf2ff505c77a16a9bed43241593e,NetworkPolicyLogger.java,ModificationType.MODIFY,"@@ -16,11 +16,13 @@
 package com.android.server.net;
 
 import static android.net.INetd.FIREWALL_CHAIN_DOZABLE;
+import static android.net.INetd.FIREWALL_CHAIN_ISOLATED;
 import static android.net.INetd.FIREWALL_CHAIN_POWERSAVE;
 import static android.net.INetd.FIREWALL_CHAIN_STANDBY;
 import static android.net.INetd.FIREWALL_RULE_ALLOW;
 import static android.net.INetd.FIREWALL_RULE_DENY;
 import static android.net.NetworkPolicyManager.FIREWALL_CHAIN_NAME_DOZABLE;
+import static android.net.NetworkPolicyManager.FIREWALL_CHAIN_NAME_ISOLATED;
 import static android.net.NetworkPolicyManager.FIREWALL_CHAIN_NAME_POWERSAVE;
 import static android.net.NetworkPolicyManager.FIREWALL_CHAIN_NAME_STANDBY;
 import static android.net.NetworkPolicyManager.FIREWALL_RULE_DEFAULT;
@@ -74,6 +76,7 @@ public class NetworkPolicyLogger {
     static final int NTWK_BLOCKED_BG_RESTRICT = 5;
     static final int NTWK_ALLOWED_DEFAULT = 6;
     static final int NTWK_ALLOWED_SYSTEM = 7;
+    static final int NTWK_BLOCKED_ISOLATED = 8;
 
     private final LogBuffer mNetworkBlockedBuffer = new LogBuffer(MAX_NETWORK_BLOCKED_LOG_SIZE);
     private final LogBuffer mUidStateChangeBuffer = new LogBuffer(MAX_LOG_SIZE);
@@ -236,6 +239,8 @@ public class NetworkPolicyLogger {
                 return ""blocked when background is restricted"";
             case NTWK_ALLOWED_DEFAULT:
                 return ""allowed by default"";
+            case NTWK_BLOCKED_ISOLATED:
+                return ""blocked by isolation"";
             default:
                 return String.valueOf(reason);
         }
@@ -296,6 +301,8 @@ public class NetworkPolicyLogger {
                 return FIREWALL_CHAIN_NAME_STANDBY;
             case FIREWALL_CHAIN_POWERSAVE:
                 return FIREWALL_CHAIN_NAME_POWERSAVE;
+            case FIREWALL_CHAIN_ISOLATED:
+                return FIREWALL_CHAIN_NAME_ISOLATED;
             default:
                 return String.valueOf(chain);
         }
",7,0,"NetworkPolicyLogger::getBlockedReason, NetworkPolicyLogger::getFirewallChainName"
186,667910a42a3edf2ff505c77a16a9bed43241593e,NetworkPolicyManagerInternal.java,ModificationType.MODIFY,"@@ -41,6 +41,11 @@ public abstract class NetworkPolicyManagerInternal {
      */
     public abstract boolean isUidRestrictedOnMeteredNetworks(int uid);
 
+    /**
+     * @return true if the uid rules provided mean that network access should be blocked.
+     */
+    public abstract boolean isNetworkingIsolatedByUidRules(int uidRules);
+
     /**
      * @return true if networking is blocked on the given interface for the given uid according
      * to current networking policies.
",5,0,
187,667910a42a3edf2ff505c77a16a9bed43241593e,NetworkPolicyManagerService.java,ModificationType.MODIFY,"@@ -39,6 +39,7 @@ import static android.net.ConnectivityManager.RESTRICT_BACKGROUND_STATUS_ENABLED
 import static android.net.ConnectivityManager.RESTRICT_BACKGROUND_STATUS_WHITELISTED;
 import static android.net.ConnectivityManager.TYPE_MOBILE;
 import static android.net.INetd.FIREWALL_CHAIN_DOZABLE;
+import static android.net.INetd.FIREWALL_CHAIN_ISOLATED;
 import static android.net.INetd.FIREWALL_CHAIN_POWERSAVE;
 import static android.net.INetd.FIREWALL_CHAIN_STANDBY;
 import static android.net.INetd.FIREWALL_RULE_ALLOW;
@@ -54,6 +55,7 @@ import static android.net.NetworkPolicyManager.FIREWALL_RULE_DEFAULT;
 import static android.net.NetworkPolicyManager.MASK_ALL_NETWORKS;
 import static android.net.NetworkPolicyManager.MASK_METERED_NETWORKS;
 import static android.net.NetworkPolicyManager.POLICY_ALLOW_METERED_BACKGROUND;
+import static android.net.NetworkPolicyManager.POLICY_NETWORK_ISOLATED;
 import static android.net.NetworkPolicyManager.POLICY_NONE;
 import static android.net.NetworkPolicyManager.POLICY_REJECT_METERED_BACKGROUND;
 import static android.net.NetworkPolicyManager.POLICY_REJECT_ON_DATA;
@@ -61,6 +63,7 @@ import static android.net.NetworkPolicyManager.POLICY_REJECT_ON_VPN;
 import static android.net.NetworkPolicyManager.POLICY_REJECT_ON_WLAN;
 import static android.net.NetworkPolicyManager.RULE_ALLOW_ALL;
 import static android.net.NetworkPolicyManager.RULE_ALLOW_METERED;
+import static android.net.NetworkPolicyManager.RULE_NETWORK_ISOLATED;
 import static android.net.NetworkPolicyManager.RULE_NONE;
 import static android.net.NetworkPolicyManager.RULE_REJECT_ALL;
 import static android.net.NetworkPolicyManager.RULE_REJECT_METERED;
@@ -107,6 +110,7 @@ import static com.android.server.net.NetworkPolicyLogger.NTWK_ALLOWED_TMP_WHITEL
 import static com.android.server.net.NetworkPolicyLogger.NTWK_ALLOWED_WHITELIST;
 import static com.android.server.net.NetworkPolicyLogger.NTWK_BLOCKED_BG_RESTRICT;
 import static com.android.server.net.NetworkPolicyLogger.NTWK_BLOCKED_BLACKLIST;
+import static com.android.server.net.NetworkPolicyLogger.NTWK_BLOCKED_ISOLATED;
 import static com.android.server.net.NetworkPolicyLogger.NTWK_BLOCKED_POWER;
 import static com.android.server.net.NetworkStatsService.ACTION_NETWORK_STATS_UPDATED;
 
@@ -462,6 +466,8 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {
     final SparseIntArray mUidFirewallDozableRules = new SparseIntArray();
     @GuardedBy(""mUidRulesFirstLock"")
     final SparseIntArray mUidFirewallPowerSaveRules = new SparseIntArray();
+    @GuardedBy(""mUidRulesFirstLock"")
+    final SparseIntArray mUidFirewallIsolatedRules = new SparseIntArray();
 
     /** Set of states for the child firewall chains. True if the chain is active. */
     @GuardedBy(""mUidRulesFirstLock"")
@@ -804,6 +810,8 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {
                     setRestrictBackgroundUL(mLoadedRestrictBackground);
                     updateRulesForGlobalChangeAL(false);
                     updateNotificationsNL();
+                    // Enable the network isolated blacklist chain
+                    enableFirewallChainUL(FIREWALL_CHAIN_ISOLATED, true);
                 }
             }
 
@@ -2545,6 +2553,11 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {
         if (!UserHandle.isApp(uid)) {
             throw new IllegalArgumentException(""cannot apply policy to UID "" + uid);
         }
+
+        if (LOGD) {
+            Log.d(TAG, ""setUidPolicy: uid = "" + uid + "" policy = "" + policy);
+        }
+
         synchronized (mUidRulesFirstLock) {
             final long token = Binder.clearCallingIdentity();
             try {
@@ -2567,6 +2580,10 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {
             throw new IllegalArgumentException(""cannot apply policy to UID "" + uid);
         }
 
+        if (LOGD) {
+            Log.d(TAG, ""addUidPolicy: uid = "" + uid + "" policy = "" + policy);
+        }
+
         synchronized (mUidRulesFirstLock) {
             final int oldPolicy = mUidPolicy.get(uid, POLICY_NONE);
             policy |= oldPolicy;
@@ -2585,6 +2602,10 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {
             throw new IllegalArgumentException(""cannot apply policy to UID "" + uid);
         }
 
+        if (LOGD) {
+            Log.d(TAG, ""removeUidPolicy: uid = "" + uid + "" policy = "" + policy);
+        }
+
         synchronized (mUidRulesFirstLock) {
             final int oldPolicy = mUidPolicy.get(uid, POLICY_NONE);
             policy = oldPolicy & ~policy;
@@ -2637,6 +2658,7 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {
 
         // uid policy changed, recompute rules and persist policy.
         updateRulesForDataUsageRestrictionsUL(uid);
+        updateRulesForIsolatedUL(uid);
         if (persist) {
             synchronized (mNetworkPoliciesSecondLock) {
                 writePolicyAL();
@@ -4115,6 +4137,7 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {
         mUidFirewallStandbyRules.delete(uid);
         mUidFirewallDozableRules.delete(uid);
         mUidFirewallPowerSaveRules.delete(uid);
+        mUidFirewallIsolatedRules.delete(uid);
         mPowerSaveWhitelistExceptIdleAppIds.delete(uid);
         mPowerSaveWhitelistAppIds.delete(uid);
         mPowerSaveTempWhitelistAppIds.delete(uid);
@@ -4321,6 +4344,37 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {
         }
     }
 
+    private void updateRulesForIsolatedUL(int uid) {
+        final int uidPolicy = mUidPolicy.get(uid, POLICY_NONE);
+        final int oldUidRules = mUidRules.get(uid, RULE_NONE);
+        final boolean wasIsolated = (oldUidRules & RULE_NETWORK_ISOLATED) != 0;
+        final boolean isIsolated = (uidPolicy & POLICY_NETWORK_ISOLATED) != 0;
+
+        if (isIsolated == wasIsolated) {
+            // No change
+            return;
+        }
+
+        setUidFirewallRule(FIREWALL_CHAIN_ISOLATED, uid,
+                isIsolated ? FIREWALL_RULE_DENY : FIREWALL_RULE_DEFAULT);
+
+        int uidRules = oldUidRules;
+        if (isIsolated) {
+            uidRules |= RULE_NETWORK_ISOLATED;
+        } else {
+            uidRules &= ~RULE_NETWORK_ISOLATED;
+        }
+
+        if (uidRules == RULE_NONE) {
+            mUidRules.delete(uid);
+        } else {
+            mUidRules.put(uid, uidRules);
+        }
+
+        // Dispatch changed rule to existing listeners.
+        mHandler.obtainMessage(MSG_RULES_CHANGED, uid, uidRules).sendToTarget();
+    }
+
     /**
      * Updates the power-related part of the {@link #mUidRules} for a given map, and notify external
      * listeners in case of change.
@@ -4400,7 +4454,10 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {
             newRule = isWhitelisted ? RULE_ALLOW_ALL : RULE_REJECT_ALL;
         }
 
-        final int newUidRules = (oldUidRules & MASK_METERED_NETWORKS) | newRule;
+        // Generate new uid rules, ensuring we persist any existing
+        // metered networks and network isolated rules.
+        final int newUidRules = (oldUidRules
+                & (MASK_METERED_NETWORKS | RULE_NETWORK_ISOLATED)) | newRule;
 
         if (LOGV) {
             Log.v(TAG, ""updateRulesForPowerRestrictionsUL("" + uid + "")""
@@ -4857,6 +4914,8 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {
                 mUidFirewallStandbyRules.put(uid, rule);
             } else if (chain == FIREWALL_CHAIN_POWERSAVE) {
                 mUidFirewallPowerSaveRules.put(uid, rule);
+            } else if (chain == FIREWALL_CHAIN_ISOLATED) {
+                mUidFirewallIsolatedRules.put(uid, rule);
             }
 
             try {
@@ -4902,6 +4961,7 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {
             mNetworkManager.setFirewallUidRule(FIREWALL_CHAIN_STANDBY, uid, FIREWALL_RULE_DEFAULT);
             mNetworkManager
                     .setFirewallUidRule(FIREWALL_CHAIN_POWERSAVE, uid, FIREWALL_RULE_DEFAULT);
+            mNetworkManager.setFirewallUidRule(FIREWALL_CHAIN_ISOLATED, uid, FIREWALL_RULE_DEFAULT);
             mNetworkManager.setUidMeteredNetworkWhitelist(uid, false);
             mNetworkManager.setUidMeteredNetworkBlacklist(uid, false);
         } catch (IllegalStateException e) {
@@ -5085,6 +5145,9 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {
         if (isSystem(uid)) {
             reason = NTWK_ALLOWED_SYSTEM;
         }
+        else if (hasRule(uidRules, RULE_NETWORK_ISOLATED)) {
+            reason = NTWK_BLOCKED_ISOLATED;
+        }
         else if (hasRule(uidRules, RULE_REJECT_ALL)) {
             reason = NTWK_BLOCKED_POWER;
         }
@@ -5119,6 +5182,7 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {
             case NTWK_BLOCKED_POWER:
             case NTWK_BLOCKED_BLACKLIST:
             case NTWK_BLOCKED_BG_RESTRICT:
+            case NTWK_BLOCKED_ISOLATED:
                 blocked = true;
                 break;
             default:
@@ -5188,6 +5252,11 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {
             return ret;
         }
 
+        @Override
+        public boolean isNetworkingIsolatedByUidRules(int uidRules) {
+            return hasRule(uidRules, RULE_NETWORK_ISOLATED);
+        }
+
         @Override
         public void onTempPowerSaveWhitelistChange(int appId, boolean added) {
             synchronized (mUidRulesFirstLock) {
",70,1,"NetworkPolicyManagerService::setUidPolicyUncheckedUL, NetworkPolicyManagerService::updateRulesForIsolatedUL, NetworkPolicyManagerService::initService, NetworkPolicyManagerService::addUidPolicy, NetworkPolicyManagerService::onUidDeletedUL, NetworkPolicyManagerService::isUidNetworkingBlockedInternal, NetworkPolicyManagerService::setUidPolicy, NetworkPolicyManagerService::NetworkPolicyManagerInternalImpl::isNetworkingIsolatedByUidRules, NetworkPolicyManagerService::setUidFirewallRule, NetworkPolicyManagerService::updateRulesForPowerRestrictionsULInner, NetworkPolicyManagerService::resetUidFirewallRules, NetworkPolicyManagerService::removeUidPolicy"
188,afd45f53c68a3e7ef17e9e7964df6d5871e90e9e,NotificationPanelView.java,ModificationType.MODIFY,"@@ -1270,7 +1270,8 @@ public class NotificationPanelView extends PanelView implements
             return false;
         }
 
-        if (mDoubleTapToSleepEnabled && mBarState == StatusBarState.KEYGUARD) {
+        if (mDoubleTapToSleepEnabled && mBarState == StatusBarState.KEYGUARD
+                && !mPulsing && !mDozing) {
             mDoubleTapGesture.onTouchEvent(event);
         }
 
",2,1,NotificationPanelView::onTouchEvent
189,afd45f53c68a3e7ef17e9e7964df6d5871e90e9e,StatusBarWindowView.java,ModificationType.MODIFY,"@@ -119,6 +119,8 @@ public class StatusBarWindowView extends FrameLayout {
     private boolean mExpandAnimationPending;
     private boolean mSuppressingWakeUpGesture;
 
+    private boolean mDoubleTapEnabledNative;
+
     private final GestureDetector.SimpleOnGestureListener mGestureListener =
             new GestureDetector.SimpleOnGestureListener() {
         @Override
@@ -141,7 +143,7 @@ public class StatusBarWindowView extends FrameLayout {
                 }
                 return true;
             }
-            if (mDoubleTapEnabled || mSingleTapEnabled) {
+            if (mDoubleTapEnabled || mSingleTapEnabled || mDoubleTapEnabledNative) {
                 mService.wakeUpIfDozing(SystemClock.uptimeMillis(), StatusBarWindowView.this,
                         ""DOUBLE_TAP"");
                 return true;
@@ -152,6 +154,9 @@ public class StatusBarWindowView extends FrameLayout {
     private final TunerService.Tunable mTunable = (key, newValue) -> {
         AmbientDisplayConfiguration configuration = new AmbientDisplayConfiguration(mContext);
         switch (key) {
+            case Settings.Secure.DOUBLE_TAP_TO_WAKE:
+                mDoubleTapEnabledNative = TunerService.parseIntegerSwitch(newValue, false);
+                break;
             case Settings.Secure.DOZE_DOUBLE_TAP_GESTURE:
                 mDoubleTapEnabled = configuration.doubleTapGestureEnabled(UserHandle.USER_CURRENT);
                 break;
@@ -180,6 +185,7 @@ public class StatusBarWindowView extends FrameLayout {
         mGestureDetector = new GestureDetector(context, mGestureListener);
         mStatusBarStateController = Dependency.get(StatusBarStateController.class);
         Dependency.get(TunerService.class).addTunable(mTunable,
+                Settings.Secure.DOUBLE_TAP_TO_WAKE,
                 Settings.Secure.DOZE_DOUBLE_TAP_GESTURE,
                 Settings.Secure.DOZE_TAP_SCREEN_GESTURE,
                 DOUBLE_TAP_SLEEP_GESTURE);
",7,1,"StatusBarWindowView::switch, StatusBarWindowView::SimpleOnGestureListener, StatusBarWindowView::StatusBarWindowView"
190,1df153ad281eae69590ae94a919afc74d32ed59d,Zygote.java,ModificationType.MODIFY,"@@ -49,9 +49,9 @@ import java.io.InputStreamReader;
 /** @hide */
 public final class Zygote {
     /*
-    * Bit values for ""runtimeFlags"" argument.  The definitions are duplicated
-    * in the native code.
-    */
+     * Bit values for ""runtimeFlags"" argument.  The definitions are duplicated
+     * in the native code.
+     */
 
     /** enable debugging over JDWP */
     public static final int DEBUG_ENABLE_JDWP   = 1;
@@ -283,7 +283,7 @@ public final class Zygote {
             int[][] rlimits, int mountExternal, String seInfo, String niceName,
             boolean startChildZygote, String instructionSet, String appDataDir) {
         nativeSpecializeAppProcess(uid, gid, gids, runtimeFlags, rlimits, mountExternal, seInfo,
-                                 niceName, startChildZygote, instructionSet, appDataDir);
+                niceName, startChildZygote, instructionSet, appDataDir);
 
         // Enable tracing as soon as possible for the child process.
         Trace.setTracingEnabled(true, runtimeFlags);
@@ -467,7 +467,7 @@ public final class Zygote {
      *         application that is passed up from usapMain.
      */
     static Runnable forkUsap(LocalServerSocket usapPoolSocket,
-                             int[] sessionSocketRawFDs) {
+            int[] sessionSocketRawFDs) {
         FileDescriptor[] pipeFDs = null;
 
         try {
@@ -491,8 +491,8 @@ public final class Zygote {
     }
 
     private static native int nativeForkUsap(int readPipeFD,
-                                                 int writePipeFD,
-                                                 int[] sessionSocketRawFDs);
+            int writePipeFD,
+            int[] sessionSocketRawFDs);
 
     /**
      * This function is used by unspecialized app processes to wait for specialization requests from
@@ -503,7 +503,7 @@ public final class Zygote {
      * @return A runnable oject representing the new application.
      */
     private static Runnable usapMain(LocalServerSocket usapPoolSocket,
-                                     FileDescriptor writePipe) {
+            FileDescriptor writePipe) {
         final int pid = Process.myPid();
         Process.setArgV0(Process.is64Bit() ? ""usap64"" : ""usap32"");
 
@@ -553,6 +553,7 @@ public final class Zygote {
         try {
             // SIGTERM is blocked on loop exit.  This prevents a USAP that is specializing from
             // being killed during a pool flush.
+            setAppProcessName(args, ""USAP"");
 
             applyUidSecurityPolicy(args, peerCredentials);
             applyDebuggerSystemProperty(args);
@@ -613,22 +614,18 @@ public final class Zygote {
             }
 
             specializeAppProcess(args.mUid, args.mGid, args.mGids,
-                                 args.mRuntimeFlags, rlimits, args.mMountExternal,
-                                 args.mSeInfo, args.mNiceName, args.mStartChildZygote,
-                                 args.mInstructionSet, args.mAppDataDir);
+                    args.mRuntimeFlags, rlimits, args.mMountExternal,
+                    args.mSeInfo, args.mNiceName, args.mStartChildZygote,
+                    args.mInstructionSet, args.mAppDataDir);
 
             disableExecuteOnly(args.mTargetSdkVersion);
 
-            if (args.mNiceName != null) {
-                Process.setArgV0(args.mNiceName);
-            }
-
             // End of the postFork event.
             Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
 
             return ZygoteInit.zygoteInit(args.mTargetSdkVersion,
-                                         args.mRemainingArgs,
-                                         null /* classLoader */);
+                    args.mRemainingArgs,
+                    null /* classLoader */);
         } finally {
             // Unblock SIGTERM to restore the process to default behavior.
             unblockSigTerm();
@@ -647,6 +644,16 @@ public final class Zygote {
 
     private static native void nativeUnblockSigTerm();
 
+    static void setAppProcessName(ZygoteArguments args, String loggingTag) {
+        if (args.mNiceName != null) {
+            Process.setArgV0(args.mNiceName);
+        } else if (args.mPackageName != null) {
+            Process.setArgV0(args.mPackageName);
+        } else {
+            Log.w(loggingTag, ""Unable to set package name."");
+        }
+    }
+
     private static final String USAP_ERROR_PREFIX = ""Invalid command to USAP: "";
 
     /**
@@ -669,7 +676,7 @@ public final class Zygote {
             throw new IllegalArgumentException(USAP_ERROR_PREFIX + ""--start-child-zygote"");
         } else if (args.mApiBlacklistExemptions != null) {
             throw new IllegalArgumentException(
-                USAP_ERROR_PREFIX + ""--set-api-blacklist-exemptions"");
+                    USAP_ERROR_PREFIX + ""--set-api-blacklist-exemptions"");
         } else if (args.mHiddenApiAccessLogSampleRate != -1) {
             throw new IllegalArgumentException(
                     USAP_ERROR_PREFIX + ""--hidden-api-log-sampling-rate="");
@@ -680,8 +687,8 @@ public final class Zygote {
             throw new IllegalArgumentException(USAP_ERROR_PREFIX + ""--invoke-with"");
         } else if (args.mPermittedCapabilities != 0 || args.mEffectiveCapabilities != 0) {
             throw new ZygoteSecurityException(""Client may not specify capabilities: ""
-                + ""permitted=0x"" + Long.toHexString(args.mPermittedCapabilities)
-                + "", effective=0x"" + Long.toHexString(args.mEffectiveCapabilities));
+                    + ""permitted=0x"" + Long.toHexString(args.mPermittedCapabilities)
+                    + "", effective=0x"" + Long.toHexString(args.mEffectiveCapabilities));
         }
     }
 
@@ -738,7 +745,7 @@ public final class Zygote {
             if (uidRestricted && args.mUidSpecified && (args.mUid < Process.SYSTEM_UID)) {
                 throw new ZygoteSecurityException(
                         ""System UID may not launch process with UID < ""
-                        + Process.SYSTEM_UID);
+                                + Process.SYSTEM_UID);
             }
         }
 
@@ -788,8 +795,8 @@ public final class Zygote {
         if (args.mInvokeWith != null && peerUid != 0
                 && (args.mRuntimeFlags & Zygote.DEBUG_ENABLE_JDWP) == 0) {
             throw new ZygoteSecurityException(""Peer is permitted to specify an ""
-                + ""explicit invoke-with wrapper command only for debuggable ""
-                + ""applications."");
+                    + ""explicit invoke-with wrapper command only for debuggable ""
+                    + ""applications."");
         }
     }
 
@@ -872,7 +879,7 @@ public final class Zygote {
             return new LocalServerSocket(fd);
         } catch (IOException ex) {
             throw new RuntimeException(
-                ""Error building socket from file descriptor: "" + fileDesc, ex);
+                    ""Error building socket from file descriptor: "" + fileDesc, ex);
         }
     }
 
",31,24,"Zygote::applyInvokeWithSecurityPolicy, Zygote::validateUsapCommand, Zygote::specializeAppProcess, Zygote::createManagedSocketFromInitSocket, Zygote::forkUsap, Zygote::setAppProcessName, Zygote::usapMain, Zygote::applyUidSecurityPolicy"
191,1df153ad281eae69590ae94a919afc74d32ed59d,ZygoteConnection.java,ModificationType.MODIFY,"@@ -580,9 +580,7 @@ class ZygoteConnection {
             }
         }
 
-        if (parsedArgs.mNiceName != null) {
-            Process.setArgV0(parsedArgs.mNiceName);
-        }
+        Zygote.setAppProcessName(parsedArgs, TAG);
 
         // End of the postFork event.
         Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
",1,3,ZygoteConnection::handleChildProc
192,16d3f8248d2a7aa77efe97c5a47148034cf74d88,Zygote.java,ModificationType.MODIFY,"@@ -172,6 +172,11 @@ public final class Zygote {
      */
     public static final int SOCKET_BUFFER_SIZE = 256;
 
+    /**
+     * @hide for internal use only
+     */
+    private static final int PRIORITY_MAX = -20;
+
     /** a prototype instance for a future List.toArray() */
     protected static final int[][] INT_ARRAY_2D = new int[0][0];
 
@@ -236,8 +241,7 @@ public final class Zygote {
             int[] fdsToIgnore, boolean startChildZygote, String instructionSet, String appDataDir,
             int targetSdkVersion) {
         ZygoteHooks.preFork();
-        // Resets nice priority for zygote process.
-        resetNicePriority();
+
         int pid = nativeForkAndSpecialize(
                 uid, gid, gids, runtimeFlags, rlimits, mountExternal, seInfo, niceName, fdsToClose,
                 fdsToIgnore, startChildZygote, instructionSet, appDataDir);
@@ -249,6 +253,7 @@ public final class Zygote {
             // Note that this event ends at the end of handleChildProc,
             Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""PostFork"");
         }
+
         ZygoteHooks.postForkCommon();
         return pid;
     }
@@ -335,15 +340,16 @@ public final class Zygote {
     public static int forkSystemServer(int uid, int gid, int[] gids, int runtimeFlags,
             int[][] rlimits, long permittedCapabilities, long effectiveCapabilities) {
         ZygoteHooks.preFork();
-        // Resets nice priority for zygote process.
-        resetNicePriority();
+
         int pid = nativeForkSystemServer(
                 uid, gid, gids, runtimeFlags, rlimits,
                 permittedCapabilities, effectiveCapabilities);
+
         // Enable tracing as soon as we enter the system_server.
         if (pid == 0) {
             Trace.setTracingEnabled(true, runtimeFlags);
         }
+
         ZygoteHooks.postForkCommon();
         return pid;
     }
@@ -461,13 +467,16 @@ public final class Zygote {
     /**
      * Fork a new unspecialized app process from the zygote
      *
+     * @param usapPoolSocket  The server socket the USAP will call accept on
      * @param sessionSocketRawFDs  Anonymous session sockets that are currently open
+     * @param isPriorityFork  Value controlling the process priority level until accept is called
      * @return In the Zygote process this function will always return null; in unspecialized app
      *         processes this function will return a Runnable object representing the new
      *         application that is passed up from usapMain.
      */
     static Runnable forkUsap(LocalServerSocket usapPoolSocket,
-            int[] sessionSocketRawFDs) {
+                             int[] sessionSocketRawFDs,
+                             boolean isPriorityFork) {
         FileDescriptor[] pipeFDs = null;
 
         try {
@@ -477,7 +486,8 @@ public final class Zygote {
         }
 
         int pid =
-                nativeForkUsap(pipeFDs[0].getInt$(), pipeFDs[1].getInt$(), sessionSocketRawFDs);
+                nativeForkUsap(pipeFDs[0].getInt$(), pipeFDs[1].getInt$(),
+                               sessionSocketRawFDs, isPriorityFork);
 
         if (pid == 0) {
             IoUtils.closeQuietly(pipeFDs[0]);
@@ -491,8 +501,9 @@ public final class Zygote {
     }
 
     private static native int nativeForkUsap(int readPipeFD,
-            int writePipeFD,
-            int[] sessionSocketRawFDs);
+                                             int writePipeFD,
+                                             int[] sessionSocketRawFDs,
+                                             boolean isPriorityFork);
 
     /**
      * This function is used by unspecialized app processes to wait for specialization requests from
@@ -512,6 +523,11 @@ public final class Zygote {
         Credentials peerCredentials = null;
         ZygoteArguments args = null;
 
+        // Change the priority to max before calling accept so we can respond to new specialization
+        // requests as quickly as possible.  This will be reverted to the default priority in the
+        // native specialization code.
+        boostUsapPriority();
+
         while (true) {
             try {
                 sessionSocket = usapPoolSocket.accept();
@@ -644,6 +660,12 @@ public final class Zygote {
 
     private static native void nativeUnblockSigTerm();
 
+    private static void boostUsapPriority() {
+        nativeBoostUsapPriority();
+    }
+
+    private static native void nativeBoostUsapPriority();
+
     static void setAppProcessName(ZygoteArguments args, String loggingTag) {
         if (args.mNiceName != null) {
             Process.setArgV0(args.mNiceName);
@@ -893,15 +915,6 @@ public final class Zygote {
         ZygoteHooks.postForkChild(runtimeFlags, isSystemServer, isZygote, instructionSet);
     }
 
-    /**
-     * Resets the calling thread priority to the default value (Thread.NORM_PRIORITY
-     * or nice value 0). This updates both the priority value in java.lang.Thread and
-     * the nice value (setpriority).
-     */
-    static void resetNicePriority() {
-        Thread.currentThread().setPriority(Thread.NORM_PRIORITY);
-    }
-
     /**
      * Executes ""/system/bin/sh -c &lt;command&gt;"" using the exec() system call.
      * This method throws a runtime exception if exec() failed, otherwise, this
",30,17,"Zygote::usapMain, Zygote::boostUsapPriority, Zygote::forkUsap, Zygote::forkUsap, Zygote::forkSystemServer, Zygote::resetNicePriority, Zygote::forkAndSpecialize"
193,16d3f8248d2a7aa77efe97c5a47148034cf74d88,ZygoteConnection.java,ModificationType.MODIFY,"@@ -347,7 +347,7 @@ class ZygoteConnection {
             if (zygoteServer.isUsapPoolEnabled()) {
                 Runnable fpResult =
                         zygoteServer.fillUsapPool(
-                                new int[]{mSocket.getFileDescriptor().getInt$()});
+                                new int[]{mSocket.getFileDescriptor().getInt$()}, false);
 
                 if (fpResult != null) {
                     zygoteServer.setForkChild();
",1,1,ZygoteConnection::stateChangeWithUsapPoolReset
194,16d3f8248d2a7aa77efe97c5a47148034cf74d88,ZygoteInit.java,ModificationType.MODIFY,"@@ -819,6 +819,9 @@ public class ZygoteInit {
     public static void main(String argv[]) {
         ZygoteServer zygoteServer = null;
 
+        // Set the initial thread priority to the ""normal"" value.
+        Thread.currentThread().setPriority(Thread.NORM_PRIORITY);
+
         // Mark zygote start. This ensures that thread creation will throw
         // an error.
         ZygoteHooks.startZygoteNoThreadCreation();
@@ -878,8 +881,6 @@ public class ZygoteInit {
                 EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_END,
                         SystemClock.uptimeMillis());
                 bootTimingsTraceLog.traceEnd(); // ZygotePreload
-            } else {
-                Zygote.resetNicePriority();
             }
 
             // Do an initial gc to clean up after startup
",3,2,ZygoteInit::main
195,16d3f8248d2a7aa77efe97c5a47148034cf74d88,ZygoteServer.java,ModificationType.MODIFY,"@@ -66,6 +66,15 @@ class ZygoteServer {
     /** The default value used for the USAP_POOL_SIZE_MIN device property */
     private static final String USAP_POOL_SIZE_MIN_DEFAULT = ""1"";
 
+    /**
+     * Number of milliseconds to delay before refilling the pool if it hasn't reached its
+     * minimum value.
+     */
+    private static final int USAP_REFILL_DELAY_MS = 3000;
+
+    /** The ""not a timestamp"" value for the refill delay timestamp mechanism. */
+    private static final int INVALID_TIMESTAMP = -1;
+
     /**
      * Indicates if this Zygote server can support a unspecialized app process pool.  Currently this
      * should only be true for the primary and secondary Zygotes, and not the App Zygotes or the
@@ -131,6 +140,12 @@ class ZygoteServer {
      */
     private int mUsapPoolRefillThreshold = 0;
 
+    private enum UsapPoolRefillAction {
+        DELAYED,
+        IMMEDIATE,
+        NONE
+    }
+
     ZygoteServer() {
         mUsapPoolEventFD = null;
         mZygoteSocket = null;
@@ -293,9 +308,16 @@ class ZygoteServer {
         }
     }
 
+    private void fetchUsapPoolPolicyPropsIfUnfetched() {
+        if (mIsFirstPropertyCheck) {
+            mIsFirstPropertyCheck = false;
+            fetchUsapPoolPolicyProps();
+        }
+    }
+
     /**
-     * Checks to see if the current policy says that pool should be refilled, and spawns new USAPs
-     * if necessary.
+     * Refill the USAP Pool to the appropriate level, determined by whether this is a priority
+     * refill event or not.
      *
      * @param sessionSocketRawFDs  Anonymous session sockets that are currently open
      * @return In the Zygote process this function will always return null; in unspecialized app
@@ -303,39 +325,46 @@ class ZygoteServer {
      *         application that is passed up from usapMain.
      */
 
-    Runnable fillUsapPool(int[] sessionSocketRawFDs) {
+    Runnable fillUsapPool(int[] sessionSocketRawFDs, boolean isPriorityRefill) {
         Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""Zygote:FillUsapPool"");
 
         // Ensure that the pool properties have been fetched.
-        fetchUsapPoolPolicyPropsWithMinInterval();
+        fetchUsapPoolPolicyPropsIfUnfetched();
 
         int usapPoolCount = Zygote.getUsapPoolCount();
-        int numUsapsToSpawn = mUsapPoolSizeMax - usapPoolCount;
+        int numUsapsToSpawn;
 
-        if (usapPoolCount < mUsapPoolSizeMin
-                || numUsapsToSpawn >= mUsapPoolRefillThreshold) {
+        if (isPriorityRefill) {
+            // Refill to min
+            numUsapsToSpawn = mUsapPoolSizeMin - usapPoolCount;
 
-            // Disable some VM functionality and reset some system values
-            // before forking.
-            ZygoteHooks.preFork();
-            Zygote.resetNicePriority();
+            Log.i(""zygote"",
+                    ""Priority USAP Pool refill. New USAPs: "" + numUsapsToSpawn);
+        } else {
+            // Refill up to max
+            numUsapsToSpawn = mUsapPoolSizeMax - usapPoolCount;
 
-            while (usapPoolCount++ < mUsapPoolSizeMax) {
-                Runnable caller = Zygote.forkUsap(mUsapPoolSocket, sessionSocketRawFDs);
+            Log.i(""zygote"",
+                    ""Delayed USAP Pool refill. New USAPs: "" + numUsapsToSpawn);
+        }
 
-                if (caller != null) {
-                    return caller;
-                }
-            }
+        // Disable some VM functionality and reset some system values
+        // before forking.
+        ZygoteHooks.preFork();
 
-            // Re-enable runtime services for the Zygote.  Services for unspecialized app process
-            // are re-enabled in specializeAppProcess.
-            ZygoteHooks.postForkCommon();
+        while (--numUsapsToSpawn >= 0) {
+            Runnable caller =
+                    Zygote.forkUsap(mUsapPoolSocket, sessionSocketRawFDs, isPriorityRefill);
 
-            Log.i(""zygote"",
-                    ""Filled the USAP pool. New USAPs: "" + numUsapsToSpawn);
+            if (caller != null) {
+                return caller;
+            }
         }
 
+        // Re-enable runtime services for the Zygote.  Services for unspecialized app process
+        // are re-enabled in specializeAppProcess.
+        ZygoteHooks.postForkCommon();
+
         Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
 
         return null;
@@ -358,7 +387,7 @@ class ZygoteServer {
         mUsapPoolEnabled = newStatus;
 
         if (newStatus) {
-            return fillUsapPool(new int[]{ sessionSocket.getFileDescriptor().getInt$() });
+            return fillUsapPool(new int[]{ sessionSocket.getFileDescriptor().getInt$() }, false);
         } else {
             Zygote.emptyUsapPool();
             return null;
@@ -377,6 +406,8 @@ class ZygoteServer {
         socketFDs.add(mZygoteSocket.getFileDescriptor());
         peers.add(null);
 
+        long usapPoolRefillTriggerTimestamp = INVALID_TIMESTAMP;
+
         while (true) {
             fetchUsapPoolPolicyPropsWithMinInterval();
 
@@ -428,140 +459,193 @@ class ZygoteServer {
                 }
             }
 
+            int pollTimeoutMs;
+
+            if (usapPoolRefillTriggerTimestamp == INVALID_TIMESTAMP) {
+                pollTimeoutMs = -1;
+            } else {
+                int elapsedTimeMs =
+                        (int) (System.currentTimeMillis() - usapPoolRefillTriggerTimestamp);
+
+                if (elapsedTimeMs >= USAP_REFILL_DELAY_MS) {
+                    // Normalize the poll timeout value when the time between one poll event and the
+                    // next pushes us over the delay value.  This prevents poll receiving a 0
+                    // timeout value, which would result in it returning immediately.
+                    pollTimeoutMs = -1;
+                } else {
+                    pollTimeoutMs = USAP_REFILL_DELAY_MS - elapsedTimeMs;
+                }
+            }
+
+            int pollReturnValue;
             try {
-                Os.poll(pollFDs, -1);
+                pollReturnValue = Os.poll(pollFDs, pollTimeoutMs);
             } catch (ErrnoException ex) {
                 throw new RuntimeException(""poll failed"", ex);
             }
 
-            boolean usapPoolFDRead = false;
-
-            while (--pollIndex >= 0) {
-                if ((pollFDs[pollIndex].revents & POLLIN) == 0) {
-                    continue;
-                }
-
-                if (pollIndex == 0) {
-                    // Zygote server socket
+            UsapPoolRefillAction usapPoolRefillAction = UsapPoolRefillAction.NONE;
+            if (pollReturnValue == 0) {
+                // The poll timeout has been exceeded.  This only occurs when we have finished the
+                // USAP pool refill delay period.
 
-                    ZygoteConnection newPeer = acceptCommandPeer(abiList);
-                    peers.add(newPeer);
-                    socketFDs.add(newPeer.getFileDescriptor());
+                usapPoolRefillTriggerTimestamp = INVALID_TIMESTAMP;
+                usapPoolRefillAction = UsapPoolRefillAction.DELAYED;
 
-                } else if (pollIndex < usapPoolEventFDIndex) {
-                    // Session socket accepted from the Zygote server socket
+            } else {
+                boolean usapPoolFDRead = false;
 
-                    try {
-                        ZygoteConnection connection = peers.get(pollIndex);
-                        final Runnable command = connection.processOneCommand(this);
+                while (--pollIndex >= 0) {
+                    if ((pollFDs[pollIndex].revents & POLLIN) == 0) {
+                        continue;
+                    }
 
-                        // TODO (chriswailes): Is this extra check necessary?
-                        if (mIsForkChild) {
-                            // We're in the child. We should always have a command to run at this
-                            // stage if processOneCommand hasn't called ""exec"".
-                            if (command == null) {
-                                throw new IllegalStateException(""command == null"");
+                    if (pollIndex == 0) {
+                        // Zygote server socket
+
+                        ZygoteConnection newPeer = acceptCommandPeer(abiList);
+                        peers.add(newPeer);
+                        socketFDs.add(newPeer.getFileDescriptor());
+
+                    } else if (pollIndex < usapPoolEventFDIndex) {
+                        // Session socket accepted from the Zygote server socket
+
+                        try {
+                            ZygoteConnection connection = peers.get(pollIndex);
+                            final Runnable command = connection.processOneCommand(this);
+
+                            // TODO (chriswailes): Is this extra check necessary?
+                            if (mIsForkChild) {
+                                // We're in the child. We should always have a command to run at
+                                // this stage if processOneCommand hasn't called ""exec"".
+                                if (command == null) {
+                                    throw new IllegalStateException(""command == null"");
+                                }
+
+                                return command;
+                            } else {
+                                // We're in the server - we should never have any commands to run.
+                                if (command != null) {
+                                    throw new IllegalStateException(""command != null"");
+                                }
+
+                                // We don't know whether the remote side of the socket was closed or
+                                // not until we attempt to read from it from processOneCommand. This
+                                // shows up as a regular POLLIN event in our regular processing
+                                // loop.
+                                if (connection.isClosedByPeer()) {
+                                    connection.closeSocket();
+                                    peers.remove(pollIndex);
+                                    socketFDs.remove(pollIndex);
+                                }
                             }
+                        } catch (Exception e) {
+                            if (!mIsForkChild) {
+                                // We're in the server so any exception here is one that has taken
+                                // place pre-fork while processing commands or reading / writing
+                                // from the control socket. Make a loud noise about any such
+                                // exceptions so that we know exactly what failed and why.
 
-                            return command;
-                        } else {
-                            // We're in the server - we should never have any commands to run.
-                            if (command != null) {
-                                throw new IllegalStateException(""command != null"");
-                            }
+                                Slog.e(TAG, ""Exception executing zygote command: "", e);
+
+                                // Make sure the socket is closed so that the other end knows
+                                // immediately that something has gone wrong and doesn't time out
+                                // waiting for a response.
+                                ZygoteConnection conn = peers.remove(pollIndex);
+                                conn.closeSocket();
 
-                            // We don't know whether the remote side of the socket was closed or
-                            // not until we attempt to read from it from processOneCommand. This
-                            // shows up as a regular POLLIN event in our regular processing loop.
-                            if (connection.isClosedByPeer()) {
-                                connection.closeSocket();
-                                peers.remove(pollIndex);
                                 socketFDs.remove(pollIndex);
+                            } else {
+                                // We're in the child so any exception caught here has happened post
+                                // fork and before we execute ActivityThread.main (or any other
+                                // main() method). Log the details of the exception and bring down
+                                // the process.
+                                Log.e(TAG, ""Caught post-fork exception in child process."", e);
+                                throw e;
                             }
+                        } finally {
+                            // Reset the child flag, in the event that the child process is a child-
+                            // zygote. The flag will not be consulted this loop pass after the
+                            // Runnable is returned.
+                            mIsForkChild = false;
                         }
-                    } catch (Exception e) {
-                        if (!mIsForkChild) {
-                            // We're in the server so any exception here is one that has taken place
-                            // pre-fork while processing commands or reading / writing from the
-                            // control socket. Make a loud noise about any such exceptions so that
-                            // we know exactly what failed and why.
-
-                            Slog.e(TAG, ""Exception executing zygote command: "", e);
-
-                            // Make sure the socket is closed so that the other end knows
-                            // immediately that something has gone wrong and doesn't time out
-                            // waiting for a response.
-                            ZygoteConnection conn = peers.remove(pollIndex);
-                            conn.closeSocket();
-
-                            socketFDs.remove(pollIndex);
-                        } else {
-                            // We're in the child so any exception caught here has happened post
-                            // fork and before we execute ActivityThread.main (or any other main()
-                            // method). Log the details of the exception and bring down the process.
-                            Log.e(TAG, ""Caught post-fork exception in child process."", e);
-                            throw e;
-                        }
-                    } finally {
-                        // Reset the child flag, in the event that the child process is a child-
-                        // zygote. The flag will not be consulted this loop pass after the Runnable
-                        // is returned.
-                        mIsForkChild = false;
-                    }
-                } else {
-                    // Either the USAP pool event FD or a USAP reporting pipe.
-
-                    // If this is the event FD the payload will be the number of USAPs removed.
-                    // If this is a reporting pipe FD the payload will be the PID of the USAP
-                    // that was just specialized.
-                    long messagePayload = -1;
 
-                    try {
-                        byte[] buffer = new byte[Zygote.USAP_MANAGEMENT_MESSAGE_BYTES];
-                        int readBytes = Os.read(pollFDs[pollIndex].fd, buffer, 0, buffer.length);
-
-                        if (readBytes == Zygote.USAP_MANAGEMENT_MESSAGE_BYTES) {
-                            DataInputStream inputStream =
-                                    new DataInputStream(new ByteArrayInputStream(buffer));
+                    } else {
+                        // Either the USAP pool event FD or a USAP reporting pipe.
+
+                        // If this is the event FD the payload will be the number of USAPs removed.
+                        // If this is a reporting pipe FD the payload will be the PID of the USAP
+                        // that was just specialized.  The `continue` statements below ensure that
+                        // the messagePayload will always be valid if we complete the try block
+                        // without an exception.
+                        long messagePayload;
+
+                        try {
+                            byte[] buffer = new byte[Zygote.USAP_MANAGEMENT_MESSAGE_BYTES];
+                            int readBytes =
+                                    Os.read(pollFDs[pollIndex].fd, buffer, 0, buffer.length);
+
+                            if (readBytes == Zygote.USAP_MANAGEMENT_MESSAGE_BYTES) {
+                                DataInputStream inputStream =
+                                        new DataInputStream(new ByteArrayInputStream(buffer));
+
+                                messagePayload = inputStream.readLong();
+                            } else {
+                                Log.e(TAG, ""Incomplete read from USAP management FD of size ""
+                                        + readBytes);
+                                continue;
+                            }
+                        } catch (Exception ex) {
+                            if (pollIndex == usapPoolEventFDIndex) {
+                                Log.e(TAG, ""Failed to read from USAP pool event FD: ""
+                                        + ex.getMessage());
+                            } else {
+                                Log.e(TAG, ""Failed to read from USAP reporting pipe: ""
+                                        + ex.getMessage());
+                            }
 
-                            messagePayload = inputStream.readLong();
-                        } else {
-                            Log.e(TAG, ""Incomplete read from USAP management FD of size ""
-                                    + readBytes);
                             continue;
                         }
-                    } catch (Exception ex) {
-                        if (pollIndex == usapPoolEventFDIndex) {
-                            Log.e(TAG, ""Failed to read from USAP pool event FD: ""
-                                    + ex.getMessage());
-                        } else {
-                            Log.e(TAG, ""Failed to read from USAP reporting pipe: ""
-                                    + ex.getMessage());
+
+                        if (pollIndex > usapPoolEventFDIndex) {
+                            Zygote.removeUsapTableEntry((int) messagePayload);
                         }
 
-                        continue;
+                        usapPoolFDRead = true;
                     }
+                }
 
-                    if (pollIndex > usapPoolEventFDIndex) {
-                        Zygote.removeUsapTableEntry((int) messagePayload);
-                    }
+                if (usapPoolFDRead) {
+                    int usapPoolCount = Zygote.getUsapPoolCount();
 
-                    usapPoolFDRead = true;
+                    if (usapPoolCount < mUsapPoolSizeMin) {
+                        // Immediate refill
+                        usapPoolRefillAction = UsapPoolRefillAction.IMMEDIATE;
+                    } else if (mUsapPoolSizeMax - usapPoolCount >= mUsapPoolRefillThreshold) {
+                        // Delayed refill
+                        usapPoolRefillTriggerTimestamp = System.currentTimeMillis();
+                    }
                 }
             }
 
-            // Check to see if the USAP pool needs to be refilled.
-            if (usapPoolFDRead) {
+            if (usapPoolRefillAction != UsapPoolRefillAction.NONE) {
                 int[] sessionSocketRawFDs =
                         socketFDs.subList(1, socketFDs.size())
                                 .stream()
                                 .mapToInt(fd -> fd.getInt$())
                                 .toArray();
 
-                final Runnable command = fillUsapPool(sessionSocketRawFDs);
+                final boolean isPriorityRefill =
+                        usapPoolRefillAction == UsapPoolRefillAction.IMMEDIATE;
+
+                final Runnable command =
+                        fillUsapPool(sessionSocketRawFDs, isPriorityRefill);
 
                 if (command != null) {
                     return command;
+                } else if (isPriorityRefill) {
+                    // Schedule a delayed refill to finish refilling the pool.
+                    usapPoolRefillTriggerTimestamp = System.currentTimeMillis();
                 }
             }
         }
",205,121,"ZygoteServer::runSelectLoop, ZygoteServer::fillUsapPool, ZygoteServer::fillUsapPool, ZygoteServer::setUsapPoolStatus, ZygoteServer::fetchUsapPoolPolicyPropsIfUnfetched"
196,b4c51ad5a9ccd5d3ca25713def9457bb2219949a,Zygote.java,ModificationType.MODIFY,"@@ -639,6 +639,9 @@ public final class Zygote {
             // End of the postFork event.
             Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
 
+            // Set the Java Language thread priority to the default value for new apps.
+            Thread.currentThread().setPriority(Thread.NORM_PRIORITY);
+
             return ZygoteInit.zygoteInit(args.mTargetSdkVersion,
                     args.mRemainingArgs,
                     null /* classLoader */);
",3,0,Zygote::usapMain
197,b4c51ad5a9ccd5d3ca25713def9457bb2219949a,ZygoteConnection.java,ModificationType.MODIFY,"@@ -582,6 +582,9 @@ class ZygoteConnection {
 
         Zygote.setAppProcessName(parsedArgs, TAG);
 
+        // Set the Java Language thread priority to the default value for new apps.
+        Thread.currentThread().setPriority(Thread.NORM_PRIORITY);
+
         // End of the postFork event.
         Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
         if (parsedArgs.mInvokeWith != null) {
",3,0,ZygoteConnection::handleChildProc
198,b4c51ad5a9ccd5d3ca25713def9457bb2219949a,ZygoteInit.java,ModificationType.MODIFY,"@@ -507,6 +507,9 @@ public class ZygoteInit {
             }
         }
 
+        // Set the Java Language thread priority to the default value for the system server.
+        Thread.currentThread().setPriority(Thread.NORM_PRIORITY);
+
         if (parsedArgs.mInvokeWith != null) {
             String[] args = parsedArgs.mRemainingArgs;
             // If we have a non-null system server class path, we'll have to duplicate the
@@ -815,13 +818,22 @@ public class ZygoteInit {
         return result;
     }
 
+    /**
+     * This is the entry point for a Zygote process.  It creates the Zygote server, loads resources,
+     * and handles other tasks related to preparing the process for forking into applications.
+     *
+     * This process is started with a nice value of -20 (highest priority).  All paths that flow
+     * into new processes are required to either set the priority to the default value or terminate
+     * before executing any non-system code.  The native side of this occurs in SpecializeCommon,
+     * while the Java Language priority is changed in ZygoteInit.handleSystemServerProcess,
+     * ZygoteConnection.handleChildProc, and Zygote.usapMain.
+     *
+     * @param argv  Command line arguments used to specify the Zygote's configuration.
+     */
     @UnsupportedAppUsage
     public static void main(String argv[]) {
         ZygoteServer zygoteServer = null;
 
-        // Set the initial thread priority to the ""normal"" value.
-        Thread.currentThread().setPriority(Thread.NORM_PRIORITY);
-
         // Mark zygote start. This ensures that thread creation will throw
         // an error.
         ZygoteHooks.startZygoteNoThreadCreation();
",15,3,"ZygoteInit::handleSystemServerProcess, ZygoteInit::main"
199,4be595e70ebf68aae337e10c440751df9d32662a,Zygote.java,ModificationType.MODIFY,"@@ -254,6 +254,9 @@ public final class Zygote {
             Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""PostFork"");
         }
 
+        // Set the Java Language thread priority to the default value for new apps.
+        Thread.currentThread().setPriority(Thread.NORM_PRIORITY);
+
         ZygoteHooks.postForkCommon();
         return pid;
     }
@@ -296,6 +299,9 @@ public final class Zygote {
         // Note that this event ends at the end of handleChildProc.
         Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""PostFork"");
 
+        // Set the Java Language thread priority to the default value for new apps.
+        Thread.currentThread().setPriority(Thread.NORM_PRIORITY);
+
         /*
          * This is called here (instead of after the fork but before the specialize) to maintain
          * consistancy with the code paths for forkAndSpecialize.
@@ -350,6 +356,9 @@ public final class Zygote {
             Trace.setTracingEnabled(true, runtimeFlags);
         }
 
+        // Set the Java Language thread priority to the default value for new apps.
+        Thread.currentThread().setPriority(Thread.NORM_PRIORITY);
+
         ZygoteHooks.postForkCommon();
         return pid;
     }
@@ -636,12 +645,6 @@ public final class Zygote {
 
             disableExecuteOnly(args.mTargetSdkVersion);
 
-            // End of the postFork event.
-            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
-
-            // Set the Java Language thread priority to the default value for new apps.
-            Thread.currentThread().setPriority(Thread.NORM_PRIORITY);
-
             return ZygoteInit.zygoteInit(args.mTargetSdkVersion,
                     args.mRemainingArgs,
                     null /* classLoader */);
",9,6,"Zygote::forkAndSpecialize, Zygote::usapMain, Zygote::specializeAppProcess, Zygote::forkSystemServer"
200,4be595e70ebf68aae337e10c440751df9d32662a,ZygoteConnection.java,ModificationType.MODIFY,"@@ -582,9 +582,6 @@ class ZygoteConnection {
 
         Zygote.setAppProcessName(parsedArgs, TAG);
 
-        // Set the Java Language thread priority to the default value for new apps.
-        Thread.currentThread().setPriority(Thread.NORM_PRIORITY);
-
         // End of the postFork event.
         Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
         if (parsedArgs.mInvokeWith != null) {
",0,3,ZygoteConnection::handleChildProc
201,4be595e70ebf68aae337e10c440751df9d32662a,ZygoteInit.java,ModificationType.MODIFY,"@@ -507,9 +507,6 @@ public class ZygoteInit {
             }
         }
 
-        // Set the Java Language thread priority to the default value for the system server.
-        Thread.currentThread().setPriority(Thread.NORM_PRIORITY);
-
         if (parsedArgs.mInvokeWith != null) {
             String[] args = parsedArgs.mRemainingArgs;
             // If we have a non-null system server class path, we'll have to duplicate the
",0,3,ZygoteInit::handleSystemServerProcess
202,b93cc8321a974df133755185e8f9dd7fc85fb180,Zygote.java,ModificationType.MODIFY,"@@ -645,6 +645,8 @@ public final class Zygote {
 
             disableExecuteOnly(args.mTargetSdkVersion);
 
+            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
+
             return ZygoteInit.zygoteInit(args.mTargetSdkVersion,
                     args.mRemainingArgs,
                     null /* classLoader */);
",2,0,Zygote::usapMain
203,30fa1d8eaeaae688594eab43ac8da7bbcf87892b,ZygoteServer.java,ModificationType.MODIFY,"@@ -66,11 +66,8 @@ class ZygoteServer {
     /** The default value used for the USAP_POOL_SIZE_MIN device property */
     private static final String USAP_POOL_SIZE_MIN_DEFAULT = ""1"";
 
-    /**
-     * Number of milliseconds to delay before refilling the pool if it hasn't reached its
-     * minimum value.
-     */
-    private static final int USAP_REFILL_DELAY_MS = 3000;
+    /** The default value used for the USAP_REFILL_DELAY_MS device property */
+    private static final String USAP_POOL_REFILL_DELAY_MS_DEFAULT = ""3000"";
 
     /** The ""not a timestamp"" value for the refill delay timestamp mechanism. */
     private static final int INVALID_TIMESTAMP = -1;
@@ -140,6 +137,12 @@ class ZygoteServer {
      */
     private int mUsapPoolRefillThreshold = 0;
 
+    /**
+     * Number of milliseconds to delay before refilling the pool if it hasn't reached its
+     * minimum value.
+     */
+    private int mUsapPoolRefillDelayMs = -1;
+
     private enum UsapPoolRefillAction {
         DELAYED,
         IMMEDIATE,
@@ -282,6 +285,13 @@ class ZygoteServer {
                         mUsapPoolSizeMax);
             }
 
+            final String usapPoolRefillDelayMsPropString = Zygote.getConfigurationProperty(
+                    ZygoteConfig.USAP_POOL_REFILL_DELAY_MS, USAP_POOL_REFILL_DELAY_MS_DEFAULT);
+
+            if (!usapPoolRefillDelayMsPropString.isEmpty()) {
+                mUsapPoolRefillDelayMs = Integer.parseInt(usapPoolRefillDelayMsPropString);
+            }
+
             // Sanity check
             if (mUsapPoolSizeMin >= mUsapPoolSizeMax) {
                 Log.w(TAG, ""The max size of the USAP pool must be greater than the minimum size.""
@@ -467,13 +477,13 @@ class ZygoteServer {
                 int elapsedTimeMs =
                         (int) (System.currentTimeMillis() - usapPoolRefillTriggerTimestamp);
 
-                if (elapsedTimeMs >= USAP_REFILL_DELAY_MS) {
+                if (elapsedTimeMs >= mUsapPoolRefillDelayMs) {
                     // Normalize the poll timeout value when the time between one poll event and the
                     // next pushes us over the delay value.  This prevents poll receiving a 0
                     // timeout value, which would result in it returning immediately.
                     pollTimeoutMs = -1;
                 } else {
-                    pollTimeoutMs = USAP_REFILL_DELAY_MS - elapsedTimeMs;
+                    pollTimeoutMs = mUsapPoolRefillDelayMs - elapsedTimeMs;
                 }
             }
 
",17,7,"ZygoteServer::fetchUsapPoolPolicyProps, ZygoteServer::runSelectLoop"
204,d547ed8c63490e80f04b522c31a04dbe9e51ed94,ZygoteServer.java,ModificationType.MODIFY,"@@ -143,6 +143,12 @@ class ZygoteServer {
      */
     private int mUsapPoolRefillDelayMs = -1;
 
+    /**
+     * If and when we should refill the USAP pool.
+     */
+    private UsapPoolRefillAction mUsapPoolRefillAction;
+    private long mUsapPoolRefillTriggerTimestamp;
+
     private enum UsapPoolRefillAction {
         DELAYED,
         IMMEDIATE,
@@ -375,6 +381,8 @@ class ZygoteServer {
         // are re-enabled in specializeAppProcess.
         ZygoteHooks.postForkCommon();
 
+        resetUsapRefillState();
+
         Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
 
         return null;
@@ -404,6 +412,11 @@ class ZygoteServer {
         }
     }
 
+    void resetUsapRefillState() {
+        mUsapPoolRefillAction = UsapPoolRefillAction.NONE;
+        mUsapPoolRefillTriggerTimestamp = INVALID_TIMESTAMP;
+    }
+
     /**
      * Runs the zygote process's select loop. Accepts new connections as
      * they happen, and reads commands from connections one spawn-request's
@@ -416,10 +429,11 @@ class ZygoteServer {
         socketFDs.add(mZygoteSocket.getFileDescriptor());
         peers.add(null);
 
-        long usapPoolRefillTriggerTimestamp = INVALID_TIMESTAMP;
+        mUsapPoolRefillTriggerTimestamp = INVALID_TIMESTAMP;
 
         while (true) {
             fetchUsapPoolPolicyPropsWithMinInterval();
+            mUsapPoolRefillAction = UsapPoolRefillAction.NONE;
 
             int[] usapPipeFDs = null;
             StructPollfd[] pollFDs = null;
@@ -471,11 +485,11 @@ class ZygoteServer {
 
             int pollTimeoutMs;
 
-            if (usapPoolRefillTriggerTimestamp == INVALID_TIMESTAMP) {
+            if (mUsapPoolRefillTriggerTimestamp == INVALID_TIMESTAMP) {
                 pollTimeoutMs = -1;
             } else {
                 int elapsedTimeMs =
-                        (int) (System.currentTimeMillis() - usapPoolRefillTriggerTimestamp);
+                        (int) (System.currentTimeMillis() - mUsapPoolRefillTriggerTimestamp);
 
                 if (elapsedTimeMs >= mUsapPoolRefillDelayMs) {
                     // Normalize the poll timeout value when the time between one poll event and the
@@ -494,13 +508,12 @@ class ZygoteServer {
                 throw new RuntimeException(""poll failed"", ex);
             }
 
-            UsapPoolRefillAction usapPoolRefillAction = UsapPoolRefillAction.NONE;
             if (pollReturnValue == 0) {
                 // The poll timeout has been exceeded.  This only occurs when we have finished the
                 // USAP pool refill delay period.
 
-                usapPoolRefillTriggerTimestamp = INVALID_TIMESTAMP;
-                usapPoolRefillAction = UsapPoolRefillAction.DELAYED;
+                mUsapPoolRefillTriggerTimestamp = INVALID_TIMESTAMP;
+                mUsapPoolRefillAction = UsapPoolRefillAction.DELAYED;
 
             } else {
                 boolean usapPoolFDRead = false;
@@ -630,15 +643,15 @@ class ZygoteServer {
 
                     if (usapPoolCount < mUsapPoolSizeMin) {
                         // Immediate refill
-                        usapPoolRefillAction = UsapPoolRefillAction.IMMEDIATE;
+                        mUsapPoolRefillAction = UsapPoolRefillAction.IMMEDIATE;
                     } else if (mUsapPoolSizeMax - usapPoolCount >= mUsapPoolRefillThreshold) {
                         // Delayed refill
-                        usapPoolRefillTriggerTimestamp = System.currentTimeMillis();
+                        mUsapPoolRefillTriggerTimestamp = System.currentTimeMillis();
                     }
                 }
             }
 
-            if (usapPoolRefillAction != UsapPoolRefillAction.NONE) {
+            if (mUsapPoolRefillAction != UsapPoolRefillAction.NONE) {
                 int[] sessionSocketRawFDs =
                         socketFDs.subList(1, socketFDs.size())
                                 .stream()
@@ -646,7 +659,7 @@ class ZygoteServer {
                                 .toArray();
 
                 final boolean isPriorityRefill =
-                        usapPoolRefillAction == UsapPoolRefillAction.IMMEDIATE;
+                        mUsapPoolRefillAction == UsapPoolRefillAction.IMMEDIATE;
 
                 final Runnable command =
                         fillUsapPool(sessionSocketRawFDs, isPriorityRefill);
@@ -655,7 +668,7 @@ class ZygoteServer {
                     return command;
                 } else if (isPriorityRefill) {
                     // Schedule a delayed refill to finish refilling the pool.
-                    usapPoolRefillTriggerTimestamp = System.currentTimeMillis();
+                    mUsapPoolRefillTriggerTimestamp = System.currentTimeMillis();
                 }
             }
         }
",24,11,"ZygoteServer::fillUsapPool, ZygoteServer::runSelectLoop, ZygoteServer::resetUsapRefillState"
205,070bafcb9e9821ca0ad8891abfff0109de0b5fc3,ZygoteServer.java,ModificationType.MODIFY,"@@ -488,16 +488,23 @@ class ZygoteServer {
             if (mUsapPoolRefillTriggerTimestamp == INVALID_TIMESTAMP) {
                 pollTimeoutMs = -1;
             } else {
-                int elapsedTimeMs =
-                        (int) (System.currentTimeMillis() - mUsapPoolRefillTriggerTimestamp);
+                long elapsedTimeMs = System.currentTimeMillis() - mUsapPoolRefillTriggerTimestamp;
 
                 if (elapsedTimeMs >= mUsapPoolRefillDelayMs) {
                     // Normalize the poll timeout value when the time between one poll event and the
                     // next pushes us over the delay value.  This prevents poll receiving a 0
                     // timeout value, which would result in it returning immediately.
                     pollTimeoutMs = -1;
+
+                } else if (elapsedTimeMs <= 0) {
+                    // This can occur if the clock used by currentTimeMillis is reset, which is
+                    // possible because it is not guaranteed to be monotonic.  Because we can't tell
+                    // how far back the clock was set the best way to recover is to simply re-start
+                    // the respawn delay countdown.
+                    pollTimeoutMs = mUsapPoolRefillDelayMs;
+
                 } else {
-                    pollTimeoutMs = mUsapPoolRefillDelayMs - elapsedTimeMs;
+                    pollTimeoutMs = (int) (mUsapPoolRefillDelayMs - elapsedTimeMs);
                 }
             }
 
",10,3,ZygoteServer::runSelectLoop
206,77907c0825856a45a593bfe4bc582edadffcdfbf,ZygoteServer.java,ModificationType.MODIFY,"@@ -184,9 +184,8 @@ class ZygoteServer {
                             Zygote.USAP_POOL_SECONDARY_SOCKET_NAME);
         }
 
-        fetchUsapPoolPolicyProps();
-
         mUsapPoolSupported = true;
+        fetchUsapPoolPolicyProps();
     }
 
     void setForkChild() {
",1,2,ZygoteServer::ZygoteServer
207,fcebbbcf56d14658c7eff35dee872b4e5efdbf50,ActivityManagerInternal.java,ModificationType.MODIFY,"@@ -299,7 +299,7 @@ public abstract class ActivityManagerInternal {
 
     /** Starts a given process. */
     public abstract void startProcess(String processName, ApplicationInfo info,
-            boolean knownToBeDead, String hostingType, ComponentName hostingName);
+            boolean knownToBeDead, boolean isTop, String hostingType, ComponentName hostingName);
 
     /** Starts up the starting activity process for debugging if needed.
      * This function needs to be called synchronously from WindowManager context so the caller
",1,1,
208,fcebbbcf56d14658c7eff35dee872b4e5efdbf50,Process.java,ModificationType.MODIFY,"@@ -511,7 +511,7 @@ public class Process {
      * @param appDataDir null-ok the data directory of the app.
      * @param invokeWith null-ok the command to invoke with.
      * @param packageName null-ok the name of the package this process belongs to.
-     *
+     * @param isTopApp whether the process starts for high priority application.
      * @param zygoteArgs Additional arguments to supply to the zygote process.
      * @return An object that describes the result of the attempt to start the process.
      * @throws RuntimeException on fatal start failure
@@ -530,11 +530,12 @@ public class Process {
                                            @Nullable String appDataDir,
                                            @Nullable String invokeWith,
                                            @Nullable String packageName,
+                                           boolean isTopApp,
                                            @Nullable String[] zygoteArgs) {
         return ZYGOTE_PROCESS.start(processClass, niceName, uid, gid, gids,
                     runtimeFlags, mountExternal, targetSdkVersion, seInfo,
                     abi, instructionSet, appDataDir, invokeWith, packageName,
-                    /*useUsapPool=*/ true, zygoteArgs);
+                    /*useUsapPool=*/ true, isTopApp, zygoteArgs);
     }
 
     /** @hide */
@@ -554,7 +555,7 @@ public class Process {
         return WebViewZygote.getProcess().start(processClass, niceName, uid, gid, gids,
                     runtimeFlags, mountExternal, targetSdkVersion, seInfo,
                     abi, instructionSet, appDataDir, invokeWith, packageName,
-                    /*useUsapPool=*/ false, zygoteArgs);
+                    /*useUsapPool=*/ false, /*isTopApp=*/ false, zygoteArgs);
     }
 
     /**
",4,3,"Process::start, Process::start, Process::startWebView"
209,fcebbbcf56d14658c7eff35dee872b4e5efdbf50,ZygoteProcess.java,ModificationType.MODIFY,"@@ -307,6 +307,7 @@ public class ZygoteProcess {
      * @param invokeWith null-ok the command to invoke with.
      * @param packageName null-ok the name of the package this process belongs to.
      * @param zygoteArgs Additional arguments to supply to the zygote process.
+     * @param isTopApp Whether the process starts for high priority application.
      *
      * @return An object that describes the result of the attempt to start the process.
      * @throws RuntimeException on fatal start failure
@@ -323,6 +324,7 @@ public class ZygoteProcess {
                                                   @Nullable String invokeWith,
                                                   @Nullable String packageName,
                                                   boolean useUsapPool,
+                                                  boolean isTopApp,
                                                   @Nullable String[] zygoteArgs) {
         // TODO (chriswailes): Is there a better place to check this value?
         if (fetchUsapPoolEnabledPropWithMinInterval()) {
@@ -333,7 +335,7 @@ public class ZygoteProcess {
             return startViaZygote(processClass, niceName, uid, gid, gids,
                     runtimeFlags, mountExternal, targetSdkVersion, seInfo,
                     abi, instructionSet, appDataDir, invokeWith, /*startChildZygote=*/ false,
-                    packageName, useUsapPool, zygoteArgs);
+                    packageName, useUsapPool, isTopApp, zygoteArgs);
         } catch (ZygoteStartFailedEx ex) {
             Log.e(LOG_TAG,
                     ""Starting VM process through Zygote failed"");
@@ -534,6 +536,7 @@ public class ZygoteProcess {
      * @param startChildZygote Start a sub-zygote. This creates a new zygote process
      * that has its state cloned from this zygote process.
      * @param packageName null-ok the name of the package this process belongs to.
+     * @param isTopApp Whether the process starts for high priority application.
      * @param extraArgs Additional arguments to supply to the zygote process.
      * @return An object that describes the result of the attempt to start the process.
      * @throws ZygoteStartFailedEx if process start failed for any reason
@@ -552,6 +555,7 @@ public class ZygoteProcess {
                                                       boolean startChildZygote,
                                                       @Nullable String packageName,
                                                       boolean useUsapPool,
+                                                      boolean isTopApp,
                                                       @Nullable String[] extraArgs)
                                                       throws ZygoteStartFailedEx {
         ArrayList<String> argsForZygote = new ArrayList<>();
@@ -623,6 +627,10 @@ public class ZygoteProcess {
             argsForZygote.add(""--package-name="" + packageName);
         }
 
+        if (isTopApp) {
+            argsForZygote.add(Zygote.START_AS_TOP_APP_ARG);
+        }
+
         argsForZygote.add(processClass);
 
         if (extraArgs != null) {
@@ -1144,7 +1152,8 @@ public class ZygoteProcess {
                     gids, runtimeFlags, 0 /* mountExternal */, 0 /* targetSdkVersion */, seInfo,
                     abi, instructionSet, null /* appDataDir */, null /* invokeWith */,
                     true /* startChildZygote */, null /* packageName */,
-                    false /* useUsapPool */, extraArgs);
+                    false /* useUsapPool */, false /* isTopApp */,
+                    extraArgs);
         } catch (ZygoteStartFailedEx ex) {
             throw new RuntimeException(""Starting child-zygote through Zygote failed"", ex);
         }
",11,2,"ZygoteProcess::startViaZygote, ZygoteProcess::startChildZygote, ZygoteProcess::start, ZygoteProcess::start"
210,fcebbbcf56d14658c7eff35dee872b4e5efdbf50,Zygote.java,ModificationType.MODIFY,"@@ -130,6 +130,9 @@ public final class Zygote {
     /** Number of bytes sent to the Zygote over USAP pipes or the pool event FD */
     public static final int USAP_MANAGEMENT_MESSAGE_BYTES = 8;
 
+    /** Make the new process have top application priority. */
+    public static final String START_AS_TOP_APP_ARG = ""--is-top-app"";
+
     /**
      * An extraArg passed when a zygote process is forking a child-zygote, specifying a name
      * in the abstract socket namespace. This socket name is what the new child zygote
@@ -232,6 +235,7 @@ public final class Zygote {
      * new zygote process.
      * @param instructionSet null-ok the instruction set to use.
      * @param appDataDir null-ok the data directory of the app.
+     * @param isTopApp true if the process is for top (high priority) application.
      *
      * @return 0 if this is the child, pid of the child
      * if this is the parent, or -1 on error.
@@ -239,12 +243,12 @@ public final class Zygote {
     public static int forkAndSpecialize(int uid, int gid, int[] gids, int runtimeFlags,
             int[][] rlimits, int mountExternal, String seInfo, String niceName, int[] fdsToClose,
             int[] fdsToIgnore, boolean startChildZygote, String instructionSet, String appDataDir,
-            int targetSdkVersion) {
+            int targetSdkVersion, boolean isTopApp) {
         ZygoteHooks.preFork();
 
         int pid = nativeForkAndSpecialize(
                 uid, gid, gids, runtimeFlags, rlimits, mountExternal, seInfo, niceName, fdsToClose,
-                fdsToIgnore, startChildZygote, instructionSet, appDataDir);
+                fdsToIgnore, startChildZygote, instructionSet, appDataDir, isTopApp);
         // Enable tracing as soon as possible for the child process.
         if (pid == 0) {
             Zygote.disableExecuteOnly(targetSdkVersion);
@@ -264,7 +268,7 @@ public final class Zygote {
     private static native int nativeForkAndSpecialize(int uid, int gid, int[] gids,
             int runtimeFlags, int[][] rlimits, int mountExternal, String seInfo, String niceName,
             int[] fdsToClose, int[] fdsToIgnore, boolean startChildZygote, String instructionSet,
-            String appDataDir);
+            String appDataDir, boolean isTopApp);
 
     /**
      * Specialize an unspecialized app process.  The current VM must have been started
@@ -286,12 +290,13 @@ public final class Zygote {
      * new zygote process.
      * @param instructionSet null-ok  The instruction set to use.
      * @param appDataDir null-ok  The data directory of the app.
+     * @param isTopApp  True if the process is for top (high priority) application.
      */
     public static void specializeAppProcess(int uid, int gid, int[] gids, int runtimeFlags,
             int[][] rlimits, int mountExternal, String seInfo, String niceName,
-            boolean startChildZygote, String instructionSet, String appDataDir) {
+            boolean startChildZygote, String instructionSet, String appDataDir, boolean isTopApp) {
         nativeSpecializeAppProcess(uid, gid, gids, runtimeFlags, rlimits, mountExternal, seInfo,
-                niceName, startChildZygote, instructionSet, appDataDir);
+                niceName, startChildZygote, instructionSet, appDataDir, isTopApp);
 
         // Enable tracing as soon as possible for the child process.
         Trace.setTracingEnabled(true, runtimeFlags);
@@ -313,7 +318,7 @@ public final class Zygote {
 
     private static native void nativeSpecializeAppProcess(int uid, int gid, int[] gids,
             int runtimeFlags, int[][] rlimits, int mountExternal, String seInfo, String niceName,
-            boolean startChildZygote, String instructionSet, String appDataDir);
+            boolean startChildZygote, String instructionSet, String appDataDir, boolean isTopApp);
 
     /**
      * Called to do any initialization before starting an application.
@@ -641,7 +646,7 @@ public final class Zygote {
             specializeAppProcess(args.mUid, args.mGid, args.mGids,
                     args.mRuntimeFlags, rlimits, args.mMountExternal,
                     args.mSeInfo, args.mNiceName, args.mStartChildZygote,
-                    args.mInstructionSet, args.mAppDataDir);
+                    args.mInstructionSet, args.mAppDataDir, args.mIsTopApp);
 
             disableExecuteOnly(args.mTargetSdkVersion);
 
",12,7,"Zygote::specializeAppProcess, Zygote::forkAndSpecialize, Zygote::usapMain, Zygote::specializeAppProcess, Zygote::forkAndSpecialize"
211,fcebbbcf56d14658c7eff35dee872b4e5efdbf50,ZygoteArguments.java,ModificationType.MODIFY,"@@ -204,6 +204,11 @@ class ZygoteArguments {
      */
     int mHiddenApiAccessStatslogSampleRate = -1;
 
+    /**
+     * @see Zygote#START_AS_TOP_APP_ARG
+     */
+    boolean mIsTopApp;
+
     /**
      * Constructs instance and parses args
      *
@@ -409,6 +414,8 @@ class ZygoteArguments {
                 mUsapPoolStatusSpecified = true;
                 mUsapPoolEnabled = Boolean.parseBoolean(arg.substring(arg.indexOf('=') + 1));
                 expectRuntimeArgs = false;
+            } else if (arg.startsWith(Zygote.START_AS_TOP_APP_ARG)) {
+                mIsTopApp = true;
             } else {
                 break;
             }
",7,0,ZygoteArguments::parseArgs
212,fcebbbcf56d14658c7eff35dee872b4e5efdbf50,ZygoteConnection.java,ModificationType.MODIFY,"@@ -267,7 +267,8 @@ class ZygoteConnection {
         pid = Zygote.forkAndSpecialize(parsedArgs.mUid, parsedArgs.mGid, parsedArgs.mGids,
                 parsedArgs.mRuntimeFlags, rlimits, parsedArgs.mMountExternal, parsedArgs.mSeInfo,
                 parsedArgs.mNiceName, fdsToClose, fdsToIgnore, parsedArgs.mStartChildZygote,
-                parsedArgs.mInstructionSet, parsedArgs.mAppDataDir, parsedArgs.mTargetSdkVersion);
+                parsedArgs.mInstructionSet, parsedArgs.mAppDataDir, parsedArgs.mTargetSdkVersion,
+                parsedArgs.mIsTopApp);
 
         try {
             if (pid == 0) {
",2,1,ZygoteConnection::processOneCommand
213,fcebbbcf56d14658c7eff35dee872b4e5efdbf50,ActivityManagerService.java,ModificationType.MODIFY,"@@ -4850,7 +4850,7 @@ public class ActivityManagerService extends IActivityManager.Stub
         EventLog.writeEvent(EventLogTags.AM_PROC_BOUND, app.userId, app.pid, app.processName);
 
         app.curAdj = app.setAdj = app.verifiedAdj = ProcessList.INVALID_ADJ;
-        app.setCurrentSchedulingGroup(app.setSchedGroup = ProcessList.SCHED_GROUP_DEFAULT);
+        mOomAdjuster.setAttachingSchedGroupLocked(app);
         app.forcingToImportant = null;
         updateProcessForegroundLocked(app, false, 0, false);
         app.hasShownUi = false;
@@ -18389,16 +18389,19 @@ public class ActivityManagerService extends IActivityManager.Stub
         }
 
         @Override
-        public void startProcess(String processName, ApplicationInfo info,
-                boolean knownToBeDead, String hostingType, ComponentName hostingName) {
+        public void startProcess(String processName, ApplicationInfo info, boolean knownToBeDead,
+                boolean isTop, String hostingType, ComponentName hostingName) {
             try {
                 if (Trace.isTagEnabled(Trace.TRACE_TAG_ACTIVITY_MANAGER)) {
                     Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""startProcess:""
                             + processName);
                 }
                 synchronized (ActivityManagerService.this) {
+                    // If the process is known as top app, set a hint so when the process is
+                    // started, the top priority can be applied immediately to avoid cpu being
+                    // preempted by other processes before attaching the process of top app.
                     startProcessLocked(processName, info, knownToBeDead, 0 /* intentFlags */,
-                            new HostingRecord(hostingType, hostingName),
+                            new HostingRecord(hostingType, hostingName, isTop),
                             false /* allowWhileBooting */, false /* isolated */,
                             true /* keepIfLarge */);
                 }
",7,4,"ActivityManagerService::attachApplicationLocked, ActivityManagerService::LocalService::startProcess, ActivityManagerService::LocalService::startProcess"
214,fcebbbcf56d14658c7eff35dee872b4e5efdbf50,HostingRecord.java,ModificationType.MODIFY,"@@ -41,6 +41,8 @@ import android.content.ComponentName;
  * {@link android.content.Context#BIND_EXTERNAL_SERVICE} service. In that case, the packageName
  * and uid in the ApplicationInfo will be set to those of the caller, not of the defining package.
  *
+ * {@code mIsTopApp} will be passed to {@link android.os.Process#start}. So Zygote will initialize
+ * the process with high priority.
  */
 
 public final class HostingRecord {
@@ -53,15 +55,22 @@ public final class HostingRecord {
     private final int mHostingZygote;
     private final String mDefiningPackageName;
     private final int mDefiningUid;
+    private final boolean mIsTopApp;
 
     public HostingRecord(String hostingType) {
-        this(hostingType, null, REGULAR_ZYGOTE, null, -1);
+        this(hostingType, null /* hostingName */, REGULAR_ZYGOTE, null /* definingPackageName */,
+                -1 /* mDefiningUid */, false /* isTopApp */);
     }
 
     public HostingRecord(String hostingType, ComponentName hostingName) {
         this(hostingType, hostingName, REGULAR_ZYGOTE);
     }
 
+    public HostingRecord(String hostingType, ComponentName hostingName, boolean isTopApp) {
+        this(hostingType, hostingName.toShortString(), REGULAR_ZYGOTE,
+                null /* definingPackageName */, -1 /* mDefiningUid */, isTopApp /* isTopApp */);
+    }
+
     public HostingRecord(String hostingType, String hostingName) {
         this(hostingType, hostingName, REGULAR_ZYGOTE);
     }
@@ -71,16 +80,18 @@ public final class HostingRecord {
     }
 
     private HostingRecord(String hostingType, String hostingName, int hostingZygote) {
-        this(hostingType, hostingName, hostingZygote, null, -1);
+        this(hostingType, hostingName, hostingZygote, null /* definingPackageName */,
+                -1 /* mDefiningUid */, false /* isTopApp */);
     }
 
     private HostingRecord(String hostingType, String hostingName, int hostingZygote,
-            String definingPackageName, int definingUid) {
+            String definingPackageName, int definingUid, boolean isTopApp) {
         mHostingType = hostingType;
         mHostingName = hostingName;
         mHostingZygote = hostingZygote;
         mDefiningPackageName = definingPackageName;
         mDefiningUid = definingUid;
+        mIsTopApp = isTopApp;
     }
 
     public String getType() {
@@ -91,6 +102,10 @@ public final class HostingRecord {
         return mHostingName;
     }
 
+    public boolean isTopApp() {
+        return mIsTopApp;
+    }
+
     /**
      * Returns the UID of the package defining the component we want to start. Only valid
      * when {@link #usesAppZygote()} returns true.
@@ -130,7 +145,7 @@ public final class HostingRecord {
     public static HostingRecord byAppZygote(ComponentName hostingName, String definingPackageName,
             int definingUid) {
         return new HostingRecord("""", hostingName.toShortString(), APP_ZYGOTE,
-                definingPackageName, definingUid);
+                definingPackageName, definingUid, false /* isTopApp */);
     }
 
     /**
",19,4,"HostingRecord::byAppZygote, HostingRecord::HostingRecord, HostingRecord::HostingRecord, HostingRecord::HostingRecord, HostingRecord::HostingRecord, HostingRecord::HostingRecord, HostingRecord::isTopApp"
215,fcebbbcf56d14658c7eff35dee872b4e5efdbf50,OomAdjuster.java,ModificationType.MODIFY,"@@ -178,9 +178,12 @@ public final class OomAdjuster {
         adjusterThread.start();
         Process.setThreadGroupAndCpuset(adjusterThread.getThreadId(), THREAD_GROUP_TOP_APP);
         mProcessGroupHandler = new Handler(adjusterThread.getLooper(), msg -> {
-            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""setProcessGroup"");
             final int pid = msg.arg1;
             final int group = msg.arg2;
+            if (Trace.isTagEnabled(Trace.TRACE_TAG_ACTIVITY_MANAGER)) {
+                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""setProcessGroup ""
+                        + msg.obj + "" to "" + group);
+            }
             try {
                 setProcessGroup(pid, group);
             } catch (Exception e) {
@@ -1758,7 +1761,7 @@ public final class OomAdjuster {
                         break;
                 }
                 mProcessGroupHandler.sendMessage(mProcessGroupHandler.obtainMessage(
-                        0 /* unused */, app.pid, processGroup));
+                        0 /* unused */, app.pid, processGroup, app.processName));
                 try {
                     if (curSchedGroup == ProcessList.SCHED_GROUP_TOP_APP) {
                         // do nothing if we already switched to RT
@@ -1949,6 +1952,38 @@ public final class OomAdjuster {
         return success;
     }
 
+    @GuardedBy(""mService"")
+    void setAttachingSchedGroupLocked(ProcessRecord app) {
+        int initialSchedGroup = ProcessList.SCHED_GROUP_DEFAULT;
+        // If the process has been marked as foreground via Zygote.START_FLAG_USE_TOP_APP_PRIORITY,
+        // then verify that the top priority is actually is applied.
+        if (app.hasForegroundActivities()) {
+            String fallbackReason = null;
+            try {
+                // The priority must be the same as how does {@link #applyOomAdjLocked} set for
+                // {@link ProcessList.SCHED_GROUP_TOP_APP}. We don't check render thread because it
+                // is not ready when attaching.
+                if (Process.getProcessGroup(app.pid) == THREAD_GROUP_TOP_APP) {
+                    app.getWindowProcessController().onTopProcChanged();
+                    setThreadPriority(app.pid, TOP_APP_PRIORITY_BOOST);
+                } else {
+                    fallbackReason = ""not expected top priority"";
+                }
+            } catch (Exception e) {
+                fallbackReason = e.toString();
+            }
+            if (fallbackReason == null) {
+                initialSchedGroup = ProcessList.SCHED_GROUP_TOP_APP;
+            } else {
+                // The real scheduling group will depend on if there is any component of the process
+                // did something during attaching.
+                Slog.w(TAG, ""Fallback pre-set sched group to default: "" + fallbackReason);
+            }
+        }
+
+        app.setCurrentSchedulingGroup(app.setSchedGroup = initialSchedGroup);
+    }
+
     // ONLY used for unit testing in OomAdjusterTests.java
     @VisibleForTesting
     void maybeUpdateUsageStats(ProcessRecord app, long nowElapsed) {
",37,2,"OomAdjuster::OomAdjuster, OomAdjuster::setAttachingSchedGroupLocked, OomAdjuster::applyOomAdjLocked"
216,fcebbbcf56d14658c7eff35dee872b4e5efdbf50,ProcessList.java,ModificationType.MODIFY,"@@ -1801,6 +1801,14 @@ public final class ProcessList {
             Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""Start proc: "" +
                     app.processName);
             checkSlow(startTime, ""startProcess: asking zygote to start proc"");
+            final boolean isTopApp = hostingRecord.isTopApp();
+            if (isTopApp) {
+                // Use has-foreground-activities as a temporary hint so the current scheduling
+                // group won't be lost when the process is attaching. The actual state will be
+                // refreshed when computing oom-adj.
+                app.setHasForegroundActivities(true);
+            }
+
             final Process.ProcessStartResult startResult;
             if (hostingRecord.usesWebviewZygote()) {
                 startResult = startWebView(entryPoint,
@@ -1815,14 +1823,14 @@ public final class ProcessList {
                         app.processName, uid, uid, gids, runtimeFlags, mountExternal,
                         app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,
                         app.info.dataDir, null, app.info.packageName,
-                        /*useUsapPool=*/ false,
-                        new String[] {PROC_START_SEQ_IDENT + app.startSeq});
+                        /*useUsapPool=*/ false, isTopApp,
+                        new String[]{PROC_START_SEQ_IDENT + app.startSeq});
             } else {
                 startResult = Process.start(entryPoint,
                         app.processName, uid, uid, gids, runtimeFlags, mountExternal,
                         app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,
-                        app.info.dataDir, invokeWith, app.info.packageName,
-                        new String[] {PROC_START_SEQ_IDENT + app.startSeq});
+                        app.info.dataDir, invokeWith, app.info.packageName, isTopApp,
+                        new String[]{PROC_START_SEQ_IDENT + app.startSeq});
             }
             checkSlow(startTime, ""startProcess: returned from zygote!"");
             return startResult;
",12,4,ProcessList::startProcess
217,fcebbbcf56d14658c7eff35dee872b4e5efdbf50,ActivityRecord.java,ModificationType.MODIFY,"@@ -3553,7 +3553,7 @@ final class ActivityRecord extends ConfigurationContainer {
         mStackSupervisor.scheduleRestartTimeout(this);
     }
 
-    private boolean isProcessRunning() {
+    boolean isProcessRunning() {
         WindowProcessController proc = app;
         if (proc == null) {
             proc = mAtmService.mProcessNames.get(processName, info.applicationInfo.uid);
",1,1,ActivityRecord::isProcessRunning
218,fcebbbcf56d14658c7eff35dee872b4e5efdbf50,ActivityStack.java,ModificationType.MODIFY,"@@ -2743,7 +2743,7 @@ class ActivityStack extends ConfigurationContainer {
         final boolean resumeWhilePausing = (next.info.flags & FLAG_RESUME_WHILE_PAUSING) != 0
                 && !lastResumedCanPip;
 
-        boolean pausing = getDisplay().pauseBackStacks(userLeaving, next, false);
+        boolean pausing = display.pauseBackStacks(userLeaving, next, false);
         if (mResumedActivity != null) {
             if (DEBUG_STATES) Slog.d(TAG_STATES,
                     ""resumeTopActivityLocked: Pausing "" + mResumedActivity);
@@ -2759,6 +2759,13 @@ class ActivityStack extends ConfigurationContainer {
             if (next.attachedToProcess()) {
                 next.app.updateProcessInfo(false /* updateServiceConnectionActivities */,
                         true /* activityChange */, false /* updateOomAdj */);
+            } else if (!next.isProcessRunning()) {
+                // Since the start-process is asynchronous, if we already know the process of next
+                // activity isn't running, we can start the process earlier to save the time to wait
+                // for the current activity to be paused.
+                final boolean isTop = this == display.getFocusedStack();
+                mService.startProcessAsync(next, false /* knownToBeDead */, isTop,
+                        isTop ? ""pre-top-activity"" : ""pre-activity"");
             }
             if (lastResumed != null) {
                 lastResumed.setWillCloseOrEnterPip(true);
@@ -2827,7 +2834,7 @@ class ActivityStack extends ConfigurationContainer {
         // that the previous one will be hidden soon.  This way it can know
         // to ignore it when computing the desired screen orientation.
         boolean anim = true;
-        final DisplayContent dc = getDisplay().mDisplayContent;
+        final DisplayContent dc = display.mDisplayContent;
         if (prev != null) {
             if (prev.finishing) {
                 if (DEBUG_TRANSITION) Slog.v(TAG_TRANSITION,
@@ -2984,7 +2991,7 @@ class ActivityStack extends ConfigurationContainer {
                 next.clearOptionsLocked();
                 transaction.setLifecycleStateRequest(
                         ResumeActivityItem.obtain(next.app.getReportedProcState(),
-                                getDisplay().mDisplayContent.isNextTransitionForward()));
+                                dc.isNextTransitionForward()));
                 mService.getLifecycleManager().scheduleTransaction(transaction);
 
                 if (DEBUG_STATES) Slog.d(TAG_STATES, ""resumeTopActivityLocked: Resumed ""
",10,3,ActivityStack::resumeTopActivityInnerLocked
219,fcebbbcf56d14658c7eff35dee872b4e5efdbf50,ActivityStackSupervisor.java,ModificationType.MODIFY,"@@ -995,20 +995,8 @@ public class ActivityStackSupervisor implements RecentTasks.Callbacks {
             r.notifyUnknownVisibilityLaunched();
         }
 
-        try {
-            if (Trace.isTagEnabled(TRACE_TAG_ACTIVITY_MANAGER)) {
-                Trace.traceBegin(TRACE_TAG_ACTIVITY_MANAGER, ""dispatchingStartProcess:""
-                        + r.processName);
-            }
-            // Post message to start process to avoid possible deadlock of calling into AMS with the
-            // ATMS lock held.
-            final Message msg = PooledLambda.obtainMessage(
-                    ActivityManagerInternal::startProcess, mService.mAmInternal, r.processName,
-                    r.info.applicationInfo, knownToBeDead, ""activity"", r.intent.getComponent());
-            mService.mH.sendMessage(msg);
-        } finally {
-            Trace.traceEnd(TRACE_TAG_ACTIVITY_MANAGER);
-        }
+        final boolean isTop = andResume && r.isTopRunningActivity();
+        mService.startProcessAsync(r, knownToBeDead, isTop, isTop ? ""top-activity"" : ""activity"");
     }
 
     boolean checkStartAnyActivityPermission(Intent intent, ActivityInfo aInfo, String resultWho,
",2,14,ActivityStackSupervisor::startSpecificActivityLocked
220,fcebbbcf56d14658c7eff35dee872b4e5efdbf50,ActivityTaskManagerService.java,ModificationType.MODIFY,"@@ -5662,6 +5662,24 @@ public class ActivityTaskManagerService extends IActivityTaskManager.Stub {
         mH.sendMessage(m);
     }
 
+    void startProcessAsync(ActivityRecord activity, boolean knownToBeDead, boolean isTop,
+            String hostingType) {
+        try {
+            if (Trace.isTagEnabled(TRACE_TAG_ACTIVITY_MANAGER)) {
+                Trace.traceBegin(TRACE_TAG_ACTIVITY_MANAGER, ""dispatchingStartProcess:""
+                        + activity.processName);
+            }
+            // Post message to start process to avoid possible deadlock of calling into AMS with the
+            // ATMS lock held.
+            final Message m = PooledLambda.obtainMessage(ActivityManagerInternal::startProcess,
+                    mAmInternal, activity.processName, activity.info.applicationInfo, knownToBeDead,
+                    isTop, hostingType, activity.intent.getComponent());
+            mH.sendMessage(m);
+        } finally {
+            Trace.traceEnd(TRACE_TAG_ACTIVITY_MANAGER);
+        }
+    }
+
     void setBooting(boolean booting) {
         mAmInternal.setBooting(booting);
     }
",18,0,ActivityTaskManagerService::startProcessAsync
221,7a321e6ef9c6ae08abd1d64caec09e0f2df24264,Process.java,ModificationType.MODIFY,"@@ -472,6 +472,40 @@ public class Process {
     private static long sStartElapsedRealtime;
     private static long sStartUptimeMillis;
 
+    /**
+     * Value used to indicate that there is no special information about an application launch.  App
+     * launches with this policy will occur through the primary or secondary Zygote with no special
+     * treatment.
+     *
+     * @hide
+     */
+    public static final int ZYGOTE_POLICY_FLAG_EMPTY = 0;
+
+    /**
+     * Flag used to indicate that an application launch is user-visible and latency sensitive.  Any
+     * launch with this policy will use a Unspecialized App Process Pool if the target Zygote
+     * supports it.
+     *
+     * @hide
+     */
+    public static final int ZYGOTE_POLICY_FLAG_LATENCY_SENSITIVE = 1 << 0;
+
+    /**
+     * Flag used to indicate that the launch is one in a series of app launches that will be
+     * performed in quick succession.  For future use.
+     *
+     * @hide
+     */
+    public static final int ZYGOTE_POLICY_FLAG_BATCH_LAUNCH = 1 << 1;
+
+    /**
+     * Flag used to indicate that the current launch event is for a system process.  All system
+     * processes are equally important, so none of them should be prioritized over the others.
+     *
+     * @hide
+     */
+    public static final int ZYGOTE_POLICY_FLAG_SYSTEM_PROCESS = 1 << 2;
+
     /**
      * State associated with the zygote process.
      * @hide
@@ -511,6 +545,7 @@ public class Process {
      * @param appDataDir null-ok the data directory of the app.
      * @param invokeWith null-ok the command to invoke with.
      * @param packageName null-ok the name of the package this process belongs to.
+     * @param zygotePolicyFlags Flags used to determine how to launch the application
      * @param isTopApp whether the process starts for high priority application.
      * @param zygoteArgs Additional arguments to supply to the zygote process.
      * @return An object that describes the result of the attempt to start the process.
@@ -530,12 +565,13 @@ public class Process {
                                            @Nullable String appDataDir,
                                            @Nullable String invokeWith,
                                            @Nullable String packageName,
+                                           int zygotePolicyFlags,
                                            boolean isTopApp,
                                            @Nullable String[] zygoteArgs) {
         return ZYGOTE_PROCESS.start(processClass, niceName, uid, gid, gids,
                     runtimeFlags, mountExternal, targetSdkVersion, seInfo,
                     abi, instructionSet, appDataDir, invokeWith, packageName,
-                    /*useUsapPool=*/ true, isTopApp, zygoteArgs);
+                    zygotePolicyFlags, isTopApp, zygoteArgs);
     }
 
     /** @hide */
@@ -555,7 +591,8 @@ public class Process {
         return WebViewZygote.getProcess().start(processClass, niceName, uid, gid, gids,
                     runtimeFlags, mountExternal, targetSdkVersion, seInfo,
                     abi, instructionSet, appDataDir, invokeWith, packageName,
-                    /*useUsapPool=*/ false, /*isTopApp=*/ false, zygoteArgs);
+                    /*zygotePolicyFlags=*/ ZYGOTE_POLICY_FLAG_EMPTY, /*isTopApp=*/ false,
+                    zygoteArgs);
     }
 
     /**
",39,2,"Process::start, Process::start, Process::startWebView"
222,7a321e6ef9c6ae08abd1d64caec09e0f2df24264,ZygoteProcess.java,ModificationType.MODIFY,"@@ -16,6 +16,9 @@
 
 package android.os;
 
+import static android.os.Process.ZYGOTE_POLICY_FLAG_LATENCY_SENSITIVE;
+import static android.os.Process.ZYGOTE_POLICY_FLAG_SYSTEM_PROCESS;
+
 import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.annotation.UnsupportedAppUsage;
@@ -117,6 +120,10 @@ public class ZygoteProcess {
         mUsapPoolSecondarySocketAddress =
                 new LocalSocketAddress(Zygote.USAP_POOL_SECONDARY_SOCKET_NAME,
                                        LocalSocketAddress.Namespace.RESERVED);
+
+        // This constructor is used to create the primary and secondary Zygotes, which can support
+        // Unspecialized App Process Pools.
+        mUsapPoolSupported = true;
     }
 
     public ZygoteProcess(LocalSocketAddress primarySocketAddress,
@@ -126,6 +133,10 @@ public class ZygoteProcess {
 
         mUsapPoolSocketAddress = null;
         mUsapPoolSecondarySocketAddress = null;
+
+        // This constructor is used to create the primary and secondary Zygotes, which CAN NOT
+        // support Unspecialized App Process Pools.
+        mUsapPoolSupported = false;
     }
 
     public LocalSocketAddress getPrimarySocketAddress() {
@@ -264,6 +275,14 @@ public class ZygoteProcess {
      */
     private ZygoteState secondaryZygoteState;
 
+    /**
+     * If this Zygote supports the creation and maintenance of a USAP pool.
+     *
+     * Currently only the primary and secondary Zygotes support USAP pools. Any
+     * child Zygotes will be unable to create or use a USAP pool.
+     */
+    private final boolean mUsapPoolSupported;
+
     /**
      * If the USAP pool should be created and used to start applications.
      *
@@ -306,9 +325,9 @@ public class ZygoteProcess {
      * @param appDataDir null-ok the data directory of the app.
      * @param invokeWith null-ok the command to invoke with.
      * @param packageName null-ok the name of the package this process belongs to.
-     * @param zygoteArgs Additional arguments to supply to the zygote process.
+     * @param zygotePolicyFlags Flags used to determine how to launch the application.
      * @param isTopApp Whether the process starts for high priority application.
-     *
+     * @param zygoteArgs Additional arguments to supply to the Zygote process.
      * @return An object that describes the result of the attempt to start the process.
      * @throws RuntimeException on fatal start failure
      */
@@ -323,7 +342,7 @@ public class ZygoteProcess {
                                                   @Nullable String appDataDir,
                                                   @Nullable String invokeWith,
                                                   @Nullable String packageName,
-                                                  boolean useUsapPool,
+                                                  int zygotePolicyFlags,
                                                   boolean isTopApp,
                                                   @Nullable String[] zygoteArgs) {
         // TODO (chriswailes): Is there a better place to check this value?
@@ -335,7 +354,7 @@ public class ZygoteProcess {
             return startViaZygote(processClass, niceName, uid, gid, gids,
                     runtimeFlags, mountExternal, targetSdkVersion, seInfo,
                     abi, instructionSet, appDataDir, invokeWith, /*startChildZygote=*/ false,
-                    packageName, useUsapPool, isTopApp, zygoteArgs);
+                    packageName, zygotePolicyFlags, isTopApp, zygoteArgs);
         } catch (ZygoteStartFailedEx ex) {
             Log.e(LOG_TAG,
                     ""Starting VM process through Zygote failed"");
@@ -381,7 +400,7 @@ public class ZygoteProcess {
      */
     @GuardedBy(""mLock"")
     private Process.ProcessStartResult zygoteSendArgsAndGetResult(
-            ZygoteState zygoteState, boolean useUsapPool, @NonNull ArrayList<String> args)
+            ZygoteState zygoteState, int zygotePolicyFlags, @NonNull ArrayList<String> args)
             throws ZygoteStartFailedEx {
         // Throw early if any of the arguments are malformed. This means we can
         // avoid writing a partial response to the zygote.
@@ -407,7 +426,7 @@ public class ZygoteProcess {
          */
         String msgStr = args.size() + ""\n"" + String.join(""\n"", args) + ""\n"";
 
-        if (useUsapPool && mUsapPoolEnabled && canAttemptUsap(args)) {
+        if (shouldAttemptUsapLaunch(zygotePolicyFlags, args)) {
             try {
                 return attemptUsapSendArgsAndGetResult(zygoteState, msgStr);
             } catch (IOException ex) {
@@ -478,7 +497,43 @@ public class ZygoteProcess {
     }
 
     /**
-     * Flags that may not be passed to a USAP.
+     * Test various member properties and parameters to determine if a launch event should be
+     * handled using an Unspecialized App Process Pool or not.
+     *
+     * @param zygotePolicyFlags Policy flags indicating special behavioral observations about the
+     *                          Zygote command
+     * @param args Arguments that will be passed to the Zygote
+     * @return If the command should be sent to a USAP Pool member or an actual Zygote
+     */
+    private boolean shouldAttemptUsapLaunch(int zygotePolicyFlags, ArrayList<String> args) {
+        return mUsapPoolSupported
+                && mUsapPoolEnabled
+                && policySpecifiesUsapPoolLaunch(zygotePolicyFlags)
+                && commandSupportedByUsap(args);
+    }
+
+    /**
+     * Tests a Zygote policy flag set for various properties that determine if it is eligible for
+     * being handled by an Unspecialized App Process Pool.
+     *
+     * @param zygotePolicyFlags Policy flags indicating special behavioral observations about the
+     *                          Zygote command
+     * @return If the policy allows for use of a USAP pool
+     */
+    private static boolean policySpecifiesUsapPoolLaunch(int zygotePolicyFlags) {
+        /*
+         * Zygote USAP Pool Policy: Launch the new process from the USAP Pool iff the launch event
+         * is latency sensitive but *NOT* a system process.  All system processes are equally
+         * important so we don't want to prioritize one over another.
+         */
+        return (zygotePolicyFlags
+                & (ZYGOTE_POLICY_FLAG_SYSTEM_PROCESS | ZYGOTE_POLICY_FLAG_LATENCY_SENSITIVE))
+                == ZYGOTE_POLICY_FLAG_LATENCY_SENSITIVE;
+    }
+
+    /**
+     * Flags that may not be passed to a USAP.  These may appear as prefixes to individual Zygote
+     * arguments.
      */
     private static final String[] INVALID_USAP_FLAGS = {
         ""--query-abi-list"",
@@ -495,10 +550,11 @@ public class ZygoteProcess {
 
     /**
      * Tests a command list to see if it is valid to send to a USAP.
+     *
      * @param args  Zygote/USAP command arguments
      * @return  True if the command can be passed to a USAP; false otherwise
      */
-    private static boolean canAttemptUsap(ArrayList<String> args) {
+    private static boolean commandSupportedByUsap(ArrayList<String> args) {
         for (String flag : args) {
             for (String badFlag : INVALID_USAP_FLAGS) {
                 if (flag.startsWith(badFlag)) {
@@ -536,6 +592,7 @@ public class ZygoteProcess {
      * @param startChildZygote Start a sub-zygote. This creates a new zygote process
      * that has its state cloned from this zygote process.
      * @param packageName null-ok the name of the package this process belongs to.
+     * @param zygotePolicyFlags Flags used to determine how to launch the application.
      * @param isTopApp Whether the process starts for high priority application.
      * @param extraArgs Additional arguments to supply to the zygote process.
      * @return An object that describes the result of the attempt to start the process.
@@ -554,7 +611,7 @@ public class ZygoteProcess {
                                                       @Nullable String invokeWith,
                                                       boolean startChildZygote,
                                                       @Nullable String packageName,
-                                                      boolean useUsapPool,
+                                                      int zygotePolicyFlags,
                                                       boolean isTopApp,
                                                       @Nullable String[] extraArgs)
                                                       throws ZygoteStartFailedEx {
@@ -641,7 +698,7 @@ public class ZygoteProcess {
             // The USAP pool can not be used if the application will not use the systems graphics
             // driver.  If that driver is requested use the Zygote application start path.
             return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi),
-                                              useUsapPool,
+                                              zygotePolicyFlags,
                                               argsForZygote);
         }
     }
@@ -671,6 +728,10 @@ public class ZygoteProcess {
     private long mLastPropCheckTimestamp = 0;
 
     private boolean fetchUsapPoolEnabledPropWithMinInterval() {
+        // If this Zygote doesn't support USAPs there is no need to fetch any
+        // properties.
+        if (!mUsapPoolSupported) return false;
+
         final long currentTimestamp = SystemClock.elapsedRealtime();
 
         if (SystemProperties.get(""dalvik.vm.boot-image"", """").endsWith(""apex.art"")) {
@@ -1152,7 +1213,7 @@ public class ZygoteProcess {
                     gids, runtimeFlags, 0 /* mountExternal */, 0 /* targetSdkVersion */, seInfo,
                     abi, instructionSet, null /* appDataDir */, null /* invokeWith */,
                     true /* startChildZygote */, null /* packageName */,
-                    false /* useUsapPool */, false /* isTopApp */,
+                    ZYGOTE_POLICY_FLAG_SYSTEM_PROCESS /* zygotePolicyFlags */, false /* isTopApp */,
                     extraArgs);
         } catch (ZygoteStartFailedEx ex) {
             throw new RuntimeException(""Starting child-zygote through Zygote failed"", ex);
",72,11,"ZygoteProcess::zygoteSendArgsAndGetResult, ZygoteProcess::startViaZygote, ZygoteProcess::start, ZygoteProcess::startChildZygote, ZygoteProcess::zygoteSendArgsAndGetResult, ZygoteProcess::canAttemptUsap, ZygoteProcess::ZygoteProcess, ZygoteProcess::shouldAttemptUsapLaunch, ZygoteProcess::ZygoteProcess, ZygoteProcess::policySpecifiesUsapPoolLaunch, ZygoteProcess::startViaZygote, ZygoteProcess::start, ZygoteProcess::fetchUsapPoolEnabledPropWithMinInterval, ZygoteProcess::commandSupportedByUsap"
223,7a321e6ef9c6ae08abd1d64caec09e0f2df24264,ActiveServices.java,ModificationType.MODIFY,"@@ -18,6 +18,7 @@ package com.android.server.am;
 
 import static android.content.pm.PackageManager.PERMISSION_GRANTED;
 import static android.content.pm.ServiceInfo.FOREGROUND_SERVICE_TYPE_MANIFEST;
+import static android.os.Process.ZYGOTE_POLICY_FLAG_EMPTY;
 
 import static com.android.server.am.ActivityManagerDebugConfig.DEBUG_BACKGROUND_CHECK;
 import static com.android.server.am.ActivityManagerDebugConfig.DEBUG_FOREGROUND_SERVICE;
@@ -2617,8 +2618,10 @@ public final class ActiveServices {
         // Not running -- get it started, and enqueue this service record
         // to be executed when the app comes up.
         if (app == null && !permissionsReviewRequired) {
+            // TODO (chriswailes): Change the Zygote policy flags based on if the launch-for-service
+            //  was initiated from a notification tap or not.
             if ((app=mAm.startProcessLocked(procName, r.appInfo, true, intentFlags,
-                    hostingRecord, false, isolated, false)) == null) {
+                    hostingRecord, ZYGOTE_POLICY_FLAG_EMPTY, false, isolated, false)) == null) {
                 String msg = ""Unable to launch app ""
                         + r.appInfo.packageName + ""/""
                         + r.appInfo.uid + "" for service ""
",4,1,ActiveServices::bringUpServiceLocked
224,7a321e6ef9c6ae08abd1d64caec09e0f2df24264,ActivityManagerService.java,ModificationType.MODIFY,"@@ -66,6 +66,10 @@ import static android.os.Process.SHELL_UID;
 import static android.os.Process.SIGNAL_USR1;
 import static android.os.Process.SYSTEM_UID;
 import static android.os.Process.THREAD_PRIORITY_FOREGROUND;
+import static android.os.Process.ZYGOTE_POLICY_FLAG_BATCH_LAUNCH;
+import static android.os.Process.ZYGOTE_POLICY_FLAG_EMPTY;
+import static android.os.Process.ZYGOTE_POLICY_FLAG_LATENCY_SENSITIVE;
+import static android.os.Process.ZYGOTE_POLICY_FLAG_SYSTEM_PROCESS;
 import static android.os.Process.ZYGOTE_PROCESS;
 import static android.os.Process.getTotalMemory;
 import static android.os.Process.isThreadInProcess;
@@ -3007,7 +3011,7 @@ public class ActivityManagerService extends IActivityManager.Stub
             info.targetSdkVersion = Build.VERSION.SDK_INT;
             ProcessRecord proc = mProcessList.startProcessLocked(processName, info /* info */,
                     false /* knownToBeDead */, 0 /* intentFlags */,
-                    sNullHostingRecord  /* hostingRecord */,
+                    sNullHostingRecord  /* hostingRecord */, ZYGOTE_POLICY_FLAG_EMPTY,
                     true /* allowWhileBooting */, true /* isolated */,
                     uid, true /* keepIfLarge */, abiOverride, entryPoint, entryPointArgs,
                     crashHandler);
@@ -3018,12 +3022,12 @@ public class ActivityManagerService extends IActivityManager.Stub
     @GuardedBy(""this"")
     final ProcessRecord startProcessLocked(String processName,
             ApplicationInfo info, boolean knownToBeDead, int intentFlags,
-            HostingRecord hostingRecord, boolean allowWhileBooting,
+            HostingRecord hostingRecord, int zygotePolicyFlags, boolean allowWhileBooting,
             boolean isolated, boolean keepIfLarge) {
         return mProcessList.startProcessLocked(processName, info, knownToBeDead, intentFlags,
-                hostingRecord, allowWhileBooting, isolated, 0 /* isolatedUid */, keepIfLarge,
-                null /* ABI override */, null /* entryPoint */, null /* entryPointArgs */,
-                null /* crashHandler */);
+                hostingRecord, zygotePolicyFlags, allowWhileBooting, isolated, 0 /* isolatedUid */,
+                keepIfLarge, null /* ABI override */, null /* entryPoint */,
+                null /* entryPointArgs */, null /* crashHandler */);
     }
 
     boolean isAllowedWhileBooting(ApplicationInfo ai) {
@@ -4843,7 +4847,8 @@ public class ActivityManagerService extends IActivityManager.Stub
         } catch (RemoteException e) {
             app.resetPackageList(mProcessStats);
             mProcessList.startProcessLocked(app,
-                    new HostingRecord(""link fail"", processName));
+                    new HostingRecord(""link fail"", processName),
+                    ZYGOTE_POLICY_FLAG_EMPTY);
             return false;
         }
 
@@ -5082,7 +5087,8 @@ public class ActivityManagerService extends IActivityManager.Stub
 
             app.resetPackageList(mProcessStats);
             app.unlinkDeathRecipient();
-            mProcessList.startProcessLocked(app, new HostingRecord(""bind-fail"", processName));
+            mProcessList.startProcessLocked(app, new HostingRecord(""bind-fail"", processName),
+                    ZYGOTE_POLICY_FLAG_EMPTY);
             return false;
         }
 
@@ -5260,7 +5266,9 @@ public class ActivityManagerService extends IActivityManager.Stub
                 for (int ip=0; ip<NP; ip++) {
                     if (DEBUG_PROCESSES) Slog.v(TAG_PROCESSES, ""Starting process on hold: ""
                             + procs.get(ip));
-                    mProcessList.startProcessLocked(procs.get(ip), new HostingRecord(""on-hold""));
+                    mProcessList.startProcessLocked(procs.get(ip),
+                            new HostingRecord(""on-hold""),
+                            ZYGOTE_POLICY_FLAG_BATCH_LAUNCH);
                 }
             }
             if (mFactoryTest == FactoryTest.FACTORY_TEST_LOW_LEVEL) {
@@ -7034,8 +7042,9 @@ public class ActivityManagerService extends IActivityManager.Stub
                             proc = startProcessLocked(cpi.processName,
                                     cpr.appInfo, false, 0,
                                     new HostingRecord(""content provider"",
-                                    new ComponentName(cpi.applicationInfo.packageName,
-                                            cpi.name)), false, false, false);
+                                        new ComponentName(cpi.applicationInfo.packageName,
+                                                cpi.name)),
+                                    ZYGOTE_POLICY_FLAG_EMPTY, false, false, false);
                             checkTime(startTime, ""getContentProviderImpl: after start process"");
                             if (proc == null) {
                                 Slog.w(TAG, ""Unable to launch app ""
@@ -7562,7 +7571,8 @@ public class ActivityManagerService extends IActivityManager.Stub
                         .getPersistentApplications(STOCK_PM_FLAGS | matchFlags).getList();
                 for (ApplicationInfo app : apps) {
                     if (!""android"".equals(app.packageName)) {
-                        addAppLocked(app, null, false, null /* ABI override */);
+                        addAppLocked(app, null, false, null /* ABI override */,
+                                ZYGOTE_POLICY_FLAG_BATCH_LAUNCH);
                     }
                 }
             } catch (RemoteException ex) {
@@ -7745,15 +7755,16 @@ public class ActivityManagerService extends IActivityManager.Stub
 
     @GuardedBy(""this"")
     final ProcessRecord addAppLocked(ApplicationInfo info, String customProcess, boolean isolated,
-            String abiOverride) {
+            String abiOverride, int zygotePolicyFlags) {
         return addAppLocked(info, customProcess, isolated, false /* disableHiddenApiChecks */,
-                false /* mountExtStorageFull */, abiOverride);
+                false /* mountExtStorageFull */, abiOverride, zygotePolicyFlags);
     }
 
     // TODO: Move to ProcessList?
     @GuardedBy(""this"")
     final ProcessRecord addAppLocked(ApplicationInfo info, String customProcess, boolean isolated,
-            boolean disableHiddenApiChecks, boolean mountExtStorageFull, String abiOverride) {
+            boolean disableHiddenApiChecks, boolean mountExtStorageFull, String abiOverride,
+            int zygotePolicyFlags) {
         ProcessRecord app;
         if (!isolated) {
             app = getProcessRecordLocked(customProcess != null ? customProcess : info.processName,
@@ -7788,7 +7799,8 @@ public class ActivityManagerService extends IActivityManager.Stub
             mPersistentStartingProcesses.add(app);
             mProcessList.startProcessLocked(app, new HostingRecord(""added application"",
                     customProcess != null ? customProcess : app.processName),
-                    disableHiddenApiChecks, mountExtStorageFull, abiOverride);
+                    zygotePolicyFlags, disableHiddenApiChecks,
+                    mountExtStorageFull, abiOverride);
         }
 
         return app;
@@ -13811,7 +13823,8 @@ public class ActivityManagerService extends IActivityManager.Stub
             mProcessList.addProcessNameLocked(app);
             app.pendingStart = false;
             mProcessList.startProcessLocked(app,
-                    new HostingRecord(""restart"", app.processName));
+                    new HostingRecord(""restart"", app.processName),
+                    ZYGOTE_POLICY_FLAG_EMPTY);
             return true;
         } else if (app.pid > 0 && app.pid != MY_PID) {
             // Goodbye!
@@ -14169,7 +14182,7 @@ public class ActivityManagerService extends IActivityManager.Stub
             ProcessRecord proc = startProcessLocked(app.processName, app,
                     false, 0,
                     new HostingRecord(""backup"", hostingName),
-                    false, false, false);
+                    ZYGOTE_POLICY_FLAG_SYSTEM_PROCESS, false, false, false);
             if (proc == null) {
                 Slog.e(TAG, ""Unable to start backup agent process "" + r);
                 return false;
@@ -15782,7 +15795,8 @@ public class ActivityManagerService extends IActivityManager.Stub
             }
 
             ProcessRecord app = addAppLocked(ai, defProcess, false, disableHiddenApiChecks,
-                    mountExtStorageFull, abiOverride);
+                    mountExtStorageFull, abiOverride,
+                    ZYGOTE_POLICY_FLAG_EMPTY);
             app.setActiveInstrumentation(activeInstr);
             activeInstr.mFinished = false;
             activeInstr.mRunningProcesses.add(app);
@@ -17258,7 +17272,8 @@ public class ActivityManagerService extends IActivityManager.Stub
                 mProcessList.mRemovedProcesses.remove(i);
 
                 if (app.isPersistent()) {
-                    addAppLocked(app.info, null, false, null /* ABI override */);
+                    addAppLocked(app.info, null, false, null /* ABI override */,
+                            ZYGOTE_POLICY_FLAG_BATCH_LAUNCH);
                 }
             }
         }
@@ -18402,8 +18417,8 @@ public class ActivityManagerService extends IActivityManager.Stub
                     // preempted by other processes before attaching the process of top app.
                     startProcessLocked(processName, info, knownToBeDead, 0 /* intentFlags */,
                             new HostingRecord(hostingType, hostingName, isTop),
-                            false /* allowWhileBooting */, false /* isolated */,
-                            true /* keepIfLarge */);
+                            ZYGOTE_POLICY_FLAG_LATENCY_SENSITIVE, false /* allowWhileBooting */,
+                            false /* isolated */, true /* keepIfLarge */);
                 }
             } finally {
                 Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
",36,21,"ActivityManagerService::startProcessLocked, ActivityManagerService::getContentProviderImpl, ActivityManagerService::startIsolatedProcess, ActivityManagerService::LocalService::startProcess, ActivityManagerService::addAppLocked, ActivityManagerService::startInstrumentation, ActivityManagerService::trimApplicationsLocked, ActivityManagerService::attachApplicationLocked, ActivityManagerService::bindBackupAgent, ActivityManagerService::addAppLocked, ActivityManagerService::addAppLocked, ActivityManagerService::cleanUpApplicationRecordLocked, ActivityManagerService::startPersistentApps, ActivityManagerService::startProcessLocked, ActivityManagerService::finishBooting, ActivityManagerService::addAppLocked"
225,7a321e6ef9c6ae08abd1d64caec09e0f2df24264,BroadcastQueue.java,ModificationType.MODIFY,"@@ -16,6 +16,9 @@
 
 package com.android.server.am;
 
+import static android.os.Process.ZYGOTE_POLICY_FLAG_EMPTY;
+import static android.os.Process.ZYGOTE_POLICY_FLAG_LATENCY_SENSITIVE;
+
 import static com.android.server.am.ActivityManagerDebugConfig.*;
 
 import android.app.ActivityManager;
@@ -1586,7 +1589,9 @@ public final class BroadcastQueue {
                     + receiverUid);
         }
 
-        if (brOptions != null && brOptions.getTemporaryAppWhitelistDuration() > 0) {
+        final boolean isActivityCapable =
+                (brOptions != null && brOptions.getTemporaryAppWhitelistDuration() > 0);
+        if (isActivityCapable) {
             scheduleTempWhitelistLocked(receiverUid,
                     brOptions.getTemporaryAppWhitelistDuration(), r);
         }
@@ -1641,6 +1646,7 @@ public final class BroadcastQueue {
                 info.activityInfo.applicationInfo, true,
                 r.intent.getFlags() | Intent.FLAG_FROM_BACKGROUND,
                 new HostingRecord(""broadcast"", r.curComponent),
+                isActivityCapable ? ZYGOTE_POLICY_FLAG_LATENCY_SENSITIVE : ZYGOTE_POLICY_FLAG_EMPTY,
                 (r.intent.getFlags()&Intent.FLAG_RECEIVER_BOOT_UPGRADE) != 0, false, false))
                         == null) {
             // Ah, this recipient is unavailable.  Finish it if necessary,
",7,1,BroadcastQueue::processNextBroadcastLocked
226,7a321e6ef9c6ae08abd1d64caec09e0f2df24264,ProcessList.java,ModificationType.MODIFY,"@@ -22,6 +22,7 @@ import static android.app.ActivityThread.PROC_START_SEQ_IDENT;
 import static android.content.pm.PackageManager.MATCH_DIRECT_BOOT_AUTO;
 import static android.os.Process.SYSTEM_UID;
 import static android.os.Process.THREAD_PRIORITY_BACKGROUND;
+import static android.os.Process.ZYGOTE_POLICY_FLAG_EMPTY;
 import static android.os.Process.getFreeMemory;
 import static android.os.Process.getTotalMemory;
 import static android.os.Process.killProcessQuiet;
@@ -1424,8 +1425,8 @@ public final class ProcessList {
      */
     @GuardedBy(""mService"")
     boolean startProcessLocked(ProcessRecord app, HostingRecord hostingRecord,
-            boolean disableHiddenApiChecks, boolean mountExtStorageFull,
-            String abiOverride) {
+            int zygotePolicyFlags, boolean disableHiddenApiChecks,
+            boolean mountExtStorageFull, String abiOverride) {
         if (app.pendingStart) {
             return true;
         }
@@ -1518,8 +1519,7 @@ public final class ProcessList {
             }
             // Run the app in safe mode if its manifest requests so or the
             // system is booted in safe mode.
-            if ((app.info.flags & ApplicationInfo.FLAG_VM_SAFE_MODE) != 0 ||
-                    mService.mSafeMode == true) {
+            if ((app.info.flags & ApplicationInfo.FLAG_VM_SAFE_MODE) != 0 || mService.mSafeMode) {
                 runtimeFlags |= Zygote.DEBUG_ENABLE_SAFEMODE;
             }
             if ((app.info.privateFlags & ApplicationInfo.PRIVATE_FLAG_PROFILEABLE_BY_SHELL) != 0) {
@@ -1617,8 +1617,8 @@ public final class ProcessList {
             final String entryPoint = ""android.app.ActivityThread"";
 
             return startProcessLocked(hostingRecord, entryPoint, app, uid, gids,
-                    runtimeFlags, mountExternal, seInfo, requiredAbi, instructionSet, invokeWith,
-                    startTime);
+                    runtimeFlags, zygotePolicyFlags, mountExternal, seInfo, requiredAbi,
+                    instructionSet, invokeWith, startTime);
         } catch (RuntimeException e) {
             Slog.e(ActivityManagerService.TAG, ""Failure starting process "" + app.processName, e);
 
@@ -1635,9 +1635,8 @@ public final class ProcessList {
     }
 
     @GuardedBy(""mService"")
-    boolean startProcessLocked(HostingRecord hostingRecord,
-            String entryPoint,
-            ProcessRecord app, int uid, int[] gids, int runtimeFlags, int mountExternal,
+    boolean startProcessLocked(HostingRecord hostingRecord, String entryPoint, ProcessRecord app,
+            int uid, int[] gids, int runtimeFlags, int zygotePolicyFlags, int mountExternal,
             String seInfo, String requiredAbi, String instructionSet, String invokeWith,
             long startTime) {
         app.pendingStart = true;
@@ -1664,8 +1663,9 @@ public final class ProcessList {
             mService.mProcStartHandler.post(() -> {
                 try {
                     final Process.ProcessStartResult startResult = startProcess(app.hostingRecord,
-                            entryPoint, app, app.startUid, gids, runtimeFlags, mountExternal,
-                            app.seInfo, requiredAbi, instructionSet, invokeWith, app.startTime);
+                            entryPoint, app, app.startUid, gids, runtimeFlags, zygotePolicyFlags,
+                            mountExternal, app.seInfo, requiredAbi, instructionSet, invokeWith,
+                            app.startTime);
                     synchronized (mService) {
                         handleProcessStartedLocked(app, startResult, startSeq);
                     }
@@ -1686,8 +1686,8 @@ public final class ProcessList {
             try {
                 final Process.ProcessStartResult startResult = startProcess(hostingRecord,
                         entryPoint, app,
-                        uid, gids, runtimeFlags, mountExternal, seInfo, requiredAbi, instructionSet,
-                        invokeWith, startTime);
+                        uid, gids, runtimeFlags, zygotePolicyFlags, mountExternal, seInfo,
+                        requiredAbi, instructionSet, invokeWith, startTime);
                 handleProcessStartedLocked(app, startResult.pid, startResult.usingWrapper,
                         startSeq, false);
             } catch (RuntimeException e) {
@@ -1794,9 +1794,9 @@ public final class ProcessList {
     }
 
     private Process.ProcessStartResult startProcess(HostingRecord hostingRecord, String entryPoint,
-            ProcessRecord app, int uid, int[] gids, int runtimeFlags, int mountExternal,
-            String seInfo, String requiredAbi, String instructionSet, String invokeWith,
-            long startTime) {
+            ProcessRecord app, int uid, int[] gids, int runtimeFlags, int zygotePolicyFlags,
+            int mountExternal, String seInfo, String requiredAbi, String instructionSet,
+            String invokeWith, long startTime) {
         try {
             Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""Start proc: "" +
                     app.processName);
@@ -1823,13 +1823,14 @@ public final class ProcessList {
                         app.processName, uid, uid, gids, runtimeFlags, mountExternal,
                         app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,
                         app.info.dataDir, null, app.info.packageName,
-                        /*useUsapPool=*/ false, isTopApp,
+                        /*zygotePolicyFlags=*/ ZYGOTE_POLICY_FLAG_EMPTY, isTopApp,
                         new String[]{PROC_START_SEQ_IDENT + app.startSeq});
             } else {
                 startResult = Process.start(entryPoint,
                         app.processName, uid, uid, gids, runtimeFlags, mountExternal,
                         app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,
-                        app.info.dataDir, invokeWith, app.info.packageName, isTopApp,
+                        app.info.dataDir, invokeWith, app.info.packageName, zygotePolicyFlags,
+                        isTopApp,
                         new String[]{PROC_START_SEQ_IDENT + app.startSeq});
             }
             checkSlow(startTime, ""startProcess: returned from zygote!"");
@@ -1840,22 +1841,24 @@ public final class ProcessList {
     }
 
     @GuardedBy(""mService"")
-    final void startProcessLocked(ProcessRecord app, HostingRecord hostingRecord) {
-        startProcessLocked(app, hostingRecord, null /* abiOverride */);
+    void startProcessLocked(ProcessRecord app, HostingRecord hostingRecord, int zygotePolicyFlags) {
+        startProcessLocked(app, hostingRecord, zygotePolicyFlags, null /* abiOverride */);
     }
 
     @GuardedBy(""mService"")
     final boolean startProcessLocked(ProcessRecord app, HostingRecord hostingRecord,
-            String abiOverride) {
-        return startProcessLocked(app, hostingRecord,
-                false /* disableHiddenApiChecks */, false /* mountExtStorageFull */, abiOverride);
+            int zygotePolicyFlags, String abiOverride) {
+        return startProcessLocked(app, hostingRecord, zygotePolicyFlags,
+                false /* disableHiddenApiChecks */,
+                false /* mountExtStorageFull */, abiOverride);
     }
 
     @GuardedBy(""mService"")
     final ProcessRecord startProcessLocked(String processName, ApplicationInfo info,
             boolean knownToBeDead, int intentFlags, HostingRecord hostingRecord,
-            boolean allowWhileBooting, boolean isolated, int isolatedUid, boolean keepIfLarge,
-            String abiOverride, String entryPoint, String[] entryPointArgs, Runnable crashHandler) {
+            int zygotePolicyFlags, boolean allowWhileBooting, boolean isolated, int isolatedUid,
+            boolean keepIfLarge, String abiOverride, String entryPoint, String[] entryPointArgs,
+            Runnable crashHandler) {
         long startTime = SystemClock.elapsedRealtime();
         ProcessRecord app;
         if (!isolated) {
@@ -1956,7 +1959,8 @@ public final class ProcessList {
         }
 
         checkSlow(startTime, ""startProcess: stepping in to startProcess"");
-        final boolean success = startProcessLocked(app, hostingRecord, abiOverride);
+        final boolean success =
+                startProcessLocked(app, hostingRecord, zygotePolicyFlags, abiOverride);
         checkSlow(startTime, ""startProcess: done starting proc!"");
         return success ? app : null;
     }
@@ -2264,7 +2268,8 @@ public final class ProcessList {
             mService.handleAppDiedLocked(app, willRestart, allowRestart);
             if (willRestart) {
                 removeLruProcessLocked(app);
-                mService.addAppLocked(app.info, null, false, null /* ABI override */);
+                mService.addAppLocked(app.info, null, false, null /* ABI override */,
+                        ZYGOTE_POLICY_FLAG_EMPTY);
             }
         } else {
             mRemovedProcesses.add(app);
",32,27,"ProcessList::startProcessLocked, ProcessList::startProcessLocked, ProcessList::startProcess, ProcessList::startProcess, ProcessList::startProcessLocked, ProcessList::removeProcessLocked, ProcessList::startProcessLocked, ProcessList::startProcessLocked, ProcessList::startProcessLocked, ProcessList::startProcessLocked, ProcessList::startProcessLocked, ProcessList::startProcessLocked, ProcessList::startProcessLocked"
227,5af935ce42e1741071729adc0a61047d76ad8d5f,ProcessCpuTracker.java,ModificationType.MODIFY,"@@ -878,8 +878,11 @@ public class ProcessCpuTracker {
 
     private void getName(Stats st, String cmdlineFile) {
         String newName = st.name;
-        if (st.name == null || st.name.equals(""app_process"")
-                || st.name.equals(""<pre-initialized>"")) {
+        if (st.name == null
+                || st.name.equals(""app_process"")
+                || st.name.equals(""<pre-initialized>"")
+                || st.name.equals(""usap32"")
+                || st.name.equals(""usap64"")) {
             String cmdName = ProcStatsUtil.readTerminatedProcFile(cmdlineFile, (byte) '\0');
             if (cmdName != null && cmdName.length() > 1) {
                 newName = cmdName;
",5,2,ProcessCpuTracker::getName
228,63f827f0a7505d527500f7f9ad3723c019831c87,PointerLocationView.java,ModificationType.MODIFY,"@@ -367,7 +367,7 @@ public class PointerLocationView extends View implements InputDeviceListener,
                 }
                 if (haveLast) {
                     canvas.drawLine(lastX, lastY, x, y, mPathPaint);
-                    final Paint paint = ps.mTraceCurrent[i] ? mCurrentPointPaint : mPaint;
+                    final Paint paint = ps.mTraceCurrent[i - 1] ? mCurrentPointPaint : mPaint;
                     canvas.drawPoint(lastX, lastY, paint);
                     drawn = true;
                 }
",1,1,PointerLocationView::onDraw
229,1c7b8e566b671ad0d099e4e4e509a9ab4e00377a,VolumeDialogImpl.java,ModificationType.MODIFY,"@@ -23,6 +23,7 @@ import static android.media.AudioManager.RINGER_MODE_VIBRATE;
 import static android.media.AudioManager.STREAM_ACCESSIBILITY;
 import static android.media.AudioManager.STREAM_ALARM;
 import static android.media.AudioManager.STREAM_MUSIC;
+import static android.media.AudioManager.STREAM_NOTIFICATION;
 import static android.media.AudioManager.STREAM_RING;
 import static android.media.AudioManager.STREAM_VOICE_CALL;
 import static android.view.View.ACCESSIBILITY_LIVE_REGION_POLITE;
@@ -853,6 +854,7 @@ public class VolumeDialogImpl implements VolumeDialog,
 
             if (row.defaultStream) {
                 return activeRow.stream == STREAM_RING
+                        || activeRow.stream == STREAM_NOTIFICATION
                         || activeRow.stream == STREAM_ALARM
                         || activeRow.stream == STREAM_VOICE_CALL
                         || activeRow.stream == STREAM_ACCESSIBILITY
",2,0,VolumeDialogImpl::shouldBeVisibleH
230,055bb26fb55bdfb59cd308f101e633920f1b5a83,VolumeDialogImpl.java,ModificationType.MODIFY,"@@ -815,11 +815,11 @@ public class VolumeDialogImpl implements VolumeDialog,
                 .withEndAction(() -> mHandler.postDelayed(() -> {
                     mDialog.dismiss();
                     tryToRemoveCaptionsTooltip();
+                    mController.notifyVisible(false);
                 }, 50));
         animator.translationX(getAnimatorX());
         animator.start();
         checkODICaptionsTooltip(true);
-        mController.notifyVisible(false);
         synchronized (mSafetyWarningLock) {
             if (mSafetyWarning != null) {
                 if (D.BUG) Log.d(TAG, ""SafetyWarning dismissed"");
",1,1,VolumeDialogImpl::dismissH
231,7a4627c58fa6b057144befd81d51d83889de4e5b,VolumeDialogImpl.java,ModificationType.MODIFY,"@@ -32,6 +32,7 @@ import static android.view.View.INVISIBLE;
 import static android.view.View.VISIBLE;
 import static android.view.ViewGroup.LayoutParams.WRAP_CONTENT;
 
+import static com.android.settingslib.media.MediaOutputSliceConstants.ACTION_MEDIA_OUTPUT;
 import static com.android.systemui.volume.Events.DISMISS_REASON_SETTINGS_CLICKED;
 
 import android.animation.ObjectAnimator;
@@ -39,6 +40,8 @@ import android.annotation.SuppressLint;
 import android.app.ActivityManager;
 import android.app.Dialog;
 import android.app.KeyguardManager;
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothProfile;
 import android.content.ContentResolver;
 import android.content.Context;
 import android.content.DialogInterface;
@@ -96,6 +99,7 @@ import com.android.systemui.plugins.VolumeDialog;
 import com.android.systemui.plugins.VolumeDialogController;
 import com.android.systemui.plugins.VolumeDialogController.State;
 import com.android.systemui.plugins.VolumeDialogController.StreamState;
+import com.android.systemui.statusbar.phone.ExpandableIndicator;
 import com.android.systemui.statusbar.policy.AccessibilityManagerWrapper;
 import com.android.systemui.statusbar.policy.ConfigurationController;
 import com.android.systemui.statusbar.policy.DeviceProvisionedController;
@@ -144,8 +148,10 @@ public class VolumeDialogImpl implements VolumeDialog,
     private ImageButton mRingerIcon;
     private ViewGroup mODICaptionsView;
     private CaptionsToggleImageButton mODICaptionsIcon;
-    private View mSettingsView;
-    private ImageButton mSettingsIcon;
+    private View mMediaOutputView;
+    private ImageButton mMediaOutputIcon;
+    private View mExpandRowsView;
+    private ExpandableIndicator mExpandRows;
     private FrameLayout mZenIcon;
     private final List<VolumeRow> mRows = new ArrayList<>();
     private ConfigurableTexts mConfigurableTexts;
@@ -175,6 +181,8 @@ public class VolumeDialogImpl implements VolumeDialog,
     // Volume panel placement left or right
     private boolean mVolumePanelOnLeft;
 
+    private boolean mExpanded;
+
     public VolumeDialogImpl(Context context) {
         mContext =
                 new ContextThemeWrapper(context, R.style.qs_theme);
@@ -221,6 +229,7 @@ public class VolumeDialogImpl implements VolumeDialog,
         mConfigurableTexts = new ConfigurableTexts(mContext);
         mHovering = false;
         mShowing = false;
+        mExpanded = false;
         mWindow = mDialog.getWindow();
         mWindow.requestFeature(Window.FEATURE_NO_TITLE);
         mWindow.setBackgroundDrawable(new ColorDrawable(Color.TRANSPARENT));
@@ -293,8 +302,11 @@ public class VolumeDialogImpl implements VolumeDialog,
             mODICaptionsTooltipViewStub = null;
         }
 
-        mSettingsView = mDialog.findViewById(R.id.settings_container);
-        mSettingsIcon = mDialog.findViewById(R.id.settings);
+        mMediaOutputView = mDialog.findViewById(R.id.media_output_container);
+        mMediaOutputIcon = mDialog.findViewById(R.id.media_output);
+
+        mExpandRowsView = mDialog.findViewById(R.id.expandable_indicator_container);
+        mExpandRows = mDialog.findViewById(R.id.expandable_indicator);
 
         if (mRows.isEmpty()) {
             if (!AudioSystem.isSingleVolume(mContext)) {
@@ -312,7 +324,7 @@ public class VolumeDialogImpl implements VolumeDialog,
                             R.drawable.ic_volume_notification_mute, true, false);
                 }
                 addRow(STREAM_ALARM,
-                        R.drawable.ic_alarm, R.drawable.ic_volume_alarm_mute, true, false);
+                        R.drawable.ic_volume_alarm, R.drawable.ic_volume_alarm_mute, true, false);
                 addRow(AudioManager.STREAM_VOICE_CALL,
                         com.android.internal.R.drawable.ic_phone,
                         com.android.internal.R.drawable.ic_phone, false, false);
@@ -405,11 +417,7 @@ public class VolumeDialogImpl implements VolumeDialog,
         if (D.BUG) Slog.d(TAG, ""Adding row for stream "" + stream);
         VolumeRow row = new VolumeRow();
         initRow(row, stream, iconRes, iconMuteRes, important, defaultStream);
-        if (mVolumePanelOnLeft) {
-            mDialogRowsView.addView(row.view, 0);
-        } else {
-            mDialogRowsView.addView(row.view);
-        }
+        mDialogRowsView.addView(row.view, mVolumePanelOnLeft ? -1 : 0);
         mRows.add(row);
     }
 
@@ -419,11 +427,7 @@ public class VolumeDialogImpl implements VolumeDialog,
             final VolumeRow row = mRows.get(i);
             initRow(row, row.stream, row.iconRes, row.iconMuteRes, row.important,
                     row.defaultStream);
-            if (mVolumePanelOnLeft) {
-                mDialogRowsView.addView(row.view, 0);
-            } else {
-                mDialogRowsView.addView(row.view);
-            }
+            mDialogRowsView.addView(row.view, mVolumePanelOnLeft ? -1 : 0);
             updateVolumeRowH(row);
         }
     }
@@ -522,22 +526,46 @@ public class VolumeDialogImpl implements VolumeDialog,
         }
     }
 
+    private static boolean isBluetoothA2dpConnected() {
+        BluetoothAdapter mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
+        return mBluetoothAdapter != null && mBluetoothAdapter.isEnabled()
+                && mBluetoothAdapter.getProfileConnectionState(BluetoothProfile.A2DP)
+                == BluetoothProfile.STATE_CONNECTED;
+    }
+
     public void initSettingsH() {
-        if (mSettingsView != null) {
-            mSettingsView.setVisibility(
+        if (mMediaOutputView != null) {
+            mMediaOutputView.setVisibility(
                     mDeviceProvisionedController.isCurrentUserSetup() &&
-                            mActivityManager.getLockTaskModeState() == LOCK_TASK_MODE_NONE ?
-                            VISIBLE : GONE);
+                            mActivityManager.getLockTaskModeState() == LOCK_TASK_MODE_NONE &&
+                            isBluetoothA2dpConnected() ? VISIBLE : GONE);
         }
-        if (mSettingsIcon != null) {
-            mSettingsIcon.setOnClickListener(v -> {
+        if (mMediaOutputIcon != null) {
+            mMediaOutputIcon.setOnClickListener(v -> {
                 Events.writeEvent(mContext, Events.EVENT_SETTINGS_CLICK);
-                Intent intent = new Intent(Settings.Panel.ACTION_VOLUME);
+                Intent intent = new Intent(ACTION_MEDIA_OUTPUT);
                 dismissH(DISMISS_REASON_SETTINGS_CLICKED);
                 Dependency.get(ActivityStarter.class).startActivity(intent,
                         true /* dismissShade */);
             });
         }
+
+        if (mExpandRowsView != null) {
+            mExpandRowsView.setVisibility(
+                    mDeviceProvisionedController.isCurrentUserSetup() &&
+                            mActivityManager.getLockTaskModeState() == LOCK_TASK_MODE_NONE ?
+                            VISIBLE : GONE);
+        }
+        if (mExpandRows != null) {
+            mExpandRows.setOnClickListener(v -> {
+                Util.setVisOrGone(findRow(AudioManager.STREAM_RING).view, !mExpanded);
+                Util.setVisOrGone(findRow(STREAM_ALARM).view, !mExpanded);
+
+                if (mExpanded) mController.setActiveStream(AudioManager.STREAM_MUSIC);
+                mExpandRows.setExpanded(!mExpanded);
+                mExpanded = !mExpanded;
+            });
+        }
     }
 
     public void initRingerH() {
@@ -798,6 +826,10 @@ public class VolumeDialogImpl implements VolumeDialog,
             Log.d(TAG, ""mDialog.dismiss() reason: "" + Events.DISMISS_REASONS[reason]
                     + "" from: "" + Debug.getCaller());
         }
+        if (!mShowing) {
+            // This may happen when dismissing an expanded panel, don't animate again
+            return;
+        }
         mHandler.removeMessages(H.DISMISS);
         mHandler.removeMessages(H.SHOW);
         mDialogView.animate().cancel();
@@ -815,6 +847,8 @@ public class VolumeDialogImpl implements VolumeDialog,
                 .withEndAction(() -> mHandler.postDelayed(() -> {
                     mDialog.dismiss();
                     tryToRemoveCaptionsTooltip();
+                    mExpanded = false;
+                    mExpandRows.setExpanded(mExpanded);
                     mController.notifyVisible(false);
                 }, 50));
         animator.translationX(getAnimatorX());
@@ -874,7 +908,7 @@ public class VolumeDialogImpl implements VolumeDialog,
         for (final VolumeRow row : mRows) {
             final boolean isActive = row == activeRow;
             final boolean shouldBeVisible = shouldBeVisibleH(row, activeRow);
-            Util.setVisOrGone(row.view, shouldBeVisible);
+            if (!mExpanded) Util.setVisOrGone(row.view, shouldBeVisible);
             if (row.view.isShown()) {
                 updateVolumeRowTintH(row, isActive);
             }
@@ -1183,7 +1217,7 @@ public class VolumeDialogImpl implements VolumeDialog,
         final int alpha = useActiveColoring
                 ? Color.alpha(tint.getDefaultColor())
                 : getAlphaAttr(android.R.attr.secondaryContentAlpha);
-        if (tint == row.cachedTint) return;
+        if (tint == row.cachedTint && mExpanded) return;
         row.slider.setProgressTintList(tint);
         row.slider.setThumbTintList(tint);
         row.slider.setProgressBackgroundTintList(tint);
",58,24,"VolumeDialogImpl::addRow, VolumeDialogImpl::initSettingsH, VolumeDialogImpl::updateRowsH, VolumeDialogImpl::initDialog, VolumeDialogImpl::addExistingRows, VolumeDialogImpl::isBluetoothA2dpConnected, VolumeDialogImpl::updateVolumeRowTintH, VolumeDialogImpl::dismissH"
232,ab272fa2916a60efaf828d119c9e4a43279da50c,VolumeDialogImpl.java,ModificationType.MODIFY,"@@ -53,6 +53,7 @@ import android.content.res.Resources;
 import android.content.res.TypedArray;
 import android.graphics.Color;
 import android.graphics.PixelFormat;
+import android.graphics.Region;
 import android.graphics.drawable.ColorDrawable;
 import android.media.AudioManager;
 import android.media.AudioSystem;
@@ -70,12 +71,16 @@ import android.util.Slog;
 import android.util.SparseBooleanArray;
 import android.view.ContextThemeWrapper;
 import android.view.Gravity;
+import android.view.LayoutInflater;
 import android.view.MotionEvent;
 import android.view.View;
 import android.view.View.AccessibilityDelegate;
 import android.view.ViewGroup;
 import android.view.ViewPropertyAnimator;
 import android.view.ViewStub;
+import android.view.ViewTreeObserver;
+import android.view.ViewTreeObserver.InternalInsetsInfo;
+import android.view.ViewTreeObserver.OnComputeInternalInsetsListener;
 import android.view.Window;
 import android.view.WindowManager;
 import android.view.accessibility.AccessibilityEvent;
@@ -136,12 +141,13 @@ public class VolumeDialogImpl implements VolumeDialog,
     static final int DIALOG_HIDE_ANIMATION_DURATION = 250;
 
     private final Context mContext;
+    private WindowManager mWindowManager;
+    private WindowManager.LayoutParams mWindowParams;
     private final H mHandler = new H();
     private final VolumeDialogController mController;
     private final DeviceProvisionedController mDeviceProvisionedController;
 
-    private Window mWindow;
-    private CustomDialog mDialog;
+    private View mDialog;
     private ViewGroup mDialogView;
     private ViewGroup mDialogRowsView;
     private ViewGroup mRinger;
@@ -189,6 +195,7 @@ public class VolumeDialogImpl implements VolumeDialog,
         mController = Dependency.get(VolumeDialogController.class);
         mKeyguard = (KeyguardManager) mContext.getSystemService(Context.KEYGUARD_SERVICE);
         mActivityManager = (ActivityManager) mContext.getSystemService(Context.ACTIVITY_SERVICE);
+        mWindowManager = (WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE);
         mAccessibilityMgr = Dependency.get(AccessibilityManagerWrapper.class);
         mDeviceProvisionedController = Dependency.get(DeviceProvisionedController.class);
         mShowActiveStreamOnly = showActiveStreamOnly();
@@ -221,8 +228,6 @@ public class VolumeDialogImpl implements VolumeDialog,
     }
 
     private void initDialog() {
-        mDialog = new CustomDialog(mContext);
-
         // Gravitate various views left/right depending on panel placement setting.
         final int panelGravity = mVolumePanelOnLeft ? Gravity.LEFT : Gravity.RIGHT;
 
@@ -230,49 +235,35 @@ public class VolumeDialogImpl implements VolumeDialog,
         mHovering = false;
         mShowing = false;
         mExpanded = false;
-        mWindow = mDialog.getWindow();
-        mWindow.requestFeature(Window.FEATURE_NO_TITLE);
-        mWindow.setBackgroundDrawable(new ColorDrawable(Color.TRANSPARENT));
-        mWindow.clearFlags(WindowManager.LayoutParams.FLAG_DIM_BEHIND
-                | WindowManager.LayoutParams.FLAG_LAYOUT_INSET_DECOR);
-        mWindow.addFlags(WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE
+        mWindowParams = new WindowManager.LayoutParams();
+        mWindowParams.flags &= ~WindowManager.LayoutParams.FLAG_DIM_BEHIND;
+        mWindowParams.flags &= ~WindowManager.LayoutParams.FLAG_LAYOUT_INSET_DECOR;
+        mWindowParams.flags |= WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE
                 | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN
                 | WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL
                 | WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED
                 | WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH
-                | WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED);
-        mWindow.setType(WindowManager.LayoutParams.TYPE_VOLUME_OVERLAY);
-        mWindow.setWindowAnimations(com.android.internal.R.style.Animation_Toast);
-        WindowManager.LayoutParams lp = mWindow.getAttributes();
-        lp.format = PixelFormat.TRANSLUCENT;
-        lp.setTitle(VolumeDialogImpl.class.getSimpleName());
-        lp.windowAnimations = -1;
-        lp.gravity = panelGravity | Gravity.CENTER_VERTICAL;
-        mWindow.setAttributes(lp);
-        mWindow.setLayout(WRAP_CONTENT, WRAP_CONTENT);
-
-        mDialog.setContentView(R.layout.volume_dialog);
+                | WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;
+        mWindowParams.type = WindowManager.LayoutParams.TYPE_VOLUME_OVERLAY;
+        mWindowParams.format = PixelFormat.TRANSLUCENT;
+        mWindowParams.windowAnimations = -1;
+        mDialog = LayoutInflater.from(mContext).inflate(R.layout.volume_dialog,
+                (ViewGroup) null, false);
+
+        mDialog.setOnTouchListener((v, event) -> {
+            if (mShowing) {
+                switch (event.getAction()) {
+                    case MotionEvent.ACTION_OUTSIDE:
+                    case MotionEvent.ACTION_DOWN:
+                        dismissH(Events.DISMISS_REASON_TOUCH_OUTSIDE);
+                        return true;
+                }
+            }
+            return false;
+        });
+
         mDialogView = mDialog.findViewById(R.id.volume_dialog);
         mDialogView.setAlpha(0);
-        mDialog.setCanceledOnTouchOutside(true);
-        mDialog.setOnShowListener(dialog -> {
-            mDialogView.setTranslationX(getAnimatorX());
-            mDialogView.setAlpha(0);
-            mDialogView.animate()
-                    .alpha(1)
-                    .translationX(0)
-                    .setDuration(DIALOG_SHOW_ANIMATION_DURATION)
-                    .setInterpolator(new SystemUIInterpolators.LogDecelerateInterpolator())
-                    .withEndAction(() -> {
-                        if (!Prefs.getBoolean(mContext, Prefs.Key.TOUCHED_RINGER_TOGGLE, false)) {
-                            if (mRingerIcon != null) {
-                                mRingerIcon.postOnAnimationDelayed(
-                                        getSinglePressFor(mRingerIcon), 1500);
-                            }
-                        }
-                    })
-                    .start();
-        });
 
         mDialogView.setOnHoverListener((v, event) -> {
             int action = event.getActionMasked();
@@ -282,6 +273,11 @@ public class VolumeDialogImpl implements VolumeDialog,
             return true;
         });
 
+        FrameLayout.LayoutParams dialogViewLP =
+                (FrameLayout.LayoutParams) mDialogView.getLayoutParams();
+        dialogViewLP.gravity = Gravity.CENTER_VERTICAL;
+        mDialogView.setLayoutParams(dialogViewLP);
+
         mDialogRowsView = mDialog.findViewById(R.id.volume_dialog_rows);
         mRinger = mDialog.findViewById(R.id.ringer);
         if (mRinger != null) {
@@ -343,6 +339,22 @@ public class VolumeDialogImpl implements VolumeDialog,
         initODICaptionsH();
     }
 
+    private final OnComputeInternalInsetsListener mInsetsListener = internalInsetsInfo -> {
+        internalInsetsInfo.touchableRegion.setEmpty();
+        internalInsetsInfo.setTouchableInsets(InternalInsetsInfo.TOUCHABLE_INSETS_REGION);
+        View main = mDialog.findViewById(R.id.main);
+        int[] mainLocation = new int[2];
+        main.getLocationOnScreen(mainLocation);
+        int[] dialogLocation = new int[2];
+        mDialogView.getLocationOnScreen(dialogLocation);
+        internalInsetsInfo.touchableRegion.set(new Region(
+                mainLocation[0],
+                dialogLocation[1],
+                mainLocation[0] + main.getWidth(),
+                dialogLocation[1] + mDialogView.getHeight()
+        ));
+    };
+
     // Helper to set layout gravity.
     // Particular useful when the ViewGroup in question
     // is different for portait vs landscape.
@@ -478,7 +490,7 @@ public class VolumeDialogImpl implements VolumeDialog,
         row.iconMuteRes = iconMuteRes;
         row.important = important;
         row.defaultStream = defaultStream;
-        row.view = mDialog.getLayoutInflater().inflate(R.layout.volume_dialog_row, null);
+        row.view = LayoutInflater.from(mContext).inflate(R.layout.volume_dialog_row, null);
         row.view.setId(row.stream);
         row.view.setTag(row);
         row.header = row.view.findViewById(R.id.volume_row_header);
@@ -496,6 +508,7 @@ public class VolumeDialogImpl implements VolumeDialog,
         row.icon.setImageResource(iconRes);
         if (row.stream != AudioSystem.STREAM_ACCESSIBILITY) {
             row.icon.setOnClickListener(v -> {
+                rescheduleTimeoutH();
                 Events.writeEvent(mContext, Events.EVENT_ICON_CLICK, row.stream, row.iconState);
                 mController.setActiveStream(row.stream);
                 if (row.stream == AudioManager.STREAM_RING) {
@@ -542,6 +555,7 @@ public class VolumeDialogImpl implements VolumeDialog,
         }
         if (mMediaOutputIcon != null) {
             mMediaOutputIcon.setOnClickListener(v -> {
+                rescheduleTimeoutH();
                 Events.writeEvent(mContext, Events.EVENT_SETTINGS_CLICK);
                 Intent intent = new Intent(ACTION_MEDIA_OUTPUT);
                 dismissH(DISMISS_REASON_SETTINGS_CLICKED);
@@ -558,6 +572,7 @@ public class VolumeDialogImpl implements VolumeDialog,
         }
         if (mExpandRows != null) {
             mExpandRows.setOnClickListener(v -> {
+                rescheduleTimeoutH();
                 Util.setVisOrGone(findRow(AudioManager.STREAM_RING).view, !mExpanded);
                 Util.setVisOrGone(findRow(STREAM_ALARM).view, !mExpanded);
 
@@ -572,6 +587,7 @@ public class VolumeDialogImpl implements VolumeDialog,
         if (mRingerIcon != null) {
             mRingerIcon.setAccessibilityLiveRegion(ACCESSIBILITY_LIVE_REGION_POLITE);
             mRingerIcon.setOnClickListener(v -> {
+                rescheduleTimeoutH();
                 Prefs.putBoolean(mContext, Prefs.Key.TOUCHED_RINGER_TOGGLE, true);
                 final StreamState ss = mState.states.get(AudioManager.STREAM_RING);
                 if (ss == null) {
@@ -631,11 +647,11 @@ public class VolumeDialogImpl implements VolumeDialog,
         if (!mHasSeenODICaptionsTooltip && mODICaptionsTooltipViewStub != null) {
             mODICaptionsTooltipView = mODICaptionsTooltipViewStub.inflate();
             mODICaptionsTooltipView.findViewById(R.id.dismiss).setOnClickListener(v -> {
+                rescheduleTimeoutH();
                 hideCaptionsTooltip();
                 Events.writeEvent(mContext, Events.EVENT_ODI_CAPTIONS_TOOLTIP_CLICK);
             });
             mODICaptionsTooltipViewStub = null;
-            rescheduleTimeoutH();
         }
 
         if (mODICaptionsTooltipView != null) {
@@ -783,8 +799,36 @@ public class VolumeDialogImpl implements VolumeDialog,
         }
 
         initSettingsH();
-        mShowing = true;
-        mDialog.show();
+        mDialog.getViewTreeObserver().addOnComputeInternalInsetsListener(mInsetsListener);
+
+        if (!mShowing && !mDialog.isShown()) {
+            if (!isLandscape()) {
+                mDialogView.setTranslationX(
+                        (mVolumePanelOnLeft ? -1 : 1) * mDialogView.getWidth() / 2.0f);
+            }
+            mDialogView.setAlpha(0);
+            mDialogView.animate()
+                    .alpha(1)
+                    .translationX(0)
+                    .setDuration(DIALOG_SHOW_ANIMATION_DURATION)
+                    .setInterpolator(new SystemUIInterpolators.LogDecelerateInterpolator())
+                    .withStartAction(() -> {
+                        if (!mDialog.isShown()) {
+                            mWindowManager.addView(mDialog, mWindowParams);
+                        }
+                    })
+                    .withEndAction(() -> {
+                        if (!Prefs.getBoolean(mContext, Prefs.Key.TOUCHED_RINGER_TOGGLE, false)) {
+                            if (mRingerIcon != null) {
+                                mRingerIcon.postOnAnimationDelayed(
+                                        getSinglePressFor(mRingerIcon), 1500);
+                            }
+                        }
+                        mShowing = true;
+                    })
+                    .start();
+        }
+
         Events.writeEvent(mContext, Events.EVENT_SHOW_DIALOG, reason, mKeyguard.isKeyguardLocked());
         mController.notifyVisible(true);
         mController.getCaptionsComponentState(false);
@@ -845,10 +889,12 @@ public class VolumeDialogImpl implements VolumeDialog,
                 .setDuration(DIALOG_HIDE_ANIMATION_DURATION)
                 .setInterpolator(new SystemUIInterpolators.LogAccelerateInterpolator())
                 .withEndAction(() -> mHandler.postDelayed(() -> {
-                    mDialog.dismiss();
-                    tryToRemoveCaptionsTooltip();
+                    if (mDialog.isShown()){
+                        mWindowManager.removeViewImmediate(mDialog);
+                    }
                     mExpanded = false;
                     mExpandRows.setExpanded(mExpanded);
+                    tryToRemoveCaptionsTooltip();
                     mController.notifyVisible(false);
                 }, 50));
         animator.translationX(getAnimatorX());
@@ -1065,7 +1111,6 @@ public class VolumeDialogImpl implements VolumeDialog,
             updateVolumeRowH(row);
         }
         updateRingerH();
-        mWindow.setTitle(composeWindowTitle());
     }
 
     CharSequence composeWindowTitle() {
@@ -1385,7 +1430,7 @@ public class VolumeDialogImpl implements VolumeDialog,
 
         @Override
         public void onConfigurationChanged() {
-            mDialog.dismiss();
+            if (mDialog.isShown()) mWindowManager.removeViewImmediate(mDialog);
             mConfigChanged = true;
         }
 
@@ -1454,41 +1499,6 @@ public class VolumeDialogImpl implements VolumeDialog,
         }
     }
 
-    private final class CustomDialog extends Dialog implements DialogInterface {
-        public CustomDialog(Context context) {
-            super(context, R.style.qs_theme);
-        }
-
-        @Override
-        public boolean dispatchTouchEvent(MotionEvent ev) {
-            rescheduleTimeoutH();
-            return super.dispatchTouchEvent(ev);
-        }
-
-        @Override
-        protected void onStart() {
-            super.setCanceledOnTouchOutside(true);
-            super.onStart();
-        }
-
-        @Override
-        protected void onStop() {
-            super.onStop();
-            mHandler.sendEmptyMessage(H.RECHECK_ALL);
-        }
-
-        @Override
-        public boolean onTouchEvent(MotionEvent event) {
-            if (mShowing) {
-                if (event.getAction() == MotionEvent.ACTION_OUTSIDE) {
-                    dismissH(Events.DISMISS_REASON_TOUCH_OUTSIDE);
-                    return true;
-                }
-            }
-            return false;
-        }
-    }
-
     private final class VolumeSeekBarChangeListener implements OnSeekBarChangeListener {
         private final VolumeRow mRow;
 
@@ -1498,6 +1508,7 @@ public class VolumeDialogImpl implements VolumeDialog,
 
         @Override
         public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
+            rescheduleTimeoutH();
             if (mRow.ss == null) return;
             if (D.BUG) Log.d(TAG, AudioSystem.streamToString(mRow.stream)
                     + "" onProgressChanged "" + progress + "" fromUser="" + fromUser);
",95,84,"VolumeDialogImpl::VolumeSeekBarChangeListener::onProgressChanged, VolumeDialogImpl::CustomDialog::dispatchTouchEvent, VolumeDialogImpl::initSettingsH, VolumeDialogImpl::VolumeDialogImpl, VolumeDialogImpl::showCaptionsTooltip, VolumeDialogImpl::showH, VolumeDialogImpl::initDialog, VolumeDialogImpl::initRow, VolumeDialogImpl::CustomDialog::CustomDialog, VolumeDialogImpl::CustomDialog::onTouchEvent, VolumeDialogImpl::Callbacks, VolumeDialogImpl::initRingerH, VolumeDialogImpl::CustomDialog::onStart, VolumeDialogImpl::onStateChangedH, VolumeDialogImpl::dismissH, VolumeDialogImpl::CustomDialog::onStop"
233,d529cfe0d581f3d9645b477c31c2b94e9b182d11,VolumeDialogImpl.java,ModificationType.MODIFY,"@@ -539,6 +539,11 @@ public class VolumeDialogImpl implements VolumeDialog,
         }
     }
 
+    private boolean isNotificationVolumeLinked() {
+        ContentResolver cr = mContext.getContentResolver();
+        return Settings.Secure.getInt(cr, Settings.Secure.VOLUME_LINK_NOTIFICATION, 1) == 1;
+    }
+
     private static boolean isBluetoothA2dpConnected() {
         BluetoothAdapter mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
         return mBluetoothAdapter != null && mBluetoothAdapter.isEnabled()
@@ -575,6 +580,10 @@ public class VolumeDialogImpl implements VolumeDialog,
                 rescheduleTimeoutH();
                 Util.setVisOrGone(findRow(AudioManager.STREAM_RING).view, !mExpanded);
                 Util.setVisOrGone(findRow(STREAM_ALARM).view, !mExpanded);
+                if (!isNotificationVolumeLinked()) {
+                    Util.setVisOrGone(
+                            findRow(AudioManager.STREAM_NOTIFICATION).view, !mExpanded);
+                }
 
                 if (mExpanded) mController.setActiveStream(AudioManager.STREAM_MUSIC);
                 mExpandRows.setExpanded(!mExpanded);
",9,0,"VolumeDialogImpl::isNotificationVolumeLinked, VolumeDialogImpl::initSettingsH"
234,702680e488c8bfea6915a19ea9f532d4082732b3,VolumeDialogImpl.java,ModificationType.MODIFY,"@@ -149,6 +149,7 @@ public class VolumeDialogImpl implements VolumeDialog,
 
     private View mDialog;
     private ViewGroup mDialogView;
+    private ViewGroup mDialogMainView;
     private ViewGroup mDialogRowsView;
     private ViewGroup mRinger;
     private ImageButton mRingerIcon;
@@ -278,6 +279,11 @@ public class VolumeDialogImpl implements VolumeDialog,
         dialogViewLP.gravity = Gravity.CENTER_VERTICAL;
         mDialogView.setLayoutParams(dialogViewLP);
 
+        mDialogMainView = mDialog.findViewById(R.id.main);
+        if (mDialogMainView != null) {
+            setLayoutGravity(mDialogMainView.getLayoutParams(), panelGravity);
+        }
+
         mDialogRowsView = mDialog.findViewById(R.id.volume_dialog_rows);
         mRinger = mDialog.findViewById(R.id.ringer);
         if (mRinger != null) {
@@ -291,6 +297,7 @@ public class VolumeDialogImpl implements VolumeDialog,
         mODICaptionsView = mDialog.findViewById(R.id.odi_captions);
         if (mODICaptionsView != null) {
             mODICaptionsIcon = mODICaptionsView.findViewById(R.id.odi_captions_icon);
+            setLayoutGravity(mODICaptionsView.getLayoutParams(), panelGravity);
         }
         mODICaptionsTooltipViewStub = mDialog.findViewById(R.id.odi_captions_tooltip_stub);
         if (mHasSeenODICaptionsTooltip && mODICaptionsTooltipViewStub != null) {
@@ -300,9 +307,16 @@ public class VolumeDialogImpl implements VolumeDialog,
 
         mMediaOutputView = mDialog.findViewById(R.id.media_output_container);
         mMediaOutputIcon = mDialog.findViewById(R.id.media_output);
+        if (mMediaOutputIcon != null) {
+            setLayoutGravity(mMediaOutputIcon.getLayoutParams(), panelGravity);
+        }
 
         mExpandRowsView = mDialog.findViewById(R.id.expandable_indicator_container);
         mExpandRows = mDialog.findViewById(R.id.expandable_indicator);
+        if (mExpandRows != null) {
+            setLayoutGravity(mExpandRows.getLayoutParams(), panelGravity);
+            mExpandRows.setRotation(mVolumePanelOnLeft ? -90 : 90);
+        }
 
         if (mRows.isEmpty()) {
             if (!AudioSystem.isSingleVolume(mContext)) {
",14,0,VolumeDialogImpl::initDialog
235,d4ccd5dbbb438b347c4b41b6484cc6cca358100e,VolumeDialogImpl.java,ModificationType.MODIFY,"@@ -173,8 +173,10 @@ public class VolumeDialogImpl implements VolumeDialog,
     private boolean mShowA11yStream;
 
     private int mActiveStream;
+    private int mAllyStream;
     private int mPrevActiveStream;
     private boolean mAutomute = VolumePrefs.DEFAULT_ENABLE_AUTOMUTE;
+    private boolean mMusicHidden;
     private boolean mSilentMode = VolumePrefs.DEFAULT_ENABLE_SILENT_MODE;
     private State mState;
     private SafetyWarningDialog mSafetyWarning;
@@ -351,6 +353,9 @@ public class VolumeDialogImpl implements VolumeDialog,
         initRingerH();
         initSettingsH();
         initODICaptionsH();
+
+        mAllyStream = -1;
+        mMusicHidden = false;
     }
 
     private final OnComputeInternalInsetsListener mInsetsListener = internalInsetsInfo -> {
@@ -583,6 +588,10 @@ public class VolumeDialogImpl implements VolumeDialog,
             });
         }
 
+        if (mAllyStream == -1) {
+            mAllyStream = mActiveStream;
+        }
+
         if (mExpandRowsView != null) {
             mExpandRowsView.setVisibility(
                     mDeviceProvisionedController.isCurrentUserSetup() &&
@@ -592,6 +601,10 @@ public class VolumeDialogImpl implements VolumeDialog,
         if (mExpandRows != null) {
             mExpandRows.setOnClickListener(v -> {
                 rescheduleTimeoutH();
+                if (mMusicHidden) {
+                    Util.setVisOrGone(findRow(AudioManager.STREAM_MUSIC).view,
+                            !mExpanded);
+                }
                 Util.setVisOrGone(findRow(AudioManager.STREAM_RING).view, !mExpanded);
                 Util.setVisOrGone(findRow(STREAM_ALARM).view, !mExpanded);
                 if (!isNotificationVolumeLinked()) {
@@ -599,7 +612,7 @@ public class VolumeDialogImpl implements VolumeDialog,
                             findRow(AudioManager.STREAM_NOTIFICATION).view, !mExpanded);
                 }
 
-                if (mExpanded) mController.setActiveStream(AudioManager.STREAM_MUSIC);
+                if (mExpanded) mController.setActiveStream(mAllyStream);
                 mExpandRows.setExpanded(!mExpanded);
                 mExpanded = !mExpanded;
             });
@@ -917,6 +930,8 @@ public class VolumeDialogImpl implements VolumeDialog,
                     }
                     mExpanded = false;
                     mExpandRows.setExpanded(mExpanded);
+                    mAllyStream = -1;
+                    mMusicHidden = false;
                     tryToRemoveCaptionsTooltip();
                     mController.notifyVisible(false);
                 }, 50));
@@ -939,6 +954,12 @@ public class VolumeDialogImpl implements VolumeDialog,
     private boolean shouldBeVisibleH(VolumeRow row, VolumeRow activeRow) {
         boolean isActive = row.stream == activeRow.stream;
 
+        if (row.stream == AudioSystem.STREAM_MUSIC &&
+                activeRow.stream != AudioSystem.STREAM_MUSIC && !mExpanded) {
+            mMusicHidden = true;
+            return false;
+        }
+
         if (isActive) {
             return true;
         }
",22,1,"VolumeDialogImpl::dismissH, VolumeDialogImpl::initDialog, VolumeDialogImpl::initSettingsH, VolumeDialogImpl::shouldBeVisibleH"
236,03d78c2254f7c2022c88bedf10b3e9a3d09cdc9f,VolumeDialogImpl.java,ModificationType.MODIFY,"@@ -1177,7 +1177,7 @@ public class VolumeDialogImpl implements VolumeDialog,
         final StreamState ss = mState.states.get(row.stream);
         if (ss == null) return;
         row.ss = ss;
-        if (ss.level > 0) {
+        if (ss.level > ss.levelMin) {
             row.lastAudibleLevel = ss.level;
         }
         if (ss.level == row.requestedLevel) {
@@ -1189,6 +1189,7 @@ public class VolumeDialogImpl implements VolumeDialog,
         final boolean isAlarmStream = row.stream == STREAM_ALARM;
         final boolean isMusicStream = row.stream == AudioManager.STREAM_MUSIC;
         final boolean isNotificationStream = row.stream == AudioManager.STREAM_NOTIFICATION;
+        final boolean isMuted = row.ss.level == row.ss.levelMin;
         final boolean isVibrate = mState.ringerModeInternal == AudioManager.RINGER_MODE_VIBRATE;
         final boolean isRingVibrate = isRingStream && isVibrate;
         final boolean isRingSilent = isRingStream
@@ -1233,7 +1234,7 @@ public class VolumeDialogImpl implements VolumeDialog,
                         (ss.muted ? R.drawable.ic_volume_media_bt_mute
                                 : R.drawable.ic_volume_media_bt)
                 : mAutomute && ss.level == 0 ? row.iconMuteRes
-                : (ss.muted ? row.iconMuteRes : row.iconRes);
+                : isMuted ? row.iconMuteRes : row.iconRes;
         row.icon.setImageResource(iconRes);
         row.iconState =
                 iconRes == R.drawable.ic_volume_ringer_vibrate ? Events.ICON_STATE_VIBRATE
@@ -1636,7 +1637,7 @@ public class VolumeDialogImpl implements VolumeDialog,
         private int iconState;  // from Events
         private ObjectAnimator anim;  // slider progress animation for non-touch-related updates
         private int animTargetProgress;
-        private int lastAudibleLevel = 1;
+        private int lastAudibleLevel = 2;
         private FrameLayout dndIcon;
     }
 }
",4,3,VolumeDialogImpl::updateVolumeRowH
237,91643253cd34411da1ad45211ab6c4fcc6eb68c9,VolumeDialogImpl.java,ModificationType.MODIFY,"@@ -530,27 +530,9 @@ public class VolumeDialogImpl implements VolumeDialog,
                 rescheduleTimeoutH();
                 Events.writeEvent(mContext, Events.EVENT_ICON_CLICK, row.stream, row.iconState);
                 mController.setActiveStream(row.stream);
-                if (row.stream == AudioManager.STREAM_RING) {
-                    final boolean hasVibrator = mController.hasVibrator();
-                    if (mState.ringerModeInternal == AudioManager.RINGER_MODE_NORMAL) {
-                        if (hasVibrator) {
-                            mController.setRingerMode(AudioManager.RINGER_MODE_VIBRATE, false);
-                        } else {
-                            final boolean wasZero = row.ss.level == 0;
-                            mController.setStreamVolume(stream,
-                                    wasZero ? row.lastAudibleLevel : 0);
-                        }
-                    } else {
-                        mController.setRingerMode(AudioManager.RINGER_MODE_NORMAL, false);
-                        if (row.ss.level == 0) {
-                            mController.setStreamVolume(stream, 1);
-                        }
-                    }
-                } else {
-                    final boolean vmute = row.ss.level == row.ss.levelMin;
-                    mController.setStreamVolume(stream,
-                            vmute ? row.lastAudibleLevel : row.ss.levelMin);
-                }
+                final boolean vmute = row.ss.level == row.ss.levelMin;
+                mController.setStreamVolume(stream,
+                        vmute ? row.lastAudibleLevel : row.ss.levelMin);
                 row.userAttempt = 0;  // reset the grace period, slider updates immediately
             });
         } else {
",3,21,VolumeDialogImpl::initRow
238,c052d65a00035722a951651c5cbf1c0b5d1d5fad,VolumeDialogImpl.java,ModificationType.MODIFY,"@@ -552,12 +552,12 @@ public class VolumeDialogImpl implements VolumeDialog,
                 == BluetoothProfile.STATE_CONNECTED;
     }
 
-    public void initSettingsH() {
+    public void updateMediaOutputH() {
         if (mMediaOutputView != null) {
             mMediaOutputView.setVisibility(
                     mDeviceProvisionedController.isCurrentUserSetup() &&
                             mActivityManager.getLockTaskModeState() == LOCK_TASK_MODE_NONE &&
-                            isBluetoothA2dpConnected() ? VISIBLE : GONE);
+                            isBluetoothA2dpConnected() && mExpanded ? VISIBLE : GONE);
         }
         if (mMediaOutputIcon != null) {
             mMediaOutputIcon.setOnClickListener(v -> {
@@ -569,7 +569,10 @@ public class VolumeDialogImpl implements VolumeDialog,
                         true /* dismissShade */);
             });
         }
+    }
 
+    public void initSettingsH() {
+        updateMediaOutputH();
         if (mAllyStream == -1) {
             mAllyStream = mActiveStream;
         }
@@ -597,6 +600,8 @@ public class VolumeDialogImpl implements VolumeDialog,
                 if (mExpanded) mController.setActiveStream(mAllyStream);
                 mExpandRows.setExpanded(!mExpanded);
                 mExpanded = !mExpanded;
+
+                updateMediaOutputH();
             });
         }
     }
",7,2,"VolumeDialogImpl::updateMediaOutputH, VolumeDialogImpl::initSettingsH"
239,5076c0611923e4d33dc8008946b10a6e767d7208,VolumeDialogImpl.java,ModificationType.MODIFY,"@@ -35,7 +35,10 @@ import static android.view.ViewGroup.LayoutParams.WRAP_CONTENT;
 import static com.android.settingslib.media.MediaOutputSliceConstants.ACTION_MEDIA_OUTPUT;
 import static com.android.systemui.volume.Events.DISMISS_REASON_SETTINGS_CLICKED;
 
+import android.animation.Animator;
+import android.animation.AnimatorListenerAdapter;
 import android.animation.ObjectAnimator;
+import android.animation.ValueAnimator;
 import android.annotation.SuppressLint;
 import android.app.ActivityManager;
 import android.app.Dialog;
@@ -267,6 +270,8 @@ public class VolumeDialogImpl implements VolumeDialog,
 
         mDialogView = mDialog.findViewById(R.id.volume_dialog);
         mDialogView.setAlpha(0);
+        mDialogView.setLayoutDirection(mVolumePanelOnLeft ?
+                View.LAYOUT_DIRECTION_LTR : View.LAYOUT_DIRECTION_RTL);
 
         mDialogView.setOnHoverListener((v, event) -> {
             int action = event.getActionMasked();
@@ -448,7 +453,7 @@ public class VolumeDialogImpl implements VolumeDialog,
         if (D.BUG) Slog.d(TAG, ""Adding row for stream "" + stream);
         VolumeRow row = new VolumeRow();
         initRow(row, stream, iconRes, iconMuteRes, important, defaultStream);
-        mDialogRowsView.addView(row.view, mVolumePanelOnLeft ? -1 : 0);
+        mDialogRowsView.addView(row.view);
         mRows.add(row);
     }
 
@@ -458,7 +463,7 @@ public class VolumeDialogImpl implements VolumeDialog,
             final VolumeRow row = mRows.get(i);
             initRow(row, row.stream, row.iconRes, row.iconMuteRes, row.important,
                     row.defaultStream);
-            mDialogRowsView.addView(row.view, mVolumePanelOnLeft ? -1 : 0);
+            mDialogRowsView.addView(row.view);
             updateVolumeRowH(row);
         }
     }
@@ -552,6 +557,55 @@ public class VolumeDialogImpl implements VolumeDialog,
                 == BluetoothProfile.STATE_CONNECTED;
     }
 
+    private void updateExpandedRows(boolean expand) {
+        if (!expand) mController.setActiveStream(mAllyStream);
+        if (mMusicHidden) {
+            Util.setVisOrGone(findRow(AudioManager.STREAM_MUSIC).view, expand);
+        }
+        Util.setVisOrGone(findRow(AudioManager.STREAM_RING).view, expand);
+        Util.setVisOrGone(findRow(STREAM_ALARM).view, expand);
+        if (!isNotificationVolumeLinked()) {
+            Util.setVisOrGone(
+                    findRow(AudioManager.STREAM_NOTIFICATION).view, expand);
+        }
+    }
+
+    private void animateExpandedRowsChange(boolean expand) {
+        final int startWidth = mDialogRowsView.getLayoutParams().width;
+        final int targetWidth;
+
+        if (expand) {
+            updateExpandedRows(expand);
+            mDialogRowsView.measure(WRAP_CONTENT, WRAP_CONTENT);
+            targetWidth = mDialogRowsView.getMeasuredWidth();
+        } else {
+            targetWidth = mContext.getResources().getDimensionPixelSize(
+                    R.dimen.volume_dialog_panel_width);
+        }
+
+        ValueAnimator animator = ValueAnimator.ofInt(startWidth, targetWidth);
+        animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
+            @Override
+            public void onAnimationUpdate(ValueAnimator valueAnimator) {
+                mDialogRowsView.getLayoutParams().width =
+                        (Integer) valueAnimator.getAnimatedValue();
+                mDialogRowsView.requestLayout();
+            }
+        });
+        animator.addListener(new AnimatorListenerAdapter() {
+            @Override
+            public void onAnimationEnd(Animator animation) {
+                if (!expand) {
+                    updateExpandedRows(expand);
+                }
+            }
+        });
+        animator.setInterpolator(expand ? new SystemUIInterpolators.LogDecelerateInterpolator()
+                : new SystemUIInterpolators.LogAccelerateInterpolator());
+        animator.setDuration(UPDATE_ANIMATION_DURATION);
+        animator.start();
+    }
+
     public void updateMediaOutputH() {
         if (mMediaOutputView != null) {
             mMediaOutputView.setVisibility(
@@ -586,18 +640,8 @@ public class VolumeDialogImpl implements VolumeDialog,
         if (mExpandRows != null) {
             mExpandRows.setOnClickListener(v -> {
                 rescheduleTimeoutH();
-                if (mMusicHidden) {
-                    Util.setVisOrGone(findRow(AudioManager.STREAM_MUSIC).view,
-                            !mExpanded);
-                }
-                Util.setVisOrGone(findRow(AudioManager.STREAM_RING).view, !mExpanded);
-                Util.setVisOrGone(findRow(STREAM_ALARM).view, !mExpanded);
-                if (!isNotificationVolumeLinked()) {
-                    Util.setVisOrGone(
-                            findRow(AudioManager.STREAM_NOTIFICATION).view, !mExpanded);
-                }
+                animateExpandedRowsChange(!mExpanded);
 
-                if (mExpanded) mController.setActiveStream(mAllyStream);
                 mExpandRows.setExpanded(!mExpanded);
                 mExpanded = !mExpanded;
 
@@ -916,6 +960,9 @@ public class VolumeDialogImpl implements VolumeDialog,
                         mWindowManager.removeViewImmediate(mDialog);
                     }
                     mExpanded = false;
+                    mDialogRowsView.getLayoutParams().width = mContext.getResources()
+                            .getDimensionPixelSize(R.dimen.volume_dialog_panel_width);
+                    updateExpandedRows(mExpanded);
                     mExpandRows.setExpanded(mExpanded);
                     mAllyStream = -1;
                     mMusicHidden = false;
",60,13,"VolumeDialogImpl::updateExpandedRows, VolumeDialogImpl::addRow, VolumeDialogImpl::initSettingsH, VolumeDialogImpl::animateExpandedRowsChange, VolumeDialogImpl::initDialog, VolumeDialogImpl::addExistingRows, VolumeDialogImpl::dismissH"
240,39a331c6f0dad426e99b11c0df76a13c17b55f29,VolumeDialogImpl.java,ModificationType.MODIFY,"@@ -557,16 +557,22 @@ public class VolumeDialogImpl implements VolumeDialog,
                 == BluetoothProfile.STATE_CONNECTED;
     }
 
+    private void setVisOrGone(int stream, boolean vis) {
+        if (!vis && stream == mAllyStream) {
+            return;
+        }
+        Util.setVisOrGone(findRow(stream).view, vis);
+    }
+
     private void updateExpandedRows(boolean expand) {
         if (!expand) mController.setActiveStream(mAllyStream);
         if (mMusicHidden) {
-            Util.setVisOrGone(findRow(AudioManager.STREAM_MUSIC).view, expand);
+            setVisOrGone(AudioManager.STREAM_MUSIC, expand);
         }
-        Util.setVisOrGone(findRow(AudioManager.STREAM_RING).view, expand);
-        Util.setVisOrGone(findRow(STREAM_ALARM).view, expand);
+        setVisOrGone(AudioManager.STREAM_RING, expand);
+        setVisOrGone(STREAM_ALARM, expand);
         if (!isNotificationVolumeLinked()) {
-            Util.setVisOrGone(
-                    findRow(AudioManager.STREAM_NOTIFICATION).view, expand);
+            setVisOrGone(AudioManager.STREAM_NOTIFICATION, expand);
         }
     }
 
",11,5,"VolumeDialogImpl::updateExpandedRows, VolumeDialogImpl::setVisOrGone"
241,a10fd15f17fc94f99f4dfae9f94d5338e4f6469e,AppOpsControllerImpl.java,ModificationType.MODIFY,"@@ -62,6 +62,7 @@ public class AppOpsControllerImpl implements AppOpsController,
     private H mBGHandler;
     private final List<AppOpsController.Callback> mCallbacks = new ArrayList<>();
     private final ArrayMap<Integer, Set<Callback>> mCallbacksByCode = new ArrayMap<>();
+    private final PermissionFlagsCache mFlagsCache;
     private boolean mListening;
 
     @GuardedBy(""mActiveItems"")
@@ -79,8 +80,14 @@ public class AppOpsControllerImpl implements AppOpsController,
 
     @Inject
     public AppOpsControllerImpl(Context context, @Named(BG_LOOPER_NAME) Looper bgLooper) {
+        this(context, bgLooper, new PermissionFlagsCache(context));
+    }
+
+    @VisibleForTesting
+    protected AppOpsControllerImpl(Context context, Looper bgLooper, PermissionFlagsCache cache) {
         mContext = context;
         mAppOps = (AppOpsManager) context.getSystemService(Context.APP_OPS_SERVICE);
+        mFlagsCache = cache;
         mBGHandler = new H(bgLooper);
         final int numOps = OPS.length;
         for (int i = 0; i < numOps; i++) {
@@ -239,7 +246,7 @@ public class AppOpsControllerImpl implements AppOpsController,
         if (permission == null) {
             return false;
         }
-        int permFlags = mContext.getPackageManager().getPermissionFlags(permission,
+        int permFlags = mFlagsCache.getPermissionFlags(permission,
                 packageName, UserHandle.getUserHandleForUid(uid));
         return (permFlags & PackageManager.FLAG_PERMISSION_USER_SENSITIVE_WHEN_GRANTED) != 0;
     }
@@ -359,7 +366,8 @@ public class AppOpsControllerImpl implements AppOpsController,
     }
 
     private void notifySuscribers(int code, int uid, String packageName, boolean active) {
-        if (mCallbacksByCode.containsKey(code)) {
+        if (mCallbacksByCode.containsKey(code)
+                && isUserVisible(code, uid, packageName)) {
             if (DEBUG) Log.d(TAG, ""Notifying of change in package "" + packageName);
             for (Callback cb: mCallbacksByCode.get(code)) {
                 cb.onActiveStateChanged(code, uid, packageName, active);
",10,2,"AppOpsControllerImpl::isUserSensitive, AppOpsControllerImpl::AppOpsControllerImpl, AppOpsControllerImpl::notifySuscribers, AppOpsControllerImpl::AppOpsControllerImpl"
242,a10fd15f17fc94f99f4dfae9f94d5338e4f6469e,AppOpsControllerTest.java,ModificationType.MODIFY,"@@ -16,17 +16,20 @@
 
 package com.android.systemui.appops;
 
+import static junit.framework.TestCase.assertFalse;
+
 import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.ArgumentMatchers.anyBoolean;
 import static org.mockito.ArgumentMatchers.anyInt;
 import static org.mockito.ArgumentMatchers.anyLong;
 import static org.mockito.ArgumentMatchers.anyString;
+import static org.mockito.ArgumentMatchers.eq;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
 
 import static java.lang.Thread.sleep;
 
@@ -55,6 +58,7 @@ public class AppOpsControllerTest extends SysuiTestCase {
     private static final String TEST_PACKAGE_NAME = ""test"";
     private static final int TEST_UID = UserHandle.getUid(0, 0);
     private static final int TEST_UID_OTHER = UserHandle.getUid(1, 0);
+    private static final int TEST_UID_NON_USER_SENSITIVE = UserHandle.getUid(2, 0);
 
     @Mock
     private AppOpsManager mAppOpsManager;
@@ -64,6 +68,8 @@ public class AppOpsControllerTest extends SysuiTestCase {
     private AppOpsController.Callback mCallback;
     @Mock
     private AppOpsControllerImpl.H mMockHandler;
+    @Mock
+    private PermissionFlagsCache mFlagsCache;
 
     private AppOpsControllerImpl mController;
     private TestableLooper mTestableLooper;
@@ -75,7 +81,19 @@ public class AppOpsControllerTest extends SysuiTestCase {
 
         getContext().addMockSystemService(AppOpsManager.class, mAppOpsManager);
 
-        mController = new AppOpsControllerImpl(mContext, mTestableLooper.getLooper());
+        // All permissions of TEST_UID and TEST_UID_OTHER are user sensitive. None of
+        // TEST_UID_NON_USER_SENSITIVE are user sensitive.
+        getContext().setMockPackageManager(mPackageManager);
+        when(mFlagsCache.getPermissionFlags(anyString(), anyString(),
+                eq(UserHandle.getUserHandleForUid(TEST_UID)))).thenReturn(
+                PackageManager.FLAG_PERMISSION_USER_SENSITIVE_WHEN_GRANTED);
+        when(mFlagsCache.getPermissionFlags(anyString(), anyString(),
+                eq(UserHandle.getUserHandleForUid(TEST_UID_OTHER)))).thenReturn(
+                PackageManager.FLAG_PERMISSION_USER_SENSITIVE_WHEN_GRANTED);
+        when(mFlagsCache.getPermissionFlags(anyString(), anyString(),
+                eq(UserHandle.getUserHandleForUid(TEST_UID_NON_USER_SENSITIVE)))).thenReturn(0);
+
+        mController = new AppOpsControllerImpl(mContext, mTestableLooper.getLooper(), mFlagsCache);
     }
 
     @Test
@@ -170,6 +188,14 @@ public class AppOpsControllerTest extends SysuiTestCase {
                 mController.getActiveAppOpsForUser(UserHandle.getUserId(TEST_UID_OTHER)).size());
     }
 
+    @Test
+    public void nonUserSensitiveOpsAreIgnored() {
+        mController.onOpActiveChanged(AppOpsManager.OP_RECORD_AUDIO,
+                TEST_UID_NON_USER_SENSITIVE, TEST_PACKAGE_NAME, true);
+        assertEquals(0, mController.getActiveAppOpsForUser(
+                UserHandle.getUserId(TEST_UID_NON_USER_SENSITIVE)).size());
+    }
+
     @Test
     public void opNotedScheduledForRemoval() {
         mController.setBGHandler(mMockHandler);
",28,2,"AppOpsControllerTest::nonUserSensitiveOpsAreIgnored, AppOpsControllerTest::setUp"
243,9637d979bcace1ac64691fe41bd5631006df5160,SystemImpl.java,ModificationType.MODIFY,"@@ -232,7 +232,7 @@ public class SystemImpl implements SystemInterface {
 
     @Override
     public boolean systemIsDebuggable() {
-        return Build.IS_DEBUGGABLE;
+        return Build.IS_DEBUGGABLE && Build.IS_ENG;
     }
 
     @Override
",1,1,SystemImpl::systemIsDebuggable
244,1ed91f78f63b1db2b95381dfa6b132da04733171,ChooserActivity.java,ModificationType.MODIFY,"@@ -930,7 +930,7 @@ public class ChooserActivity extends ResolverActivity {
         final ComponentName cn = getNearbySharingComponent();
         if (cn == null) return null;
 
-        final Intent resolveIntent = new Intent();
+        final Intent resolveIntent = new Intent(originalIntent);
         resolveIntent.setComponent(cn);
         final ResolveInfo ri = getPackageManager().resolveActivity(
                 resolveIntent, PackageManager.GET_META_DATA);
@@ -1097,6 +1097,13 @@ public class ChooserActivity extends ResolverActivity {
             ViewGroup parent) {
         ViewGroup contentPreviewLayout = (ViewGroup) layoutInflater.inflate(
                 R.layout.chooser_grid_preview_image, parent, false);
+
+
+        final ViewGroup actionRow =
+               (ViewGroup) contentPreviewLayout.findViewById(R.id.chooser_action_row);
+        //TODO: addActionButton(actionRow, createCopyButton());
+        addActionButton(actionRow, createNearbyButton(targetIntent));
+
         mPreviewCoord = new ContentPreviewCoordinator(contentPreviewLayout, true);
 
         String action = targetIntent.getAction();
@@ -1207,10 +1214,10 @@ public class ChooserActivity extends ResolverActivity {
         ViewGroup contentPreviewLayout = (ViewGroup) layoutInflater.inflate(
                 R.layout.chooser_grid_preview_file, parent, false);
 
-        // TODO(b/120417119): Disable file copy until after moving to sysui,
-        // due to permissions issues
-        //((ViewGroup) contentPreviewLayout.findViewById(R.id.chooser_action_row))
-        //        .addView(createCopyButton());
+        final ViewGroup actionRow =
+                (ViewGroup) contentPreviewLayout.findViewById(R.id.chooser_action_row);
+        //TODO(b/120417119): addActionButton(actionRow, createCopyButton());
+        addActionButton(actionRow, createNearbyButton(targetIntent));
 
         String action = targetIntent.getAction();
         if (Intent.ACTION_SEND.equals(action)) {
",12,5,"ChooserActivity::getNearbySharingTarget, ChooserActivity::displayFileContentPreview, ChooserActivity::displayImageContentPreview"
245,d41cf50b5816c11dcbba3bb56396243c789001b4,WifiManager.java,ModificationType.MODIFY,"@@ -4551,6 +4551,71 @@ public class WifiManager {
         }
     }
 
+    /**
+     * @hide
+     */
+    public interface StaStateCallback {
+        /**
+         * @hide
+         */
+        void onStaToBeOff();
+    }
+
+    /**
+     * @hide
+     */
+    private class StaStateCallbackProxy extends IStaStateCallback.Stub {
+        private final Handler mHandler;
+        private final StaStateCallback mCallback;
+
+        StaStateCallbackProxy(Looper looper, StaStateCallback callback) {
+            mHandler = new Handler(looper);
+            mCallback = callback;
+        }
+
+        @Override
+        public void onStaToBeOff() {
+            if (mVerboseLoggingEnabled) {
+                Log.v(TAG, ""StaStateCallbackProxy: onStaToBeOff"");
+            }
+            mHandler.post(() -> {
+                mCallback.onStaToBeOff();
+            });
+        }
+    }
+
+    /**
+     * @hide
+     */
+    public void registerStaStateCallback(@NonNull StaStateCallback callback,
+                                             @Nullable Handler handler) {
+        if (callback == null) throw new IllegalArgumentException(""callback cannot be null"");
+        Log.v(TAG, ""registerStaStateCallback: callback="" + callback + "", handler="" + handler);
+
+        Looper looper = (handler == null) ? mContext.getMainLooper() : handler.getLooper();
+        Binder binder = new Binder();
+        try {
+            mService.registerStaStateCallback(
+                    binder, new StaStateCallbackProxy(looper, callback), callback.hashCode());
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    /**
+     * @hide
+     */
+    public void unregisterStaStateCallback(@NonNull StaStateCallback callback) {
+        if (callback == null) throw new IllegalArgumentException(""callback cannot be null"");
+        Log.v(TAG, ""unregisterStaStateCallback: callback="" + callback);
+
+        try {
+            mService.unregisterStaStateCallback(callback.hashCode());
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
     /**
      * Helper method to update the local verbose logging flag based on the verbose logging
      * level from wifi service.
",65,0,"WifiManager::StaStateCallbackProxy::StaStateCallbackProxy, WifiManager::registerStaStateCallback, WifiManager::unregisterStaStateCallback, WifiManager::StaStateCallbackProxy::onStaToBeOff"
246,d41cf50b5816c11dcbba3bb56396243c789001b4,BaseWifiService.java,ModificationType.MODIFY,"@@ -25,6 +25,7 @@ import android.net.wifi.IDppCallback;
 import android.net.wifi.INetworkRequestMatchCallback;
 import android.net.wifi.IOnWifiUsabilityStatsListener;
 import android.net.wifi.ISoftApCallback;
+import android.net.wifi.IStaStateCallback;
 import android.net.wifi.ITrafficStateCallback;
 import android.net.wifi.IWifiManager;
 import android.net.wifi.ScanResult;
@@ -481,4 +482,15 @@ public class BaseWifiService extends IWifiManager.Stub {
     public void updateWifiUsabilityScore(int seqNum, int score, int predictionHorizonSec) {
         throw new UnsupportedOperationException();
     }
+
+    @Override
+    public void registerStaStateCallback(
+            IBinder binder, IStaStateCallback callback, int callbackIdentifier) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void unregisterStaStateCallback(int callbackIdentifier) {
+        throw new UnsupportedOperationException();
+    }
 }
",12,0,"BaseWifiService::unregisterStaStateCallback, BaseWifiService::registerStaStateCallback"
247,7d16102bf49fa6951a96d869af33d3f5f01713d9,StatusBar.java,ModificationType.MODIFY,"@@ -4180,7 +4180,8 @@ public class StatusBar extends SystemUI implements DemoMode,
 
         boolean launchingAffordanceWithPreview =
                 mNotificationPanel.isLaunchingAffordanceWithPreview();
-        mScrimController.setLaunchingAffordanceWithPreview(launchingAffordanceWithPreview);
+        mScrimController.setLaunchingAffordanceWithPreview(launchingAffordanceWithPreview
+                || mBiometricUnlockController.isWakeAndUnlock());
 
         if (mBouncerShowing) {
             // Bouncer needs the front scrim when it's on top of an activity,
",2,1,StatusBar::updateScrimController
248,6d687f055a32430c09ddbde8ef3075bc429b51ad,UninstallAlertDialogFragment.java,ModificationType.MODIFY,"@@ -35,7 +35,6 @@ import android.os.Bundle;
 import android.os.UserHandle;
 import android.os.UserManager;
 import android.os.storage.StorageManager;
-import android.os.storage.StorageVolume;
 import android.util.Log;
 import android.view.LayoutInflater;
 import android.view.View;
@@ -64,29 +63,18 @@ public class UninstallAlertDialogFragment extends DialogFragment implements
      * @return The number of bytes.
      */
     private long getAppDataSizeForUser(@NonNull String pkg, @NonNull UserHandle user) {
-        StorageManager storageManager = getContext().getSystemService(StorageManager.class);
+        PackageManager packageManager = getContext().getPackageManager();
         StorageStatsManager storageStatsManager =
                 getContext().getSystemService(StorageStatsManager.class);
 
-        List<StorageVolume> volumes = storageManager.getStorageVolumes();
-        long appDataSize = 0;
-
-        int numVolumes = volumes.size();
-        for (int i = 0; i < numVolumes; i++) {
-            StorageStats stats;
-            try {
-                stats = storageStatsManager.queryStatsForPackage(convert(volumes.get(i).getUuid()),
-                        pkg, user);
-            } catch (PackageManager.NameNotFoundException | IOException e) {
-                Log.e(LOG_TAG, ""Cannot determine amount of app data for "" + pkg + "" on ""
-                        + volumes.get(i) + "" (user "" + user + "")"", e);
-                continue;
-            }
-
-            appDataSize += stats.getDataBytes();
+        try {
+            ApplicationInfo info = packageManager.getApplicationInfo(pkg, 0);
+            return storageStatsManager.queryStatsForPackage(
+                    info.storageUuid, pkg, user).getDataBytes();
+        } catch (PackageManager.NameNotFoundException | IOException e) {
+            Log.e(LOG_TAG, ""Cannot determine amount of app data for "" + pkg, e);
+            return 0;
         }
-
-        return appDataSize;
     }
 
     /**
",8,20,UninstallAlertDialogFragment::getAppDataSizeForUser
249,df8fb7aba99e839cc7fc1a063923ab8375c90365,FODCircleView.java,ModificationType.MODIFY,"@@ -201,6 +201,7 @@ public class FODCircleView extends ImageView {
                 super.onDraw(canvas);
             }
         };
+        mPressedView.setImageResource(R.drawable.fod_icon_pressed);
 
         mWindowManager.addView(this, mParams);
 
",1,0,FODCircleView::FODCircleView
250,04946cf98899916545eb5ea9b3cbffe88c1f1109,CompanionDeviceManagerService.java,ModificationType.MODIFY,"@@ -316,12 +316,14 @@ public class CompanionDeviceManagerService extends SystemService implements Bind
                             .toString());
             long identity = Binder.clearCallingIdentity();
             try {
-                return PendingIntent.getActivity(getContext(),
+                return PendingIntent.getActivityAsUser(getContext(),
                         0 /* request code */,
                         NotificationAccessConfirmationActivityContract.launcherIntent(
                                 userId, component, packageTitle),
                         PendingIntent.FLAG_IMMUTABLE | PendingIntent.FLAG_ONE_SHOT
-                                | PendingIntent.FLAG_CANCEL_CURRENT);
+                                | PendingIntent.FLAG_CANCEL_CURRENT,
+                        null /* options */,
+                        new UserHandle(userId));
             } finally {
                 Binder.restoreCallingIdentity(identity);
             }
",4,2,CompanionDeviceManagerService::CompanionDeviceManagerImpl::requestNotificationAccess
251,94b70411e3b104ac307a51b60ec853dd12f80888,GlobalScreenshot.java,ModificationType.MODIFY,"@@ -49,6 +49,7 @@ import android.content.ContentResolver;
 import android.content.Context;
 import android.content.Intent;
 import android.content.pm.ActivityInfo;
+import android.content.pm.ApplicationInfo;
 import android.content.pm.PackageManager;
 import android.content.pm.UserInfo;
 import android.content.res.Configuration;
@@ -103,12 +104,15 @@ import com.android.internal.annotations.VisibleForTesting;
 import com.android.internal.config.sysui.SystemUiDeviceConfigFlags;
 import com.android.internal.messages.nano.SystemMessageProto.SystemMessage;
 import com.android.internal.statusbar.IStatusBarService;
+import com.android.systemui.Dependency;
 import com.android.systemui.R;
 import com.android.systemui.SysUiServiceProvider;
 import com.android.systemui.SystemUI;
 import com.android.systemui.SystemUIFactory;
 import com.android.systemui.shared.system.ActivityManagerWrapper;
+import com.android.systemui.shared.system.TaskStackChangeListener;
 import com.android.systemui.statusbar.phone.StatusBar;
+import com.android.systemui.UiOffloadThread;
 import com.android.systemui.util.NotificationChannels;
 
 import libcore.io.IoUtils;
@@ -177,36 +181,18 @@ class SaveImageInBackgroundTask extends AsyncTask<Void, Void, Void> {
     private final boolean mSmartActionsEnabled;
     private final Random mRandom = new Random();
 
-    private static CharSequence getRunningActivityName(Context context) {
-        final ActivityManager am = context.getSystemService(ActivityManager.class);
-        final PackageManager pm = context.getPackageManager();
-
-        List<ActivityManager.RunningTaskInfo> tasks = am.getRunningTasks(1);
-        if (tasks != null && !tasks.isEmpty()) {
-            ActivityManager.RunningTaskInfo top = tasks.get(0);
-            try {
-                ActivityInfo info = pm.getActivityInfo(top.topActivity, 0);
-                return pm.getApplicationLabel(info.applicationInfo);
-            } catch (PackageManager.NameNotFoundException e) {
-            }
-        }
-
-        return null;
-    }
-
     SaveImageInBackgroundTask(Context context, SaveImageInBackgroundData data,
-            NotificationManager nManager) {
+            NotificationManager nManager, String appLabel) {
         Resources r = context.getResources();
 
         // Prepare all the output metadata
         mParams = data;
         mImageTime = System.currentTimeMillis();
         String imageDate = new SimpleDateFormat(""yyyyMMdd-HHmmss"").format(new Date(mImageTime));
-        CharSequence appName = getRunningActivityName(context);
         boolean onKeyguard = context.getSystemService(KeyguardManager.class).isKeyguardLocked();
-        if (!onKeyguard && appName != null) {
+        if (!onKeyguard && appLabel != null) {
             // Replace all spaces and special chars with an underscore
-            String appNameString = appName.toString().replaceAll(""[\\\\/:*?\""<>|\\s]+"", ""_"");
+            String appNameString = appLabel.toString().replaceAll(""[\\\\/:*?\""<>|\\s]+"", ""_"");
             mImageFileName = String.format(SCREENSHOT_FILE_NAME_TEMPLATE_APPNAME,
                     imageDate, appNameString);
         } else {
@@ -667,6 +653,33 @@ class GlobalScreenshot {
     private AudioManager mAudioManager;
     private Vibrator mVibrator;
 
+    private ComponentName mTaskComponentName;
+    private PackageManager mPm;
+
+    private final UiOffloadThread mUiOffloadThread = Dependency.get(UiOffloadThread.class);
+    private final TaskStackChangeListener mTaskListener = new TaskStackChangeListener() {
+        @Override
+        public void onTaskStackChanged() {
+            mUiOffloadThread.submit(() -> {
+                try {
+                    final ActivityManager.StackInfo focusedStack =
+                            ActivityTaskManager.getService().getFocusedStackInfo();
+                    if (focusedStack != null && focusedStack.topActivity != null) {
+                        mTaskComponentName = focusedStack.topActivity;
+                    }
+                } catch (Exception e) {}
+            });
+        }
+    };
+
+    private String getForegroundAppLabel() {
+        try {
+            final ActivityInfo ai = mPm.getActivityInfo(mTaskComponentName, 0);
+            return ai.applicationInfo.loadLabel(mPm).toString();
+        } catch (PackageManager.NameNotFoundException e) {
+             return null;
+        }
+    }
 
     /**
      * @param context everything needs a context :(
@@ -743,12 +756,21 @@ class GlobalScreenshot {
         // Grab system services needed for screenshot sound
         mAudioManager = (AudioManager) mContext.getSystemService(Context.AUDIO_SERVICE);
         mVibrator = (Vibrator) mContext.getSystemService(Context.VIBRATOR_SERVICE);
+
+        // Grab PackageManager
+        mPm = mContext.getPackageManager();
+
+        // Register task stack listener
+        ActivityManagerWrapper.getInstance().registerTaskStackListener(mTaskListener);
+
+        // Initialize current foreground package name
+        mTaskListener.onTaskStackChanged();
     }
 
     /**
      * Creates a new worker thread and saves the screenshot to the media store.
      */
-    private void saveScreenshotInWorkerThread(Consumer<Uri> finisher) {
+    private void saveScreenshotInWorkerThread(Consumer<Uri> finisher, String appLabel) {
         SaveImageInBackgroundData data = new SaveImageInBackgroundData();
         data.context = mContext;
         data.image = mScreenBitmap;
@@ -759,8 +781,8 @@ class GlobalScreenshot {
         if (mSaveInBgTask != null) {
             mSaveInBgTask.cancel(false);
         }
-        mSaveInBgTask = new SaveImageInBackgroundTask(mContext, data, mNotificationManager)
-                .execute();
+        mSaveInBgTask = new SaveImageInBackgroundTask(
+                mContext, data, mNotificationManager, appLabel).execute();
     }
 
     /**
@@ -787,7 +809,7 @@ class GlobalScreenshot {
 
         // Start the post-screenshot animation
         startAnimation(finisher, mDisplayMetrics.widthPixels, mDisplayMetrics.heightPixels,
-                statusBarVisible, navBarVisible);
+                statusBarVisible, navBarVisible, getForegroundAppLabel());
     }
 
     void takeScreenshot(Consumer<Uri> finisher, boolean statusBarVisible, boolean navBarVisible) {
@@ -936,7 +958,7 @@ class GlobalScreenshot {
      * Starts the animation after taking the screenshot
      */
     private void startAnimation(final Consumer<Uri> finisher, int w, int h,
-            boolean statusBarVisible, boolean navBarVisible) {
+            boolean statusBarVisible, boolean navBarVisible, String appLabel) {
         // If power save is on, show a toast so there is some visual indication that a screenshot
         // has been taken.
         PowerManager powerManager = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
@@ -966,7 +988,7 @@ class GlobalScreenshot {
             @Override
             public void onAnimationEnd(Animator animation) {
                 // Save the screenshot once we have a bit of time now
-                saveScreenshotInWorkerThread(finisher);
+                saveScreenshotInWorkerThread(finisher, appLabel);
                 mWindowManager.removeView(mScreenshotLayout);
 
                 // Clear any references to the bitmap
",49,27,"GlobalScreenshot::TaskStackChangeListener, GlobalScreenshot::startAnimation, GlobalScreenshot::GlobalScreenshot, SaveImageInBackgroundTask::SaveImageInBackgroundTask, SaveImageInBackgroundTask::getRunningActivityName, GlobalScreenshot::saveScreenshotInWorkerThread, GlobalScreenshot::startAnimation, GlobalScreenshot::getForegroundAppLabel, GlobalScreenshot::saveScreenshotInWorkerThread, SaveImageInBackgroundTask::SaveImageInBackgroundTask, GlobalScreenshot::takeScreenshot"
252,92e0aaf9c0da1e4bb13515c8fb3c08a9a8cc00bf,GlobalActionsDialog.java,ModificationType.MODIFY,"@@ -1288,6 +1288,7 @@ public class GlobalActionsDialog implements DialogInterface.OnDismissListener,
 
         @Override
         public void onClickItem(int position) {
+            if (mDialog == null) return;
             Action item = mAdapter.getItem(position);
             if (!(item instanceof SilentModeTriStateAction)) {
                 mDialog.dismiss();
",1,0,GlobalActionsDialog::MyAdapter::onClickItem
253,1ac5d4f8f92667c7a0aa377af3bd387410c357e8,WiredAccessoryManager.java,ModificationType.MODIFY,"@@ -70,6 +70,7 @@ final class WiredAccessoryManager implements WiredAccessoryCallbacks {
     private static final String NAME_H2W = ""h2w"";
     private static final String NAME_USB_AUDIO = ""usb_audio"";
     private static final String NAME_HDMI_AUDIO = ""hdmi_audio"";
+    private static final String NAME_DP_AUDIO = ""soc:qcom,msm-ext-disp"";
     private static final String NAME_HDMI = ""hdmi"";
 
     private static final int MSG_NEW_DEVICE_STATE = 1;
@@ -416,22 +417,86 @@ final class WiredAccessoryManager implements WiredAccessoryCallbacks {
                 }
             }
 
+            // Monitor DisplayPort
+            uei = new UEventInfo(NAME_DP_AUDIO, BIT_HDMI_AUDIO, 0, 0);
+            if (uei.checkSwitchExists()) {
+                retVal.add(uei);
+            } else {
+                Slog.w(TAG, ""This kernel does not have DP audio support"");
+            }
+
             return retVal;
         }
 
         @Override
         public void onUEvent(UEventObserver.UEvent event) {
-            if (LOG) Slog.v(TAG, ""Headset UEVENT: "" + event.toString());
+            String devPath = event.get(""DEVPATH"");
+            String name = event.get(""NAME"");
+            int state = 0;
+
+            if (name == null) {
+                name = event.get(""SWITCH_NAME"");
+            }
 
             try {
-                String devPath = event.get(""DEVPATH"");
-                String name = event.get(""SWITCH_NAME"");
-                int state = Integer.parseInt(event.get(""SWITCH_STATE""));
-                synchronized (mLock) {
-                    updateStateLocked(devPath, name, state);
+                if (name.equals(NAME_DP_AUDIO)) {
+                    String stateStr = event.get(""STATE"");
+                    int offset = 0;
+                    int length = stateStr.length();
+
+                    // parse DP=1\nHDMI=1\0
+                    while (offset < length) {
+                        int equals = stateStr.indexOf('=', offset);
+
+                        if (equals > offset) {
+                            String intfName = stateStr.substring(offset, equals);
+
+                            if (intfName.equals(""DP"")) {
+                                state = Integer.parseInt(
+                                        stateStr.substring(equals + 1, equals + 2));
+                                break;
+                            }
+                        }
+
+                        offset = equals + 3;
+                    }
+                } else {
+                    state = Integer.parseInt(event.get(""SWITCH_STATE""));
                 }
             } catch (NumberFormatException e) {
-                Slog.e(TAG, ""Could not parse switch state from event "" + event);
+                Slog.i(TAG, ""couldn't get state from event, checking node"");
+
+                for (int i = 0; i < mUEventInfo.size(); ++i) {
+                    UEventInfo uei = mUEventInfo.get(i);
+
+                    if (name.equals(uei.getDevName())) {
+                        char[] buffer = new char[1024];
+                        int len = 0;
+
+                        try {
+                            FileReader file = new FileReader(uei.getSwitchStatePath());
+                            len = file.read(buffer, 0, 1024);
+                            file.close();
+                        } catch (FileNotFoundException e1) {
+                            Slog.e(TAG, ""file not found"");
+                            break;
+                        } catch (Exception e11) {
+                            Slog.e(TAG, ""onUEvent exception"", e11);
+                        }
+
+                        try {
+                            state = Integer.parseInt((new String(buffer, 0, len)).trim());
+                        } catch (NumberFormatException e2) {
+                            Slog.e(TAG, ""could not convert to number"");
+                            break;
+                        }
+                        break;
+                    }
+                }
+            }
+
+            synchronized (mLock) {
+                updateStateLocked(devPath, name, state);
             }
         }
 
@@ -450,12 +515,79 @@ final class WiredAccessoryManager implements WiredAccessoryCallbacks {
             private final int mState1Bits;
             private final int mState2Bits;
             private final int mStateNbits;
+            private int mDevIndex;
+            private int mCableIndex;
 
             public UEventInfo(String devName, int state1Bits, int state2Bits, int stateNbits) {
                 mDevName = devName;
                 mState1Bits = state1Bits;
                 mState2Bits = state2Bits;
                 mStateNbits = stateNbits;
+
+                if (mDevName.equals(NAME_DP_AUDIO)) {
+                    getDevIndex();
+                    getCableIndex();
+                }
+            }
+
+            private void getDevIndex() {
+                int index = 0;
+                char[] buffer = new char[1024];
+
+                while (true) {
+                    String devPath = String.format(Locale.US,
+                            ""/sys/class/switch/extcon%d/name"",
+                            index);
+
+                    try {
+                        FileReader file = new FileReader(devPath);
+                        int len = file.read(buffer, 0, 1024);
+                        file.close();
+
+                        String devName = (new String(buffer, 0, len)).trim();
+                        if (devName.equals(mDevName)) {
+                            mDevIndex = index;
+                            break;
+                        } else {
+                            index++;
+                        }
+                    } catch (FileNotFoundException e) {
+                        break;
+                    } catch (Exception e) {
+                        Slog.e(TAG, ""getDevIndex exception"", e);
+                        break;
+                    }
+                }
+            }
+
+            private void getCableIndex() {
+                int index = 0;
+                char[] buffer = new char[1024];
+
+                while (true) {
+                    String cablePath = String.format(Locale.US,
+                            ""/sys/class/switch/extcon%d/cable.%d/name"",
+                            mDevIndex, index);
+
+                    try {
+                        FileReader file = new FileReader(cablePath);
+                        int len = file.read(buffer, 0, 1024);
+                        file.close();
+
+                        String cableName = (new String(buffer, 0, len)).trim();
+                        if (cableName.equals(""DP"")) {
+                            mCableIndex = index;
+                            break;
+                        } else {
+                            index++;
+                        }
+                    } catch (FileNotFoundException e) {
+                        break;
+                    } catch (Exception e) {
+                        Slog.e(TAG, ""getCableIndex exception"", e);
+                        break;
+                    }
+                }
             }
 
             public String getDevName() {
@@ -463,10 +595,20 @@ final class WiredAccessoryManager implements WiredAccessoryCallbacks {
             }
 
             public String getDevPath() {
+                if (mDevName.equals(NAME_DP_AUDIO)) {
+                    return String.format(Locale.US,
+                            ""/devices/platform/soc/%s/extcon/extcon%d"",
+                            mDevName, mDevIndex);
+                }
                 return String.format(Locale.US, ""/devices/virtual/switch/%s"", mDevName);
             }
 
             public String getSwitchStatePath() {
+                if (mDevName.equals(NAME_DP_AUDIO)) {
+                    return String.format(Locale.US,
+                            ""/sys/class/switch/extcon%d/cable.%d/state"",
+                            mDevIndex, mCableIndex);
+                }
                 return String.format(Locale.US, ""/sys/class/switch/%s/state"", mDevName);
             }
 
",149,7,"WiredAccessoryManager::WiredAccessoryObserver::UEventInfo::getDevPath, WiredAccessoryManager::WiredAccessoryObserver::makeObservedUEventList, WiredAccessoryManager::WiredAccessoryObserver::UEventInfo::getCableIndex, WiredAccessoryManager::WiredAccessoryObserver::onUEvent, WiredAccessoryManager::WiredAccessoryObserver::UEventInfo::getSwitchStatePath, WiredAccessoryManager::WiredAccessoryObserver::UEventInfo::getDevIndex, WiredAccessoryManager::WiredAccessoryObserver::UEventInfo::UEventInfo"
254,b2852f022d36436ec93f579f21e99e03eeff8813,WiredAccessoryManager.java,ModificationType.MODIFY,"@@ -536,8 +536,8 @@ final class WiredAccessoryManager implements WiredAccessoryCallbacks {
 
                 while (true) {
                     String devPath = String.format(Locale.US,
-                            ""/sys/class/switch/extcon%d/name"",
-                            index);
+                            ""/sys/devices/platform/soc/%s/extcon/extcon%d/name"",
+                            mDevName, index);
 
                     try {
                         FileReader file = new FileReader(devPath);
@@ -566,8 +566,8 @@ final class WiredAccessoryManager implements WiredAccessoryCallbacks {
 
                 while (true) {
                     String cablePath = String.format(Locale.US,
-                            ""/sys/class/switch/extcon%d/cable.%d/name"",
-                            mDevIndex, index);
+                            ""/sys/devices/platform/soc/%s/extcon/extcon%d/cable.%d/name"",
+                            mDevName, mDevIndex, index);
 
                     try {
                         FileReader file = new FileReader(cablePath);
@@ -606,8 +606,8 @@ final class WiredAccessoryManager implements WiredAccessoryCallbacks {
             public String getSwitchStatePath() {
                 if (mDevName.equals(NAME_DP_AUDIO)) {
                     return String.format(Locale.US,
-                            ""/sys/class/switch/extcon%d/cable.%d/state"",
-                            mDevIndex, mCableIndex);
+                            ""/sys/devices/platform/soc/%s/extcon/extcon%d/cable.%d/state"",
+                            mDevName, mDevIndex, mCableIndex);
                 }
                 return String.format(Locale.US, ""/sys/class/switch/%s/state"", mDevName);
             }
",6,6,"WiredAccessoryManager::WiredAccessoryObserver::UEventInfo::getCableIndex, WiredAccessoryManager::WiredAccessoryObserver::UEventInfo::getSwitchStatePath, WiredAccessoryManager::WiredAccessoryObserver::UEventInfo::getDevIndex"
255,d8312348044bacac2c4419855295c4248163d6d4,WiredAccessoryManager.java,ModificationType.MODIFY,"@@ -71,6 +71,11 @@ final class WiredAccessoryManager implements WiredAccessoryCallbacks {
     private static final String NAME_USB_AUDIO = ""usb_audio"";
     private static final String NAME_HDMI_AUDIO = ""hdmi_audio"";
     private static final String NAME_DP_AUDIO = ""soc:qcom,msm-ext-disp"";
+    // within a device, a single stream supports DP
+    private static final String[] DP_AUDIO_CONNS = {
+            NAME_DP_AUDIO + ""/1/0"",
+            NAME_DP_AUDIO + ""/0/0""
+    };
     private static final String NAME_HDMI = ""hdmi"";
 
     private static final int MSG_NEW_DEVICE_STATE = 1;
@@ -173,7 +178,7 @@ final class WiredAccessoryManager implements WiredAccessoryCallbacks {
                     break;
             }
 
-            updateLocked(NAME_H2W,
+            updateLocked(NAME_H2W, """",
                     (mHeadsetState & ~(BIT_HEADSET | BIT_HEADSET_NO_MIC | BIT_LINEOUT)) | headset);
         }
     }
@@ -197,7 +202,7 @@ final class WiredAccessoryManager implements WiredAccessoryCallbacks {
      * @param newName  One of the NAME_xxx variables defined above.
      * @param newState 0 or one of the BIT_xxx variables defined above.
      */
-    private void updateLocked(String newName, int newState) {
+    private void updateLocked(String newName, String address, int newState) {
         // Retain only relevant bits
         int headsetState = newState & SUPPORTED_HEADSETS;
         int usb_headset_anlg = headsetState & BIT_USB_HEADSET_ANLG;
@@ -238,8 +243,9 @@ final class WiredAccessoryManager implements WiredAccessoryCallbacks {
         mWakeLock.acquire();
 
         Log.i(TAG, ""MSG_NEW_DEVICE_STATE"");
+        // Send a combined name, address string separated by |
         Message msg = mHandler.obtainMessage(MSG_NEW_DEVICE_STATE, headsetState,
-                mHeadsetState, """");
+                mHeadsetState, newName + ""/"" + address);
         mHandler.sendMessage(msg);
 
         mHeadsetState = headsetState;
@@ -262,12 +268,13 @@ final class WiredAccessoryManager implements WiredAccessoryCallbacks {
     };
 
     private void setDevicesState(
-            int headsetState, int prevHeadsetState, String headsetName) {
+            int headsetState, int prevHeadsetState, String headsetNameAddr) {
         synchronized (mLock) {
             int allHeadsets = SUPPORTED_HEADSETS;
             for (int curHeadset = 1; allHeadsets != 0; curHeadset <<= 1) {
                 if ((curHeadset & allHeadsets) != 0) {
-                    setDeviceStateLocked(curHeadset, headsetState, prevHeadsetState, headsetName);
+                    setDeviceStateLocked(curHeadset, headsetState, prevHeadsetState,
+                            headsetNameAddr);
                     allHeadsets &= ~curHeadset;
                 }
             }
@@ -275,7 +282,7 @@ final class WiredAccessoryManager implements WiredAccessoryCallbacks {
     }
 
     private void setDeviceStateLocked(int headset,
-            int headsetState, int prevHeadsetState, String headsetName) {
+            int headsetState, int prevHeadsetState, String headsetNameAddr) {
         if ((headsetState & headset) != (prevHeadsetState & headset)) {
             int outDevice = 0;
             int inDevice = 0;
@@ -306,15 +313,18 @@ final class WiredAccessoryManager implements WiredAccessoryCallbacks {
             }
 
             if (LOG) {
-                Slog.v(TAG, ""headsetName: "" + headsetName +
+                Slog.v(TAG, ""headsetNameAddr: "" + headsetNameAddr +
                         (state == 1 ? "" connected"" : "" disconnected""));
             }
 
+            String[] hs = headsetNameAddr.split(""/"");
             if (outDevice != 0) {
-                mAudioManager.setWiredDeviceConnectionState(outDevice, state, """", headsetName);
+                mAudioManager.setWiredDeviceConnectionState(outDevice, state,
+                        (hs.length > 1 ? hs[1] : """"), hs[0]);
             }
             if (inDevice != 0) {
-                mAudioManager.setWiredDeviceConnectionState(inDevice, state, """", headsetName);
+                mAudioManager.setWiredDeviceConnectionState(inDevice, state,
+                        (hs.length > 1 ? hs[1] : """"), hs[0]);
             }
         }
     }
@@ -417,12 +427,17 @@ final class WiredAccessoryManager implements WiredAccessoryCallbacks {
                 }
             }
 
-            // Monitor DisplayPort
-            uei = new UEventInfo(NAME_DP_AUDIO, BIT_HDMI_AUDIO, 0, 0);
-            if (uei.checkSwitchExists()) {
-                retVal.add(uei);
-            } else {
-                Slog.w(TAG, ""This kernel does not have DP audio support"");
+            for (String conn : DP_AUDIO_CONNS) {
+                // Monitor DisplayPort
+                if (LOG) {
+                    Slog.v(TAG, ""Monitor DP conn "" + conn);
+                }
+                uei = new UEventInfo(conn, BIT_HDMI_AUDIO, 0, 0);
+                if (uei.checkSwitchExists()) {
+                    retVal.add(uei);
+                } else {
+                    Slog.w(TAG, ""Conn "" + conn + "" does not have DP audio support"");
+                }
             }
 
             return retVal;
@@ -439,7 +454,7 @@ final class WiredAccessoryManager implements WiredAccessoryCallbacks {
             }
 
             try {
-                if (name.equals(NAME_DP_AUDIO)) {
+                if (name.startsWith(NAME_DP_AUDIO)) {
                     String stateStr = event.get(""STATE"");
                     int offset = 0;
                     int length = stateStr.length();
@@ -504,7 +519,8 @@ final class WiredAccessoryManager implements WiredAccessoryCallbacks {
             for (int i = 0; i < mUEventInfo.size(); ++i) {
                 UEventInfo uei = mUEventInfo.get(i);
                 if (devPath.equals(uei.getDevPath())) {
-                    updateLocked(name, uei.computeNewHeadsetState(mHeadsetState, state));
+                    updateLocked(name, uei.getDevAddress(),
+                            uei.computeNewHeadsetState(mHeadsetState, state));
                     return;
                 }
             }
@@ -512,6 +528,7 @@ final class WiredAccessoryManager implements WiredAccessoryCallbacks {
 
         private final class UEventInfo {
             private final String mDevName;
+            private String mDevAddress;
             private final int mState1Bits;
             private final int mState2Bits;
             private final int mStateNbits;
@@ -520,71 +537,103 @@ final class WiredAccessoryManager implements WiredAccessoryCallbacks {
 
             public UEventInfo(String devName, int state1Bits, int state2Bits, int stateNbits) {
                 mDevName = devName;
+                mDevAddress = ""controller=0;stream=0"";
                 mState1Bits = state1Bits;
                 mState2Bits = state2Bits;
                 mStateNbits = stateNbits;
 
-                if (mDevName.equals(NAME_DP_AUDIO)) {
-                    getDevIndex();
-                    getCableIndex();
+                mDevIndex = -1;
+                mCableIndex = -1;
+
+                if (mDevName.startsWith(NAME_DP_AUDIO)) {
+                    int idx = mDevName.indexOf(""/"");
+                    if (idx != -1) {
+                        int idx2 = mDevName.indexOf(""/"", idx + 1);
+                        assert(idx2 != -1);
+                        int dev = Integer.parseInt(mDevName.substring(idx + 1, idx2));
+                        int cable = Integer.parseInt(mDevName.substring(idx2 + 1));
+                        mDevAddress = ""controller="" + dev + "";stream="" + cable;
+                        if (LOG) {
+                            Slog.v(TAG, ""UEvent dev address "" + mDevAddress);
+                        }
+                        checkDevIndex(dev);
+                        checkCableIndex(cable);
+                    }
                 }
             }
 
-            private void getDevIndex() {
+            private void checkDevIndex(int devIndex) {
                 int index = 0;
                 char[] buffer = new char[1024];
 
                 while (true) {
                     String devPath = String.format(Locale.US,
                             ""/sys/devices/platform/soc/%s/extcon/extcon%d/name"",
-                            mDevName, index);
+                            NAME_DP_AUDIO, index);
+                    if (LOG) {
+                        Slog.v(TAG, ""checkDevIndex "" + devPath);
+                    }
+
+                    File f = new File(devPath);
+                    if (!f.exists()) {
+                        Slog.e(TAG, ""file "" + devPath + "" not found"");
+                        break;
+                    }
 
                     try {
-                        FileReader file = new FileReader(devPath);
+                        FileReader file = new FileReader(f);
                         int len = file.read(buffer, 0, 1024);
                         file.close();
 
                         String devName = (new String(buffer, 0, len)).trim();
-                        if (devName.equals(mDevName)) {
-                            mDevIndex = index;
+                        if (devName.startsWith(NAME_DP_AUDIO) && index == devIndex) {
+                            mDevIndex = devIndex;
                             break;
                         } else {
                             index++;
                         }
-                    } catch (FileNotFoundException e) {
-                        break;
                     } catch (Exception e) {
-                        Slog.e(TAG, ""getDevIndex exception"", e);
+                        Slog.e(TAG, ""checkDevIndex exception"", e);
                         break;
                     }
                 }
             }
 
-            private void getCableIndex() {
+            private void checkCableIndex(int cableIndex) {
+                if (mDevIndex == -1) {
+                    return;
+                }
                 int index = 0;
                 char[] buffer = new char[1024];
 
                 while (true) {
                     String cablePath = String.format(Locale.US,
                             ""/sys/devices/platform/soc/%s/extcon/extcon%d/cable.%d/name"",
-                            mDevName, mDevIndex, index);
+                            NAME_DP_AUDIO, mDevIndex, index);
+                    if (LOG) {
+                        Slog.v(TAG, ""checkCableIndex "" + cablePath);
+                    }
+
+                    File f = new File(cablePath);
+                    if (!f.exists()) {
+                        Slog.e(TAG, ""file "" + cablePath + "" not found"");
+                        break;
+                    }
 
                     try {
-                        FileReader file = new FileReader(cablePath);
+                        FileReader file = new FileReader(f);
                         int len = file.read(buffer, 0, 1024);
                         file.close();
 
                         String cableName = (new String(buffer, 0, len)).trim();
-                        if (cableName.equals(""DP"")) {
-                            mCableIndex = index;
+                        if (cableName.equals(""DP"") && index == cableIndex) {
+                            mCableIndex = cableIndex;
                             break;
                         } else {
                             index++;
                         }
-                    } catch (FileNotFoundException e) {
-                        break;
                     } catch (Exception e) {
-                        Slog.e(TAG, ""getCableIndex exception"", e);
+                        Slog.e(TAG, ""checkCableIndex exception"", e);
                         break;
                     }
                 }
@@ -594,20 +643,24 @@ final class WiredAccessoryManager implements WiredAccessoryCallbacks {
                 return mDevName;
             }
 
+            public String getDevAddress() {
+                return mDevAddress;
+            }
+
             public String getDevPath() {
-                if (mDevName.equals(NAME_DP_AUDIO)) {
+                if (mDevName.startsWith(NAME_DP_AUDIO)) {
                     return String.format(Locale.US,
                             ""/devices/platform/soc/%s/extcon/extcon%d"",
-                            mDevName, mDevIndex);
+                            NAME_DP_AUDIO, mDevIndex);
                 }
                 return String.format(Locale.US, ""/devices/virtual/switch/%s"", mDevName);
             }
 
             public String getSwitchStatePath() {
-                if (mDevName.equals(NAME_DP_AUDIO)) {
+                if (mDevName.startsWith(NAME_DP_AUDIO)) {
                     return String.format(Locale.US,
                             ""/sys/devices/platform/soc/%s/extcon/extcon%d/cable.%d/state"",
-                            mDevName, mDevIndex, mCableIndex);
+                            NAME_DP_AUDIO, mDevIndex, mCableIndex);
                 }
                 return String.format(Locale.US, ""/sys/class/switch/%s/state"", mDevName);
             }
@@ -680,7 +733,7 @@ final class WiredAccessoryManager implements WiredAccessoryCallbacks {
             synchronized (mLock) {
                 int mask = maskAndState.first;
                 int state = maskAndState.second;
-                updateLocked(name, mHeadsetState & ~(mask & ~state) | (mask & state));
+                updateLocked(name, """", mHeadsetState & ~(mask & ~state) | (mask & state));
                 return;
             }
         }
",94,41,"WiredAccessoryManager::WiredAccessoryObserver::UEventInfo::checkCableIndex, WiredAccessoryManager::updateLocked, WiredAccessoryManager::setDeviceStateLocked, WiredAccessoryManager::updateLocked, WiredAccessoryManager::WiredAccessoryExtconObserver::updateState, WiredAccessoryManager::WiredAccessoryObserver::UEventInfo::UEventInfo, WiredAccessoryManager::WiredAccessoryObserver::makeObservedUEventList, WiredAccessoryManager::WiredAccessoryObserver::UEventInfo::getDevAddress, WiredAccessoryManager::WiredAccessoryObserver::UEventInfo::getDevIndex, WiredAccessoryManager::WiredAccessoryObserver::UEventInfo::getCableIndex, WiredAccessoryManager::WiredAccessoryObserver::UEventInfo::getSwitchStatePath, WiredAccessoryManager::notifyWiredAccessoryChanged, WiredAccessoryManager::WiredAccessoryObserver::updateStateLocked, WiredAccessoryManager::setDevicesState, WiredAccessoryManager::WiredAccessoryObserver::onUEvent, WiredAccessoryManager::WiredAccessoryObserver::UEventInfo::checkDevIndex, WiredAccessoryManager::setDeviceStateLocked, WiredAccessoryManager::WiredAccessoryObserver::UEventInfo::getDevPath, WiredAccessoryManager::setDevicesState"
256,0692127e5b435ad264986721fefe84de600bcd1c,WiredAccessoryManager.java,ModificationType.MODIFY,"@@ -129,7 +129,7 @@ final class WiredAccessoryManager implements WiredAccessoryCallbacks {
         }
 
 
-        if (ExtconUEventObserver.extconExists()) {
+        if (ExtconUEventObserver.extconExists() && mExtconObserver.uEventCount() > 0) {
             if (mUseDevInputEventForAudioJack) {
                 Log.w(TAG, ""Both input event and extcon are used for audio jack,""
                         + "" please just choose one."");
@@ -713,6 +713,10 @@ final class WiredAccessoryManager implements WiredAccessoryCallbacks {
 
         }
 
+        public int uEventCount() {
+            return mExtconInfos.size();
+        }
+
         @Override
         public Pair<Integer, Integer> parseState(ExtconInfo extconInfo, String status) {
             if (LOG) Slog.v(TAG, ""status  "" + status);
",5,1,"WiredAccessoryManager::onSystemReady, WiredAccessoryManager::WiredAccessoryExtconObserver::uEventCount"
257,8cf2ddeaf18aa1fbbdfb3bf016a7147a0c1638bc,WiredAccessoryManager.java,ModificationType.MODIFY,"@@ -87,6 +87,7 @@ final class WiredAccessoryManager implements WiredAccessoryCallbacks {
     private final AudioManager mAudioManager;
 
     private int mHeadsetState;
+    private int mDpCount;
 
     private int mSwitchValues;
 
@@ -199,25 +200,32 @@ final class WiredAccessoryManager implements WiredAccessoryCallbacks {
      * results in support for the last one plugged in. Similarly, unplugging either is seen as
      * unplugging all.
      *
+     * For Display port allow up to two connections.
+     * Block display port request if HDMI already connected and vice versa.
+     *
      * @param newName  One of the NAME_xxx variables defined above.
      * @param newState 0 or one of the BIT_xxx variables defined above.
      */
     private void updateLocked(String newName, String address, int newState) {
         // Retain only relevant bits
         int headsetState = newState & SUPPORTED_HEADSETS;
+        int newDpState = newState & BIT_HDMI_AUDIO;
         int usb_headset_anlg = headsetState & BIT_USB_HEADSET_ANLG;
         int usb_headset_dgtl = headsetState & BIT_USB_HEADSET_DGTL;
         int h2w_headset = headsetState & (BIT_HEADSET | BIT_HEADSET_NO_MIC | BIT_LINEOUT);
         boolean h2wStateChange = true;
         boolean usbStateChange = true;
+        boolean dpBitState = (mHeadsetState & BIT_HDMI_AUDIO) > 0;
+        boolean dpCountState = mDpCount != 0;
         if (LOG) {
             Slog.v(TAG, ""newName="" + newName
                     + "" newState="" + newState
                     + "" headsetState="" + headsetState
-                    + "" prev headsetState="" + mHeadsetState);
+                    + "" prev headsetState="" + mHeadsetState
+                    + "" num of active dp conns= "" + mDpCount);
         }
 
-        if (mHeadsetState == headsetState) {
+        if (mHeadsetState == headsetState && !newName.startsWith(NAME_DP_AUDIO)) {
             Log.e(TAG, ""No state change."");
             return;
         }
@@ -240,12 +248,42 @@ final class WiredAccessoryManager implements WiredAccessoryCallbacks {
             return;
         }
 
+        if (newName.startsWith(NAME_DP_AUDIO)) {
+            if ((newDpState > 0) && (mDpCount < DP_AUDIO_CONNS.length)
+                    && (dpBitState == dpCountState)) {
+                // Allow DP0 if no HDMI previously connected.
+                // Allow second request only if DP connected previously.
+                mDpCount++;
+            } else if ((newDpState == 0) && (mDpCount > 0)) {
+                mDpCount--;
+            } else {
+                Log.e(TAG, ""No state change for DP."");
+                return;
+            }
+        }
+
         mWakeLock.acquire();
 
         Log.i(TAG, ""MSG_NEW_DEVICE_STATE"");
         // Send a combined name, address string separated by |
-        Message msg = mHandler.obtainMessage(MSG_NEW_DEVICE_STATE, headsetState,
-                mHeadsetState, newName + ""/"" + address);
+        Message msg;
+        if (newName.startsWith(NAME_DP_AUDIO)) {
+            int pseudoHeadsetState = mHeadsetState;
+            if (dpBitState && (newDpState != 0)) {
+                // One DP already connected, so allow request to connect second.
+                pseudoHeadsetState = mHeadsetState & (~BIT_HDMI_AUDIO);
+            }
+            msg = mHandler.obtainMessage(MSG_NEW_DEVICE_STATE, headsetState,
+                    pseudoHeadsetState, NAME_DP_AUDIO + ""/"" + address);
+
+            if ((headsetState == 0) && (mDpCount != 0)) {
+                // Atleast one DP is connected, so keep mHeadsetState's DP bit set.
+                headsetState = headsetState | BIT_HDMI_AUDIO;
+            }
+        } else {
+            msg = mHandler.obtainMessage(MSG_NEW_DEVICE_STATE, headsetState,
+                    mHeadsetState, newName + ""/"" + address);
+        }
         mHandler.sendMessage(msg);
 
         mHeadsetState = headsetState;
@@ -552,7 +590,7 @@ final class WiredAccessoryManager implements WiredAccessoryCallbacks {
                         assert(idx2 != -1);
                         int dev = Integer.parseInt(mDevName.substring(idx + 1, idx2));
                         int cable = Integer.parseInt(mDevName.substring(idx2 + 1));
-                        mDevAddress = ""controller="" + dev + "";stream="" + cable;
+                        mDevAddress = ""controller="" + cable + "";stream="" + dev;
                         if (LOG) {
                             Slog.v(TAG, ""UEvent dev address "" + mDevAddress);
                         }
",43,5,"WiredAccessoryManager::updateLocked, WiredAccessoryManager::WiredAccessoryObserver::UEventInfo::UEventInfo"
258,08630565e4a2b2bafa930923c51d8c905d3940dd,PowerManager.java,ModificationType.MODIFY,"@@ -883,6 +883,15 @@ public final class PowerManager {
                 com.android.internal.R.integer.config_buttonBrightnessSettingDefault);
     }
 
+    /**
+     * Gets the default keyboard brightness value.
+     * @hide
+     */
+    public int getDefaultKeyboardBrightness() {
+        return mContext.getResources().getInteger(
+                com.android.internal.R.integer.config_keyboardBrightnessSettingDefault);
+    }
+
     /**
      * Creates a new wake lock with the specified level and flags.
      * <p>
@@ -1908,6 +1917,18 @@ public final class PowerManager {
         }
     }
 
+    /**
+     * @hide
+     */
+    public void setKeyboardVisibility(boolean visible) {
+        try {
+            if (mService != null) {
+                mService.setKeyboardVisibility(visible);
+            }
+        } catch (RemoteException e) {
+        }
+    }
+
     /**
      * If true, the doze component is not started until after the screen has been
      * turned off and the screen off animation has been performed.
",21,0,"PowerManager::getDefaultKeyboardBrightness, PowerManager::setKeyboardVisibility"
259,08630565e4a2b2bafa930923c51d8c905d3940dd,DisplayPowerController.java,ModificationType.MODIFY,"@@ -856,12 +856,15 @@ final class DisplayPowerController implements AutomaticBrightnessController.Call
             brightness = PowerManager.BRIGHTNESS_OFF;
             mBrightnessReasonTemp.setReason(BrightnessReason.REASON_SCREEN_OFF);
             mLights.getLight(LightsManager.LIGHT_ID_BUTTONS).setBrightness(brightness);
+            mLights.getLight(LightsManager.LIGHT_ID_KEYBOARD).setBrightness(brightness);
         }
 
-        // Disable button lights when dozing
+        // Disable button and keyboard lights when dozing
         if (state == Display.STATE_DOZE || state == Display.STATE_DOZE_SUSPEND) {
             mLights.getLight(LightsManager.LIGHT_ID_BUTTONS)
                     .setBrightness(PowerManager.BRIGHTNESS_OFF);
+            mLights.getLight(LightsManager.LIGHT_ID_KEYBOARD)
+                    .setBrightness(PowerManager.BRIGHTNESS_OFF);
         }
 
         // Always use the VR brightness when in the VR state.
",4,1,DisplayPowerController::updatePowerState
260,08630565e4a2b2bafa930923c51d8c905d3940dd,PhoneWindowManager.java,ModificationType.MODIFY,"@@ -2685,6 +2685,10 @@ public class PhoneWindowManager implements WindowManagerPolicy {
         }
     }
 
+    private boolean isBuiltInKeyboardVisible() {
+        return mHaveBuiltInKeyboard && !isHidden(mLidKeyboardAccessibility);
+    }
+
     /** {@inheritDoc} */
     @Override
     public void adjustConfigurationLw(Configuration config, int keyboardPresence,
@@ -5852,6 +5856,8 @@ public class PhoneWindowManager implements WindowManagerPolicy {
     }
 
     private void applyLidSwitchState() {
+        mPowerManager.setKeyboardVisibility(isBuiltInKeyboardVisible());
+
         final int lidState = mDefaultDisplayPolicy.getLidState();
         if (mLidControlsDisplayFold && mDisplayFoldController != null) {
             mDisplayFoldController.requestDeviceFolded(lidState == LID_CLOSED);
",6,0,"PhoneWindowManager::isBuiltInKeyboardVisible, PhoneWindowManager::applyLidSwitchState"
261,08630565e4a2b2bafa930923c51d8c905d3940dd,PowerManagerService.java,ModificationType.MODIFY,"@@ -261,10 +261,14 @@ public final class PowerManagerService extends SystemService
     private DreamManagerInternal mDreamManager;
     private Light mAttentionLight;
     private Light mButtonsLight;
+    private Light mKeyboardLight;
 
     private int mButtonTimeout;
     private int mButtonBrightness;
     private int mButtonBrightnessSettingDefault;
+    private boolean mKeyboardVisible;
+    private int mKeyboardBrightness;
+    private int mKeyboardBrightnessSettingDefault;
 
     private boolean mButtonPressed;
     private boolean mButtonOn;
@@ -881,6 +885,7 @@ public final class PowerManagerService extends SystemService
 
             PowerManager pm = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
             mButtonBrightnessSettingDefault = pm.getDefaultButtonBrightness();
+            mButtonBrightnessSettingDefault = pm.getDefaultKeyboardBrightness();
             mScreenBrightnessSettingMinimum = pm.getMinimumScreenBrightnessSetting();
             mScreenBrightnessSettingMaximum = pm.getMaximumScreenBrightnessSetting();
             mScreenBrightnessSettingDefault = pm.getDefaultScreenBrightnessSetting();
@@ -903,6 +908,7 @@ public final class PowerManagerService extends SystemService
             mLightsManager = getLocalService(LightsManager.class);
             mAttentionLight = mLightsManager.getLight(LightsManager.LIGHT_ID_ATTENTION);
             mButtonsLight = mLightsManager.getLight(LightsManager.LIGHT_ID_BUTTONS);
+            mKeyboardLight = mLightsManager.getLight(LightsManager.LIGHT_ID_KEYBOARD);
 
             // Initialize display power management.
             mDisplayManagerInternal.initPowerManagement(
@@ -978,6 +984,9 @@ public final class PowerManagerService extends SystemService
         resolver.registerContentObserver(LineageSettings.System.getUriFor(
                 LineageSettings.System.BUTTON_BACKLIGHT_ONLY_WHEN_PRESSED),
                 false, mSettingsObserver, UserHandle.USER_ALL);
+        resolver.registerContentObserver(LineageSettings.Secure.getUriFor(
+                LineageSettings.Secure.KEYBOARD_BRIGHTNESS),
+                false, mSettingsObserver, UserHandle.USER_ALL);
         resolver.registerContentObserver(LineageSettings.System.getUriFor(
                 LineageSettings.System.PROXIMITY_ON_WAKE),
                 false, mSettingsObserver, UserHandle.USER_ALL);
@@ -1130,6 +1139,9 @@ public final class PowerManagerService extends SystemService
         mButtonLightOnKeypressOnly = LineageSettings.System.getIntForUser(resolver,
                 LineageSettings.System.BUTTON_BACKLIGHT_ONLY_WHEN_PRESSED,
                 0, UserHandle.USER_CURRENT) == 1;
+        mKeyboardBrightness = LineageSettings.Secure.getIntForUser(resolver,
+                LineageSettings.Secure.KEYBOARD_BRIGHTNESS, mKeyboardBrightnessSettingDefault,
+                UserHandle.USER_CURRENT);
 
         mProximityWakeEnabled = LineageSettings.System.getInt(resolver,
                 LineageSettings.System.PROXIMITY_ON_WAKE,
@@ -2192,6 +2204,15 @@ public final class PowerManagerService extends SystemService
                                     nextTimeout = mLastButtonActivityTime + mButtonTimeout;
                                 }
                             }
+
+                            int keyboardBrightness;
+                            if (mButtonBrightnessOverrideFromWindowManager >= 0) {
+                                keyboardBrightness = mButtonBrightnessOverrideFromWindowManager;
+                            } else {
+                                keyboardBrightness = mKeyboardBrightness;
+                            }
+                            mKeyboardLight.setBrightness(mKeyboardVisible ?
+                                    keyboardBrightness : 0);
                         }
                     } else {
                         nextTimeout = mLastUserActivityTime + screenOffTimeout;
@@ -2200,6 +2221,8 @@ public final class PowerManagerService extends SystemService
                             if (mWakefulness == WAKEFULNESS_AWAKE) {
                                 mButtonsLight.setBrightness(0);
                                 mButtonOn = false;
+
+                                mKeyboardLight.setBrightness(0);
                             }
                         }
                     }
@@ -4967,6 +4990,22 @@ public final class PowerManagerService extends SystemService
             }
         }
 
+        @Override // Binder call
+        public void setKeyboardVisibility(boolean visible) {
+            synchronized (mLock) {
+                if (DEBUG_SPEW) {
+                    Slog.d(TAG, ""setKeyboardVisibility: "" + visible);
+                }
+                if (mKeyboardVisible != visible) {
+                    mKeyboardVisible = visible;
+                    synchronized (mLock) {
+                        mDirty |= DIRTY_USER_ACTIVITY;
+                        updatePowerStateLocked();
+                    }
+                }
+            }
+        }
+
         @Override // Binder call
         public void setDozeAfterScreenOff(boolean on) {
             mContext.enforceCallingOrSelfPermission(
",39,0,"PowerManagerService::updateUserActivitySummaryLocked, PowerManagerService::updateSettingsLocked, PowerManagerService::BinderService::setKeyboardVisibility, PowerManagerService::systemReady"
262,2fb8dda77a5942ebef1ecc70df7b5e506cbb5681,NotificationManagerService.java,ModificationType.MODIFY,"@@ -7239,7 +7239,15 @@ public class NotificationManagerService extends SystemService {
             return;
         }
 
-        LedValues ledValues = new LedValues(light.color, light.onMs, light.offMs);
+        int ledColor = light.color;
+        if (isLedForcedOn(ledNotification) && ledColor == 0) {
+            // User has requested color 0.  However, lineage-sdk interprets
+            // color 0 as ""supply a default"" therefore adjust alpha to make
+            // the color still black but non-zero.
+            ledColor = 0x01000000;
+        }
+
+        LedValues ledValues = new LedValues(ledColor, light.onMs, light.offMs);
         mLineageNotificationLights.calcLights(ledValues, ledNotification.sbn.getPackageName(),
                 ledNotification.sbn.getNotification(), mScreenOn || isInCall(),
                 ledNotification.getSuppressedVisualEffects());
",9,1,NotificationManagerService::updateLightsLocked
263,2fb8dda77a5942ebef1ecc70df7b5e506cbb5681,NotificationRecord.java,ModificationType.MODIFY,"@@ -269,11 +269,6 @@ public final class NotificationRecord {
                 if ((notification.defaults & Notification.DEFAULT_LIGHTS) != 0) {
                     light = new Light(defaultLightColor, defaultLightOn,
                             defaultLightOff);
-                } else if (light.color == 0) {
-                    // User has requested color 0.  However, lineage-sdk interprets
-                    // color 0 as ""supply a default"" therefore adjust alpha to make
-                    // the color still black but non-zero.
-                    light = new Light(0x01000000, light.onMs, light.offMs);
                 }
             } else {
                 light = null;
",0,5,NotificationRecord::calculateLights
264,44f7cdc0ef98074572a572b6aa78d1c0a23420f7,NotificationPanelView.java,ModificationType.MODIFY,"@@ -3082,7 +3082,7 @@ public class NotificationPanelView extends PanelView implements
      * @param x the x-coordinate the touch event
      */
     protected void updateVerticalPanelPosition(float x) {
-        if (mNotificationStackScroller.getWidth() * 1.75f > getWidth()) {
+        if (mKeyguardShowing || mNotificationStackScroller.getWidth() * 1.75f > getWidth()) {
             resetHorizontalPanelPosition();
             return;
         }
",1,1,NotificationPanelView::updateVerticalPanelPosition
265,e0577f3064c46e46ae18345a2aabbf426b5a05f2,PowerManagerService.java,ModificationType.MODIFY,"@@ -885,7 +885,7 @@ public final class PowerManagerService extends SystemService
 
             PowerManager pm = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
             mButtonBrightnessSettingDefault = pm.getDefaultButtonBrightness();
-            mButtonBrightnessSettingDefault = pm.getDefaultKeyboardBrightness();
+            mKeyboardBrightnessSettingDefault = pm.getDefaultKeyboardBrightness();
             mScreenBrightnessSettingMinimum = pm.getMinimumScreenBrightnessSetting();
             mScreenBrightnessSettingMaximum = pm.getMaximumScreenBrightnessSetting();
             mScreenBrightnessSettingDefault = pm.getDefaultScreenBrightnessSetting();
",1,1,PowerManagerService::systemReady
266,1e29fd7e53932c0d335a72f6326b1459cc3aa389,PhoneWindowManager.java,ModificationType.MODIFY,"@@ -552,6 +552,9 @@ public class PhoneWindowManager implements WindowManagerPolicy {
 
     boolean mVolumeAnswerCall;
 
+    // Click volume down + power for partial screenshot
+    boolean mClickPartialScreenshot;
+
     private boolean mPendingKeyguardOccluded;
     private boolean mKeyguardOccludedChanged;
     private boolean mNotifyUserActivity;
@@ -961,6 +964,9 @@ public class PhoneWindowManager implements WindowManagerPolicy {
             resolver.registerContentObserver(LineageSettings.System.getUriFor(
                     LineageSettings.System.VOLUME_ANSWER_CALL), false, this,
                     UserHandle.USER_ALL);
+            resolver.registerContentObserver(LineageSettings.System.getUriFor(
+                    LineageSettings.System.CLICK_PARTIAL_SCREENSHOT), false, this,
+                    UserHandle.USER_ALL);
 
             updateSettings();
         }
@@ -2451,6 +2457,9 @@ public class PhoneWindowManager implements WindowManagerPolicy {
             mCameraLaunch = LineageSettings.System.getIntForUser(resolver,
                     LineageSettings.System.CAMERA_LAUNCH, 0,
                     UserHandle.USER_CURRENT) == 1;
+            mClickPartialScreenshot = LineageSettings.System.getIntForUser(resolver,
+                    LineageSettings.System.CLICK_PARTIAL_SCREENSHOT, 0,
+                    UserHandle.USER_CURRENT) == 1;
 
             // Configure wake gesture.
             boolean wakeGestureEnabledSetting = Settings.Secure.getIntForUser(resolver,
@@ -4411,6 +4420,11 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                         mScreenshotChordVolumeDownKeyTriggered = false;
                         cancelPendingScreenshotChordAction();
                         cancelPendingAccessibilityShortcutAction();
+
+                        if (mClickPartialScreenshot && mScreenshotChordVolumeDownKeyConsumed) {
+                            mScreenshotRunnable.setScreenshotType(TAKE_SCREENSHOT_SELECTED_REGION);
+                            mHandler.post(mScreenshotRunnable);
+                        }
                     }
                 } else if (keyCode == KeyEvent.KEYCODE_VOLUME_UP) {
                     if (down) {
",14,0,"PhoneWindowManager::updateSettings, PhoneWindowManager::SettingsObserver::observe, PhoneWindowManager::interceptKeyBeforeQueueing"
267,1a0cc0d44edbc779b53876802ffdd19f996ddb26,NotificationMediaManager.java,ModificationType.MODIFY,"@@ -28,6 +28,7 @@ import static com.android.systemui.statusbar.phone.StatusBar.SHOW_LOCKSCREEN_MED
 import android.annotation.MainThread;
 import android.annotation.Nullable;
 import android.app.Notification;
+import android.app.WallpaperManager;
 import android.content.Context;
 import android.graphics.Bitmap;
 import android.graphics.drawable.BitmapDrawable;
@@ -137,6 +138,7 @@ public class NotificationMediaManager implements Dumpable, TunerService.Tunable
     private final ArrayList<MediaListener> mMediaListeners;
     private final MediaArtworkProcessor mMediaArtworkProcessor;
     private final Set<AsyncTask<?, ?, ?>> mProcessArtworkTasks = new ArraySet<>();
+    private final WallpaperManager mWallpaperManager;
 
     protected NotificationPresenter mPresenter;
     private MediaController mMediaController;
@@ -213,6 +215,8 @@ public class NotificationMediaManager implements Dumpable, TunerService.Tunable
         mMediaListeners = new ArrayList<>();
         mMediaSessionManager
                 = (MediaSessionManager) mContext.getSystemService(Context.MEDIA_SESSION_SERVICE);
+        mWallpaperManager
+                = (WallpaperManager) mContext.getSystemService(Context.WALLPAPER_SERVICE);
         // TODO: use MediaSessionManager.SessionListener to hook us up to future updates
         // in session state
         mShadeController = shadeController;
@@ -539,8 +543,9 @@ public class NotificationMediaManager implements Dumpable, TunerService.Tunable
         }
         boolean hasMediaArtwork = artworkDrawable != null;
         boolean allowWhenShade = false;
+        Bitmap lockWallpaper = null;
         if (ENABLE_LOCKSCREEN_WALLPAPER && artworkDrawable == null) {
-            Bitmap lockWallpaper =
+            lockWallpaper =
                     mLockscreenWallpaper != null ? mLockscreenWallpaper.getBitmap() : null;
             if (lockWallpaper != null) {
                 artworkDrawable = new LockscreenWallpaper.WallpaperDrawable(
@@ -562,11 +567,9 @@ public class NotificationMediaManager implements Dumpable, TunerService.Tunable
         }
 
         mStatusBar = SysUiServiceProvider.getComponent(mContext, StatusBar.class);
-        if (mStatusBar != null && hasMediaArtwork &&
-                mStatusBarStateController.getState() != StatusBarState.SHADE) {
+        if (mStatusBar != null && mStatusBarStateController.getState() != StatusBarState.SHADE) {
             VisualizerView visualizerView = mStatusBar.getVisualizer();
             if (!mKeyguardMonitor.isKeyguardFadingAway() && !mStatusBar.isScreenFullyOff()) {
-                // if there's album art, ensure visualizer is visible
                 visualizerView.setPlaying(getMediaControllerPlaybackState(mMediaController) ==
                         PlaybackState.STATE_PLAYING);
             }
@@ -574,6 +577,13 @@ public class NotificationMediaManager implements Dumpable, TunerService.Tunable
             if (artworkDrawable instanceof BitmapDrawable) {
                 // always use current backdrop to color eq
                 visualizerView.setBitmap(((BitmapDrawable) artworkDrawable).getBitmap());
+            } else if (lockWallpaper instanceof Bitmap) {
+                // use lockscreen wallpaper in case user set one
+                visualizerView.setBitmap(lockWallpaper.getConfig() == Bitmap.Config.HARDWARE ?
+                        lockWallpaper.copy(Bitmap.Config.ARGB_8888, false) : lockWallpaper);
+            } else {
+                // use regular wallpaper
+                visualizerView.setBitmap(mWallpaperManager.getBitmap(false));
             }
         }
 
",14,4,"NotificationMediaManager::finishUpdateMediaMetaData, NotificationMediaManager::NotificationMediaManager"
268,1a0cc0d44edbc779b53876802ffdd19f996ddb26,VisualizerView.java,ModificationType.MODIFY,"@@ -1,19 +1,19 @@
 /*
-* Copyright (C) 2015 The CyanogenMod Project
-*               2017-2019 The LineageOS Project
-*
-* Licensed under the Apache License, Version 2.0 (the ""License"");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an ""AS IS"" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
+ * Copyright (C) 2015 The CyanogenMod Project
+ *               2017-2019 The LineageOS Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 package com.android.systemui.statusbar;
 
@@ -302,7 +302,7 @@ public class VisualizerView extends View
         }
         mCurrentBitmap = bitmap;
         if (bitmap != null) {
-            Palette.generateAsync(bitmap, this);
+            Palette.from(bitmap).generate(this);
         } else {
             setColor(Color.TRANSPARENT);
         }
",16,16,VisualizerView::setBitmap
269,fed4017112180060e2563f7f21939fbdbbb4191d,NetworkPolicyManagerService.java,ModificationType.MODIFY,"@@ -4355,8 +4355,13 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {
             return;
         }
 
-        setUidFirewallRule(FIREWALL_CHAIN_ISOLATED, uid,
-                isIsolated ? FIREWALL_RULE_DENY : FIREWALL_RULE_DEFAULT);
+        final long token = Binder.clearCallingIdentity();
+        try {
+            setUidFirewallRule(FIREWALL_CHAIN_ISOLATED, uid,
+                    isIsolated ? FIREWALL_RULE_DENY : FIREWALL_RULE_DEFAULT);
+        } finally {
+            Binder.restoreCallingIdentity(token);
+        }
 
         int uidRules = oldUidRules;
         if (isIsolated) {
",7,2,NetworkPolicyManagerService::updateRulesForIsolatedUL
270,caf02804a772e48692d768813608789648c555a9,WifiManager.java,ModificationType.MODIFY,"@@ -775,19 +775,26 @@ public class WifiManager {
 
     /**
      * Broadcast intent action indicating that the configured networks changed.
-     * This can be as a result of adding/updating/deleting a network. If
-     * {@link #EXTRA_MULTIPLE_NETWORKS_CHANGED} is set to true the new configuration
-     * can be retreived with the {@link #EXTRA_WIFI_CONFIGURATION} extra. If multiple
-     * Wi-Fi configurations changed, {@link #EXTRA_WIFI_CONFIGURATION} will not be present.
+     * This can be as a result of adding/updating/deleting a network.
+     * <br />
+     * {@link #EXTRA_CHANGE_REASON} contains whether the configuration was added/changed/removed.
+     * {@link #EXTRA_WIFI_CONFIGURATION} is never set starting in Android 11.
+     * {@link #EXTRA_MULTIPLE_NETWORKS_CHANGED} is set for backwards compatibility reasons, but
+     * its value is always true, even if only a single network changed.
+     * <br />
+     * The {@link android.Manifest.permission#ACCESS_WIFI_STATE ACCESS_WIFI_STATE} permission is
+     * required to receive this broadcast.
+     *
      * @hide
      */
     @SystemApi
     public static final String CONFIGURED_NETWORKS_CHANGED_ACTION =
         ""android.net.wifi.CONFIGURED_NETWORKS_CHANGE"";
     /**
-     * The lookup key for a (@link android.net.wifi.WifiConfiguration} object representing
+     * The lookup key for a {@link android.net.wifi.WifiConfiguration} object representing
      * the changed Wi-Fi configuration when the {@link #CONFIGURED_NETWORKS_CHANGED_ACTION}
      * broadcast is sent.
+     * Note: this extra is never set starting in Android 11.
      * @hide
      */
     @SystemApi
@@ -795,14 +802,16 @@ public class WifiManager {
     /**
      * Multiple network configurations have changed.
      * @see #CONFIGURED_NETWORKS_CHANGED_ACTION
-     *
+     * Note: this extra is always true starting in Android 11.
      * @hide
      */
     @SystemApi
     public static final String EXTRA_MULTIPLE_NETWORKS_CHANGED = ""multipleChanges"";
     /**
      * The lookup key for an integer indicating the reason a Wi-Fi network configuration
-     * has changed. Only present if {@link #EXTRA_MULTIPLE_NETWORKS_CHANGED} is {@code false}
+     * has changed. One of {@link #CHANGE_REASON_ADDED}, {@link #CHANGE_REASON_REMOVED},
+     * {@link #CHANGE_REASON_CONFIG_CHANGE}.
+     *
      * @see #CONFIGURED_NETWORKS_CHANGED_ACTION
      * @hide
      */
",16,7,
271,350010d2238ae0c9eb2d8a141a5e85c4b975b071,InputMethodService.java,ModificationType.MODIFY,"@@ -92,6 +92,7 @@ import java.io.FileDescriptor;
 import java.io.PrintWriter;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
+import java.util.Collections;
 
 /**
  * InputMethodService provides a standard implementation of an InputMethod,
@@ -437,6 +438,7 @@ public class InputMethodService extends AbstractInputMethodService {
     private static final int VOLUME_CURSOR_ON_REVERSE = 2;
 
     final ViewTreeObserver.OnComputeInternalInsetsListener mInsetsComputer = info -> {
+        onComputeInsets(mTmpInsets);
         if (isExtractViewShown()) {
             // In true fullscreen mode, we just say the window isn't covering
             // any content so we don't impact whatever is behind.
@@ -445,12 +447,15 @@ public class InputMethodService extends AbstractInputMethodService {
             info.touchableRegion.setEmpty();
             info.setTouchableInsets(ViewTreeObserver.InternalInsetsInfo.TOUCHABLE_INSETS_FRAME);
         } else {
-            onComputeInsets(mTmpInsets);
             info.contentInsets.top = mTmpInsets.contentTopInsets;
             info.visibleInsets.top = mTmpInsets.visibleTopInsets;
             info.touchableRegion.set(mTmpInsets.touchableRegion);
             info.setTouchableInsets(mTmpInsets.touchableInsets);
         }
+
+        if (mInputFrame != null) {
+            setImeExclusionRect(mTmpInsets.visibleTopInsets);
+        }
     };
 
     final View.OnClickListener mActionClickListener = v -> {
@@ -675,6 +680,14 @@ public class InputMethodService extends AbstractInputMethodService {
         mPrivOps.setImeWindowStatus(visibilityFlags, backDisposition);
     }
 
+    /** Set region of the keyboard to be avoided from back gesture */
+    private void setImeExclusionRect(int visibleTopInsets) {
+        View inputFrameRootView = mInputFrame.getRootView();
+        Rect r = new Rect(0, visibleTopInsets, inputFrameRootView.getWidth(),
+                inputFrameRootView.getHeight());
+        inputFrameRootView.setSystemGestureExclusionRects(Collections.singletonList(r));
+    }
+
     /**
      * Concrete implementation of
      * {@link AbstractInputMethodService.AbstractInputMethodSessionImpl} that provides
",14,1,"InputMethodService::setImeExclusionRect, InputMethodService::if"
272,350010d2238ae0c9eb2d8a141a5e85c4b975b071,EdgeBackGestureHandler.java,ModificationType.MODIFY,"@@ -61,7 +61,6 @@ import com.android.systemui.R;
 import com.android.systemui.bubbles.BubbleController;
 import com.android.systemui.recents.OverviewProxyService;
 import com.android.systemui.shared.system.QuickStepContract;
-import com.android.systemui.shared.system.WindowManagerWrapper;
 import com.android.systemui.tuner.TunerService;
 
 import lineageos.providers.LineageSettings;
@@ -84,37 +83,6 @@ public class EdgeBackGestureHandler implements DisplayListener, TunerService.Tun
     private static final String KEY_GESTURE_BACK_EXCLUDE_TOP =
             ""lineagesecure:"" + LineageSettings.Secure.GESTURE_BACK_EXCLUDE_TOP;
 
-    private final IPinnedStackListener.Stub mImeChangedListener = new IPinnedStackListener.Stub() {
-        @Override
-        public void onListenerRegistered(IPinnedStackController controller) {
-        }
-
-        @Override
-        public void onImeVisibilityChanged(boolean imeVisible, int imeHeight) {
-            // No need to thread jump, assignments are atomic
-            mImeHeight = imeVisible ? imeHeight : 0;
-            // TODO: Probably cancel any existing gesture
-        }
-
-        @Override
-        public void onShelfVisibilityChanged(boolean shelfVisible, int shelfHeight) {
-        }
-
-        @Override
-        public void onMinimizedStateChanged(boolean isMinimized) {
-        }
-
-        @Override
-        public void onMovementBoundsChanged(Rect insetBounds, Rect normalBounds,
-                Rect animatingBounds, boolean fromImeAdjustment, boolean fromShelfAdjustment,
-                int displayRotation) {
-        }
-
-        @Override
-        public void onActionsChanged(ParceledListSlice actions) {
-        }
-    };
-
     private ISystemGestureExclusionListener mGestureExclusionListener =
             new ISystemGestureExclusionListener.Stub() {
                 @Override
@@ -164,8 +132,6 @@ public class EdgeBackGestureHandler implements DisplayListener, TunerService.Tun
     private boolean mInRejectedExclusion = false;
     private boolean mIsOnLeftEdge;
 
-    private int mImeHeight = 0;
-
     private boolean mIsAttached;
     private boolean mIsGesturalModeEnabled;
     private boolean mIsEnabled;
@@ -270,7 +236,6 @@ public class EdgeBackGestureHandler implements DisplayListener, TunerService.Tun
         }
 
         if (!mIsEnabled) {
-            WindowManagerWrapper.getInstance().removePinnedStackListener(mImeChangedListener);
             mContext.getSystemService(DisplayManager.class).unregisterDisplayListener(this);
 
             try {
@@ -287,7 +252,6 @@ public class EdgeBackGestureHandler implements DisplayListener, TunerService.Tun
                     mContext.getMainThreadHandler());
 
             try {
-                WindowManagerWrapper.getInstance().addPinnedStackListener(mImeChangedListener);
                 WindowManagerGlobal.getWindowManagerService()
                         .registerSystemGestureExclusionListener(
                                 mGestureExclusionListener, mDisplayId);
@@ -344,14 +308,8 @@ public class EdgeBackGestureHandler implements DisplayListener, TunerService.Tun
     }
 
     private boolean isWithinTouchRegion(int x, int y) {
-        final int baseY = mDisplaySize.y - Math.max(mImeHeight, mNavBarHeight);
-        // Disallow if over the IME
-        if (y > baseY) {
-            return false;
-        }
-
         // Disallow if over user exclusion area
-        if (mUserExclude > 0 && y < baseY - mUserExclude) {
+        if (mUserExclude > 0 && y < mDisplaySize.y - mNavBarHeight - mUserExclude) {
             return false;
         }
 
@@ -582,7 +540,6 @@ public class EdgeBackGestureHandler implements DisplayListener, TunerService.Tun
         pw.println(""  mInRejectedExclusion"" + mInRejectedExclusion);
         pw.println(""  mExcludeRegion="" + mExcludeRegion);
         pw.println(""  mUnrestrictedExcludeRegion="" + mUnrestrictedExcludeRegion);
-        pw.println(""  mImeHeight="" + mImeHeight);
         pw.println(""  mIsAttached="" + mIsAttached);
         pw.println(""  mEdgeWidth="" + mEdgeWidth);
     }
",1,44,"EdgeBackGestureHandler::dump, EdgeBackGestureHandler::isWithinTouchRegion, EdgeBackGestureHandler::updateIsEnabled, EdgeBackGestureHandler::Stub"
273,20c41861cf1259b4054bd993abf7ff3d73f7f45e,EdgeBackGestureHandler.java,ModificationType.MODIFY,"@@ -111,6 +111,8 @@ public class EdgeBackGestureHandler implements DisplayListener, TunerService.Tun
 
     // The edge width where touch down is allowed
     private int mEdgeWidth;
+    // The bottom gesture area height
+    private int mBottomGestureHeight;
     // The slop to distinguish between horizontal and vertical motion
     private final float mTouchSlop;
     // Duration after which we consider the event as longpress.
@@ -179,6 +181,8 @@ public class EdgeBackGestureHandler implements DisplayListener, TunerService.Tun
     public void updateCurrentUserResources(Resources res) {
         mEdgeWidth = res.getDimensionPixelSize(
                 com.android.internal.R.dimen.config_backGestureInset);
+        mBottomGestureHeight = res.getDimensionPixelSize(
+                com.android.internal.R.dimen.navigation_bar_gesture_height);
     }
 
     /**
@@ -318,6 +322,11 @@ public class EdgeBackGestureHandler implements DisplayListener, TunerService.Tun
             return false;
         }
 
+        // Disallow if we are in the bottom gesture area
+        if (y >= (mDisplaySize.y - mBottomGestureHeight)) {
+            return false;
+        }
+
         // Always allow if the user is in a transient sticky immersive state
         if (mIsInTransientImmersiveStickyState) {
             return true;
",9,0,"EdgeBackGestureHandler::updateCurrentUserResources, EdgeBackGestureHandler::isWithinTouchRegion"
274,6343aa2a280e00c077efeeab7d542c89cb501243,EdgeBackGestureHandler.java,ModificationType.MODIFY,"@@ -486,9 +486,7 @@ public class EdgeBackGestureHandler implements DisplayListener, TunerService.Tun
     }
 
     private void updateDisplaySize() {
-        mContext.getSystemService(DisplayManager.class)
-                .getDisplay(mDisplayId)
-                .getRealSize(mDisplaySize);
+        mContext.getDisplay().getRealSize(mDisplaySize);
         updateLongSwipeWidth();
         loadUserExclusion();
     }
",1,3,EdgeBackGestureHandler::updateDisplaySize
275,4be11d7d051b8eba57e4d2f7130844d77d0fef10,NfcTile.java,ModificationType.MODIFY,"@@ -56,6 +56,7 @@ public class NfcTile extends QSTileImpl<BooleanState> {
 
     @Override
     public void handleSetListening(boolean listening) {
+        if (mListening == listening) return;
         mListening = listening;
         if (mListening) {
             mContext.registerReceiver(mNfcReceiver,
",1,0,NfcTile::handleSetListening
276,c7c48b01e94c28663ce2e38a321da9fc19e601ee,ApplicationPackageManager.java,ModificationType.MODIFY,"@@ -101,6 +101,8 @@ import com.android.internal.os.SomeArgs;
 import com.android.internal.util.Preconditions;
 import com.android.internal.util.UserIcons;
 
+import com.nvidia.NvAppProfileService;
+
 import dalvik.system.VMRuntime;
 
 import libcore.util.EmptyArray;
@@ -130,6 +132,7 @@ public class ApplicationPackageManager extends PackageManager {
     private UserManager mUserManager;
     @GuardedBy(""mLock"")
     private PackageInstaller mInstaller;
+    private NvAppProfileService mAppProfileService;
     @GuardedBy(""mLock"")
     private ArtManager mArtManager;
 
@@ -389,6 +392,15 @@ public class ApplicationPackageManager extends PackageManager {
         }
     }
 
+    /** @hide */
+    @Override
+    public NvAppProfileService getAppProfileService() {
+        if (mAppProfileService == null) {
+            mAppProfileService = new NvAppProfileService(mContext);
+        }
+        return mAppProfileService;
+    }
+
     @Override
     public ApplicationInfo getApplicationInfo(String packageName, int flags)
             throws NameNotFoundException {
",12,0,ApplicationPackageManager::getAppProfileService
277,c7c48b01e94c28663ce2e38a321da9fc19e601ee,PackageManager.java,ModificationType.MODIFY,"@@ -64,6 +64,8 @@ import android.util.Log;
 
 import com.android.internal.util.ArrayUtils;
 
+import com.nvidia.NvAppProfileService;
+
 import dalvik.system.VMRuntime;
 
 import java.io.File;
@@ -3643,6 +3645,9 @@ public abstract class PackageManager {
     public abstract List<PermissionGroupInfo> getAllPermissionGroups(
             @PermissionGroupInfoFlags int flags);
 
+    /** @hide */
+    public abstract NvAppProfileService getAppProfileService();
+
     /**
      * Retrieve all of the information we know about a particular
      * package/application.
",5,0,
278,c7c48b01e94c28663ce2e38a321da9fc19e601ee,PackageParser.java,ModificationType.MODIFY,"@@ -107,6 +107,8 @@ import com.android.internal.util.ArrayUtils;
 import com.android.internal.util.XmlUtils;
 import com.android.server.SystemConfig;
 
+import com.nvidia.NvAppProfileService;
+
 import libcore.io.IoUtils;
 import libcore.util.EmptyArray;
 
@@ -575,6 +577,7 @@ public class PackageParser {
      * a package.
      */
     public interface Callback {
+        NvAppProfileService getAppProfileService();
         boolean hasFeature(String feature);
         String[] getOverlayPaths(String targetPackageName, String targetPath);
         String[] getOverlayApks(String targetPackageName);
@@ -591,6 +594,10 @@ public class PackageParser {
             mPm = pm;
         }
 
+        @Override public NvAppProfileService getAppProfileService() {
+            return mPm.getAppProfileService();
+        }
+
         @Override public boolean hasFeature(String feature) {
             return mPm.hasSystemFeature(feature);
         }
",7,0,PackageParser::CallbackImpl::getAppProfileService
279,c7c48b01e94c28663ce2e38a321da9fc19e601ee,NvAppProfileService.java,ModificationType.ADD,"@@ -0,0 +1,246 @@
+/*
+ * Copyright (c) 2012 - 2014 NVIDIA Corporation.  All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * Class structure based upon Camera in Camera.java:
+ * Copyright (C) 2009 The Android Open Source Project
+ */
+
+package com.nvidia;
+
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.PackageManager;
+import android.content.res.Resources;
+import android.graphics.drawable.Drawable;
+import android.os.SystemProperties;
+import android.os.UserHandle;
+import android.util.Log;
+
+import com.nvidia.profilemanager.NvAppProfileSettingId;
+
+/**
+ * @hide
+ */
+public class NvAppProfileService {
+    private static final String TAG = ""NvAppProfileService"";
+    private static final String APP_START_ACTION =
+            ""com.nvidia.NvAppProfileService.action.APP_START"";
+    private static final String APP_START_TARGET_PACKAGE = ""com.nvidia.peripheralservice"";
+    private static final String FEATURE_POWER_BUDGET_CONTROL =
+            ""nvidia.feature.power_budget_control"";
+    private static final String FEATURE_FAN_ON_DEVICE = ""nvidia.feature.fan_on_device"";
+
+    private final NvAppProfiles mAppProfile;
+    private final NvWhitelistService mWhitelistService;
+    private final Context mContext;
+
+    private boolean mInitialisedAppProfiles = false;
+    private boolean mFanCapEnabled = false;
+    private boolean mPbcEnabled = false;
+
+    public NvAppProfileService(Context context) {
+        Context appContext = context.getApplicationContext();
+        if (appContext == null) {
+            mContext = context;
+        } else {
+            mContext = appContext;
+        }
+
+        mAppProfile = new NvAppProfiles(mContext);
+        mWhitelistService = new NvWhitelistService(mContext);
+    }
+
+    private static String getPackageName(String appName) {
+        int index = appName.indexOf('/');
+        if (index < 0) {
+            Log.e(TAG, ""appName does not contain '/'. "" +
+                    ""The packageName cannot be extracted from appName!"");
+            return null;
+        }
+        return appName.substring(0, index);
+    }
+
+    /*
+     * These are functions that depend on NvAppProfiles and may or may not
+     * be supported for certain platforms. In the latter case, these methods
+     * should return -1.
+     */
+    public boolean getAppProfileFRCEnable(String packageName) {
+        return packageName != null && mAppProfile.getApplicationProfile(packageName,
+                NvAppProfileSettingId.VIDEO_FRC_ENABLE) == 1;
+    }
+
+    public boolean getAppProfileCreateSecureDecoder(String packageName) {
+        return packageName != null && mAppProfile.getApplicationProfile(packageName,
+                NvAppProfileSettingId.VIDEO_SECURE_DECODE) == 1;
+    }
+
+    public boolean getAppProfileTSFilterEnable(String packageName) {
+        return packageName != null && mAppProfile.getApplicationProfile(packageName,
+                NvAppProfileSettingId.VIDEO_TS_FILTERING) == 1;
+    }
+
+    public boolean getAppProfileMediaEnableMsdHal(String packageName) {
+        return packageName != null && this.mAppProfile.getApplicationProfile(packageName,
+                NvAppProfileSettingId.MEDIA_ENABLE_MSD_HAL) == 1;
+    }
+
+    public boolean getAppProfileNvidiaCertification(String packageName) {
+        return packageName != null && mAppProfile.getApplicationProfile(packageName,
+                NvAppProfileSettingId.NVIDIA_VIDEO_CERTIFICATION_ENABLED) == 1;
+    }
+
+    public String customizeAppBanner(String packageName) {
+        if (packageName == null) return null;
+
+        final String bannerName = mAppProfile.getApplicationProfileString(packageName,
+                NvAppProfileSettingId.WHITELIST_CUSTOMIZE_BANNER);
+        if (bannerName != null) return bannerName;
+
+        return mWhitelistService.getBannerName(packageName);
+    }
+
+    public Drawable getBannerDrawable(String packageName) {
+        final String bannerName = customizeAppBanner(packageName);
+        if (bannerName == null || bannerName.length() == 0) {
+            return null;
+        }
+
+        final Resources systemResources = mContext.getResources().getSystem();
+        final int drawableResourceId = systemResources.getIdentifier(bannerName,
+                ""drawable"", ""android"");
+        if (drawableResourceId == 0) return null;
+
+        return systemResources.getDrawable(drawableResourceId);
+    }
+
+    public NvWhitelistService getWhitelistService() {
+        return mWhitelistService;
+    }
+
+    public boolean getAppProfileDisableApp(String packageName) {
+        return packageName != null && mAppProfile.getApplicationProfile(packageName,
+                NvAppProfileSettingId.DISABLE_APP) == 1;
+    }
+
+    private int getAppProfileCpuScalingMinFreq(String packageName) {
+        return mAppProfile.getApplicationProfile(packageName,
+                NvAppProfileSettingId.SCALING_MIN_FREQ);
+    }
+
+    private int getAppProfileCpuCoreBias(String packageName) {
+        return mAppProfile.getApplicationProfile(packageName, NvAppProfileSettingId.CORE_BIAS);
+    }
+
+    private int getAppProfileGpuScaling(String packageName) {
+        return mAppProfile.getApplicationProfile(packageName, NvAppProfileSettingId.GPU_SCALING);
+    }
+
+    private int getAppProfileCpuMaxNormalFreq(String packageName) {
+        return mAppProfile.getApplicationProfile(packageName, NvAppProfileSettingId.CPU_FREQ_BIAS);
+    }
+
+    private int getAppProfileCpuMaxNormalFreqPercent(String packageName) {
+        return mAppProfile.getApplicationProfile(packageName,
+                NvAppProfileSettingId.MAX_CPU_FREQ_PCT);
+    }
+
+    private int getAppProfileCpuMinCore(String packageName) {
+        return mAppProfile.getApplicationProfile(packageName, NvAppProfileSettingId.MIN_CPU_CORES);
+    }
+
+    private int getAppProfileCpuMaxCore(String packageName) {
+        return mAppProfile.getApplicationProfile(packageName, NvAppProfileSettingId.MAX_CPU_CORES);
+    }
+
+    private int getAppProfileGpuCbusCapLevel(String packageName) {
+        return mAppProfile.getApplicationProfile(packageName, NvAppProfileSettingId.GPU_CORE_CAP);
+    }
+
+    private int getAppProfileEdpMode(String packageName) {
+        return mAppProfile.getApplicationProfile(packageName, NvAppProfileSettingId.EDP_MODE);
+    }
+
+    private int getAppProfilePbcPwr(String packageName) {
+        if (!mPbcEnabled) return -1;
+
+        return mAppProfile.getApplicationProfile(packageName, NvAppProfileSettingId.PBC_PWR_LIMIT);
+    }
+
+    private int getAppProfileFanCap(String packageName) {
+        if (!mFanCapEnabled) return -1;
+
+        return mAppProfile.getApplicationProfile(packageName, NvAppProfileSettingId.FAN_PWM_CAP);
+    }
+
+    private int getAppProfileVoltTempMode(String packageName) {
+        return mAppProfile.getApplicationProfile(packageName, NvAppProfileSettingId.VOLT_TEMP_MODE);
+    }
+
+    private int getAppProfileAggresivePrismEnable(String packageName) {
+        return mAppProfile.getApplicationProfile(packageName,
+                NvAppProfileSettingId.AGGRESSIVE_PRISM_ENABLE);
+    }
+
+    private int getAppProfileDevicePowerMode(String packageName) {
+        return mAppProfile.getApplicationProfile(packageName,
+                NvAppProfileSettingId.SYSTEM_POWER_MODE);
+    }
+
+    public String getAppProfileRegionEnableList(String packageName) {
+        return mAppProfile.getApplicationProfileString(packageName,
+                NvAppProfileSettingId.SET_REGION_LIST);
+    }
+
+    public int getAppProfileNvidiaBBCApps(String packageName) {
+        return mAppProfile.getApplicationProfile(packageName, NvAppProfileSettingId.BBC_APPS);
+    }
+
+    private int retrievePowerMode() {
+        final String powerMode = SystemProperties.get(NvConstants.NvPowerModeProperty);
+        if (powerMode != null) {
+            try {
+                return Integer.parseInt(powerMode);
+            } catch (NumberFormatException ex) {
+                // Fallthrough to error case
+            }
+        }
+
+        return -1;
+    }
+
+    /**
+     * Interface for the caller
+     */
+    public void setAppProfile(String packageName) {
+        // Greedy initialization of App Profiles
+        if (!mInitialisedAppProfiles) {
+            PackageManager pm = mContext.getPackageManager();
+            mPbcEnabled = pm.hasSystemFeature(FEATURE_POWER_BUDGET_CONTROL);
+            mFanCapEnabled = pm.hasSystemFeature(FEATURE_FAN_ON_DEVICE);
+
+            Log.w(TAG, ""Enabled"");
+            mInitialisedAppProfiles = true;
+        }
+
+        mAppProfile.powerHint(packageName);
+
+        Intent intent = new Intent(APP_START_ACTION);
+        intent.setPackage(APP_START_TARGET_PACKAGE);
+        intent.putExtra(""AppStartId"", packageName);
+        mContext.sendBroadcastAsUser(intent, UserHandle.CURRENT,
+                ""nvidia.permission.READ_APP_START_INFO"");
+    }
+}
",246,0,"NvAppProfileService::getAppProfileAggresivePrismEnable, NvAppProfileService::getAppProfileCreateSecureDecoder, NvAppProfileService::getBannerDrawable, NvAppProfileService::getAppProfileRegionEnableList, NvAppProfileService::getAppProfileNvidiaBBCApps, NvAppProfileService::getWhitelistService, NvAppProfileService::getAppProfileCpuScalingMinFreq, NvAppProfileService::getAppProfileCpuMaxNormalFreqPercent, NvAppProfileService::getAppProfileCpuCoreBias, NvAppProfileService::getAppProfilePbcPwr, NvAppProfileService::getAppProfileFRCEnable, NvAppProfileService::getAppProfileGpuScaling, NvAppProfileService::getAppProfileTSFilterEnable, NvAppProfileService::getAppProfileCpuMinCore, NvAppProfileService::getAppProfileNvidiaCertification, NvAppProfileService::getAppProfileFanCap, NvAppProfileService::getAppProfileEdpMode, NvAppProfileService::retrievePowerMode, NvAppProfileService::getAppProfileVoltTempMode, NvAppProfileService::getAppProfileDisableApp, NvAppProfileService::getAppProfileGpuCbusCapLevel, NvAppProfileService::getAppProfileMediaEnableMsdHal, NvAppProfileService::getAppProfileCpuMaxNormalFreq, NvAppProfileService::customizeAppBanner, NvAppProfileService::getAppProfileCpuMaxCore, NvAppProfileService::NvAppProfileService, NvAppProfileService::getAppProfileDevicePowerMode, NvAppProfileService::setAppProfile, NvAppProfileService::getPackageName"
280,c7c48b01e94c28663ce2e38a321da9fc19e601ee,NvAppProfiles.java,ModificationType.ADD,"@@ -0,0 +1,96 @@
+package com.nvidia;
+
+import android.content.Context;
+import android.content.Intent;
+import android.os.IBinder;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.util.Log;
+
+import com.nvidia.NvCPLSvc.INvCPLRemoteService;
+
+public class NvAppProfiles {
+    /**
+     * Unique name used for NvCPLSvc to whitelist this class
+     */
+    static final String NV_APP_PROFILES_NAME = ""Frameworks_NvAppProfiles"";
+    static final boolean DEBUG = false;
+    private static final String TAG = ""NvAppProfiles"";
+    private final Context mContext;
+    private INvCPLRemoteService mNvCPLSvc = null;
+    private IBinder mNvCPLSvcBinder = null;
+
+    /**
+     * Callback class given by the NvCPLService
+     */
+
+    public NvAppProfiles(Context context) {
+        mContext = context;
+    }
+
+    public int getApplicationProfile(String packageName, int settingId) {
+        getNvCPLService();
+        if (mNvCPLSvc != null) {
+            try {
+                return mNvCPLSvc.getAppProfileSettingInt(packageName, settingId);
+            } catch (RemoteException ex) {
+                Log.w(TAG, ""Failed to retrieve profile setting. Error="" + ex.getMessage());
+            }
+        }
+
+        return -1;
+    }
+
+    public String getApplicationProfileString(String packageName, int settingId) {
+        getNvCPLService();
+        if (mNvCPLSvc != null) {
+            try {
+                return mNvCPLSvc.getAppProfileSettingString(packageName, settingId);
+            } catch (RemoteException ex) {
+                Log.w(TAG, ""Failed to retrieve profile setting. Error="" + ex.getMessage());
+            }
+        }
+
+        return null;
+    }
+
+    public void setPowerMode(int index) {
+        if (DEBUG) Log.w(TAG, ""Setting power mode: "" + String.valueOf(index));
+
+        Intent intent = new Intent();
+        intent.setClassName(NvConstants.NvCPLSvc, NvConstants.NvCPLService);
+        intent.putExtra(NvConstants.NvOrigin, 1);
+        intent.putExtra(NvConstants.NvPowerMode , String.valueOf(index));
+
+        handleIntent(intent);
+    }
+
+    public void powerHint(String packageName) {
+        getNvCPLService();
+        if (mNvCPLSvc != null) {
+            try {
+                mNvCPLSvc.powerHint(packageName);
+            } catch (RemoteException ex) {
+                Log.w(TAG, ""Failed to send power hint. Error="" + ex.getMessage());
+            }
+        }
+    }
+
+    public void handleIntent(Intent intent) {
+        getNvCPLService();
+        if (mNvCPLSvc != null) {
+            try {
+                mNvCPLSvc.handleIntent(intent);
+            } catch (RemoteException ex) {
+                Log.w(TAG, ""Failed to handle intent. Error="" + ex.getMessage());
+            }
+        }
+    }
+
+    private void getNvCPLService() {
+        if (mNvCPLSvc == null || mNvCPLSvcBinder == null || !mNvCPLSvcBinder.isBinderAlive()) {
+            mNvCPLSvcBinder = ServiceManager.getService(""nvcpl"");
+            mNvCPLSvc = INvCPLRemoteService.Stub.asInterface(mNvCPLSvcBinder);
+        }
+    }
+}
",96,0,"NvAppProfiles::setPowerMode, NvAppProfiles::getApplicationProfile, NvAppProfiles::powerHint, NvAppProfiles::getNvCPLService, NvAppProfiles::handleIntent, NvAppProfiles::NvAppProfiles, NvAppProfiles::getApplicationProfileString"
281,c7c48b01e94c28663ce2e38a321da9fc19e601ee,NvConstants.java,ModificationType.ADD,"@@ -0,0 +1,18 @@
+package com.nvidia;
+
+public class NvConstants {
+    public static final String NvAppClose = ""com.nvidia.app.close"";
+    public static final String NvBatteryMonitor = ""com.nvidia.NvCPLSvc.BatteryMonitor"";
+    public static final String NvCPLService = ""com.nvidia.NvCPLSvc.NvCPLService"";
+    public static final String NvCPLSvc = ""com.nvidia.NvCPLSvc"";
+    public static final String NvMaxGpuMode = ""com.nvidia.NvCPLSvc.MaxGpuMode"";
+    public static final String NvOrigin = ""com.nvidia.NvCPLSvc.Origin"";
+    public static final String NvPowerMode = ""com.nvidia.NvCPLSvc.NV_POWER_MODE"";
+    public static final String NvPowerModeProperty = ""persist.vendor.sys.NV_POWER_MODE"";
+    public static final String NvStateId = ""com.nvidia.NvCPLSvc.StateID"";
+    public static final String NvTCPDivisor = ""com.nvidia.NvCPLSvc.NV_TCPDIVISOR"";
+    public static final String NvThermalStats = ""com.nvidia.peripheralservice.NvThermalStats"";
+    public static final int NV_POWER_MODE_MAX_PERF = 0;
+    public static final int NV_POWER_MODE_OPTIMIZED = 1;
+    public static final int NV_POWER_MODE_BATTERY_SAVER = 2;
+}
",18,0,
282,c7c48b01e94c28663ce2e38a321da9fc19e601ee,NvWhitelistService.java,ModificationType.ADD,"@@ -0,0 +1,112 @@
+package com.nvidia;
+
+import android.content.Context;
+import android.content.res.XmlResourceParser;
+import android.util.Log;
+
+import com.android.internal.R;
+
+import java.util.ArrayList;
+import java.io.IOException;
+
+import org.json.JSONObject;
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.xmlpull.v1.XmlPullParserException;
+
+public class NvWhitelistService {
+    private static final String TAG = ""NvWhitelistService"";
+    private JSONArray mWhiteListArray;
+    private Context mContext;
+
+    public NvWhitelistService(Context context) {
+        Context appContext = context.getApplicationContext();
+        mContext = appContext != null ? appContext : context;
+        mWhiteListArray =
+                parseXml(mContext.getResources().getXml(R.xml.tv_launcher_app_white_list));
+    }
+
+    public boolean isWhiteApp(String pkgName) {
+        if (mWhiteListArray == null) return false;
+
+        for (int i = 0; i < mWhiteListArray.length(); i++) {
+            try {
+                if (pkgName.equals(mWhiteListArray.getJSONObject(i).getString(""packageName""))) {
+                    return true;
+                }
+            } catch (JSONException ex) {
+                Log.w(TAG, ex.getMessage());
+            }
+        }
+
+        return false;
+    }
+
+    public boolean isTvGame(String pkgName) {
+        if (mWhiteListArray == null) return false;
+
+        for (int i = 0; i < mWhiteListArray.length(); i++) {
+            try {
+                if (mWhiteListArray.getJSONObject(i).getString(""packageName"").equals(pkgName) &&
+                        mWhiteListArray.getJSONObject(i).getString(""isGame"").equals(""true"")) {
+                    return true;
+                }
+            } catch (JSONException ex) {
+                Log.w(TAG, ex.getMessage());
+            }
+        }
+
+        return false;
+    }
+
+    public String getBannerName(String pkgName) {
+        for (int i = 0; i < mWhiteListArray.length(); i++) {
+            try {
+                if (mWhiteListArray.getJSONObject(i).getString(""packageName"").equals(pkgName)) {
+                    return mWhiteListArray.getJSONObject(i).getString(""bannerName"");
+                }
+            } catch (JSONException ex) {
+                Log.w(TAG, ex.getMessage());
+            }
+        }
+
+        return """";
+    }
+
+    private JSONArray parseXml(XmlResourceParser xmlParser) {
+        if (xmlParser == null) return null;
+
+        JSONObject jsonObj = null;
+        ArrayList<JSONObject> widgetConfigs = new ArrayList<>();
+        try {
+            int type = xmlParser.getEventType();
+            while (type != XmlResourceParser.END_DOCUMENT) {
+                switch (type) {
+                    case XmlResourceParser.START_TAG:
+                        if (xmlParser.getName().equals(""app"")) {
+                            jsonObj = new JSONObject();
+                            for (int i = 0; i < xmlParser.getAttributeCount(); i++) {
+                                jsonObj.put(xmlParser.getAttributeName(i),
+                                        xmlParser.getAttributeValue(i));
+                            }
+                            break;
+                        }
+                        break;
+                    case XmlResourceParser.END_TAG:
+                        if (xmlParser.getName().equals(""app"") && jsonObj != null) {
+                            widgetConfigs.add(jsonObj);
+                            break;
+                        }
+                        break;
+                    default:
+                        break;
+                }
+                type = xmlParser.next();
+            }
+        } catch (IOException | JSONException | XmlPullParserException e) {
+            e.printStackTrace();
+        }
+
+        return new JSONArray(widgetConfigs);
+    }
+}
",112,0,"NvWhitelistService::isTvGame, NvWhitelistService::NvWhitelistService, NvWhitelistService::getBannerName, NvWhitelistService::isWhiteApp, NvWhitelistService::parseXml"
283,c7c48b01e94c28663ce2e38a321da9fc19e601ee,NvAppProfileSettingId.java,ModificationType.ADD,"@@ -0,0 +1,93 @@
+package com.nvidia.profilemanager;
+
+public class NvAppProfileSettingId {
+    public static int RESOVERRIDE_SCALE_FACTOR = 5;
+    public static int STEREO_PERF_WIDTH = 7;
+    public static int RESOVERRIDE_PERF_WIDTH = 8;
+    public static int FORCE_HW_UI = 9;
+    public static int CORE_BIAS = 17;
+    public static int CPU_FREQ_BIAS = 18;
+    public static int GPU_CORE_CAP = 19;
+    public static int SCALING_MIN_FREQ = 20;
+    public static int GPU_SCALING = 21;
+    public static int PBC_PWR_LIMIT = 22;
+    public static int FAN_PWM_CAP = 23;
+    public static int VOLT_TEMP_MODE = 24;
+    public static int FRAME_RATE_LIMIT = 26;
+    public static int DISABLE_APM = 29;
+    public static int EDP_MODE = 30;
+    public static int GPU_MODE = 35;
+    public static int STYLUS_FINGER_ONLY_MODE = 40;
+    public static int STEREO_PERF_SCALE_FACTOR = 43;
+    public static int DISABLE_BUFFER_AGE = 47;
+    public static int SYSTEM_POWER_MODE = 48;
+    public static int CUSTOM_PROFILE_BLACKLIST = 51;
+    public static int BLOCK_NETWORK_ACCESS = 53;
+    public static int MAX_CPU_CORES = 58;
+    public static int AGGRESSIVE_PRISM_ENABLE = 59;
+    public static int BLOCK_ON_NETWORK = 60;
+    public static int MAX_CPU_FREQ_PCT = 61;
+    public static int DEPTH_COMPRESSION = 62;
+    public static int OGL_THREADCONTROL = 63;
+    public static int OGL_SKIP_ENABLED_UNSET_ARRAY = 64;
+    public static int CMU_GTM_MAPPING_LUT = 65;
+    public static int OGL_CLEAR_METERING = 66;
+    public static int KILL_PROCESS_BELOW_ADJ = 67;
+    public static int EGL_REPORT_ES1_CONFIG_ONLY = 69;
+    public static int VIDEO_IQ = 70;
+    public static int CAMERA_MEMORY = 71;
+    public static int PERF_FP = 72;
+    public static int MIN_CPU_CORES = 73;
+    public static int PROMOTE_SURFACE_TO_32BIT = 74;
+    public static int AFFINITY_DAEMON_ENABLE = 75;
+    public static int CUSTOM_PROFILE_SYSTEM_WHITELIST = 76;
+    public static int FORCEONCPU = 77;
+    public static int KEY_DEVICE_ID_HASH = 78;
+    public static int GSYNC_WHITELIST = 79;
+    public static int GSYNC_BLACKLIST = 80;
+    public static int TOUCH_MODE = 81;
+    public static int DISPLAY_UPSCALE_HEIGHT = 82;
+    public static int DISPLAY_UPSCALE_WIDTH = 83;
+    public static int OGL_APP_RUNTIME_VERTEX_ATTRIB_SOURCING = 84;
+    public static int MAXWELL_TILEDCACHE = 85;
+    public static int OGL_HIDE_EXTENSIONS_STRING = 86;
+    public static int NVIDIA_WEBVIEW = 87;
+    public static int OGL_HIDE_EXTENSIONS = 88;
+    public static int HDD_DIALOG_FREQ = 89;
+    public static int HDD_DIALOG_TEXT = 90;
+    public static int HDD_DIALOG_THRESHOLD = 91;
+    public static int HDD_DIALOG_ENABLE = 92;
+    public static int TCP_DIVISOR = 93;
+    public static int BBC_APPS = 94;
+    public static int HDD_STATS_ENABLE = 95;
+    public static int HDD_DIALOG_REMIND_ME_LATER_FREQ = 96;
+    public static int HDD_STATS_FREQ = 97;
+    public static int HDD_DIALOG_STR_THRESHOLD = 98;
+    public static int OGL_VERSION_OVERRIDE = 99;
+    public static int OGL_ES_VERSION_OVERRIDE = 100;
+    public static int MULTI_CHANNEL_SWITCH_MODE = 101;
+    public static int VIDEO_FRC_ENABLE = 102;
+    public static int VIDEO_SECURE_DECODE = 103;
+    public static int VIDEO_TS_FILTERING = 104;
+    public static int NVIDIA_VIDEO_CERTIFICATION_ENABLED = 105;
+    public static int OGL_SHADER_PORTABILITY_WARNINGS = 106;
+    public static int OGL_THREADCONTROL2 = 107;
+    public static int OGL_EXTRA_CGC_OPTION = 108;
+    public static int DISABLE_APP = 109;
+    public static int SET_REGION_LIST = 110;
+    public static int PINNING_ENABLE = 111;
+    public static int PINNING_ORDER = 112;
+    public static int GPU_MODESET_ENABLE = 113;
+    public static int AVS_DELAY_ENABLE = 114;
+    public static int BLACKLIST_USB_30 = 115;
+    public static int DRM_DIALOG_ENABLE = 116;
+    public static int FILTER_EGLCONFIGS = 117;
+    public static int SHIELD_LOGGING = 118;
+    public static int APP_AUDIO_SWITCH_TO_STEREO = 119;
+    public static int WHITELIST_CUSTOMIZE_BANNER = 120;
+    public static int NV_MAPPER_GAME_LIST = 121;
+    public static int NV_MULTI_CAPTURE_MOD = 122;
+    public static int MEDIA_ENABLE_MSD_HAL = 123;
+    public static int DEEPISP_DISABLED = 124;
+    public static int OGL_GPFIFO_SIZE_ENTRIES = 125;
+}
",93,0,
284,c7c48b01e94c28663ce2e38a321da9fc19e601ee,ProfileTypeId.java,ModificationType.ADD,"@@ -0,0 +1,11 @@
+package com.nvidia.profilemanager;
+
+public class ProfileTypeId {
+    public static int LAST_RESERVED_TYPE = 9999;
+
+    public static int DEFAULT = 0;
+    public static int OEM_OVERRIDE = 1;
+    public static int DEV_OVERRIDE = 2;
+    public static int USER = 10000;
+    public static int OPTIMIZED = 10001;
+}
",11,0,
285,c7c48b01e94c28663ce2e38a321da9fc19e601ee,PackageManagerService.java,ModificationType.MODIFY,"@@ -328,6 +328,8 @@ import com.android.server.security.VerityUtils;
 import com.android.server.storage.DeviceStorageMonitorInternal;
 import com.android.server.wm.ActivityTaskManagerInternal;
 
+import com.nvidia.NvAppProfileService;
+
 import dalvik.system.CloseGuard;
 import dalvik.system.VMRuntime;
 
@@ -845,6 +847,13 @@ public class PackageManagerService extends IPackageManager.Stub
                 String targetPath) {
             return getStaticOverlayPaths(targetPackageName, targetPath);
         }
+
+        @Override public NvAppProfileService getAppProfileService() {
+            if (mAppProfileService == null) {
+                mAppProfileService = new NvAppProfileService(mContext);
+            }
+            return mAppProfileService;
+        }
     }
 
     class ParallelPackageParserCallback extends PackageParserCallback {
@@ -906,6 +915,8 @@ public class PackageManagerService extends IPackageManager.Stub
 
     final PackageInstallerService mInstallerService;
 
+    private NvAppProfileService mAppProfileService;
+
     final ArtManagerService mArtManagerService;
 
     private final PackageDexOptimizer mPackageDexOptimizer;
",11,0,PackageManagerService::PackageParserCallback::getAppProfileService
286,c7c48b01e94c28663ce2e38a321da9fc19e601ee,MockPackageManager.java,ModificationType.MODIFY,"@@ -55,6 +55,8 @@ import android.os.PersistableBundle;
 import android.os.UserHandle;
 import android.os.storage.VolumeInfo;
 
+import com.nvidia.NvAppProfileService;
+
 import java.util.List;
 import java.util.Set;
 
@@ -178,6 +180,12 @@ public class MockPackageManager extends PackageManager {
         throw new UnsupportedOperationException();
     }
 
+    /** @hide */
+    @Override
+    public NvAppProfileService getAppProfileService() {
+        throw new UnsupportedOperationException();
+    }
+
     @Override
     public ApplicationInfo getApplicationInfo(String packageName, int flags)
             throws NameNotFoundException {
",8,0,MockPackageManager::getAppProfileService
287,51d126e0ca6600c64f6670bdbed70c4c223711e4,NvAppProfile.java,ModificationType.ADD,"@@ -0,0 +1,65 @@
+package com.nvidia.NvCPLSvc;
+
+import android.net.ProxyInfo;
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.util.SparseArray;
+
+public class NvAppProfile implements Parcelable {
+    public static final Creator<NvAppProfile> CREATOR = new Creator<NvAppProfile>() {
+        public NvAppProfile createFromParcel(Parcel parcel) {
+            return NvAppProfile.createFromParcel(parcel);
+        }
+
+        public NvAppProfile[] newArray(int size) {
+            return new NvAppProfile[size];
+        }
+    };
+    public final String pkgName;
+    public final String pkgVersion;
+    public final int typeId;
+    public SparseArray<String> settings;
+
+    public NvAppProfile(int typeId, String pkgName, String pkgVersion,
+            SparseArray<String> settings) {
+        this.typeId = typeId;
+        this.pkgName = pkgName;
+        this.pkgVersion = pkgVersion;
+        this.settings = settings;
+    }
+
+    private static NvAppProfile createFromParcel(Parcel parcel) {
+        int typeId = parcel.readInt();
+        String pkgName = decodeNull(parcel.readString());
+        String pkgVersion = decodeNull(parcel.readString());
+        int numSettings = parcel.readInt();
+        SparseArray<String> settings = new SparseArray();
+        for (int i = 0; i < numSettings; i++) {
+            settings.append(parcel.readInt(), parcel.readString());
+        }
+        return new NvAppProfile(typeId, pkgName, pkgVersion, settings);
+    }
+
+    private static String encodeNull(String string) {
+        return string != null ? string : ProxyInfo.LOCAL_EXCL_LIST;
+    }
+
+    private static String decodeNull(String string) {
+        return !string.equals(ProxyInfo.LOCAL_EXCL_LIST) ? string : null;
+    }
+
+    public int describeContents() {
+        return 0;
+    }
+
+    public void writeToParcel(Parcel parcel, int flag) {
+        parcel.writeInt(this.typeId);
+        parcel.writeString(encodeNull(this.pkgName));
+        parcel.writeString(encodeNull(this.pkgVersion));
+        parcel.writeInt(this.settings.size());
+        for (int i = 0; i < this.settings.size(); i++) {
+            parcel.writeInt(this.settings.keyAt(i));
+            parcel.writeString((String) this.settings.valueAt(i));
+        }
+    }
+}
",65,0,"NvAppProfile::NvAppProfile, NvAppProfile::Creator<NvAppProfile>, NvAppProfile::decodeNull, NvAppProfile::describeContents, NvAppProfile::createFromParcel, NvAppProfile::writeToParcel, NvAppProfile::encodeNull"
288,51d126e0ca6600c64f6670bdbed70c4c223711e4,NvSaverAppInfo.java,ModificationType.ADD,"@@ -0,0 +1,166 @@
+package com.nvidia.NvCPLSvc;
+
+import android.graphics.drawable.Drawable;
+import android.os.Parcel;
+import android.os.Parcelable;
+
+public class NvSaverAppInfo implements Parcelable {
+    public static final Creator<NvSaverAppInfo> CREATOR = new Creator<NvSaverAppInfo>() {
+        public NvSaverAppInfo createFromParcel(Parcel source) {
+            return new NvSaverAppInfo(source);
+        }
+
+        public NvSaverAppInfo[] newArray(int size) {
+            return new NvSaverAppInfo[size];
+        }
+    };
+
+    public static final int NVSAVER_ACTIVITY_HIGH = 1;
+    public static final int NVSAVER_ACTIVITY_LOW = 3;
+    public static final int NVSAVER_ACTIVITY_MIDIUM = 2;
+    public static final int NVSAVER_LIST_BLACKLIST = 3;
+    public static final int NVSAVER_LIST_NONE = 1;
+    public static final int NVSAVER_LIST_WHITELIST = 2;
+    public static final int NV_APP_OPTIMIZE_LIST = 4;
+    public int mAppList;
+    public String mPkgName;
+    public long mTotalWakeupStatsTime;
+    public int mUid;
+    public long mWakeupStatsTime;
+    public int mWakeupTimes;
+    public int mWowWakeupTimes;
+    private int mAppActivity;
+    private Drawable mAppIcon;
+    private String mAppLabel;
+    private float mPowerSaver;
+
+    public NvSaverAppInfo(Parcel pl) {
+        mUid = pl.readInt();
+        mAppList = pl.readInt();
+        mWakeupTimes = pl.readInt();
+        mWowWakeupTimes = pl.readInt();
+        mPkgName = pl.readString();
+        mWakeupStatsTime = pl.readLong();
+        mTotalWakeupStatsTime = pl.readLong();
+        mAppLabel = null;
+        mAppIcon = null;
+        mAppActivity = 0;
+        mPowerSaver = 0.0f;
+    }
+
+    public NvSaverAppInfo(int u, int a, int w, int wow, String pkg, long t1, long t2) {
+        mUid = u;
+        mAppList = a;
+        mWakeupTimes = w;
+        mWowWakeupTimes = wow;
+        mPkgName = pkg;
+        mWakeupStatsTime = t1;
+        mTotalWakeupStatsTime = t2;
+        mAppLabel = null;
+        mAppIcon = null;
+        mAppActivity = 0;
+        mPowerSaver = 0.0f;
+    }
+
+    public String getAppLabel() {
+        return mAppLabel;
+    }
+
+    public void setAppLabel(String appLabel) {
+        mAppLabel = appLabel;
+    }
+
+    public Drawable getAppIcon() {
+        return mAppIcon;
+    }
+
+    public void setAppIcon(Drawable appIcon) {
+        mAppIcon = appIcon;
+    }
+
+    public int getAppActivity() {
+        return mAppActivity;
+    }
+
+    public void setAppActivity(int activity) {
+        mAppActivity = activity;
+    }
+
+    public String getPkgName() {
+        return mPkgName;
+    }
+
+    public void setPkgName(String pkgName) {
+        mPkgName = pkgName;
+    }
+
+    public int getUid() {
+        return mUid;
+    }
+
+    public void setUid(int uid) {
+        mUid = uid;
+    }
+
+    public int getWakeupTimes() {
+        return mWakeupTimes;
+    }
+
+    public void setWakeupTimes(int wakeupTimes) {
+        mWakeupTimes = wakeupTimes;
+    }
+
+    public int getWowWakeupTimes() {
+        return mWowWakeupTimes;
+    }
+
+    public void setWowWakeupTimes(int wowWakeupTimes) {
+        mWowWakeupTimes = wowWakeupTimes;
+    }
+
+    public long getTotalWakeupStatsTime() {
+        return mTotalWakeupStatsTime;
+    }
+
+    public void setTotalWakeupStatsTime(long totalWakeupStatsTime) {
+        mTotalWakeupStatsTime = totalWakeupStatsTime;
+    }
+
+    public long getWakeupStatsTime() {
+        return mWakeupStatsTime;
+    }
+
+    public void setWakeupStatsTime(long wakeupStatsTime) {
+        mWakeupStatsTime = wakeupStatsTime;
+    }
+
+    public int getAppList() {
+        return mAppList;
+    }
+
+    public void setAppList(int appList) {
+        mAppList = appList;
+    }
+
+    public float getPowerSaver() {
+        return mPowerSaver;
+    }
+
+    public void setPowerSaver(float powerSaver) {
+        mPowerSaver = powerSaver;
+    }
+
+    public int describeContents() {
+        return 0;
+    }
+
+    public void writeToParcel(Parcel dest, int flags) {
+        dest.writeInt(mUid);
+        dest.writeInt(mAppList);
+        dest.writeInt(mWakeupTimes);
+        dest.writeInt(mWowWakeupTimes);
+        dest.writeString(mPkgName);
+        dest.writeLong(mWakeupStatsTime);
+        dest.writeLong(mTotalWakeupStatsTime);
+    }
+}
",166,0,"NvSaverAppInfo::getUid, NvSaverAppInfo::setTotalWakeupStatsTime, NvSaverAppInfo::getPowerSaver, NvSaverAppInfo::getAppActivity, NvSaverAppInfo::getAppLabel, NvSaverAppInfo::setAppList, NvSaverAppInfo::getPkgName, NvSaverAppInfo::getTotalWakeupStatsTime, NvSaverAppInfo::setPkgName, NvSaverAppInfo::getWakeupTimes, NvSaverAppInfo::setWakeupStatsTime, NvSaverAppInfo::getAppList, NvSaverAppInfo::Creator<NvSaverAppInfo>, NvSaverAppInfo::setUid, NvSaverAppInfo::setAppLabel, NvSaverAppInfo::setWowWakeupTimes, NvSaverAppInfo::setAppActivity, NvSaverAppInfo::setWakeupTimes, NvSaverAppInfo::NvSaverAppInfo, NvSaverAppInfo::getWowWakeupTimes, NvSaverAppInfo::getAppIcon, NvSaverAppInfo::NvSaverAppInfo, NvSaverAppInfo::getWakeupStatsTime, NvSaverAppInfo::describeContents, NvSaverAppInfo::writeToParcel, NvSaverAppInfo::setAppIcon, NvSaverAppInfo::setPowerSaver"
289,acbd268cbdee3672574dd1b3e8b2bde70cdb131a,StatusBar.java,ModificationType.MODIFY,"@@ -3327,7 +3327,7 @@ public class StatusBar extends SystemUI implements DemoMode,
 
     private void updatePanelExpansionForKeyguard() {
         if (mState == StatusBarState.KEYGUARD && mBiometricUnlockController.getMode()
-                != BiometricUnlockController.MODE_WAKE_AND_UNLOCK && !mBouncerShowing) {
+                != BiometricUnlockController.MODE_WAKE_AND_UNLOCK) {
             instantExpandNotificationsPanel();
         } else if (mState == StatusBarState.FULLSCREEN_USER_SWITCHER) {
             instantCollapseNotificationPanel();
",1,1,StatusBar::updatePanelExpansionForKeyguard
290,acbd268cbdee3672574dd1b3e8b2bde70cdb131a,StatusBarKeyguardViewManager.java,ModificationType.MODIFY,"@@ -96,7 +96,6 @@ public class StatusBarKeyguardViewManager implements RemoteInputController.Callb
         @Override
         public void onFullyShown() {
             updateStates();
-            mStatusBar.wakeUpIfDozing(SystemClock.uptimeMillis(), mContainer, ""BOUNCER_VISIBLE"");
             updateLockIcon();
         }
 
",0,1,StatusBarKeyguardViewManager::BouncerExpansionCallback
291,86d76dab26a9f56549eaf9e9a45f9cf4a317c2c0,ZygoteInit.java,ModificationType.MODIFY,"@@ -754,7 +754,7 @@ public class ZygoteInit {
                 ""--setuid=1000"",
                 ""--setgid=1000"",
                 ""--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1021,1023,""
-                        + ""1024,1032,1065,3001,3002,3003,3006,3007,3009,3010"",
+                        + ""1024,1032,1065,3001,3002,3003,3006,3007,3009,3010,3011"",
                 ""--capabilities="" + capabilities + "","" + capabilities,
                 ""--nice-name=system_server"",
                 ""--runtime-args"",
",1,1,ZygoteInit::forkSystemServer
292,9ec2532457e70234e622cbdad75a3e4dfb2b0a90,VolumeDialogImpl.java,ModificationType.MODIFY,"@@ -1160,7 +1160,7 @@ public class VolumeDialogImpl implements VolumeDialog,
 
     protected void onStateChangedH(State state) {
         if (D.BUG) Log.d(TAG, ""onStateChangedH() state: "" + state.toString());
-        if (mState != null && state != null
+        if (mShowing && mState != null && state != null
                 && mState.ringerModeInternal != state.ringerModeInternal
                 && state.ringerModeInternal == AudioManager.RINGER_MODE_VIBRATE) {
             mController.vibrate(VibrationEffect.get(VibrationEffect.EFFECT_HEAVY_CLICK));
",1,1,VolumeDialogImpl::onStateChangedH
293,03ea07d9ebb254a8b0102b465e13afe421f40a4c,HdmiCecLocalDeviceAudioSystem.java,ModificationType.MODIFY,"@@ -70,6 +70,9 @@ public class HdmiCecLocalDeviceAudioSystem extends HdmiCecLocalDeviceSource {
 
     private static final String TAG = ""HdmiCecLocalDeviceAudioSystem"";
 
+    private static final boolean WAKE_ON_HOTPLUG =
+            SystemProperties.getBoolean(Constants.PROPERTY_WAKE_ON_HOTPLUG, false);
+
     // Whether the System Audio Control feature is enabled or not. True by default.
     @GuardedBy(""mLock"")
     private boolean mSystemAudioControlFeatureEnabled;
@@ -299,7 +302,7 @@ public class HdmiCecLocalDeviceAudioSystem extends HdmiCecLocalDeviceSource {
     @ServiceThreadOnly
     void onHotplug(int portId, boolean connected) {
         assertRunOnServiceThread();
-        if (connected) {
+        if (WAKE_ON_HOTPLUG && connected) {
             mService.wakeUp();
         }
         if (mService.getPortInfo(portId).getType() == HdmiPortInfo.PORT_OUTPUT) {
",4,1,HdmiCecLocalDeviceAudioSystem::onHotplug
294,03ea07d9ebb254a8b0102b465e13afe421f40a4c,HdmiCecLocalDeviceAudioSystemTest.java,ModificationType.MODIFY,"@@ -76,6 +76,7 @@ public class HdmiCecLocalDeviceAudioSystemTest {
     private boolean mMutingEnabled;
     private boolean mArcSupport;
     private HdmiPortInfo[] mHdmiPortInfo;
+    private boolean mWokenUp;
 
     @Before
     public void setUp() {
@@ -138,7 +139,9 @@ public class HdmiCecLocalDeviceAudioSystemTest {
                 }
 
                 @Override
-                void wakeUp() {}
+                void wakeUp() {
+                    mWokenUp = true;
+                }
 
                 @Override
                 void invokeDeviceEventListeners(HdmiDeviceInfo device, int status) {
@@ -692,4 +695,18 @@ public class HdmiCecLocalDeviceAudioSystemTest {
             .getCecDeviceInfo(differentDevice.getLogicalAddress())).isEqualTo(differentDevice);
         assertThat(mInvokeDeviceEventState).isEqualTo(DEVICE_EVENT_ADD_DEVICE);
     }
+
+    @Test
+    public void doNotWakeUpOnHotPlug_PlugIn() {
+        mWokenUp = false;
+        mHdmiCecLocalDeviceAudioSystem.onHotplug(0, true);
+        assertThat(mWokenUp).isFalse();
+    }
+
+    @Test
+    public void doNotWakeUpOnHotPlug_PlugOut() {
+        mWokenUp = false;
+        mHdmiCecLocalDeviceAudioSystem.onHotplug(0, false);
+        assertThat(mWokenUp).isFalse();
+    }
 }
",18,1,"HdmiCecLocalDeviceAudioSystemTest::doNotWakeUpOnHotPlug_PlugOut, HdmiCecLocalDeviceAudioSystemTest::setUp, HdmiCecLocalDeviceAudioSystemTest::doNotWakeUpOnHotPlug_PlugIn"
295,03ea07d9ebb254a8b0102b465e13afe421f40a4c,HdmiCecLocalDevicePlaybackTest.java,ModificationType.MODIFY,"@@ -47,6 +47,7 @@ public class HdmiCecLocalDevicePlaybackTest {
     private TestLooper mTestLooper = new TestLooper();
     private ArrayList<HdmiCecLocalDevice> mLocalDevices = new ArrayList<>();
     private int mPlaybackPhysicalAddress;
+    private boolean mWokenUp;
 
     @Before
     public void setUp() {
@@ -54,6 +55,7 @@ public class HdmiCecLocalDevicePlaybackTest {
             new HdmiControlService(InstrumentationRegistry.getTargetContext()) {
                 @Override
                 void wakeUp() {
+                    mWokenUp = true;
                 }
 
                 @Override
@@ -132,4 +134,18 @@ public class HdmiCecLocalDevicePlaybackTest {
         assertThat(mHdmiCecLocalDevicePlayback.handleSystemAudioModeStatus(message)).isTrue();
         assertThat(mHdmiCecLocalDevicePlayback.mService.isSystemAudioActivated()).isTrue();
     }
+
+    @Test
+    public void doNotWakeUpOnHotPlug_PlugIn() {
+        mWokenUp = false;
+        mHdmiCecLocalDevicePlayback.onHotplug(0, true);
+        assertThat(mWokenUp).isFalse();
+    }
+
+    @Test
+    public void doNotWakeUpOnHotPlug_PlugOut() {
+        mWokenUp = false;
+        mHdmiCecLocalDevicePlayback.onHotplug(0, false);
+        assertThat(mWokenUp).isFalse();
+    }
 }
",16,0,"HdmiCecLocalDevicePlaybackTest::doNotWakeUpOnHotPlug_PlugIn, HdmiCecLocalDevicePlaybackTest::doNotWakeUpOnHotPlug_PlugOut, HdmiCecLocalDevicePlaybackTest::setUp"
296,610e9d4a9b85c01570953d4e29a4d47e736420cd,HdmiControlService.java,ModificationType.MODIFY,"@@ -453,7 +453,7 @@ public class HdmiControlService extends SystemService {
             mIoThread.start();
             mIoLooper = mIoThread.getLooper();
         }
-        mPowerStatus = HdmiControlManager.POWER_STATUS_TRANSIENT_TO_ON;
+        mPowerStatus = getInitialPowerStatus();
         mProhibitMode = false;
         mHdmiControlEnabled = readBooleanSetting(Global.HDMI_CONTROL_ENABLED, true);
         mMhlInputChangeEnabled = readBooleanSetting(Global.MHL_INPUT_SWITCHING_ENABLED, true);
@@ -500,6 +500,28 @@ public class HdmiControlService extends SystemService {
         mMhlController.setOption(OPTION_MHL_SERVICE_CONTROL, ENABLED);
     }
 
+    private void bootCompleted() {
+        // on boot, if device is interactive, set HDMI CEC state as powered on as well
+        if (mPowerManager.isInteractive() && isPowerStandbyOrTransient()) {
+            onWakeUp();
+        }
+    }
+
+    /**
+     * Returns the initial power status used when the HdmiControlService starts.
+     */
+    @VisibleForTesting
+    int getInitialPowerStatus() {
+        // The initial power status is POWER_STATUS_TRANSIENT_TO_STANDBY.
+        // Once boot completes the service transitions to POWER_STATUS_ON if the device is
+        // interactive.
+        // Quiescent boot is a special boot mode, in which the screen stays off during boot
+        // and the device goes to sleep after boot has finished.
+        // We don't transition to POWER_STATUS_ON initially, as we might be booting in quiescent
+        // mode, during which we don't want to appear powered on to avoid being made active source.
+        return HdmiControlManager.POWER_STATUS_TRANSIENT_TO_STANDBY;
+    }
+
     @VisibleForTesting
     void setCecController(HdmiCecController cecController) {
         mCecController = cecController;
@@ -515,7 +537,9 @@ public class HdmiControlService extends SystemService {
         if (phase == SystemService.PHASE_SYSTEM_SERVICES_READY) {
             mTvInputManager = (TvInputManager) getContext().getSystemService(
                     Context.TV_INPUT_SERVICE);
-            mPowerManager = (PowerManager) getContext().getSystemService(Context.POWER_SERVICE);
+            mPowerManager = getContext().getSystemService(PowerManager.class);
+        } else if (phase == SystemService.PHASE_BOOT_COMPLETED) {
+            runOnServiceThread(this::bootCompleted);
         }
     }
 
@@ -541,9 +565,7 @@ public class HdmiControlService extends SystemService {
      * Called when the initialization of local devices is complete.
      */
     private void onInitializeCecComplete(int initiatedBy) {
-        if (mPowerStatus == HdmiControlManager.POWER_STATUS_TRANSIENT_TO_ON) {
-            mPowerStatus = HdmiControlManager.POWER_STATUS_ON;
-        }
+        updatePowerStatusOnInitializeCecComplete();
         mWakeUpMessageReceived = false;
 
         if (isTvDeviceEnabled()) {
@@ -567,6 +589,17 @@ public class HdmiControlService extends SystemService {
         }
     }
 
+    /**
+     * Updates the power status once the initialization of local devices is complete.
+     */
+    private void updatePowerStatusOnInitializeCecComplete() {
+        if (mPowerStatus == HdmiControlManager.POWER_STATUS_TRANSIENT_TO_ON) {
+            mPowerStatus = HdmiControlManager.POWER_STATUS_ON;
+        } else if (mPowerStatus == HdmiControlManager.POWER_STATUS_TRANSIENT_TO_STANDBY) {
+            mPowerStatus = HdmiControlManager.POWER_STATUS_STANDBY;
+        }
+    }
+
     private void registerContentObserver() {
         ContentResolver resolver = getContext().getContentResolver();
         String[] settings = new String[] {
@@ -2418,6 +2451,13 @@ public class HdmiControlService extends SystemService {
         return mPowerStatus;
     }
 
+    @ServiceThreadOnly
+    @VisibleForTesting
+    void setPowerStatus(int powerStatus) {
+        assertRunOnServiceThread();
+        mPowerStatus = powerStatus;
+    }
+
     @ServiceThreadOnly
     boolean isPowerOnOrTransient() {
         assertRunOnServiceThread();
",45,5,"HdmiControlService::updatePowerStatusOnInitializeCecComplete, HdmiControlService::bootCompleted, HdmiControlService::onStart, HdmiControlService::setPowerStatus, HdmiControlService::onBootPhase, HdmiControlService::onInitializeCecComplete, HdmiControlService::getInitialPowerStatus"
297,610e9d4a9b85c01570953d4e29a4d47e736420cd,HdmiControlServiceTest.java,ModificationType.MODIFY,"@@ -18,6 +18,7 @@ package com.android.server.hdmi;
 import static android.hardware.hdmi.HdmiDeviceInfo.DEVICE_AUDIO_SYSTEM;
 import static android.hardware.hdmi.HdmiDeviceInfo.DEVICE_PLAYBACK;
 
+import static com.android.server.SystemService.PHASE_BOOT_COMPLETED;
 import static com.android.server.hdmi.HdmiControlService.INITIATED_BY_ENABLE_CEC;
 
 import static com.google.common.truth.Truth.assertThat;
@@ -25,8 +26,17 @@ import static com.google.common.truth.Truth.assertThat;
 import static junit.framework.Assert.assertFalse;
 import static junit.framework.Assert.assertTrue;
 
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.when;
+
+import android.content.Context;
+import android.content.ContextWrapper;
+import android.hardware.hdmi.HdmiControlManager;
 import android.hardware.hdmi.HdmiPortInfo;
+import android.os.IPowerManager;
 import android.os.Looper;
+import android.os.PowerManager;
+import android.os.RemoteException;
 import android.os.test.TestLooper;
 
 import androidx.test.InstrumentationRegistry;
@@ -36,6 +46,8 @@ import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
 
 import java.util.ArrayList;
 
@@ -98,6 +110,7 @@ public class HdmiControlServiceTest {
     }
 
     private static final String TAG = ""HdmiControlServiceTest"";
+    private Context mContextSpy;
     private HdmiControlService mHdmiControlService;
     private HdmiCecController mHdmiCecController;
     private HdmiCecLocalDeviceMyDevice mMyAudioSystemDevice;
@@ -109,15 +122,24 @@ public class HdmiControlServiceTest {
     private boolean mStandbyMessageReceived;
     private HdmiPortInfo[] mHdmiPortInfo;
 
+    @Mock private IPowerManager mIPowerManagerMock;
+
     @Before
-    public void SetUp() {
-        mHdmiControlService =
-                new HdmiControlService(InstrumentationRegistry.getTargetContext()) {
-                    @Override
-                    boolean isStandbyMessageReceived() {
-                        return mStandbyMessageReceived;
-                    }
-                };
+    public void setUp() throws Exception {
+        MockitoAnnotations.initMocks(this);
+
+        mContextSpy = spy(new ContextWrapper(InstrumentationRegistry.getTargetContext()));
+
+        PowerManager powerManager = new PowerManager(mContextSpy, mIPowerManagerMock, null);
+        when(mContextSpy.getSystemService(Context.POWER_SERVICE)).thenReturn(powerManager);
+        when(mIPowerManagerMock.isInteractive()).thenReturn(true);
+
+        mHdmiControlService = new HdmiControlService(mContextSpy) {
+            @Override
+            boolean isStandbyMessageReceived() {
+                return mStandbyMessageReceived;
+            }
+        };
         mMyLooper = mTestLooper.getLooper();
 
         mMyAudioSystemDevice =
@@ -198,4 +220,33 @@ public class HdmiControlServiceTest {
         mHdmiControlService.initPortInfo();
         assertThat(mHdmiControlService.pathToPortId(0x1000)).isEqualTo(Constants.INVALID_PORT_ID);
     }
+
+    @Test
+    public void initialPowerStatus_normalBoot_isTransientToStandby() {
+        assertThat(mHdmiControlService.getInitialPowerStatus()).isEqualTo(
+                HdmiControlManager.POWER_STATUS_TRANSIENT_TO_STANDBY);
+    }
+
+    @Test
+    public void initialPowerStatus_quiescentBoot_isTransientToStandby() throws RemoteException {
+        when(mIPowerManagerMock.isInteractive()).thenReturn(false);
+        assertThat(mHdmiControlService.getInitialPowerStatus()).isEqualTo(
+                HdmiControlManager.POWER_STATUS_TRANSIENT_TO_STANDBY);
+    }
+
+    @Test
+    public void powerStatusAfterBootComplete_normalBoot_isOn() {
+        mHdmiControlService.setPowerStatus(HdmiControlManager.POWER_STATUS_TRANSIENT_TO_ON);
+        mHdmiControlService.onBootPhase(PHASE_BOOT_COMPLETED);
+        assertThat(mHdmiControlService.getPowerStatus()).isEqualTo(
+                HdmiControlManager.POWER_STATUS_TRANSIENT_TO_ON);
+    }
+
+    @Test
+    public void powerStatusAfterBootComplete_quiescentBoot_isStandby() throws RemoteException {
+        when(mIPowerManagerMock.isInteractive()).thenReturn(false);
+        mHdmiControlService.onBootPhase(PHASE_BOOT_COMPLETED);
+        assertThat(mHdmiControlService.getPowerStatus()).isEqualTo(
+                HdmiControlManager.POWER_STATUS_STANDBY);
+    }
 }
",59,8,"HdmiControlServiceTest::powerStatusAfterBootComplete_quiescentBoot_isStandby, HdmiControlServiceTest::SetUp, HdmiControlServiceTest::powerStatusAfterBootComplete_normalBoot_isOn, HdmiControlServiceTest::initialPowerStatus_normalBoot_isTransientToStandby, HdmiControlServiceTest::initialPowerStatus_quiescentBoot_isTransientToStandby, HdmiControlServiceTest::setUp"
298,b093ac4618707fe28934336a23bae05367d0f344,HdmiControlManager.java,ModificationType.MODIFY,"@@ -684,6 +684,28 @@ public final class HdmiControlManager {
     private final ArrayMap<HotplugEventListener, IHdmiHotplugEventListener>
             mHotplugEventListeners = new ArrayMap<>();
 
+    /**
+     * Listener used to get HDMI Control (CEC) status (enabled/disabled) and the connected display
+     * status.
+     * @hide
+     */
+    public interface HdmiControlStatusChangeListener {
+        /**
+         * Called when HDMI Control (CEC) is enabled/disabled.
+         *
+         * @param isCecEnabled status of HDMI Control
+         * {@link android.provider.Settings.Global#HDMI_CONTROL_ENABLED}: {@code true} if enabled.
+         * @param isCecAvailable status of CEC support of the connected display (the TV).
+         * {@code true} if supported.
+         *
+         * Note: Value of isCecAvailable is only valid when isCecEnabled is true.
+         **/
+        void onStatusChange(boolean isCecEnabled, boolean isCecAvailable);
+    }
+
+    private final ArrayMap<HdmiControlStatusChangeListener, IHdmiControlStatusChangeListener>
+            mHdmiControlStatusChangeListeners = new ArrayMap<>();
+
     /**
      * Listener used to get vendor-specific commands.
      */
@@ -777,4 +799,73 @@ public final class HdmiControlManager {
             }
         };
     }
+
+    /**
+     * Adds a listener to get informed of {@link HdmiControlStatusChange}.
+     *
+     * <p>To stop getting the notification,
+     * use {@link #removeHdmiControlStatusChangeListener(HdmiControlStatusChangeListener)}.
+     *
+     * @param listener {@link HdmiControlStatusChangeListener} instance
+     * @see HdmiControlManager#removeHdmiControlStatusChangeListener(
+     * HdmiControlStatusChangeListener)
+     *
+     * @hide
+     */
+    @RequiresPermission(android.Manifest.permission.HDMI_CEC)
+    public void addHdmiControlStatusChangeListener(HdmiControlStatusChangeListener listener) {
+        if (mService == null) {
+            Log.e(TAG, ""HdmiControlService is not available"");
+            return;
+        }
+        if (mHdmiControlStatusChangeListeners.containsKey(listener)) {
+            Log.e(TAG, ""listener is already registered"");
+            return;
+        }
+        IHdmiControlStatusChangeListener wrappedListener =
+                getHdmiControlStatusChangeListenerWrapper(listener);
+        mHdmiControlStatusChangeListeners.put(listener, wrappedListener);
+        try {
+            mService.addHdmiControlStatusChangeListener(wrappedListener);
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    /**
+     * Removes a listener to stop getting informed of {@link HdmiControlStatusChange}.
+     *
+     * @param listener {@link HdmiControlStatusChangeListener} instance to be removed
+     *
+     * @hide
+     */
+    @RequiresPermission(android.Manifest.permission.HDMI_CEC)
+    public void removeHdmiControlStatusChangeListener(HdmiControlStatusChangeListener listener) {
+        if (mService == null) {
+            Log.e(TAG, ""HdmiControlService is not available"");
+            return;
+        }
+        IHdmiControlStatusChangeListener wrappedListener =
+                mHdmiControlStatusChangeListeners.remove(listener);
+        if (wrappedListener == null) {
+            Log.e(TAG, ""tried to remove not-registered listener"");
+            return;
+        }
+        try {
+            mService.removeHdmiControlStatusChangeListener(wrappedListener);
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    private IHdmiControlStatusChangeListener getHdmiControlStatusChangeListenerWrapper(
+            final HdmiControlStatusChangeListener listener) {
+        return new IHdmiControlStatusChangeListener.Stub() {
+            @Override
+            public void onStatusChange(boolean isCecEnabled, boolean isCecAvailable) {
+                listener.onStatusChange(isCecEnabled, isCecAvailable);
+            }
+        };
+    }
+
 }
",91,0,"HdmiControlManager::removeHdmiControlStatusChangeListener, HdmiControlManager::addHdmiControlStatusChangeListener, HdmiControlManager::getHdmiControlStatusChangeListenerWrapper"
299,b093ac4618707fe28934336a23bae05367d0f344,HdmiAudioSystemClientTest.java,ModificationType.MODIFY,"@@ -193,6 +193,16 @@ public class HdmiAudioSystemClientTest {
         public void queryDisplayStatus(final IHdmiControlCallback callback) {
         }
 
+        @Override
+        public void addHdmiControlStatusChangeListener(
+                final IHdmiControlStatusChangeListener listener) {
+        }
+
+        @Override
+        public void removeHdmiControlStatusChangeListener(
+                final IHdmiControlStatusChangeListener listener) {
+        }
+
         @Override
         public void addHotplugEventListener(final IHdmiHotplugEventListener listener) {
         }
",10,0,"HdmiAudioSystemClientTest::TestHdmiControlService::removeHdmiControlStatusChangeListener, HdmiAudioSystemClientTest::TestHdmiControlService::addHdmiControlStatusChangeListener"
300,b093ac4618707fe28934336a23bae05367d0f344,AudioService.java,ModificationType.MODIFY,"@@ -889,7 +889,12 @@ public class AudioService extends IAudioService.Stub
 
         if (mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_HDMI_CEC)) {
             synchronized (mHdmiClientLock) {
+                mHdmiCecSink = false;
                 mHdmiManager = mContext.getSystemService(HdmiControlManager.class);
+                if (mHdmiManager != null) {
+                    mHdmiManager.addHdmiControlStatusChangeListener(
+                            mHdmiControlStatusChangeListenerCallback);
+                }
                 mHdmiTvClient = mHdmiManager.getTvClient();
                 if (mHdmiTvClient != null) {
                     mFixedVolumeDevices &= ~AudioSystem.DEVICE_ALL_HDMI_SYSTEM_AUDIO_AND_SPEAKER;
@@ -900,7 +905,6 @@ public class AudioService extends IAudioService.Stub
                     mFixedVolumeDevices &= ~AudioSystem.DEVICE_OUT_HDMI;
                     mFullVolumeDevices |= AudioSystem.DEVICE_OUT_HDMI;
                 }
-                mHdmiCecSink = false;
                 mHdmiAudioSystemClient = mHdmiManager.getAudioSystemClient();
             }
         }
@@ -1180,8 +1184,7 @@ public class AudioService extends IAudioService.Stub
                 checkAddAllFixedVolumeDevices(AudioSystem.DEVICE_OUT_HDMI, caller);
                 synchronized (mHdmiClientLock) {
                     if (mHdmiManager != null && mHdmiPlaybackClient != null) {
-                        mHdmiCecSink = false;
-                        mHdmiPlaybackClient.queryDisplayStatus(mHdmiDisplayStatusCallback);
+                        updateHdmiCecSinkLocked(mHdmiCecSink | false);
                     }
                 }
             }
@@ -1191,7 +1194,7 @@ public class AudioService extends IAudioService.Stub
             if (isPlatformTelevision()) {
                 synchronized (mHdmiClientLock) {
                     if (mHdmiManager != null) {
-                        mHdmiCecSink = false;
+                        updateHdmiCecSinkLocked(mHdmiCecSink | false);
                     }
                 }
             }
@@ -6265,32 +6268,37 @@ public class AudioService extends IAudioService.Stub
     //     are transformed into key events for the HDMI playback client.
     //==========================================================================================
 
-    private class MyDisplayStatusCallback implements HdmiPlaybackClient.DisplayStatusCallback {
-        public void onComplete(int status) {
-            synchronized (mHdmiClientLock) {
-                if (mHdmiManager != null) {
-                    mHdmiCecSink = (status != HdmiControlManager.POWER_STATUS_UNKNOWN);
-                    // Television devices without CEC service apply software volume on HDMI output
-                    if (mHdmiCecSink) {
-                        if (DEBUG_VOL) {
-                            Log.d(TAG, ""CEC sink: setting HDMI as full vol device"");
-                        }
-                        mFullVolumeDevices |= AudioSystem.DEVICE_OUT_HDMI;
-                    } else {
-                        if (DEBUG_VOL) {
-                            Log.d(TAG, ""TV, no CEC: setting HDMI as regular vol device"");
-                        }
-                        // Android TV devices without CEC service apply software volume on
-                        // HDMI output
-                        mFullVolumeDevices &= ~AudioSystem.DEVICE_OUT_HDMI;
-                    }
-                    checkAddAllFixedVolumeDevices(AudioSystem.DEVICE_OUT_HDMI,
-                            ""HdmiPlaybackClient.DisplayStatusCallback"");
-                }
+    @GuardedBy(""mHdmiClientLock"")
+    private void updateHdmiCecSinkLocked(boolean hdmiCecSink) {
+        mHdmiCecSink = hdmiCecSink;
+        if (mHdmiCecSink) {
+            if (DEBUG_VOL) {
+                Log.d(TAG, ""CEC sink: setting HDMI as full vol device"");
+            }
+            mFullVolumeDevices |= AudioSystem.DEVICE_OUT_HDMI;
+        } else {
+            if (DEBUG_VOL) {
+                Log.d(TAG, ""TV, no CEC: setting HDMI as regular vol device"");
             }
+            // Android TV devices without CEC service apply software volume on
+            // HDMI output
+            mFullVolumeDevices &= ~AudioSystem.DEVICE_OUT_HDMI;
         }
+
+        checkAddAllFixedVolumeDevices(AudioSystem.DEVICE_OUT_HDMI,
+                ""HdmiPlaybackClient.DisplayStatusCallback"");
     }
 
+    private class MyHdmiControlStatusChangeListenerCallback
+            implements HdmiControlManager.HdmiControlStatusChangeListener {
+        public void onStatusChange(boolean isCecEnabled, boolean isCecAvailable) {
+            synchronized (mHdmiClientLock) {
+                if (mHdmiManager == null) return;
+                updateHdmiCecSinkLocked(isCecEnabled ? isCecAvailable : false);
+            }
+        }
+    };
+
     private final Object mHdmiClientLock = new Object();
 
     // If HDMI-CEC system audio is supported
@@ -6306,12 +6314,14 @@ public class AudioService extends IAudioService.Stub
     @GuardedBy(""mHdmiClientLock"")
     private HdmiPlaybackClient mHdmiPlaybackClient;
     // true if we are a set-top box, an HDMI sink is connected and it supports CEC.
+    @GuardedBy(""mHdmiClientLock"")
     private boolean mHdmiCecSink;
     // Set only when device is an audio system.
     @GuardedBy(""mHdmiClientLock"")
     private HdmiAudioSystemClient mHdmiAudioSystemClient;
 
-    private MyDisplayStatusCallback mHdmiDisplayStatusCallback = new MyDisplayStatusCallback();
+    private MyHdmiControlStatusChangeListenerCallback mHdmiControlStatusChangeListenerCallback =
+            new MyHdmiControlStatusChangeListenerCallback();
 
     @Override
     public int setHdmiSystemAudioSupported(boolean on) {
",37,27,"AudioService::onCheckVolumeCecOnHdmiConnection, AudioService::MyHdmiControlStatusChangeListenerCallback::onStatusChange, AudioService::updateHdmiCecSinkLocked, AudioService::MyDisplayStatusCallback::onComplete, AudioService::onSystemReady"
301,b093ac4618707fe28934336a23bae05367d0f344,HdmiControlService.java,ModificationType.MODIFY,"@@ -42,6 +42,7 @@ import android.hardware.hdmi.HdmiHotplugEvent;
 import android.hardware.hdmi.HdmiPortInfo;
 import android.hardware.hdmi.IHdmiControlCallback;
 import android.hardware.hdmi.IHdmiControlService;
+import android.hardware.hdmi.IHdmiControlStatusChangeListener;
 import android.hardware.hdmi.IHdmiDeviceEventListener;
 import android.hardware.hdmi.IHdmiHotplugEventListener;
 import android.hardware.hdmi.IHdmiInputChangeListener;
@@ -251,6 +252,11 @@ public class HdmiControlService extends SystemService {
     // Type of logical devices hosted in the system. Stored in the unmodifiable list.
     private final List<Integer> mLocalDevices;
 
+    // List of records for HDMI control status change listener for death monitoring.
+    @GuardedBy(""mLock"")
+    private final ArrayList<HdmiControlStatusChangeListenerRecord>
+            mHdmiControlStatusChangeListenerRecords = new ArrayList<>();
+
     // List of records for hotplug event listener to handle the the caller killed in action.
     @GuardedBy(""mLock"")
     private final ArrayList<HotplugEventListenerRecord> mHotplugEventListenerRecords =
@@ -586,6 +592,7 @@ public class HdmiControlService extends SystemService {
         }
         if (reason != -1) {
             invokeVendorCommandListenersOnControlStateChanged(true, reason);
+            announceHdmiControlStatusChange(true);
         }
     }
 
@@ -1348,6 +1355,37 @@ public class HdmiControlService extends SystemService {
         }
     }
 
+    // Record class that monitors the event of the caller of being killed. Used to clean up
+    // the listener list and record list accordingly.
+    private final class HdmiControlStatusChangeListenerRecord implements IBinder.DeathRecipient {
+        private final IHdmiControlStatusChangeListener mListener;
+
+        HdmiControlStatusChangeListenerRecord(IHdmiControlStatusChangeListener listener) {
+            mListener = listener;
+        }
+
+        @Override
+        public void binderDied() {
+            synchronized (mLock) {
+                mHdmiControlStatusChangeListenerRecords.remove(this);
+            }
+        }
+
+        @Override
+        public boolean equals(Object obj) {
+            if (!(obj instanceof HdmiControlStatusChangeListenerRecord)) return false;
+            if (obj == this) return true;
+            HdmiControlStatusChangeListenerRecord other =
+                    (HdmiControlStatusChangeListenerRecord) obj;
+            return other.mListener == this.mListener;
+        }
+
+        @Override
+        public int hashCode() {
+            return mListener.hashCode();
+        }
+    }
+
     // Record class that monitors the event of the caller of being killed. Used to clean up
     // the listener list and record list accordingly.
     private final class HotplugEventListenerRecord implements IBinder.DeathRecipient {
@@ -1653,6 +1691,20 @@ public class HdmiControlService extends SystemService {
             });
         }
 
+        @Override
+        public void addHdmiControlStatusChangeListener(
+                final IHdmiControlStatusChangeListener listener) {
+            enforceAccessPermission();
+            HdmiControlService.this.addHdmiControlStatusChangeListener(listener);
+        }
+
+        @Override
+        public void removeHdmiControlStatusChangeListener(
+                final IHdmiControlStatusChangeListener listener) {
+            enforceAccessPermission();
+            HdmiControlService.this.removeHdmiControlStatusChangeListener(listener);
+        }
+
         @Override
         public void addHotplugEventListener(final IHdmiHotplugEventListener listener) {
             enforceAccessPermission();
@@ -2168,6 +2220,51 @@ public class HdmiControlService extends SystemService {
         source.queryDisplayStatus(callback);
     }
 
+    private void addHdmiControlStatusChangeListener(
+            final IHdmiControlStatusChangeListener listener) {
+        final HdmiControlStatusChangeListenerRecord record =
+                new HdmiControlStatusChangeListenerRecord(listener);
+        try {
+            listener.asBinder().linkToDeath(record, 0);
+        } catch (RemoteException e) {
+            Slog.w(TAG, ""Listener already died"");
+            return;
+        }
+        synchronized (mLock) {
+            mHdmiControlStatusChangeListenerRecords.add(record);
+        }
+
+        // Inform the listener of the initial state of each HDMI port by generating
+        // hotplug events.
+        runOnServiceThread(new Runnable() {
+            @Override
+            public void run() {
+                synchronized (mLock) {
+                    if (!mHdmiControlStatusChangeListenerRecords.contains(record)) return;
+                }
+
+                // Return the current status of mHdmiControlEnabled;
+                synchronized (mLock) {
+                    invokeHdmiControlStatusChangeListenerLocked(listener, mHdmiControlEnabled);
+                }
+            }
+        });
+    }
+
+    private void removeHdmiControlStatusChangeListener(
+            final IHdmiControlStatusChangeListener listener) {
+        synchronized (mLock) {
+            for (HdmiControlStatusChangeListenerRecord record :
+                    mHdmiControlStatusChangeListenerRecords) {
+                if (record.mListener.asBinder() == listener.asBinder()) {
+                    listener.asBinder().unlinkToDeath(record, 0);
+                    mHdmiControlStatusChangeListenerRecords.remove(record);
+                    break;
+                }
+            }
+        }
+    }
+
     private void addHotplugEventListener(final IHdmiHotplugEventListener listener) {
         final HotplugEventListenerRecord record = new HotplugEventListenerRecord(listener);
         try {
@@ -2400,6 +2497,47 @@ public class HdmiControlService extends SystemService {
         }
     }
 
+    private void announceHdmiControlStatusChange(boolean isEnabled) {
+        assertRunOnServiceThread();
+        synchronized (mLock) {
+            for (HdmiControlStatusChangeListenerRecord record :
+                    mHdmiControlStatusChangeListenerRecords) {
+                invokeHdmiControlStatusChangeListenerLocked(record.mListener, isEnabled);
+            }
+        }
+    }
+
+    private void invokeHdmiControlStatusChangeListenerLocked(
+            IHdmiControlStatusChangeListener listener, boolean isEnabled) {
+        if (isEnabled) {
+            queryDisplayStatus(new IHdmiControlCallback.Stub() {
+                public void onComplete(int status) {
+                    boolean isAvailable = true;
+                    if (status == HdmiControlManager.POWER_STATUS_UNKNOWN
+                            || status == HdmiControlManager.RESULT_EXCEPTION
+                            || status == HdmiControlManager.RESULT_SOURCE_NOT_AVAILABLE) {
+                        isAvailable = false;
+                    }
+
+                    try {
+                        listener.onStatusChange(isEnabled, isAvailable);
+                    } catch (RemoteException e) {
+                        Slog.e(TAG, ""Failed to report HdmiControlStatusChange: "" + isEnabled
+                                + "" isAvailable: "" + isAvailable, e);
+                    }
+                }
+            });
+            return;
+        }
+
+        try {
+            listener.onStatusChange(isEnabled, false);
+        } catch (RemoteException e) {
+            Slog.e(TAG, ""Failed to report HdmiControlStatusChange: "" + isEnabled
+                    + "" isAvailable: "" + false, e);
+        }
+    }
+
     public HdmiCecLocalDeviceTv tv() {
         return (HdmiCecLocalDeviceTv) mCecController.getLocalDevice(HdmiDeviceInfo.DEVICE_TV);
     }
@@ -2776,6 +2914,8 @@ public class HdmiControlService extends SystemService {
                 disableHdmiControlService();
             }
         });
+        announceHdmiControlStatusChange(enabled);
+
         return;
     }
 
",140,0,"HdmiControlService::HdmiControlStatusChangeListenerRecord::equals, HdmiControlService::BinderService::removeHdmiControlStatusChangeListener, HdmiControlService::HdmiControlStatusChangeListenerRecord::hashCode, HdmiControlService::announceHdmiControlStatusChange, HdmiControlService::setControlEnabled, HdmiControlService::HdmiControlStatusChangeListenerRecord::binderDied, HdmiControlService::invokeHdmiControlStatusChangeListenerLocked, HdmiControlService::HdmiControlStatusChangeListenerRecord::HdmiControlStatusChangeListenerRecord, HdmiControlService::removeHdmiControlStatusChangeListener, HdmiControlService::BinderService::addHdmiControlStatusChangeListener, HdmiControlService::onInitializeCecComplete, HdmiControlService::addHdmiControlStatusChangeListener"
302,dccbb024fd13bc8cb50fc46d73a38be3f4d6ddc0,HdmiControlManager.java,ModificationType.MODIFY,"@@ -592,6 +592,68 @@ public final class HdmiControlManager {
         }
     }
 
+    /**
+     * Controls whether volume control commands via HDMI CEC are enabled.
+     *
+     * <p>When disabled:
+     * <ul>
+     *     <li>the device will not send any HDMI CEC audio messages
+     *     <li>received HDMI CEC audio messages are responded to with {@code <Feature Abort>}
+     * </ul>
+     *
+     * <p>Effects on different device types:
+     * <table>
+     *     <tr><th>HDMI CEC device type</th><th>enabled</th><th>disabled</th></tr>
+     *     <tr>
+     *         <td>TV (type: 0)</td>
+     *         <td>Per CEC specification.</td>
+     *         <td>TV changes system volume. TV no longer reacts to incoming volume changes via
+     *         {@code <User Control Pressed>}. TV no longer handles {@code <Report Audio Status>}
+     *         .</td>
+     *     </tr>
+     *     <tr>
+     *         <td>Playback device (type: 4)</td>
+     *         <td>Device sends volume commands to TV/Audio system via {@code <User Control
+     *         Pressed>}</td><td>Device does not send volume commands via {@code <User Control
+     *         Pressed>}.</td>
+     *     </tr>
+     *     <tr>
+     *         <td>Audio device (type: 5)</td>
+     *         <td>Full ""System Audio Control"" capabilities.</td>
+     *         <td>Audio device no longer reacts to incoming {@code <User Control Pressed>}
+     *         volume commands. Audio device no longer reports volume changes via {@code <Report
+     *         Audio Status>}.</td>
+     *     </tr>
+     * </table>
+     *
+     * <p> Due to the resulting behavior, usage on TV and Audio devices is discouraged.
+     *
+     * @param isHdmiCecVolumeControlEnabled target state of HDMI CEC volume control.
+     * @see Settings.Global.HDMI_CONTROL_VOLUME_CONTROL_ENABLED
+     * @hide
+     */
+    @RequiresPermission(android.Manifest.permission.HDMI_CEC)
+    public void setHdmiCecVolumeControlEnabled(boolean isHdmiCecVolumeControlEnabled) {
+        try {
+            mService.setHdmiCecVolumeControlEnabled(isHdmiCecVolumeControlEnabled);
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    /**
+     * Returns whether volume changes via HDMI CEC are enabled.
+     * @hide
+     */
+    @RequiresPermission(android.Manifest.permission.HDMI_CEC)
+    public boolean isHdmiCecVolumeControlEnabled() {
+        try {
+            return mService.isHdmiCecVolumeControlEnabled();
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
     /**
      * Gets whether the system is in system audio mode.
      *
",62,0,"HdmiControlManager::setHdmiCecVolumeControlEnabled, HdmiControlManager::isHdmiCecVolumeControlEnabled"
303,dccbb024fd13bc8cb50fc46d73a38be3f4d6ddc0,Settings.java,ModificationType.MODIFY,"@@ -10075,6 +10075,43 @@ public final class Settings {
         */
        public static final String HDMI_CONTROL_ENABLED = ""hdmi_control_enabled"";
 
+        /**
+         * Controls whether volume control commands via HDMI CEC are enabled. (0 = false, 1 =
+         * true).
+         *
+         * <p>Effects on different device types:
+         * <table>
+         *     <tr><th>HDMI CEC device type</th><th>0: disabled</th><th>1: enabled</th></tr>
+         *     <tr>
+         *         <td>TV (type: 0)</td>
+         *         <td>Per CEC specification.</td>
+         *         <td>TV changes system volume. TV no longer reacts to incoming volume changes
+         *         via {@code <User Control Pressed>}. TV no longer handles {@code <Report Audio
+         *         Status>}.</td>
+         *     </tr>
+         *     <tr>
+         *         <td>Playback device (type: 4)</td>
+         *         <td>Device sends volume commands to TV/Audio system via {@code <User Control
+         *         Pressed>}</td>
+         *         <td>Device does not send volume commands via {@code <User Control Pressed>}.</td>
+         *     </tr>
+         *     <tr>
+         *         <td>Audio device (type: 5)</td>
+         *         <td>Full ""System Audio Control"" capabilities.</td>
+         *         <td>Audio device no longer reacts to incoming {@code <User Control Pressed>}
+         *         volume commands. Audio device no longer reports volume changes via {@code
+         *         <Report Audio Status>}.</td>
+         *     </tr>
+         * </table>
+         *
+         * <p> Due to the resulting behavior, usage on TV and Audio devices is discouraged.
+         *
+         * @hide
+         * @see android.hardware.hdmi.HdmiControlManager#setHdmiCecVolumeControlEnabled(boolean)
+         */
+        public static final String HDMI_CONTROL_VOLUME_CONTROL_ENABLED =
+                ""hdmi_control_volume_control_enabled"";
+
        /**
         * Whether HDMI System Audio Control feature is enabled. If enabled, TV will try to turn on
         * system audio mode if there's a connected CEC-enabled AV Receiver. Then audio stream will
",37,0,
304,dccbb024fd13bc8cb50fc46d73a38be3f4d6ddc0,HdmiAudioSystemClientTest.java,ModificationType.MODIFY,"@@ -354,6 +354,15 @@ public class HdmiAudioSystemClientTest {
         @Override
         public void askRemoteDeviceToBecomeActiveSource(int physicalAddress) {
         }
+
+        @Override
+        public void setHdmiCecVolumeControlEnabled(boolean isHdmiCecVolumeControlEnabled) {
+        }
+
+        @Override
+        public boolean isHdmiCecVolumeControlEnabled() {
+            return true;
+        }
     }
 
 }
",9,0,"HdmiAudioSystemClientTest::TestHdmiControlService::setHdmiCecVolumeControlEnabled, HdmiAudioSystemClientTest::TestHdmiControlService::isHdmiCecVolumeControlEnabled"
305,dccbb024fd13bc8cb50fc46d73a38be3f4d6ddc0,HdmiCecLocalDevice.java,ModificationType.MODIFY,"@@ -31,6 +31,7 @@ import android.view.KeyCharacterMap;
 import android.view.KeyEvent;
 
 import com.android.internal.annotations.GuardedBy;
+import com.android.internal.annotations.VisibleForTesting;
 import com.android.internal.util.IndentingPrintWriter;
 import com.android.server.hdmi.Constants.LocalActivePort;
 import com.android.server.hdmi.HdmiAnnotations.ServiceThreadOnly;
@@ -143,7 +144,8 @@ abstract class HdmiCecLocalDevice {
 
     // A collection of FeatureAction.
     // Note that access to this collection should happen in service thread.
-    private final ArrayList<HdmiCecFeatureAction> mActions = new ArrayList<>();
+    @VisibleForTesting
+    final ArrayList<HdmiCecFeatureAction> mActions = new ArrayList<>();
 
     private final Handler mHandler =
             new Handler() {
@@ -532,6 +534,8 @@ abstract class HdmiCecLocalDevice {
         } else if (mService.isPowerStandbyOrTransient() && isPowerOnOrToggleCommand(message)) {
             mService.wakeUp();
             return true;
+        } else if (!mService.isHdmiCecVolumeControlEnabled() && isVolumeOrMuteCommand(message)) {
+            return false;
         }
 
         final long downTime = SystemClock.uptimeMillis();
@@ -606,6 +610,16 @@ abstract class HdmiCecLocalDevice {
                         || params[0] == HdmiCecKeycode.CEC_KEYCODE_POWER_TOGGLE_FUNCTION);
     }
 
+    static boolean isVolumeOrMuteCommand(HdmiCecMessage message) {
+        byte[] params = message.getParams();
+        return message.getOpcode() == Constants.MESSAGE_USER_CONTROL_PRESSED
+                && (params[0] == HdmiCecKeycode.CEC_KEYCODE_VOLUME_DOWN
+                    || params[0] == HdmiCecKeycode.CEC_KEYCODE_VOLUME_UP
+                    || params[0] == HdmiCecKeycode.CEC_KEYCODE_MUTE
+                    || params[0] == HdmiCecKeycode.CEC_KEYCODE_MUTE_FUNCTION
+                    || params[0] == HdmiCecKeycode.CEC_KEYCODE_RESTORE_VOLUME_FUNCTION);
+    }
+
     protected boolean handleTextViewOn(HdmiCecMessage message) {
         return false;
     }
@@ -1026,6 +1040,9 @@ abstract class HdmiCecLocalDevice {
     @ServiceThreadOnly
     protected void sendVolumeKeyEvent(int keyCode, boolean isPressed) {
         assertRunOnServiceThread();
+        if (!mService.isHdmiCecVolumeControlEnabled()) {
+            return;
+        }
         if (!HdmiCecKeycode.isVolumeKeycode(keyCode)) {
             Slog.w(TAG, ""Not a volume key: "" + keyCode);
             return;
",18,1,"HdmiCecLocalDevice::isVolumeOrMuteCommand, HdmiCecLocalDevice::handleUserControlPressed, HdmiCecLocalDevice::sendVolumeKeyEvent"
306,dccbb024fd13bc8cb50fc46d73a38be3f4d6ddc0,HdmiCecLocalDeviceAudioSystem.java,ModificationType.MODIFY,"@@ -505,7 +505,7 @@ public class HdmiCecLocalDeviceAudioSystem extends HdmiCecLocalDeviceSource {
     @ServiceThreadOnly
     protected boolean handleGiveAudioStatus(HdmiCecMessage message) {
         assertRunOnServiceThread();
-        if (isSystemAudioControlFeatureEnabled()) {
+        if (isSystemAudioControlFeatureEnabled() && mService.isHdmiCecVolumeControlEnabled()) {
             reportAudioStatus(message.getSource());
         } else {
             mService.maySendFeatureAbortCommand(message, Constants.ABORT_REFUSED);
@@ -838,6 +838,9 @@ public class HdmiCecLocalDeviceAudioSystem extends HdmiCecLocalDeviceSource {
 
     void reportAudioStatus(int source) {
         assertRunOnServiceThread();
+        if (!mService.isHdmiCecVolumeControlEnabled()) {
+            return;
+        }
 
         int volume = mService.getAudioManager().getStreamVolume(AudioManager.STREAM_MUSIC);
         boolean mute = mService.getAudioManager().isStreamMute(AudioManager.STREAM_MUSIC);
",4,1,"HdmiCecLocalDeviceAudioSystem::handleGiveAudioStatus, HdmiCecLocalDeviceAudioSystem::reportAudioStatus"
307,dccbb024fd13bc8cb50fc46d73a38be3f4d6ddc0,HdmiCecLocalDeviceTv.java,ModificationType.MODIFY,"@@ -678,6 +678,9 @@ final class HdmiCecLocalDeviceTv extends HdmiCecLocalDevice {
     @ServiceThreadOnly
     protected boolean handleReportAudioStatus(HdmiCecMessage message) {
         assertRunOnServiceThread();
+        if (!mService.isHdmiCecVolumeControlEnabled()) {
+            return false;
+        }
 
         boolean mute = HdmiUtils.isAudioStatusMute(message);
         int volume = HdmiUtils.getAudioStatusVolume(message);
@@ -983,7 +986,7 @@ final class HdmiCecLocalDeviceTv extends HdmiCecLocalDevice {
     }
 
     void setAudioStatus(boolean mute, int volume) {
-        if (!isSystemAudioActivated()) {
+        if (!isSystemAudioActivated() || !mService.isHdmiCecVolumeControlEnabled()) {
             return;
         }
         synchronized (mLock) {
@@ -1005,7 +1008,7 @@ final class HdmiCecLocalDeviceTv extends HdmiCecLocalDevice {
             // On initialization process, getAvrDeviceInfo() may return null and cause exception
             return;
         }
-        if (delta == 0 || !isSystemAudioActivated()) {
+        if (delta == 0 || !isSystemAudioActivated() || !mService.isHdmiCecVolumeControlEnabled()) {
             return;
         }
 
@@ -1034,7 +1037,7 @@ final class HdmiCecLocalDeviceTv extends HdmiCecLocalDevice {
     @ServiceThreadOnly
     void changeMute(boolean mute) {
         assertRunOnServiceThread();
-        if (getAvrDeviceInfo() == null) {
+        if (getAvrDeviceInfo() == null || !mService.isHdmiCecVolumeControlEnabled()) {
             // On initialization process, getAvrDeviceInfo() may return null and cause exception
             return;
         }
",6,3,"HdmiCecLocalDeviceTv::changeVolume, HdmiCecLocalDeviceTv::handleReportAudioStatus, HdmiCecLocalDeviceTv::setAudioStatus, HdmiCecLocalDeviceTv::changeMute"
308,dccbb024fd13bc8cb50fc46d73a38be3f4d6ddc0,HdmiControlService.java,ModificationType.MODIFY,"@@ -148,6 +148,10 @@ public class HdmiControlService extends SystemService {
     @GuardedBy(""mLock"")
     protected final ActiveSource mActiveSource = new ActiveSource();
 
+    // Whether HDMI CEC volume control is enabled or not.
+    @GuardedBy(""mLock"")
+    private boolean mHdmiCecVolumeControlEnabled;
+
     // Whether System Audio Mode is activated or not.
     @GuardedBy(""mLock"")
     private boolean mSystemAudioActivated = false;
@@ -462,6 +466,8 @@ public class HdmiControlService extends SystemService {
         mPowerStatus = getInitialPowerStatus();
         mProhibitMode = false;
         mHdmiControlEnabled = readBooleanSetting(Global.HDMI_CONTROL_ENABLED, true);
+        mHdmiCecVolumeControlEnabled = readBooleanSetting(
+                Global.HDMI_CONTROL_VOLUME_CONTROL_ENABLED, true);
         mMhlInputChangeEnabled = readBooleanSetting(Global.MHL_INPUT_SWITCHING_ENABLED, true);
 
         if (mCecController == null) {
@@ -611,6 +617,7 @@ public class HdmiControlService extends SystemService {
         ContentResolver resolver = getContext().getContentResolver();
         String[] settings = new String[] {
                 Global.HDMI_CONTROL_ENABLED,
+                Global.HDMI_CONTROL_VOLUME_CONTROL_ENABLED,
                 Global.HDMI_CONTROL_AUTO_WAKEUP_ENABLED,
                 Global.HDMI_CONTROL_AUTO_DEVICE_OFF_ENABLED,
                 Global.HDMI_SYSTEM_AUDIO_CONTROL_ENABLED,
@@ -639,6 +646,9 @@ public class HdmiControlService extends SystemService {
                 case Global.HDMI_CONTROL_ENABLED:
                     setControlEnabled(enabled);
                     break;
+                case Global.HDMI_CONTROL_VOLUME_CONTROL_ENABLED:
+                    setHdmiCecVolumeControlEnabled(enabled);
+                    break;
                 case Global.HDMI_CONTROL_AUTO_WAKEUP_ENABLED:
                     if (isTvDeviceEnabled()) {
                         tv().setAutoWakeup(enabled);
@@ -1198,7 +1208,9 @@ public class HdmiControlService extends SystemService {
     }
 
     void setAudioStatus(boolean mute, int volume) {
-        if (!isTvDeviceEnabled() || !tv().isSystemAudioActivated()) {
+        if (!isTvDeviceEnabled()
+                || !tv().isSystemAudioActivated()
+                || !isHdmiCecVolumeControlEnabled()) {
             return;
         }
         AudioManager audioManager = getAudioManager();
@@ -2088,6 +2100,24 @@ public class HdmiControlService extends SystemService {
             });
         }
 
+        @Override
+        public boolean isHdmiCecVolumeControlEnabled() {
+            enforceAccessPermission();
+            return HdmiControlService.this.isHdmiCecVolumeControlEnabled();
+        }
+
+        @Override
+        public void setHdmiCecVolumeControlEnabled(final boolean isHdmiCecVolumeControlEnabled) {
+            enforceAccessPermission();
+            runOnServiceThread(new Runnable() {
+                @Override
+                public void run() {
+                    HdmiControlService.this.setHdmiCecVolumeControlEnabled(
+                            isHdmiCecVolumeControlEnabled);
+                }
+            });
+        }
+
         @Override
         public void reportAudioStatus(final int deviceType, final int volume, final int maxVolume,
                 final boolean isMute) {
@@ -2152,6 +2182,7 @@ public class HdmiControlService extends SystemService {
             pw.println(""mHdmiControlEnabled: "" + mHdmiControlEnabled);
             pw.println(""mMhlInputChangeEnabled: "" + mMhlInputChangeEnabled);
             pw.println(""mSystemAudioActivated: "" + isSystemAudioActivated());
+            pw.println(""mHdmiCecVolumeControlEnabled "" + mHdmiCecVolumeControlEnabled);
             pw.decreaseIndent();
 
             pw.println(""mMhlController: "");
@@ -2861,6 +2892,29 @@ public class HdmiControlService extends SystemService {
         }
     }
 
+    void setHdmiCecVolumeControlEnabled(boolean isHdmiCecVolumeControlEnabled) {
+        assertRunOnServiceThread();
+        synchronized (mLock) {
+            mHdmiCecVolumeControlEnabled = isHdmiCecVolumeControlEnabled;
+
+            boolean storedValue = readBooleanSetting(Global.HDMI_CONTROL_VOLUME_CONTROL_ENABLED,
+                    true);
+            if (storedValue != isHdmiCecVolumeControlEnabled) {
+                HdmiLogger.debug(""Changing HDMI CEC volume control feature state: %s"",
+                        isHdmiCecVolumeControlEnabled);
+                writeBooleanSetting(Global.HDMI_CONTROL_VOLUME_CONTROL_ENABLED,
+                        isHdmiCecVolumeControlEnabled);
+            }
+        }
+    }
+
+    boolean isHdmiCecVolumeControlEnabled() {
+        assertRunOnServiceThread();
+        synchronized (mLock) {
+            return mHdmiCecVolumeControlEnabled;
+        }
+    }
+
     boolean isProhibitMode() {
         synchronized (mLock) {
             return mProhibitMode;
@@ -2901,8 +2955,12 @@ public class HdmiControlService extends SystemService {
 
         if (enabled) {
             enableHdmiControlService();
+            setHdmiCecVolumeControlEnabled(
+                    readBooleanSetting(Global.HDMI_CONTROL_VOLUME_CONTROL_ENABLED, true));
             return;
         }
+
+        setHdmiCecVolumeControlEnabled(false);
         // Call the vendor handler before the service is disabled.
         invokeVendorCommandListenersOnControlStateChanged(false,
                 HdmiControlManager.CONTROL_STATE_CHANGED_REASON_SETTING);
",59,1,"HdmiControlService::BinderService::setHdmiCecVolumeControlEnabled, HdmiControlService::onStart, HdmiControlService::setControlEnabled, HdmiControlService::setAudioStatus, HdmiControlService::SettingsObserver::onChange, HdmiControlService::BinderService::dump, HdmiControlService::setHdmiCecVolumeControlEnabled, HdmiControlService::BinderService::isHdmiCecVolumeControlEnabled, HdmiControlService::isHdmiCecVolumeControlEnabled, HdmiControlService::registerContentObserver"
309,dccbb024fd13bc8cb50fc46d73a38be3f4d6ddc0,HdmiCecLocalDeviceAudioSystemTest.java,ModificationType.MODIFY,"@@ -24,6 +24,7 @@ import static com.android.server.hdmi.Constants.ADDR_PLAYBACK_1;
 import static com.android.server.hdmi.Constants.ADDR_PLAYBACK_2;
 import static com.android.server.hdmi.Constants.ADDR_TUNER_1;
 import static com.android.server.hdmi.Constants.ADDR_TV;
+import static com.android.server.hdmi.Constants.MESSAGE_GIVE_AUDIO_STATUS;
 import static com.android.server.hdmi.HdmiControlService.INITIATED_BY_ENABLE_CEC;
 import static com.android.server.hdmi.HdmiControlService.STANDBY_SCREEN_OFF;
 
@@ -47,6 +48,7 @@ import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
 import java.util.ArrayList;
+
 @SmallTest
 @RunWith(JUnit4.class)
 /** Tests for {@link HdmiCecLocalDeviceAudioSystem} class. */
@@ -167,6 +169,8 @@ public class HdmiCecLocalDeviceAudioSystemTest {
                 }
             };
 
+        mHdmiControlService.setHdmiCecVolumeControlEnabled(true);
+
         mMyLooper = mTestLooper.getLooper();
         mHdmiCecLocalDeviceAudioSystem = new HdmiCecLocalDeviceAudioSystem(mHdmiControlService);
         mHdmiCecLocalDevicePlayback = new HdmiCecLocalDevicePlayback(mHdmiControlService) {
@@ -709,4 +713,112 @@ public class HdmiCecLocalDeviceAudioSystemTest {
         mHdmiCecLocalDeviceAudioSystem.onHotplug(0, false);
         assertThat(mWokenUp).isFalse();
     }
+
+    @Test
+    public void giveAudioStatus_volumeEnabled() {
+        mMusicVolume = 50;
+        mMusicMaxVolume = 100;
+        mHdmiControlService.setHdmiCecVolumeControlEnabled(true);
+        mHdmiCecLocalDeviceAudioSystem.setSystemAudioControlFeatureEnabled(true);
+
+        int volume = mHdmiControlService.getAudioManager()
+                .getStreamVolume(AudioManager.STREAM_MUSIC);
+        boolean mute = mHdmiControlService.getAudioManager()
+                .isStreamMute(AudioManager.STREAM_MUSIC);
+        int maxVolume = mHdmiControlService.getAudioManager()
+                .getStreamMaxVolume(AudioManager.STREAM_MUSIC);
+        int scaledVolume = VolumeControlAction.scaleToCecVolume(volume, maxVolume);
+        HdmiCecMessage expected = HdmiCecMessageBuilder.buildReportAudioStatus(ADDR_AUDIO_SYSTEM,
+                ADDR_TV, scaledVolume, mute);
+        HdmiCecMessage featureAbort = HdmiCecMessageBuilder.buildFeatureAbortCommand(
+                ADDR_AUDIO_SYSTEM, ADDR_TV, MESSAGE_GIVE_AUDIO_STATUS, Constants.ABORT_REFUSED);
+
+        HdmiCecMessage giveAudioStatus = HdmiCecMessageBuilder.buildGiveAudioStatus(ADDR_TV,
+                ADDR_AUDIO_SYSTEM);
+        mNativeWrapper.clearResultMessages();
+        boolean handled = mHdmiCecLocalDeviceAudioSystem.handleGiveAudioStatus(giveAudioStatus);
+        mTestLooper.dispatchAll();
+
+        assertThat(mNativeWrapper.getResultMessages()).contains(expected);
+        assertThat(mNativeWrapper.getResultMessages()).doesNotContain(featureAbort);
+        assertThat(handled).isTrue();
+    }
+
+    @Test
+    public void giveAudioStatus_volumeDisabled() {
+        mMusicVolume = 50;
+        mMusicMaxVolume = 100;
+        mHdmiControlService.setHdmiCecVolumeControlEnabled(false);
+        mHdmiCecLocalDeviceAudioSystem.setSystemAudioControlFeatureEnabled(true);
+
+        int volume = mHdmiControlService.getAudioManager()
+                .getStreamVolume(AudioManager.STREAM_MUSIC);
+        boolean mute = mHdmiControlService.getAudioManager()
+                .isStreamMute(AudioManager.STREAM_MUSIC);
+        int maxVolume = mHdmiControlService.getAudioManager()
+                .getStreamMaxVolume(AudioManager.STREAM_MUSIC);
+        int scaledVolume = VolumeControlAction.scaleToCecVolume(volume, maxVolume);
+        HdmiCecMessage unexpected = HdmiCecMessageBuilder.buildReportAudioStatus(ADDR_AUDIO_SYSTEM,
+                ADDR_TV, scaledVolume, mute);
+        HdmiCecMessage featureAbort = HdmiCecMessageBuilder.buildFeatureAbortCommand(
+                ADDR_AUDIO_SYSTEM, ADDR_TV, MESSAGE_GIVE_AUDIO_STATUS, Constants.ABORT_REFUSED);
+
+        HdmiCecMessage giveAudioStatus = HdmiCecMessageBuilder.buildGiveAudioStatus(ADDR_TV,
+                ADDR_AUDIO_SYSTEM);
+        mNativeWrapper.clearResultMessages();
+        boolean handled = mHdmiCecLocalDeviceAudioSystem.handleGiveAudioStatus(giveAudioStatus);
+        mTestLooper.dispatchAll();
+
+        assertThat(mNativeWrapper.getResultMessages()).contains(featureAbort);
+        assertThat(mNativeWrapper.getResultMessages()).doesNotContain(unexpected);
+        assertThat(handled).isTrue();
+    }
+
+    @Test
+    public void reportAudioStatus_volumeEnabled() {
+        mMusicVolume = 50;
+        mMusicMaxVolume = 100;
+        mHdmiControlService.setHdmiCecVolumeControlEnabled(true);
+        mHdmiCecLocalDeviceAudioSystem.setSystemAudioControlFeatureEnabled(true);
+
+        int volume = mHdmiControlService.getAudioManager()
+                .getStreamVolume(AudioManager.STREAM_MUSIC);
+        boolean mute = mHdmiControlService.getAudioManager()
+                .isStreamMute(AudioManager.STREAM_MUSIC);
+        int maxVolume = mHdmiControlService.getAudioManager()
+                .getStreamMaxVolume(AudioManager.STREAM_MUSIC);
+        int scaledVolume = VolumeControlAction.scaleToCecVolume(volume, maxVolume);
+        HdmiCecMessage expected = HdmiCecMessageBuilder.buildReportAudioStatus(ADDR_AUDIO_SYSTEM,
+                ADDR_TV, scaledVolume, mute);
+
+        mNativeWrapper.clearResultMessages();
+        mHdmiCecLocalDeviceAudioSystem.reportAudioStatus(ADDR_TV);
+        mTestLooper.dispatchAll();
+
+        assertThat(mNativeWrapper.getResultMessages()).contains(expected);
+    }
+
+    @Test
+    public void reportAudioStatus_volumeDisabled() {
+        mMusicVolume = 50;
+        mMusicMaxVolume = 100;
+        mHdmiControlService.setHdmiCecVolumeControlEnabled(false);
+        mHdmiCecLocalDeviceAudioSystem.setSystemAudioControlFeatureEnabled(true);
+
+        int volume = mHdmiControlService.getAudioManager()
+                .getStreamVolume(AudioManager.STREAM_MUSIC);
+        boolean mute = mHdmiControlService.getAudioManager()
+                .isStreamMute(AudioManager.STREAM_MUSIC);
+        int maxVolume = mHdmiControlService.getAudioManager()
+                .getStreamMaxVolume(AudioManager.STREAM_MUSIC);
+        int scaledVolume = VolumeControlAction.scaleToCecVolume(volume, maxVolume);
+        HdmiCecMessage unexpected = HdmiCecMessageBuilder.buildReportAudioStatus(ADDR_AUDIO_SYSTEM,
+                ADDR_TV, scaledVolume, mute);
+
+        mNativeWrapper.clearResultMessages();
+        mHdmiCecLocalDeviceAudioSystem.reportAudioStatus(ADDR_TV);
+        mTestLooper.dispatchAll();
+
+        assertThat(mNativeWrapper.getResultMessages()).doesNotContain(unexpected);
+    }
 }
",112,0,"HdmiCecLocalDeviceAudioSystemTest::giveAudioStatus_volumeDisabled, HdmiCecLocalDeviceAudioSystemTest::reportAudioStatus_volumeEnabled, HdmiCecLocalDeviceAudioSystemTest::setUp, HdmiCecLocalDeviceAudioSystemTest::giveAudioStatus_volumeEnabled, HdmiCecLocalDeviceAudioSystemTest::reportAudioStatus_volumeDisabled"
310,dccbb024fd13bc8cb50fc46d73a38be3f4d6ddc0,HdmiCecLocalDevicePlaybackTest.java,ModificationType.MODIFY,"@@ -22,6 +22,7 @@ import static com.google.common.truth.Truth.assertThat;
 
 import android.os.Looper;
 import android.os.test.TestLooper;
+import android.view.KeyEvent;
 
 import androidx.test.InstrumentationRegistry;
 import androidx.test.filters.SmallTest;
@@ -148,4 +149,75 @@ public class HdmiCecLocalDevicePlaybackTest {
         mHdmiCecLocalDevicePlayback.onHotplug(0, false);
         assertThat(mWokenUp).isFalse();
     }
+
+    @Test
+    @Ignore(""b/151147315"")
+    public void sendVolumeKeyEvent_up_volumeEnabled() {
+        mHdmiControlService.setHdmiCecVolumeControlEnabled(true);
+        mHdmiCecLocalDevicePlayback.sendVolumeKeyEvent(KeyEvent.KEYCODE_VOLUME_UP, true);
+        mHdmiCecLocalDevicePlayback.sendVolumeKeyEvent(KeyEvent.KEYCODE_VOLUME_UP, false);
+
+        assertThat(hasSendKeyAction()).isTrue();
+    }
+
+    @Test
+    @Ignore(""b/151147315"")
+    public void sendVolumeKeyEvent_down_volumeEnabled() {
+        mHdmiControlService.setHdmiCecVolumeControlEnabled(true);
+        mHdmiCecLocalDevicePlayback.sendVolumeKeyEvent(KeyEvent.KEYCODE_VOLUME_DOWN, true);
+        mHdmiCecLocalDevicePlayback.sendVolumeKeyEvent(KeyEvent.KEYCODE_VOLUME_DOWN, false);
+
+        assertThat(hasSendKeyAction()).isTrue();
+    }
+
+    @Test
+    @Ignore(""b/151147315"")
+    public void sendVolumeKeyEvent_mute_volumeEnabled() {
+        mHdmiControlService.setHdmiCecVolumeControlEnabled(true);
+        mHdmiCecLocalDevicePlayback.sendVolumeKeyEvent(KeyEvent.KEYCODE_VOLUME_MUTE, true);
+        mHdmiCecLocalDevicePlayback.sendVolumeKeyEvent(KeyEvent.KEYCODE_VOLUME_MUTE, false);
+
+        assertThat(hasSendKeyAction()).isTrue();
+    }
+
+    @Test
+    @Ignore(""b/151147315"")
+    public void sendVolumeKeyEvent_up_volumeDisabled() {
+        mHdmiControlService.setHdmiCecVolumeControlEnabled(false);
+        mHdmiCecLocalDevicePlayback.sendVolumeKeyEvent(KeyEvent.KEYCODE_VOLUME_UP, true);
+        mHdmiCecLocalDevicePlayback.sendVolumeKeyEvent(KeyEvent.KEYCODE_VOLUME_UP, false);
+
+        assertThat(hasSendKeyAction()).isFalse();
+    }
+
+    @Test
+    @Ignore(""b/151147315"")
+    public void sendVolumeKeyEvent_down_volumeDisabled() {
+        mHdmiControlService.setHdmiCecVolumeControlEnabled(false);
+        mHdmiCecLocalDevicePlayback.sendVolumeKeyEvent(KeyEvent.KEYCODE_VOLUME_DOWN, true);
+        mHdmiCecLocalDevicePlayback.sendVolumeKeyEvent(KeyEvent.KEYCODE_VOLUME_DOWN, false);
+
+        assertThat(hasSendKeyAction()).isFalse();
+    }
+
+    @Test
+    @Ignore(""b/151147315"")
+    public void sendVolumeKeyEvent_mute_volumeDisabled() {
+        mHdmiControlService.setHdmiCecVolumeControlEnabled(false);
+        mHdmiCecLocalDevicePlayback.sendVolumeKeyEvent(KeyEvent.KEYCODE_VOLUME_MUTE, true);
+        mHdmiCecLocalDevicePlayback.sendVolumeKeyEvent(KeyEvent.KEYCODE_VOLUME_MUTE, false);
+
+        assertThat(hasSendKeyAction()).isFalse();
+    }
+
+    private boolean hasSendKeyAction() {
+        boolean match = false;
+        for (HdmiCecFeatureAction action : mHdmiCecLocalDevicePlayback.mActions) {
+            if (action instanceof SendKeyAction) {
+                match = true;
+                break;
+            }
+        }
+        return match;
+    }
 }
",72,0,"HdmiCecLocalDevicePlaybackTest::sendVolumeKeyEvent_up_volumeEnabled, HdmiCecLocalDevicePlaybackTest::hasSendKeyAction, HdmiCecLocalDevicePlaybackTest::sendVolumeKeyEvent_down_volumeDisabled, HdmiCecLocalDevicePlaybackTest::sendVolumeKeyEvent_up_volumeDisabled, HdmiCecLocalDevicePlaybackTest::sendVolumeKeyEvent_mute_volumeEnabled, HdmiCecLocalDevicePlaybackTest::sendVolumeKeyEvent_mute_volumeDisabled, HdmiCecLocalDevicePlaybackTest::sendVolumeKeyEvent_down_volumeEnabled"
311,dccbb024fd13bc8cb50fc46d73a38be3f4d6ddc0,HdmiCecLocalDeviceTest.java,ModificationType.MODIFY,"@@ -19,6 +19,7 @@ import static android.hardware.hdmi.HdmiDeviceInfo.DEVICE_TV;
 
 import static com.android.server.hdmi.Constants.ADDR_AUDIO_SYSTEM;
 import static com.android.server.hdmi.Constants.ADDR_BROADCAST;
+import static com.android.server.hdmi.Constants.ADDR_PLAYBACK_1;
 import static com.android.server.hdmi.Constants.ADDR_TV;
 import static com.android.server.hdmi.Constants.ADDR_UNREGISTERED;
 import static com.android.server.hdmi.Constants.MESSAGE_DEVICE_VENDOR_ID;
@@ -185,4 +186,64 @@ public class HdmiCecLocalDeviceTest {
                 HdmiCecMessageBuilder.buildStandby(ADDR_TV, ADDR_AUDIO_SYSTEM));
         assertTrue(mStandbyMessageReceived);
     }
+
+    @Test
+    public void handleUserControlPressed_volumeUp() {
+        mHdmiControlService.setHdmiCecVolumeControlEnabled(true);
+        boolean result = mHdmiLocalDevice.handleUserControlPressed(
+                HdmiCecMessageBuilder.buildUserControlPressed(ADDR_PLAYBACK_1, ADDR_TV,
+                        HdmiCecKeycode.CEC_KEYCODE_VOLUME_UP));
+
+        assertTrue(result);
+    }
+
+    @Test
+    public void handleUserControlPressed_volumeDown() {
+        mHdmiControlService.setHdmiCecVolumeControlEnabled(true);
+        boolean result = mHdmiLocalDevice.handleUserControlPressed(
+                HdmiCecMessageBuilder.buildUserControlPressed(ADDR_PLAYBACK_1, ADDR_TV,
+                        HdmiCecKeycode.CEC_KEYCODE_VOLUME_DOWN));
+
+        assertTrue(result);
+    }
+
+    @Test
+    public void handleUserControlPressed_volumeMute() {
+        mHdmiControlService.setHdmiCecVolumeControlEnabled(true);
+        boolean result = mHdmiLocalDevice.handleUserControlPressed(
+                HdmiCecMessageBuilder.buildUserControlPressed(ADDR_PLAYBACK_1, ADDR_TV,
+                        HdmiCecKeycode.CEC_KEYCODE_MUTE));
+
+        assertTrue(result);
+    }
+
+    @Test
+    public void handleUserControlPressed_volumeUp_disabled() {
+        mHdmiControlService.setHdmiCecVolumeControlEnabled(false);
+        boolean result = mHdmiLocalDevice.handleUserControlPressed(
+                HdmiCecMessageBuilder.buildUserControlPressed(ADDR_PLAYBACK_1, ADDR_TV,
+                        HdmiCecKeycode.CEC_KEYCODE_VOLUME_UP));
+
+        assertFalse(result);
+    }
+
+    @Test
+    public void handleUserControlPressed_volumeDown_disabled() {
+        mHdmiControlService.setHdmiCecVolumeControlEnabled(false);
+        boolean result = mHdmiLocalDevice.handleUserControlPressed(
+                HdmiCecMessageBuilder.buildUserControlPressed(ADDR_PLAYBACK_1, ADDR_TV,
+                        HdmiCecKeycode.CEC_KEYCODE_VOLUME_DOWN));
+
+        assertFalse(result);
+    }
+
+    @Test
+    public void handleUserControlPressed_volumeMute_disabled() {
+        mHdmiControlService.setHdmiCecVolumeControlEnabled(false);
+        boolean result = mHdmiLocalDevice.handleUserControlPressed(
+                HdmiCecMessageBuilder.buildUserControlPressed(ADDR_PLAYBACK_1, ADDR_TV,
+                        HdmiCecKeycode.CEC_KEYCODE_MUTE));
+
+        assertFalse(result);
+    }
 }
",61,0,"HdmiCecLocalDeviceTest::handleUserControlPressed_volumeMute_disabled, HdmiCecLocalDeviceTest::handleUserControlPressed_volumeUp_disabled, HdmiCecLocalDeviceTest::handleUserControlPressed_volumeUp, HdmiCecLocalDeviceTest::handleUserControlPressed_volumeDown, HdmiCecLocalDeviceTest::handleUserControlPressed_volumeDown_disabled, HdmiCecLocalDeviceTest::handleUserControlPressed_volumeMute"
312,dccbb024fd13bc8cb50fc46d73a38be3f4d6ddc0,HdmiControlServiceTest.java,ModificationType.MODIFY,"@@ -249,4 +249,13 @@ public class HdmiControlServiceTest {
         assertThat(mHdmiControlService.getPowerStatus()).isEqualTo(
                 HdmiControlManager.POWER_STATUS_STANDBY);
     }
+
+    @Test
+    public void setAndGetCecVolumeControlEnabled_isApi() {
+        mHdmiControlService.setHdmiCecVolumeControlEnabled(false);
+        assertThat(mHdmiControlService.isHdmiCecVolumeControlEnabled()).isFalse();
+
+        mHdmiControlService.setHdmiCecVolumeControlEnabled(true);
+        assertThat(mHdmiControlService.isHdmiCecVolumeControlEnabled()).isTrue();
+    }
 }
",9,0,HdmiControlServiceTest::setAndGetCecVolumeControlEnabled_isApi
313,c5bf1dde970782e741711d1179236e6dbbdcf43a,HdmiControlManager.java,ModificationType.MODIFY,"@@ -18,6 +18,7 @@ package android.hardware.hdmi;
 
 import static com.android.internal.os.RoSystemProperties.PROPERTY_HDMI_IS_DEVICE_HDMI_CEC_SWITCH;
 
+import android.annotation.CallbackExecutor;
 import android.annotation.IntDef;
 import android.annotation.NonNull;
 import android.annotation.Nullable;
@@ -30,6 +31,7 @@ import android.annotation.SystemApi;
 import android.annotation.SystemService;
 import android.content.Context;
 import android.content.pm.PackageManager;
+import android.os.Binder;
 import android.os.RemoteException;
 import android.os.SystemProperties;
 import android.util.ArrayMap;
@@ -38,6 +40,7 @@ import android.util.Log;
 import com.android.internal.util.Preconditions;
 
 import java.util.List;
+import java.util.concurrent.Executor;
 
 /**
  * The {@link HdmiControlManager} class is used to send HDMI control messages
@@ -768,6 +771,24 @@ public final class HdmiControlManager {
     private final ArrayMap<HdmiControlStatusChangeListener, IHdmiControlStatusChangeListener>
             mHdmiControlStatusChangeListeners = new ArrayMap<>();
 
+    /**
+     * Listener used to get the status of the HDMI CEC volume control feature (enabled/disabled).
+     * @hide
+     */
+    public interface HdmiCecVolumeControlFeatureListener {
+        /**
+         * Called when the HDMI Control (CEC) volume control feature is enabled/disabled.
+         *
+         * @param enabled status of HDMI CEC volume control feature
+         * @see {@link HdmiControlManager#setHdmiCecVolumeControlEnabled(boolean)} ()}
+         **/
+        void onHdmiCecVolumeControlFeature(boolean enabled);
+    }
+
+    private final ArrayMap<HdmiCecVolumeControlFeatureListener,
+            IHdmiCecVolumeControlFeatureListener>
+            mHdmiCecVolumeControlFeatureListeners = new ArrayMap<>();
+
     /**
      * Listener used to get vendor-specific commands.
      */
@@ -930,4 +951,76 @@ public final class HdmiControlManager {
         };
     }
 
+    /**
+     * Adds a listener to get informed of changes to the state of the HDMI CEC volume control
+     * feature.
+     *
+     * Upon adding a listener, the current state of the HDMI CEC volume control feature will be
+     * sent immediately.
+     *
+     * <p>To stop getting the notification,
+     * use {@link #removeHdmiCecVolumeControlFeatureListener(HdmiCecVolumeControlFeatureListener)}.
+     *
+     * @param listener {@link HdmiCecVolumeControlFeatureListener} instance
+     * @hide
+     * @see #removeHdmiCecVolumeControlFeatureListener(HdmiCecVolumeControlFeatureListener)
+     */
+    @RequiresPermission(android.Manifest.permission.HDMI_CEC)
+    public void addHdmiCecVolumeControlFeatureListener(@NonNull @CallbackExecutor Executor executor,
+            @NonNull HdmiCecVolumeControlFeatureListener listener) {
+        if (mService == null) {
+            Log.e(TAG, ""HdmiControlService is not available"");
+            return;
+        }
+        if (mHdmiCecVolumeControlFeatureListeners.containsKey(listener)) {
+            Log.e(TAG, ""listener is already registered"");
+            return;
+        }
+        IHdmiCecVolumeControlFeatureListener wrappedListener =
+                createHdmiCecVolumeControlFeatureListenerWrapper(executor, listener);
+        mHdmiCecVolumeControlFeatureListeners.put(listener, wrappedListener);
+        try {
+            mService.addHdmiCecVolumeControlFeatureListener(wrappedListener);
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    /**
+     * Removes a listener to stop getting informed of changes to the state of the HDMI CEC volume
+     * control feature.
+     *
+     * @param listener {@link HdmiCecVolumeControlFeatureListener} instance to be removed
+     * @hide
+     */
+    @RequiresPermission(android.Manifest.permission.HDMI_CEC)
+    public void removeHdmiCecVolumeControlFeatureListener(
+            HdmiCecVolumeControlFeatureListener listener) {
+        if (mService == null) {
+            Log.e(TAG, ""HdmiControlService is not available"");
+            return;
+        }
+        IHdmiCecVolumeControlFeatureListener wrappedListener =
+                mHdmiCecVolumeControlFeatureListeners.remove(listener);
+        if (wrappedListener == null) {
+            Log.e(TAG, ""tried to remove not-registered listener"");
+            return;
+        }
+        try {
+            mService.removeHdmiCecVolumeControlFeatureListener(wrappedListener);
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    private IHdmiCecVolumeControlFeatureListener createHdmiCecVolumeControlFeatureListenerWrapper(
+            Executor executor, final HdmiCecVolumeControlFeatureListener listener) {
+        return new android.hardware.hdmi.IHdmiCecVolumeControlFeatureListener.Stub() {
+            @Override
+            public void onHdmiCecVolumeControlFeature(boolean enabled) {
+                Binder.clearCallingIdentity();
+                executor.execute(() -> listener.onHdmiCecVolumeControlFeature(enabled));
+            }
+        };
+    }
 }
",93,0,"HdmiControlManager::removeHdmiCecVolumeControlFeatureListener, HdmiControlManager::createHdmiCecVolumeControlFeatureListenerWrapper, HdmiControlManager::addHdmiCecVolumeControlFeatureListener"
314,c5bf1dde970782e741711d1179236e6dbbdcf43a,HdmiAudioSystemClientTest.java,ModificationType.MODIFY,"@@ -363,6 +363,16 @@ public class HdmiAudioSystemClientTest {
         public boolean isHdmiCecVolumeControlEnabled() {
             return true;
         }
+
+        @Override
+        public void addHdmiCecVolumeControlFeatureListener(
+                IHdmiCecVolumeControlFeatureListener listener) {
+        }
+
+        @Override
+        public void removeHdmiCecVolumeControlFeatureListener(
+                IHdmiCecVolumeControlFeatureListener listener) {
+        }
     }
 
 }
",10,0,"HdmiAudioSystemClientTest::TestHdmiControlService::addHdmiCecVolumeControlFeatureListener, HdmiAudioSystemClientTest::TestHdmiControlService::removeHdmiCecVolumeControlFeatureListener"
315,c5bf1dde970782e741711d1179236e6dbbdcf43a,HdmiControlService.java,ModificationType.MODIFY,"@@ -40,6 +40,7 @@ import android.hardware.hdmi.HdmiControlManager;
 import android.hardware.hdmi.HdmiDeviceInfo;
 import android.hardware.hdmi.HdmiHotplugEvent;
 import android.hardware.hdmi.HdmiPortInfo;
+import android.hardware.hdmi.IHdmiCecVolumeControlFeatureListener;
 import android.hardware.hdmi.IHdmiControlCallback;
 import android.hardware.hdmi.IHdmiControlService;
 import android.hardware.hdmi.IHdmiControlStatusChangeListener;
@@ -62,6 +63,7 @@ import android.os.HandlerThread;
 import android.os.IBinder;
 import android.os.Looper;
 import android.os.PowerManager;
+import android.os.RemoteCallbackList;
 import android.os.RemoteException;
 import android.os.SystemClock;
 import android.os.SystemProperties;
@@ -261,6 +263,11 @@ public class HdmiControlService extends SystemService {
     private final ArrayList<HdmiControlStatusChangeListenerRecord>
             mHdmiControlStatusChangeListenerRecords = new ArrayList<>();
 
+    // List of records for HDMI control volume control status change listener for death monitoring.
+    @GuardedBy(""mLock"")
+    private final RemoteCallbackList<IHdmiCecVolumeControlFeatureListener>
+            mHdmiCecVolumeControlFeatureListenerRecords = new RemoteCallbackList<>();
+
     // List of records for hotplug event listener to handle the the caller killed in action.
     @GuardedBy(""mLock"")
     private final ArrayList<HotplugEventListenerRecord> mHotplugEventListenerRecords =
@@ -1717,6 +1724,21 @@ public class HdmiControlService extends SystemService {
             HdmiControlService.this.removeHdmiControlStatusChangeListener(listener);
         }
 
+        @Override
+        public void addHdmiCecVolumeControlFeatureListener(
+                final IHdmiCecVolumeControlFeatureListener listener) {
+            enforceAccessPermission();
+            HdmiControlService.this.addHdmiCecVolumeControlFeatureListener(listener);
+        }
+
+        @Override
+        public void removeHdmiCecVolumeControlFeatureListener(
+                final IHdmiCecVolumeControlFeatureListener listener) {
+            enforceAccessPermission();
+            HdmiControlService.this.removeHdmiControlVolumeControlStatusChangeListener(listener);
+        }
+
+
         @Override
         public void addHotplugEventListener(final IHdmiHotplugEventListener listener) {
             enforceAccessPermission();
@@ -2296,6 +2318,33 @@ public class HdmiControlService extends SystemService {
         }
     }
 
+    @VisibleForTesting
+    void addHdmiCecVolumeControlFeatureListener(
+            final IHdmiCecVolumeControlFeatureListener listener) {
+        mHdmiCecVolumeControlFeatureListenerRecords.register(listener);
+
+        runOnServiceThread(new Runnable() {
+            @Override
+            public void run() {
+                // Return the current status of mHdmiCecVolumeControlEnabled;
+                synchronized (mLock) {
+                    try {
+                        listener.onHdmiCecVolumeControlFeature(mHdmiCecVolumeControlEnabled);
+                    } catch (RemoteException e) {
+                        Slog.e(TAG, ""Failed to report HdmiControlVolumeControlStatusChange: ""
+                                + mHdmiCecVolumeControlEnabled, e);
+                    }
+                }
+            }
+        });
+    }
+
+    @VisibleForTesting
+    void removeHdmiControlVolumeControlStatusChangeListener(
+            final IHdmiCecVolumeControlFeatureListener listener) {
+        mHdmiCecVolumeControlFeatureListenerRecords.unregister(listener);
+    }
+
     private void addHotplugEventListener(final IHdmiHotplugEventListener listener) {
         final HotplugEventListenerRecord record = new HotplugEventListenerRecord(listener);
         try {
@@ -2569,6 +2618,19 @@ public class HdmiControlService extends SystemService {
         }
     }
 
+    private void announceHdmiCecVolumeControlFeatureChange(boolean isEnabled) {
+        assertRunOnServiceThread();
+        mHdmiCecVolumeControlFeatureListenerRecords.broadcast(listener -> {
+            try {
+                listener.onHdmiCecVolumeControlFeature(isEnabled);
+            } catch (RemoteException e) {
+                Slog.e(TAG,
+                        ""Failed to report HdmiControlVolumeControlStatusChange: ""
+                                + isEnabled);
+            }
+        });
+    }
+
     public HdmiCecLocalDeviceTv tv() {
         return (HdmiCecLocalDeviceTv) mCecController.getLocalDevice(HdmiDeviceInfo.DEVICE_TV);
     }
@@ -2906,6 +2968,7 @@ public class HdmiControlService extends SystemService {
                         isHdmiCecVolumeControlEnabled);
             }
         }
+        announceHdmiCecVolumeControlFeatureChange(isHdmiCecVolumeControlEnabled);
     }
 
     boolean isHdmiCecVolumeControlEnabled() {
",63,0,"HdmiControlService::setHdmiCecVolumeControlEnabled, HdmiControlService::BinderService::removeHdmiCecVolumeControlFeatureListener, HdmiControlService::announceHdmiCecVolumeControlFeatureChange, HdmiControlService::removeHdmiControlVolumeControlStatusChangeListener, HdmiControlService::addHdmiCecVolumeControlFeatureListener, HdmiControlService::BinderService::addHdmiCecVolumeControlFeatureListener"
316,c5bf1dde970782e741711d1179236e6dbbdcf43a,HdmiControlServiceTest.java,ModificationType.MODIFY,"@@ -33,6 +33,7 @@ import android.content.Context;
 import android.content.ContextWrapper;
 import android.hardware.hdmi.HdmiControlManager;
 import android.hardware.hdmi.HdmiPortInfo;
+import android.hardware.hdmi.IHdmiCecVolumeControlFeatureListener;
 import android.os.IPowerManager;
 import android.os.Looper;
 import android.os.PowerManager;
@@ -258,4 +259,89 @@ public class HdmiControlServiceTest {
         mHdmiControlService.setHdmiCecVolumeControlEnabled(true);
         assertThat(mHdmiControlService.isHdmiCecVolumeControlEnabled()).isTrue();
     }
+
+    @Test
+    public void addHdmiCecVolumeControlFeatureListener_emitsCurrentState_enabled() {
+        mHdmiControlService.setHdmiCecVolumeControlEnabled(true);
+        VolumeControlFeatureCallback callback = new VolumeControlFeatureCallback();
+
+        mHdmiControlService.addHdmiCecVolumeControlFeatureListener(callback);
+        mTestLooper.dispatchAll();
+
+        assertThat(callback.mCallbackReceived).isTrue();
+        assertThat(callback.mVolumeControlEnabled).isTrue();
+    }
+
+    @Test
+    public void addHdmiCecVolumeControlFeatureListener_emitsCurrentState_disabled() {
+        mHdmiControlService.setHdmiCecVolumeControlEnabled(false);
+        VolumeControlFeatureCallback callback = new VolumeControlFeatureCallback();
+
+        mHdmiControlService.addHdmiCecVolumeControlFeatureListener(callback);
+        mTestLooper.dispatchAll();
+
+        assertThat(callback.mCallbackReceived).isTrue();
+        assertThat(callback.mVolumeControlEnabled).isFalse();
+    }
+
+    @Test
+    public void addHdmiCecVolumeControlFeatureListener_notifiesStateUpdate() {
+        mHdmiControlService.setHdmiCecVolumeControlEnabled(false);
+        VolumeControlFeatureCallback callback = new VolumeControlFeatureCallback();
+
+        mHdmiControlService.addHdmiCecVolumeControlFeatureListener(callback);
+
+        mHdmiControlService.setHdmiCecVolumeControlEnabled(true);
+        mTestLooper.dispatchAll();
+
+        assertThat(callback.mCallbackReceived).isTrue();
+        assertThat(callback.mVolumeControlEnabled).isTrue();
+    }
+
+    @Test
+    public void addHdmiCecVolumeControlFeatureListener_honorsUnregistration() {
+        mHdmiControlService.setHdmiCecVolumeControlEnabled(false);
+        VolumeControlFeatureCallback callback = new VolumeControlFeatureCallback();
+
+        mHdmiControlService.addHdmiCecVolumeControlFeatureListener(callback);
+        mTestLooper.dispatchAll();
+
+        mHdmiControlService.removeHdmiControlVolumeControlStatusChangeListener(callback);
+        mHdmiControlService.setHdmiCecVolumeControlEnabled(true);
+        mTestLooper.dispatchAll();
+
+        assertThat(callback.mCallbackReceived).isTrue();
+        assertThat(callback.mVolumeControlEnabled).isFalse();
+    }
+
+    @Test
+    public void addHdmiCecVolumeControlFeatureListener_notifiesStateUpdate_multiple() {
+        mHdmiControlService.setHdmiCecVolumeControlEnabled(false);
+        VolumeControlFeatureCallback callback1 = new VolumeControlFeatureCallback();
+        VolumeControlFeatureCallback callback2 = new VolumeControlFeatureCallback();
+
+        mHdmiControlService.addHdmiCecVolumeControlFeatureListener(callback1);
+        mHdmiControlService.addHdmiCecVolumeControlFeatureListener(callback2);
+
+
+        mHdmiControlService.setHdmiCecVolumeControlEnabled(true);
+        mTestLooper.dispatchAll();
+
+        assertThat(callback1.mCallbackReceived).isTrue();
+        assertThat(callback2.mCallbackReceived).isTrue();
+        assertThat(callback1.mVolumeControlEnabled).isTrue();
+        assertThat(callback2.mVolumeControlEnabled).isTrue();
+    }
+
+    private static class VolumeControlFeatureCallback extends
+            IHdmiCecVolumeControlFeatureListener.Stub {
+        boolean mCallbackReceived = false;
+        boolean mVolumeControlEnabled = false;
+
+        @Override
+        public void onHdmiCecVolumeControlFeature(boolean enabled) throws RemoteException {
+            this.mCallbackReceived = true;
+            this.mVolumeControlEnabled = enabled;
+        }
+    }
 }
",86,0,"HdmiControlServiceTest::addHdmiCecVolumeControlFeatureListener_emitsCurrentState_enabled, HdmiControlServiceTest::addHdmiCecVolumeControlFeatureListener_notifiesStateUpdate, HdmiControlServiceTest::addHdmiCecVolumeControlFeatureListener_honorsUnregistration, HdmiControlServiceTest::addHdmiCecVolumeControlFeatureListener_notifiesStateUpdate_multiple, HdmiControlServiceTest::VolumeControlFeatureCallback::onHdmiCecVolumeControlFeature, HdmiControlServiceTest::addHdmiCecVolumeControlFeatureListener_emitsCurrentState_disabled"
317,c247463592a1457e6bf182577406a5c41574904a,HdmiControlService.java,ModificationType.MODIFY,"@@ -3023,7 +3023,7 @@ public class HdmiControlService extends SystemService {
             return;
         }
 
-        setHdmiCecVolumeControlEnabled(false);
+        mHdmiCecVolumeControlEnabled = false;
         // Call the vendor handler before the service is disabled.
         invokeVendorCommandListenersOnControlStateChanged(false,
                 HdmiControlManager.CONTROL_STATE_CHANGED_REASON_SETTING);
",1,1,HdmiControlService::setControlEnabled
318,c247463592a1457e6bf182577406a5c41574904a,HdmiControlServiceTest.java,ModificationType.MODIFY,"@@ -260,6 +260,19 @@ public class HdmiControlServiceTest {
         assertThat(mHdmiControlService.isHdmiCecVolumeControlEnabled()).isTrue();
     }
 
+    @Test
+    public void disableAndReenableCec_volumeControlReturnsToOriginalValue() {
+        boolean volumeControlEnabled = true;
+        mHdmiControlService.setHdmiCecVolumeControlEnabled(volumeControlEnabled);
+
+        mHdmiControlService.setControlEnabled(false);
+        assertThat(mHdmiControlService.isHdmiCecVolumeControlEnabled()).isFalse();
+
+        mHdmiControlService.setControlEnabled(true);
+        assertThat(mHdmiControlService.isHdmiCecVolumeControlEnabled()).isEqualTo(
+                volumeControlEnabled);
+    }
+
     @Test
     public void addHdmiCecVolumeControlFeatureListener_emitsCurrentState_enabled() {
         mHdmiControlService.setHdmiCecVolumeControlEnabled(true);
",13,0,HdmiControlServiceTest::disableAndReenableCec_volumeControlReturnsToOriginalValue
319,90a5c10361b1b2fc89015bb16b6b7cbe8fce8e0e,AudioService.java,ModificationType.MODIFY,"@@ -1976,8 +1976,8 @@ public class AudioService extends IAudioService.Stub
                         if (keyCode != KeyEvent.KEYCODE_UNKNOWN) {
                             final long ident = Binder.clearCallingIdentity();
                             try {
-                                mHdmiPlaybackClient.sendKeyEvent(keyCode, true);
-                                mHdmiPlaybackClient.sendKeyEvent(keyCode, false);
+                                mHdmiPlaybackClient.sendVolumeKeyEvent(keyCode, true);
+                                mHdmiPlaybackClient.sendVolumeKeyEvent(keyCode, false);
                             } finally {
                                 Binder.restoreCallingIdentity(ident);
                             }
",2,2,AudioService::adjustStreamVolume
320,917cfdf91fae9b136526b1ce54e79ce07f322658,AudioService.java,ModificationType.MODIFY,"@@ -1663,6 +1663,58 @@ public class AudioService extends IAudioService.Stub
     ///////////////////////////////////////////////////////////////////////////
     // IPC methods
     ///////////////////////////////////////////////////////////////////////////
+    /** Indicates no special treatment in the handling of the volume adjustement */
+    private static final int VOL_ADJUST_NORMAL = 0;
+    /** Indicates the start of a volume adjustement */
+    private static final int VOL_ADJUST_START = 1;
+    /** Indicates the end of a volume adjustment */
+    private static final int VOL_ADJUST_END = 2;
+
+    // pre-condition: event.getKeyCode() is one of KeyEvent.KEYCODE_VOLUME_UP,
+    //                                   KeyEvent.KEYCODE_VOLUME_DOWN, KeyEvent.KEYCODE_VOLUME_MUTE
+    public void handleVolumeKey(@NonNull KeyEvent event, boolean isOnTv,
+            @NonNull String callingPackage, @NonNull String caller) {
+        int keyEventMode = VOL_ADJUST_NORMAL;
+        if (isOnTv) {
+            if (event.getAction() == KeyEvent.ACTION_DOWN) {
+                keyEventMode = VOL_ADJUST_START;
+            } else { // may catch more than ACTION_UP, but will end vol adjustement
+                // the vol key is either released (ACTION_UP), or multiple keys are pressed
+                // (ACTION_MULTIPLE) and we don't know what to do for volume control on CEC, end
+                // the repeated volume adjustement
+                keyEventMode = VOL_ADJUST_END;
+            }
+        } else if (event.getAction() != KeyEvent.ACTION_DOWN) {
+            return;
+        }
+
+        int flags = AudioManager.FLAG_SHOW_UI | AudioManager.FLAG_PLAY_SOUND
+                | AudioManager.FLAG_FROM_KEY;
+
+        switch (event.getKeyCode()) {
+            case KeyEvent.KEYCODE_VOLUME_UP:
+                    adjustSuggestedStreamVolume(AudioManager.ADJUST_RAISE,
+                            AudioManager.USE_DEFAULT_STREAM_TYPE, flags, callingPackage, caller,
+                            Binder.getCallingUid(), keyEventMode);
+                break;
+            case KeyEvent.KEYCODE_VOLUME_DOWN:
+                    adjustSuggestedStreamVolume(AudioManager.ADJUST_LOWER,
+                            AudioManager.USE_DEFAULT_STREAM_TYPE, flags, callingPackage, caller,
+                            Binder.getCallingUid(), keyEventMode);
+                break;
+            case KeyEvent.KEYCODE_VOLUME_MUTE:
+                if (event.getRepeatCount() == 0) {
+                    adjustSuggestedStreamVolume(AudioManager.ADJUST_TOGGLE_MUTE,
+                            AudioManager.USE_DEFAULT_STREAM_TYPE, flags, callingPackage, caller,
+                            Binder.getCallingUid(), VOL_ADJUST_NORMAL);
+                }
+                break;
+            default:
+                Log.e(TAG, ""Invalid key code "" + event.getKeyCode() + "" sent by "" + callingPackage);
+                return; // not needed but added if code gets added below this switch statement
+        }
+    }
+
     /** @see AudioManager#adjustVolume(int, int) */
     public void adjustSuggestedStreamVolume(int direction, int suggestedStreamType, int flags,
             String callingPackage, String caller) {
@@ -1676,12 +1728,12 @@ public class AudioService extends IAudioService.Stub
                     extVolCtlr, 0 /*delay*/);
         } else {
             adjustSuggestedStreamVolume(direction, suggestedStreamType, flags, callingPackage,
-                    caller, Binder.getCallingUid());
+                    caller, Binder.getCallingUid(), VOL_ADJUST_NORMAL);
         }
     }
 
     private void adjustSuggestedStreamVolume(int direction, int suggestedStreamType, int flags,
-            String callingPackage, String caller, int uid) {
+            String callingPackage, String caller, int uid, int keyEventMode) {
         if (DEBUG_VOL) Log.d(TAG, ""adjustSuggestedStreamVolume() stream="" + suggestedStreamType
                 + "", flags="" + flags + "", caller="" + caller
                 + "", volControlStream="" + mVolumeControlStream
@@ -1735,7 +1787,8 @@ public class AudioService extends IAudioService.Stub
             if (DEBUG_VOL) Log.d(TAG, ""Volume controller suppressed adjustment"");
         }
 
-        adjustStreamVolume(streamType, direction, flags, callingPackage, caller, uid);
+        adjustStreamVolume(streamType, direction, flags, callingPackage, caller, uid,
+                keyEventMode);
     }
 
     /** @see AudioManager#adjustStreamVolume(int, int, int) */
@@ -1749,11 +1802,11 @@ public class AudioService extends IAudioService.Stub
         sVolumeLogger.log(new VolumeEvent(VolumeEvent.VOL_ADJUST_STREAM_VOL, streamType,
                 direction/*val1*/, flags/*val2*/, callingPackage));
         adjustStreamVolume(streamType, direction, flags, callingPackage, callingPackage,
-                Binder.getCallingUid());
+                Binder.getCallingUid(), VOL_ADJUST_NORMAL);
     }
 
     protected void adjustStreamVolume(int streamType, int direction, int flags,
-            String callingPackage, String caller, int uid) {
+            String callingPackage, String caller, int uid, int keyEventMode) {
         if (mUseFixedVolume) {
             return;
         }
@@ -1976,8 +2029,21 @@ public class AudioService extends IAudioService.Stub
                         if (keyCode != KeyEvent.KEYCODE_UNKNOWN) {
                             final long ident = Binder.clearCallingIdentity();
                             try {
-                                mHdmiPlaybackClient.sendVolumeKeyEvent(keyCode, true);
-                                mHdmiPlaybackClient.sendVolumeKeyEvent(keyCode, false);
+                                final long time = java.lang.System.currentTimeMillis();
+                                switch (keyEventMode) {
+                                    case VOL_ADJUST_NORMAL:
+                                        mHdmiPlaybackClient.sendVolumeKeyEvent(keyCode, true);
+                                        mHdmiPlaybackClient.sendVolumeKeyEvent(keyCode, false);
+                                        break;
+                                    case VOL_ADJUST_START:
+                                        mHdmiPlaybackClient.sendVolumeKeyEvent(keyCode, true);
+                                        break;
+                                    case VOL_ADJUST_END:
+                                        mHdmiPlaybackClient.sendVolumeKeyEvent(keyCode, false);
+                                        break;
+                                    default:
+                                        Log.e(TAG, ""Invalid keyEventMode "" + keyEventMode);
+                                }
                             } finally {
                                 Binder.restoreCallingIdentity(ident);
                             }
@@ -6795,7 +6861,7 @@ public class AudioService extends IAudioService.Stub
             // direction and stream type swap here because the public
             // adjustSuggested has a different order than the other methods.
             adjustSuggestedStreamVolume(direction, streamType, flags, callingPackage,
-                    callingPackage, uid);
+                    callingPackage, uid, VOL_ADJUST_NORMAL);
         }
 
         @Override
@@ -6807,7 +6873,7 @@ public class AudioService extends IAudioService.Stub
                         .append("" uid:"").append(uid).toString()));
             }
             adjustStreamVolume(streamType, direction, flags, callingPackage,
-                    callingPackage, uid);
+                    callingPackage, uid, VOL_ADJUST_NORMAL);
         }
 
         @Override
",75,9,"AudioService::adjustSuggestedStreamVolume, AudioService::handleVolumeKey, AudioService::adjustSuggestedStreamVolume, AudioService::AudioServiceInternal::adjustStreamVolumeForUid, AudioService::adjustStreamVolume, AudioService::AudioServiceInternal::adjustSuggestedStreamVolumeForUid, AudioService::adjustStreamVolume, AudioService::adjustSuggestedStreamVolume, AudioService::adjustStreamVolume"
321,917cfdf91fae9b136526b1ce54e79ce07f322658,PhoneWindowManager.java,ModificationType.MODIFY,"@@ -5014,6 +5014,8 @@ public class PhoneWindowManager implements WindowManagerPolicy {
         return false;
     }
 
+    // pre-condition: event.getKeyCode() is one of KeyEvent.KEYCODE_VOLUME_UP,
+    //                                   KeyEvent.KEYCODE_VOLUME_DOWN, KeyEvent.KEYCODE_VOLUME_MUTE
     private void dispatchDirectAudioEvent(KeyEvent event) {
         // When System Audio Mode is off, volume keys received by AVR can be either consumed by AVR
         // or forwarded to the TV. It's up to Amplifier manufacturers implementation.
@@ -5028,42 +5030,12 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                 return;
             }
         }
-        if (event.getAction() != KeyEvent.ACTION_DOWN) {
-            return;
-        }
-        int keyCode = event.getKeyCode();
-        int flags = AudioManager.FLAG_SHOW_UI | AudioManager.FLAG_PLAY_SOUND
-                | AudioManager.FLAG_FROM_KEY;
-        String pkgName = mContext.getOpPackageName();
-
-        switch (keyCode) {
-            case KeyEvent.KEYCODE_VOLUME_UP:
-                try {
-                    getAudioService().adjustSuggestedStreamVolume(AudioManager.ADJUST_RAISE,
-                            AudioManager.USE_DEFAULT_STREAM_TYPE, flags, pkgName, TAG);
-                } catch (Exception e) {
-                    Log.e(TAG, ""Error dispatching volume up in dispatchTvAudioEvent."", e);
-                }
-                break;
-            case KeyEvent.KEYCODE_VOLUME_DOWN:
-                try {
-                    getAudioService().adjustSuggestedStreamVolume(AudioManager.ADJUST_LOWER,
-                            AudioManager.USE_DEFAULT_STREAM_TYPE, flags, pkgName, TAG);
-                } catch (Exception e) {
-                    Log.e(TAG, ""Error dispatching volume down in dispatchTvAudioEvent."", e);
-                }
-                break;
-            case KeyEvent.KEYCODE_VOLUME_MUTE:
-                try {
-                    if (event.getRepeatCount() == 0) {
-                        getAudioService().adjustSuggestedStreamVolume(
-                                AudioManager.ADJUST_TOGGLE_MUTE,
-                                AudioManager.USE_DEFAULT_STREAM_TYPE, flags, pkgName, TAG);
-                    }
-                } catch (Exception e) {
-                    Log.e(TAG, ""Error dispatching mute in dispatchTvAudioEvent."", e);
-                }
-                break;
+        try {
+            getAudioService().handleVolumeKey(event, mUseTvRouting,
+                    mContext.getOpPackageName(), TAG);
+        } catch (Exception e) {
+            Log.e(TAG, ""Error dispatching volume key in handleVolumeKey for event:""
+                    + event, e);
         }
     }
 
",8,36,PhoneWindowManager::dispatchDirectAudioEvent
322,1d72978514e54a02e8f72deec3b3e49a3caa6c17,PhoneWindowManager.java,ModificationType.MODIFY,"@@ -5264,6 +5264,12 @@ public class PhoneWindowManager implements WindowManagerPolicy {
     private void wakeUpFromPowerKey(long eventTime) {
         wakeUp(eventTime, mAllowTheaterModeWakeFromPowerKey,
                 PowerManager.WAKE_REASON_POWER_BUTTON, ""android.policy:POWER"");
+
+        // Turn on the connected TV and switch HDMI input if we're a HDMI playback device.
+        final HdmiControl hdmiControl = getHdmiControl();
+        if (hdmiControl != null) {
+            hdmiControl.turnOnTv();
+        }
     }
 
     private boolean wakeUp(long wakeTime, boolean wakeInTheaterMode, @WakeReason int reason,
",6,0,PhoneWindowManager::wakeUpFromPowerKey
323,a82d1f6a2b5af75b7a9dd178cc069e934a81c533,PhoneWindowManager.java,ModificationType.MODIFY,"@@ -5264,12 +5264,6 @@ public class PhoneWindowManager implements WindowManagerPolicy {
     private void wakeUpFromPowerKey(long eventTime) {
         wakeUp(eventTime, mAllowTheaterModeWakeFromPowerKey,
                 PowerManager.WAKE_REASON_POWER_BUTTON, ""android.policy:POWER"");
-
-        // Turn on the connected TV and switch HDMI input if we're a HDMI playback device.
-        final HdmiControl hdmiControl = getHdmiControl();
-        if (hdmiControl != null) {
-            hdmiControl.turnOnTv();
-        }
     }
 
     private boolean wakeUp(long wakeTime, boolean wakeInTheaterMode, @WakeReason int reason,
@@ -5294,6 +5288,12 @@ public class PhoneWindowManager implements WindowManagerPolicy {
         } else {
             mPowerManager.wakeUp(wakeTime, reason, details);
         }
+
+        // Turn on the connected TV and switch HDMI input if we're a HDMI playback device.
+        final HdmiControl hdmiControl = getHdmiControl();
+        if (hdmiControl != null) {
+            hdmiControl.turnOnTv();
+        }
         return true;
     }
 
",6,6,"PhoneWindowManager::wakeUpFromPowerKey, PhoneWindowManager::wakeUp"
324,8de96493d9838406c0ded5f1ccf71c1ee6977967,TaskPositioner.java,ModificationType.MODIFY,"@@ -351,7 +351,9 @@ class TaskPositioner implements IBinder.DeathRecipient {
         }
         mDisplayContent.resumeRotationLocked();
         mDisplayContent = null;
-        mClientCallback.unlinkToDeath(this, 0 /* flags */);
+        if (mClientCallback != null) {
+            mClientCallback.unlinkToDeath(this, 0 /* flags */);
+        }
     }
 
     void startDrag(WindowState win, boolean resize, boolean preserveOrientation, float startX,
",3,1,TaskPositioner::unregister
325,8de96493d9838406c0ded5f1ccf71c1ee6977967,TaskPositioningControllerTests.java,ModificationType.MODIFY,"@@ -123,13 +123,7 @@ public class TaskPositioningControllerTests extends WindowTestsBase {
             assertNull(mTarget.getDragWindowHandleLocked());
         }
 
-        final DisplayContent content = mock(DisplayContent.class);
-        when(content.findTaskForResizePoint(anyInt(), anyInt())).thenReturn(mWindow.getTask());
-        assertNotNull(mWindow.getTask().getTopVisibleAppMainWindow());
-
-        mTarget.handleTapOutsideTask(content, 0, 0);
-        // Wait until the looper processes finishTaskPositioning.
-        assertTrue(mWm.mH.runWithScissors(() -> { }, TIMEOUT_MS));
+        triggerHandleTapOutsideTask();
 
         synchronized (mWm.mGlobalLock) {
             assertTrue(mTarget.isPositioningLocked());
@@ -143,4 +137,32 @@ public class TaskPositioningControllerTests extends WindowTestsBase {
         assertFalse(mTarget.isPositioningLocked());
         assertNull(mTarget.getDragWindowHandleLocked());
     }
+
+    @Test
+    public void testHandleTapOutsideTaskWithTransferTouchFocusFailed() {
+        when(mWm.mInputManager.transferTouchFocus(
+                any(InputChannel.class),
+                any(InputChannel.class))).thenReturn(false);
+        synchronized (mWm.mGlobalLock) {
+            assertFalse(mTarget.isPositioningLocked());
+            assertNull(mTarget.getDragWindowHandleLocked());
+        }
+
+        triggerHandleTapOutsideTask();
+
+        synchronized (mWm.mGlobalLock) {
+            assertFalse(mTarget.isPositioningLocked());
+            assertNull(mTarget.getDragWindowHandleLocked());
+        }
+    }
+
+    private void triggerHandleTapOutsideTask() {
+        final DisplayContent content = mock(DisplayContent.class);
+        when(content.findTaskForResizePoint(anyInt(), anyInt())).thenReturn(mWindow.getTask());
+        assertNotNull(mWindow.getTask().getTopVisibleAppMainWindow());
+
+        mTarget.handleTapOutsideTask(content, 0, 0);
+        // Wait until the looper processes finishTaskPositioning.
+        assertTrue(mWm.mH.runWithScissors(() -> { }, TIMEOUT_MS));
+    }
 }
",29,7,"TaskPositioningControllerTests::testHandleTapOutsideTask, TaskPositioningControllerTests::triggerHandleTapOutsideTask, TaskPositioningControllerTests::testHandleTapOutsideTaskWithTransferTouchFocusFailed"
326,0d4186c1ff41d534b0a563304f2ffe9923498088,InputMonitor.java,ModificationType.MODIFY,"@@ -321,7 +321,11 @@ final class InputMonitor {
     }
 
     void updateInputWindowsImmediately() {
-        if (mUpdateInputWindowsPending) {
+        updateInputWindowsImmediately(false);
+    }
+
+    void updateInputWindowsImmediately(boolean ignorePending) {
+        if (ignorePending || mUpdateInputWindowsPending) {
             mApplyImmediately = true;
             mUpdateInputWindows.run();
             mApplyImmediately = false;
",5,1,"InputMonitor::updateInputWindowsImmediately, InputMonitor::updateInputWindowsImmediately"
327,0d4186c1ff41d534b0a563304f2ffe9923498088,TaskPositioner.java,ModificationType.MODIFY,"@@ -308,7 +308,11 @@ class TaskPositioner implements IBinder.DeathRecipient {
         mDisplayContent.pauseRotationLocked();
 
         // Notify InputMonitor to take mDragWindowHandle.
-        mDisplayContent.getInputMonitor().updateInputWindowsImmediately();
+        // We must add mDragWindowHandle to InputManager immediately although
+        // there is pending for updateInputWindows. Otherwise, the
+        // InputManager.transferTouchFocus will fail because of not-found
+        // mDragWindowHandle(to window).
+        mDisplayContent.getInputMonitor().updateInputWindowsImmediately(true);
         new SurfaceControl.Transaction().syncInputWindows().apply();
 
         mSideMargin = dipToPixel(SIDE_MARGIN_DIP, mDisplayMetrics);
",5,1,TaskPositioner::register
328,4920fca12d39a1948b6052f194172b79ad72c2d8,CallLog.java,ModificationType.MODIFY,"@@ -100,6 +100,13 @@ public class CallLog {
          */
         public static final String LIMIT_PARAM_KEY = ""limit"";
 
+        /**
+         * Form of {@link #CONTENT_URI} which limits the query results to a single result.
+         */
+        private static final Uri CONTENT_URI_LIMIT_1 = CONTENT_URI.buildUpon()
+                .appendQueryParameter(LIMIT_PARAM_KEY, ""1"")
+                .build();
+
         /**
          * Query parameter used to specify the starting record to return.
          * <p>
@@ -931,11 +938,11 @@ public class CallLog {
             Cursor c = null;
             try {
                 c = resolver.query(
-                    CONTENT_URI,
+                    CONTENT_URI_LIMIT_1,
                     new String[] {NUMBER},
                     TYPE + "" = "" + OUTGOING_TYPE,
                     null,
-                    DEFAULT_SORT_ORDER + "" LIMIT 1"");
+                    DEFAULT_SORT_ORDER);
                 if (c == null || !c.moveToFirst()) {
                     return """";
                 }
",9,2,CallLog::Calls::getLastOutgoingCall
329,b32281563c9ff5d0de46fa175e13453424eb02b7,VolumeDialogImpl.java,ModificationType.MODIFY,"@@ -403,8 +403,7 @@ public class VolumeDialogImpl implements VolumeDialog,
                 if (mVolumePanelOnLeft != volumePanelOnLeft) {
                     mVolumePanelOnLeft = volumePanelOnLeft;
                     mHandler.post(() -> {
-                        // Trigger panel rebuild on next show
-                        mConfigChanged = true;
+                        mControllerCallbackH.onConfigurationChanged();
                     });
                 }
             }
",1,2,VolumeDialogImpl::Tunable
330,cceffef44a297cafc671590fb541f5c5171d6ee6,AbstractBatteryStatusPreferenceController.java,ModificationType.ADD,"@@ -0,0 +1,157 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.settingslib.deviceinfo;
+
+import androidx.annotation.VisibleForTesting;
+import androidx.preference.Preference;
+import androidx.preference.PreferenceScreen;
+
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.os.BatteryManager;
+import android.os.Handler;
+import android.os.Message;
+import android.os.SystemClock;
+import android.text.format.DateUtils;
+
+import com.android.settingslib.core.AbstractPreferenceController;
+import com.android.settingslib.core.lifecycle.Lifecycle;
+import com.android.settingslib.core.lifecycle.LifecycleObserver;
+import com.android.settingslib.core.lifecycle.events.OnStart;
+import com.android.settingslib.core.lifecycle.events.OnStop;
+import com.android.settingslib.R;
+
+import java.lang.ref.WeakReference;
+
+/**
+ * Preference controller for battery status
+ */
+public abstract class AbstractBatteryStatusPreferenceController extends AbstractPreferenceController
+        implements LifecycleObserver, OnStart, OnStop {
+
+    @VisibleForTesting
+    static final String KEY_BATTERY_STATUS = ""battery_status"";
+    private static final int EVENT_UPDATE_BATTERY = 700;
+
+    private Preference mBatteryStatus;
+    private Handler mHandler;
+    private Context mContext;
+
+    public AbstractBatteryStatusPreferenceController(Context context, Lifecycle lifecycle) {
+        super(context);
+	mContext = context;
+        if (lifecycle != null) {
+            lifecycle.addObserver(this);
+        }
+    }
+
+    @Override
+    public void onStart() {
+        getHandler().sendEmptyMessage(EVENT_UPDATE_BATTERY);
+    }
+
+    @Override
+    public void onStop() {
+        getHandler().removeMessages(EVENT_UPDATE_BATTERY);
+    }
+
+    @Override
+    public boolean isAvailable() {
+        Intent intent = mContext.registerReceiver(null,
+                new IntentFilter(Intent.ACTION_BATTERY_CHANGED));
+
+        return intent.getBooleanExtra(BatteryManager.EXTRA_PRESENT, false);
+    }
+
+    @Override
+    public String getPreferenceKey() {
+        return KEY_BATTERY_STATUS;
+    }
+
+    @Override
+    public void displayPreference(PreferenceScreen screen) {
+        super.displayPreference(screen);
+        mBatteryStatus = screen.findPreference(KEY_BATTERY_STATUS);
+        updateBattery();
+    }
+
+    private Handler getHandler() {
+        if (mHandler == null) {
+            mHandler = new MyHandler(this);
+        }
+        return mHandler;
+    }
+
+    private void updateBattery() {
+        Intent intent = mContext.registerReceiver(null,
+                new IntentFilter(Intent.ACTION_BATTERY_CHANGED));
+
+        if (mBatteryStatus != null) {
+            String batterystatus = mContext.getString(R.string.battery_info_status_unknown);
+	    String batterylevel = Integer.toString(Math.round(100.f
+                    * intent.getIntExtra(BatteryManager.EXTRA_LEVEL, 100)
+                    / intent.getIntExtra(BatteryManager.EXTRA_SCALE, 100))) + ""%"";
+
+            switch (intent.getIntExtra(BatteryManager.EXTRA_STATUS, -1)) {
+                case BatteryManager.BATTERY_STATUS_CHARGING:
+                    batterystatus = mContext.getString(R.string.battery_info_status_charging);
+                    break;
+                case BatteryManager.BATTERY_STATUS_DISCHARGING:
+                    batterystatus = mContext.getString(R.string.battery_info_status_discharging);
+                    break;
+                case BatteryManager.BATTERY_STATUS_FULL:
+                    batterystatus = mContext.getString(R.string.battery_info_status_full);
+                    break;
+                case BatteryManager.BATTERY_STATUS_NOT_CHARGING:
+                    batterystatus = mContext.getString(R.string.battery_info_status_not_charging);
+                    break;
+                case BatteryManager.BATTERY_STATUS_UNKNOWN:
+                default:
+                    break;
+            }
+
+            mBatteryStatus.setSummary(batterylevel + "" - "" + batterystatus);
+        }
+    }
+
+    private static class MyHandler extends Handler {
+        private WeakReference<AbstractBatteryStatusPreferenceController> mStatus;
+
+        public MyHandler(AbstractBatteryStatusPreferenceController activity) {
+            mStatus = new WeakReference<>(activity);
+        }
+
+        @Override
+        public void handleMessage(Message msg) {
+            AbstractBatteryStatusPreferenceController status = mStatus.get();
+            if (status == null) {
+                return;
+            }
+
+            switch (msg.what) {
+                case EVENT_UPDATE_BATTERY:
+                    status.updateBattery();
+                    sendEmptyMessageDelayed(EVENT_UPDATE_BATTERY, 1000);
+                    break;
+
+                default:
+                    throw new IllegalStateException(""Unknown message "" + msg.what);
+            }
+        }
+    }
+}
",157,0,"AbstractBatteryStatusPreferenceController::MyHandler::MyHandler, AbstractBatteryStatusPreferenceController::getPreferenceKey, AbstractBatteryStatusPreferenceController::displayPreference, AbstractBatteryStatusPreferenceController::onStart, AbstractBatteryStatusPreferenceController::AbstractBatteryStatusPreferenceController, AbstractBatteryStatusPreferenceController::isAvailable, AbstractBatteryStatusPreferenceController::onStop, AbstractBatteryStatusPreferenceController::updateBattery, AbstractBatteryStatusPreferenceController::MyHandler::handleMessage, AbstractBatteryStatusPreferenceController::getHandler"
331,338240eed7fa054f0911ce27151de555e2a2f74b,NotificationStackScrollLayout.java,ModificationType.MODIFY,"@@ -137,8 +137,6 @@ import com.android.systemui.statusbar.phone.ShadeController;
 import com.android.systemui.statusbar.phone.StatusBar;
 import com.android.systemui.statusbar.policy.ConfigurationController;
 import com.android.systemui.statusbar.policy.ConfigurationController.ConfigurationListener;
-import com.android.systemui.statusbar.policy.DeviceProvisionedController;
-import com.android.systemui.statusbar.policy.DeviceProvisionedController.DeviceProvisionedListener;
 import com.android.systemui.statusbar.policy.HeadsUpUtil;
 import com.android.systemui.statusbar.policy.ScrollAdapter;
 import com.android.systemui.tuner.TunerService;
@@ -286,7 +284,6 @@ public class NotificationStackScrollLayout extends ViewGroup implements ScrollAd
     private boolean mExpandedInThisMotion;
     private boolean mShouldShowShelfOnly;
     protected boolean mScrollingEnabled;
-    private boolean mIsCurrentUserSetup;
     protected FooterView mFooterView;
     protected EmptyShadeView mEmptyShadeView;
     private boolean mDismissAllInProgress;
@@ -487,8 +484,6 @@ public class NotificationStackScrollLayout extends ViewGroup implements ScrollAd
     private final Rect mTmpRect = new Rect();
     private final NotificationEntryManager mEntryManager =
             Dependency.get(NotificationEntryManager.class);
-    private final DeviceProvisionedController mDeviceProvisionedController =
-            Dependency.get(DeviceProvisionedController.class);
     private final IStatusBarService mBarService = IStatusBarService.Stub.asInterface(
             ServiceManager.getService(Context.STATUS_BAR_SERVICE));
     @VisibleForTesting
@@ -610,28 +605,6 @@ public class NotificationStackScrollLayout extends ViewGroup implements ScrollAd
         }, HIGH_PRIORITY, Settings.Secure.NOTIFICATION_DISMISS_RTL,
                 LOCKSCREEN_TRANSLUCENT_NOTIFICATIONS_BG_ENABLED);
 
-        mDeviceProvisionedController.addCallback(
-                new DeviceProvisionedListener() {
-                    @Override
-                    public void onDeviceProvisionedChanged() {
-                        updateCurrentUserIsSetup();
-                    }
-
-                    @Override
-                    public void onUserSwitched() {
-                        updateCurrentUserIsSetup();
-                    }
-
-                    @Override
-                    public void onUserSetupChanged() {
-                        updateCurrentUserIsSetup();
-                    }
-
-                    private void updateCurrentUserIsSetup() {
-                        setCurrentUserSetup(mDeviceProvisionedController.isCurrentUserSetup());
-                    }
-                });
-
         mEntryManager.addNotificationEntryListener(new NotificationEntryListener() {
             @Override
             public void onPostEntryUpdated(NotificationEntry entry) {
@@ -724,7 +697,6 @@ public class NotificationStackScrollLayout extends ViewGroup implements ScrollAd
         boolean showDismissView = mClearAllEnabled && hasActiveClearableNotifications(ROWS_ALL);
         boolean showFooterView = (showDismissView ||
                 mEntryManager.getNotificationData().getActiveNotifications().size() != 0)
-                && mIsCurrentUserSetup  // see: b/193149550
                 && mStatusBarState != StatusBarState.KEYGUARD
                 && !mRemoteInputManager.getController().isRemoteInputActive();
 
@@ -5774,16 +5746,6 @@ public class NotificationStackScrollLayout extends ViewGroup implements ScrollAd
         return MathUtils.smoothStep(0, totalDistance, dragDownAmount);
     }
 
-    /**
-     * Sets whether the current user is set up, which is required to show the footer (b/193149550)
-     */
-    public void setCurrentUserSetup(boolean isCurrentUserSetup) {
-        if (mIsCurrentUserSetup != isCurrentUserSetup) {
-            mIsCurrentUserSetup = isCurrentUserSetup;
-            updateFooter();
-        }
-    }
-
     /**
      * A listener that is notified when the empty space below the notifications is clicked on
      */
",0,38,"NotificationStackScrollLayout::updateFooter, NotificationStackScrollLayout::NotificationStackScrollLayout, NotificationStackScrollLayout::setCurrentUserSetup"
332,338240eed7fa054f0911ce27151de555e2a2f74b,NotificationStackScrollLayoutTest.java,ModificationType.MODIFY,"@@ -299,7 +299,6 @@ public class NotificationStackScrollLayoutTest extends SysuiTestCase {
     @Test
     public void testUpdateFooter_noNotifications() {
         setBarStateForTest(StatusBarState.SHADE);
-        mStackScroller.setCurrentUserSetup(true);
         assertEquals(0, mNotificationData.getActiveNotifications().size());
 
         mStackScroller.updateFooter();
@@ -309,8 +308,6 @@ public class NotificationStackScrollLayoutTest extends SysuiTestCase {
     @Test
     public void testUpdateFooter_remoteInput() {
         setBarStateForTest(StatusBarState.SHADE);
-        mStackScroller.setCurrentUserSetup(true);
-
         ArrayList<NotificationEntry> entries = new ArrayList<>();
         entries.add(mock(NotificationEntry.class));
         when(mNotificationData.getActiveNotifications()).thenReturn(entries);
@@ -328,8 +325,6 @@ public class NotificationStackScrollLayoutTest extends SysuiTestCase {
     @Test
     public void testUpdateFooter_oneClearableNotification() {
         setBarStateForTest(StatusBarState.SHADE);
-        mStackScroller.setCurrentUserSetup(true);
-
         ArrayList<NotificationEntry> entries = new ArrayList<>();
         entries.add(mock(NotificationEntry.class));
         when(mNotificationData.getActiveNotifications()).thenReturn(entries);
@@ -343,29 +338,9 @@ public class NotificationStackScrollLayoutTest extends SysuiTestCase {
         verify(mStackScroller).updateFooterView(true, true);
     }
 
-    @Test
-    public void testUpdateFooter_oneClearableNotification_beforeUserSetup() {
-        setBarStateForTest(StatusBarState.SHADE);
-        mStackScroller.setCurrentUserSetup(false);
-
-        ArrayList<NotificationEntry> entries = new ArrayList<>();
-        entries.add(mock(NotificationEntry.class));
-        when(mNotificationData.getActiveNotifications()).thenReturn(entries);
-
-        ExpandableNotificationRow row = mock(ExpandableNotificationRow.class);
-        when(row.canViewBeDismissed()).thenReturn(true);
-        when(mStackScroller.getChildCount()).thenReturn(1);
-        when(mStackScroller.getChildAt(anyInt())).thenReturn(row);
-
-        mStackScroller.updateFooter();
-        verify(mStackScroller).updateFooterView(false, true);
-    }
-
     @Test
     public void testUpdateFooter_oneNonClearableNotification() {
         setBarStateForTest(StatusBarState.SHADE);
-        mStackScroller.setCurrentUserSetup(true);
-
         ArrayList<NotificationEntry> entries = new ArrayList<>();
         entries.add(mock(NotificationEntry.class));
         when(mEntryManager.getNotificationData().getActiveNotifications()).thenReturn(entries);
@@ -377,8 +352,6 @@ public class NotificationStackScrollLayoutTest extends SysuiTestCase {
 
     @Test
     public void testUpdateFooter_atEnd() {
-        mStackScroller.setCurrentUserSetup(true);
-
         // add footer
         mStackScroller.inflateFooterView();
 
",0,27,"NotificationStackScrollLayoutTest::testUpdateFooter_oneClearableNotification, NotificationStackScrollLayoutTest::testUpdateFooter_oneClearableNotification_beforeUserSetup, NotificationStackScrollLayoutTest::testUpdateFooter_oneNonClearableNotification, NotificationStackScrollLayoutTest::testUpdateFooter_atEnd, NotificationStackScrollLayoutTest::testUpdateFooter_remoteInput, NotificationStackScrollLayoutTest::testUpdateFooter_noNotifications"
333,ca0fe022e4e3a03c0241813ddd4d933e52309c1e,TextServicesManagerService.java,ModificationType.MODIFY,"@@ -43,6 +43,8 @@ import android.service.textservice.SpellCheckerService;
 import android.text.TextUtils;
 import android.util.Slog;
 import android.util.SparseArray;
+import android.view.inputmethod.InputMethodManager;
+import android.view.inputmethod.InputMethodSubtype;
 import android.view.inputmethod.InputMethodSystemProperty;
 import android.view.textservice.SpellCheckerInfo;
 import android.view.textservice.SpellCheckerSubtype;
@@ -573,19 +575,37 @@ public class TextServicesManagerService extends ITextServicesManager.Stub {
 
         // subtypeHashCode == 0 means spell checker language settings is ""auto""
 
-        if (systemLocale == null) {
+        Locale candidateLocale = null;
+        final InputMethodManager imm = mContext.getSystemService(InputMethodManager.class);
+        if (imm != null) {
+            final InputMethodSubtype currentInputMethodSubtype =
+                    imm.getCurrentInputMethodSubtype();
+            if (currentInputMethodSubtype != null) {
+                final String localeString = currentInputMethodSubtype.getLocale();
+                if (!TextUtils.isEmpty(localeString)) {
+                    // 1. Use keyboard locale if available in the spell checker
+                    candidateLocale = SubtypeLocaleUtils.constructLocaleFromString(localeString);
+                }
+            }
+        }
+        if (candidateLocale == null) {
+            // 2. Use System locale if available in the spell checker
+            candidateLocale = systemLocale;
+        }
+
+        if (candidateLocale == null) {
             return null;
         }
         SpellCheckerSubtype firstLanguageMatchingSubtype = null;
         for (int i = 0; i < sci.getSubtypeCount(); ++i) {
             final SpellCheckerSubtype scs = sci.getSubtypeAt(i);
             final Locale scsLocale = scs.getLocaleObject();
-            if (Objects.equals(scsLocale, systemLocale)) {
+            if (Objects.equals(scsLocale, candidateLocale)) {
                 // Exact match wins.
                 return scs;
             }
             if (firstLanguageMatchingSubtype == null && scsLocale != null
-                    && TextUtils.equals(systemLocale.getLanguage(), scsLocale.getLanguage())) {
+                    && TextUtils.equals(candidateLocale.getLanguage(), scsLocale.getLanguage())) {
                 // Remember as a fall back candidate
                 firstLanguageMatchingSubtype = scs;
             }
",23,3,TextServicesManagerService::getCurrentSpellCheckerSubtype
334,17ba3bd38d56c527b112c2f3c2b22680f4e423db,NotificationStackScrollLayout.java,ModificationType.MODIFY,"@@ -137,6 +137,8 @@ import com.android.systemui.statusbar.phone.ShadeController;
 import com.android.systemui.statusbar.phone.StatusBar;
 import com.android.systemui.statusbar.policy.ConfigurationController;
 import com.android.systemui.statusbar.policy.ConfigurationController.ConfigurationListener;
+import com.android.systemui.statusbar.policy.DeviceProvisionedController;
+import com.android.systemui.statusbar.policy.DeviceProvisionedController.DeviceProvisionedListener;
 import com.android.systemui.statusbar.policy.HeadsUpUtil;
 import com.android.systemui.statusbar.policy.ScrollAdapter;
 import com.android.systemui.tuner.TunerService;
@@ -284,6 +286,7 @@ public class NotificationStackScrollLayout extends ViewGroup implements ScrollAd
     private boolean mExpandedInThisMotion;
     private boolean mShouldShowShelfOnly;
     protected boolean mScrollingEnabled;
+    private boolean mIsCurrentUserSetup;
     protected FooterView mFooterView;
     protected EmptyShadeView mEmptyShadeView;
     private boolean mDismissAllInProgress;
@@ -484,6 +487,8 @@ public class NotificationStackScrollLayout extends ViewGroup implements ScrollAd
     private final Rect mTmpRect = new Rect();
     private final NotificationEntryManager mEntryManager =
             Dependency.get(NotificationEntryManager.class);
+    private final DeviceProvisionedController mDeviceProvisionedController =
+            Dependency.get(DeviceProvisionedController.class);
     private final IStatusBarService mBarService = IStatusBarService.Stub.asInterface(
             ServiceManager.getService(Context.STATUS_BAR_SERVICE));
     @VisibleForTesting
@@ -605,6 +610,28 @@ public class NotificationStackScrollLayout extends ViewGroup implements ScrollAd
         }, HIGH_PRIORITY, Settings.Secure.NOTIFICATION_DISMISS_RTL,
                 LOCKSCREEN_TRANSLUCENT_NOTIFICATIONS_BG_ENABLED);
 
+        mDeviceProvisionedController.addCallback(
+                new DeviceProvisionedListener() {
+                    @Override
+                    public void onDeviceProvisionedChanged() {
+                        updateCurrentUserIsSetup();
+                    }
+
+                    @Override
+                    public void onUserSwitched() {
+                        updateCurrentUserIsSetup();
+                    }
+
+                    @Override
+                    public void onUserSetupChanged() {
+                        updateCurrentUserIsSetup();
+                    }
+
+                    private void updateCurrentUserIsSetup() {
+                        setCurrentUserSetup(mDeviceProvisionedController.isCurrentUserSetup());
+                    }
+                });
+
         mEntryManager.addNotificationEntryListener(new NotificationEntryListener() {
             @Override
             public void onPostEntryUpdated(NotificationEntry entry) {
@@ -700,6 +727,7 @@ public class NotificationStackScrollLayout extends ViewGroup implements ScrollAd
         boolean showDismissView = mClearAllEnabled && hasActiveClearableNotifications(ROWS_ALL);
         boolean showFooterView = (showDismissView ||
                 mEntryManager.getNotificationData().getActiveNotifications().size() != 0)
+                && mIsCurrentUserSetup  // see: b/193149550
                 && mStatusBarState != StatusBarState.KEYGUARD
                 && !mRemoteInputManager.getController().isRemoteInputActive();
 
@@ -5749,6 +5777,16 @@ public class NotificationStackScrollLayout extends ViewGroup implements ScrollAd
         return MathUtils.smoothStep(0, totalDistance, dragDownAmount);
     }
 
+    /**
+     * Sets whether the current user is set up, which is required to show the footer (b/193149550)
+     */
+    public void setCurrentUserSetup(boolean isCurrentUserSetup) {
+        if (mIsCurrentUserSetup != isCurrentUserSetup) {
+            mIsCurrentUserSetup = isCurrentUserSetup;
+            updateFooter();
+        }
+    }
+
     /**
      * A listener that is notified when the empty space below the notifications is clicked on
      */
",38,0,"NotificationStackScrollLayout::updateFooter, NotificationStackScrollLayout::NotificationStackScrollLayout, NotificationStackScrollLayout::setCurrentUserSetup"
335,17ba3bd38d56c527b112c2f3c2b22680f4e423db,NotificationStackScrollLayoutTest.java,ModificationType.MODIFY,"@@ -299,6 +299,7 @@ public class NotificationStackScrollLayoutTest extends SysuiTestCase {
     @Test
     public void testUpdateFooter_noNotifications() {
         setBarStateForTest(StatusBarState.SHADE);
+        mStackScroller.setCurrentUserSetup(true);
         assertEquals(0, mNotificationData.getActiveNotifications().size());
 
         mStackScroller.updateFooter();
@@ -308,6 +309,8 @@ public class NotificationStackScrollLayoutTest extends SysuiTestCase {
     @Test
     public void testUpdateFooter_remoteInput() {
         setBarStateForTest(StatusBarState.SHADE);
+        mStackScroller.setCurrentUserSetup(true);
+
         ArrayList<NotificationEntry> entries = new ArrayList<>();
         entries.add(mock(NotificationEntry.class));
         when(mNotificationData.getActiveNotifications()).thenReturn(entries);
@@ -325,6 +328,8 @@ public class NotificationStackScrollLayoutTest extends SysuiTestCase {
     @Test
     public void testUpdateFooter_oneClearableNotification() {
         setBarStateForTest(StatusBarState.SHADE);
+        mStackScroller.setCurrentUserSetup(true);
+
         ArrayList<NotificationEntry> entries = new ArrayList<>();
         entries.add(mock(NotificationEntry.class));
         when(mNotificationData.getActiveNotifications()).thenReturn(entries);
@@ -338,9 +343,29 @@ public class NotificationStackScrollLayoutTest extends SysuiTestCase {
         verify(mStackScroller).updateFooterView(true, true);
     }
 
+    @Test
+    public void testUpdateFooter_oneClearableNotification_beforeUserSetup() {
+        setBarStateForTest(StatusBarState.SHADE);
+        mStackScroller.setCurrentUserSetup(false);
+
+        ArrayList<NotificationEntry> entries = new ArrayList<>();
+        entries.add(mock(NotificationEntry.class));
+        when(mNotificationData.getActiveNotifications()).thenReturn(entries);
+
+        ExpandableNotificationRow row = mock(ExpandableNotificationRow.class);
+        when(row.canViewBeDismissed()).thenReturn(true);
+        when(mStackScroller.getChildCount()).thenReturn(1);
+        when(mStackScroller.getChildAt(anyInt())).thenReturn(row);
+
+        mStackScroller.updateFooter();
+        verify(mStackScroller).updateFooterView(false, true);
+    }
+
     @Test
     public void testUpdateFooter_oneNonClearableNotification() {
         setBarStateForTest(StatusBarState.SHADE);
+        mStackScroller.setCurrentUserSetup(true);
+
         ArrayList<NotificationEntry> entries = new ArrayList<>();
         entries.add(mock(NotificationEntry.class));
         when(mEntryManager.getNotificationData().getActiveNotifications()).thenReturn(entries);
@@ -352,6 +377,8 @@ public class NotificationStackScrollLayoutTest extends SysuiTestCase {
 
     @Test
     public void testUpdateFooter_atEnd() {
+        mStackScroller.setCurrentUserSetup(true);
+
         // add footer
         mStackScroller.inflateFooterView();
 
",27,0,"NotificationStackScrollLayoutTest::testUpdateFooter_oneClearableNotification, NotificationStackScrollLayoutTest::testUpdateFooter_oneClearableNotification_beforeUserSetup, NotificationStackScrollLayoutTest::testUpdateFooter_oneNonClearableNotification, NotificationStackScrollLayoutTest::testUpdateFooter_atEnd, NotificationStackScrollLayoutTest::testUpdateFooter_remoteInput, NotificationStackScrollLayoutTest::testUpdateFooter_noNotifications"
