,hash,filename,diff,added_lines,deleted_lines,changed_methods
0,e388fe787e4400e4bc427b359b0d659746d34250,ChooserActivity.java,"@@ -2800,7 +2800,7 @@ public class ChooserActivity extends ResolverActivity implements
 
     @Override // ChooserListCommunicator
     public int getMaxRankedTargets() {
-        return getMaxTargetsPerRow();
+        return MAX_TARGETS_PER_ROW_LANDSCAPE;
     }
 
     @Override // ChooserListCommunicator
",1,1,ChooserActivity::getMaxRankedTargets
1,b10457e10341b7813020e7d700abbcf66055c248,ActivityStarter.java,"@@ -2023,6 +2023,13 @@ class ActivityStarter {
             final ActivityRecord top = targetTask.performClearTaskForReuseLocked(mStartActivity,
                     mLaunchFlags);
 
+            // The above code can remove {@code reusedActivity} from the task, leading to the
+            // {@code ActivityRecord} removing its reference to the {@code Task}. The task
+            // reference is needed in the call below to {@link setTargetStackAndMoveToFrontIfNeeded}
+            if (targetTaskTop.getTask() == null) {
+                targetTask.addChild(targetTaskTop);
+            }
+
             if (top != null) {
                 if (top.isRootOfTask()) {
                     // Activity aliases may mean we use different intents for the top activity,
",7,0,ActivityStarter::complyActivityFlags
2,5ca4149777ba5401a49e72ecab26daeba72cd401,AmbientDisplayTile.java,"@@ -1,6 +1,6 @@
 /*
  * Copyright (C) 2015 The CyanogenMod Project
- * Copyright (C) 2017 The LineageOS Project
+ * Copyright (C) 2017-2021 The LineageOS Project
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
@@ -39,9 +39,6 @@ import javax.inject.Inject;
 public class AmbientDisplayTile extends QSTileImpl<BooleanState> {
 
     private final Icon mIcon = ResourceIcon.get(R.drawable.ic_qs_ambient_display);
-
-    private static final Intent DISPLAY_SETTINGS = new Intent(""android.settings.DISPLAY_SETTINGS"");
-
     private final SecureSetting mSetting;
 
     @Inject
@@ -78,7 +75,7 @@ public class AmbientDisplayTile extends QSTileImpl<BooleanState> {
 
     @Override
     public Intent getLongClickIntent() {
-        return DISPLAY_SETTINGS;
+        return new Intent(Settings.ACTION_DISPLAY_SETTINGS);
     }
 
     private void setEnabled(boolean enabled) {
",2,5,AmbientDisplayTile::getLongClickIntent
3,810cac874dea92f4ce88ef15d1bb2a4ea2ca81f8,AmbientDisplayTile.java,"@@ -69,8 +69,7 @@ public class AmbientDisplayTile extends QSTileImpl<BooleanState> {
 
     @Override
     protected void handleClick() {
-        setEnabled(!mState.value);
-        refreshState();
+        mSetting.setValue(mState.value ? 0 : 1);
     }
 
     @Override
@@ -78,12 +77,6 @@ public class AmbientDisplayTile extends QSTileImpl<BooleanState> {
         return new Intent(Settings.ACTION_DISPLAY_SETTINGS);
     }
 
-    private void setEnabled(boolean enabled) {
-        Settings.Secure.putInt(mContext.getContentResolver(),
-                Settings.Secure.DOZE_ENABLED,
-                enabled ? 1 : 0);
-    }
-
     @Override
     protected void handleUpdateState(BooleanState state, Object arg) {
         final int value = arg instanceof Integer ? (Integer) arg : mSetting.getValue();
",1,8,"AmbientDisplayTile::setEnabled, AmbientDisplayTile::handleClick"
4,4d3d8db45aa07e8bb1f0a4c401031dd0d1f7a9db,AmbientDisplayTile.java,"@@ -53,6 +53,12 @@ public class AmbientDisplayTile extends QSTileImpl<BooleanState> {
         };
     }
 
+    @Override
+    protected void handleDestroy() {
+        super.handleDestroy();
+        mSetting.setListening(false);
+    }
+
     @Override
     public boolean isAvailable() {
         String name = Build.IS_DEBUGGABLE ? SystemProperties.get(""debug.doze.component"") : null;
@@ -67,6 +73,18 @@ public class AmbientDisplayTile extends QSTileImpl<BooleanState> {
         return new BooleanState();
     }
 
+    @Override
+    public void handleSetListening(boolean listening) {
+        super.handleSetListening(listening);
+        mSetting.setListening(listening);
+    }
+
+    @Override
+    protected void handleUserSwitch(int newUserId) {
+        mSetting.setUserId(newUserId);
+        handleRefreshState(mSetting.getValue());
+    }
+
     @Override
     protected void handleClick() {
         mSetting.setValue(mState.value ? 0 : 1);
@@ -115,9 +133,4 @@ public class AmbientDisplayTile extends QSTileImpl<BooleanState> {
                     R.string.accessibility_quick_settings_ambient_display_changed_off);
         }
     }
-
-    @Override
-    public void handleSetListening(boolean listening) {
-        // Do nothing
-    }
 }
",18,5,"AmbientDisplayTile::handleSetListening, AmbientDisplayTile::handleUserSwitch, AmbientDisplayTile::handleDestroy"
5,e928b5d031267a912efbe9e9888d36c42a5a111d,SecureSetting.java,"@@ -26,14 +26,13 @@ import com.android.systemui.statusbar.policy.Listenable;
 
 /** Helper for managing a secure setting. **/
 public abstract class SecureSetting extends ContentObserver implements Listenable {
-    private static final int DEFAULT = 0;
-
     private final Context mContext;
     private final String mSettingName;
+    private final int mDefaultValue;
 
     private boolean mListening;
     private int mUserId;
-    private int mObservedValue = DEFAULT;
+    private int mObservedValue;
 
     protected abstract void handleValueChanged(int value, boolean observedChange);
 
@@ -41,15 +40,22 @@ public abstract class SecureSetting extends ContentObserver implements Listenabl
         this(context, handler, settingName, ActivityManager.getCurrentUser());
     }
 
-    public SecureSetting(Context context, Handler handler, String settingName, int userId) {
+    protected SecureSetting(Context context, Handler handler, String settingName, int userId) {
+        this(context, handler, settingName, userId, 0);
+    }
+
+    public SecureSetting(Context context, Handler handler, String settingName, int userId,
+            int defaultValue) {
         super(handler);
         mContext = context;
         mSettingName = settingName;
+        mObservedValue = mDefaultValue = defaultValue;
         mUserId = userId;
     }
 
     public int getValue() {
-        return Secure.getIntForUser(mContext.getContentResolver(), mSettingName, DEFAULT, mUserId);
+        return Secure.getIntForUser(mContext.getContentResolver(), mSettingName, mDefaultValue,
+                mUserId);
     }
 
     public void setValue(int value) {
@@ -66,7 +72,7 @@ public abstract class SecureSetting extends ContentObserver implements Listenabl
                     Secure.getUriFor(mSettingName), false, this, mUserId);
         } else {
             mContext.getContentResolver().unregisterContentObserver(this);
-            mObservedValue = DEFAULT;
+            mObservedValue = mDefaultValue;
         }
     }
 
",12,6,"SecureSetting::getValue, SecureSetting::SecureSetting, SecureSetting::setListening, SecureSetting::SecureSetting"
6,d209b4106e3b48bcbb3ce3ed93f21f037a8f2195,AmbientDisplayTile.java,"@@ -17,6 +17,7 @@
 
 package com.android.systemui.qs.tiles;
 
+import android.app.ActivityManager;
 import android.content.Intent;
 import android.os.Build;
 import android.os.SystemProperties;
@@ -45,7 +46,8 @@ public class AmbientDisplayTile extends QSTileImpl<BooleanState> {
     public AmbientDisplayTile(QSHost host) {
         super(host);
 
-        mSetting = new SecureSetting(mContext, mHandler, Secure.DOZE_ENABLED) {
+        mSetting = new SecureSetting(mContext, mHandler, Secure.DOZE_ENABLED,
+                ActivityManager.getCurrentUser(), 1) {
             @Override
             protected void handleValueChanged(int value, boolean observedChange) {
                 handleRefreshState(value);
",3,1,AmbientDisplayTile::AmbientDisplayTile
7,d3943268592259421a5392bc0651161108530ca5,PreferredComponent.java,"@@ -254,6 +254,43 @@ public class PreferredComponent {
         return numMatch == NS;
     }
 
+    public boolean sameSet(PreferredComponent pc) {
+        if (mSetPackages == null || pc == null || pc.mSetPackages == null
+                || !sameComponent(pc.mComponent)) {
+            return false;
+        }
+        final int otherPackageCount = pc.mSetPackages.length;
+        final int packageCount = mSetPackages.length;
+        int numMatch = 0;
+        for (int i = 0; i < otherPackageCount; i++) {
+            boolean good = false;
+            for (int j = 0; j < packageCount; j++) {
+                if (mSetPackages[j].equals(pc.mSetPackages[j])
+                        && mSetClasses[j].equals(pc.mSetClasses[j])) {
+                    numMatch++;
+                    good = true;
+                    break;
+                }
+            }
+            if (!good) {
+                return false;
+            }
+        }
+        return numMatch == packageCount;
+    }
+
+    /** Returns true if the preferred component represents the provided ComponentName. */
+    private boolean sameComponent(ComponentName comp) {
+        if (mComponent == null || comp == null) {
+            return false;
+        }
+        if (mComponent.getPackageName().equals(comp.getPackageName())
+                && mComponent.getClassName().equals(comp.getClassName())) {
+            return true;
+        }
+        return false;
+    }
+
     public boolean isSuperset(List<ResolveInfo> query, boolean excludeSetupWizardPackage) {
         if (mSetPackages == null) {
             return query == null;
",37,0,"PreferredComponent::sameSet, PreferredComponent::sameComponent"
8,d3943268592259421a5392bc0651161108530ca5,PreferredIntentResolver.java,"@@ -22,6 +22,7 @@ import android.content.IntentFilter;
 import java.io.PrintWriter;
 
 import com.android.server.IntentResolver;
+import java.util.ArrayList;
 
 public class PreferredIntentResolver
         extends IntentResolver<PreferredActivity, PreferredActivity> {
@@ -45,4 +46,24 @@ public class PreferredIntentResolver
     protected IntentFilter getIntentFilter(@NonNull PreferredActivity input) {
         return input;
     }
+
+    public boolean shouldAddPreferredActivity(PreferredActivity pa) {
+        ArrayList<PreferredActivity> pal = findFilters(pa);
+        if (pal == null || pal.isEmpty()) {
+            return true;
+        }
+        if (!pa.mPref.mAlways) {
+            return false;
+        }
+        final int activityCount = pal.size();
+        for (int i = 0; i < activityCount; i++) {
+            PreferredActivity cur = pal.get(i);
+            if (cur.mPref.mAlways
+                    && cur.mPref.mMatch == (pa.mPref.mMatch & IntentFilter.MATCH_CATEGORY_MASK)
+                    && cur.mPref.sameSet(pa.mPref)) {
+                return false;
+            }
+        }
+        return true;
+    }
 }
",21,0,PreferredIntentResolver::shouldAddPreferredActivity
9,d3943268592259421a5392bc0651161108530ca5,Settings.java,"@@ -1410,8 +1410,7 @@ public final class Settings {
                 PreferredActivity pa = new PreferredActivity(parser);
                 if (pa.mPref.getParseError() == null) {
                     final PreferredIntentResolver resolver = editPreferredActivitiesLPw(userId);
-                    ArrayList<PreferredActivity> pal = resolver.findFilters(pa);
-                    if (pal == null || pal.size() == 0 || pa.mPref.mAlways) {
+                    if (resolver.shouldAddPreferredActivity(pa)) {
                         resolver.addFilter(pa);
                     }
                 } else {
",1,2,Settings::readPreferredActivitiesLPw
10,3de49ba59cecc365badb2e7193d3dbc8924be4e7,PreferredComponent.java,"@@ -254,43 +254,6 @@ public class PreferredComponent {
         return numMatch == NS;
     }
 
-    public boolean sameSet(PreferredComponent pc) {
-        if (mSetPackages == null || pc == null || pc.mSetPackages == null
-                || !sameComponent(pc.mComponent)) {
-            return false;
-        }
-        final int otherPackageCount = pc.mSetPackages.length;
-        final int packageCount = mSetPackages.length;
-        int numMatch = 0;
-        for (int i = 0; i < otherPackageCount; i++) {
-            boolean good = false;
-            for (int j = 0; j < packageCount; j++) {
-                if (mSetPackages[j].equals(pc.mSetPackages[j])
-                        && mSetClasses[j].equals(pc.mSetClasses[j])) {
-                    numMatch++;
-                    good = true;
-                    break;
-                }
-            }
-            if (!good) {
-                return false;
-            }
-        }
-        return numMatch == packageCount;
-    }
-
-    /** Returns true if the preferred component represents the provided ComponentName. */
-    private boolean sameComponent(ComponentName comp) {
-        if (mComponent == null || comp == null) {
-            return false;
-        }
-        if (mComponent.getPackageName().equals(comp.getPackageName())
-                && mComponent.getClassName().equals(comp.getClassName())) {
-            return true;
-        }
-        return false;
-    }
-
     public boolean isSuperset(List<ResolveInfo> query, boolean excludeSetupWizardPackage) {
         if (mSetPackages == null) {
             return query == null;
",0,37,"PreferredComponent::sameSet, PreferredComponent::sameComponent"
11,3de49ba59cecc365badb2e7193d3dbc8924be4e7,PreferredIntentResolver.java,"@@ -22,7 +22,6 @@ import android.content.IntentFilter;
 import java.io.PrintWriter;
 
 import com.android.server.IntentResolver;
-import java.util.ArrayList;
 
 public class PreferredIntentResolver
         extends IntentResolver<PreferredActivity, PreferredActivity> {
@@ -46,24 +45,4 @@ public class PreferredIntentResolver
     protected IntentFilter getIntentFilter(@NonNull PreferredActivity input) {
         return input;
     }
-
-    public boolean shouldAddPreferredActivity(PreferredActivity pa) {
-        ArrayList<PreferredActivity> pal = findFilters(pa);
-        if (pal == null || pal.isEmpty()) {
-            return true;
-        }
-        if (!pa.mPref.mAlways) {
-            return false;
-        }
-        final int activityCount = pal.size();
-        for (int i = 0; i < activityCount; i++) {
-            PreferredActivity cur = pal.get(i);
-            if (cur.mPref.mAlways
-                    && cur.mPref.mMatch == (pa.mPref.mMatch & IntentFilter.MATCH_CATEGORY_MASK)
-                    && cur.mPref.sameSet(pa.mPref)) {
-                return false;
-            }
-        }
-        return true;
-    }
 }
",0,21,PreferredIntentResolver::shouldAddPreferredActivity
12,3de49ba59cecc365badb2e7193d3dbc8924be4e7,Settings.java,"@@ -1410,7 +1410,8 @@ public final class Settings {
                 PreferredActivity pa = new PreferredActivity(parser);
                 if (pa.mPref.getParseError() == null) {
                     final PreferredIntentResolver resolver = editPreferredActivitiesLPw(userId);
-                    if (resolver.shouldAddPreferredActivity(pa)) {
+                    ArrayList<PreferredActivity> pal = resolver.findFilters(pa);
+                    if (pal == null || pal.size() == 0 || pa.mPref.mAlways) {
                         resolver.addFilter(pa);
                     }
                 } else {
",2,1,Settings::readPreferredActivitiesLPw
13,62da546cf8f4615cea39257aa4fca38331768952,PreferredComponent.java,"@@ -254,6 +254,37 @@ public class PreferredComponent {
         return numMatch == NS;
     }
 
+    public boolean sameSet(PreferredComponent pc) {
+        if (mSetPackages == null || pc == null || pc.mSetPackages == null
+                || !sameComponent(pc.mComponent)) {
+            return false;
+        }
+        final int otherPackageCount = pc.mSetPackages.length;
+        final int packageCount = mSetPackages.length;
+        if (otherPackageCount != packageCount) {
+            return false;
+        }
+        for (int i = 0; i < packageCount; i++) {
+            if (!mSetPackages[i].equals(pc.mSetPackages[i])
+                    || !mSetClasses[i].equals(pc.mSetClasses[i])) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    /** Returns true if the preferred component represents the provided ComponentName. */
+    private boolean sameComponent(ComponentName comp) {
+        if (mComponent == null || comp == null) {
+            return false;
+        }
+        if (mComponent.getPackageName().equals(comp.getPackageName())
+                && mComponent.getClassName().equals(comp.getClassName())) {
+            return true;
+        }
+        return false;
+    }
+
     public boolean isSuperset(List<ResolveInfo> query, boolean excludeSetupWizardPackage) {
         if (mSetPackages == null) {
             return query == null;
",31,0,"PreferredComponent::sameSet, PreferredComponent::sameComponent"
14,62da546cf8f4615cea39257aa4fca38331768952,PreferredIntentResolver.java,"@@ -22,6 +22,7 @@ import android.content.IntentFilter;
 import java.io.PrintWriter;
 
 import com.android.server.IntentResolver;
+import java.util.ArrayList;
 
 public class PreferredIntentResolver
         extends IntentResolver<PreferredActivity, PreferredActivity> {
@@ -45,4 +46,24 @@ public class PreferredIntentResolver
     protected IntentFilter getIntentFilter(@NonNull PreferredActivity input) {
         return input;
     }
+
+    public boolean shouldAddPreferredActivity(PreferredActivity pa) {
+        ArrayList<PreferredActivity> pal = findFilters(pa);
+        if (pal == null || pal.isEmpty()) {
+            return true;
+        }
+        if (!pa.mPref.mAlways) {
+            return false;
+        }
+        final int activityCount = pal.size();
+        for (int i = 0; i < activityCount; i++) {
+            PreferredActivity cur = pal.get(i);
+            if (cur.mPref.mAlways
+                    && cur.mPref.mMatch == (pa.mPref.mMatch & IntentFilter.MATCH_CATEGORY_MASK)
+                    && cur.mPref.sameSet(pa.mPref)) {
+                return false;
+            }
+        }
+        return true;
+    }
 }
",21,0,PreferredIntentResolver::shouldAddPreferredActivity
15,62da546cf8f4615cea39257aa4fca38331768952,Settings.java,"@@ -1410,8 +1410,7 @@ public final class Settings {
                 PreferredActivity pa = new PreferredActivity(parser);
                 if (pa.mPref.getParseError() == null) {
                     final PreferredIntentResolver resolver = editPreferredActivitiesLPw(userId);
-                    ArrayList<PreferredActivity> pal = resolver.findFilters(pa);
-                    if (pal == null || pal.size() == 0 || pa.mPref.mAlways) {
+                    if (resolver.shouldAddPreferredActivity(pa)) {
                         resolver.addFilter(pa);
                     }
                 } else {
",1,2,Settings::readPreferredActivitiesLPw
16,95fa7687295561b3d938165d38393cfd7d9cab66,MediaCodecInfo.java,"@@ -25,6 +25,7 @@ import android.annotation.SuppressLint;
 import android.annotation.TestApi;
 import android.compat.annotation.UnsupportedAppUsage;
 import android.os.Build;
+import android.os.Process;
 import android.os.SystemProperties;
 import android.util.Log;
 import android.util.Pair;
@@ -188,13 +189,14 @@ public final class MediaCodecInfo {
 
     // COMMON CONSTANTS
     private static final Range<Integer> POSITIVE_INTEGERS =
-        Range.create(1, Integer.MAX_VALUE);
+            Range.create(1, Integer.MAX_VALUE);
     private static final Range<Long> POSITIVE_LONGS =
-        Range.create(1l, Long.MAX_VALUE);
+            Range.create(1L, Long.MAX_VALUE);
     private static final Range<Rational> POSITIVE_RATIONALS =
-        Range.create(new Rational(1, Integer.MAX_VALUE),
-                     new Rational(Integer.MAX_VALUE, 1));
-    private static final Range<Integer> SIZE_RANGE = Range.create(1, 32768);
+            Range.create(new Rational(1, Integer.MAX_VALUE),
+                         new Rational(Integer.MAX_VALUE, 1));
+    private static final Range<Integer> SIZE_RANGE =
+            Process.is64Bit() ? Range.create(1, 32768) : Range.create(1, 4096);
     private static final Range<Integer> FRAME_RATE_RANGE = Range.create(0, 960);
     private static final Range<Integer> BITRATE_RANGE = Range.create(0, 500000000);
     private static final int DEFAULT_MAX_SUPPORTED_INSTANCES = 32;
@@ -1399,6 +1401,9 @@ public final class MediaCodecInfo {
 
         /**
          * Returns the range of supported video widths.
+         * <p class=note>
+         * 32-bit processes will not support resolutions larger than 4096x4096 due to
+         * the limited address space.
          */
         public Range<Integer> getSupportedWidths() {
             return mWidthRange;
@@ -1406,6 +1411,9 @@ public final class MediaCodecInfo {
 
         /**
          * Returns the range of supported video heights.
+         * <p class=note>
+         * 32-bit processes will not support resolutions larger than 4096x4096 due to
+         * the limited address space.
          */
         public Range<Integer> getSupportedHeights() {
             return mHeightRange;
@@ -1857,6 +1865,10 @@ public final class MediaCodecInfo {
                         && aligned.mMaxMacroBlockRate >= otherAligned.mMaxMacroBlockRate);
             }
 
+            /* package private */ boolean isEqualDimension(@NonNull PerformancePoint other) {
+                return mWidth == other.mWidth && mHeight == other.mHeight;
+            }
+
             private @NonNull Size getCommonBlockSize(@NonNull PerformancePoint other) {
                 return new Size(
                         Math.max(mBlockSize.getWidth(), other.mBlockSize.getWidth()) * 16,
@@ -1997,6 +2009,9 @@ public final class MediaCodecInfo {
          * Performance points assume a single active codec. For use cases where multiple
          * codecs are active, should use that highest pixel count, and add the frame rates of
          * each individual codec.
+         * <p class=note>
+         * Supported resolution could be further restricted for 32-bit processes due to
+         * the limited virtual memory space.
          */
         @Nullable
         public List<PerformancePoint> getSupportedPerformancePoints() {
@@ -2164,6 +2179,12 @@ public final class MediaCodecInfo {
                 if (size == null || size.getWidth() * size.getHeight() <= 0) {
                     continue;
                 }
+                if (size.getWidth() > SIZE_RANGE.getUpper()
+                        || size.getHeight() > SIZE_RANGE.getUpper()) {
+                    size = new Size(
+                            Math.min(size.getWidth(), SIZE_RANGE.getUpper()),
+                            Math.min(size.getHeight(), SIZE_RANGE.getUpper()));
+                }
                 Range<Long> range = Utils.parseLongRange(map.get(key), null);
                 if (range == null || range.getLower() < 0 || range.getUpper() < 0) {
                     continue;
@@ -2193,6 +2214,29 @@ public final class MediaCodecInfo {
                                (a.getMaxMacroBlockRate() < b.getMaxMacroBlockRate() ? -1 : 1) :
                        (a.getMaxFrameRate() != b.getMaxFrameRate()) ?
                                (a.getMaxFrameRate() < b.getMaxFrameRate() ? -1 : 1) : 0));
+
+            // remove redundant points
+            for (int i = 1; i < ret.size(); ++i) {
+                PerformancePoint a = ret.get(i);
+                for (int j = 0; j < i; ++j) {
+                    PerformancePoint b = ret.get(j);
+                    if (b.isEqualDimension(a) && b.covers(a)) {
+                        ret.set(i, null);
+                        break;
+                    }
+                }
+            }
+            int newSize = 0;
+            for (int i = 0; i < ret.size(); ++i) {
+                PerformancePoint a = ret.get(i);
+                if (a == null) {
+                    continue;
+                }
+                ret.set(newSize, a);
+                ++newSize;
+            }
+            ret.setSize(newSize);
+
             return Collections.unmodifiableList(ret);
         }
 
",49,5,MediaCodecInfo::create
17,6941cbf93f302eeaedb5ab984b33c09ed77dbbbc,MediaCodecInfo.java,"@@ -1865,10 +1865,6 @@ public final class MediaCodecInfo {
                         && aligned.mMaxMacroBlockRate >= otherAligned.mMaxMacroBlockRate);
             }
 
-            /* package private */ boolean isEqualDimension(@NonNull PerformancePoint other) {
-                return mWidth == other.mWidth && mHeight == other.mHeight;
-            }
-
             private @NonNull Size getCommonBlockSize(@NonNull PerformancePoint other) {
                 return new Size(
                         Math.max(mBlockSize.getWidth(), other.mBlockSize.getWidth()) * 16,
@@ -2010,8 +2006,11 @@ public final class MediaCodecInfo {
          * codecs are active, should use that highest pixel count, and add the frame rates of
          * each individual codec.
          * <p class=note>
-         * Supported resolution could be further restricted for 32-bit processes due to
-         * the limited virtual memory space.
+         * 32-bit processes will not support resolutions larger than 4096x4096 due to
+         * the limited address space, but performance points will be presented as is.
+         * In other words, even though a component publishes a performance point for
+         * a resolution higher than 4096x4096, it does not mean that the resolution is supported
+         * for 32-bit processes.
          */
         @Nullable
         public List<PerformancePoint> getSupportedPerformancePoints() {
@@ -2215,28 +2214,6 @@ public final class MediaCodecInfo {
                        (a.getMaxFrameRate() != b.getMaxFrameRate()) ?
                                (a.getMaxFrameRate() < b.getMaxFrameRate() ? -1 : 1) : 0));
 
-            // remove redundant points
-            for (int i = 1; i < ret.size(); ++i) {
-                PerformancePoint a = ret.get(i);
-                for (int j = 0; j < i; ++j) {
-                    PerformancePoint b = ret.get(j);
-                    if (b.isEqualDimension(a) && b.covers(a)) {
-                        ret.set(i, null);
-                        break;
-                    }
-                }
-            }
-            int newSize = 0;
-            for (int i = 0; i < ret.size(); ++i) {
-                PerformancePoint a = ret.get(i);
-                if (a == null) {
-                    continue;
-                }
-                ret.set(newSize, a);
-                ++newSize;
-            }
-            ret.setSize(newSize);
-
             return Collections.unmodifiableList(ret);
         }
 
",5,28,MediaCodecInfo::create
18,401638a795b0c25097eb0561bb70f97d6a5bc556,VolumeDialogImpl.java,"@@ -1176,7 +1176,7 @@ public class VolumeDialogImpl implements VolumeDialog,
 
     protected void onStateChangedH(State state) {
         if (D.BUG) Log.d(TAG, ""onStateChangedH() state: "" + state.toString());
-        if (mState != null && state != null
+        if (mShowing && mState != null && state != null
                 && mState.ringerModeInternal != -1
                 && mState.ringerModeInternal != state.ringerModeInternal
                 && state.ringerModeInternal == AudioManager.RINGER_MODE_VIBRATE) {
",1,1,VolumeDialogImpl::onStateChangedH
19,90a1fae619522e79d16799099de7525f0d6db0c5,AODTile.java,"@@ -1,6 +1,6 @@
 /*
  * Copyright (C) 2018 The OmniROM Project
- *               2020 The LineageOS Project
+ *               2020-2021 The LineageOS Project
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
@@ -75,8 +75,7 @@ public class AODTile extends QSTileImpl<BooleanState> implements
 
     @Override
     public void handleClick() {
-        setEnabled(!mState.value);
-        refreshState();
+        mSetting.setValue(mState.value ? 0 : 1);
     }
 
     @Override
@@ -84,12 +83,6 @@ public class AODTile extends QSTileImpl<BooleanState> implements
         return null;
     }
 
-    private void setEnabled(boolean enabled) {
-        Settings.Secure.putInt(mContext.getContentResolver(),
-                Settings.Secure.DOZE_ALWAYS_ON,
-                enabled ? 1 : 0);
-    }
-
     @Override
     public CharSequence getTileLabel() {
         if (mBatteryController.isAodPowerSave()) {
",2,9,"AODTile::setEnabled, AODTile::handleClick"
20,bc36ac0dcbb62ad81f099087bb66b2ede59c3057,AODTile.java,"@@ -60,6 +60,12 @@ public class AODTile extends QSTileImpl<BooleanState> implements
         refreshState();
     }
 
+    @Override
+    protected void handleDestroy() {
+        super.handleDestroy();
+        mSetting.setListening(false);
+    }
+
     @Override
     public boolean isAvailable() {
         return mContext.getResources().getBoolean(
@@ -73,6 +79,18 @@ public class AODTile extends QSTileImpl<BooleanState> implements
         return state;
     }
 
+    @Override
+    public void handleSetListening(boolean listening) {
+        super.handleSetListening(listening);
+        mSetting.setListening(listening);
+    }
+
+    @Override
+    protected void handleUserSwitch(int newUserId) {
+        mSetting.setUserId(newUserId);
+        handleRefreshState(mSetting.getValue());
+    }
+
     @Override
     public void handleClick() {
         mSetting.setValue(mState.value ? 0 : 1);
@@ -113,8 +131,4 @@ public class AODTile extends QSTileImpl<BooleanState> implements
     public int getMetricsCategory() {
         return LineageMetricsLogger.TILE_AOD;
     }
-
-    @Override
-    public void handleSetListening(boolean listening) {
-    }
 }
",18,4,"AODTile::handleUserSwitch, AODTile::handleDestroy, AODTile::handleSetListening"
21,1f0ac7f71914449a6cbf5d4c63356e7105106392,KeyguardViewMediator.java,"@@ -1980,13 +1980,6 @@ public class KeyguardViewMediator extends SystemUI implements Dumpable {
     private void handleHide() {
         Trace.beginSection(""KeyguardViewMediator#handleHide"");
 
-        // It's possible that the device was unlocked in a dream state. It's time to wake up.
-        if (mAodShowing) {
-            PowerManager pm = mContext.getSystemService(PowerManager.class);
-            pm.wakeUp(SystemClock.uptimeMillis(), PowerManager.WAKE_REASON_GESTURE,
-                    ""com.android.systemui:BOUNCER_DOZING"");
-        }
-
         synchronized (KeyguardViewMediator.this) {
             if (DEBUG) Log.d(TAG, ""handleHide"");
 
",0,7,KeyguardViewMediator::handleHide
22,2269a328e8f3ce8742a083260055fe81c61be022,GlobalActionsFlatLayout.java,"@@ -90,6 +90,7 @@ public class GlobalActionsFlatLayout extends GlobalActionsLayout {
             if (child instanceof GlobalActionsItem) {
                 GlobalActionsItem item = (GlobalActionsItem) child;
                 anyTruncated = anyTruncated || item.isTruncated();
+                item.setMessageMargin();
             }
         }
         // If any of the items have been truncated, set the all to single-line marquee
",1,0,GlobalActionsFlatLayout::onLayout
23,2269a328e8f3ce8742a083260055fe81c61be022,GlobalActionsItem.java,"@@ -21,6 +21,7 @@ import android.text.Layout;
 import android.text.TextUtils;
 import android.util.AttributeSet;
 import android.widget.LinearLayout;
+import android.widget.LinearLayout.LayoutParams;
 import android.widget.TextView;
 
 import com.android.internal.R;
@@ -54,6 +55,26 @@ public class GlobalActionsItem extends LinearLayout {
         text.setEllipsize(marquee ? TextUtils.TruncateAt.MARQUEE : TextUtils.TruncateAt.END);
     }
 
+    /**
+     * Sets message top margin depending on linecount
+     */
+    public void setMessageMargin() {
+        TextView message = findViewById(R.id.message);
+
+        if (message != null) {
+            LayoutParams params = (LinearLayout.LayoutParams) message.getLayoutParams();
+            int marginTop = (int) getResources().getDimension(getTextView().getLineCount() > 1
+                    ? com.android.systemui.R.dimen
+                            .global_actions_power_dialog_twoline_message_top_margin
+                    : com.android.systemui.R.dimen
+                            .global_actions_power_dialog_message_top_margin);
+
+            params.setMargins(params.leftMargin, marginTop, params.rightMargin,
+                    params.bottomMargin);
+            message.setLayoutParams(params);
+        }
+    }
+
     /**
      * Determines whether the message for this item has been truncated.
      */
",21,0,GlobalActionsItem::setMessageMargin
24,21a64f309e0b6b43b6ddf913e9d31adba893158f,LiveDisplayTile.java,"@@ -52,8 +52,7 @@ import javax.inject.Inject;
 /** Quick settings tile: LiveDisplay mode switcher **/
 public class LiveDisplayTile extends QSTileImpl<LiveDisplayState> {
 
-    private static final Intent LIVEDISPLAY_SETTINGS =
-            new Intent(""org.lineageos.lineageparts.LIVEDISPLAY_SETTINGS"");
+    private static final Intent DISPLAY_SETTINGS = new Intent(""android.settings.DISPLAY_SETTINGS"");
 
     private final LiveDisplayObserver mObserver;
     private String mTitle;
@@ -185,7 +184,7 @@ public class LiveDisplayTile extends QSTileImpl<LiveDisplayState> {
 
     @Override
     public Intent getLongClickIntent() {
-        return LIVEDISPLAY_SETTINGS;
+        return DISPLAY_SETTINGS;
     }
 
     @Override
",2,3,LiveDisplayTile::getLongClickIntent
25,21a64f309e0b6b43b6ddf913e9d31adba893158f,ReadingModeTile.java,"@@ -36,8 +36,7 @@ public class ReadingModeTile extends QSTileImpl<BooleanState> {
 
     private final Icon mIcon = ResourceIcon.get(R.drawable.ic_qs_reader);
 
-    private static final Intent LIVEDISPLAY_SETTINGS =
-            new Intent(""org.lineageos.lineageparts.LIVEDISPLAY_SETTINGS"");
+    private static final Intent DISPLAY_SETTINGS = new Intent(""android.settings.DISPLAY_SETTINGS"");
 
     private LineageHardwareManager mHardware;
 
@@ -61,7 +60,7 @@ public class ReadingModeTile extends QSTileImpl<BooleanState> {
 
     @Override
     public Intent getLongClickIntent() {
-        return LIVEDISPLAY_SETTINGS;
+        return DISPLAY_SETTINGS;
     }
 
     @Override
",2,3,ReadingModeTile::getLongClickIntent
26,5960e54c09803b3b07f4274afb1dc6a205bf58cd,QSFactoryImpl.java,"@@ -29,6 +29,7 @@ import com.android.systemui.qs.QSHost;
 import com.android.systemui.qs.external.CustomTile;
 import com.android.systemui.qs.tiles.AirplaneModeTile;
 import com.android.systemui.qs.tiles.AmbientDisplayTile;
+import com.android.systemui.qs.tiles.AntiFlickerTile;
 import com.android.systemui.qs.tiles.AODTile;
 import com.android.systemui.qs.tiles.BatterySaverTile;
 import com.android.systemui.qs.tiles.BluetoothTile;
@@ -103,6 +104,7 @@ public class QSFactoryImpl implements QSFactory {
     private final Provider<UsbTetherTile> mUsbTetherTileProvider;
     private final Provider<VolumeTile> mVolumeTileProvider;
     private final Provider<VpnTile> mVpnTileProvider;
+    private final Provider<AntiFlickerTile> mAntiFlickerTileProvider;
 
     private final Lazy<QSHost> mQsHostLazy;
 
@@ -139,7 +141,8 @@ public class QSFactoryImpl implements QSFactory {
             Provider<SyncTile> syncTileProvider,
             Provider<UsbTetherTile> usbTetherTileProvider,
             Provider<VolumeTile> volumeTileProvider,
-            Provider<VpnTile> vpnTileProvider) {
+            Provider<VpnTile> vpnTileProvider,
+            Provider<AntiFlickerTile> antiFlickerTileProvider) {
         mQsHostLazy = qsHostLazy;
         mWifiTileProvider = wifiTileProvider;
         mBluetoothTileProvider = bluetoothTileProvider;
@@ -173,6 +176,7 @@ public class QSFactoryImpl implements QSFactory {
         mUsbTetherTileProvider = usbTetherTileProvider;
         mVolumeTileProvider = volumeTileProvider;
         mVpnTileProvider = vpnTileProvider;
+        mAntiFlickerTileProvider = antiFlickerTileProvider;
     }
 
     public QSTile createTile(String tileSpec) {
@@ -249,6 +253,8 @@ public class QSFactoryImpl implements QSFactory {
                 return mVolumeTileProvider.get();
             case ""vpn"":
                 return mVpnTileProvider.get();
+            case ""anti_flicker"":
+                return mAntiFlickerTileProvider.get();
         }
 
         // Custom tiles
",7,1,"QSFactoryImpl::QSFactoryImpl, QSFactoryImpl::QSFactoryImpl, QSFactoryImpl::createTileInternal"
27,5960e54c09803b3b07f4274afb1dc6a205bf58cd,AntiFlickerTile.java,"@@ -0,0 +1,139 @@
+/*
+ * Copyright (C) 2020-2021 The LineageOS Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.systemui.qs.tiles;
+
+import static lineageos.hardware.LiveDisplayManager.FEATURE_ANTI_FLICKER;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.service.quicksettings.Tile;
+
+import com.android.systemui.plugins.qs.QSTile.BooleanState;
+import com.android.systemui.qs.QSHost;
+import com.android.systemui.qs.tileimpl.QSTileImpl;
+import com.android.systemui.R;
+
+import org.lineageos.internal.logging.LineageMetricsLogger;
+
+import lineageos.hardware.LiveDisplayManager;
+import lineageos.providers.LineageSettings;
+
+import javax.inject.Inject;
+
+public class AntiFlickerTile extends QSTileImpl<BooleanState> {
+    private boolean mAntiFlickerEnabled = true;
+    private boolean mReceiverRegistered;
+
+    private final Icon mIcon = ResourceIcon.get(R.drawable.ic_qs_anti_flicker);
+
+    private static final Intent DISPLAY_SETTINGS = new Intent(""android.settings.DISPLAY_SETTINGS"");
+
+    private final LiveDisplayManager mLiveDisplay;
+
+    @Inject
+    public AntiFlickerTile(QSHost host) {
+        super(host);
+        mLiveDisplay = LiveDisplayManager.getInstance(mContext);
+        if (!updateConfig()) {
+            mContext.registerReceiver(mReceiver,
+                    new IntentFilter(lineageos.content.Intent.ACTION_INITIALIZE_LIVEDISPLAY));
+            mReceiverRegistered = true;
+        }
+    }
+
+    @Override
+    protected void handleDestroy() {
+        super.handleDestroy();
+        unregisterReceiver();
+    }
+
+    private void unregisterReceiver() {
+        if (mReceiverRegistered) {
+            mContext.unregisterReceiver(mReceiver);
+            mReceiverRegistered = false;
+        }
+    }
+
+    private boolean updateConfig() {
+        if (mLiveDisplay.getConfig() != null) {
+            mAntiFlickerEnabled = mLiveDisplay.getConfig().hasFeature(FEATURE_ANTI_FLICKER);
+            if (!isAvailable()) {
+                mHost.removeTile(getTileSpec());
+            }
+            return true;
+        }
+        return false;
+    }
+
+    @Override
+    public BooleanState newTileState() {
+        return new BooleanState();
+    }
+
+    @Override
+    protected void handleClick() {
+        setEnabled(!mLiveDisplay.isAntiFlickerEnabled());
+        refreshState();
+    }
+
+    private void setEnabled(boolean enabled) {
+        LineageSettings.System.putInt(mContext.getContentResolver(),
+                LineageSettings.System.DISPLAY_ANTI_FLICKER, enabled ? 1 : 0);
+    }
+
+    @Override
+    public Intent getLongClickIntent() {
+        return DISPLAY_SETTINGS;
+    }
+
+    @Override
+    public boolean isAvailable() {
+        return mAntiFlickerEnabled;
+    }
+
+    @Override
+    protected void handleUpdateState(BooleanState state, Object arg) {
+        state.value = mLiveDisplay.isAntiFlickerEnabled();
+        state.icon = mIcon;
+        state.contentDescription = mContext.getString(R.string.quick_settings_anti_flicker);
+        state.state = (state.value ? Tile.STATE_ACTIVE : Tile.STATE_INACTIVE);
+        state.label = getTileLabel();
+    }
+
+    @Override
+    public CharSequence getTileLabel() {
+        return mContext.getString(R.string.quick_settings_anti_flicker);
+    }
+
+    @Override
+    public int getMetricsCategory() {
+        return LineageMetricsLogger.TILE_ANTI_FLICKER;
+    }
+
+    @Override
+    public void handleSetListening(boolean listening) {}
+
+    private final BroadcastReceiver mReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            updateConfig();
+            unregisterReceiver();
+        }
+    };
+}
",139,0,"AntiFlickerTile::AntiFlickerTile, AntiFlickerTile::handleClick, AntiFlickerTile::getTileLabel, AntiFlickerTile::handleSetListening, AntiFlickerTile::isAvailable, AntiFlickerTile::unregisterReceiver, AntiFlickerTile::BroadcastReceiver, AntiFlickerTile::updateConfig, AntiFlickerTile::handleUpdateState, AntiFlickerTile::getLongClickIntent, AntiFlickerTile::newTileState, AntiFlickerTile::handleDestroy, AntiFlickerTile::setEnabled, AntiFlickerTile::getMetricsCategory"
28,46712ee2e10a2e714edde5664354b132cb651d43,PhoneStatusBarView.java,"@@ -33,6 +33,7 @@ import android.view.DisplayCutout;
 import android.view.Gravity;
 import android.view.IWindowManager;
 import android.view.MotionEvent;
+import android.view.Surface;
 import android.view.View;
 import android.view.ViewGroup;
 import android.view.WindowInsets;
@@ -405,6 +406,13 @@ public class PhoneStatusBarView extends PanelBar implements Callbacks {
                         mDisplayCutout, cornerCutoutMargins, mRoundedCornerPadding);
 
         setPadding(padding.first, getPaddingTop(), padding.second, getPaddingBottom());
+
+        // Apply negative paddings to center clock layout so that we'll actually be on the center.
+        final int winRotation = getDisplay().getRotation();
+        LayoutParams centerClockParams =
+                (LayoutParams) findViewById(R.id.center_clock_layout).getLayoutParams();
+        centerClockParams.leftMargin = winRotation == Surface.ROTATION_0 ? -padding.first : 0;
+        centerClockParams.rightMargin = winRotation == Surface.ROTATION_0 ? -padding.second : 0;
     }
 
     public void setHeadsUpVisible(boolean headsUpVisible) {
",8,0,PhoneStatusBarView::updateSafeInsets
29,5a28ff769b487f003dc72cbd0ede6e8da4e605b3,PhoneStatusBarView.java,"@@ -407,12 +407,12 @@ public class PhoneStatusBarView extends PanelBar implements Callbacks {
 
         setPadding(padding.first, getPaddingTop(), padding.second, getPaddingBottom());
 
-        // Apply negative paddings to center clock layout so that we'll actually be on the center.
+        // Apply negative paddings to centered area layout so that we'll actually be on the center.
         final int winRotation = getDisplay().getRotation();
-        LayoutParams centerClockParams =
-                (LayoutParams) findViewById(R.id.center_clock_layout).getLayoutParams();
-        centerClockParams.leftMargin = winRotation == Surface.ROTATION_0 ? -padding.first : 0;
-        centerClockParams.rightMargin = winRotation == Surface.ROTATION_0 ? -padding.second : 0;
+        LayoutParams centeredAreaParams =
+                (LayoutParams) findViewById(R.id.centered_area).getLayoutParams();
+        centeredAreaParams.leftMargin = winRotation == Surface.ROTATION_0 ? -padding.first : 0;
+        centeredAreaParams.rightMargin = winRotation == Surface.ROTATION_0 ? -padding.second : 0;
     }
 
     public void setHeadsUpVisible(boolean headsUpVisible) {
",5,5,PhoneStatusBarView::updateSafeInsets
30,84c0117f46816f2d591e593856d430877eb5aee7,HeadsUpAppearanceController.java,"@@ -54,6 +54,7 @@ public class HeadsUpAppearanceController implements OnHeadsUpChangedListener,
     private final HeadsUpManagerPhone mHeadsUpManager;
     private final NotificationStackScrollLayout mStackScroller;
     private final HeadsUpStatusBarView mHeadsUpStatusBarView;
+    private final View mCenteredView;
     private final View mCenteredIconView;
     private final ClockController mClockController;
     private final View mOperatorNameView;
@@ -108,6 +109,7 @@ public class HeadsUpAppearanceController implements OnHeadsUpChangedListener,
                 statusBarView.findViewById(R.id.clock),
                 new ClockController(statusBarView.getContext(), statusBarView),
                 statusBarView.findViewById(R.id.operator_name_frame),
+                statusBarView.findViewById(R.id.centered_area),
                 statusBarView.findViewById(R.id.centered_icon_area));
     }
 
@@ -126,11 +128,13 @@ public class HeadsUpAppearanceController implements OnHeadsUpChangedListener,
             View clockView,
             ClockController clockController,
             View operatorNameView,
+            View centeredView,
             View centeredIconView) {
         mNotificationIconAreaController = notificationIconAreaController;
         mHeadsUpManager = headsUpManager;
         mHeadsUpManager.addListener(this);
         mHeadsUpStatusBarView = headsUpStatusBarView;
+        mCenteredView = centeredView;
         mCenteredIconView = centeredIconView;
         headsUpStatusBarView.setOnDrawingRectChangedListener(
                 () -> updateIsolatedIconLocation(true /* requireUpdate */));
@@ -287,6 +291,9 @@ public class HeadsUpAppearanceController implements OnHeadsUpChangedListener,
                 if (!isRightClock) {
                     hide(clockView, View.INVISIBLE);
                 }
+                if (mCenteredView.getVisibility() != View.GONE) {
+                    hide(mCenteredView, View.INVISIBLE);
+                }
                 if (mCenteredIconView.getVisibility() != View.GONE) {
                     hide(mCenteredIconView, View.INVISIBLE);
                 }
@@ -297,6 +304,9 @@ public class HeadsUpAppearanceController implements OnHeadsUpChangedListener,
                 if (!isRightClock) {
                     show(clockView);
                 }
+                if (mCenteredView.getVisibility() != View.GONE) {
+                    show(mCenteredView);
+                }
                 if (mCenteredIconView.getVisibility() != View.GONE) {
                     show(mCenteredIconView);
                 }
",10,0,"HeadsUpAppearanceController::setShown, HeadsUpAppearanceController::HeadsUpAppearanceController, HeadsUpAppearanceController::HeadsUpAppearanceController"
31,84c0117f46816f2d591e593856d430877eb5aee7,HeadsUpAppearanceControllerTest.java,"@@ -100,6 +100,7 @@ public class HeadsUpAppearanceControllerTest extends SysuiTestCase {
                 new View(mContext),
                 mock(ClockController.class),
                 mOperatorNameView,
+                new View(mContext),
                 new View(mContext));
         mHeadsUpAppearanceController.setAppearFraction(0.0f, 0.0f);
     }
@@ -180,6 +181,7 @@ public class HeadsUpAppearanceControllerTest extends SysuiTestCase {
                 new View(mContext),
                 mock(ClockController.class),
                 new View(mContext),
+                new View(mContext),
                 new View(mContext));
         newController.readFrom(mHeadsUpAppearanceController);
 
",2,0,"HeadsUpAppearanceControllerTest::setUp, HeadsUpAppearanceControllerTest::testHeaderReadFromOldController"
32,70af95c7b26e3d2dcbab3a4bf1e41336e91ea1cf,AuthCredentialPatternView.java,"@@ -100,6 +100,7 @@ public class AuthCredentialPatternView extends AuthCredentialView {
     protected void onAttachedToWindow() {
         super.onAttachedToWindow();
         mLockPatternView = findViewById(R.id.lockPattern);
+        mLockPatternView.setLockPatternSize(mLockPatternUtils.getLockPatternSize(mUserId));
         mLockPatternView.setOnPatternListener(new UnlockPatternListener());
         mLockPatternView.setInStealthMode(
                 !mLockPatternUtils.isVisiblePatternEnabled(mUserId));
",1,0,AuthCredentialPatternView::onAttachedToWindow
33,01b994ac7c5624c1efa8fba1c3fa84d586c164da,NavigationBarFragment.java,"@@ -25,9 +25,7 @@ import static android.view.InsetsState.ITYPE_NAVIGATION_BAR;
 import static android.view.InsetsState.containsType;
 import static android.view.WindowInsetsController.APPEARANCE_LOW_PROFILE_BARS;
 import static android.view.WindowInsetsController.APPEARANCE_OPAQUE_NAVIGATION_BARS;
-import static android.view.WindowManager.LayoutParams.PRIVATE_FLAG_NO_MOVE_ANIMATION;
 import static android.view.WindowManagerPolicyConstants.NAV_BAR_MODE_3BUTTON;
-import static android.view.WindowManagerPolicyConstants.NAV_BAR_MODE_GESTURAL;
 
 import static com.android.internal.accessibility.common.ShortcutConstants.CHOOSER_PACKAGE_NAME;
 import static com.android.internal.config.sysui.SystemUiDeviceConfigFlags.NAV_BAR_HANDLE_FORCE_OPAQUE;
@@ -59,9 +57,6 @@ import android.content.IntentFilter;
 import android.content.res.Configuration;
 import android.database.ContentObserver;
 import android.graphics.PixelFormat;
-import android.graphics.Rect;
-import android.graphics.RectF;
-import android.hardware.display.DisplayManager;
 import android.inputmethodservice.InputMethodService;
 import android.net.Uri;
 import android.os.Binder;
@@ -77,7 +72,6 @@ import android.telecom.TelecomManager;
 import android.text.TextUtils;
 import android.util.Log;
 import android.view.Display;
-import android.view.Gravity;
 import android.view.InsetsState.InternalInsetsType;
 import android.view.KeyEvent;
 import android.view.LayoutInflater;
@@ -145,7 +139,7 @@ import dagger.Lazy;
  * on clicks and view states of the nav bar.
  */
 public class NavigationBarFragment extends LifecycleFragment implements Callbacks,
-        NavigationModeController.ModeChangedListener, DisplayManager.DisplayListener {
+        NavigationModeController.ModeChangedListener {
 
     public static final String TAG = ""NavigationBar"";
     private static final boolean DEBUG = false;
@@ -211,23 +205,7 @@ public class NavigationBarFragment extends LifecycleFragment implements Callback
     private boolean mIsOnDefaultDisplay;
     public boolean mHomeBlockedThisTouch;
 
-    /**
-     * When user is QuickSwitching between apps of different orientations, we'll draw a fake
-     * home handle on the orientation they originally touched down to start their swipe
-     * gesture to indicate to them that they can continue in that orientation without having to
-     * rotate the phone
-     * The secondary handle will show when we get
-     * {@link OverviewProxyListener#onQuickSwitchToNewTask(int)} callback with the
-     * original handle hidden and we'll flip the visibilities once the
-     * {@link #mTasksFrozenListener} fires
-     */
-    private QuickswitchOrientedNavHandle mOrientationHandle;
-    private WindowManager.LayoutParams mOrientationParams;
-    private int mStartingQuickSwitchRotation = -1;
-    private int mCurrentRotation;
-    private ViewTreeObserver.OnGlobalLayoutListener mOrientationHandleGlobalLayoutListener;
     private UiEventLogger mUiEventLogger;
-    private boolean mShowOrientedHandleForImmersiveMode;
 
     @com.android.internal.annotations.VisibleForTesting
     public enum NavBarActionEvent implements UiEventLogger.UiEventEnum {
@@ -296,15 +274,6 @@ public class NavigationBarFragment extends LifecycleFragment implements Callback
             mShadeController.collapsePanel(true /* animate */);
         }
 
-        @Override
-        public void onQuickSwitchToNewTask(@Surface.Rotation int rotation) {
-            mStartingQuickSwitchRotation = rotation;
-            if (rotation == -1) {
-                mShowOrientedHandleForImmersiveMode = false;
-            }
-            orientSecondaryHomeHandle();
-        }
-
         @Override
         public void startAssistant(Bundle bundle) {
             mAssistManager.startAssist(bundle);
@@ -346,14 +315,6 @@ public class NavigationBarFragment extends LifecycleFragment implements Callback
         }
     };
 
-    private NavigationBarTransitions.DarkIntensityListener mOrientationHandleIntensityListener =
-            new NavigationBarTransitions.DarkIntensityListener() {
-                @Override
-                public void onDarkIntensity(float darkIntensity) {
-                    mOrientationHandle.setDarkIntensity(darkIntensity);
-                }
-            };
-
     private final Runnable mAutoDim = () -> getBarTransitions().setAutoDim(true);
 
     private final ContentObserver mAssistContentObserver = new ContentObserver(
@@ -531,8 +492,6 @@ public class NavigationBarFragment extends LifecycleFragment implements Callback
                 new AssistHandleViewController(mHandler, mNavigationBarView);
             getBarTransitions().addDarkIntensityListener(mAssistHandlerViewController);
         }
-
-        initSecondaryHomeHandleForRotation();
     }
 
     @Override
@@ -549,14 +508,6 @@ public class NavigationBarFragment extends LifecycleFragment implements Callback
         }
         mOverviewProxyService.removeCallback(mOverviewProxyListener);
         mBroadcastDispatcher.unregisterReceiver(mBroadcastReceiver);
-        if (mOrientationHandle != null) {
-            resetSecondaryHandle();
-            getContext().getSystemService(DisplayManager.class).unregisterDisplayListener(this);
-            getBarTransitions().removeDarkIntensityListener(mOrientationHandleIntensityListener);
-            mWindowManager.removeView(mOrientationHandle);
-            mOrientationHandle.getViewTreeObserver().removeOnGlobalLayoutListener(
-                    mOrientationHandleGlobalLayoutListener);
-        }
     }
 
     @Override
@@ -589,115 +540,6 @@ public class NavigationBarFragment extends LifecycleFragment implements Callback
         repositionNavigationBar();
     }
 
-    private void initSecondaryHomeHandleForRotation() {
-        if (!canShowSecondaryHandle()) {
-            return;
-        }
-
-        getContext().getSystemService(DisplayManager.class)
-                .registerDisplayListener(this, new Handler(Looper.getMainLooper()));
-
-        mOrientationHandle = new QuickswitchOrientedNavHandle(getContext());
-        mOrientationHandle.setId(R.id.secondary_home_handle);
-
-        getBarTransitions().addDarkIntensityListener(mOrientationHandleIntensityListener);
-        mOrientationParams = new WindowManager.LayoutParams(0, 0,
-                WindowManager.LayoutParams.TYPE_NAVIGATION_BAR_PANEL,
-                WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE
-                        | WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL
-                        | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN
-                        | WindowManager.LayoutParams.FLAG_SPLIT_TOUCH
-                        | WindowManager.LayoutParams.FLAG_SLIPPERY,
-                PixelFormat.TRANSLUCENT);
-        mOrientationParams.setTitle(""SecondaryHomeHandle"" + getContext().getDisplayId());
-        mOrientationParams.privateFlags |= PRIVATE_FLAG_NO_MOVE_ANIMATION;
-        mWindowManager.addView(mOrientationHandle, mOrientationParams);
-        mOrientationHandle.setVisibility(View.GONE);
-        mOrientationParams.setFitInsetsTypes(0 /* types*/);
-        mOrientationHandleGlobalLayoutListener =
-                () -> {
-                    if (mStartingQuickSwitchRotation == -1) {
-                        return;
-                    }
-
-                    RectF boundsOnScreen = mOrientationHandle.computeHomeHandleBounds();
-                    mOrientationHandle.mapRectFromViewToScreenCoords(boundsOnScreen, true);
-                    Rect boundsRounded = new Rect();
-                    boundsOnScreen.roundOut(boundsRounded);
-                    mNavigationBarView.setOrientedHandleSamplingRegion(boundsRounded);
-                };
-        mOrientationHandle.getViewTreeObserver().addOnGlobalLayoutListener(
-                mOrientationHandleGlobalLayoutListener);
-    }
-
-    private void orientSecondaryHomeHandle() {
-        if (!canShowSecondaryHandle()) {
-            return;
-        }
-
-        if (mStartingQuickSwitchRotation == -1 || mDivider.isDividerVisible()) {
-            // Hide the secondary home handle if we are in multiwindow since apps in multiwindow
-            // aren't allowed to set the display orientation
-            resetSecondaryHandle();
-        } else {
-            int deltaRotation = deltaRotation(mCurrentRotation, mStartingQuickSwitchRotation);
-            if (mStartingQuickSwitchRotation == -1 || deltaRotation == -1) {
-                // Curious if starting quickswitch can change between the if check and our delta
-                Log.d(TAG, ""secondary nav delta rotation: "" + deltaRotation
-                        + "" current: "" + mCurrentRotation
-                        + "" starting: "" + mStartingQuickSwitchRotation);
-            }
-            int height = 0;
-            int width = 0;
-            Rect dispSize = mWindowManager.getCurrentWindowMetrics().getBounds();
-            mOrientationHandle.setDeltaRotation(deltaRotation);
-            switch (deltaRotation) {
-                case Surface.ROTATION_90:
-                case Surface.ROTATION_270:
-                    height = dispSize.height();
-                    width = mNavigationBarView.getHeight();
-                    break;
-                case Surface.ROTATION_180:
-                case Surface.ROTATION_0:
-                    // TODO(b/152683657): Need to determine best UX for this
-                    if (!mShowOrientedHandleForImmersiveMode) {
-                        resetSecondaryHandle();
-                        return;
-                    }
-                    width = dispSize.width();
-                    height = mNavigationBarView.getHeight();
-                    break;
-            }
-
-            mOrientationParams.gravity =
-                    deltaRotation == Surface.ROTATION_0 ? Gravity.BOTTOM :
-                            (deltaRotation == Surface.ROTATION_90 ? Gravity.LEFT : Gravity.RIGHT);
-            mOrientationParams.height = height;
-            mOrientationParams.width = width;
-            mWindowManager.updateViewLayout(mOrientationHandle, mOrientationParams);
-            mNavigationBarView.setVisibility(View.GONE);
-            mOrientationHandle.setVisibility(View.VISIBLE);
-        }
-    }
-
-    private void resetSecondaryHandle() {
-        if (mOrientationHandle != null) {
-            // Case where nav mode is changed w/o ever invoking a quickstep
-            // mOrientedHandle is initialized lazily
-            mOrientationHandle.setVisibility(View.GONE);
-        }
-        if (mNavigationBarView != null) {
-            mNavigationBarView.setVisibility(View.VISIBLE);
-            mNavigationBarView.setOrientedHandleSamplingRegion(null);
-        }
-    }
-
-    private int deltaRotation(int oldRotation, int newRotation) {
-        int delta = newRotation - oldRotation;
-        if (delta < 0) delta += 4;
-        return delta;
-    }
-
     @Override
     public void dump(String prefix, FileDescriptor fd, PrintWriter pw, String[] args) {
         if (mNavigationBarView != null) {
@@ -708,8 +550,6 @@ public class NavigationBarFragment extends LifecycleFragment implements Callback
             dumpBarTransitions(pw, ""mNavigationBarView"", mNavigationBarView.getBarTransitions());
         }
 
-        pw.print(""  mStartingQuickSwitchRotation="" + mStartingQuickSwitchRotation);
-        pw.print(""  mCurrentRotation="" + mCurrentRotation);
         pw.print(""  mNavigationBarView="");
         if (mNavigationBarView == null) {
             pw.println(""null"");
@@ -765,11 +605,6 @@ public class NavigationBarFragment extends LifecycleFragment implements Callback
                 && mNavigationBarWindowState != state) {
             mNavigationBarWindowState = state;
             updateSystemUiStateFlags(-1);
-            mShowOrientedHandleForImmersiveMode = state == WINDOW_STATE_HIDDEN;
-            if (mOrientationHandle != null
-                    && mStartingQuickSwitchRotation != -1) {
-                orientSecondaryHomeHandle();
-            }
             if (DEBUG_WINDOW_STATE) Log.d(TAG, ""Navigation bar "" + windowStateToString(state));
 
             if (mNavigationBarView != null) {
@@ -1333,10 +1168,6 @@ public class NavigationBarFragment extends LifecycleFragment implements Callback
         mNavBarMode = mode;
         updateScreenPinningGestures();
 
-        if (!canShowSecondaryHandle()) {
-            resetSecondaryHandle();
-        }
-
         // Workaround for b/132825155, for secondary users, we currently don't receive configuration
         // changes on overlay package change since SystemUI runs for the system user. In this case,
         // trigger a new configuration change to ensure that the nav bar is updated in the same way.
@@ -1381,34 +1212,6 @@ public class NavigationBarFragment extends LifecycleFragment implements Callback
     private final AccessibilityServicesStateChangeListener mAccessibilityListener =
             this::updateAccessibilityServicesState;
 
-    @Override
-    public void onDisplayAdded(int displayId) {
-
-    }
-
-    @Override
-    public void onDisplayRemoved(int displayId) {
-
-    }
-
-    @Override
-    public void onDisplayChanged(int displayId) {
-        if (!canShowSecondaryHandle()) {
-            return;
-        }
-
-        int rotation = getContext().getResources().getConfiguration()
-                .windowConfiguration.getRotation();
-        if (rotation != mCurrentRotation) {
-            mCurrentRotation = rotation;
-            orientSecondaryHomeHandle();
-        }
-    }
-
-    private boolean canShowSecondaryHandle() {
-        return mNavBarMode == NAV_BAR_MODE_GESTURAL;
-    }
-
     private final Consumer<Integer> mRotationWatcher = rotation -> {
         if (mNavigationBarView != null
                 && mNavigationBarView.needsReorient(rotation)) {
",1,198,"NavigationBarFragment::onDisplayRemoved, NavigationBarFragment::canShowSecondaryHandle, NavigationBarFragment::orientSecondaryHomeHandle, NavigationBarFragment::setWindowState, NavigationBarFragment::onNavigationModeChanged, NavigationBarFragment::resetSecondaryHandle, NavigationBarFragment::deltaRotation, NavigationBarFragment::onDisplayAdded, NavigationBarFragment::onDestroyView, NavigationBarFragment::OverviewProxyListener, NavigationBarFragment::onViewCreated, NavigationBarFragment::dump, NavigationBarFragment::onDisplayChanged, NavigationBarFragment::initSecondaryHomeHandleForRotation, NavigationBarFragment::DarkIntensityListener"
34,01b994ac7c5624c1efa8fba1c3fa84d586c164da,NavigationHandle.java,"@@ -32,11 +32,11 @@ import com.android.systemui.R;
 
 public class NavigationHandle extends View implements ButtonInterface {
 
-    protected final Paint mPaint = new Paint();
+    private final Paint mPaint = new Paint();
     private @ColorInt final int mLightColor;
     private @ColorInt final int mDarkColor;
-    protected final int mRadius;
-    protected final int mBottom;
+    private final int mRadius;
+    private final int mBottom;
     private boolean mRequiresInvalidate;
 
     public NavigationHandle(Context context) {
",3,3,
35,01b994ac7c5624c1efa8fba1c3fa84d586c164da,QuickswitchOrientedNavHandle.java,"@@ -1,80 +0,0 @@
-/*
- * Copyright (C) 2019 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.systemui.statusbar.phone;
-
-import android.content.Context;
-import android.graphics.Canvas;
-import android.graphics.RectF;
-import android.view.Surface;
-
-import com.android.systemui.R;
-
-/** Temporarily shown view when using QuickSwitch to switch between apps of different rotations */
-public class QuickswitchOrientedNavHandle extends NavigationHandle {
-    private final int mWidth;
-    private final RectF mTmpBoundsRectF = new RectF();
-    private @Surface.Rotation int mDeltaRotation;
-
-    public QuickswitchOrientedNavHandle(Context context) {
-        super(context);
-        mWidth = context.getResources().getDimensionPixelSize(R.dimen.navigation_home_handle_width);
-    }
-
-    void setDeltaRotation(@Surface.Rotation int rotation) {
-        mDeltaRotation = rotation;
-    }
-
-    @Override
-    protected void onDraw(Canvas canvas) {
-        canvas.drawRoundRect(computeHomeHandleBounds(), mRadius, mRadius, mPaint);
-    }
-
-    RectF computeHomeHandleBounds() {
-        int left;
-        int top;
-        int bottom;
-        int right;
-        int radiusOffset = mRadius * 2;
-        int topStart = getLocationOnScreen()[1];
-
-        switch (mDeltaRotation) {
-            default:
-            case Surface.ROTATION_0:
-            case Surface.ROTATION_180:
-                int height = mRadius * 2;
-                left = getWidth() / 2 - mWidth / 2;
-                top = (getHeight() - mBottom - height);
-                right = getWidth() / 2 + mWidth / 2;
-                bottom = top + height;
-                break;
-            case Surface.ROTATION_90:
-                left = mBottom;
-                right = left + radiusOffset;
-                top = getHeight() / 2 - (mWidth / 2) - (topStart / 2);
-                bottom = top + mWidth;
-                break;
-            case Surface.ROTATION_270:
-                right = getWidth() - mBottom;
-                left = right - radiusOffset;
-                top = getHeight() / 2 - (mWidth / 2) - (topStart / 2);
-                bottom = top + mWidth;
-                break;
-        }
-        mTmpBoundsRectF.set(left, top, right, bottom);
-        return mTmpBoundsRectF;
-    }
-}
",0,80,"QuickswitchOrientedNavHandle::onDraw, QuickswitchOrientedNavHandle::computeHomeHandleBounds, QuickswitchOrientedNavHandle::setDeltaRotation, QuickswitchOrientedNavHandle::QuickswitchOrientedNavHandle"
36,6cd9135c9cbfe3b423825a67f600b3cb06fa0717,KeyguardPINView.java,"@@ -51,6 +51,7 @@ public class KeyguardPINView extends KeyguardPinBasedInputView {
     private View mDivider;
     private int mDisappearYTranslation;
     private View[][] mViews;
+    private boolean mScramblePin;
     private final KeyguardUpdateMonitor mKeyguardUpdateMonitor;
 
     private static List<Integer> sNumbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 0);
@@ -131,9 +132,9 @@ public class KeyguardPINView extends KeyguardPinBasedInputView {
             });
         }
 
-        boolean scramblePin = (LineageSettings.System.getInt(getContext().getContentResolver(),
-                LineageSettings.System.LOCKSCREEN_PIN_SCRAMBLE_LAYOUT, 0) == 1);
-        if (scramblePin) {
+        mScramblePin = LineageSettings.System.getInt(getContext().getContentResolver(),
+                LineageSettings.System.LOCKSCREEN_PIN_SCRAMBLE_LAYOUT, 0) == 1;
+        if (mScramblePin) {
             Collections.shuffle(sNumbers);
             // get all children who are NumPadKey's
             LinearLayout container = (LinearLayout) findViewById(R.id.container);
@@ -214,6 +215,14 @@ public class KeyguardPINView extends KeyguardPinBasedInputView {
         setClipChildren(enable);
     }
 
+    @Override
+    protected int getNumberIndex(int number) {
+        if (mScramblePin) {
+            return (sNumbers.indexOf(number) + 1) % sNumbers.size();
+        }
+        return super.getNumberIndex(number);
+    }
+
     @Override
     public boolean hasOverlappingRendering() {
         return false;
",12,3,"KeyguardPINView::getNumberIndex, KeyguardPINView::onFinishInflate"
37,6cd9135c9cbfe3b423825a67f600b3cb06fa0717,KeyguardPinBasedInputView.java,"@@ -125,12 +125,16 @@ public abstract class KeyguardPinBasedInputView extends KeyguardAbsKeyInputView
         }
     }
 
+    protected int getNumberIndex(int number) {
+        return number;
+    }
+
     private void performClick(View view) {
         view.performClick();
     }
 
     private void performNumberClick(int number) {
-        switch (number) {
+        switch (getNumberIndex(number)) {
             case 0:
                 performClick(mButton0);
                 break;
",5,1,"KeyguardPinBasedInputView::getNumberIndex, KeyguardPinBasedInputView::performNumberClick"
38,be00ba5a03fe0aefa1a6ec61158504ede7f444bf,KeyguardStatusBarView.java,"@@ -149,10 +149,6 @@ public class KeyguardStatusBarView extends RelativeLayout
         lp.setMarginStart(getResources().getDimensionPixelSize(
                 R.dimen.system_icons_super_container_margin_start));
         mSystemIconsContainer.setLayoutParams(lp);
-        mSystemIconsContainer.setPaddingRelative(mSystemIconsContainer.getPaddingStart(),
-                mSystemIconsContainer.getPaddingTop(),
-                getResources().getDimensionPixelSize(R.dimen.system_icons_keyguard_padding_end),
-                mSystemIconsContainer.getPaddingBottom());
 
         // Respect font size setting.
         mCarrierLabel.setTextSize(TypedValue.COMPLEX_UNIT_PX,
",0,4,KeyguardStatusBarView::onConfigurationChanged
39,2807f50ea5f5263bb23039c42fa0c9dc1d736bf6,ScreenMediaRecorder.java,"@@ -48,6 +48,8 @@ import android.util.Size;
 import android.view.Surface;
 import android.view.WindowManager;
 
+import com.android.systemui.R;
+
 import java.io.File;
 import java.io.IOException;
 import java.io.OutputStream;
@@ -79,6 +81,7 @@ public class ScreenMediaRecorder {
     private ScreenRecordingMuxer mMuxer;
     private ScreenInternalAudioRecorder mAudio;
     private ScreenRecordingAudioSource mAudioSource;
+    private int mMaxRefreshRate;
 
     private Context mContext;
     MediaRecorder.OnInfoListener mListener;
@@ -90,6 +93,8 @@ public class ScreenMediaRecorder {
         mUser = user;
         mListener = listener;
         mAudioSource = audioSource;
+        mMaxRefreshRate = mContext.getResources().getInteger(
+                R.integer.config_screenRecorderMaxFramerate);
     }
 
     private void prepare() throws IOException, RemoteException {
@@ -127,6 +132,7 @@ public class ScreenMediaRecorder {
         int screenWidth = metrics.widthPixels;
         int screenHeight = metrics.heightPixels;
         int refereshRate = (int) wm.getDefaultDisplay().getRefreshRate();
+        if (mMaxRefreshRate != 0 && refereshRate > mMaxRefreshRate) refereshRate = mMaxRefreshRate;
         int vidBitRate = screenHeight * screenWidth * refereshRate / VIDEO_FRAME_RATE
                 * VIDEO_FRAME_RATE_TO_RESOLUTION_RATIO;
         mMediaRecorder.setVideoEncoder(MediaRecorder.VideoEncoder.H264);
",6,0,"ScreenMediaRecorder::prepare, ScreenMediaRecorder::ScreenMediaRecorder"
40,b6f3f9833f563fb9c4f5a1813104bd7d10462435,KeyguardStatusBarView.java,"@@ -154,14 +154,7 @@ public class KeyguardStatusBarView extends RelativeLayout
         mCarrierLabel.setTextSize(TypedValue.COMPLEX_UNIT_PX,
                 getResources().getDimensionPixelSize(
                         com.android.internal.R.dimen.text_size_small_material));
-        lp = (MarginLayoutParams) mCarrierLabel.getLayoutParams();
 
-        int marginStart = calculateMargin(
-                getResources().getDimensionPixelSize(R.dimen.keyguard_carrier_text_margin),
-                mPadding.first);
-        lp.setMarginStart(marginStart);
-
-        mCarrierLabel.setLayoutParams(lp);
         updateKeyguardStatusBarHeight();
     }
 
@@ -241,6 +234,7 @@ public class KeyguardStatusBarView extends RelativeLayout
         Pair<Integer, Integer> cornerCutoutMargins =
                 StatusBarWindowView.cornerCutoutMargins(mDisplayCutout, getDisplay());
         updatePadding(cornerCutoutMargins);
+        updateCarrierLabelParams();
         if (mDisplayCutout == null || cornerCutoutMargins != null) {
             return updateLayoutParamsNoCutout();
         } else {
@@ -257,6 +251,16 @@ public class KeyguardStatusBarView extends RelativeLayout
         setPadding(mPadding.first, waterfallTop, mPadding.second, 0);
     }
 
+    private void updateCarrierLabelParams() {
+        int marginStart = calculateMargin(
+                getResources().getDimensionPixelSize(R.dimen.keyguard_carrier_text_margin),
+                mPadding.first);
+        MarginLayoutParams lp = (MarginLayoutParams) mCarrierLabel.getLayoutParams();
+        lp.setMarginStart(marginStart);
+
+        mCarrierLabel.setLayoutParams(lp);
+    }
+
     private boolean updateLayoutParamsNoCutout() {
         if (mLayoutState == LAYOUT_NO_CUTOUT) {
             return false;
",11,7,"KeyguardStatusBarView::onConfigurationChanged, KeyguardStatusBarView::updateCarrierLabelParams, KeyguardStatusBarView::updateLayoutConsideringCutout"
41,9bf606b9a614ce1de6a9d75af2c75b5d4d4f1f9b,PhoneWindowManager.java,"@@ -561,6 +561,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
     private int mForceNavbar = -1;
 
     // Tracks user-customisable behavior for certain key events
+    private Action mBackLongPressAction;
     private Action mHomeLongPressAction;
     private Action mHomeDoubleTapAction;
     private Action mMenuPressAction;
@@ -776,7 +777,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                     showPictureInPictureMenuInternal();
                     break;
                 case MSG_BACK_LONG_PRESS:
-                    backLongPress();
+                    backLongPress((KeyEvent) msg.obj);
                     break;
                 case MSG_ACCESSIBILITY_SHORTCUT:
                     accessibilityShortcutActivated();
@@ -879,6 +880,9 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                     LineageSettings.System.TORCH_LONG_PRESS_POWER_TIMEOUT), false, this,
                     UserHandle.USER_ALL);
             resolver.registerContentObserver(LineageSettings.System.getUriFor(
+                    LineageSettings.System.KEY_BACK_LONG_PRESS_ACTION), false, this,
+                    UserHandle.USER_ALL);
+           resolver.registerContentObserver(LineageSettings.System.getUriFor(
                     LineageSettings.System.KEY_HOME_LONG_PRESS_ACTION), false, this,
                     UserHandle.USER_ALL);
             resolver.registerContentObserver(LineageSettings.System.getUriFor(
@@ -1014,13 +1018,13 @@ public class PhoneWindowManager implements WindowManagerPolicy {
         }
     }
 
-    private void interceptBackKeyDown() {
+    private void interceptBackKeyDown(KeyEvent event) {
         mLogger.count(""key_back_down"", 1);
         // Reset back key state for long press
         mBackKeyHandled = false;
 
         if (hasLongPressOnBackBehavior()) {
-            Message msg = mHandler.obtainMessage(MSG_BACK_LONG_PRESS);
+            Message msg = mHandler.obtainMessage(MSG_BACK_LONG_PRESS, event);
             msg.setAsynchronous(true);
             mHandler.sendMessageDelayed(msg,
                     ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout());
@@ -1458,16 +1462,12 @@ public class PhoneWindowManager implements WindowManagerPolicy {
         }
     }
 
-    private void backLongPress() {
+    private void backLongPress(KeyEvent event) {
         mBackKeyHandled = true;
 
-        switch (mLongPressOnBackBehavior) {
-            case LONG_PRESS_BACK_NOTHING:
-                break;
-            case LONG_PRESS_BACK_GO_TO_VOICE_ASSIST:
-                launchVoiceAssist(false /* allowDuringSetup */);
-                break;
-        }
+        performHapticFeedback(HapticFeedbackConstants.LONG_PRESS, false,
+                ""Back - Long Press"");
+        performKeyAction(mBackLongPressAction, event);
     }
 
     private void accessibilityShortcutActivated() {
@@ -1523,7 +1523,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
     }
 
     private boolean hasLongPressOnBackBehavior() {
-        return mLongPressOnBackBehavior != LONG_PRESS_BACK_NOTHING;
+        return mBackLongPressAction != Action.NOTHING;
     }
 
     private void interceptScreenshotChord() {
@@ -2304,6 +2304,16 @@ public class PhoneWindowManager implements WindowManagerPolicy {
 
         mEdgeLongSwipeAction = Action.NOTHING;
 
+        mBackLongPressAction = Action.fromIntSafe(res.getInteger(
+                org.lineageos.platform.internal.R.integer.config_longPressOnBackBehavior));
+        if (mBackLongPressAction.ordinal() > Action.SLEEP.ordinal()) {
+            mBackLongPressAction = Action.NOTHING;
+        }
+
+        mBackLongPressAction = Action.fromSettings(resolver,
+                LineageSettings.System.KEY_BACK_LONG_PRESS_ACTION,
+                mBackLongPressAction);
+
         mHomeLongPressAction = Action.fromIntSafe(res.getInteger(
                 org.lineageos.platform.internal.R.integer.config_longPressOnHomeBehavior));
         if (mHomeLongPressAction.ordinal() > Action.SLEEP.ordinal()) {
@@ -4244,7 +4254,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                 }
 
                 if (down) {
-                    interceptBackKeyDown();
+                    interceptBackKeyDown(event);
                 } else {
                     boolean handled = interceptBackKeyUp(event);
 
",23,13,"PhoneWindowManager::interceptBackKeyDown, PhoneWindowManager::interceptBackKeyDown, PhoneWindowManager::updateKeyAssignments, PhoneWindowManager::SettingsObserver::observe, PhoneWindowManager::backLongPress, PhoneWindowManager::interceptKeyBeforeQueueing, PhoneWindowManager::backLongPress, PhoneWindowManager::PolicyHandler::handleMessage, PhoneWindowManager::hasLongPressOnBackBehavior"
42,773c39a5871868044a07201e6b31f051b6eb8eba,PhoneWindowManager.java,"@@ -1828,6 +1828,9 @@ public class PhoneWindowManager implements WindowManagerPolicy {
             case SPLIT_SCREEN:
                 toggleSplitScreen();
                 break;
+            case KILL_APP:
+                ActionUtils.killForegroundApp(mContext, mCurrentUserId);
+                break;
             default:
                 break;
         }
",3,0,PhoneWindowManager::performKeyAction
43,e97818f314866868b1995ddb5ee9fe28e41ec790,WifiManager.java,"@@ -5274,6 +5274,71 @@ public class WifiManager {
         }
     }
 
+    /**
+     * @hide
+     */
+    public interface StaStateCallback {
+        /**
+         * @hide
+         */
+        void onStaToBeOff();
+    }
+
+    /**
+     * @hide
+     */
+    private class StaStateCallbackProxy extends IStaStateCallback.Stub {
+        private final Handler mHandler;
+        private final StaStateCallback mCallback;
+
+        StaStateCallbackProxy(Looper looper, StaStateCallback callback) {
+            mHandler = new Handler(looper);
+            mCallback = callback;
+        }
+
+        @Override
+        public void onStaToBeOff() {
+            if (mVerboseLoggingEnabled) {
+                Log.v(TAG, ""StaStateCallbackProxy: onStaToBeOff"");
+            }
+            mHandler.post(() -> {
+                mCallback.onStaToBeOff();
+            });
+        }
+    }
+
+    /**
+     * @hide
+     */
+    public void registerStaStateCallback(@NonNull StaStateCallback callback,
+                                             @Nullable Handler handler) {
+        if (callback == null) throw new IllegalArgumentException(""callback cannot be null"");
+        Log.v(TAG, ""registerStaStateCallback: callback="" + callback + "", handler="" + handler);
+
+        Looper looper = (handler == null) ? mContext.getMainLooper() : handler.getLooper();
+        Binder binder = new Binder();
+        try {
+            mService.registerStaStateCallback(
+                    binder, new StaStateCallbackProxy(looper, callback), callback.hashCode());
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    /**
+     * @hide
+     */
+    public void unregisterStaStateCallback(@NonNull StaStateCallback callback) {
+        if (callback == null) throw new IllegalArgumentException(""callback cannot be null"");
+        Log.v(TAG, ""unregisterStaStateCallback: callback="" + callback);
+
+        try {
+            mService.unregisterStaStateCallback(callback.hashCode());
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
     /**
      * Helper method to update the local verbose logging flag based on the verbose logging
      * level from wifi service.
",65,0,"WifiManager::unregisterStaStateCallback, WifiManager::StaStateCallbackProxy::onStaToBeOff, WifiManager::StaStateCallbackProxy::StaStateCallbackProxy, WifiManager::registerStaStateCallback"
44,c3805604ef5323aa349e2f8c89abc8e32cf0941d,VolumeDialogImpl.java,"@@ -707,6 +707,7 @@ public class VolumeDialogImpl implements VolumeDialog,
     private void initODICaptionsH() {
         if (mODICaptionsIcon != null) {
             mODICaptionsIcon.setOnConfirmedTapListener(() -> {
+                rescheduleTimeoutH();
                 onCaptionIconClicked();
                 Events.writeEvent(Events.EVENT_ODI_CAPTIONS_CLICK);
             }, mHandler);
",1,0,VolumeDialogImpl::initODICaptionsH
45,678a06b709f35c37faa2c4a3c500c2eb4c0d6232,VolumeDialogImpl.java,"@@ -989,6 +989,8 @@ public class VolumeDialogImpl implements VolumeDialog,
                     mAllyStream = -1;
                     mMusicHidden = false;
                     tryToRemoveCaptionsTooltip();
+                    mDialog.getViewTreeObserver().removeOnComputeInternalInsetsListener(
+                            mInsetsListener);
                     mController.notifyVisible(false);
                 }, 50));
         if (!isLandscape() || !mShowActiveStreamOnly) animator.translationX(getAnimatorX());
",2,0,VolumeDialogImpl::dismissH
46,b0675cecd76f907284d7dfb0a266fcd663f4fa6f,VolumeDialogImpl.java,"@@ -376,9 +376,9 @@ public class VolumeDialogImpl implements VolumeDialog,
         internalInsetsInfo.setTouchableInsets(InternalInsetsInfo.TOUCHABLE_INSETS_REGION);
         View main = mDialog.findViewById(R.id.main);
         int[] mainLocation = new int[2];
-        main.getLocationOnScreen(mainLocation);
+        main.getLocationInWindow(mainLocation);
         int[] dialogLocation = new int[2];
-        mDialogView.getLocationOnScreen(dialogLocation);
+        mDialogView.getLocationInWindow(dialogLocation);
         internalInsetsInfo.touchableRegion.set(new Region(
                 mainLocation[0],
                 dialogLocation[1],
",2,2,
47,5921a436984295af3491037de42c406e26193d62,ReadingModeTile.java,"@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2018-2020 The LineageOS Project
+ * Copyright (C) 2018-2021 The LineageOS Project
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
@@ -25,7 +25,6 @@ import com.android.systemui.qs.tileimpl.QSTileImpl;
 import com.android.systemui.R;
 
 import org.lineageos.internal.logging.LineageMetricsLogger;
-import org.lineageos.internal.util.PackageManagerUtils;
 
 import lineageos.hardware.LineageHardwareManager;
 import lineageos.providers.LineageSettings;
@@ -65,8 +64,7 @@ public class ReadingModeTile extends QSTileImpl<BooleanState> {
 
     @Override
     public boolean isAvailable() {
-        return !isWellbeingEnabled() &&
-                mHardware.isSupported(LineageHardwareManager.FEATURE_READING_ENHANCEMENT);
+        return mHardware.isSupported(LineageHardwareManager.FEATURE_READING_ENHANCEMENT);
     }
 
     @Override
@@ -113,9 +111,4 @@ public class ReadingModeTile extends QSTileImpl<BooleanState> {
     private boolean isReadingModeEnabled() {
         return mHardware.get(LineageHardwareManager.FEATURE_READING_ENHANCEMENT);
     }
-
-    private boolean isWellbeingEnabled() {
-        return PackageManagerUtils.isAppEnabled(mContext,
-                mContext.getString(com.android.internal.R.string.config_defaultWellbeingPackage));
-    }
 }
",2,9,"ReadingModeTile::isWellbeingEnabled, ReadingModeTile::isAvailable"
48,de06a3c7cc67bb116f321a8e0c192585eb1e6c9e,FODCircleView.java,"@@ -167,7 +167,7 @@ public class FODCircleView extends ImageView {
         }
 
         @Override
-        public void onStartedGoingToSleep(int why) {
+        public void onScreenTurnedOff() {
             hide();
         }
 
",1,1,FODCircleView::KeyguardUpdateMonitorCallback
49,600d04c1e5822d3cadeb752b142a80553b424582,ConnectivityService.java,"@@ -2061,7 +2061,8 @@ public class ConnectivityService extends IConnectivityManager.Stub
         reattachNetworkRequestsForUid(uid);
     }
 
-    private boolean isUidIsolated(int uid) {
+    @Override
+    public boolean isUidIsolated(int uid) {
         synchronized (mIsolatedUids) {
             return mIsolatedUids.get(uid);
         }
",2,1,ConnectivityService::isUidIsolated
50,b5632e3ae323675db4243c451f91ec63f88339d5,GlobalActionsDialog.java,"@@ -1,7 +1,7 @@
 /*
  * Copyright (C) 2017 The Android Open Source Project
  * Copyright (C) 2010-2015 CyanogenMod Project
- * Copyright (C) 2017-2020 The LineageOS Project
+ * Copyright (C) 2017-2021 The LineageOS Project
  *
  * Licensed under the Apache License, Version 2.0 (the ""License""); you may not use this file
  * except in compliance with the License. You may obtain a copy of the License at
@@ -22,7 +22,6 @@ import static android.view.WindowManager.LayoutParams.LAYOUT_IN_DISPLAY_CUTOUT_M
 import static android.view.WindowManager.ScreenshotSource.SCREENSHOT_GLOBAL_ACTIONS;
 import static android.view.WindowManager.TAKE_SCREENSHOT_FULLSCREEN;
 import static android.view.WindowManager.TAKE_SCREENSHOT_SELECTED_REGION;
-import static android.view.WindowManagerPolicyConstants.NAV_BAR_MODE_2BUTTON;
 
 import static com.android.internal.widget.LockPatternUtils.StrongAuthTracker.SOME_AUTH_REQUIRED_AFTER_USER_REQUEST;
 import static com.android.internal.widget.LockPatternUtils.StrongAuthTracker.STRONG_AUTH_NOT_REQUIRED;
@@ -30,6 +29,8 @@ import static com.android.internal.widget.LockPatternUtils.StrongAuthTracker.STR
 import static com.android.internal.widget.LockPatternUtils.StrongAuthTracker.STRONG_AUTH_REQUIRED_AFTER_USER_LOCKDOWN;
 import static com.android.systemui.shared.system.QuickStepContract.SYSUI_STATE_GLOBAL_ACTIONS_SHOWING;
 
+import static org.lineageos.internal.util.PowerMenuConstants.*;
+
 import android.animation.Animator;
 import android.animation.AnimatorListenerAdapter;
 import android.animation.AnimatorSet;
@@ -55,7 +56,15 @@ import android.content.pm.UserInfo;
 import android.content.res.ColorStateList;
 import android.content.res.Resources;
 import android.database.ContentObserver;
+import android.graphics.Bitmap;
+import android.graphics.BitmapShader;
+import android.graphics.Canvas;
 import android.graphics.Color;
+import android.graphics.Matrix;
+import android.graphics.Paint;
+import android.graphics.RectF;
+import android.graphics.Shader;
+import android.graphics.drawable.BitmapDrawable;
 import android.graphics.drawable.Drawable;
 import android.media.AudioManager;
 import android.net.ConnectivityManager;
@@ -117,6 +126,7 @@ import com.android.internal.statusbar.IStatusBarService;
 import com.android.internal.util.EmergencyAffordanceManager;
 import com.android.internal.util.ScreenRecordHelper;
 import com.android.internal.util.ScreenshotHelper;
+import com.android.internal.util.UserIcons;
 import com.android.internal.view.RotationPolicy;
 import com.android.internal.widget.LockPatternUtils;
 import com.android.systemui.Interpolators;
@@ -144,6 +154,7 @@ import com.android.systemui.util.EmergencyDialerConstants;
 import com.android.systemui.util.RingerModeTracker;
 import com.android.systemui.util.leak.RotationUtils;
 
+import lineageos.app.LineageGlobalActions;
 import lineageos.providers.LineageSettings;
 import org.lineageos.internal.util.PowerMenuUtils;
 
@@ -176,23 +187,6 @@ public class GlobalActionsDialog implements DialogInterface.OnDismissListener,
 
     private static final boolean SHOW_SILENT_TOGGLE = true;
 
-    /* Valid settings for global actions keys.
-     * see config.xml config_globalActionList */
-    @VisibleForTesting
-    static final String GLOBAL_ACTION_KEY_POWER = ""power"";
-    private static final String GLOBAL_ACTION_KEY_AIRPLANE = ""airplane"";
-    static final String GLOBAL_ACTION_KEY_BUGREPORT = ""bugreport"";
-    private static final String GLOBAL_ACTION_KEY_SILENT = ""silent"";
-    private static final String GLOBAL_ACTION_KEY_USERS = ""users"";
-    private static final String GLOBAL_ACTION_KEY_SETTINGS = ""settings"";
-    static final String GLOBAL_ACTION_KEY_LOCKDOWN = ""lockdown"";
-    private static final String GLOBAL_ACTION_KEY_VOICEASSIST = ""voiceassist"";
-    private static final String GLOBAL_ACTION_KEY_ASSIST = ""assist"";
-    static final String GLOBAL_ACTION_KEY_RESTART = ""restart"";
-    private static final String GLOBAL_ACTION_KEY_LOGOUT = ""logout"";
-    static final String GLOBAL_ACTION_KEY_EMERGENCY = ""emergency"";
-    static final String GLOBAL_ACTION_KEY_SCREENSHOT = ""screenshot"";
-
     /* Valid settings for restart actions keys.
      * see lineage-sdk config.xml config_restartActionsList */
     private static final String RESTART_ACTION_KEY_RESTART = ""restart"";
@@ -224,6 +218,7 @@ public class GlobalActionsDialog implements DialogInterface.OnDismissListener,
     private final UiEventLogger mUiEventLogger;
     private final NotificationShadeDepthController mDepthController;
     private final SysUiState mSysUiState;
+    private final LineageGlobalActions mLineageGlobalActions;
 
     // Used for RingerModeTracker
     private final LifecycleRegistry mLifecycle = new LifecycleRegistry(this);
@@ -310,6 +305,9 @@ public class GlobalActionsDialog implements DialogInterface.OnDismissListener,
         }
     }
 
+    // Power menu customizations
+    private String[] mActions;
+
     /**
      * @param context everything needs a context :(
      */
@@ -362,12 +360,14 @@ public class GlobalActionsDialog implements DialogInterface.OnDismissListener,
         mSysUiState = sysUiState;
         mMainHandler = handler;
         mCurrentUserContextTracker = currentUserContextTracker;
+        mLineageGlobalActions = LineageGlobalActions.getInstance(mContext);
 
         // receive broadcasts
         IntentFilter filter = new IntentFilter();
         filter.addAction(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
         filter.addAction(Intent.ACTION_SCREEN_OFF);
         filter.addAction(TelephonyManager.ACTION_EMERGENCY_CALLBACK_MODE_CHANGED);
+        filter.addAction(lineageos.content.Intent.ACTION_UPDATE_POWER_MENU);
         mBroadcastDispatcher.registerReceiver(mBroadcastReceiver, filter);
 
         mHasTelephony = connectivityManager.isNetworkSupported(ConnectivityManager.TYPE_MOBILE);
@@ -439,6 +439,8 @@ public class GlobalActionsDialog implements DialogInterface.OnDismissListener,
                         onPowerMenuLockScreenSettingsChanged();
                     }
                 });
+
+        mActions = mLineageGlobalActions.getUserActionsArray();
     }
 
     /**
@@ -627,7 +629,6 @@ public class GlobalActionsDialog implements DialogInterface.OnDismissListener,
         mOverflowItems.clear();
         mPowerItems.clear();
         mRestartItems.clear();
-        String[] defaultActions = getDefaultActions();
         String[] restartActions = getRestartActions();
 
         ShutDownAction shutdownAction = new ShutDownAction();
@@ -648,8 +649,8 @@ public class GlobalActionsDialog implements DialogInterface.OnDismissListener,
             addedKeys.add(GLOBAL_ACTION_KEY_EMERGENCY);
         }
 
-        for (int i = 0; i < defaultActions.length; i++) {
-            String actionKey = defaultActions[i];
+        for (int i = 0; i < mActions.length; i++) {
+            String actionKey = mActions[i];
             if (addedKeys.contains(actionKey)) {
                 // If we already have added this, don't add it again.
                 continue;
@@ -667,7 +668,8 @@ public class GlobalActionsDialog implements DialogInterface.OnDismissListener,
                     addIfShouldShowAction(tempActions, mSilentModeAction);
                 }
             } else if (GLOBAL_ACTION_KEY_USERS.equals(actionKey)) {
-                if (SystemProperties.getBoolean(""fw.power_user_switcher"", false)) {
+                List<UserInfo> users = mUserManager.getUsers();
+                if (users.size() > 1) {
                     addUserActions(tempActions, currentUser.get());
                 }
             } else if (GLOBAL_ACTION_KEY_SETTINGS.equals(actionKey)) {
@@ -1143,7 +1145,6 @@ public class GlobalActionsDialog implements DialogInterface.OnDismissListener,
 
     @VisibleForTesting
     class ScreenshotAction extends SinglePressAction implements LongPressAction {
-        final String KEY_SYSTEM_NAV_2BUTTONS = ""system_nav_2buttons"";
 
         public ScreenshotAction() {
             super(R.drawable.ic_screenshot, R.string.global_action_screenshot);
@@ -1176,19 +1177,6 @@ public class GlobalActionsDialog implements DialogInterface.OnDismissListener,
             return false;
         }
 
-        @Override
-        public boolean shouldShow() {
-          // Include screenshot in power menu for legacy nav because it is not accessible
-          // through Recents in that mode
-            return is2ButtonNavigationEnabled();
-        }
-
-        boolean is2ButtonNavigationEnabled() {
-            return NAV_BAR_MODE_2BUTTON == mContext.getResources().getInteger(
-                    com.android.internal.R.integer.config_navBarInteractionMode);
-        }
-
-
         @Override
         public boolean onLongPress() {
             if (FeatureFlagUtils.isEnabled(mContext, FeatureFlagUtils.SCREENRECORD_LONG_PRESS)) {
@@ -1441,14 +1429,23 @@ public class GlobalActionsDialog implements DialogInterface.OnDismissListener,
     private void addUserActions(List<Action> actions, UserInfo currentUser) {
         if (mUserManager.isUserSwitcherEnabled()) {
             List<UserInfo> users = mUserManager.getUsers();
+            final int avatarSize = mContext.getResources().getDimensionPixelSize(
+                    com.android.systemui.R.dimen.global_actions_avatar_size);
             for (final UserInfo user : users) {
                 if (user.supportsSwitchToByUser()) {
                     boolean isCurrentUser = currentUser == null
                             ? user.id == 0 : (currentUser.id == user.id);
-                    Drawable icon = user.iconPath != null ? Drawable.createFromPath(user.iconPath)
-                            : null;
+                    Drawable avatar = null;
+                    Bitmap rawAvatar = mUserManager.getUserIcon(user.id);
+                    if (rawAvatar == null) {
+                        rawAvatar = UserIcons.convertToBitmap(UserIcons.getDefaultUserIcon(
+                                mContext.getResources(),
+                                user.isGuest() ? UserHandle.USER_NULL : user.id, /*light=*/ false));
+                    }
+                    avatar = new BitmapDrawable(mContext.getResources(),
+                            createCircularClip(rawAvatar, avatarSize, avatarSize));
                     SinglePressAction switchToUser = new SinglePressAction(
-                            R.drawable.ic_menu_cc, icon,
+                            com.android.systemui.R.drawable.ic_lock_user, avatar,
                             (user.name != null ? user.name : ""Primary"")
                                     + (isCurrentUser ? "" \u2714"" : """")) {
                         public void onPress() {
@@ -1467,6 +1464,10 @@ public class GlobalActionsDialog implements DialogInterface.OnDismissListener,
                             return false;
                         }
                     };
+                    if (isCurrentUser) {
+                        switchToUser.setStatus(mContext.getString(
+                                com.android.systemui.R.string.global_action_current_user));
+                    }
                     addIfShouldShowAction(actions, switchToUser);
                 }
             }
@@ -1849,6 +1850,7 @@ public class GlobalActionsDialog implements DialogInterface.OnDismissListener,
         private final Drawable mIcon;
         private final int mMessageResId;
         private final CharSequence mMessage;
+        private CharSequence mStatusMessage;
 
         protected SinglePressAction(int iconResId, int messageResId) {
             mIconResId = iconResId;
@@ -1868,8 +1870,12 @@ public class GlobalActionsDialog implements DialogInterface.OnDismissListener,
             return true;
         }
 
-        public String getStatus() {
-            return null;
+        public CharSequence getStatus() {
+            return mStatusMessage;
+        }
+
+        public void setStatus(CharSequence status) {
+            mStatusMessage = status;
         }
 
         abstract public void onPress();
@@ -2069,8 +2075,8 @@ public class GlobalActionsDialog implements DialogInterface.OnDismissListener,
     private class AirplaneModeAction extends ToggleAction {
         AirplaneModeAction() {
             super(
-                    R.drawable.ic_lock_airplane_mode,
-                    R.drawable.ic_lock_airplane_mode_off,
+                    com.android.systemui.R.drawable.ic_lock_airplane_mode_enabled,
+                    com.android.systemui.R.drawable.ic_lock_airplane_mode_disabled,
                     R.string.global_actions_toggle_airplane_mode,
                     R.string.global_actions_airplane_mode_on_status,
                     R.string.global_actions_airplane_mode_off_status);
@@ -2237,6 +2243,8 @@ public class GlobalActionsDialog implements DialogInterface.OnDismissListener,
                     mIsWaitingForEcmExit = false;
                     changeAirplaneModeSystemSetting(true);
                 }
+            } else if (lineageos.content.Intent.ACTION_UPDATE_POWER_MENU.equals(action)) {
+                mActions = mLineageGlobalActions.getUserActionsArray();
             }
         }
     };
@@ -2327,6 +2335,33 @@ public class GlobalActionsDialog implements DialogInterface.OnDismissListener,
         return mLifecycle;
     }
 
+    /**
+     * Generate a new bitmap (width x height pixels, ARGB_8888) with the input bitmap scaled
+     * to fit and clipped to an inscribed circle.
+     * @param input Bitmap to resize and clip
+     * @param width Width of output bitmap (and diameter of circle)
+     * @param height Height of output bitmap
+     * @return A shiny new bitmap for you to use
+     */
+    private static Bitmap createCircularClip(Bitmap input, int width, int height) {
+        if (input == null) return null;
+
+        final int inWidth = input.getWidth();
+        final int inHeight = input.getHeight();
+        final Bitmap output = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
+        final Canvas canvas = new Canvas(output);
+        final Paint paint = new Paint();
+        paint.setShader(new BitmapShader(input, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP));
+        paint.setAntiAlias(true);
+        final RectF srcRect = new RectF(0, 0, inWidth, inHeight);
+        final RectF dstRect = new RectF(0, 0, width, height);
+        final Matrix m = new Matrix();
+        m.setRectToRect(srcRect, dstRect, Matrix.ScaleToFit.CENTER);
+        canvas.setMatrix(m);
+        canvas.drawCircle(inWidth / 2, inHeight / 2, inWidth / 2, paint);
+        return output;
+    }
+
     @VisibleForTesting
     static final class ActionsDialog extends Dialog implements DialogInterface,
             ColorExtractor.OnColorsChangedListener {
",79,44,"GlobalActionsDialog::GlobalActionsDialog, GlobalActionsDialog::AirplaneModeAction::AirplaneModeAction, GlobalActionsDialog::SinglePressAction::setStatus, GlobalActionsDialog::ScreenshotAction::shouldShow, GlobalActionsDialog::SinglePressAction::getStatus, GlobalActionsDialog::BroadcastReceiver, GlobalActionsDialog::addUserActions, GlobalActionsDialog::ScreenshotAction::is2ButtonNavigationEnabled, GlobalActionsDialog::createActionItems, GlobalActionsDialog::createCircularClip"
51,2ca394b51030666edbab57775e1b7c30ae9c334b,GlobalActionsDialog.java,"@@ -129,6 +129,7 @@ import com.android.internal.util.ScreenshotHelper;
 import com.android.internal.util.UserIcons;
 import com.android.internal.view.RotationPolicy;
 import com.android.internal.widget.LockPatternUtils;
+import com.android.systemui.Dependency;
 import com.android.systemui.Interpolators;
 import com.android.systemui.MultiListLayout;
 import com.android.systemui.MultiListLayout.MultiListAdapter;
@@ -150,6 +151,7 @@ import com.android.systemui.statusbar.NotificationShadeDepthController;
 import com.android.systemui.statusbar.phone.NotificationShadeWindowController;
 import com.android.systemui.statusbar.policy.ConfigurationController;
 import com.android.systemui.statusbar.policy.KeyguardStateController;
+import com.android.systemui.tuner.TunerService;
 import com.android.systemui.util.EmergencyDialerConstants;
 import com.android.systemui.util.RingerModeTracker;
 import com.android.systemui.util.leak.RotationUtils;
@@ -177,7 +179,7 @@ public class GlobalActionsDialog implements DialogInterface.OnDismissListener,
         DialogInterface.OnShowListener,
         ConfigurationController.ConfigurationListener,
         GlobalActionsPanelPlugin.Callbacks,
-        LifecycleOwner {
+        LifecycleOwner, TunerService.Tunable {
 
     public static final String SYSTEM_DIALOG_REASON_KEY = ""reason"";
     public static final String SYSTEM_DIALOG_REASON_GLOBAL_ACTIONS = ""globalactions"";
@@ -199,6 +201,9 @@ public class GlobalActionsDialog implements DialogInterface.OnDismissListener,
     public static final String PREFS_CONTROLS_FILE = ""controls_prefs"";
     private static final int SEEDING_MAX = 2;
 
+    private static final String POWER_MENU_ACTIONS_STRING =
+            ""lineagesecure:"" + LineageSettings.Secure.POWER_MENU_ACTIONS;
+
     private final Context mContext;
     private final GlobalActionsManager mWindowManagerFuncs;
     private final AudioManager mAudioManager;
@@ -367,7 +372,6 @@ public class GlobalActionsDialog implements DialogInterface.OnDismissListener,
         filter.addAction(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
         filter.addAction(Intent.ACTION_SCREEN_OFF);
         filter.addAction(TelephonyManager.ACTION_EMERGENCY_CALLBACK_MODE_CHANGED);
-        filter.addAction(lineageos.content.Intent.ACTION_UPDATE_POWER_MENU);
         mBroadcastDispatcher.registerReceiver(mBroadcastReceiver, filter);
 
         mHasTelephony = connectivityManager.isNetworkSupported(ConnectivityManager.TYPE_MOBILE);
@@ -440,6 +444,8 @@ public class GlobalActionsDialog implements DialogInterface.OnDismissListener,
                     }
                 });
 
+        Dependency.get(TunerService.class).addTunable(this, POWER_MENU_ACTIONS_STRING);
+
         mActions = mLineageGlobalActions.getUserActionsArray();
     }
 
@@ -2243,8 +2249,6 @@ public class GlobalActionsDialog implements DialogInterface.OnDismissListener,
                     mIsWaitingForEcmExit = false;
                     changeAirplaneModeSystemSetting(true);
                 }
-            } else if (lineageos.content.Intent.ACTION_UPDATE_POWER_MENU.equals(action)) {
-                mActions = mLineageGlobalActions.getUserActionsArray();
             }
         }
     };
@@ -2263,6 +2267,13 @@ public class GlobalActionsDialog implements DialogInterface.OnDismissListener,
         }
     };
 
+    @Override
+    public void onTuningChanged(String key, String newValue) {
+        if (POWER_MENU_ACTIONS_STRING.equals(key)) {
+            mActions = mLineageGlobalActions.getUserActionsArray();
+        }
+    }
+
     private ContentObserver mAirplaneModeObserver = new ContentObserver(mMainHandler) {
         @Override
         public void onChange(boolean selfChange) {
",15,4,"GlobalActionsDialog::GlobalActionsDialog, GlobalActionsDialog::onTuningChanged, GlobalActionsDialog::BroadcastReceiver"
52,d68b0efb442a405e4c7aa6cb574cf2d085ff2d45,GlobalActionsDialog.java,"@@ -236,6 +236,8 @@ public class GlobalActionsDialog implements DialogInterface.OnDismissListener,
     protected final ArrayList<Action> mPowerItems = new ArrayList<>();
     @VisibleForTesting
     protected final ArrayList<Action> mRestartItems = new ArrayList<>();
+    @VisibleForTesting
+    protected final ArrayList<Action> mUsersItems = new ArrayList<>();
 
     @VisibleForTesting
     protected ActionsDialog mDialog;
@@ -247,6 +249,7 @@ public class GlobalActionsDialog implements DialogInterface.OnDismissListener,
     private MyOverflowAdapter mOverflowAdapter;
     private MyPowerOptionsAdapter mPowerAdapter;
     private MyRestartOptionsAdapter mRestartAdapter;
+    private MyUsersAdapter mUsersAdapter;
 
     private boolean mKeyguardShowing = false;
     private boolean mDeviceProvisioned = false;
@@ -635,6 +638,7 @@ public class GlobalActionsDialog implements DialogInterface.OnDismissListener,
         mOverflowItems.clear();
         mPowerItems.clear();
         mRestartItems.clear();
+        mUsersItems.clear();
         String[] restartActions = getRestartActions();
 
         ShutDownAction shutdownAction = new ShutDownAction();
@@ -676,7 +680,8 @@ public class GlobalActionsDialog implements DialogInterface.OnDismissListener,
             } else if (GLOBAL_ACTION_KEY_USERS.equals(actionKey)) {
                 List<UserInfo> users = mUserManager.getUsers();
                 if (users.size() > 1) {
-                    addUserActions(tempActions, currentUser.get());
+                    addUserActions(mUsersItems, currentUser.get());
+                    addIfShouldShowAction(tempActions, new UsersAction());
                 }
             } else if (GLOBAL_ACTION_KEY_SETTINGS.equals(actionKey)) {
                 addIfShouldShowAction(tempActions, getSettingsAction());
@@ -764,6 +769,7 @@ public class GlobalActionsDialog implements DialogInterface.OnDismissListener,
         mOverflowAdapter = new MyOverflowAdapter();
         mPowerAdapter = new MyPowerOptionsAdapter();
         mRestartAdapter = new MyRestartOptionsAdapter();
+        mUsersAdapter = new MyUsersAdapter();
 
         mDepthController.setShowingHomeControls(true);
         ControlsUiController uiController = null;
@@ -774,7 +780,8 @@ public class GlobalActionsDialog implements DialogInterface.OnDismissListener,
                 this::getWalletViewController, mDepthController, mSysuiColorExtractor,
                 mStatusBarService, mNotificationShadeWindowController,
                 controlsAvailable(), uiController,
-                mSysUiState, this::onRotate, mKeyguardShowing, mPowerAdapter, mRestartAdapter);
+                mSysUiState, this::onRotate, mKeyguardShowing, mPowerAdapter, mRestartAdapter,
+                mUsersAdapter);
 
         if (shouldShowLockMessage(dialog)) {
             dialog.showLockMessage();
@@ -1406,6 +1413,31 @@ public class GlobalActionsDialog implements DialogInterface.OnDismissListener,
         }
     }
 
+    @VisibleForTesting
+    final class UsersAction extends SinglePressAction {
+        private UsersAction() {
+            super(com.android.systemui.R.drawable.ic_lock_user,
+                    com.android.systemui.R.string.global_action_users);
+        }
+
+        @Override
+        public boolean showDuringKeyguard() {
+            return true;
+        }
+
+        @Override
+        public boolean showBeforeProvisioning() {
+            return false;
+        }
+
+        @Override
+        public void onPress() {
+            if (mDialog != null) {
+                mDialog.showUsersMenu();
+            }
+        }
+    }
+
     private UserInfo getCurrentUser() {
         try {
             return mIActivityManager.getCurrentUser();
@@ -1615,7 +1647,8 @@ public class GlobalActionsDialog implements DialogInterface.OnDismissListener,
                 if (mDialog != null) {
                     // don't dismiss the dialog if we're opening the power/restart options menu
                     if (!(item instanceof PowerOptionsAction ||
-                            (item instanceof RestartAction && shouldShowRestartSubmenu()))) {
+                            (item instanceof RestartAction && shouldShowRestartSubmenu()) ||
+                            (item instanceof UsersAction))) {
                         mDialog.dismiss();
                     }
                 } else {
@@ -1772,7 +1805,65 @@ public class GlobalActionsDialog implements DialogInterface.OnDismissListener,
         private void onClickItem(int position) {
             Action item = getItem(position);
             if (!(item instanceof SilentModeTriStateAction)) {
-                if (mDialog != null) {
+                if (mDialog != null && !(item instanceof UsersAction)) {
+                    mDialog.dismiss();
+                } else {
+                    Log.w(TAG, ""Action clicked while mDialog is null."");
+                }
+                item.onPress();
+            }
+        }
+    }
+
+    /**
+     * The adapter used for items in the users menu.
+     */
+    public class MyUsersAdapter extends BaseAdapter {
+        @Override
+        public int getCount() {
+            return mUsersItems.size();
+        }
+
+        @Override
+        public Action getItem(int position) {
+            return mUsersItems.get(position);
+        }
+
+        @Override
+        public long getItemId(int position) {
+            return position;
+        }
+
+        @Override
+        public View getView(int position, View convertView, ViewGroup parent) {
+            Action action = getItem(position);
+            if (action == null) {
+                Log.w(TAG, ""No users action found at position: "" + position);
+                return null;
+            }
+            int viewLayoutResource = com.android.systemui.R.layout.global_actions_power_item;
+            View view = convertView != null ? convertView
+                    : LayoutInflater.from(mContext).inflate(viewLayoutResource, parent, false);
+            view.setOnClickListener(v -> onClickItem(position));
+            ImageView icon = view.findViewById(R.id.icon);
+            TextView messageView = view.findViewById(R.id.message);
+            messageView.setSelected(true); // necessary for marquee to work
+
+            icon.setImageDrawable(action.getIcon(mContext));
+            icon.setScaleType(ScaleType.CENTER_CROP);
+
+            if (action.getMessage() != null) {
+                messageView.setText(action.getMessage());
+            } else {
+                messageView.setText(action.getMessageResId());
+            }
+            return view;
+        }
+
+        private void onClickItem(int position) {
+            Action item = getItem(position);
+            if (!(item instanceof SilentModeTriStateAction)) {
+                if (mDialog != null && !(item instanceof UsersAction)) {
                     mDialog.dismiss();
                 } else {
                     Log.w(TAG, ""Action clicked while mDialog is null."");
@@ -2382,6 +2473,7 @@ public class GlobalActionsDialog implements DialogInterface.OnDismissListener,
         private final MyOverflowAdapter mOverflowAdapter;
         private final MyPowerOptionsAdapter mPowerOptionsAdapter;
         private final MyRestartOptionsAdapter mRestartOptionsAdapter;
+        private final MyUsersAdapter mUsersAdapter;
         private final IStatusBarService mStatusBarService;
         private final IBinder mToken = new Binder();
         private MultiListLayout mGlobalActionsLayout;
@@ -2399,6 +2491,7 @@ public class GlobalActionsDialog implements DialogInterface.OnDismissListener,
         private ListPopupWindow mOverflowPopup;
         private Dialog mPowerOptionsDialog;
         private Dialog mRestartOptionsDialog;
+        private Dialog mUsersDialog;
         private final Runnable mOnRotateCallback;
         private final boolean mControlsAvailable;
 
@@ -2415,13 +2508,15 @@ public class GlobalActionsDialog implements DialogInterface.OnDismissListener,
                 NotificationShadeWindowController notificationShadeWindowController,
                 boolean controlsAvailable, @Nullable ControlsUiController controlsUiController,
                 SysUiState sysuiState, Runnable onRotateCallback, boolean keyguardShowing,
-                MyPowerOptionsAdapter powerAdapter, MyRestartOptionsAdapter restartAdapter) {
+                MyPowerOptionsAdapter powerAdapter, MyRestartOptionsAdapter restartAdapter,
+                MyUsersAdapter usersAdapter) {
             super(context, com.android.systemui.R.style.Theme_SystemUI_Dialog_GlobalActions);
             mContext = context;
             mAdapter = adapter;
             mOverflowAdapter = overflowAdapter;
             mPowerOptionsAdapter = powerAdapter;
             mRestartOptionsAdapter = restartAdapter;
+            mUsersAdapter = usersAdapter;
             mDepthController = depthController;
             mColorExtractor = sysuiColorExtractor;
             mStatusBarService = statusBarService;
@@ -2573,6 +2668,11 @@ public class GlobalActionsDialog implements DialogInterface.OnDismissListener,
             mOverflowPopup.show();
         }
 
+        public void showUsersMenu() {
+            mUsersDialog = GlobalActionsPowerDialog.create(mContext, mUsersAdapter);
+            mUsersDialog.show();
+        }
+
         private void initializeLayout() {
             setContentView(com.android.systemui.R.layout.global_actions_grid_v2);
             fixNavBarClipping();
@@ -2749,6 +2849,7 @@ public class GlobalActionsDialog implements DialogInterface.OnDismissListener,
                 dismissOverflow(false);
                 dismissPowerOptions(false);
                 dismissRestartOptions(false);
+                dismissUsers(false);
                 if (mControlsUiController != null) mControlsUiController.closeDialogs(false);
             });
         }
@@ -2775,6 +2876,7 @@ public class GlobalActionsDialog implements DialogInterface.OnDismissListener,
             dismissOverflow(true);
             dismissPowerOptions(true);
             dismissRestartOptions(true);
+            dismissUsers(true);
             if (mControlsUiController != null) mControlsUiController.hide();
             mNotificationShadeWindowController.setRequestTopUi(false, TAG);
             mDepthController.updateGlobalDialogVisibility(0, null /* view */);
@@ -2821,6 +2923,16 @@ public class GlobalActionsDialog implements DialogInterface.OnDismissListener,
             }
         }
 
+        private void dismissUsers(boolean immediate) {
+            if (mUsersDialog != null) {
+                if (immediate) {
+                    mUsersDialog.dismiss();
+                } else {
+                    mUsersDialog.dismiss();
+                }
+            }
+        }
+
         private void setRotationSuggestionsEnabled(boolean enabled) {
             try {
                 final int userId = Binder.getCallingUserHandle().getIdentifier();
@@ -2866,6 +2978,7 @@ public class GlobalActionsDialog implements DialogInterface.OnDismissListener,
             dismissOverflow(true);
             dismissPowerOptions(true);
             dismissRestartOptions(true);
+            dismissUsers(true);
             if (mControlsUiController != null) {
                 mControlsUiController.hide();
             }
",118,5,"GlobalActionsDialog::ActionsDialog::showUsersMenu, GlobalActionsDialog::UsersAction::UsersAction, GlobalActionsDialog::ActionsDialog::dismissUsers, GlobalActionsDialog::createDialog, GlobalActionsDialog::createActionItems, GlobalActionsDialog::ActionsDialog::completeDismiss, GlobalActionsDialog::MyUsersAdapter::getView, GlobalActionsDialog::MyUsersAdapter::getItemId, GlobalActionsDialog::UsersAction::onPress, GlobalActionsDialog::UsersAction::showDuringKeyguard, GlobalActionsDialog::MyAdapter::onClickItem, GlobalActionsDialog::ActionsDialog::ActionsDialog, GlobalActionsDialog::ActionsDialog::refreshDialog, GlobalActionsDialog::MyUsersAdapter::onClickItem, GlobalActionsDialog::MyOverflowAdapter::onClickItem, GlobalActionsDialog::ActionsDialog::dismiss, GlobalActionsDialog::ActionsDialog::ActionsDialog, GlobalActionsDialog::UsersAction::showBeforeProvisioning, GlobalActionsDialog::MyUsersAdapter::getCount, GlobalActionsDialog::MyUsersAdapter::getItem"
53,5ce924dca11eec89dbdb59f4bf8b56407beced49,GlobalActionsDialog.java,"@@ -82,8 +82,6 @@ import android.provider.Settings;
 import android.service.dreams.IDreamManager;
 import android.sysprop.TelephonyProperties;
 import android.telecom.TelecomManager;
-import android.telephony.PhoneStateListener;
-import android.telephony.ServiceState;
 import android.telephony.TelephonyManager;
 import android.transition.AutoTransition;
 import android.transition.TransitionManager;
@@ -380,7 +378,6 @@ public class GlobalActionsDialog implements DialogInterface.OnDismissListener,
         mHasTelephony = connectivityManager.isNetworkSupported(ConnectivityManager.TYPE_MOBILE);
 
         // get notified of phone state changes
-        telephonyManager.listen(mPhoneStateListener, PhoneStateListener.LISTEN_SERVICE_STATE);
         contentResolver.registerContentObserver(
                 Settings.Global.getUriFor(Settings.Global.AIRPLANE_MODE_ON), true,
                 mAirplaneModeObserver);
@@ -2344,20 +2341,6 @@ public class GlobalActionsDialog implements DialogInterface.OnDismissListener,
         }
     };
 
-    PhoneStateListener mPhoneStateListener = new PhoneStateListener() {
-        @Override
-        public void onServiceStateChanged(ServiceState serviceState) {
-            if (!mHasTelephony) return;
-            final boolean inAirplaneMode = serviceState.getState() == ServiceState.STATE_POWER_OFF;
-            mAirplaneState = inAirplaneMode ? ToggleState.On : ToggleState.Off;
-            mAirplaneModeOn.updateState(mAirplaneState);
-            mAdapter.notifyDataSetChanged();
-            mOverflowAdapter.notifyDataSetChanged();
-            mPowerAdapter.notifyDataSetChanged();
-            mRestartAdapter.notifyDataSetChanged();
-        }
-    };
-
     @Override
     public void onTuningChanged(String key, String newValue) {
         if (POWER_MENU_ACTIONS_STRING.equals(key)) {
@@ -2403,9 +2386,6 @@ public class GlobalActionsDialog implements DialogInterface.OnDismissListener,
     };
 
     private void onAirplaneModeChanged() {
-        // Let the service state callbacks handle the state.
-        if (mHasTelephony) return;
-
         boolean airplaneModeOn = Settings.Global.getInt(
                 mContentResolver,
                 Settings.Global.AIRPLANE_MODE_ON,
",0,20,"GlobalActionsDialog::GlobalActionsDialog, GlobalActionsDialog::PhoneStateListener, GlobalActionsDialog::onAirplaneModeChanged"
54,b1a93f058c54bdda880bbaf4fada024d69672c8a,BluetoothCodecConfig.java,"@@ -467,7 +467,7 @@ public final class BluetoothCodecConfig implements Parcelable {
      * @return true if the codec is mandatory, otherwise false.
      */
     public boolean isMandatoryCodec() {
-        return mCodecType == SOURCE_CODEC_TYPE_SBC;
+        return mCodecType == SOURCE_CODEC_TYPE_SBC && mChannelMode != CHANNEL_MODE_DUAL_CHANNEL;
     }
 
     /**
",1,1,BluetoothCodecConfig::isMandatoryCodec
55,1d36f44fdef026dcc8c56d77e6afaeacde0595d7,QSPanel.java,"@@ -959,7 +959,7 @@ public class QSPanel extends LinearLayout implements Tunable, Callback, Brightne
         }
         r.tile.setDetailListening(show);
         int x = r.tileView.getLeft() + r.tileView.getWidth() / 2;
-        int y = r.tileView.getDetailY() + mTileLayout.getOffsetTop(r);
+        int y = r.tileView.getDetailY();
         handleShowDetailImpl(r, show, x, y);
     }
 
",1,1,QSPanel::handleShowDetailTile
56,045f7580f787f5a3434667f59cd46cc5d9695439,DozeSensors.java,"@@ -46,6 +46,7 @@ import com.android.internal.logging.UiEvent;
 import com.android.internal.logging.UiEventLogger;
 import com.android.internal.logging.UiEventLoggerImpl;
 import com.android.internal.logging.nano.MetricsProto;
+import com.android.systemui.R;
 import com.android.systemui.plugins.SensorManagerPlugin;
 import com.android.systemui.statusbar.phone.DozeParameters;
 import com.android.systemui.util.sensors.AsyncSensorManager;
@@ -174,13 +175,15 @@ public class DozeSensors {
                         dozeLog),
         };
 
-        setProxListening(false);  // Don't immediately start listening when we register.
-        mProximitySensor.register(
-                proximityEvent -> {
-                    if (proximityEvent != null) {
-                        mProxCallback.accept(!proximityEvent.getBelow());
-                    }
-                });
+        if (context.getResources().getBoolean(R.bool.doze_proximity_sensor_supported)) {
+            setProxListening(false);  // Don't immediately start listening when we register.
+            mProximitySensor.register(
+                    proximityEvent -> {
+                        if (proximityEvent != null) {
+                            mProxCallback.accept(!proximityEvent.getBelow());
+                        }
+                    });
+        }
     }
 
     /**
",10,7,DozeSensors::DozeSensors
57,14ea33f8e87874069612cb26912bf33bfd0e0be0,DisplayModeDirector.java,"@@ -46,8 +46,10 @@ import android.view.DisplayInfo;
 import com.android.internal.R;
 import com.android.internal.annotations.VisibleForTesting;
 import com.android.internal.os.BackgroundThread;
+import com.android.internal.util.IndentingPrintWriter;
 import com.android.server.display.utils.AmbientFilter;
 import com.android.server.display.utils.AmbientFilterFactory;
+import com.android.server.utils.DeviceConfigInterface;
 
 import java.io.PrintWriter;
 import java.util.ArrayList;
@@ -64,9 +66,9 @@ public class DisplayModeDirector {
     private static final boolean DEBUG = false;
 
     private static final int MSG_REFRESH_RATE_RANGE_CHANGED = 1;
-    private static final int MSG_BRIGHTNESS_THRESHOLDS_CHANGED = 2;
+    private static final int MSG_LOW_BRIGHTNESS_THRESHOLDS_CHANGED = 2;
     private static final int MSG_DEFAULT_PEAK_REFRESH_RATE_CHANGED = 3;
-    private static final int MSG_REFRESH_RATE_IN_ZONE_CHANGED = 4;
+    private static final int MSG_REFRESH_RATE_IN_LOW_ZONE_CHANGED = 4;
 
     // Special ID used to indicate that given vote is to be applied globally, rather than to a
     // specific display.
@@ -79,6 +81,13 @@ public class DisplayModeDirector {
     private final Context mContext;
 
     private final DisplayModeDirectorHandler mHandler;
+    private final Injector mInjector;
+
+    private final AppRequestObserver mAppRequestObserver;
+    private final SettingsObserver mSettingsObserver;
+    private final DisplayObserver mDisplayObserver;
+    private final DeviceConfigInterface mDeviceConfig;
+    private final DeviceConfigDisplaySettings mDeviceConfigDisplaySettings;
 
     // A map from the display ID to the collection of votes and their priority. The latter takes
     // the form of another map from the priority to the vote itself so that each priority is
@@ -89,17 +98,19 @@ public class DisplayModeDirector {
     // A map from the display ID to the default mode of that display.
     private SparseArray<Display.Mode> mDefaultModeByDisplay;
 
-    private final AppRequestObserver mAppRequestObserver;
-    private final SettingsObserver mSettingsObserver;
-    private final DisplayObserver mDisplayObserver;
     private BrightnessObserver mBrightnessObserver;
 
-    private final DeviceConfigDisplaySettings mDeviceConfigDisplaySettings;
     private DesiredDisplayModeSpecsListener mDesiredDisplayModeSpecsListener;
 
     public DisplayModeDirector(@NonNull Context context, @NonNull Handler handler) {
+        this(context, handler, new RealInjector());
+    }
+
+    public DisplayModeDirector(@NonNull Context context, @NonNull Handler handler,
+            @NonNull Injector injector) {
         mContext = context;
         mHandler = new DisplayModeDirectorHandler(handler.getLooper());
+        mInjector = injector;
         mVotesByDisplay = new SparseArray<>();
         mSupportedModesByDisplay = new SparseArray<>();
         mDefaultModeByDisplay =  new SparseArray<>();
@@ -108,6 +119,7 @@ public class DisplayModeDirector {
         mDisplayObserver = new DisplayObserver(context, handler);
         mBrightnessObserver = new BrightnessObserver(context, handler);
         mDeviceConfigDisplaySettings = new DeviceConfigDisplaySettings();
+        mDeviceConfig = injector.getDeviceConfig();
     }
 
     /**
@@ -348,6 +360,23 @@ public class DisplayModeDirector {
         }
     }
 
+    /**
+     * Retrieve the Vote for the given display and priority. Intended only for testing purposes.
+     *
+     * @param displayId the display to query for
+     * @param priority the priority of the vote to return
+     * @return the vote corresponding to the given {@code displayId} and {@code priority},
+     *         or {@code null} if there isn't one
+     */
+    @VisibleForTesting
+    @Nullable
+    Vote getVote(int displayId, int priority) {
+        synchronized (mLock) {
+            SparseArray<Vote> votes = getVotesLocked(displayId);
+            return votes.get(priority);
+        }
+    }
+
     /**
      * Print the object's state and debug information into the given stream.
      *
@@ -465,6 +494,17 @@ public class DisplayModeDirector {
         mBrightnessObserver = brightnessObserver;
     }
 
+    @VisibleForTesting
+    BrightnessObserver getBrightnessObserver() {
+        return mBrightnessObserver;
+    }
+
+    @VisibleForTesting
+    SettingsObserver getSettingsObserver() {
+        return mSettingsObserver;
+    }
+
+
     @VisibleForTesting
     DesiredDisplayModeSpecs getDesiredDisplayModeSpecsWithInjectedFpsSettings(
             float minRefreshRate, float peakRefreshRate, float defaultRefreshRate) {
@@ -475,6 +515,13 @@ public class DisplayModeDirector {
         }
     }
 
+    @VisibleForTesting
+    void updateSettingForHighZone(int refreshRate, int[] brightnessThresholds,
+            int[] ambientThresholds) {
+        mBrightnessObserver.updateThresholdsRefreshRateForHighZone(refreshRate,
+                brightnessThresholds, ambientThresholds);
+    }
+
     /**
      * Listens for changes refresh rate coordination.
      */
@@ -493,15 +540,10 @@ public class DisplayModeDirector {
         @Override
         public void handleMessage(Message msg) {
             switch (msg.what) {
-                case MSG_BRIGHTNESS_THRESHOLDS_CHANGED:
+                case MSG_LOW_BRIGHTNESS_THRESHOLDS_CHANGED:
                     Pair<int[], int[]> thresholds = (Pair<int[], int[]>) msg.obj;
-
-                    if (thresholds != null) {
-                        mBrightnessObserver.onDeviceConfigThresholdsChanged(
-                                thresholds.first, thresholds.second);
-                    } else {
-                        mBrightnessObserver.onDeviceConfigThresholdsChanged(null, null);
-                    }
+                    mBrightnessObserver.onDeviceConfigLowBrightnessThresholdsChanged(
+                            thresholds.first, thresholds.second);
                     break;
 
                 case MSG_DEFAULT_PEAK_REFRESH_RATE_CHANGED:
@@ -510,9 +552,9 @@ public class DisplayModeDirector {
                             defaultPeakRefreshRate);
                     break;
 
-                case MSG_REFRESH_RATE_IN_ZONE_CHANGED:
+                case MSG_REFRESH_RATE_IN_LOW_ZONE_CHANGED:
                     int refreshRateInZone = msg.arg1;
-                    mBrightnessObserver.onDeviceConfigRefreshRateInZoneChanged(
+                    mBrightnessObserver.onDeviceConfigRefreshRateInLowZoneChanged(
                             refreshRateInZone);
                     break;
 
@@ -685,10 +727,11 @@ public class DisplayModeDirector {
         // by all other considerations. It acts to set a default frame rate for a device.
         public static final int PRIORITY_DEFAULT_REFRESH_RATE = 0;
 
-        // LOW_BRIGHTNESS votes for a single refresh rate like [60,60], [90,90] or null.
+        // FLICKER votes for a single refresh rate like [60,60], [90,90] or null.
         // If the higher voters result is a range, it will fix the rate to a single choice.
-        // It's used to avoid rate switch in certain conditions.
-        public static final int PRIORITY_LOW_BRIGHTNESS = 1;
+        // It's used to avoid refresh rate switches in certain conditions which may result in the
+        // user seeing the display flickering when the switches occur.
+        public static final int PRIORITY_FLICKER = 1;
 
         // SETTING_MIN_REFRESH_RATE is used to propose a lower bound of display refresh rate.
         // It votes [MIN_REFRESH_RATE, Float.POSITIVE_INFINITY]
@@ -761,8 +804,8 @@ public class DisplayModeDirector {
             switch (priority) {
                 case PRIORITY_DEFAULT_REFRESH_RATE:
                     return ""PRIORITY_DEFAULT_REFRESH_RATE"";
-                case PRIORITY_LOW_BRIGHTNESS:
-                    return ""PRIORITY_LOW_BRIGHTNESS"";
+                case PRIORITY_FLICKER:
+                    return ""PRIORITY_FLICKER"";
                 case PRIORITY_USER_SETTING_MIN_REFRESH_RATE:
                     return ""PRIORITY_USER_SETTING_MIN_REFRESH_RATE"";
                 case PRIORITY_APP_REQUEST_REFRESH_RATE:
@@ -787,7 +830,8 @@ public class DisplayModeDirector {
         }
     }
 
-    private final class SettingsObserver extends ContentObserver {
+    @VisibleForTesting
+    final class SettingsObserver extends ContentObserver {
         private final Uri mPeakRefreshRateSetting =
                 Settings.System.getUriFor(Settings.System.PEAK_REFRESH_RATE);
         private final Uri mMinRefreshRateSetting =
@@ -810,8 +854,7 @@ public class DisplayModeDirector {
 
         public void observe() {
             final ContentResolver cr = mContext.getContentResolver();
-            cr.registerContentObserver(mPeakRefreshRateSetting, false /*notifyDescendants*/, this,
-                    UserHandle.USER_SYSTEM);
+            mInjector.registerPeakRefreshRateObserver(cr, this);
             cr.registerContentObserver(mMinRefreshRateSetting, false /*notifyDescendants*/, this,
                     UserHandle.USER_SYSTEM);
             cr.registerContentObserver(mLowPowerModeSetting, false /*notifyDescendants*/, this,
@@ -829,6 +872,13 @@ public class DisplayModeDirector {
             }
         }
 
+        public void setDefaultRefreshRate(float refreshRate) {
+            synchronized (mLock) {
+                mDefaultRefreshRate = refreshRate;
+                updateRefreshRateSettingLocked();
+            }
+        }
+
         public void onDeviceConfigDefaultPeakRefreshRateChanged(Float defaultPeakRefreshRate) {
             if (defaultPeakRefreshRate == null) {
                 defaultPeakRefreshRate = (float) mContext.getResources().getInteger(
@@ -1033,6 +1083,7 @@ public class DisplayModeDirector {
         @Override
         public void onDisplayChanged(int displayId) {
             updateDisplayModes(displayId);
+            // TODO: Break the coupling between DisplayObserver and BrightnessObserver.
             mBrightnessObserver.onDisplayChanged(displayId);
         }
 
@@ -1071,15 +1122,16 @@ public class DisplayModeDirector {
      */
     @VisibleForTesting
     public class BrightnessObserver extends ContentObserver {
-        // TODO: brightnessfloat: change this to the float setting
-        private final Uri mDisplayBrightnessSetting =
-                Settings.System.getUriFor(Settings.System.SCREEN_BRIGHTNESS);
         private final static int LIGHT_SENSOR_RATE_MS = 250;
-        private int[] mDisplayBrightnessThresholds;
-        private int[] mAmbientBrightnessThresholds;
+        private int[] mLowDisplayBrightnessThresholds;
+        private int[] mLowAmbientBrightnessThresholds;
+        private int[] mHighDisplayBrightnessThresholds;
+        private int[] mHighAmbientBrightnessThresholds;
         // valid threshold if any item from the array >= 0
-        private boolean mShouldObserveDisplayChange;
-        private boolean mShouldObserveAmbientChange;
+        private boolean mShouldObserveDisplayLowChange;
+        private boolean mShouldObserveAmbientLowChange;
+        private boolean mShouldObserveDisplayHighChange;
+        private boolean mShouldObserveAmbientHighChange;
 
         private SensorManager mSensorManager;
         private Sensor mLightSensor;
@@ -1087,46 +1139,114 @@ public class DisplayModeDirector {
         // Take it as low brightness before valid sensor data comes
         private float mAmbientLux = -1.0f;
         private AmbientFilter mAmbientFilter;
+        private int mBrightness = -1;
 
         private final Context mContext;
 
-        // Enable light sensor only when mShouldObserveAmbientChange is true, screen is on, peak
-        // refresh rate changeable and low power mode off. After initialization, these states will
+        // Enable light sensor only when mShouldObserveAmbientLowChange is true or
+        // mShouldObserveAmbientHighChange is true, screen is on, peak refresh rate
+        // changeable and low power mode off. After initialization, these states will
         // be updated from the same handler thread.
-        private boolean mScreenOn = false;
+        private boolean mDefaultDisplayOn = false;
         private boolean mRefreshRateChangeable = false;
         private boolean mLowPowerModeEnabled = false;
 
-        private int mRefreshRateInZone;
+        private int mRefreshRateInLowZone;
+        private int mRefreshRateInHighZone;
 
         BrightnessObserver(Context context, Handler handler) {
             super(handler);
             mContext = context;
-            mDisplayBrightnessThresholds = context.getResources().getIntArray(
+            mLowDisplayBrightnessThresholds = context.getResources().getIntArray(
                     R.array.config_brightnessThresholdsOfPeakRefreshRate);
-            mAmbientBrightnessThresholds = context.getResources().getIntArray(
+            mLowAmbientBrightnessThresholds = context.getResources().getIntArray(
                     R.array.config_ambientThresholdsOfPeakRefreshRate);
 
-            if (mDisplayBrightnessThresholds.length != mAmbientBrightnessThresholds.length) {
-                throw new RuntimeException(""display brightness threshold array and ambient ""
-                        + ""brightness threshold array have different length"");
+            if (mLowDisplayBrightnessThresholds.length != mLowAmbientBrightnessThresholds.length) {
+                throw new RuntimeException(""display low brightness threshold array and ambient ""
+                        + ""brightness threshold array have different length: ""
+                        + ""displayBrightnessThresholds=""
+                        + Arrays.toString(mLowDisplayBrightnessThresholds)
+                        + "", ambientBrightnessThresholds=""
+                        + Arrays.toString(mLowAmbientBrightnessThresholds));
             }
+
+            mHighDisplayBrightnessThresholds = context.getResources().getIntArray(
+                    R.array.config_highDisplayBrightnessThresholdsOfFixedRefreshRate);
+            mHighAmbientBrightnessThresholds = context.getResources().getIntArray(
+                    R.array.config_highAmbientBrightnessThresholdsOfFixedRefreshRate);
+            if (mHighDisplayBrightnessThresholds.length
+                    != mHighAmbientBrightnessThresholds.length) {
+                throw new RuntimeException(""display high brightness threshold array and ambient ""
+                        + ""brightness threshold array have different length: ""
+                        + ""displayBrightnessThresholds=""
+                        + Arrays.toString(mHighDisplayBrightnessThresholds)
+                        + "", ambientBrightnessThresholds=""
+                        + Arrays.toString(mHighAmbientBrightnessThresholds));
+            }
+            mRefreshRateInHighZone = context.getResources().getInteger(
+                    R.integer.config_fixedRefreshRateInHighZone);
+        }
+
+        /**
+         * @return the refresh to lock to when in a low brightness zone
+         */
+        @VisibleForTesting
+        int getRefreshRateInLowZone() {
+            return mRefreshRateInLowZone;
+        }
+
+        /**
+         * @return the display brightness thresholds for the low brightness zones
+         */
+        @VisibleForTesting
+        int[] getLowDisplayBrightnessThresholds() {
+            return mLowDisplayBrightnessThresholds;
+        }
+
+        /**
+         * @return the ambient brightness thresholds for the low brightness zones
+         */
+        @VisibleForTesting
+        int[] getLowAmbientBrightnessThresholds() {
+            return mLowAmbientBrightnessThresholds;
+        }
+
+        public void registerLightSensor(SensorManager sensorManager, Sensor lightSensor) {
+            mSensorManager = sensorManager;
+            mLightSensor = lightSensor;
+
+            mSensorManager.registerListener(mLightSensorListener,
+                    mLightSensor, LIGHT_SENSOR_RATE_MS * 1000, mHandler);
+        }
+
+        public void updateThresholdsRefreshRateForHighZone(int refreshRate,
+                int[] brightnessThresholds, int[] ambientThresholds) {
+            mRefreshRateInHighZone = refreshRate;
+            mHighDisplayBrightnessThresholds = brightnessThresholds;
+            mHighAmbientBrightnessThresholds = ambientThresholds;
         }
 
         public void observe(SensorManager sensorManager) {
             mSensorManager = sensorManager;
+            final ContentResolver cr = mContext.getContentResolver();
+            mBrightness = Settings.System.getIntForUser(cr,
+                    Settings.System.SCREEN_BRIGHTNESS, -1 /*default*/, cr.getUserId());
 
             // DeviceConfig is accessible after system ready.
-            int[] brightnessThresholds = mDeviceConfigDisplaySettings.getBrightnessThresholds();
-            int[] ambientThresholds = mDeviceConfigDisplaySettings.getAmbientThresholds();
+            int[] lowDisplayBrightnessThresholds =
+                    mDeviceConfigDisplaySettings.getLowDisplayBrightnessThresholds();
+            int[] lowAmbientBrightnessThresholds =
+                    mDeviceConfigDisplaySettings.getLowAmbientBrightnessThresholds();
 
-            if (brightnessThresholds != null && ambientThresholds != null
-                    && brightnessThresholds.length == ambientThresholds.length) {
-                mDisplayBrightnessThresholds = brightnessThresholds;
-                mAmbientBrightnessThresholds = ambientThresholds;
+            if (lowDisplayBrightnessThresholds != null && lowAmbientBrightnessThresholds != null
+                    && lowDisplayBrightnessThresholds.length
+                    == lowAmbientBrightnessThresholds.length) {
+                mLowDisplayBrightnessThresholds = lowDisplayBrightnessThresholds;
+                mLowAmbientBrightnessThresholds = lowAmbientBrightnessThresholds;
             }
 
-            mRefreshRateInZone = mDeviceConfigDisplaySettings.getRefreshRateInZone();
+            mRefreshRateInLowZone = mDeviceConfigDisplaySettings.getRefreshRateInLowZone();
             restartObserver();
             mDeviceConfigDisplaySettings.startListening();
         }
@@ -1138,7 +1258,7 @@ public class DisplayModeDirector {
                 updateSensorStatus();
                 if (!changeable) {
                     // Revoke previous vote from BrightnessObserver
-                    updateVoteLocked(Vote.PRIORITY_LOW_BRIGHTNESS, null);
+                    updateVoteLocked(Vote.PRIORITY_FLICKER, null);
                 }
             }
         }
@@ -1150,25 +1270,25 @@ public class DisplayModeDirector {
             }
         }
 
-        public void onDeviceConfigThresholdsChanged(int[] brightnessThresholds,
+        public void onDeviceConfigLowBrightnessThresholdsChanged(int[] displayThresholds,
                 int[] ambientThresholds) {
-            if (brightnessThresholds != null && ambientThresholds != null
-                    && brightnessThresholds.length == ambientThresholds.length) {
-                mDisplayBrightnessThresholds = brightnessThresholds;
-                mAmbientBrightnessThresholds = ambientThresholds;
+            if (displayThresholds != null && ambientThresholds != null
+                    && displayThresholds.length == ambientThresholds.length) {
+                mLowDisplayBrightnessThresholds = displayThresholds;
+                mLowAmbientBrightnessThresholds = ambientThresholds;
             } else {
                 // Invalid or empty. Use device default.
-                mDisplayBrightnessThresholds = mContext.getResources().getIntArray(
+                mLowDisplayBrightnessThresholds = mContext.getResources().getIntArray(
                         R.array.config_brightnessThresholdsOfPeakRefreshRate);
-                mAmbientBrightnessThresholds = mContext.getResources().getIntArray(
+                mLowAmbientBrightnessThresholds = mContext.getResources().getIntArray(
                         R.array.config_ambientThresholdsOfPeakRefreshRate);
             }
             restartObserver();
         }
 
-        public void onDeviceConfigRefreshRateInZoneChanged(int refreshRate) {
-            if (refreshRate != mRefreshRateInZone) {
-                mRefreshRateInZone = refreshRate;
+        public void onDeviceConfigRefreshRateInLowZoneChanged(int refreshRate) {
+            if (refreshRate != mRefreshRateInLowZone) {
+                mRefreshRateInLowZone = refreshRate;
                 restartObserver();
             }
         }
@@ -1176,48 +1296,95 @@ public class DisplayModeDirector {
         public void dumpLocked(PrintWriter pw) {
             pw.println(""  BrightnessObserver"");
             pw.println(""    mAmbientLux: "" + mAmbientLux);
-            pw.println(""    mRefreshRateInZone: "" + mRefreshRateInZone);
+            pw.println(""    mBrightness: "" + mBrightness);
+            pw.println(""    mDefaultDisplayOn: "" + mDefaultDisplayOn);
+            pw.println(""    mLowPowerModeEnabled: "" + mLowPowerModeEnabled);
+            pw.println(""    mRefreshRateChangeable: "" + mRefreshRateChangeable);
+            pw.println(""    mShouldObserveDisplayLowChange: "" + mShouldObserveDisplayLowChange);
+            pw.println(""    mShouldObserveAmbientLowChange: "" + mShouldObserveAmbientLowChange);
+            pw.println(""    mRefreshRateInLowZone: "" + mRefreshRateInLowZone);
+
+            for (int d : mLowDisplayBrightnessThresholds) {
+                pw.println(""    mDisplayLowBrightnessThreshold: "" + d);
+            }
+
+            for (int d : mLowAmbientBrightnessThresholds) {
+                pw.println(""    mAmbientLowBrightnessThreshold: "" + d);
+            }
+
+            pw.println(""    mShouldObserveDisplayHighChange: "" + mShouldObserveDisplayHighChange);
+            pw.println(""    mShouldObserveAmbientHighChange: "" + mShouldObserveAmbientHighChange);
+            pw.println(""    mRefreshRateInHighZone: "" + mRefreshRateInHighZone);
 
-            for (int d: mDisplayBrightnessThresholds) {
-                pw.println(""    mDisplayBrightnessThreshold: "" + d);
+            for (int d : mHighDisplayBrightnessThresholds) {
+                pw.println(""    mDisplayHighBrightnessThresholds: "" + d);
             }
 
-            for (int d: mAmbientBrightnessThresholds) {
-                pw.println(""    mAmbientBrightnessThreshold: "" + d);
+            for (int d : mHighAmbientBrightnessThresholds) {
+                pw.println(""    mAmbientHighBrightnessThresholds: "" + d);
             }
 
             mLightSensorListener.dumpLocked(pw);
+
+            if (mAmbientFilter != null) {
+                IndentingPrintWriter ipw = new IndentingPrintWriter(pw, ""  "");
+                ipw.setIndent(""    "");
+                mAmbientFilter.dump(ipw);
+            }
         }
 
         public void onDisplayChanged(int displayId) {
             if (displayId == Display.DEFAULT_DISPLAY) {
-                onScreenOn(isDefaultDisplayOn());
+                updateDefaultDisplayState();
             }
         }
 
         @Override
         public void onChange(boolean selfChange, Uri uri, int userId) {
             synchronized (mLock) {
-                onBrightnessChangedLocked();
+                final ContentResolver cr = mContext.getContentResolver();
+                int brightness = Settings.System.getIntForUser(cr,
+                        Settings.System.SCREEN_BRIGHTNESS, -1 /*default*/, cr.getUserId());
+                if (brightness != mBrightness) {
+                    mBrightness = brightness;
+                    onBrightnessChangedLocked();
+                }
             }
         }
 
         private void restartObserver() {
-            mShouldObserveDisplayChange = checkShouldObserve(mDisplayBrightnessThresholds);
-            mShouldObserveAmbientChange = checkShouldObserve(mAmbientBrightnessThresholds);
-
             final ContentResolver cr = mContext.getContentResolver();
-            if (mShouldObserveDisplayChange) {
+
+            if (mRefreshRateInLowZone > 0) {
+                mShouldObserveDisplayLowChange = hasValidThreshold(
+                        mLowDisplayBrightnessThresholds);
+                mShouldObserveAmbientLowChange = hasValidThreshold(
+                        mLowAmbientBrightnessThresholds);
+            } else {
+                mShouldObserveDisplayLowChange = false;
+                mShouldObserveAmbientLowChange = false;
+            }
+
+            if (mRefreshRateInHighZone > 0) {
+                mShouldObserveDisplayHighChange = hasValidThreshold(
+                        mHighDisplayBrightnessThresholds);
+                mShouldObserveAmbientHighChange = hasValidThreshold(
+                        mHighAmbientBrightnessThresholds);
+            } else {
+                mShouldObserveDisplayHighChange = false;
+                mShouldObserveAmbientHighChange = false;
+            }
+
+            if (mShouldObserveDisplayLowChange || mShouldObserveDisplayHighChange) {
                 // Content Service does not check if an listener has already been registered.
                 // To ensure only one listener is registered, force an unregistration first.
-                cr.unregisterContentObserver(this);
-                cr.registerContentObserver(mDisplayBrightnessSetting,
-                        false /*notifyDescendants*/, this, UserHandle.USER_SYSTEM);
+                mInjector.unregisterBrightnessObserver(cr, this);
+                mInjector.registerBrightnessObserver(cr, this);
             } else {
-                cr.unregisterContentObserver(this);
+                mInjector.unregisterBrightnessObserver(cr, this);
             }
 
-            if (mShouldObserveAmbientChange) {
+            if (mShouldObserveAmbientLowChange || mShouldObserveAmbientHighChange) {
                 Resources resources = mContext.getResources();
                 String lightSensorType = resources.getString(
                         com.android.internal.R.string.config_displayLightSensorType);
@@ -1243,8 +1410,6 @@ public class DisplayModeDirector {
 
                     mAmbientFilter = AmbientFilterFactory.createBrightnessFilter(TAG, res);
                     mLightSensor = lightSensor;
-
-                    onScreenOn(isDefaultDisplayOn());
                 }
             } else {
                 mAmbientFilter = null;
@@ -1263,11 +1428,7 @@ public class DisplayModeDirector {
          * Checks to see if at least one value is positive, in which case it is necessary to listen
          * to value changes.
          */
-        private boolean checkShouldObserve(int[] a) {
-            if (mRefreshRateInZone <= 0) {
-                return false;
-            }
-
+        private boolean hasValidThreshold(int[] a) {
             for (int d: a) {
                 if (d >= 0) {
                     return true;
@@ -1277,13 +1438,13 @@ public class DisplayModeDirector {
             return false;
         }
 
-        private boolean isInsideZone(int brightness, float lux) {
-            for (int i = 0; i < mDisplayBrightnessThresholds.length; i++) {
-                int disp = mDisplayBrightnessThresholds[i];
-                int ambi = mAmbientBrightnessThresholds[i];
+        private boolean isInsideLowZone(int brightness, float lux) {
+            for (int i = 0; i < mLowDisplayBrightnessThresholds.length; i++) {
+                int disp = mLowDisplayBrightnessThresholds[i];
+                int ambi = mLowAmbientBrightnessThresholds[i];
 
                 if (disp >= 0 && ambi >= 0) {
-                    if (brightness <= disp && mAmbientLux <= ambi) {
+                    if (brightness <= disp && lux <= ambi) {
                         return true;
                     }
                 } else if (disp >= 0) {
@@ -1291,7 +1452,7 @@ public class DisplayModeDirector {
                         return true;
                     }
                 } else if (ambi >= 0) {
-                    if (mAmbientLux <= ambi) {
+                    if (lux <= ambi) {
                         return true;
                     }
                 }
@@ -1299,27 +1460,77 @@ public class DisplayModeDirector {
 
             return false;
         }
-        // TODO: brightnessfloat: make it use float not int
-        private void onBrightnessChangedLocked() {
-            int brightness = Settings.System.getInt(mContext.getContentResolver(),
-                    Settings.System.SCREEN_BRIGHTNESS, -1);
 
+        private boolean isInsideHighZone(int brightness, float lux) {
+            for (int i = 0; i < mHighDisplayBrightnessThresholds.length; i++) {
+                int disp = mHighDisplayBrightnessThresholds[i];
+                int ambi = mHighAmbientBrightnessThresholds[i];
+
+                if (disp >= 0 && ambi >= 0) {
+                    if (brightness >= disp && lux >= ambi) {
+                        return true;
+                    }
+                } else if (disp >= 0) {
+                    if (brightness >= disp) {
+                        return true;
+                    }
+                } else if (ambi >= 0) {
+                    if (lux >= ambi) {
+                        return true;
+                    }
+                }
+            }
+
+            return false;
+        }
+        private void onBrightnessChangedLocked() {
             Vote vote = null;
-            boolean insideZone = isInsideZone(brightness, mAmbientLux);
-            if (insideZone) {
-                vote = Vote.forRefreshRates(mRefreshRateInZone, mRefreshRateInZone);
+
+            if (mBrightness < 0) {
+                // Either the setting isn't available or we shouldn't be observing yet anyways.
+                // Either way, just bail out since there's nothing we can do here.
+                return;
+            }
+
+            boolean insideLowZone = hasValidLowZone() && isInsideLowZone(mBrightness, mAmbientLux);
+            if (insideLowZone) {
+                vote = Vote.forRefreshRates(mRefreshRateInLowZone, mRefreshRateInLowZone);
+            }
+
+            boolean insideHighZone = hasValidHighZone()
+                    && isInsideHighZone(mBrightness, mAmbientLux);
+            if (insideHighZone) {
+                vote = Vote.forRefreshRates(mRefreshRateInHighZone, mRefreshRateInHighZone);
             }
 
             if (DEBUG) {
-                Slog.d(TAG, ""Display brightness "" + brightness + "", ambient lux "" +  mAmbientLux +
-                        "", Vote "" + vote);
+                Slog.d(TAG, ""Display brightness "" + mBrightness + "", ambient lux "" +  mAmbientLux
+                        + "", Vote "" + vote);
             }
-            updateVoteLocked(Vote.PRIORITY_LOW_BRIGHTNESS, vote);
+            updateVoteLocked(Vote.PRIORITY_FLICKER, vote);
+        }
+
+        private boolean hasValidLowZone() {
+            return mRefreshRateInLowZone > 0
+                    && (mShouldObserveDisplayLowChange || mShouldObserveAmbientLowChange);
+        }
+
+        private boolean hasValidHighZone() {
+            return mRefreshRateInHighZone > 0
+                    && (mShouldObserveDisplayHighChange || mShouldObserveAmbientHighChange);
+        }
+
+        private void updateDefaultDisplayState() {
+            Display display = mContext.getSystemService(DisplayManager.class)
+                    .getDisplay(Display.DEFAULT_DISPLAY);
+            boolean defaultDisplayOn = display != null && display.getState() != Display.STATE_OFF;
+            setDefaultDisplayState(defaultDisplayOn);
         }
 
-        private void onScreenOn(boolean on) {
-            if (mScreenOn != on) {
-                mScreenOn = on;
+        @VisibleForTesting
+        public void setDefaultDisplayState(boolean on) {
+            if (mDefaultDisplayOn != on) {
+                mDefaultDisplayOn = on;
                 updateSensorStatus();
             }
         }
@@ -1329,8 +1540,8 @@ public class DisplayModeDirector {
                 return;
             }
 
-            if (mShouldObserveAmbientChange && mScreenOn && !mLowPowerModeEnabled
-                    && mRefreshRateChangeable) {
+            if ((mShouldObserveAmbientLowChange || mShouldObserveAmbientHighChange)
+                     && isDeviceActive() && !mLowPowerModeEnabled && mRefreshRateChangeable) {
                 mSensorManager.registerListener(mLightSensorListener,
                         mLightSensor, LIGHT_SENSOR_RATE_MS * 1000, mHandler);
             } else {
@@ -1339,11 +1550,8 @@ public class DisplayModeDirector {
             }
         }
 
-        private boolean isDefaultDisplayOn() {
-            final Display display = mContext.getSystemService(DisplayManager.class)
-                    .getDisplay(Display.DEFAULT_DISPLAY);
-            return display.getState() != Display.STATE_OFF
-                    && mContext.getSystemService(PowerManager.class).isInteractive();
+        private boolean isDeviceActive() {
+            return mDefaultDisplayOn && mInjector.isDeviceInteractive(mContext);
         }
 
         private final class LightSensorEventListener implements SensorEventListener {
@@ -1361,23 +1569,33 @@ public class DisplayModeDirector {
                     Slog.d(TAG, ""On sensor changed: "" + mLastSensorData);
                 }
 
-                boolean zoneChanged = isDifferentZone(mLastSensorData, mAmbientLux);
-                if (zoneChanged && mLastSensorData < mAmbientLux) {
-                    // Easier to see flicker at lower brightness environment. Forget the history to
-                    // get immediate response.
-                    mAmbientFilter.clear();
+                boolean lowZoneChanged = isDifferentZone(mLastSensorData, mAmbientLux,
+                        mLowAmbientBrightnessThresholds);
+                boolean highZoneChanged = isDifferentZone(mLastSensorData, mAmbientLux,
+                        mHighAmbientBrightnessThresholds);
+                if ((lowZoneChanged && mLastSensorData < mAmbientLux)
+                        || (highZoneChanged && mLastSensorData > mAmbientLux)) {
+                    // Easier to see flicker at lower brightness environment or high brightness
+                    // environment. Forget the history to get immediate response.
+                    if (mAmbientFilter != null) {
+                        mAmbientFilter.clear();
+                    }
                 }
 
                 long now = SystemClock.uptimeMillis();
-                mAmbientFilter.addValue(now, mLastSensorData);
+                if (mAmbientFilter != null) {
+                    mAmbientFilter.addValue(now, mLastSensorData);
+                }
 
                 mHandler.removeCallbacks(mInjectSensorEventRunnable);
                 processSensorData(now);
 
-                if (zoneChanged && mLastSensorData > mAmbientLux) {
+                if ((lowZoneChanged && mLastSensorData > mAmbientLux)
+                        || (highZoneChanged && mLastSensorData < mAmbientLux)) {
                     // Sensor may not report new event if there is no brightness change.
                     // Need to keep querying the temporal filter for the latest estimation,
-                    // until enter in higher lux zone or is interrupted by a new sensor event.
+                    // until sensor readout and filter estimation are in the same zone or
+                    // is interrupted by a new sensor event.
                     mHandler.postDelayed(mInjectSensorEventRunnable, INJECT_EVENTS_INTERVAL_MS);
                 }
             }
@@ -1392,17 +1610,19 @@ public class DisplayModeDirector {
             }
 
             private void processSensorData(long now) {
-                mAmbientLux = mAmbientFilter.getEstimate(now);
+                if (mAmbientFilter != null) {
+                    mAmbientLux = mAmbientFilter.getEstimate(now);
+                } else {
+                    mAmbientLux = mLastSensorData;
+                }
 
                 synchronized (mLock) {
                     onBrightnessChangedLocked();
                 }
             }
 
-            private boolean isDifferentZone(float lux1, float lux2) {
-                for (int z = 0; z < mAmbientBrightnessThresholds.length; z++) {
-                    final float boundary = mAmbientBrightnessThresholds[z];
-
+            private boolean isDifferentZone(float lux1, float lux2, int[] luxThresholds) {
+                for (final float boundary : luxThresholds) {
                     // Test each boundary. See if the current value and the new value are at
                     // different sides.
                     if ((lux1 <= boundary && lux2 > boundary)
@@ -1422,7 +1642,10 @@ public class DisplayModeDirector {
                     processSensorData(now);
 
                     // Inject next event if there is a possible zone change.
-                    if (isDifferentZone(mLastSensorData, mAmbientLux)) {
+                    if (isDifferentZone(mLastSensorData, mAmbientLux,
+                            mLowAmbientBrightnessThresholds)
+                            || isDifferentZone(mLastSensorData, mAmbientLux,
+                            mHighAmbientBrightnessThresholds)) {
                         mHandler.postDelayed(mInjectSensorEventRunnable, INJECT_EVENTS_INTERVAL_MS);
                     }
                 }
@@ -1435,14 +1658,14 @@ public class DisplayModeDirector {
         }
 
         public void startListening() {
-            DeviceConfig.addOnPropertiesChangedListener(DeviceConfig.NAMESPACE_DISPLAY_MANAGER,
+            mDeviceConfig.addOnPropertiesChangedListener(DeviceConfig.NAMESPACE_DISPLAY_MANAGER,
                     BackgroundThread.getExecutor(), this);
         }
 
         /*
          * Return null if no such property or wrong format (not comma separated integers).
          */
-        public int[] getBrightnessThresholds() {
+        public int[] getLowDisplayBrightnessThresholds() {
             return getIntArrayProperty(
                     DisplayManager.DeviceConfig.
                             KEY_PEAK_REFRESH_RATE_DISPLAY_BRIGHTNESS_THRESHOLDS);
@@ -1451,17 +1674,29 @@ public class DisplayModeDirector {
         /*
          * Return null if no such property or wrong format (not comma separated integers).
          */
-        public int[] getAmbientThresholds() {
+        public int[] getLowAmbientBrightnessThresholds() {
             return getIntArrayProperty(
                     DisplayManager.DeviceConfig.
                             KEY_PEAK_REFRESH_RATE_AMBIENT_BRIGHTNESS_THRESHOLDS);
         }
 
+        public int getRefreshRateInLowZone() {
+            int defaultRefreshRateInZone = mContext.getResources().getInteger(
+                    R.integer.config_defaultRefreshRateInZone);
+
+            int refreshRate = mDeviceConfig.getInt(
+                    DeviceConfig.NAMESPACE_DISPLAY_MANAGER,
+                    DisplayManager.DeviceConfig.KEY_REFRESH_RATE_IN_ZONE,
+                    defaultRefreshRateInZone);
+
+            return refreshRate;
+        }
+
         /*
          * Return null if no such property
          */
         public Float getDefaultPeakRefreshRate() {
-            float defaultPeakRefreshRate = DeviceConfig.getFloat(
+            float defaultPeakRefreshRate = mDeviceConfig.getFloat(
                     DeviceConfig.NAMESPACE_DISPLAY_MANAGER,
                     DisplayManager.DeviceConfig.KEY_PEAK_REFRESH_RATE_DEFAULT, -1);
 
@@ -1471,36 +1706,25 @@ public class DisplayModeDirector {
             return defaultPeakRefreshRate;
         }
 
-        public int getRefreshRateInZone() {
-            int defaultRefreshRateInZone = mContext.getResources().getInteger(
-                    R.integer.config_defaultRefreshRateInZone);
-
-            int refreshRate = DeviceConfig.getInt(
-                    DeviceConfig.NAMESPACE_DISPLAY_MANAGER,
-                    DisplayManager.DeviceConfig.KEY_REFRESH_RATE_IN_ZONE,
-                    defaultRefreshRateInZone);
-
-            return refreshRate;
-        }
-
         @Override
         public void onPropertiesChanged(@NonNull DeviceConfig.Properties properties) {
-            int[] brightnessThresholds = getBrightnessThresholds();
-            int[] ambientThresholds = getAmbientThresholds();
             Float defaultPeakRefreshRate = getDefaultPeakRefreshRate();
-            int refreshRateInZone = getRefreshRateInZone();
-
-            mHandler.obtainMessage(MSG_BRIGHTNESS_THRESHOLDS_CHANGED,
-                    new Pair<int[], int[]>(brightnessThresholds, ambientThresholds))
-                    .sendToTarget();
             mHandler.obtainMessage(MSG_DEFAULT_PEAK_REFRESH_RATE_CHANGED,
                     defaultPeakRefreshRate).sendToTarget();
-            mHandler.obtainMessage(MSG_REFRESH_RATE_IN_ZONE_CHANGED, refreshRateInZone,
-                    0).sendToTarget();
+
+            int[] lowDisplayBrightnessThresholds = getLowDisplayBrightnessThresholds();
+            int[] lowAmbientBrightnessThresholds = getLowAmbientBrightnessThresholds();
+            int refreshRateInLowZone = getRefreshRateInLowZone();
+
+            mHandler.obtainMessage(MSG_LOW_BRIGHTNESS_THRESHOLDS_CHANGED,
+                    new Pair<>(lowDisplayBrightnessThresholds, lowAmbientBrightnessThresholds))
+                    .sendToTarget();
+            mHandler.obtainMessage(MSG_REFRESH_RATE_IN_LOW_ZONE_CHANGED, refreshRateInLowZone, 0)
+                    .sendToTarget();
         }
 
         private int[] getIntArrayProperty(String prop) {
-            String strArray = DeviceConfig.getString(DeviceConfig.NAMESPACE_DISPLAY_MANAGER, prop,
+            String strArray = mDeviceConfig.getString(DeviceConfig.NAMESPACE_DISPLAY_MANAGER, prop,
                     null);
 
             if (strArray != null) {
@@ -1527,4 +1751,59 @@ public class DisplayModeDirector {
         }
     }
 
+    interface Injector {
+        // TODO: brightnessfloat: change this to the float setting
+        Uri DISPLAY_BRIGHTNESS_URI = Settings.System.getUriFor(Settings.System.SCREEN_BRIGHTNESS);
+        Uri PEAK_REFRESH_RATE_URI = Settings.System.getUriFor(Settings.System.PEAK_REFRESH_RATE);
+
+        @NonNull
+        DeviceConfigInterface getDeviceConfig();
+
+        void registerBrightnessObserver(@NonNull ContentResolver cr,
+                @NonNull ContentObserver observer);
+
+        void unregisterBrightnessObserver(@NonNull ContentResolver cr,
+                @NonNull ContentObserver observer);
+
+        void registerPeakRefreshRateObserver(@NonNull ContentResolver cr,
+                @NonNull ContentObserver observer);
+
+        boolean isDeviceInteractive(@NonNull Context context);
+    }
+
+    @VisibleForTesting
+    static class RealInjector implements Injector {
+
+        @Override
+        @NonNull
+        public DeviceConfigInterface getDeviceConfig() {
+            return DeviceConfigInterface.REAL;
+        }
+
+        @Override
+        public void registerBrightnessObserver(@NonNull ContentResolver cr,
+                @NonNull ContentObserver observer) {
+            cr.registerContentObserver(DISPLAY_BRIGHTNESS_URI, false /*notifyDescendants*/,
+                    observer, UserHandle.USER_SYSTEM);
+        }
+
+        @Override
+        public void unregisterBrightnessObserver(@NonNull ContentResolver cr,
+                @NonNull ContentObserver observer) {
+            cr.unregisterContentObserver(observer);
+        }
+
+        @Override
+        public void registerPeakRefreshRateObserver(@NonNull ContentResolver cr,
+                @NonNull ContentObserver observer) {
+            cr.registerContentObserver(PEAK_REFRESH_RATE_URI, false /*notifyDescendants*/,
+                    observer, UserHandle.USER_SYSTEM);
+        }
+
+        @Override
+        public boolean isDeviceInteractive(@NonNull Context ctx) {
+            return ctx.getSystemService(PowerManager.class).isInteractive();
+        }
+    }
+
 }
",426,147,"DisplayModeDirector::BrightnessObserver::onChange, DisplayModeDirector::DeviceConfigDisplaySettings::getBrightnessThresholds, DisplayModeDirector::getSettingsObserver, DisplayModeDirector::updateSettingForHighZone, DisplayModeDirector::BrightnessObserver::observe, DisplayModeDirector::BrightnessObserver::onDeviceConfigLowBrightnessThresholdsChanged, DisplayModeDirector::RealInjector::registerPeakRefreshRateObserver, DisplayModeDirector::DisplayModeDirector, DisplayModeDirector::DeviceConfigDisplaySettings::getIntArrayProperty, DisplayModeDirector::getBrightnessObserver, DisplayModeDirector::RealInjector::isDeviceInteractive, DisplayModeDirector::BrightnessObserver::hasValidHighZone, DisplayModeDirector::BrightnessObserver::isInsideHighZone, DisplayModeDirector::BrightnessObserver::dumpLocked, DisplayModeDirector::BrightnessObserver::BrightnessObserver, DisplayModeDirector::SettingsObserver::observe, DisplayModeDirector::Vote::priorityToString, DisplayModeDirector::BrightnessObserver::getRefreshRateInLowZone, DisplayModeDirector::DeviceConfigDisplaySettings::getRefreshRateInZone, DisplayModeDirector::DeviceConfigDisplaySettings::startListening, DisplayModeDirector::BrightnessObserver::updateThresholdsRefreshRateForHighZone, DisplayModeDirector::BrightnessObserver::LightSensorEventListener::isDifferentZone, DisplayModeDirector::DisplayModeDirector, DisplayModeDirector::BrightnessObserver::updateDefaultDisplayState, DisplayModeDirector::BrightnessObserver::updateSensorStatus, DisplayModeDirector::BrightnessObserver::LightSensorEventListener::onSensorChanged, DisplayModeDirector::BrightnessObserver::onDeviceConfigThresholdsChanged, DisplayModeDirector::BrightnessObserver::isDeviceActive, DisplayModeDirector::BrightnessObserver::isDefaultDisplayOn, DisplayModeDirector::BrightnessObserver::onDisplayChanged, DisplayModeDirector::BrightnessObserver::isInsideZone, DisplayModeDirector::BrightnessObserver::hasValidThreshold, DisplayModeDirector::BrightnessObserver::registerLightSensor, DisplayModeDirector::DeviceConfigDisplaySettings::getAmbientThresholds, DisplayModeDirector::DeviceConfigDisplaySettings::getLowAmbientBrightnessThresholds, DisplayModeDirector::DeviceConfigDisplaySettings::getRefreshRateInLowZone, DisplayModeDirector::DisplayModeDirectorHandler::handleMessage, DisplayModeDirector::BrightnessObserver::onDeviceConfigRefreshRateInZoneChanged, DisplayModeDirector::DeviceConfigDisplaySettings::getLowDisplayBrightnessThresholds, DisplayModeDirector::SettingsObserver::setDefaultRefreshRate, DisplayModeDirector::getVote, DisplayModeDirector::BrightnessObserver::getLowDisplayBrightnessThresholds, DisplayModeDirector::BrightnessObserver::LightSensorEventListener::processSensorData, DisplayModeDirector::RealInjector::getDeviceConfig, DisplayModeDirector::DeviceConfigDisplaySettings::onPropertiesChanged, DisplayModeDirector::BrightnessObserver::isInsideLowZone, DisplayModeDirector::BrightnessObserver::onRefreshRateSettingChangedLocked, DisplayModeDirector::BrightnessObserver::onScreenOn, DisplayModeDirector::BrightnessObserver::getLowAmbientBrightnessThresholds, DisplayModeDirector::BrightnessObserver::checkShouldObserve, DisplayModeDirector::BrightnessObserver::LightSensorEventListener::isDifferentZone, DisplayModeDirector::RealInjector::unregisterBrightnessObserver, DisplayModeDirector::BrightnessObserver::LightSensorEventListener::Runnable, DisplayModeDirector::RealInjector::registerBrightnessObserver, DisplayModeDirector::DeviceConfigDisplaySettings::getDefaultPeakRefreshRate, DisplayModeDirector::BrightnessObserver::setDefaultDisplayState, DisplayModeDirector::BrightnessObserver::onDeviceConfigRefreshRateInLowZoneChanged, DisplayModeDirector::DisplayObserver::onDisplayChanged, DisplayModeDirector::BrightnessObserver::onBrightnessChangedLocked, DisplayModeDirector::BrightnessObserver::hasValidLowZone, DisplayModeDirector::BrightnessObserver::restartObserver"
58,14ea33f8e87874069612cb26912bf33bfd0e0be0,DeviceConfigInterface.java,"@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.android.server.wm.utils;
+package com.android.server.utils;
 
 import android.annotation.NonNull;
 import android.annotation.Nullable;
@@ -53,6 +53,11 @@ public interface DeviceConfigInterface {
      */
     boolean getBoolean(@NonNull String namespace, @NonNull String name, boolean defaultValue);
 
+    /**
+     * @see DeviceConfig#getFloat
+     */
+    float getFloat(@NonNull String namespace, @NonNull String name, float defaultValue);
+
     /**
      * @see DeviceConfig#addOnPropertiesChangedListener
      */
@@ -95,6 +100,12 @@ public interface DeviceConfigInterface {
             return DeviceConfig.getBoolean(namespace, name, defaultValue);
         }
 
+        @Override
+        public float getFloat(@NonNull String namespace, @NonNull String name,
+                float defaultValue) {
+            return DeviceConfig.getFloat(namespace, name, defaultValue);
+        }
+
         @Override
         public void addOnPropertiesChangedListener(String namespace, Executor executor,
                 DeviceConfig.OnPropertiesChangedListener listener) {
",12,1,DeviceConfigInterface
59,14ea33f8e87874069612cb26912bf33bfd0e0be0,HighRefreshRateBlacklist.java,"@@ -27,7 +27,7 @@ import android.util.ArraySet;
 import com.android.internal.R;
 import com.android.internal.annotations.VisibleForTesting;
 import com.android.internal.os.BackgroundThread;
-import com.android.server.wm.utils.DeviceConfigInterface;
+import com.android.server.utils.DeviceConfigInterface;
 
 import java.io.PrintWriter;
 
",1,1,
60,14ea33f8e87874069612cb26912bf33bfd0e0be0,WindowManagerConstants.java,"@@ -23,7 +23,7 @@ import android.provider.AndroidDeviceConfig;
 import android.provider.DeviceConfig;
 
 import com.android.internal.annotations.VisibleForTesting;
-import com.android.server.wm.utils.DeviceConfigInterface;
+import com.android.server.utils.DeviceConfigInterface;
 
 import java.io.PrintWriter;
 import java.util.Objects;
",1,1,
61,14ea33f8e87874069612cb26912bf33bfd0e0be0,WindowManagerService.java,"@@ -282,8 +282,8 @@ import com.android.server.policy.WindowManagerPolicy.ScreenOffListener;
 import com.android.server.power.ShutdownThread;
 import com.android.server.protolog.ProtoLogImpl;
 import com.android.server.protolog.common.ProtoLog;
+import com.android.server.utils.DeviceConfigInterface;
 import com.android.server.utils.PriorityDump;
-import com.android.server.wm.utils.DeviceConfigInterface;
 
 import java.io.BufferedWriter;
 import java.io.DataInputStream;
",1,1,
62,14ea33f8e87874069612cb26912bf33bfd0e0be0,DisplayModeDirectorTest.java,"@@ -16,49 +16,96 @@
 
 package com.android.server.display;
 
+import static android.hardware.display.DisplayManager.DeviceConfig.KEY_PEAK_REFRESH_RATE_AMBIENT_BRIGHTNESS_THRESHOLDS;
+import static android.hardware.display.DisplayManager.DeviceConfig.KEY_PEAK_REFRESH_RATE_DISPLAY_BRIGHTNESS_THRESHOLDS;
+import static android.hardware.display.DisplayManager.DeviceConfig.KEY_REFRESH_RATE_IN_ZONE;
+
+import static com.android.server.display.DisplayModeDirector.Vote.PRIORITY_FLICKER;
+
+import static com.google.common.truth.Truth.assertThat;
+
 import static org.junit.Assert.assertTrue;
+import static org.mockito.ArgumentMatchers.anyInt;
+import static org.mockito.ArgumentMatchers.eq;
+import static org.mockito.Mockito.any;
+import static org.mockito.Mockito.spy;
 import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
 
+import android.annotation.NonNull;
+import android.content.ContentResolver;
 import android.content.Context;
+import android.content.ContextWrapper;
+import android.database.ContentObserver;
+import android.hardware.Sensor;
+import android.hardware.SensorEventListener;
+import android.hardware.SensorManager;
 import android.os.Handler;
 import android.os.Looper;
+import android.provider.DeviceConfig;
+import android.provider.Settings;
+import android.test.mock.MockContentResolver;
+import android.util.Slog;
 import android.util.SparseArray;
 import android.view.Display;
 
-import androidx.test.InstrumentationRegistry;
+import androidx.test.core.app.ApplicationProvider;
 import androidx.test.filters.SmallTest;
 import androidx.test.runner.AndroidJUnit4;
 
+import com.android.internal.util.Preconditions;
+import com.android.internal.util.test.FakeSettingsProvider;
+import com.android.internal.util.test.FakeSettingsProviderRule;
 import com.android.server.display.DisplayModeDirector.BrightnessObserver;
 import com.android.server.display.DisplayModeDirector.DesiredDisplayModeSpecs;
 import com.android.server.display.DisplayModeDirector.Vote;
+import com.android.server.testutils.FakeDeviceConfigInterface;
 
 import com.google.common.truth.Truth;
 
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
 import org.mockito.Mockito;
 import org.mockito.MockitoAnnotations;
 
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.concurrent.Executor;
+import java.util.concurrent.TimeUnit;
+import java.util.stream.Collectors;
+
 @SmallTest
 @RunWith(AndroidJUnit4.class)
 public class DisplayModeDirectorTest {
     // The tolerance within which we consider something approximately equals.
+    private static final String TAG = ""DisplayModeDirectorTest"";
+    private static final boolean DEBUG = false;
     private static final float FLOAT_TOLERANCE = 0.01f;
 
     private Context mContext;
+    private FakesInjector mInjector;
+    private Handler mHandler;
+    @Rule
+    public FakeSettingsProviderRule mSettingsProviderRule = FakeSettingsProvider.rule();
 
     @Before
     public void setUp() throws Exception {
         MockitoAnnotations.initMocks(this);
-        mContext = InstrumentationRegistry.getInstrumentation().getTargetContext();
+        mContext = spy(new ContextWrapper(ApplicationProvider.getApplicationContext()));
+        final MockContentResolver resolver = mSettingsProviderRule.mockContentResolver(mContext);
+        when(mContext.getContentResolver()).thenReturn(resolver);
+        mInjector = new FakesInjector();
+        mHandler = new Handler(Looper.getMainLooper());
     }
 
     private DisplayModeDirector createDirectorFromRefreshRateArray(
             float[] refreshRates, int baseModeId) {
         DisplayModeDirector director =
-                new DisplayModeDirector(mContext, new Handler(Looper.getMainLooper()));
+                new DisplayModeDirector(mContext, mHandler, mInjector);
         int displayId = 0;
         Display.Mode[] modes = new Display.Mode[refreshRates.length];
         for (int i = 0; i < refreshRates.length; i++) {
@@ -159,9 +206,9 @@ public class DisplayModeDirectorTest {
     }
 
     @Test
-    public void testBrightnessHasLowerPriorityThanUser() {
-        assertTrue(Vote.PRIORITY_LOW_BRIGHTNESS < Vote.PRIORITY_APP_REQUEST_REFRESH_RATE);
-        assertTrue(Vote.PRIORITY_LOW_BRIGHTNESS < Vote.PRIORITY_APP_REQUEST_SIZE);
+    public void testFlickerHasLowerPriorityThanUser() {
+        assertTrue(PRIORITY_FLICKER < Vote.PRIORITY_APP_REQUEST_REFRESH_RATE);
+        assertTrue(PRIORITY_FLICKER < Vote.PRIORITY_APP_REQUEST_SIZE);
 
         int displayId = 0;
         DisplayModeDirector director = createDirectorFromFpsRange(60, 90);
@@ -169,7 +216,7 @@ public class DisplayModeDirectorTest {
         SparseArray<SparseArray<Vote>> votesByDisplay = new SparseArray<>();
         votesByDisplay.put(displayId, votes);
         votes.put(Vote.PRIORITY_APP_REQUEST_REFRESH_RATE, Vote.forRefreshRates(60, 90));
-        votes.put(Vote.PRIORITY_LOW_BRIGHTNESS, Vote.forRefreshRates(60, 60));
+        votes.put(PRIORITY_FLICKER, Vote.forRefreshRates(60, 60));
         director.injectVotesByDisplay(votesByDisplay);
         DesiredDisplayModeSpecs desiredSpecs = director.getDesiredDisplayModeSpecs(displayId);
         Truth.assertThat(desiredSpecs.primaryRefreshRateRange.min).isWithin(FLOAT_TOLERANCE).of(60);
@@ -177,7 +224,7 @@ public class DisplayModeDirectorTest {
 
         votes.clear();
         votes.put(Vote.PRIORITY_APP_REQUEST_REFRESH_RATE, Vote.forRefreshRates(60, 90));
-        votes.put(Vote.PRIORITY_LOW_BRIGHTNESS, Vote.forRefreshRates(90, 90));
+        votes.put(PRIORITY_FLICKER, Vote.forRefreshRates(90, 90));
         director.injectVotesByDisplay(votesByDisplay);
         desiredSpecs = director.getDesiredDisplayModeSpecs(displayId);
         Truth.assertThat(desiredSpecs.primaryRefreshRateRange.min).isWithin(FLOAT_TOLERANCE).of(90);
@@ -185,7 +232,7 @@ public class DisplayModeDirectorTest {
 
         votes.clear();
         votes.put(Vote.PRIORITY_APP_REQUEST_REFRESH_RATE, Vote.forRefreshRates(90, 90));
-        votes.put(Vote.PRIORITY_LOW_BRIGHTNESS, Vote.forRefreshRates(60, 60));
+        votes.put(PRIORITY_FLICKER, Vote.forRefreshRates(60, 60));
         director.injectVotesByDisplay(votesByDisplay);
         desiredSpecs = director.getDesiredDisplayModeSpecs(displayId);
         Truth.assertThat(desiredSpecs.primaryRefreshRateRange.min).isWithin(FLOAT_TOLERANCE).of(90);
@@ -193,7 +240,7 @@ public class DisplayModeDirectorTest {
 
         votes.clear();
         votes.put(Vote.PRIORITY_APP_REQUEST_REFRESH_RATE, Vote.forRefreshRates(60, 60));
-        votes.put(Vote.PRIORITY_LOW_BRIGHTNESS, Vote.forRefreshRates(90, 90));
+        votes.put(PRIORITY_FLICKER, Vote.forRefreshRates(90, 90));
         director.injectVotesByDisplay(votesByDisplay);
         desiredSpecs = director.getDesiredDisplayModeSpecs(displayId);
         Truth.assertThat(desiredSpecs.primaryRefreshRateRange.min).isWithin(FLOAT_TOLERANCE).of(60);
@@ -202,10 +249,10 @@ public class DisplayModeDirectorTest {
 
     @Test
     public void testAppRequestRefreshRateRange() {
-        // Confirm that the app request range doesn't include low brightness or min refresh rate
-        // settings, but does include everything else.
+        // Confirm that the app request range doesn't include flicker or min refresh rate settings,
+        // but does include everything else.
         assertTrue(
-                Vote.PRIORITY_LOW_BRIGHTNESS < Vote.APP_REQUEST_REFRESH_RATE_RANGE_PRIORITY_CUTOFF);
+                PRIORITY_FLICKER < Vote.APP_REQUEST_REFRESH_RATE_RANGE_PRIORITY_CUTOFF);
         assertTrue(Vote.PRIORITY_USER_SETTING_MIN_REFRESH_RATE
                 < Vote.APP_REQUEST_REFRESH_RATE_RANGE_PRIORITY_CUTOFF);
         assertTrue(Vote.PRIORITY_APP_REQUEST_REFRESH_RATE
@@ -216,7 +263,7 @@ public class DisplayModeDirectorTest {
         SparseArray<Vote> votes = new SparseArray<>();
         SparseArray<SparseArray<Vote>> votesByDisplay = new SparseArray<>();
         votesByDisplay.put(displayId, votes);
-        votes.put(Vote.PRIORITY_LOW_BRIGHTNESS, Vote.forRefreshRates(60, 60));
+        votes.put(PRIORITY_FLICKER, Vote.forRefreshRates(60, 60));
         director.injectVotesByDisplay(votesByDisplay);
         DesiredDisplayModeSpecs desiredSpecs = director.getDesiredDisplayModeSpecs(displayId);
         Truth.assertThat(desiredSpecs.primaryRefreshRateRange.min).isWithin(FLOAT_TOLERANCE).of(60);
@@ -302,4 +349,307 @@ public class DisplayModeDirectorTest {
         verifyBrightnessObserverCall(director, 90, 90, 0, 90, 90);
         verifyBrightnessObserverCall(director, 120, 90, 0, 120, 90);
     }
+
+    @Test
+    public void testBrightnessObserverGetsUpdatedRefreshRatesForZone() {
+        DisplayModeDirector director =
+                createDirectorFromRefreshRateArray(new float[] {60.f, 90.f}, /* baseModeId= */ 0);
+        SensorManager sensorManager = createMockSensorManager(createLightSensor());
+
+        final int initialRefreshRate = 60;
+        mInjector.getDeviceConfig().setRefreshRateInLowZone(initialRefreshRate);
+        director.start(sensorManager);
+        assertThat(director.getBrightnessObserver().getRefreshRateInLowZone())
+                .isEqualTo(initialRefreshRate);
+
+        final int updatedRefreshRate = 90;
+        mInjector.getDeviceConfig().setRefreshRateInLowZone(updatedRefreshRate);
+        // Need to wait for the property change to propagate to the main thread.
+        waitForIdleSync();
+        assertThat(director.getBrightnessObserver().getRefreshRateInLowZone())
+                .isEqualTo(updatedRefreshRate);
+    }
+
+    @Test
+    public void testBrightnessObserverThresholdsInZone() {
+        DisplayModeDirector director =
+                createDirectorFromRefreshRateArray(new float[] {60.f, 90.f}, /* baseModeId= */ 0);
+        SensorManager sensorManager = createMockSensorManager(createLightSensor());
+
+        final int[] initialDisplayThresholds = { 10 };
+        final int[] initialAmbientThresholds = { 20 };
+
+        final FakeDeviceConfig config = mInjector.getDeviceConfig();
+        config.setLowDisplayBrightnessThresholds(initialDisplayThresholds);
+        config.setLowAmbientBrightnessThresholds(initialAmbientThresholds);
+        director.start(sensorManager);
+
+        assertThat(director.getBrightnessObserver().getLowDisplayBrightnessThresholds())
+                .isEqualTo(initialDisplayThresholds);
+        assertThat(director.getBrightnessObserver().getLowAmbientBrightnessThresholds())
+                .isEqualTo(initialAmbientThresholds);
+
+        final int[] updatedDisplayThresholds = { 9, 14 };
+        final int[] updatedAmbientThresholds = { -1, 19 };
+        config.setLowDisplayBrightnessThresholds(updatedDisplayThresholds);
+        config.setLowAmbientBrightnessThresholds(updatedAmbientThresholds);
+        // Need to wait for the property change to propagate to the main thread.
+        waitForIdleSync();
+        assertThat(director.getBrightnessObserver().getLowDisplayBrightnessThresholds())
+                .isEqualTo(updatedDisplayThresholds);
+        assertThat(director.getBrightnessObserver().getLowAmbientBrightnessThresholds())
+                .isEqualTo(updatedAmbientThresholds);
+    }
+
+    @Test
+    public void testLockFpsForLowZone() throws Exception {
+        DisplayModeDirector director =
+                createDirectorFromRefreshRateArray(new float[] {60.f, 90.f}, 0);
+        setPeakRefreshRate(90);
+        director.getSettingsObserver().setDefaultRefreshRate(90);
+        director.getBrightnessObserver().setDefaultDisplayState(true);
+
+        final FakeDeviceConfig config = mInjector.getDeviceConfig();
+        config.setRefreshRateInLowZone(90);
+        config.setLowDisplayBrightnessThresholds(new int[] { 10 });
+        config.setLowAmbientBrightnessThresholds(new int[] { 20 });
+
+        Sensor lightSensor = createLightSensor();
+        SensorManager sensorManager = createMockSensorManager(lightSensor);
+
+        director.start(sensorManager);
+
+        ArgumentCaptor<SensorEventListener> listenerCaptor =
+                ArgumentCaptor.forClass(SensorEventListener.class);
+        Mockito.verify(sensorManager, Mockito.timeout(TimeUnit.SECONDS.toMillis(1)))
+                .registerListener(
+                        listenerCaptor.capture(),
+                        eq(lightSensor),
+                        anyInt(),
+                        any(Handler.class));
+        SensorEventListener listener = listenerCaptor.getValue();
+
+        setBrightness(10);
+        // Sensor reads 20 lux,
+        listener.onSensorChanged(TestUtils.createSensorEvent(lightSensor, 20 /*lux*/));
+
+        Vote vote = director.getVote(Display.DEFAULT_DISPLAY, PRIORITY_FLICKER);
+        assertVoteForRefreshRateLocked(vote, 90 /*fps*/);
+
+        setBrightness(125);
+        // Sensor reads 1000 lux,
+        listener.onSensorChanged(TestUtils.createSensorEvent(lightSensor, 1000 /*lux*/));
+
+        vote = director.getVote(Display.DEFAULT_DISPLAY, PRIORITY_FLICKER);
+        assertThat(vote).isNull();
+    }
+
+    @Test
+    public void testLockFpsForHighZone() throws Exception {
+        DisplayModeDirector director =
+                createDirectorFromRefreshRateArray(new float[] {60.f, 90.f}, 0);
+        setPeakRefreshRate(90 /*fps*/);
+        director.getSettingsObserver().setDefaultRefreshRate(90);
+        director.getBrightnessObserver().setDefaultDisplayState(true);
+        director.updateSettingForHighZone(60, new int[] {255}, new int[] {8000});
+
+        Sensor lightSensor = createLightSensor();
+        SensorManager sensorManager = createMockSensorManager(lightSensor);
+
+        director.start(sensorManager);
+
+        ArgumentCaptor<SensorEventListener> listenerCaptor =
+                ArgumentCaptor.forClass(SensorEventListener.class);
+        Mockito.verify(sensorManager, Mockito.timeout(TimeUnit.SECONDS.toMillis(1)))
+                .registerListener(
+                        listenerCaptor.capture(),
+                        eq(lightSensor),
+                        anyInt(),
+                        any(Handler.class));
+        SensorEventListener listener = listenerCaptor.getValue();
+
+        setBrightness(100);
+        // Sensor reads 2000 lux,
+        listener.onSensorChanged(TestUtils.createSensorEvent(lightSensor, 2000));
+
+        Vote vote = director.getVote(Display.DEFAULT_DISPLAY, PRIORITY_FLICKER);
+        assertThat(vote).isNull();
+
+        setBrightness(255);
+        // Sensor reads 9000 lux,
+        listener.onSensorChanged(TestUtils.createSensorEvent(lightSensor, 9000));
+
+        vote = director.getVote(Display.DEFAULT_DISPLAY, PRIORITY_FLICKER);
+        assertVoteForRefreshRateLocked(vote, 60 /*fps*/);
+    }
+
+    private void assertVoteForRefreshRateLocked(Vote vote, float refreshRate) {
+        assertThat(vote).isNotNull();
+        final DisplayModeDirector.RefreshRateRange expectedRange =
+                new DisplayModeDirector.RefreshRateRange(refreshRate, refreshRate);
+        assertThat(vote.refreshRateRange).isEqualTo(expectedRange);
+    }
+
+    private static class FakeDeviceConfig extends FakeDeviceConfigInterface {
+        @Override
+        public String getProperty(String namespace, String name) {
+            Preconditions.checkArgument(DeviceConfig.NAMESPACE_DISPLAY_MANAGER.equals(namespace));
+            return super.getProperty(namespace, name);
+        }
+
+        @Override
+        public void addOnPropertiesChangedListener(
+                String namespace,
+                Executor executor,
+                DeviceConfig.OnPropertiesChangedListener listener) {
+            Preconditions.checkArgument(DeviceConfig.NAMESPACE_DISPLAY_MANAGER.equals(namespace));
+            super.addOnPropertiesChangedListener(namespace, executor, listener);
+        }
+
+        void setRefreshRateInLowZone(int fps) {
+            putPropertyAndNotify(
+                    DeviceConfig.NAMESPACE_DISPLAY_MANAGER, KEY_REFRESH_RATE_IN_ZONE,
+                    String.valueOf(fps));
+        }
+
+        void setLowDisplayBrightnessThresholds(int[] brightnessThresholds) {
+            String thresholds = toPropertyValue(brightnessThresholds);
+
+            if (DEBUG) {
+                Slog.e(TAG, ""Brightness Thresholds = "" + thresholds);
+            }
+
+            putPropertyAndNotify(
+                    DeviceConfig.NAMESPACE_DISPLAY_MANAGER,
+                    KEY_PEAK_REFRESH_RATE_DISPLAY_BRIGHTNESS_THRESHOLDS,
+                    thresholds);
+        }
+
+        void setLowAmbientBrightnessThresholds(int[] ambientThresholds) {
+            String thresholds = toPropertyValue(ambientThresholds);
+
+            if (DEBUG) {
+                Slog.e(TAG, ""Ambient Thresholds = "" + thresholds);
+            }
+
+            putPropertyAndNotify(
+                    DeviceConfig.NAMESPACE_DISPLAY_MANAGER,
+                    KEY_PEAK_REFRESH_RATE_AMBIENT_BRIGHTNESS_THRESHOLDS,
+                    thresholds);
+        }
+
+        @NonNull
+        private static String toPropertyValue(@NonNull int[] intArray) {
+            return Arrays.stream(intArray)
+                    .mapToObj(Integer::toString)
+                    .collect(Collectors.joining("",""));
+        }
+    }
+
+    private void setBrightness(int brightness) {
+        Settings.System.putInt(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS,
+                brightness);
+        mInjector.notifyBrightnessChanged();
+        waitForIdleSync();
+    }
+
+    private void setPeakRefreshRate(float fps) {
+        Settings.System.putFloat(mContext.getContentResolver(), Settings.System.PEAK_REFRESH_RATE,
+                 fps);
+        mInjector.notifyPeakRefreshRateChanged();
+        waitForIdleSync();
+    }
+
+    private static SensorManager createMockSensorManager(Sensor... sensors) {
+        SensorManager sensorManager = Mockito.mock(SensorManager.class);
+        when(sensorManager.getSensorList(anyInt())).then((invocation) -> {
+            List<Sensor> requestedSensors = new ArrayList<>();
+            int type = invocation.getArgument(0);
+            for (Sensor sensor : sensors) {
+                if (sensor.getType() == type || type == Sensor.TYPE_ALL) {
+                    requestedSensors.add(sensor);
+                }
+            }
+            return requestedSensors;
+        });
+
+        when(sensorManager.getDefaultSensor(anyInt())).then((invocation) -> {
+            int type = invocation.getArgument(0);
+            for (Sensor sensor : sensors) {
+                if (sensor.getType() == type) {
+                    return sensor;
+                }
+            }
+            return null;
+        });
+        return sensorManager;
+    }
+
+    private static Sensor createLightSensor() {
+        try {
+            return TestUtils.createSensor(Sensor.TYPE_LIGHT, Sensor.STRING_TYPE_LIGHT);
+        } catch (Exception e) {
+            // There's nothing we can do if this fails, just throw a RuntimeException so that we
+            // don't have to mark every function that might call this as throwing Exception
+            throw new RuntimeException(""Failed to create a light sensor"", e);
+        }
+    }
+
+    private void waitForIdleSync() {
+        mHandler.runWithScissors(() -> { }, 500 /*timeout*/);
+    }
+
+    static class FakesInjector implements DisplayModeDirector.Injector {
+        private final FakeDeviceConfig mDeviceConfig;
+        private ContentObserver mBrightnessObserver;
+        private ContentObserver mPeakRefreshRateObserver;
+
+        FakesInjector() {
+            mDeviceConfig = new FakeDeviceConfig();
+        }
+
+        @NonNull
+        public FakeDeviceConfig getDeviceConfig() {
+            return mDeviceConfig;
+        }
+
+        @Override
+        public void registerBrightnessObserver(@NonNull ContentResolver cr,
+                @NonNull ContentObserver observer) {
+            if (mBrightnessObserver != null) {
+                throw new IllegalStateException(""Tried to register a second brightness observer"");
+            }
+            mBrightnessObserver = observer;
+        }
+
+        @Override
+        public void unregisterBrightnessObserver(@NonNull ContentResolver cr,
+                @NonNull ContentObserver observer) {
+            mBrightnessObserver = null;
+        }
+
+        void notifyBrightnessChanged() {
+            if (mBrightnessObserver != null) {
+                mBrightnessObserver.dispatchChange(false /*selfChange*/, DISPLAY_BRIGHTNESS_URI);
+            }
+        }
+
+        @Override
+        public void registerPeakRefreshRateObserver(@NonNull ContentResolver cr,
+                @NonNull ContentObserver observer) {
+            mPeakRefreshRateObserver = observer;
+        }
+
+        void notifyPeakRefreshRateChanged() {
+            if (mPeakRefreshRateObserver != null) {
+                mPeakRefreshRateObserver.dispatchChange(false /*selfChange*/,
+                        PEAK_REFRESH_RATE_URI);
+            }
+        }
+
+        @Override
+        public boolean isDeviceInteractive(@NonNull Context context) {
+            return true;
+        }
+    }
 }
",364,14,"DisplayModeDirectorTest::waitForIdleSync, DisplayModeDirectorTest::FakeDeviceConfig::setRefreshRateInLowZone, DisplayModeDirectorTest::setBrightness, DisplayModeDirectorTest::testAppRequestRefreshRateRange, DisplayModeDirectorTest::testLockFpsForHighZone, DisplayModeDirectorTest::FakeDeviceConfig::toPropertyValue, DisplayModeDirectorTest::testBrightnessObserverGetsUpdatedRefreshRatesForZone, DisplayModeDirectorTest::assertVoteForRefreshRateLocked, DisplayModeDirectorTest::createLightSensor, DisplayModeDirectorTest::setUp, DisplayModeDirectorTest::FakesInjector::getDeviceConfig, DisplayModeDirectorTest::testBrightnessObserverThresholdsInZone, DisplayModeDirectorTest::FakesInjector::unregisterBrightnessObserver, DisplayModeDirectorTest::FakesInjector::notifyBrightnessChanged, DisplayModeDirectorTest::createMockSensorManager, DisplayModeDirectorTest::FakesInjector::registerPeakRefreshRateObserver, DisplayModeDirectorTest::FakeDeviceConfig::setLowDisplayBrightnessThresholds, DisplayModeDirectorTest::FakeDeviceConfig::setLowAmbientBrightnessThresholds, DisplayModeDirectorTest::FakesInjector::registerBrightnessObserver, DisplayModeDirectorTest::FakesInjector::isDeviceInteractive, DisplayModeDirectorTest::testLockFpsForLowZone, DisplayModeDirectorTest::setPeakRefreshRate, DisplayModeDirectorTest::createDirectorFromRefreshRateArray, DisplayModeDirectorTest::FakesInjector::FakesInjector, DisplayModeDirectorTest::FakeDeviceConfig::getProperty, DisplayModeDirectorTest::FakeDeviceConfig::addOnPropertiesChangedListener, DisplayModeDirectorTest::testBrightnessHasLowerPriorityThanUser, DisplayModeDirectorTest::testFlickerHasLowerPriorityThanUser, DisplayModeDirectorTest::FakesInjector::notifyPeakRefreshRateChanged"
63,14ea33f8e87874069612cb26912bf33bfd0e0be0,FakeDeviceConfigInterface.java,"@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.android.server.wm.utils;
+package com.android.server.testutils;
 
 import android.annotation.NonNull;
 import android.provider.DeviceConfig;
@@ -22,6 +22,7 @@ import android.util.ArrayMap;
 import android.util.Pair;
 
 import com.android.internal.util.Preconditions;
+import com.android.server.utils.DeviceConfigInterface;
 
 import java.lang.reflect.Constructor;
 import java.util.HashMap;
@@ -121,6 +122,19 @@ public class FakeDeviceConfigInterface implements DeviceConfigInterface {
         }
     }
 
+    @Override
+    public float getFloat(String namespace, String name, float defaultValue) {
+        String value = getProperty(namespace, name);
+        if (value == null) {
+            return defaultValue;
+        }
+        try {
+            return Float.parseFloat(value);
+        } catch (NumberFormatException e) {
+            return defaultValue;
+        }
+    }
+
     @Override
     public boolean getBoolean(String namespace, String name, boolean defaultValue) {
         String value = getProperty(namespace, name);
",15,1,FakeDeviceConfigInterface::getFloat
64,14ea33f8e87874069612cb26912bf33bfd0e0be0,HighRefreshRateBlacklistTest.java,"@@ -31,7 +31,7 @@ import androidx.test.filters.SmallTest;
 
 import com.android.internal.R;
 import com.android.internal.util.Preconditions;
-import com.android.server.wm.utils.FakeDeviceConfigInterface;
+import com.android.server.testutils.FakeDeviceConfigInterface;
 
 import org.junit.After;
 import org.junit.Test;
",1,1,
65,14ea33f8e87874069612cb26912bf33bfd0e0be0,WindowManagerConstantsTest.java,"@@ -32,7 +32,7 @@ import android.platform.test.annotations.Presubmit;
 
 import androidx.test.filters.SmallTest;
 
-import com.android.server.wm.utils.FakeDeviceConfigInterface;
+import com.android.server.testutils.FakeDeviceConfigInterface;
 
 import org.junit.After;
 import org.junit.Before;
",1,1,
66,b80ca7e2abedc724fd31d6dfac0798f52ba2e6e3,DisplayManager.java,"@@ -875,37 +875,76 @@ public final class DisplayManager {
     public interface DeviceConfig {
 
         /**
-         * Key for refresh rate in the zone defined by thresholds.
+         * Key for refresh rate in the low zone defined by thresholds.
          *
+         * Note that the name and value don't match because they were added before we had a high
+         * zone to consider.
          * @see android.provider.DeviceConfig#NAMESPACE_DISPLAY_MANAGER
          * @see android.R.integer#config_defaultZoneBehavior
          */
-        String KEY_REFRESH_RATE_IN_ZONE = ""refresh_rate_in_zone"";
+        String KEY_REFRESH_RATE_IN_LOW_ZONE = ""refresh_rate_in_zone"";
 
         /**
-         * Key for accessing the display brightness thresholds for the configured refresh rate zone.
+         * Key for accessing the low display brightness thresholds for the configured refresh
+         * rate zone.
          * The value will be a pair of comma separated integers representing the minimum and maximum
          * thresholds of the zone, respectively, in display backlight units (i.e. [0, 255]).
          *
+         * Note that the name and value don't match because they were added before we had a high
+         * zone to consider.
+         *
          * @see android.provider.DeviceConfig#NAMESPACE_DISPLAY_MANAGER
          * @see android.R.array#config_brightnessThresholdsOfPeakRefreshRate
          * @hide
          */
-        String KEY_PEAK_REFRESH_RATE_DISPLAY_BRIGHTNESS_THRESHOLDS =
+        String KEY_FIXED_REFRESH_RATE_LOW_DISPLAY_BRIGHTNESS_THRESHOLDS =
                 ""peak_refresh_rate_brightness_thresholds"";
 
         /**
-         * Key for accessing the ambient brightness thresholds for the configured refresh rate zone.
-         * The value will be a pair of comma separated integers representing the minimum and maximum
-         * thresholds of the zone, respectively, in lux.
+         * Key for accessing the low ambient brightness thresholds for the configured refresh
+         * rate zone. The value will be a pair of comma separated integers representing the minimum
+         * and maximum thresholds of the zone, respectively, in lux.
+         *
+         * Note that the name and value don't match because they were added before we had a high
+         * zone to consider.
          *
          * @see android.provider.DeviceConfig#NAMESPACE_DISPLAY_MANAGER
          * @see android.R.array#config_ambientThresholdsOfPeakRefreshRate
          * @hide
          */
-        String KEY_PEAK_REFRESH_RATE_AMBIENT_BRIGHTNESS_THRESHOLDS =
+        String KEY_FIXED_REFRESH_RATE_LOW_AMBIENT_BRIGHTNESS_THRESHOLDS =
                 ""peak_refresh_rate_ambient_thresholds"";
+        /**
+         * Key for refresh rate in the high zone defined by thresholds.
+         *
+         * @see android.provider.DeviceConfig#NAMESPACE_DISPLAY_MANAGER
+         * @see android.R.integer#config_fixedRefreshRateInHighZone
+         */
+        String KEY_REFRESH_RATE_IN_HIGH_ZONE = ""refresh_rate_in_high_zone"";
 
+        /**
+         * Key for accessing the display brightness thresholds for the configured refresh rate zone.
+         * The value will be a pair of comma separated integers representing the minimum and maximum
+         * thresholds of the zone, respectively, in display backlight units (i.e. [0, 255]).
+         *
+         * @see android.provider.DeviceConfig#NAMESPACE_DISPLAY_MANAGER
+         * @see android.R.array#config_brightnessHighThresholdsOfFixedRefreshRate
+         * @hide
+         */
+        String KEY_FIXED_REFRESH_RATE_HIGH_DISPLAY_BRIGHTNESS_THRESHOLDS =
+                ""fixed_refresh_rate_high_display_brightness_thresholds"";
+
+        /**
+         * Key for accessing the ambient brightness thresholds for the configured refresh rate zone.
+         * The value will be a pair of comma separated integers representing the minimum and maximum
+         * thresholds of the zone, respectively, in lux.
+         *
+         * @see android.provider.DeviceConfig#NAMESPACE_DISPLAY_MANAGER
+         * @see android.R.array#config_ambientHighThresholdsOfFixedRefreshRate
+         * @hide
+         */
+        String KEY_FIXED_REFRESH_RATE_HIGH_AMBIENT_BRIGHTNESS_THRESHOLDS =
+                ""fixed_refresh_rate_high_ambient_brightness_thresholds"";
         /**
          * Key for default peak refresh rate
          *
",47,8,
67,b80ca7e2abedc724fd31d6dfac0798f52ba2e6e3,DisplayModeDirector.java,"@@ -69,6 +69,8 @@ public class DisplayModeDirector {
     private static final int MSG_LOW_BRIGHTNESS_THRESHOLDS_CHANGED = 2;
     private static final int MSG_DEFAULT_PEAK_REFRESH_RATE_CHANGED = 3;
     private static final int MSG_REFRESH_RATE_IN_LOW_ZONE_CHANGED = 4;
+    private static final int MSG_REFRESH_RATE_IN_HIGH_ZONE_CHANGED = 5;
+    private static final int MSG_HIGH_BRIGHTNESS_THRESHOLDS_CHANGED = 6;
 
     // Special ID used to indicate that given vote is to be applied globally, rather than to a
     // specific display.
@@ -515,13 +517,6 @@ public class DisplayModeDirector {
         }
     }
 
-    @VisibleForTesting
-    void updateSettingForHighZone(int refreshRate, int[] brightnessThresholds,
-            int[] ambientThresholds) {
-        mBrightnessObserver.updateThresholdsRefreshRateForHighZone(refreshRate,
-                brightnessThresholds, ambientThresholds);
-    }
-
     /**
      * Listens for changes refresh rate coordination.
      */
@@ -540,23 +535,41 @@ public class DisplayModeDirector {
         @Override
         public void handleMessage(Message msg) {
             switch (msg.what) {
-                case MSG_LOW_BRIGHTNESS_THRESHOLDS_CHANGED:
+                case MSG_LOW_BRIGHTNESS_THRESHOLDS_CHANGED: {
                     Pair<int[], int[]> thresholds = (Pair<int[], int[]>) msg.obj;
                     mBrightnessObserver.onDeviceConfigLowBrightnessThresholdsChanged(
                             thresholds.first, thresholds.second);
                     break;
+                }
 
-                case MSG_DEFAULT_PEAK_REFRESH_RATE_CHANGED:
-                    Float defaultPeakRefreshRate = (Float) msg.obj;
-                    mSettingsObserver.onDeviceConfigDefaultPeakRefreshRateChanged(
-                            defaultPeakRefreshRate);
+                case MSG_REFRESH_RATE_IN_LOW_ZONE_CHANGED: {
+                    int refreshRateInZone = msg.arg1;
+                    mBrightnessObserver.onDeviceConfigRefreshRateInLowZoneChanged(
+                            refreshRateInZone);
                     break;
+                }
+
+                case MSG_HIGH_BRIGHTNESS_THRESHOLDS_CHANGED: {
+                    Pair<int[], int[]> thresholds = (Pair<int[], int[]>) msg.obj;
+
+                    mBrightnessObserver.onDeviceConfigHighBrightnessThresholdsChanged(
+                            thresholds.first, thresholds.second);
+
+                    break;
+                }
 
-                case MSG_REFRESH_RATE_IN_LOW_ZONE_CHANGED:
+                case MSG_REFRESH_RATE_IN_HIGH_ZONE_CHANGED: {
                     int refreshRateInZone = msg.arg1;
-                    mBrightnessObserver.onDeviceConfigRefreshRateInLowZoneChanged(
+                    mBrightnessObserver.onDeviceConfigRefreshRateInHighZoneChanged(
                             refreshRateInZone);
                     break;
+                }
+
+                case MSG_DEFAULT_PEAK_REFRESH_RATE_CHANGED:
+                    Float defaultPeakRefreshRate = (Float) msg.obj;
+                    mSettingsObserver.onDeviceConfigDefaultPeakRefreshRateChanged(
+                            defaultPeakRefreshRate);
+                    break;
 
                 case MSG_REFRESH_RATE_RANGE_CHANGED:
                     DesiredDisplayModeSpecsListener desiredDisplayModeSpecsListener =
@@ -1220,13 +1233,6 @@ public class DisplayModeDirector {
                     mLightSensor, LIGHT_SENSOR_RATE_MS * 1000, mHandler);
         }
 
-        public void updateThresholdsRefreshRateForHighZone(int refreshRate,
-                int[] brightnessThresholds, int[] ambientThresholds) {
-            mRefreshRateInHighZone = refreshRate;
-            mHighDisplayBrightnessThresholds = brightnessThresholds;
-            mHighAmbientBrightnessThresholds = ambientThresholds;
-        }
-
         public void observe(SensorManager sensorManager) {
             mSensorManager = sensorManager;
             final ContentResolver cr = mContext.getContentResolver();
@@ -1246,7 +1252,22 @@ public class DisplayModeDirector {
                 mLowAmbientBrightnessThresholds = lowAmbientBrightnessThresholds;
             }
 
+
+            int[] highDisplayBrightnessThresholds =
+                    mDeviceConfigDisplaySettings.getHighDisplayBrightnessThresholds();
+            int[] highAmbientBrightnessThresholds =
+                    mDeviceConfigDisplaySettings.getHighAmbientBrightnessThresholds();
+
+            if (highDisplayBrightnessThresholds != null && highAmbientBrightnessThresholds != null
+                    && highDisplayBrightnessThresholds.length
+                    == highAmbientBrightnessThresholds.length) {
+                mHighDisplayBrightnessThresholds = highDisplayBrightnessThresholds;
+                mHighAmbientBrightnessThresholds = highAmbientBrightnessThresholds;
+            }
+
             mRefreshRateInLowZone = mDeviceConfigDisplaySettings.getRefreshRateInLowZone();
+            mRefreshRateInHighZone = mDeviceConfigDisplaySettings.getRefreshRateInHighZone();
+
             restartObserver();
             mDeviceConfigDisplaySettings.startListening();
         }
@@ -1293,6 +1314,29 @@ public class DisplayModeDirector {
             }
         }
 
+        public void onDeviceConfigHighBrightnessThresholdsChanged(int[] displayThresholds,
+                int[] ambientThresholds) {
+            if (displayThresholds != null && ambientThresholds != null
+                    && displayThresholds.length == ambientThresholds.length) {
+                mHighDisplayBrightnessThresholds = displayThresholds;
+                mHighAmbientBrightnessThresholds = ambientThresholds;
+            } else {
+                // Invalid or empty. Use device default.
+                mHighDisplayBrightnessThresholds = mContext.getResources().getIntArray(
+                        R.array.config_highDisplayBrightnessThresholdsOfFixedRefreshRate);
+                mHighAmbientBrightnessThresholds = mContext.getResources().getIntArray(
+                        R.array.config_highAmbientBrightnessThresholdsOfFixedRefreshRate);
+            }
+            restartObserver();
+        }
+
+        public void onDeviceConfigRefreshRateInHighZoneChanged(int refreshRate) {
+            if (refreshRate != mRefreshRateInHighZone) {
+                mRefreshRateInHighZone = refreshRate;
+                restartObserver();
+            }
+        }
+
         public void dumpLocked(PrintWriter pw) {
             pw.println(""  BrightnessObserver"");
             pw.println(""    mAmbientLux: "" + mAmbientLux);
@@ -1668,7 +1712,7 @@ public class DisplayModeDirector {
         public int[] getLowDisplayBrightnessThresholds() {
             return getIntArrayProperty(
                     DisplayManager.DeviceConfig.
-                            KEY_PEAK_REFRESH_RATE_DISPLAY_BRIGHTNESS_THRESHOLDS);
+                            KEY_FIXED_REFRESH_RATE_LOW_DISPLAY_BRIGHTNESS_THRESHOLDS);
         }
 
         /*
@@ -1677,7 +1721,7 @@ public class DisplayModeDirector {
         public int[] getLowAmbientBrightnessThresholds() {
             return getIntArrayProperty(
                     DisplayManager.DeviceConfig.
-                            KEY_PEAK_REFRESH_RATE_AMBIENT_BRIGHTNESS_THRESHOLDS);
+                            KEY_FIXED_REFRESH_RATE_LOW_AMBIENT_BRIGHTNESS_THRESHOLDS);
         }
 
         public int getRefreshRateInLowZone() {
@@ -1686,7 +1730,37 @@ public class DisplayModeDirector {
 
             int refreshRate = mDeviceConfig.getInt(
                     DeviceConfig.NAMESPACE_DISPLAY_MANAGER,
-                    DisplayManager.DeviceConfig.KEY_REFRESH_RATE_IN_ZONE,
+                    DisplayManager.DeviceConfig.KEY_REFRESH_RATE_IN_LOW_ZONE,
+                    defaultRefreshRateInZone);
+
+            return refreshRate;
+        }
+
+        /*
+         * Return null if no such property or wrong format (not comma separated integers).
+         */
+        public int[] getHighDisplayBrightnessThresholds() {
+            return getIntArrayProperty(
+                    DisplayManager.DeviceConfig
+                            .KEY_FIXED_REFRESH_RATE_HIGH_DISPLAY_BRIGHTNESS_THRESHOLDS);
+        }
+
+        /*
+         * Return null if no such property or wrong format (not comma separated integers).
+         */
+        public int[] getHighAmbientBrightnessThresholds() {
+            return getIntArrayProperty(
+                    DisplayManager.DeviceConfig
+                            .KEY_FIXED_REFRESH_RATE_HIGH_AMBIENT_BRIGHTNESS_THRESHOLDS);
+        }
+
+        public int getRefreshRateInHighZone() {
+            int defaultRefreshRateInZone = mContext.getResources().getInteger(
+                    R.integer.config_fixedRefreshRateInHighZone);
+
+            int refreshRate = mDeviceConfig.getInt(
+                    DeviceConfig.NAMESPACE_DISPLAY_MANAGER,
+                    DisplayManager.DeviceConfig.KEY_REFRESH_RATE_IN_HIGH_ZONE,
                     defaultRefreshRateInZone);
 
             return refreshRate;
@@ -1721,6 +1795,16 @@ public class DisplayModeDirector {
                     .sendToTarget();
             mHandler.obtainMessage(MSG_REFRESH_RATE_IN_LOW_ZONE_CHANGED, refreshRateInLowZone, 0)
                     .sendToTarget();
+
+            int[] highDisplayBrightnessThresholds = getHighDisplayBrightnessThresholds();
+            int[] highAmbientBrightnessThresholds = getHighAmbientBrightnessThresholds();
+            int refreshRateInHighZone = getRefreshRateInHighZone();
+
+            mHandler.obtainMessage(MSG_HIGH_BRIGHTNESS_THRESHOLDS_CHANGED,
+                    new Pair<>(highDisplayBrightnessThresholds, highAmbientBrightnessThresholds))
+                    .sendToTarget();
+            mHandler.obtainMessage(MSG_REFRESH_RATE_IN_HIGH_ZONE_CHANGED, refreshRateInHighZone, 0)
+                    .sendToTarget();
         }
 
         private int[] getIntArrayProperty(String prop) {
",108,24,"DisplayModeDirector::DeviceConfigDisplaySettings::getHighAmbientBrightnessThresholds, DisplayModeDirector::DeviceConfigDisplaySettings::getRefreshRateInHighZone, DisplayModeDirector::updateSettingForHighZone, DisplayModeDirector::BrightnessObserver::observe, DisplayModeDirector::DeviceConfigDisplaySettings::getLowDisplayBrightnessThresholds, DisplayModeDirector::BrightnessObserver::updateThresholdsRefreshRateForHighZone, DisplayModeDirector::DeviceConfigDisplaySettings::getLowAmbientBrightnessThresholds, DisplayModeDirector::DeviceConfigDisplaySettings::getRefreshRateInLowZone, DisplayModeDirector::DeviceConfigDisplaySettings::onPropertiesChanged, DisplayModeDirector::BrightnessObserver::onDeviceConfigHighBrightnessThresholdsChanged, DisplayModeDirector::DeviceConfigDisplaySettings::getHighDisplayBrightnessThresholds, DisplayModeDirector::DisplayModeDirectorHandler::handleMessage, DisplayModeDirector::BrightnessObserver::onDeviceConfigRefreshRateInHighZoneChanged"
68,b80ca7e2abedc724fd31d6dfac0798f52ba2e6e3,DisplayModeDirectorTest.java,"@@ -16,9 +16,12 @@
 
 package com.android.server.display;
 
-import static android.hardware.display.DisplayManager.DeviceConfig.KEY_PEAK_REFRESH_RATE_AMBIENT_BRIGHTNESS_THRESHOLDS;
-import static android.hardware.display.DisplayManager.DeviceConfig.KEY_PEAK_REFRESH_RATE_DISPLAY_BRIGHTNESS_THRESHOLDS;
-import static android.hardware.display.DisplayManager.DeviceConfig.KEY_REFRESH_RATE_IN_ZONE;
+import static android.hardware.display.DisplayManager.DeviceConfig.KEY_FIXED_REFRESH_RATE_HIGH_AMBIENT_BRIGHTNESS_THRESHOLDS;
+import static android.hardware.display.DisplayManager.DeviceConfig.KEY_FIXED_REFRESH_RATE_HIGH_DISPLAY_BRIGHTNESS_THRESHOLDS;
+import static android.hardware.display.DisplayManager.DeviceConfig.KEY_FIXED_REFRESH_RATE_LOW_AMBIENT_BRIGHTNESS_THRESHOLDS;
+import static android.hardware.display.DisplayManager.DeviceConfig.KEY_FIXED_REFRESH_RATE_LOW_DISPLAY_BRIGHTNESS_THRESHOLDS;
+import static android.hardware.display.DisplayManager.DeviceConfig.KEY_REFRESH_RATE_IN_HIGH_ZONE;
+import static android.hardware.display.DisplayManager.DeviceConfig.KEY_REFRESH_RATE_IN_LOW_ZONE;
 
 import static com.android.server.display.DisplayModeDirector.Vote.PRIORITY_FLICKER;
 
@@ -451,7 +454,11 @@ public class DisplayModeDirectorTest {
         setPeakRefreshRate(90 /*fps*/);
         director.getSettingsObserver().setDefaultRefreshRate(90);
         director.getBrightnessObserver().setDefaultDisplayState(true);
-        director.updateSettingForHighZone(60, new int[] {255}, new int[] {8000});
+
+        final FakeDeviceConfig config = mInjector.getDeviceConfig();
+        config.setRefreshRateInHighZone(60);
+        config.setHighDisplayBrightnessThresholds(new int[] { 255 });
+        config.setHighAmbientBrightnessThresholds(new int[] { 8000 });
 
         Sensor lightSensor = createLightSensor();
         SensorManager sensorManager = createMockSensorManager(lightSensor);
@@ -508,7 +515,7 @@ public class DisplayModeDirectorTest {
 
         void setRefreshRateInLowZone(int fps) {
             putPropertyAndNotify(
-                    DeviceConfig.NAMESPACE_DISPLAY_MANAGER, KEY_REFRESH_RATE_IN_ZONE,
+                    DeviceConfig.NAMESPACE_DISPLAY_MANAGER, KEY_REFRESH_RATE_IN_LOW_ZONE,
                     String.valueOf(fps));
         }
 
@@ -521,7 +528,7 @@ public class DisplayModeDirectorTest {
 
             putPropertyAndNotify(
                     DeviceConfig.NAMESPACE_DISPLAY_MANAGER,
-                    KEY_PEAK_REFRESH_RATE_DISPLAY_BRIGHTNESS_THRESHOLDS,
+                    KEY_FIXED_REFRESH_RATE_LOW_DISPLAY_BRIGHTNESS_THRESHOLDS,
                     thresholds);
         }
 
@@ -534,7 +541,39 @@ public class DisplayModeDirectorTest {
 
             putPropertyAndNotify(
                     DeviceConfig.NAMESPACE_DISPLAY_MANAGER,
-                    KEY_PEAK_REFRESH_RATE_AMBIENT_BRIGHTNESS_THRESHOLDS,
+                    KEY_FIXED_REFRESH_RATE_LOW_AMBIENT_BRIGHTNESS_THRESHOLDS,
+                    thresholds);
+        }
+
+        void setRefreshRateInHighZone(int fps) {
+            putPropertyAndNotify(
+                    DeviceConfig.NAMESPACE_DISPLAY_MANAGER, KEY_REFRESH_RATE_IN_HIGH_ZONE,
+                    String.valueOf(fps));
+        }
+
+        void setHighDisplayBrightnessThresholds(int[] brightnessThresholds) {
+            String thresholds = toPropertyValue(brightnessThresholds);
+
+            if (DEBUG) {
+                Slog.e(TAG, ""Brightness Thresholds = "" + thresholds);
+            }
+
+            putPropertyAndNotify(
+                    DeviceConfig.NAMESPACE_DISPLAY_MANAGER,
+                    KEY_FIXED_REFRESH_RATE_HIGH_DISPLAY_BRIGHTNESS_THRESHOLDS,
+                    thresholds);
+        }
+
+        void setHighAmbientBrightnessThresholds(int[] ambientThresholds) {
+            String thresholds = toPropertyValue(ambientThresholds);
+
+            if (DEBUG) {
+                Slog.e(TAG, ""Ambient Thresholds = "" + thresholds);
+            }
+
+            putPropertyAndNotify(
+                    DeviceConfig.NAMESPACE_DISPLAY_MANAGER,
+                    KEY_FIXED_REFRESH_RATE_HIGH_AMBIENT_BRIGHTNESS_THRESHOLDS,
                     thresholds);
         }
 
",46,7,"DisplayModeDirectorTest::FakeDeviceConfig::setLowAmbientBrightnessThresholds, DisplayModeDirectorTest::FakeDeviceConfig::setRefreshRateInLowZone, DisplayModeDirectorTest::FakeDeviceConfig::setHighAmbientBrightnessThresholds, DisplayModeDirectorTest::testLockFpsForHighZone, DisplayModeDirectorTest::FakeDeviceConfig::setHighDisplayBrightnessThresholds, DisplayModeDirectorTest::FakeDeviceConfig::setRefreshRateInHighZone, DisplayModeDirectorTest::FakeDeviceConfig::setLowDisplayBrightnessThresholds"
69,d24d25db774b4b6a67029e122191da810970a9a6,PeriodicAdvertisingCallback.java,"@@ -78,4 +78,13 @@ public abstract class PeriodicAdvertisingCallback {
      */
     public void onSyncLost(int syncHandle) {
     }
+
+    /**
+     * Callback when periodic sync transfered.
+     *
+     * @param device
+     * @param status
+     */
+    public void onSyncTransfered(BluetoothDevice device, int status) {
+    }
 }
",9,0,PeriodicAdvertisingCallback::onSyncTransfered
70,d24d25db774b4b6a67029e122191da810970a9a6,PeriodicAdvertisingManager.java,"@@ -196,6 +196,62 @@ public final class PeriodicAdvertisingManager {
         }
     }
 
+    public void transferSync(BluetoothDevice bda, int service_data, int sync_handle) {
+        IBluetoothGatt gatt;
+        try {
+            gatt = mBluetoothManager.getBluetoothGatt();
+        } catch (RemoteException e) {
+            Log.e(TAG, ""Failed to get Bluetooth gatt - "", e);
+            PeriodicAdvertisingCallback callback = null;
+            for (PeriodicAdvertisingCallback cb : mCallbackWrappers.keySet()) {
+                callback = cb;
+            }
+            if (callback != null) {
+                callback.onSyncTransfered(bda,
+                        PeriodicAdvertisingCallback.SYNC_NO_RESOURCES);
+            }
+            return;
+        }
+        try {
+            gatt.transferSync(bda, service_data , sync_handle);
+        } catch (RemoteException e) {
+            Log.e(TAG, ""Failed to register sync - "", e);
+            return;
+        }
+    }
+
+    public void transferSetInfo(BluetoothDevice bda, int service_data,
+                      int adv_handle, PeriodicAdvertisingCallback callback) {
+        transferSetInfo(bda, service_data, adv_handle, callback, null);
+    }
+
+    public void transferSetInfo (BluetoothDevice bda, int service_data,
+                        int adv_handle, PeriodicAdvertisingCallback callback, Handler handler) {
+        if (callback == null) {
+            throw new IllegalArgumentException(""callback can't be null"");
+        }
+        IBluetoothGatt gatt;
+        try {
+            gatt = mBluetoothManager.getBluetoothGatt();
+        } catch (RemoteException e) {
+            Log.e(TAG, ""Failed to get Bluetooth gatt - "", e);
+            return;
+        }
+        if (handler == null) {
+            handler = new Handler(Looper.getMainLooper());
+        }
+        IPeriodicAdvertisingCallback wrapper = wrap(callback, handler);
+        if (wrapper == null) {
+            throw new IllegalArgumentException(""callback was not properly registered"");
+        }
+        try {
+            gatt.transferSetInfo(bda, service_data , adv_handle, wrapper);
+        } catch (RemoteException e) {
+            Log.e(TAG, ""Failed to register sync - "", e);
+            return;
+        }
+
+    }
     private IPeriodicAdvertisingCallback wrap(PeriodicAdvertisingCallback callback,
             Handler handler) {
         return new IPeriodicAdvertisingCallback.Stub() {
@@ -239,6 +295,18 @@ public final class PeriodicAdvertisingManager {
                     }
                 });
             }
+
+            public void onSyncTransfered(BluetoothDevice device, int status) {
+                handler.post(new Runnable() {
+                    @Override
+                    public void run() {
+                        callback.onSyncTransfered(device, status);
+                        // App can still unregister the sync until notified it's lost.
+                        // Remove callback after app was notifed.
+                        //mCallbackWrappers.remove(callback);
+                    }
+                });
+            }
         };
     }
 }
",68,0,"PeriodicAdvertisingManager::wrap, PeriodicAdvertisingManager::transferSetInfo, PeriodicAdvertisingManager::transferSetInfo, PeriodicAdvertisingManager::transferSync"
71,4d3f23e48452eaae2f82c3e17a4c2cf8bb44c480,BluetoothDevice.java,"@@ -2355,6 +2355,48 @@ public final class BluetoothDevice implements Parcelable {
     public BluetoothGatt connectGatt(Context context, boolean autoConnect,
             BluetoothGattCallback callback, int transport,
             boolean opportunistic, int phy, Handler handler) {
+        return connectGatt(context, autoConnect, callback, transport, opportunistic,
+                phy, handler, false);
+    }
+
+    /**
+     * Connect to GATT Server hosted by this device. Caller acts as GATT client.
+     * The callback is used to deliver results to Caller, such as connection status as well
+     * as any further GATT client operations.
+     * The method returns a BluetoothGatt instance. You can use BluetoothGatt to conduct
+     * GATT client operations.
+     *
+     * @param callback GATT callback handler that will receive asynchronous callbacks.
+     * @param autoConnect Whether to directly connect to the remote device (false) or to
+     * automatically connect as soon as the remote device becomes available (true).
+     * @param transport preferred transport for GATT connections to remote dual-mode devices {@link
+     * BluetoothDevice#TRANSPORT_AUTO} or {@link BluetoothDevice#TRANSPORT_BREDR} or {@link
+     * BluetoothDevice#TRANSPORT_LE}
+     * @param opportunistic Whether this GATT client is opportunistic. An opportunistic GATT client
+     * does not hold a GATT connection. It automatically disconnects when no other GATT connections
+     * are active for the remote device.
+     * @param phy preferred PHY for connections to remote LE device. Bitwise OR of any of {@link
+     * BluetoothDevice#PHY_LE_1M_MASK}, {@link BluetoothDevice#PHY_LE_2M_MASK}, an d{@link
+     * BluetoothDevice#PHY_LE_CODED_MASK}. This option does not take effect if {@code autoConnect}
+     * is set to true.
+     * @param handler The handler to use for the callback. If {@code null}, callbacks will happen on
+     * an un-specified background thread.
+     * @param eattSupport specifies whether client app needs EATT channel for client operations.
+     * If both local and remote devices support EATT and local app asks for EATT, GATT client
+     * operations will be performed using EATT channel.
+     * If either local or remote device doesn't support EATT but local App asks for EATT, GATT
+     * client operations will be performed using unenhanced ATT channel.
+     *
+     * @return A BluetoothGatt instance. You can use BluetoothGatt to conduct GATT client
+     * operations.
+     *
+     * @throws NullPointerException if callback is null
+     *
+     * @hide
+     */
+    public BluetoothGatt connectGatt(Context context, boolean autoConnect,
+            BluetoothGattCallback callback, int transport, boolean opportunistic,
+            int phy, Handler handler, boolean eattSupport) {
         if (callback == null) {
             throw new NullPointerException(""callback is null"");
         }
@@ -2370,7 +2412,7 @@ public final class BluetoothDevice implements Parcelable {
                 return null;
             }
             BluetoothGatt gatt = new BluetoothGatt(iGatt, this, transport, opportunistic, phy);
-            gatt.connect(autoConnect, callback, handler);
+            gatt.connect(autoConnect, callback, handler, eattSupport);
             return gatt;
         } catch (RemoteException e) {
             Log.e(TAG, """", e);
",43,1,"BluetoothDevice::connectGatt, BluetoothDevice::connectGatt"
72,4d3f23e48452eaae2f82c3e17a4c2cf8bb44c480,BluetoothGatt.java,"@@ -799,6 +799,28 @@ public final class BluetoothGatt implements BluetoothProfile {
      * error
      */
     private boolean registerApp(BluetoothGattCallback callback, Handler handler) {
+        return registerApp(callback, handler, false);
+    }
+
+    /**
+     * Register an application callback to start using GATT.
+     *
+     * <p>This is an asynchronous call. The callback {@link BluetoothGattCallback#onAppRegistered}
+     * is used to notify success or failure if the function returns true.
+     *
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
+     *
+     * @param callback GATT callback handler that will receive asynchronous callbacks.
+     * @param eattSupport specifies whether client app needs EATT channel for client operations.
+     * If both local and remote devices support EATT and local app asks for EATT, GATT client
+     * operations will be performed using EATT channel.
+     * If either local or remote device doesn't support EATT but local App asks for EATT, GATT
+     * client operations will be performed using unenhanced ATT channel.
+     * @return If true, the callback will be called to notify success or failure, false on immediate
+     * error
+     * @hide
+     */
+    private boolean registerApp(BluetoothGattCallback callback, Handler handler, boolean eattSupport) {
         if (DBG) Log.d(TAG, ""registerApp()"");
         if (mService == null) return false;
 
@@ -808,7 +830,7 @@ public final class BluetoothGatt implements BluetoothProfile {
         if (DBG) Log.d(TAG, ""registerApp() - UUID="" + uuid);
 
         try {
-            mService.registerClient(new ParcelUuid(uuid), mBluetoothGattCallback);
+            mService.registerClient(new ParcelUuid(uuid), mBluetoothGattCallback, eattSupport);
         } catch (RemoteException e) {
             Log.e(TAG, """", e);
             return false;
@@ -859,9 +881,45 @@ public final class BluetoothGatt implements BluetoothProfile {
     @UnsupportedAppUsage
     /*package*/ boolean connect(Boolean autoConnect, BluetoothGattCallback callback,
             Handler handler) {
+        return connect(autoConnect, callback, handler, false);
+    }
+
+    /**
+     * Initiate a connection to a Bluetooth GATT capable device.
+     *
+     * <p>The connection may not be established right away, but will be
+     * completed when the remote device is available. A
+     * {@link BluetoothGattCallback#onConnectionStateChange} callback will be
+     * invoked when the connection state changes as a result of this function.
+     *
+     * <p>The autoConnect parameter determines whether to actively connect to
+     * the remote device, or rather passively scan and finalize the connection
+     * when the remote device is in range/available. Generally, the first ever
+     * connection to a device should be direct (autoConnect set to false) and
+     * subsequent connections to known devices should be invoked with the
+     * autoConnect parameter set to true.
+     *
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
+     *
+     * @param device Remote device to connect to
+     * @param autoConnect Whether to directly connect to the remote device (false) or to
+     * automatically connect as soon as the remote device becomes available (true).
+     * @param eattSupport specifies whether client app needs EATT channel for client operations.
+     * If both local and remote devices support EATT and local app asks for EATT, GATT client
+     * operations will be performed using EATT channel.
+     * If either local or remote device doesn't support EATT but local App asks for EATT, GATT
+     * client operations will be performed using unenhanced ATT channel.
+     * @return true, if the connection attempt was initiated successfully
+     *
+     * @hide
+     */
+    @UnsupportedAppUsage
+    /*package*/ boolean connect(Boolean autoConnect, BluetoothGattCallback callback,
+            Handler handler, boolean eattSupport) {
         if (DBG) {
             Log.d(TAG,
-                    ""connect() - device: "" + mDevice.getAddress() + "", auto: "" + autoConnect);
+                    ""connect() - device: "" + mDevice.getAddress() + "", auto: "" + autoConnect
+                    + "", eattSupport: "" + eattSupport);
         }
         synchronized (mStateLock) {
             if (mConnState != CONN_STATE_IDLE) {
@@ -872,7 +930,7 @@ public final class BluetoothGatt implements BluetoothProfile {
 
         mAutoConnect = autoConnect;
 
-        if (!registerApp(callback, handler)) {
+        if (!registerApp(callback, handler, eattSupport)) {
             synchronized (mStateLock) {
                 mConnState = CONN_STATE_IDLE;
             }
",61,3,"BluetoothGatt::registerApp, BluetoothGatt::connect, BluetoothGatt::registerApp, BluetoothGatt::connect"
73,4d3f23e48452eaae2f82c3e17a4c2cf8bb44c480,BluetoothGattServer.java,"@@ -443,6 +443,24 @@ public final class BluetoothGattServer implements BluetoothProfile {
      * error
      */
     /*package*/ boolean registerCallback(BluetoothGattServerCallback callback) {
+        return registerCallback(callback, false);
+    }
+
+    /**
+     * Register an application callback to start using GattServer.
+     *
+     * <p>This is an asynchronous call. The callback is used to notify
+     * success or failure if the function returns true.
+     *
+     * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
+     *
+     * @param callback GATT callback handler that will receive asynchronous callbacks.
+     * @param eattSupport whether eattSupport is needed for Gatt server
+     * @return true, the callback will be called to notify success or failure, false on immediate
+     * error
+     * @hide
+     */
+    /*package*/ boolean registerCallback(BluetoothGattServerCallback callback, boolean eattSupport) {
         if (DBG) Log.d(TAG, ""registerCallback()"");
         if (mService == null) {
             Log.e(TAG, ""GATT service not available"");
@@ -459,7 +477,7 @@ public final class BluetoothGattServer implements BluetoothProfile {
 
             mCallback = callback;
             try {
-                mService.registerServer(new ParcelUuid(uuid), mBluetoothGattServerCallback);
+                mService.registerServer(new ParcelUuid(uuid), mBluetoothGattServerCallback, eattSupport);
             } catch (RemoteException e) {
                 Log.e(TAG, """", e);
                 mCallback = null;
",19,1,"BluetoothGattServer::registerCallback, BluetoothGattServer::registerCallback"
74,4d3f23e48452eaae2f82c3e17a4c2cf8bb44c480,BluetoothManager.java,"@@ -233,6 +233,31 @@ public final class BluetoothManager {
      */
     public BluetoothGattServer openGattServer(Context context,
             BluetoothGattServerCallback callback, int transport) {
+        return (openGattServer(context, callback, transport, false));
+    }
+
+    /**
+     * Open a GATT Server
+     * The callback is used to deliver results to Caller, such as connection status as well
+     * as the results of any other GATT server operations.
+     * The method returns a BluetoothGattServer instance. You can use BluetoothGattServer
+     * to conduct GATT server operations.
+     *
+     * @param context App context
+     * @param callback GATT server callback handler that will receive asynchronous callbacks.
+     * @param transport preferred transport for GATT connections to remote dual-mode devices {@link
+     * BluetoothDevice#TRANSPORT_AUTO} or {@link BluetoothDevice#TRANSPORT_BREDR} or {@link
+     * BluetoothDevice#TRANSPORT_LE}
+     * @param eattSupport specifies whether server app needs EATT channel for server operations.
+     * If both local and remote devices support EATT, local app asks for EATT using this API and
+     * calls server connect, GATT server operations will be performed using EATT channel.
+     * If either local or remote device doesn't support EATT but local App asks for EATT, GATT
+     * server operations will be performed using unenhanced ATT channel.
+     * @return BluetoothGattServer instance
+     * @hide
+     */
+    public BluetoothGattServer openGattServer(Context context,
+            BluetoothGattServerCallback callback, int transport, boolean eattSupport) {
         if (context == null || callback == null) {
             throw new IllegalArgumentException(""null parameter: "" + context + "" "" + callback);
         }
@@ -248,7 +273,7 @@ public final class BluetoothManager {
                 return null;
             }
             BluetoothGattServer mGattServer = new BluetoothGattServer(iGatt, transport);
-            Boolean regStatus = mGattServer.registerCallback(callback);
+            Boolean regStatus = mGattServer.registerCallback(callback, eattSupport);
             return regStatus ? mGattServer : null;
         } catch (RemoteException e) {
             Log.e(TAG, """", e);
",26,1,"BluetoothManager::openGattServer, BluetoothManager::openGattServer"
75,69f29b96ef5108ea4a2421aba9fb7336fc0572bb,BluetoothAdapter.java,"@@ -66,6 +66,9 @@ import java.util.UUID;
 import java.util.concurrent.Executor;
 import java.util.concurrent.TimeoutException;
 import java.util.concurrent.locks.ReentrantReadWriteLock;
+import java.lang.reflect.Method;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
 
 /**
  * Represents the local device Bluetooth adapter. The {@link BluetoothAdapter}
@@ -2780,6 +2783,92 @@ public final class BluetoothAdapter {
         return null;
     }
 
+    private void closeBCProfile(BluetoothProfile proxy) {
+        Class<?> bshClass = null;
+        Method bshClose = null;
+        try {
+            bshClass = Class.forName(""android.bluetooth.BluetoothSyncHelper"");
+        } catch (ClassNotFoundException ex) {
+            Log.e(TAG, ""no BSH: exists"");
+            bshClass = null;
+        }
+        if (bshClass != null) {
+            Log.d(TAG, ""Able to get BSH class handle"");
+            try {
+                bshClose =  bshClass.getDeclaredMethod(""close"", null);
+            } catch (NoSuchMethodException e) {
+                Log.e(TAG, ""no BSH:isSupported method exists"");
+            }
+            if (bshClose != null) {
+                try {
+                   bshClose.invoke(proxy, null);
+                } catch(IllegalAccessException e) {
+                   Log.e(TAG, ""bshClose IllegalAccessException"");
+                } catch (InvocationTargetException e) {
+                   Log.e(TAG, ""bshClose InvocationTargetException"");
+                }
+            }
+        }
+        Log.d(TAG, ""CloseBCProfile returns"");
+    }
+
+    private boolean getBCProfile(Context context, BluetoothProfile.ServiceListener sl) {
+        boolean ret = true;
+        boolean isProfileSupported = false;
+        Class<?> bshClass = null;
+        Method bshSupported = null;
+        Constructor bshCons = null;
+        Object bshObj = null;
+        try {
+            bshClass = Class.forName(""android.bluetooth.BluetoothSyncHelper"");
+        } catch (ClassNotFoundException ex) {
+            Log.e(TAG, ""no BSH: exists"");
+            bshClass = null;
+        }
+        if (bshClass != null) {
+            Log.d(TAG, ""Able to get BSH class handle"");
+            try {
+                bshSupported =  bshClass.getDeclaredMethod(""isSupported"", null);
+            } catch (NoSuchMethodException e) {
+                Log.e(TAG, ""no BSH:isSupported method exists: gdm"");
+            }
+            try {
+                bshCons =
+                  bshClass.getDeclaredConstructor(
+                    new Class[]{Context.class,
+                        BluetoothProfile.ServiceListener.class});
+            } catch (NoSuchMethodException ex) {
+                Log.e(TAG, ""bshCons: NoSuchMethodException: gdm"" + ex);
+            }
+        }
+        if (bshClass != null && bshSupported != null && bshCons != null) {
+            try {
+                isProfileSupported = (boolean)bshSupported.invoke(null, null);
+            } catch(IllegalAccessException e) {
+                Log.e(TAG, ""BSH:isSupported IllegalAccessException"");
+            } catch (InvocationTargetException e) {
+                Log.e(TAG, ""BSH:isSupported InvocationTargetException"");
+            }
+            if (isProfileSupported) {
+                try {
+                    bshObj = bshCons.newInstance(
+                                       context, sl);
+                } catch (InstantiationException ex) {
+                    Log.e(TAG, ""bshCons InstantiationException:"" + ex);
+                } catch (IllegalAccessException ex) {
+                    Log.e(TAG, ""bshCons InstantiationException:"" + ex);
+                } catch (InvocationTargetException ex) {
+                    Log.e(TAG, ""bshCons InvocationTargetException:"" + ex);
+                }
+             }
+        }
+        if (bshObj == null) {
+            ret = false;
+        }
+        Log.d(TAG, ""getBCService returns"" + ret);
+        return ret;
+    }
+
     /**
      * Get the profile proxy object associated with the profile.
      *
@@ -2844,6 +2933,8 @@ public final class BluetoothAdapter {
         } else if (profile == BluetoothProfile.HID_DEVICE) {
             BluetoothHidDevice hidDevice = new BluetoothHidDevice(context, listener);
             return true;
+        } else if (profile == BluetoothProfile.BC_PROFILE) {
+            return getBCProfile(context, listener);
         } else if (profile == BluetoothProfile.HEARING_AID) {
             if (isHearingAidProfileSupported()) {
                 BluetoothHearingAid hearingAid = new BluetoothHearingAid(context, listener);
@@ -2931,6 +3022,9 @@ public final class BluetoothAdapter {
                 BluetoothHidDevice hidDevice = (BluetoothHidDevice) proxy;
                 hidDevice.close();
                 break;
+            case BluetoothProfile.BC_PROFILE:
+                closeBCProfile(proxy);
+                break;
             case BluetoothProfile.HEARING_AID:
                 BluetoothHearingAid hearingAid = (BluetoothHearingAid) proxy;
                 hearingAid.close();
",94,0,"BluetoothAdapter::getBCProfile, BluetoothAdapter::closeBCProfile, BluetoothAdapter::getProfileProxy, BluetoothAdapter::closeProfileProxy"
76,69f29b96ef5108ea4a2421aba9fb7336fc0572bb,BluetoothProfile.java,"@@ -205,13 +205,31 @@ public interface BluetoothProfile {
      */
     int HEARING_AID = 21;
 
+    /**
+     * BC_PROFILE
+     * @hide
+     */
+    public static final int BC_PROFILE = 24;
+
+    /**
+     * PC_PROFILE
+     * @hide
+     */
+    public static final int PC_PROFILE = 25;
+
+    /**
+     * CC_SERVER
+     * @hide
+     */
+    public static final int CC_SERVER = 26;
+
     /**
      * Max profile ID. This value should be updated whenever a new profile is added to match
      * the largest value assigned to a profile.
      *
      * @hide
      */
-    int MAX_PROFILE_ID = 21;
+    int MAX_PROFILE_ID = 26;
 
     /**
      * Default priority for devices that we try to auto-connect to and
",19,1,
77,69f29b96ef5108ea4a2421aba9fb7336fc0572bb,BluetoothEventManager.java,"@@ -42,6 +42,8 @@ import java.util.Map;
 import java.util.Objects;
 import java.util.Set;
 import java.util.concurrent.CopyOnWriteArrayList;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
 
 /**
  * BluetoothEventManager receives broadcasts and callbacks from the Bluetooth
@@ -61,6 +63,8 @@ public class BluetoothEventManager {
     private final android.os.Handler mReceiverHandler;
     private final UserHandle mUserHandle;
     private final Context mContext;
+    private final String ACT_BROADCAST_SOURCE_INFO =
+          ""android.bluetooth.BroadcastAudioSAManager.action.BROADCAST_SOURCE_INFO"";
 
     interface Handler {
         void onReceive(Context context, Intent intent, BluetoothDevice device);
@@ -128,6 +132,23 @@ public class BluetoothEventManager {
         addHandler(BluetoothDevice.ACTION_ACL_CONNECTED, new AclStateChangedHandler());
         addHandler(BluetoothDevice.ACTION_ACL_DISCONNECTED, new AclStateChangedHandler());
         addHandler(BluetoothA2dp.ACTION_CODEC_CONFIG_CHANGED, new A2dpCodecConfigChangedHandler());
+        Object sourceInfoHandler = null;
+        try {
+           Class<?> classSourceInfoHandler =
+               Class.forName(""com.android.settingslib.bluetooth.BroadcastSourceInfoHandler"");
+           Constructor ctor;
+           ctor = classSourceInfoHandler.getDeclaredConstructor(
+                      new Class[] {CachedBluetoothDeviceManager.class});
+           sourceInfoHandler = ctor.newInstance(mDeviceManager);
+        } catch (ClassNotFoundException | NoSuchMethodException | IllegalAccessException
+                  | InstantiationException | InvocationTargetException e) {
+              e.printStackTrace();
+        }
+        if (sourceInfoHandler != null) {
+           Log.d(TAG, ""adding SourceInfo Handler"");
+           addHandler(ACT_BROADCAST_SOURCE_INFO,
+                    (Handler)sourceInfoHandler);
+        }
 
         registerAdapterIntentReceiver();
     }
",21,0,BluetoothEventManager::BluetoothEventManager
78,69f29b96ef5108ea4a2421aba9fb7336fc0572bb,CachedBluetoothDevice.java,"@@ -43,6 +43,9 @@ import java.util.ArrayList;
 import java.util.Collection;
 import java.util.List;
 import java.util.concurrent.CopyOnWriteArrayList;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Method;
+import java.lang.reflect.InvocationTargetException;
 
 /**
  * CachedBluetoothDevice represents a remote Bluetooth device. It contains
@@ -138,6 +141,17 @@ public class CachedBluetoothDevice implements Comparable<CachedBluetoothDevice>
         mTwspBatteryLevel = -1;
     }
 
+    CachedBluetoothDevice(CachedBluetoothDevice cachedDevice) {
+        mContext = cachedDevice.mContext;
+        mLocalAdapter = BluetoothAdapter.getDefaultAdapter();
+        mProfileManager = cachedDevice.mProfileManager;
+        mDevice = cachedDevice.mDevice;
+        fillData();
+        mHiSyncId = BluetoothHearingAid.HI_SYNC_ID_INVALID;
+        mTwspBatteryState = -1;
+        mTwspBatteryLevel = -1;
+    }
+
     /* Gets Device for seondary TWS device
      * @param mDevice Primary TWS device  to get secondary
      * @return Description of the device
@@ -774,13 +788,49 @@ public class CachedBluetoothDevice implements Comparable<CachedBluetoothDevice>
         return new ArrayList<>(mProfiles);
     }
 
+    public boolean isBASeeker() {
+        if (mDevice == null) {
+            Log.e(TAG, ""isBASeeker: mDevice is null"");
+            return false;
+        }
+        boolean ret = false;
+        Class<?> bCProfileClass = null;
+        String BC_PROFILE_CLASS = ""com.android.settingslib.bluetooth.BCProfile"";
+        Method baSeeker;
+        try {
+            bCProfileClass = Class.forName(BC_PROFILE_CLASS);
+            baSeeker = bCProfileClass.getDeclaredMethod(""isBASeeker"", BluetoothDevice.class);
+            ret = (boolean)baSeeker.invoke(null, mDevice);
+        } catch (ClassNotFoundException | NoSuchMethodException
+                 | IllegalAccessException | InvocationTargetException e) {
+            e.printStackTrace();
+        }
+        return ret;
+    }
+
     public List<LocalBluetoothProfile> getConnectableProfiles() {
         List<LocalBluetoothProfile> connectableProfiles =
                 new ArrayList<LocalBluetoothProfile>();
+        Class<?> bCProfileClass = null;
+        String BC_PROFILE_CLASS = ""com.android.settingslib.bluetooth.BCProfile"";
+        try {
+            bCProfileClass = Class.forName(BC_PROFILE_CLASS);
+        } catch (ClassNotFoundException ex) {
+            Log.e(TAG, ""no BCProfileClass: exists"");
+            bCProfileClass = null;
+        }
         synchronized (mProfileLock) {
             for (LocalBluetoothProfile profile : mProfiles) {
-                if (profile.accessProfileEnabled()) {
-                    connectableProfiles.add(profile);
+                if (bCProfileClass != null && bCProfileClass.isInstance(profile)) {
+                    if (isBASeeker()) {
+                        connectableProfiles.add(profile);
+                    } else {
+                        Log.d(TAG, ""BC profile is not enabled for"" + mDevice);
+                    }
+                } else {
+                    if (profile.accessProfileEnabled()) {
+                       connectableProfiles.add(profile);
+                    }
                 }
             }
         }
",52,2,"CachedBluetoothDevice::CachedBluetoothDevice, CachedBluetoothDevice::isBASeeker, CachedBluetoothDevice::getConnectableProfiles"
79,69f29b96ef5108ea4a2421aba9fb7336fc0572bb,LocalBluetoothProfileManager.java,"@@ -49,6 +49,8 @@ import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.concurrent.CopyOnWriteArrayList;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
 
 
 /**
@@ -94,6 +96,7 @@ public class LocalBluetoothProfileManager {
     private MapProfile mMapProfile;
     private MapClientProfile mMapClientProfile;
     private HidProfile mHidProfile;
+    private LocalBluetoothProfile mBCProfile;
     private HidDeviceProfile mHidDeviceProfile;
     private OppProfile mOppProfile;
     private PanProfile mPanProfile;
@@ -102,6 +105,8 @@ public class LocalBluetoothProfileManager {
     private HearingAidProfile mHearingAidProfile;
     private SapProfile mSapProfile;
 
+    private static final String BC_CONNECTION_STATE_CHANGED =
+            ""android.bluetooth.bc.profile.action.CONNECTION_STATE_CHANGED"";
     /**
      * Mapping from profile name, e.g. ""HEADSET"" to profile object.
      */
@@ -213,6 +218,23 @@ public class LocalBluetoothProfileManager {
             addProfile(mPbapClientProfile, PbapClientProfile.NAME,
                     BluetoothPbapClient.ACTION_CONNECTION_STATE_CHANGED);
         }
+        if (mBCProfile == null && supportedList.contains(BluetoothProfile.BC_PROFILE)) {
+            if (DEBUG) Log.d(TAG, ""Adding local BC profile"");
+           try {
+              Class<?> classBCProfile =
+                  Class.forName(""com.android.settingslib.bluetooth.BCProfile"");
+              Constructor ctor;
+              ctor = classBCProfile.getDeclaredConstructor(new Class[] {Context.class,
+                                                          CachedBluetoothDeviceManager.class,
+                                                          LocalBluetoothProfileManager.class});
+              mBCProfile = (LocalBluetoothProfile)ctor.newInstance(mContext, mDeviceManager, this);
+              addProfile(mBCProfile, ""BCProfile"",
+                    BC_CONNECTION_STATE_CHANGED);
+            } catch (ClassNotFoundException | NoSuchMethodException | IllegalAccessException
+                  | InstantiationException | InvocationTargetException e) {
+              e.printStackTrace();
+            }
+        }
         if (mSapProfile == null && supportedList.contains(BluetoothProfile.SAP)) {
             if (DEBUG) {
                 Log.d(TAG, ""Adding local SAP profile"");
@@ -441,6 +463,10 @@ public class LocalBluetoothProfileManager {
         return mHearingAidProfile;
     }
 
+    public LocalBluetoothProfile getBCProfile() {
+        Log.d(TAG, ""getBCProfile returning: "" + mBCProfile);
+        return mBCProfile;
+    }
     @VisibleForTesting
     HidProfile getHidProfile() {
         return mHidProfile;
@@ -565,6 +591,11 @@ public class LocalBluetoothProfileManager {
             removedProfiles.remove(mSapProfile);
         }
 
+        if (mBCProfile != null) {
+            profiles.add(mBCProfile);
+            removedProfiles.remove(mBCProfile);
+            if(DEBUG) Log.d(TAG, ""BC profile removed"");
+        }
         if (DEBUG) {
             Log.d(TAG,""New Profiles"" + profiles.toString());
         }
",31,0,"LocalBluetoothProfileManager::getBCProfile, LocalBluetoothProfileManager::updateProfiles, LocalBluetoothProfileManager::updateLocalProfiles"
80,99e87bb3ef8772a5833fb5ffbe730f5e1c4fd2c2,BluetoothAdapter.java,"@@ -1870,6 +1870,22 @@ public final class BluetoothAdapter {
         return false;
     }
 
+    /** @hide */
+    @RequiresPermission(Manifest.permission.BLUETOOTH)
+    public boolean isBroadcastActive() {
+        try {
+            mServiceLock.readLock().lock();
+            if (mService != null) {
+                return mService.isBroadcastActive();
+            }
+        } catch (RemoteException e) {
+            Log.e(TAG, """", e);
+        } finally {
+            mServiceLock.readLock().unlock();
+        }
+        return false;
+    }
+
     /**
      * Connects all enabled and supported bluetooth profiles between the local and remote device.
      * Connection is asynchronous and you should listen to each profile's broadcast intent
@@ -2935,6 +2951,8 @@ public final class BluetoothAdapter {
             return true;
         } else if (profile == BluetoothProfile.BC_PROFILE) {
             return getBCProfile(context, listener);
+        } else if (profile == BluetoothProfile.BROADCAST) {
+            return getBroadcastProfile(context, listener);
         } else if (profile == BluetoothProfile.HEARING_AID) {
             if (isHearingAidProfileSupported()) {
                 BluetoothHearingAid hearingAid = new BluetoothHearingAid(context, listener);
@@ -3025,12 +3043,73 @@ public final class BluetoothAdapter {
             case BluetoothProfile.BC_PROFILE:
                 closeBCProfile(proxy);
                 break;
+            case BluetoothProfile.BROADCAST:
+                closeBroadcastProfile(proxy);
+                break;
             case BluetoothProfile.HEARING_AID:
                 BluetoothHearingAid hearingAid = (BluetoothHearingAid) proxy;
                 hearingAid.close();
         }
     }
 
+    private boolean getBroadcastProfile(Context context,
+                                      BluetoothProfile.ServiceListener listener) {
+        boolean ret = true;
+        Class<?> broadcastClass = null;
+        Constructor bcastConstructor = null;
+        Object broadcastObj = null;
+        try {
+            broadcastClass = Class.forName(""android.bluetooth.BluetoothBroadcast"");
+        } catch (ClassNotFoundException ex) {
+            Log.e(TAG, ""no BluetoothBroadcast: exists"");
+        }
+        if (broadcastClass != null) {
+            try {
+               bcastConstructor =
+                        broadcastClass.getDeclaredConstructor(new Class[]{Context.class,
+                                             BluetoothProfile.ServiceListener.class});
+            } catch (NoSuchMethodException ex) {
+               Log.e(TAG, ""bcastConstructor: NoSuchMethodException: gdm"" + ex);
+            }
+        }
+        if (bcastConstructor != null) {
+            try {
+                broadcastObj = bcastConstructor.newInstance(context, listener);
+            } catch (InstantiationException | IllegalAccessException |
+                InvocationTargetException ex) {
+                ex.printStackTrace();
+            }
+        }
+        if (broadcastObj == null) {
+            return false;
+        }
+        return true;
+    }
+
+    private void closeBroadcastProfile(BluetoothProfile proxy) {
+        Class<?> broadcastClass = null;
+        Method broadcastClose = null;
+        try {
+            broadcastClass = Class.forName(""android.bluetooth.BluetootBroadcast"");
+        } catch (ClassNotFoundException ex) {
+            Log.e(TAG, ""no BluetoothBroadcast: exists"");
+        }
+        if (broadcastClass != null) {
+            try {
+                broadcastClose =  broadcastClass.getDeclaredMethod(""close"", null);
+            } catch (NoSuchMethodException e) {
+                Log.e(TAG, ""no Broadcast:close method exists"");
+            }
+            if (broadcastClose != null) {
+                try {
+                    broadcastClose.invoke(proxy, null);
+                } catch(IllegalAccessException | InvocationTargetException ex) {
+                    ex.printStackTrace();
+                }
+            }
+        }
+    }
+
     private final IBluetoothManagerCallback mManagerCallback =
             new IBluetoothManagerCallback.Stub() {
                 public void onBluetoothServiceUp(IBluetooth bluetoothService) {
",79,0,"BluetoothAdapter::isBroadcastActive, BluetoothAdapter::closeProfileProxy, BluetoothAdapter::getBroadcastProfile, BluetoothAdapter::closeBroadcastProfile, BluetoothAdapter::getProfileProxy"
81,99e87bb3ef8772a5833fb5ffbe730f5e1c4fd2c2,BluetoothProfile.java,"@@ -223,13 +223,19 @@ public interface BluetoothProfile {
      */
     public static final int CC_SERVER = 26;
 
+    /**
+     * Broadcast
+     * @hide
+     */
+    public static final int BROADCAST = 27;
+
     /**
      * Max profile ID. This value should be updated whenever a new profile is added to match
      * the largest value assigned to a profile.
      *
      * @hide
      */
-    int MAX_PROFILE_ID = 26;
+    int MAX_PROFILE_ID = 27;
 
     /**
      * Default priority for devices that we try to auto-connect to and
@@ -428,6 +434,8 @@ public interface BluetoothProfile {
                 return ""OPP"";
             case HEARING_AID:
                 return ""HEARING_AID"";
+            case BROADCAST:
+                return ""BROADCAST"";
             default:
                 return ""UNKNOWN_PROFILE"";
         }
",9,1,getProfileName
82,99e87bb3ef8772a5833fb5ffbe730f5e1c4fd2c2,BluetoothAirplaneModeListener.java,"@@ -198,7 +198,8 @@ class BluetoothAirplaneModeListener {
 
         @VisibleForTesting
         public boolean isA2dpOrHearingAidConnected() {
-            return isA2dpConnected() || isHearingAidConnected();
+            return isA2dpConnected() || isHearingAidConnected() ||
+                   isBroadcastActive();
         }
 
         @VisibleForTesting
@@ -256,5 +257,11 @@ class BluetoothAirplaneModeListener {
             }
             return hearingAid.getConnectedDevices().size() > 0;
         }
+
+        private boolean isBroadcastActive() {
+           boolean ret = false;
+           ret = mAdapter.isBroadcastActive();
+           return ret;
+        }
     };
 }
",8,1,"BluetoothAirplaneModeListener::AirplaneModeHelper::isA2dpOrHearingAidConnected, BluetoothAirplaneModeListener::AirplaneModeHelper::isBroadcastActive"
83,c230fe4a4bcb56b7d909b800575ff1581bef7dd2,ScreenPinningRequest.java,"@@ -35,9 +35,11 @@ import android.text.SpannableStringBuilder;
 import android.text.style.BulletSpan;
 import android.util.DisplayMetrics;
 import android.view.Gravity;
+import android.view.IWindowManager;
 import android.view.View;
 import android.view.ViewGroup;
 import android.view.WindowManager;
+import android.view.WindowManagerGlobal;
 import android.view.accessibility.AccessibilityManager;
 import android.view.animation.DecelerateInterpolator;
 import android.widget.Button;
@@ -270,22 +272,26 @@ public class ScreenPinningRequest implements View.OnClickListener,
                     && navigationBarView.isRecentsButtonVisible();
             boolean touchExplorationEnabled = mAccessibilityService.isTouchExplorationEnabled();
             int descriptionStringResId;
-            if (QuickStepContract.isGesturalMode(mNavBarMode)) {
+            if (hasNavigationBar() && QuickStepContract.isGesturalMode(mNavBarMode)) {
                 descriptionStringResId = R.string.screen_pinning_description_gestural;
             } else if (recentsVisible) {
                 mLayout.findViewById(R.id.screen_pinning_recents_group).setVisibility(VISIBLE);
                 mLayout.findViewById(R.id.screen_pinning_home_bg_light).setVisibility(INVISIBLE);
                 mLayout.findViewById(R.id.screen_pinning_home_bg).setVisibility(INVISIBLE);
-                descriptionStringResId = touchExplorationEnabled
-                        ? R.string.screen_pinning_description_accessible
-                        : R.string.screen_pinning_description;
+                descriptionStringResId = !hasNavigationBar()
+                        ? R.string.screen_pinning_description_no_navbar
+                        : touchExplorationEnabled
+                                ? R.string.screen_pinning_description_accessible
+                                : R.string.screen_pinning_description;
             } else {
                 mLayout.findViewById(R.id.screen_pinning_recents_group).setVisibility(INVISIBLE);
                 mLayout.findViewById(R.id.screen_pinning_home_bg_light).setVisibility(VISIBLE);
                 mLayout.findViewById(R.id.screen_pinning_home_bg).setVisibility(VISIBLE);
-                descriptionStringResId = touchExplorationEnabled
-                        ? R.string.screen_pinning_description_recents_invisible_accessible
-                        : R.string.screen_pinning_description_recents_invisible;
+                descriptionStringResId = !hasNavigationBar()
+                        ? R.string.screen_pinning_description_no_navbar
+                        : touchExplorationEnabled
+                                ? R.string.screen_pinning_description_recents_invisible_accessible
+                                : R.string.screen_pinning_description_recents_invisible;
             }
 
             if (navigationBarView != null) {
@@ -335,6 +341,15 @@ public class ScreenPinningRequest implements View.OnClickListener,
             }
         }
 
+        private boolean hasNavigationBar() {
+            IWindowManager windowManagerService = WindowManagerGlobal.getWindowManagerService();
+            try {
+                return windowManagerService.hasNavigationBar(mContext.getDisplayId());
+            } catch (RemoteException e) {
+                return false;
+            }
+        }
+
         @Override
         public void onDetachedFromWindow() {
             mBroadcastDispatcher.unregisterReceiver(mReceiver);
",22,7,"ScreenPinningRequest::RequestWindowView::hasNavigationBar, ScreenPinningRequest::RequestWindowView::inflateView"
84,c230fe4a4bcb56b7d909b800575ff1581bef7dd2,ScreenPinningNotify.java,"@@ -17,8 +17,11 @@
 package com.android.systemui.statusbar.phone;
 
 import android.content.Context;
+import android.os.RemoteException;
 import android.os.SystemClock;
 import android.util.Slog;
+import android.view.IWindowManager;
+import android.view.WindowManagerGlobal;
 import android.widget.Toast;
 
 import com.android.systemui.R;
@@ -60,11 +63,13 @@ public class ScreenPinningNotify {
         if (mLastToast != null) {
             mLastToast.cancel();
         }
-        mLastToast = makeAllUserToastAndShow(isGestureNavEnabled
-                ? R.string.screen_pinning_toast_gesture_nav
-                : isRecentsButtonVisible
-                        ? R.string.screen_pinning_toast
-                        : R.string.screen_pinning_toast_recents_invisible);
+        mLastToast = makeAllUserToastAndShow(!hasNavigationBar()
+                ? R.string.screen_pinning_toast_no_navbar
+                : isGestureNavEnabled
+                        ? R.string.screen_pinning_toast_gesture_nav
+                        : isRecentsButtonVisible
+                                ? R.string.screen_pinning_toast
+                                : R.string.screen_pinning_toast_recents_invisible);
         mLastShowToastTime = showToastTime;
     }
 
@@ -73,4 +78,13 @@ public class ScreenPinningNotify {
         toast.show();
         return toast;
     }
+
+    private boolean hasNavigationBar() {
+        IWindowManager windowManagerService = WindowManagerGlobal.getWindowManagerService();
+        try {
+            return windowManagerService.hasNavigationBar(mContext.getDisplayId());
+        } catch (RemoteException e) {
+            return false;
+        }
+     }
 }
",19,5,"ScreenPinningNotify::hasNavigationBar, ScreenPinningNotify::showEscapeToast"
85,c230fe4a4bcb56b7d909b800575ff1581bef7dd2,PhoneWindowManager.java,"@@ -1467,7 +1467,9 @@ public class PhoneWindowManager implements WindowManagerPolicy {
 
         performHapticFeedback(HapticFeedbackConstants.LONG_PRESS, false,
                 ""Back - Long Press"");
-        performKeyAction(mBackLongPressAction, event);
+        if (!unpinActivity(false)) {
+            performKeyAction(mBackLongPressAction, event);
+        }
     }
 
     private void accessibilityShortcutActivated() {
@@ -1523,7 +1525,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
     }
 
     private boolean hasLongPressOnBackBehavior() {
-        return mBackLongPressAction != Action.NOTHING;
+        return mBackLongPressAction != Action.NOTHING || unpinActivity(true);
     }
 
     private void interceptScreenshotChord() {
@@ -3581,6 +3583,22 @@ public class PhoneWindowManager implements WindowManagerPolicy {
         return false;
     }
 
+    private boolean unpinActivity(boolean checkOnly) {
+        if (!hasNavigationBar()) {
+            try {
+                if (ActivityTaskManager.getService().isInLockTaskMode()) {
+                    if (!checkOnly) {
+                        ActivityTaskManager.getService().stopSystemLockTaskMode();
+                    }
+                    return true;
+                }
+            } catch (RemoteException e) {
+                // ignore
+            }
+        }
+        return false;
+    }
+
     // TODO(b/117479243): handle it in InputPolicy
     /** {@inheritDoc} */
     @Override
",20,2,"PhoneWindowManager::unpinActivity, PhoneWindowManager::backLongPress, PhoneWindowManager::hasLongPressOnBackBehavior"
86,0c29b0278b722cf531a55795de78dcad969c1b8a,KeyguardUpdateMonitor.java,"@@ -106,6 +106,8 @@ import com.android.systemui.util.RingerModeTracker;
 
 import com.google.android.collect.Lists;
 
+import lineageos.app.LineageContextConstants;
+
 import java.io.FileDescriptor;
 import java.io.PrintWriter;
 import java.lang.ref.WeakReference;
@@ -310,6 +312,7 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener, Dumpab
     };
 
     private final Handler mHandler;
+    private final boolean mHasFod;
 
     private final Observer<Integer> mRingerModeObserver = new Observer<Integer>() {
         @Override
@@ -1693,6 +1696,9 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener, Dumpab
             }
         };
 
+        mHasFod = mContext.getPackageManager().hasSystemFeature(
+                LineageContextConstants.Features.FOD);
+
         // Since device can't be un-provisioned, we only need to register a content observer
         // to update mDeviceProvisioned when we are...
         if (!mDeviceProvisioned) {
@@ -1856,7 +1862,8 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener, Dumpab
             return;
         }
         mHandler.removeCallbacks(mRetryFingerprintAuthentication);
-        boolean shouldListenForFingerprint = shouldListenForFingerprint();
+        boolean hideFodForStrongAuth = mHasFod && userNeedsStrongAuth();
+        boolean shouldListenForFingerprint = !hideFodForStrongAuth && shouldListenForFingerprint();
         boolean runningOrRestarting = mFingerprintRunningState == BIOMETRIC_STATE_RUNNING
                 || mFingerprintRunningState == BIOMETRIC_STATE_CANCELLING_RESTARTING;
         if (runningOrRestarting && !shouldListenForFingerprint) {
",8,1,"KeyguardUpdateMonitor::updateFingerprintListeningState, KeyguardUpdateMonitor::KeyguardUpdateMonitor"
87,75137cdbf4d1b39bbf42c4239a51988efc79df7a,UnusedStatusBar.java,"@@ -26,6 +26,7 @@ import com.android.keyguard.KeyguardUpdateMonitor;
 import com.android.keyguard.ViewMediatorCallback;
 import com.android.systemui.InitController;
 import com.android.systemui.assist.AssistManager;
+import com.android.systemui.biometrics.FODCircleViewImpl;
 import com.android.systemui.broadcast.BroadcastDispatcher;
 import com.android.systemui.bubbles.BubbleController;
 import com.android.systemui.colorextraction.SysuiColorExtractor;
@@ -184,7 +185,8 @@ public class UnusedStatusBar extends StatusBar {
             DismissCallbackRegistry dismissCallbackRegistry,
             Lazy<NotificationShadeDepthController> notificationShadeDepthControllerLazy,
             StatusBarTouchableRegionManager statusBarTouchableRegionManager,
-            TunerService tunerService) {
+            TunerService tunerService,
+            FODCircleViewImpl fodCircleViewImpl) {
         super(context, notificationsController, lightBarController, autoHideController,
                 keyguardUpdateMonitor, statusBarIconController, pulseExpansionHandler,
                 notificationWakeUpCoordinator, keyguardBypassController, keyguardStateController,
@@ -211,7 +213,8 @@ public class UnusedStatusBar extends StatusBar {
                 userInfoControllerImpl, phoneStatusBarPolicy, keyguardIndicationController,
                 dismissCallbackRegistry, notificationShadeDepthControllerLazy,
                 statusBarTouchableRegionManager,
-                tunerService);
+                tunerService,
+                fodCircleViewImpl);
     }
 
     @Override
",5,2,"UnusedStatusBar::UnusedStatusBar, UnusedStatusBar::UnusedStatusBar"
88,75137cdbf4d1b39bbf42c4239a51988efc79df7a,UnusedStatusBarModule.java,"@@ -30,6 +30,7 @@ import com.android.keyguard.KeyguardUpdateMonitor;
 import com.android.keyguard.ViewMediatorCallback;
 import com.android.systemui.InitController;
 import com.android.systemui.assist.AssistManager;
+import com.android.systemui.biometrics.FODCircleViewImpl;
 import com.android.systemui.broadcast.BroadcastDispatcher;
 import com.android.systemui.bubbles.BubbleController;
 import com.android.systemui.colorextraction.SysuiColorExtractor;
@@ -204,7 +205,8 @@ public interface UnusedStatusBarModule {
             Lazy<NotificationShadeDepthController> notificationShadeDepthController,
             DismissCallbackRegistry dismissCallbackRegistry,
             StatusBarTouchableRegionManager statusBarTouchableRegionManager,
-            TunerService tunerService) {
+            TunerService tunerService,
+            FODCircleViewImpl fodCircleViewImpl) {
         return new UnusedStatusBar(
                 context,
                 notificationsController,
@@ -283,6 +285,7 @@ public interface UnusedStatusBarModule {
                 dismissCallbackRegistry,
                 notificationShadeDepthController,
                 statusBarTouchableRegionManager,
-                tunerService);
+                tunerService,
+                fodCircleViewImpl);
     }
 }
",5,2,"provideStatusBar, provideStatusBar"
89,e6ffa411f095906d5fe9d99bf422d6a04afa17d5,AuthBiometricFingerprintView.java,"@@ -22,6 +22,7 @@ import android.graphics.drawable.AnimatedVectorDrawable;
 import android.graphics.drawable.Drawable;
 import android.util.AttributeSet;
 import android.util.Log;
+import android.view.View;
 
 import com.android.systemui.R;
 
@@ -76,6 +77,18 @@ public class AuthBiometricFingerprintView extends AuthBiometricView {
         showTouchSensorString();
     }
 
+    @Override
+    void onFinishInflateInternal() {
+        super.onFinishInflateInternal();
+        if (mHasFod) {
+            mIconView.setVisibility(View.INVISIBLE);
+            mIconView.setPadding(0, 0, 0, 0);
+            // Add IndicatorView above the biometric icon
+            removeView(mIndicatorView);
+            addView(mIndicatorView, indexOfChild(mIconView));
+        }
+    }
+
     private void showTouchSensorString() {
         mIndicatorView.setText(R.string.fingerprint_dialog_touch_sensor);
         mIndicatorView.setTextColor(mTextColorHint);
",13,0,AuthBiometricFingerprintView::onFinishInflateInternal
90,e6ffa411f095906d5fe9d99bf422d6a04afa17d5,AuthBiometricView.java,"@@ -24,6 +24,7 @@ import android.annotation.IntDef;
 import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.content.Context;
+import android.content.pm.PackageManager;
 import android.hardware.biometrics.BiometricPrompt;
 import android.os.Bundle;
 import android.os.Handler;
@@ -40,8 +41,12 @@ import android.widget.LinearLayout;
 import android.widget.TextView;
 
 import com.android.internal.annotations.VisibleForTesting;
+import com.android.systemui.statusbar.phone.StatusBar;
+import com.android.systemui.Dependency;
 import com.android.systemui.R;
 
+import lineageos.app.LineageContextConstants;
+
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.ArrayList;
@@ -186,6 +191,8 @@ public abstract class AuthBiometricView extends LinearLayout {
     protected boolean mDialogSizeAnimating;
     protected Bundle mSavedState;
 
+    protected boolean mHasFod;
+
     /**
      * Delay after authentication is confirmed, before the dialog should be animated away.
      */
@@ -248,6 +255,10 @@ public abstract class AuthBiometricView extends LinearLayout {
 
         mAccessibilityManager = context.getSystemService(AccessibilityManager.class);
 
+        PackageManager packageManager = context.getPackageManager();
+        mHasFod = packageManager.hasSystemFeature(PackageManager.FEATURE_FINGERPRINT) &&
+                packageManager.hasSystemFeature(LineageContextConstants.Features.FOD);
+
         mResetErrorRunnable = () -> {
             updateState(getStateForAfterError());
             handleResetAfterError();
@@ -703,9 +714,22 @@ public abstract class AuthBiometricView extends LinearLayout {
             final View child = getChildAt(i);
 
             if (child.getId() == R.id.biometric_icon) {
-                child.measure(
-                        MeasureSpec.makeMeasureSpec(newWidth, MeasureSpec.AT_MOST),
-                        MeasureSpec.makeMeasureSpec(height, MeasureSpec.AT_MOST));
+                if (this instanceof AuthBiometricFingerprintView && mHasFod) {
+                    final int buttonBarHeight =
+                            findViewById(R.id.button_bar).getLayoutParams().height;
+                    // The view is invisible, so it still takes space and
+                    // we use that to adjust for the FOD icon
+                    final int fodHeight = Dependency.get(StatusBar.class).getFodHeight(true) -
+                            buttonBarHeight - findViewById(R.id.button_bar).getPaddingTop();
+
+                    child.measure(
+                            MeasureSpec.makeMeasureSpec(newWidth, MeasureSpec.AT_MOST),
+                            MeasureSpec.makeMeasureSpec(fodHeight, MeasureSpec.EXACTLY));
+                } else {
+                    child.measure(
+                            MeasureSpec.makeMeasureSpec(newWidth, MeasureSpec.AT_MOST),
+                            MeasureSpec.makeMeasureSpec(height, MeasureSpec.AT_MOST));
+                }
             } else if (child.getId() == R.id.button_bar) {
                 child.measure(
                         MeasureSpec.makeMeasureSpec(newWidth, MeasureSpec.EXACTLY),
",27,3,"AuthBiometricView::AuthBiometricView, AuthBiometricView::onMeasure"
91,e6ffa411f095906d5fe9d99bf422d6a04afa17d5,FODCircleView.java,"@@ -30,6 +30,7 @@ import android.os.Handler;
 import android.os.Looper;
 import android.os.RemoteException;
 import android.provider.Settings;
+import android.util.DisplayMetrics;
 import android.view.Display;
 import android.view.Gravity;
 import android.view.MotionEvent;
@@ -423,6 +424,16 @@ public class FODCircleView extends ImageView {
         dispatchHide();
     }
 
+    public int getHeight(boolean includeDecor) {
+        DisplayMetrics dm = new DisplayMetrics();
+        if (includeDecor) {
+            mWindowManager.getDefaultDisplay().getMetrics(dm);
+        } else {
+            mWindowManager.getDefaultDisplay().getRealMetrics(dm);
+        }
+        return dm.heightPixels - mPositionY + mSize / 2;
+    }
+
     private void updateAlpha() {
         setAlpha(mIsDreaming ? 0.5f : 1.0f);
     }
",11,0,FODCircleView::getHeight
92,e6ffa411f095906d5fe9d99bf422d6a04afa17d5,FODCircleViewImpl.java,"@@ -100,6 +100,10 @@ public class FODCircleViewImpl extends SystemUI implements CommandQueue.Callback
         }
     }
 
+    public int getHeight(boolean includeDecor) {
+         return mFodCircleView.getHeight(includeDecor);
+    }
+
     public void registerCallback(FODCircleViewImplCallback callback) {
         Assert.isMainThread();
         Slog.v(TAG, ""*** register callback for "" + callback);
",4,0,FODCircleViewImpl::getHeight
93,e6ffa411f095906d5fe9d99bf422d6a04afa17d5,StatusBar.java,"@@ -4694,4 +4694,8 @@ public class StatusBar extends SystemUI implements DemoMode,
         }
         return null;
     }
+
+    public int getFodHeight(boolean includeDecor) {
+        return mFODCircleViewImpl.getHeight(includeDecor);
+    }
 }
",4,0,StatusBar::getFodHeight
94,3ad13ef1b01126a7e0ecfe16f5073b63ab8b8b6f,VolumeDialogImpl.java,"@@ -411,8 +411,7 @@ public class VolumeDialogImpl implements VolumeDialog,
                 if (mVolumePanelOnLeft != volumePanelOnLeft) {
                     mVolumePanelOnLeft = volumePanelOnLeft;
                     mHandler.post(() -> {
-                        // Trigger panel rebuild on next show
-                        mConfigChanged = true;
+                        mControllerCallbackH.onConfigurationChanged();
                     });
                 }
             }
",1,2,VolumeDialogImpl::Tunable
95,8cee4033510acf237ec15a80441c13b160c1713e,KeyEvent.java,"@@ -3167,4 +3167,22 @@ public class KeyEvent extends InputEvent implements Parcelable {
         out.writeLong(mEventTime);
         out.writeString(mCharacters);
     }
+
+    /* @hide */
+    public boolean equals(KeyEvent other) {
+        return other != null
+                && mId == other.mId
+                && mDeviceId == other.mDeviceId
+                && mSource == other.mSource
+                && mDisplayId == other.mDisplayId
+                && mAction == other.mAction
+                && mKeyCode == other.mKeyCode
+                && mRepeatCount == other.mRepeatCount
+                && mMetaState == other.mMetaState
+                && mScanCode == other.mScanCode
+                && mFlags == other.mFlags
+                && mDownTime == other.mDownTime
+                && mEventTime == other.mEventTime
+                && mCharacters == other.mCharacters;
+    }
 }
",18,0,KeyEvent::equals
96,8cee4033510acf237ec15a80441c13b160c1713e,MotionEvent.java,"@@ -1565,6 +1565,8 @@ public final class MotionEvent extends InputEvent implements Parcelable {
     private static native long nativeCopy(long destNativePtr, long sourceNativePtr,
             boolean keepHistory);
     @CriticalNative
+    private static native boolean nativeEquals(long nativePtrA, long nativePtrB);
+    @CriticalNative
     private static native int nativeGetId(long nativePtr);
     @CriticalNative
     private static native int nativeGetDeviceId(long nativePtr);
@@ -3788,6 +3790,14 @@ public final class MotionEvent extends InputEvent implements Parcelable {
         nativeWriteToParcel(mNativePtr, out);
     }
 
+    /* @hide */
+    public boolean equals(MotionEvent other) {
+        if (other == null) {
+            return false;
+        }
+        return nativeEquals(mNativePtr, other.mNativePtr);
+    }
+
     /**
      * Transfer object for pointer coordinates.
      *
",10,0,MotionEvent::equals
97,8cee4033510acf237ec15a80441c13b160c1713e,WindowManagerPolicyConstants.java,"@@ -34,6 +34,7 @@ public interface WindowManagerPolicyConstants {
     int FLAG_TRUSTED = 0x02000000;
     int FLAG_FILTERED = 0x04000000;
     int FLAG_DISABLE_KEY_REPEAT = 0x08000000;
+    int FLAG_INJECTED_IS_UNCHANGED = 0x10000000;
 
     int FLAG_INTERACTIVE = 0x20000000;
     int FLAG_PASS_TO_USER = 0x40000000;
",1,0,
98,8cee4033510acf237ec15a80441c13b160c1713e,InputManagerService.java,"@@ -77,6 +77,7 @@ import android.view.InputDevice;
 import android.view.InputEvent;
 import android.view.InputMonitor;
 import android.view.KeyEvent;
+import android.view.MotionEvent;
 import android.view.PointerIcon;
 import android.view.Surface;
 import android.view.VerifiedInputEvent;
@@ -1997,6 +1998,7 @@ public class InputManagerService extends IInputManager.Stub
     final boolean filterInputEvent(InputEvent event, int policyFlags) {
         synchronized (mInputFilterLock) {
             if (mInputFilter != null) {
+                mInputFilterHost.setPreFilterEventLocked(event);
                 try {
                     mInputFilter.filterInputEvent(event, policyFlags);
                 } catch (RemoteException e) {
@@ -2343,6 +2345,7 @@ public class InputManagerService extends IInputManager.Stub
      */
     private final class InputFilterHost extends IInputFilterHost.Stub {
         private boolean mDisconnected;
+        private InputEvent mPreFilterEvent;
 
         public void disconnectLocked() {
             mDisconnected = true;
@@ -2356,12 +2359,36 @@ public class InputManagerService extends IInputManager.Stub
 
             synchronized (mInputFilterLock) {
                 if (!mDisconnected) {
+                    if (isEventEqual(event, mPreFilterEvent)) {
+                        policyFlags |= WindowManagerPolicy.FLAG_INJECTED_IS_UNCHANGED;
+                        setPreFilterEventLocked(null);
+                    } else {
+                        policyFlags &= ~WindowManagerPolicy.FLAG_INJECTED_IS_UNCHANGED;
+                    }
+
                     nativeInjectInputEvent(mPtr, event, 0, 0,
                             InputManager.INJECT_INPUT_EVENT_MODE_ASYNC, 0,
                             policyFlags | WindowManagerPolicy.FLAG_FILTERED);
                 }
             }
         }
+
+        private void setPreFilterEventLocked(InputEvent event) {
+            if (mPreFilterEvent != null) {
+                mPreFilterEvent.recycle();
+            }
+            mPreFilterEvent = event != null ? event.copy() : null;
+        }
+    }
+
+    private boolean isEventEqual(InputEvent a, InputEvent b) {
+        if (a instanceof KeyEvent && b instanceof KeyEvent) {
+            return ((KeyEvent) a).equals((KeyEvent) b);
+        }
+        if (a instanceof MotionEvent && b instanceof MotionEvent) {
+            return ((MotionEvent) a).equals((MotionEvent) b);
+        }
+        return false;
     }
 
     /**
",27,0,"InputManagerService::InputFilterHost::sendInputEvent, InputManagerService::InputFilterHost::setPreFilterEventLocked, InputManagerService::filterInputEvent, InputManagerService::isEventEqual"
99,751fb2d24ef1504c0bdcfa7c14ac9112adac28dd,KeyEvent.java,"@@ -3168,7 +3168,7 @@ public class KeyEvent extends InputEvent implements Parcelable {
         out.writeString(mCharacters);
     }
 
-    /* @hide */
+    /** @hide */
     public boolean equals(KeyEvent other) {
         return other != null
                 && mId == other.mId
",1,1,
100,751fb2d24ef1504c0bdcfa7c14ac9112adac28dd,MotionEvent.java,"@@ -3790,7 +3790,7 @@ public final class MotionEvent extends InputEvent implements Parcelable {
         nativeWriteToParcel(mNativePtr, out);
     }
 
-    /* @hide */
+    /** @hide */
     public boolean equals(MotionEvent other) {
         if (other == null) {
             return false;
",1,1,
101,fa60142543972f8ec4cc251e5877acca786dafed,DatabaseHelper.java,"@@ -849,8 +849,8 @@ class DatabaseHelper extends SQLiteOpenHelper {
             try {
                 stmt = db.compileStatement(""INSERT INTO system(name,value)""
                         + "" VALUES(?,?);"");
-                loadBooleanSetting(stmt, Settings.System.USER_ROTATION,
-                        R.integer.def_user_rotation); // should be zero degrees
+                loadIntegerSetting(stmt, Settings.System.USER_ROTATION,
+                        R.integer.def_user_rotation);
                 db.setTransactionSuccessful();
             } finally {
                 db.endTransaction();
@@ -2269,6 +2269,8 @@ class DatabaseHelper extends SQLiteOpenHelper {
             loadBooleanSetting(stmt, Settings.System.ACCELEROMETER_ROTATION,
                     R.bool.def_accelerometer_rotation);
 
+            loadIntegerSetting(stmt, Settings.System.USER_ROTATION, R.integer.def_user_rotation);
+
             loadDefaultHapticSettings(stmt);
 
             loadBooleanSetting(stmt, Settings.System.NOTIFICATION_LIGHT_PULSE,
",4,2,"DatabaseHelper::onUpgrade, DatabaseHelper::loadSystemSettings"
102,dda6759718d03ae48b24cc55a85114bc1a862501,KeyEvent.java,"@@ -3167,22 +3167,4 @@ public class KeyEvent extends InputEvent implements Parcelable {
         out.writeLong(mEventTime);
         out.writeString(mCharacters);
     }
-
-    /** @hide */
-    public boolean equals(KeyEvent other) {
-        return other != null
-                && mId == other.mId
-                && mDeviceId == other.mDeviceId
-                && mSource == other.mSource
-                && mDisplayId == other.mDisplayId
-                && mAction == other.mAction
-                && mKeyCode == other.mKeyCode
-                && mRepeatCount == other.mRepeatCount
-                && mMetaState == other.mMetaState
-                && mScanCode == other.mScanCode
-                && mFlags == other.mFlags
-                && mDownTime == other.mDownTime
-                && mEventTime == other.mEventTime
-                && mCharacters == other.mCharacters;
-    }
 }
",0,18,KeyEvent::equals
103,dda6759718d03ae48b24cc55a85114bc1a862501,MotionEvent.java,"@@ -1565,8 +1565,6 @@ public final class MotionEvent extends InputEvent implements Parcelable {
     private static native long nativeCopy(long destNativePtr, long sourceNativePtr,
             boolean keepHistory);
     @CriticalNative
-    private static native boolean nativeEquals(long nativePtrA, long nativePtrB);
-    @CriticalNative
     private static native int nativeGetId(long nativePtr);
     @CriticalNative
     private static native int nativeGetDeviceId(long nativePtr);
@@ -3790,14 +3788,6 @@ public final class MotionEvent extends InputEvent implements Parcelable {
         nativeWriteToParcel(mNativePtr, out);
     }
 
-    /** @hide */
-    public boolean equals(MotionEvent other) {
-        if (other == null) {
-            return false;
-        }
-        return nativeEquals(mNativePtr, other.mNativePtr);
-    }
-
     /**
      * Transfer object for pointer coordinates.
      *
",0,10,MotionEvent::equals
104,dda6759718d03ae48b24cc55a85114bc1a862501,WindowManagerPolicyConstants.java,"@@ -34,7 +34,6 @@ public interface WindowManagerPolicyConstants {
     int FLAG_TRUSTED = 0x02000000;
     int FLAG_FILTERED = 0x04000000;
     int FLAG_DISABLE_KEY_REPEAT = 0x08000000;
-    int FLAG_INJECTED_IS_UNCHANGED = 0x10000000;
 
     int FLAG_INTERACTIVE = 0x20000000;
     int FLAG_PASS_TO_USER = 0x40000000;
",0,1,
105,dda6759718d03ae48b24cc55a85114bc1a862501,InputManagerService.java,"@@ -77,7 +77,6 @@ import android.view.InputDevice;
 import android.view.InputEvent;
 import android.view.InputMonitor;
 import android.view.KeyEvent;
-import android.view.MotionEvent;
 import android.view.PointerIcon;
 import android.view.Surface;
 import android.view.VerifiedInputEvent;
@@ -1998,7 +1997,6 @@ public class InputManagerService extends IInputManager.Stub
     final boolean filterInputEvent(InputEvent event, int policyFlags) {
         synchronized (mInputFilterLock) {
             if (mInputFilter != null) {
-                mInputFilterHost.setPreFilterEventLocked(event);
                 try {
                     mInputFilter.filterInputEvent(event, policyFlags);
                 } catch (RemoteException e) {
@@ -2345,7 +2343,6 @@ public class InputManagerService extends IInputManager.Stub
      */
     private final class InputFilterHost extends IInputFilterHost.Stub {
         private boolean mDisconnected;
-        private InputEvent mPreFilterEvent;
 
         public void disconnectLocked() {
             mDisconnected = true;
@@ -2359,36 +2356,12 @@ public class InputManagerService extends IInputManager.Stub
 
             synchronized (mInputFilterLock) {
                 if (!mDisconnected) {
-                    if (isEventEqual(event, mPreFilterEvent)) {
-                        policyFlags |= WindowManagerPolicy.FLAG_INJECTED_IS_UNCHANGED;
-                        setPreFilterEventLocked(null);
-                    } else {
-                        policyFlags &= ~WindowManagerPolicy.FLAG_INJECTED_IS_UNCHANGED;
-                    }
-
                     nativeInjectInputEvent(mPtr, event, 0, 0,
                             InputManager.INJECT_INPUT_EVENT_MODE_ASYNC, 0,
                             policyFlags | WindowManagerPolicy.FLAG_FILTERED);
                 }
             }
         }
-
-        private void setPreFilterEventLocked(InputEvent event) {
-            if (mPreFilterEvent != null) {
-                mPreFilterEvent.recycle();
-            }
-            mPreFilterEvent = event != null ? event.copy() : null;
-        }
-    }
-
-    private boolean isEventEqual(InputEvent a, InputEvent b) {
-        if (a instanceof KeyEvent && b instanceof KeyEvent) {
-            return ((KeyEvent) a).equals((KeyEvent) b);
-        }
-        if (a instanceof MotionEvent && b instanceof MotionEvent) {
-            return ((MotionEvent) a).equals((MotionEvent) b);
-        }
-        return false;
     }
 
     /**
",0,27,"InputManagerService::InputFilterHost::sendInputEvent, InputManagerService::InputFilterHost::setPreFilterEventLocked, InputManagerService::filterInputEvent, InputManagerService::isEventEqual"
106,00712220684bdb143e3a43fc1afe8dd722a1c054,AutomaticBrightnessController.java,"@@ -211,6 +211,8 @@ class AutomaticBrightnessController {
     private DisplayDeviceConfig mDisplayDeviceConfig;
     private final Injector mInjector;
 
+    private boolean mAutoBrightnessOneShot;
+
     AutomaticBrightnessController(Callbacks callbacks, Looper looper,
             SensorManager sensorManager, Sensor lightSensor, BrightnessMappingStrategy mapper,
             int lightSensorWarmUpTime, float brightnessMin, float brightnessMax,
@@ -273,6 +275,7 @@ class AutomaticBrightnessController {
         mPendingForegroundAppPackageName = null;
         mForegroundAppCategory = ApplicationInfo.CATEGORY_UNDEFINED;
         mPendingForegroundAppCategory = ApplicationInfo.CATEGORY_UNDEFINED;
+        mAutoBrightnessOneShot = false;
     }
 
     /**
@@ -312,7 +315,8 @@ class AutomaticBrightnessController {
 
     public void configure(boolean enable, @Nullable BrightnessConfiguration configuration,
             float brightness, boolean userChangedBrightness, float adjustment,
-            boolean userChangedAutoBrightnessAdjustment, int displayPolicy) {
+            boolean userChangedAutoBrightnessAdjustment, int displayPolicy,
+            boolean autoBrightnessOneShot) {
         // While dozing, the application processor may be suspended which will prevent us from
         // receiving new information from the light sensor. On some devices, we may be able to
         // switch to a wake-up light sensor instead but for now we will simply disable the sensor
@@ -321,6 +325,7 @@ class AutomaticBrightnessController {
         boolean dozing = (displayPolicy == DisplayPowerRequest.POLICY_DOZE);
         boolean changed = setBrightnessConfiguration(configuration);
         changed |= setDisplayPolicy(displayPolicy);
+
         if (userChangedAutoBrightnessAdjustment) {
             changed |= setAutoBrightnessAdjustment(adjustment);
         }
@@ -337,6 +342,8 @@ class AutomaticBrightnessController {
         changed |= setLightSensorEnabled(enable && !dozing);
         if (changed) {
             updateAutoBrightness(false /*sendUpdate*/, userInitiatedChange);
+        } else {
+            handleSettingsChange(autoBrightnessOneShot);
         }
     }
 
@@ -352,6 +359,16 @@ class AutomaticBrightnessController {
         return mBrightnessMapper.getDefaultConfig();
     }
 
+    private void handleSettingsChange(boolean autoBrightnessOneShot) {
+        if (mAutoBrightnessOneShot && !autoBrightnessOneShot) {
+            mSensorManager.registerListener(mLightSensorListener, mLightSensor,
+                        mCurrentLightSensorRate * 1000, mHandler);
+        } else if (!mAutoBrightnessOneShot && autoBrightnessOneShot) {
+            mSensorManager.unregisterListener(mLightSensorListener);
+        }
+        mAutoBrightnessOneShot = autoBrightnessOneShot;
+    }
+
     private boolean setDisplayPolicy(int policy) {
         if (mDisplayPolicy == policy) {
             return false;
@@ -760,6 +777,9 @@ class AutomaticBrightnessController {
                 mCallbacks.updateBrightness();
             }
         }
+        if (mAutoBrightnessOneShot) {
+            mSensorManager.unregisterListener(mLightSensorListener);
+        }
     }
 
     // Clamps values with float range [0.0-1.0]
",21,1,"AutomaticBrightnessController::configure, AutomaticBrightnessController::configure, AutomaticBrightnessController::AutomaticBrightnessController, AutomaticBrightnessController::handleSettingsChange, AutomaticBrightnessController::updateAutoBrightness"
107,00712220684bdb143e3a43fc1afe8dd722a1c054,DisplayPowerController.java,"@@ -65,6 +65,8 @@ import com.android.server.lights.LightsManager;
 import com.android.server.lights.LogicalLight;
 import com.android.server.policy.WindowManagerPolicy;
 
+import lineageos.providers.LineageSettings;
+
 import java.io.PrintWriter;
 import java.util.List;
 
@@ -396,6 +398,9 @@ final class DisplayPowerController implements AutomaticBrightnessController.Call
     // PowerManager.BRIGHTNESS_INVALID_FLOAT when there's no temporary adjustment set.
     private float mTemporaryAutoBrightnessAdjustment;
 
+    // Wether auto brightness is applied one shot when screen is turned on
+    private boolean mAutoBrightnessOneShot;
+
     // Animators.
     private ObjectAnimator mColorFadeOnAnimator;
     private ObjectAnimator mColorFadeOffAnimator;
@@ -424,6 +429,7 @@ final class DisplayPowerController implements AutomaticBrightnessController.Call
         mContext = context;
         mBrightnessSynchronizer = new BrightnessSynchronizer(context);
         mDisplayDevice = displayDevice;
+        mAutoBrightnessOneShot = getAutoBrightnessOneShotSetting();
 
         PowerManager pm =  context.getSystemService(PowerManager.class);
         DisplayDeviceConfig displayDeviceConfig = mDisplayDevice.getDisplayDeviceConfig();
@@ -731,6 +737,9 @@ final class DisplayPowerController implements AutomaticBrightnessController.Call
         mContext.getContentResolver().registerContentObserver(
                 Settings.System.getUriFor(Settings.System.SCREEN_AUTO_BRIGHTNESS_ADJ),
                 false /*notifyForDescendants*/, mSettingsObserver, UserHandle.USER_ALL);
+        mContext.getContentResolver().registerContentObserver(
+                LineageSettings.System.getUriFor(LineageSettings.System.AUTO_BRIGHTNESS_ONE_SHOT),
+                false /*notifyForDescendants*/, mSettingsObserver, UserHandle.USER_ALL);
     }
 
     private final Animator.AnimatorListener mAnimatorListener = new Animator.AnimatorListener() {
@@ -958,6 +967,7 @@ final class DisplayPowerController implements AutomaticBrightnessController.Call
             brightnessAdjustmentFlags = BrightnessReason.ADJUSTMENT_AUTO;
             mAppliedTemporaryAutoBrightnessAdjustment = false;
         }
+
         // Apply brightness boost.
         // We do this here after deciding whether auto-brightness is enabled so that we don't
         // disable the light sensor during this temporary state.  That way when boost ends we will
@@ -983,7 +993,8 @@ final class DisplayPowerController implements AutomaticBrightnessController.Call
                     mBrightnessConfiguration,
                     mLastUserSetScreenBrightness,
                     userSetBrightnessChanged, autoBrightnessAdjustment,
-                    autoBrightnessAdjustmentChanged, mPowerRequest.policy);
+                    autoBrightnessAdjustmentChanged, mPowerRequest.policy,
+                    mAutoBrightnessOneShot);
         }
 
         if (mBrightnessTracker != null) {
@@ -1695,9 +1706,16 @@ final class DisplayPowerController implements AutomaticBrightnessController.Call
         // We don't bother with a pending variable for VR screen brightness since we just
         // immediately adapt to it.
         mScreenBrightnessForVr = getScreenBrightnessForVrSetting();
+        mAutoBrightnessOneShot = getAutoBrightnessOneShotSetting();
         sendUpdatePowerState();
     }
 
+    private boolean getAutoBrightnessOneShotSetting() {
+        return LineageSettings.System.getIntForUser(
+                mContext.getContentResolver(), LineageSettings.System.AUTO_BRIGHTNESS_ONE_SHOT,
+                0, UserHandle.USER_CURRENT) == 1 ? true : false;
+    }
+
     private float getAutoBrightnessAdjustmentSetting() {
         final float adj = Settings.System.getFloatForUser(mContext.getContentResolver(),
                 Settings.System.SCREEN_AUTO_BRIGHTNESS_ADJ, 0.0f, UserHandle.USER_CURRENT);
",19,1,"DisplayPowerController::updatePowerState, DisplayPowerController::handleSettingsChange, DisplayPowerController::getAutoBrightnessOneShotSetting, DisplayPowerController::DisplayPowerController, DisplayPowerController::initialize"
108,a5459eb9718f55e1195bd360edb533267942db9c,QuickStatusBarHeader.java,"@@ -301,6 +301,7 @@ public class QuickStatusBarHeader extends RelativeLayout implements
         // QS will always show the estimate, and BatteryMeterView handles the case where
         // it's unavailable or charging
         mBatteryRemainingIcon.setPercentShowMode(BatteryMeterView.MODE_ESTIMATE);
+        mBatteryRemainingIcon.setOnClickListener(this);
         mRingerModeTextView.setSelected(true);
         mNextAlarmTextView.setSelected(true);
 
@@ -720,6 +721,9 @@ public class QuickStatusBarHeader extends RelativeLayout implements
         } else if (v == mRingerContainer && mRingerContainer.isVisibleToUser()) {
             mActivityStarter.postStartActivityDismissingKeyguard(new Intent(
                     Settings.ACTION_SOUND_SETTINGS), 0);
+        } else if (v == mBatteryRemainingIcon) {
+            mActivityStarter.postStartActivityDismissingKeyguard(new Intent(
+                    Intent.ACTION_POWER_USAGE_SUMMARY), 0);
         }
     }
 
",4,0,"QuickStatusBarHeader::onClick, QuickStatusBarHeader::onFinishInflate"
109,0f312543ee63b520763b73e8662c85a21b2e6785,AutomaticBrightnessController.java,"@@ -325,7 +325,6 @@ class AutomaticBrightnessController {
         boolean dozing = (displayPolicy == DisplayPowerRequest.POLICY_DOZE);
         boolean changed = setBrightnessConfiguration(configuration);
         changed |= setDisplayPolicy(displayPolicy);
-
         if (userChangedAutoBrightnessAdjustment) {
             changed |= setAutoBrightnessAdjustment(adjustment);
         }
@@ -362,7 +361,7 @@ class AutomaticBrightnessController {
     private void handleSettingsChange(boolean autoBrightnessOneShot) {
         if (mAutoBrightnessOneShot && !autoBrightnessOneShot) {
             mSensorManager.registerListener(mLightSensorListener, mLightSensor,
-                        mCurrentLightSensorRate * 1000, mHandler);
+                    mCurrentLightSensorRate * 1000, mHandler);
         } else if (!mAutoBrightnessOneShot && autoBrightnessOneShot) {
             mSensorManager.unregisterListener(mLightSensorListener);
         }
",1,2,"AutomaticBrightnessController::handleSettingsChange, AutomaticBrightnessController::configure"
110,0f312543ee63b520763b73e8662c85a21b2e6785,DisplayPowerController.java,"@@ -398,7 +398,7 @@ final class DisplayPowerController implements AutomaticBrightnessController.Call
     // PowerManager.BRIGHTNESS_INVALID_FLOAT when there's no temporary adjustment set.
     private float mTemporaryAutoBrightnessAdjustment;
 
-    // Wether auto brightness is applied one shot when screen is turned on
+    // Whether auto brightness is applied one shot when screen is turned on
     private boolean mAutoBrightnessOneShot;
 
     // Animators.
@@ -967,7 +967,6 @@ final class DisplayPowerController implements AutomaticBrightnessController.Call
             brightnessAdjustmentFlags = BrightnessReason.ADJUSTMENT_AUTO;
             mAppliedTemporaryAutoBrightnessAdjustment = false;
         }
-
         // Apply brightness boost.
         // We do this here after deciding whether auto-brightness is enabled so that we don't
         // disable the light sensor during this temporary state.  That way when boost ends we will
",1,2,DisplayPowerController::updatePowerState
111,422769ab9aaeea94693c2c8e394be47979bdaf18,PhoneStatusBarPolicy.java,"@@ -22,7 +22,6 @@ import android.app.AlarmManager;
 import android.app.AlarmManager.AlarmClockInfo;
 import android.app.IActivityManager;
 import android.app.SynchronousUserSwitchObserver;
-import android.bluetooth.BluetoothDevice;
 import android.content.BroadcastReceiver;
 import android.content.Context;
 import android.content.Intent;
@@ -43,7 +42,6 @@ import android.view.View;
 
 import androidx.lifecycle.Observer;
 
-import com.android.settingslib.bluetooth.CachedBluetoothDevice;
 import com.android.systemui.R;
 import com.android.systemui.broadcast.BroadcastDispatcher;
 import com.android.systemui.dagger.qualifiers.DisplayId;
@@ -231,7 +229,6 @@ public class PhoneStatusBarPolicy
 
         filter.addAction(AudioManager.ACTION_HEADSET_PLUG);
         filter.addAction(Intent.ACTION_SIM_STATE_CHANGED);
-        filter.addAction(BluetoothDevice.ACTION_BATTERY_LEVEL_CHANGED);
         filter.addAction(TelecomManager.ACTION_CURRENT_TTY_MODE_CHANGED);
         filter.addAction(Intent.ACTION_MANAGED_PROFILE_AVAILABLE);
         filter.addAction(Intent.ACTION_MANAGED_PROFILE_UNAVAILABLE);
@@ -443,9 +440,7 @@ public class PhoneStatusBarPolicy
             if (mBluetooth.isBluetoothConnected()
                     && (mBluetooth.isBluetoothAudioActive()
                     || !mBluetooth.isBluetoothAudioProfileOnly())) {
-                List<CachedBluetoothDevice> connectedDevices = mBluetooth.getConnectedDevices();
-                int batteryLevel = connectedDevices.isEmpty() ?
-                        -1 : connectedDevices.get(0).getBatteryLevel();
+                int batteryLevel = mBluetooth.getBatteryLevel();
                 if (batteryLevel == 100) {
                     iconId = R.drawable.stat_sys_data_bluetooth_connected_battery_9;
                 } else if (batteryLevel >= 90) {
@@ -742,9 +737,6 @@ public class PhoneStatusBarPolicy
                 case AudioManager.ACTION_HEADSET_PLUG:
                     updateHeadsetPlug(intent);
                     break;
-                case BluetoothDevice.ACTION_BATTERY_LEVEL_CHANGED:
-                    updateBluetooth();
-                    break;
             }
         }
     };
",1,9,"PhoneStatusBarPolicy::updateBluetooth, PhoneStatusBarPolicy::BroadcastReceiver, PhoneStatusBarPolicy::init"
112,422769ab9aaeea94693c2c8e394be47979bdaf18,BluetoothController.java,"@@ -44,6 +44,8 @@ public interface BluetoothController extends CallbackController<Callback>, Dumpa
     int getBondState(CachedBluetoothDevice device);
     List<CachedBluetoothDevice> getConnectedDevices();
 
+    int getBatteryLevel();
+
     public interface Callback {
         void onBluetoothStateChange(boolean enabled);
         void onBluetoothDevicesChanged();
",2,0,
113,422769ab9aaeea94693c2c8e394be47979bdaf18,BluetoothControllerImpl.java,"@@ -68,6 +68,7 @@ public class BluetoothControllerImpl implements BluetoothController, BluetoothCa
     private int mConnectionState = BluetoothAdapter.STATE_DISCONNECTED;
     private boolean mAudioProfileOnly;
     private boolean mIsActive;
+    private int mBatteryLevel;
 
     private final H mHandler;
     private int mState;
@@ -107,6 +108,7 @@ public class BluetoothControllerImpl implements BluetoothController, BluetoothCa
         pw.print(""  mEnabled=""); pw.println(mEnabled);
         pw.print(""  mConnectionState=""); pw.println(stateToString(mConnectionState));
         pw.print(""  mAudioProfileOnly=""); pw.println(mAudioProfileOnly);
+        pw.print(""  mBatteryLevel=""); pw.println(mBatteryLevel);
         pw.print(""  mIsActive=""); pw.println(mIsActive);
         pw.print(""  mConnectedDevices=""); pw.println(mConnectedDevices);
         pw.print(""  mCallbacks.size=""); pw.println(mHandler.mCallbacks.size());
@@ -255,6 +257,7 @@ public class BluetoothControllerImpl implements BluetoothController, BluetoothCa
             mHandler.sendEmptyMessage(H.MSG_STATE_CHANGED);
         }
         updateAudioProfile();
+        updateBattery();
     }
 
     private void updateActive() {
@@ -298,6 +301,22 @@ public class BluetoothControllerImpl implements BluetoothController, BluetoothCa
 
     }
 
+    @Override
+    public int getBatteryLevel() {
+        if (!mConnectedDevices.isEmpty()) {
+            return mConnectedDevices.get(0).getBatteryLevel();
+        }
+        return -1;
+    }
+
+    private void updateBattery() {
+        int batteryLevel = getBatteryLevel();
+        if (batteryLevel != mBatteryLevel) {
+            mBatteryLevel = batteryLevel;
+            mHandler.sendEmptyMessage(H.MSG_STATE_CHANGED);
+        }
+    }
+
     @Override
     public void onBluetoothStateChanged(int bluetoothState) {
         if (DEBUG) Log.d(TAG, ""BluetoothStateChanged="" + stateToString(bluetoothState));
",19,0,"BluetoothControllerImpl::dump, BluetoothControllerImpl::updateBattery, BluetoothControllerImpl::getBatteryLevel, BluetoothControllerImpl::updateConnected"
114,422769ab9aaeea94693c2c8e394be47979bdaf18,FakeBluetoothController.java,"@@ -110,4 +110,9 @@ public class FakeBluetoothController extends BaseLeakChecker<Callback> implement
     public List<CachedBluetoothDevice> getConnectedDevices() {
         return Collections.emptyList();
     }
+
+    @Override
+    public int getBatteryLevel() {
+        return 0;
+    }
 }
",5,0,FakeBluetoothController::getBatteryLevel
115,5d4222ae0575a5393077f45a6f898bc76124fbdf,TtsEngines.java,"@@ -498,7 +498,7 @@ public class TtsEngines {
      * specific preference in the list.
      */
     private static String parseEnginePrefFromList(String prefValue, String engineName) {
-        if (TextUtils.isEmpty(prefValue)) {
+        if (TextUtils.isEmpty(prefValue) || TextUtils.isEmpty(engineName)) {
             return null;
         }
 
",1,1,TtsEngines::parseEnginePrefFromList
116,6945498aec5d820db04bee203eb01425014d6d6a,PhoneWindowManager.java,"@@ -539,6 +539,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
 
     // Click volume down + power for partial screenshot
     boolean mClickPartialScreenshot;
+    boolean mClickPartialScreenshotAllowed = true;
 
     private boolean mPendingKeyguardOccluded;
     private boolean mKeyguardOccludedChanged;
@@ -1639,7 +1640,8 @@ public class PhoneWindowManager implements WindowManagerPolicy {
 
         @Override
         public void run() {
-            mDefaultDisplayPolicy.takeScreenshot(mScreenshotType, mScreenshotSource);
+            mDefaultDisplayPolicy.takeScreenshot(mScreenshotType, mScreenshotSource,
+                    uri -> { mClickPartialScreenshotAllowed = false; });
         }
     }
 
@@ -4322,10 +4324,13 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                         cancelPendingScreenshotChordAction();
                         cancelPendingAccessibilityShortcutAction();
 
-                        if (mClickPartialScreenshot && mScreenshotChordVolumeDownKeyConsumed) {
+                        if (mClickPartialScreenshot && mClickPartialScreenshotAllowed &&
+                                mScreenshotChordVolumeDownKeyConsumed) {
                             mScreenshotRunnable.setScreenshotType(TAKE_SCREENSHOT_SELECTED_REGION);
                             mHandler.post(mScreenshotRunnable);
                         }
+
+                        mClickPartialScreenshotAllowed = true;
                     }
                 } else if (keyCode == KeyEvent.KEYCODE_VOLUME_UP) {
                     if (down) {
",7,2,"PhoneWindowManager::interceptKeyBeforeQueueing, PhoneWindowManager::ScreenshotRunnable::run"
117,6945498aec5d820db04bee203eb01425014d6d6a,DisplayPolicy.java,"@@ -151,6 +151,7 @@ import android.graphics.Rect;
 import android.graphics.Region;
 import android.hardware.input.InputManager;
 import android.hardware.power.V1_0.PowerHint;
+import android.net.Uri;
 import android.os.Handler;
 import android.os.Looper;
 import android.os.Message;
@@ -4121,16 +4122,30 @@ public class DisplayPolicy {
      *                       {@link WindowManager#TAKE_SCREENSHOT_FULLSCREEN} or
      *                       {@link WindowManager#TAKE_SCREENSHOT_SELECTED_REGION}
      * @param source Where the screenshot originated from (see WindowManager.ScreenshotSource)
+     * @param completionConsumer Consumes `false` if a screenshot was not taken, and `true` if the
+     *                       screenshot was taken.
      */
-    public void takeScreenshot(int screenshotType, int source) {
+    public void takeScreenshot(int screenshotType, int source, Consumer<Uri> completionConsumer) {
         if (mScreenshotHelper != null) {
             mScreenshotHelper.takeScreenshot(screenshotType,
                     getStatusBar() != null && getStatusBar().isVisibleLw(),
                     getNavigationBar() != null && getNavigationBar().isVisibleLw(),
-                    source, mHandler, null /* completionConsumer */);
+                    source, mHandler, completionConsumer);
         }
     }
 
+    /**
+     * Request a screenshot be taken.
+     *
+     * @param screenshotType The type of screenshot, for example either
+     *                       {@link WindowManager#TAKE_SCREENSHOT_FULLSCREEN} or
+     *                       {@link WindowManager#TAKE_SCREENSHOT_SELECTED_REGION}
+     * @param source Where the screenshot originated from (see WindowManager.ScreenshotSource)
+     */
+    public void takeScreenshot(int screenshotType, int source) {
+        takeScreenshot(screenshotType, source, null /* completionConsumer */);
+    }
+
     RefreshRatePolicy getRefreshRatePolicy() {
         return mRefreshRatePolicy;
     }
",17,2,"DisplayPolicy::takeScreenshot, DisplayPolicy::takeScreenshot"
118,1bbd56683d797f8758cd109be45e058a712a5435,RootWindowContainer.java,"@@ -3391,7 +3391,7 @@ class RootWindowContainer extends WindowContainer<DisplayContent>
     }
 
     /**
-     * Find all visible task stacks containing {@param userId} and intercept them with an activity
+     * Find all task stacks containing {@param userId} and intercept them with an activity
      * to block out the contents and possibly start a credential-confirming intent.
      *
      * @param userId user handle for the locked managed profile.
@@ -3399,42 +3399,18 @@ class RootWindowContainer extends WindowContainer<DisplayContent>
     void lockAllProfileTasks(@UserIdInt int userId) {
         mService.deferWindowLayout();
         try {
-            final PooledConsumer c = PooledLambda.obtainConsumer(
-                    RootWindowContainer::taskTopActivityIsUser, this, PooledLambda.__(Task.class),
-                    userId);
-            forAllLeafTasks(c, true /* traverseTopToBottom */);
-            c.recycle();
+            forAllLeafTasks(task -> {
+                if (task.getActivity(activity -> !activity.finishing && activity.mUserId == userId)
+                        != null) {
+                    mService.getTaskChangeNotificationController().notifyTaskProfileLocked(
+                            task.mTaskId, userId);
+                }
+            }, true /* traverseTopToBottom */);
         } finally {
             mService.continueWindowLayout();
         }
     }
 
-    /**
-     * Detects whether we should show a lock screen in front of this task for a locked user.
-     * <p>
-     * We'll do this if either of the following holds:
-     * <ul>
-     *   <li>The top activity explicitly belongs to {@param userId}.</li>
-     *   <li>The top activity returns a result to an activity belonging to {@param userId}.</li>
-     * </ul>
-     *
-     * @return {@code true} if the top activity looks like it belongs to {@param userId}.
-     */
-    private void taskTopActivityIsUser(Task task, @UserIdInt int userId) {
-        // To handle the case that work app is in the task but just is not the top one.
-        final ActivityRecord activityRecord = task.getTopNonFinishingActivity();
-        final ActivityRecord resultTo = (activityRecord != null ? activityRecord.resultTo : null);
-
-        // Check the task for a top activity belonging to userId, or returning a
-        // result to an activity belonging to userId. Example case: a document
-        // picker for personal files, opened by a work app, should still get locked.
-        if ((activityRecord != null && activityRecord.mUserId == userId)
-                || (resultTo != null && resultTo.mUserId == userId)) {
-            mService.getTaskChangeNotificationController().notifyTaskProfileLocked(
-                    task.mTaskId, userId);
-        }
-    }
-
     void cancelInitializingActivities() {
         for (int displayNdx = getChildCount() - 1; displayNdx >= 0; --displayNdx) {
             final DisplayContent display = getChildAt(displayNdx);
",8,32,"RootWindowContainer::lockAllProfileTasks, RootWindowContainer::taskTopActivityIsUser"
119,1bbd56683d797f8758cd109be45e058a712a5435,RootWindowContainerTests.java,"@@ -25,6 +25,7 @@ import static android.view.WindowManager.LayoutParams.TYPE_NOTIFICATION_SHADE;
 import static android.view.WindowManager.LayoutParams.TYPE_STATUS_BAR;
 import static android.view.WindowManager.LayoutParams.TYPE_TOAST;
 
+import static com.android.dx.mockito.inline.extended.ExtendedMockito.spyOn;
 import static com.android.server.wm.ActivityStack.ActivityState.FINISHING;
 import static com.android.server.wm.ActivityStack.ActivityState.PAUSED;
 import static com.android.server.wm.ActivityStack.ActivityState.PAUSING;
@@ -36,10 +37,13 @@ import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
+import static org.mockito.ArgumentMatchers.eq;
+import static org.mockito.Mockito.verify;
 
 import android.app.WindowConfiguration;
 import android.content.ComponentName;
 import android.content.pm.ActivityInfo;
+import android.os.UserHandle;
 import android.platform.test.annotations.Presubmit;
 
 import androidx.test.filters.SmallTest;
@@ -169,5 +173,34 @@ public class RootWindowContainerTests extends WindowTestsBase {
         activity.setState(FINISHING, ""test FINISHING"");
         assertThat(mWm.mRoot.allPausedActivitiesComplete()).isTrue();
     }
+
+    @Test
+    public void testLockAllProfileTasks() {
+        // Make an activity visible with the user id set to 0
+        DisplayContent displayContent = mWm.mRoot.getDisplayContent(DEFAULT_DISPLAY);
+        TaskDisplayArea taskDisplayArea = displayContent.getTaskDisplayAreaAt(0);
+        final ActivityStack stack = createTaskStackOnDisplay(WINDOWING_MODE_FULLSCREEN,
+                ACTIVITY_TYPE_STANDARD, displayContent);
+        final ActivityRecord activity = new ActivityTestsBase.ActivityBuilder(stack.mAtmService)
+                .setStack(stack)
+                .setUid(0)
+                .setCreateTask(true)
+                .build();
+
+        // Create another activity on top and the user id is 1
+        Task task = activity.getTask();
+        final ActivityRecord topActivity = new ActivityTestsBase.ActivityBuilder(mWm.mAtmService)
+                .setStack(stack)
+                .setUid(UserHandle.PER_USER_RANGE + 1)
+                .setTask(task)
+                .build();
+
+        // Make sure the listeners will be notified for putting the task to locked state
+        TaskChangeNotificationController controller =
+                mWm.mAtmService.getTaskChangeNotificationController();
+        spyOn(controller);
+        mWm.mRoot.lockAllProfileTasks(0);
+        verify(controller).notifyTaskProfileLocked(eq(task.mTaskId), eq(0));
+    }
 }
 
",33,0,RootWindowContainerTests::testLockAllProfileTasks
120,b8404be70d59c2ba60436cbc36d76780eb38deaa,GlobalScreenshot.java,"@@ -404,7 +404,9 @@ public class GlobalScreenshot implements ViewTreeObserver.OnComputeInternalInset
 
     void hideScreenshotSelector() {
         setLockedScreenOrientation(false);
-        mWindowManager.removeView(mScreenshotLayout);
+        if (mScreenshotLayout.getWindowToken() != null) {
+            mWindowManager.removeView(mScreenshotLayout);
+        }
         mScreenshotSelectorView.stopSelection();
         mScreenshotSelectorView.setVisibility(View.GONE);
         mCaptureButton.setVisibility(View.GONE);
@@ -1174,6 +1176,7 @@ public class GlobalScreenshot implements ViewTreeObserver.OnComputeInternalInset
         mActionsContainer.setTranslationY(0);
         mActionsContainerBackground.setTranslationY(0);
         mScreenshotPreview.setTranslationY(0);
+        hideScreenshotSelector();
     }
 
     private void setAnimatedViewSize(int width, int height) {
",4,1,"GlobalScreenshot::hideScreenshotSelector, GlobalScreenshot::clearScreenshot"
121,3b46ef1258c25467a7db4675387577fe27b5d50c,Settings.java,"@@ -5447,7 +5447,7 @@ public final class Settings {
         }
 
         private String getExtendedFingerprint(long version) {
-            return Build.FINGERPRINT + ""?pc_version="" + version;
+            return Build.DATE + ""?pc_version="" + version;
         }
 
         public void writePermissionsForUserSyncLPr(int userId) {
",1,1,Settings::RuntimePermissionPersistence::getExtendedFingerprint
122,118931188c9c131bea15241109c4e7025c60b41f,LockPatternView.java,"@@ -1587,7 +1587,9 @@ public class LockPatternView extends View {
             if (virtualViewId != ExploreByTouchHelper.INVALID_ID) {
                 int row = (virtualViewId - VIRTUAL_BASE_VIEW_ID) / 3;
                 int col = (virtualViewId - VIRTUAL_BASE_VIEW_ID) % 3;
-                return !mPatternDrawLookup[row][col];
+                if (row < 3) {
+                    return !mPatternDrawLookup[row][col];
+                }
             }
             return false;
         }
@@ -1633,7 +1635,6 @@ public class LockPatternView extends View {
             final Rect bounds = mTempRect;
             final int row = ordinal / 3;
             final int col = ordinal % 3;
-            final CellState cell = mCellStates[row][col];
             float centerX = getCenterXForColumn(col);
             float centerY = getCenterYForRow(row);
             float cellheight = mSquareHeight * mHitFactor * 0.5f;
",3,2,"LockPatternView::PatternExploreByTouchHelper::getBoundsForVirtualView, LockPatternView::PatternExploreByTouchHelper::isClickable"
123,6cdc54bee9d86d3b2de929a99e13da42d088a3fb,VolumeDialogImpl.java,"@@ -244,7 +244,11 @@ public class VolumeDialogImpl implements VolumeDialog,
     private void initDialog() {
 
         // Gravitate various views left/right depending on panel placement setting.
-        final int panelGravity = mVolumePanelOnLeft ? Gravity.LEFT : Gravity.RIGHT;
+        int panelGravity =
+                mContext.getResources().getInteger(R.integer.volume_dialog_gravity);
+        if (!mShowActiveStreamOnly) {
+            panelGravity = mVolumePanelOnLeft ? Gravity.LEFT : Gravity.RIGHT;
+        }
 
         mConfigurableTexts = new ConfigurableTexts(mContext);
         mHovering = false;
@@ -291,7 +295,8 @@ public class VolumeDialogImpl implements VolumeDialog,
 
         FrameLayout.LayoutParams dialogViewLP =
                 (FrameLayout.LayoutParams) mDialogView.getLayoutParams();
-        dialogViewLP.gravity = Gravity.CENTER_VERTICAL;
+        dialogViewLP.gravity = mShowActiveStreamOnly ? panelGravity
+                : Gravity.CENTER_VERTICAL;
         mDialogView.setLayoutParams(dialogViewLP);
 
         mDialogMainView = mDialog.findViewById(R.id.main);
",7,2,VolumeDialogImpl::initDialog
124,cf0606c2f73d42e8fd9081f7b635e10b575a0b0c,AbstractBatteryStatusPreferenceController.java,"@@ -0,0 +1,157 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.settingslib.deviceinfo;
+
+import androidx.annotation.VisibleForTesting;
+import androidx.preference.Preference;
+import androidx.preference.PreferenceScreen;
+
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.os.BatteryManager;
+import android.os.Handler;
+import android.os.Message;
+import android.os.SystemClock;
+import android.text.format.DateUtils;
+
+import com.android.settingslib.core.AbstractPreferenceController;
+import com.android.settingslib.core.lifecycle.Lifecycle;
+import com.android.settingslib.core.lifecycle.LifecycleObserver;
+import com.android.settingslib.core.lifecycle.events.OnStart;
+import com.android.settingslib.core.lifecycle.events.OnStop;
+import com.android.settingslib.R;
+
+import java.lang.ref.WeakReference;
+
+/**
+ * Preference controller for battery status
+ */
+public abstract class AbstractBatteryStatusPreferenceController extends AbstractPreferenceController
+        implements LifecycleObserver, OnStart, OnStop {
+
+    @VisibleForTesting
+    static final String KEY_BATTERY_STATUS = ""battery_status"";
+    private static final int EVENT_UPDATE_BATTERY = 700;
+
+    private Preference mBatteryStatus;
+    private Handler mHandler;
+    private Context mContext;
+
+    public AbstractBatteryStatusPreferenceController(Context context, Lifecycle lifecycle) {
+        super(context);
+	mContext = context;
+        if (lifecycle != null) {
+            lifecycle.addObserver(this);
+        }
+    }
+
+    @Override
+    public void onStart() {
+        getHandler().sendEmptyMessage(EVENT_UPDATE_BATTERY);
+    }
+
+    @Override
+    public void onStop() {
+        getHandler().removeMessages(EVENT_UPDATE_BATTERY);
+    }
+
+    @Override
+    public boolean isAvailable() {
+        Intent intent = mContext.registerReceiver(null,
+                new IntentFilter(Intent.ACTION_BATTERY_CHANGED));
+
+        return intent.getBooleanExtra(BatteryManager.EXTRA_PRESENT, false);
+    }
+
+    @Override
+    public String getPreferenceKey() {
+        return KEY_BATTERY_STATUS;
+    }
+
+    @Override
+    public void displayPreference(PreferenceScreen screen) {
+        super.displayPreference(screen);
+        mBatteryStatus = screen.findPreference(KEY_BATTERY_STATUS);
+        updateBattery();
+    }
+
+    private Handler getHandler() {
+        if (mHandler == null) {
+            mHandler = new MyHandler(this);
+        }
+        return mHandler;
+    }
+
+    private void updateBattery() {
+        Intent intent = mContext.registerReceiver(null,
+                new IntentFilter(Intent.ACTION_BATTERY_CHANGED));
+
+        if (mBatteryStatus != null) {
+            String batterystatus = mContext.getString(R.string.battery_info_status_unknown);
+	    String batterylevel = Integer.toString(Math.round(100.f
+                    * intent.getIntExtra(BatteryManager.EXTRA_LEVEL, 100)
+                    / intent.getIntExtra(BatteryManager.EXTRA_SCALE, 100))) + ""%"";
+
+            switch (intent.getIntExtra(BatteryManager.EXTRA_STATUS, -1)) {
+                case BatteryManager.BATTERY_STATUS_CHARGING:
+                    batterystatus = mContext.getString(R.string.battery_info_status_charging);
+                    break;
+                case BatteryManager.BATTERY_STATUS_DISCHARGING:
+                    batterystatus = mContext.getString(R.string.battery_info_status_discharging);
+                    break;
+                case BatteryManager.BATTERY_STATUS_FULL:
+                    batterystatus = mContext.getString(R.string.battery_info_status_full);
+                    break;
+                case BatteryManager.BATTERY_STATUS_NOT_CHARGING:
+                    batterystatus = mContext.getString(R.string.battery_info_status_not_charging);
+                    break;
+                case BatteryManager.BATTERY_STATUS_UNKNOWN:
+                default:
+                    break;
+            }
+
+            mBatteryStatus.setSummary(batterylevel + "" - "" + batterystatus);
+        }
+    }
+
+    private static class MyHandler extends Handler {
+        private WeakReference<AbstractBatteryStatusPreferenceController> mStatus;
+
+        public MyHandler(AbstractBatteryStatusPreferenceController activity) {
+            mStatus = new WeakReference<>(activity);
+        }
+
+        @Override
+        public void handleMessage(Message msg) {
+            AbstractBatteryStatusPreferenceController status = mStatus.get();
+            if (status == null) {
+                return;
+            }
+
+            switch (msg.what) {
+                case EVENT_UPDATE_BATTERY:
+                    status.updateBattery();
+                    sendEmptyMessageDelayed(EVENT_UPDATE_BATTERY, 1000);
+                    break;
+
+                default:
+                    throw new IllegalStateException(""Unknown message "" + msg.what);
+            }
+        }
+    }
+}
",157,0,"AbstractBatteryStatusPreferenceController::MyHandler::MyHandler, AbstractBatteryStatusPreferenceController::updateBattery, AbstractBatteryStatusPreferenceController::onStart, AbstractBatteryStatusPreferenceController::onStop, AbstractBatteryStatusPreferenceController::getPreferenceKey, AbstractBatteryStatusPreferenceController::displayPreference, AbstractBatteryStatusPreferenceController::getHandler, AbstractBatteryStatusPreferenceController::AbstractBatteryStatusPreferenceController, AbstractBatteryStatusPreferenceController::isAvailable, AbstractBatteryStatusPreferenceController::MyHandler::handleMessage"
125,2e9288e003a7c0a4403a43fe70e7160497fe66da,QSPanel.java,"@@ -663,7 +663,9 @@ public class QSPanel extends LinearLayout implements Tunable, Callback, Brightne
     private boolean shouldUseHorizontalLayout() {
         return mUsingMediaPlayer && mMediaHost.getVisible()
                 && getResources().getConfiguration().orientation
-                == Configuration.ORIENTATION_LANDSCAPE;
+                == Configuration.ORIENTATION_LANDSCAPE
+                && getResources().getConfiguration().screenWidthDp
+                < 600;
     }
 
     protected void reAttachMediaHost() {
",3,1,QSPanel::shouldUseHorizontalLayout
126,161e8a70fa041d3cdce7dbe52eccae9f186771b2,CameraMetadataNative.java,"@@ -1758,6 +1758,18 @@ public class CameraMetadataNative implements Parcelable {
     private static native int nativeGetTypeFromTag(int tag, long vendorId)
             throws IllegalArgumentException;
 
+    private synchronized byte[] nativeReadValues(int tag) {
+        return nativeReadValues(tag, mMetadataPtr);
+    }
+
+    private synchronized int nativeGetTypeFromTagLocal(int tag) {
+        return nativeGetTypeFromTagLocal(mMetadataPtr, tag);
+    }
+
+    private synchronized int nativeGetTagFromKeyLocal(String keyname) {
+        return nativeGetTagFromKeyLocal(mMetadataPtr, keyname);
+    }
+
     /**
      * <p>Perform a 0-copy swap of the internal metadata with another object.</p>
      *
",12,0,"CameraMetadataNative::nativeGetTypeFromTagLocal, CameraMetadataNative::nativeReadValues, CameraMetadataNative::nativeGetTagFromKeyLocal"
127,b64352d7c66e93ddc2b448f556e265178309d730,ActiveServices.java,"@@ -734,11 +734,8 @@ public final class ActiveServices {
         }
         ComponentName cmp = startServiceInnerLocked(smap, service, r, callerFg, addToStarting);
 
-        if (!r.mAllowWhileInUsePermissionInFgs) {
-            r.mAllowWhileInUsePermissionInFgs =
-                    shouldAllowWhileInUsePermissionInFgsLocked(callingPackage, callingPid,
-                            callingUid, service, r, allowBackgroundActivityStarts);
-        }
+        setFgsRestrictionLocked(callingPackage, callingPid, callingUid, r,
+                allowBackgroundActivityStarts);
 
         return cmp;
     }
@@ -1411,14 +1408,6 @@ public final class ActiveServices {
                         +  String.format(""0x%08X"", manifestType)
                         + "" in service element of manifest file"");
                 }
-                // If the foreground service is not started from TOP process, do not allow it to
-                // have while-in-use location/camera/microphone access.
-                if (!r.mAllowWhileInUsePermissionInFgs) {
-                    Slog.w(TAG,
-                            ""Foreground service started from background can not have ""
-                                    + ""location/camera/microphone access: service ""
-                                    + r.shortInstanceName);
-                }
             }
             boolean alreadyStartedOp = false;
             boolean stopProcStatsOp = false;
@@ -1466,6 +1455,57 @@ public final class ActiveServices {
                     ignoreForeground = true;
                 }
 
+                if (!ignoreForeground) {
+                    if (r.mStartForegroundCount == 0) {
+                        /*
+                        If the service was started with startService(), not
+                        startForegroundService(), and if startForeground() isn't called within
+                        mFgsStartForegroundTimeoutMs, then we check the state of the app
+                        (who owns the service, which is the app that called startForeground())
+                        again. If the app is in the foreground, or in any other cases where
+                        FGS-starts are allowed, then we still allow the FGS to be started.
+                        Otherwise, startForeground() would fail.
+
+                        If the service was started with startForegroundService(), then the service
+                        must call startForeground() within a timeout anyway, so we don't need this
+                        check.
+                        */
+                        if (!r.fgRequired) {
+                            final long delayMs = SystemClock.elapsedRealtime() - r.createRealTime;
+                            if (delayMs > mAm.mConstants.mFgsStartForegroundTimeoutMs) {
+                                resetFgsRestrictionLocked(r);
+                                setFgsRestrictionLocked(r.serviceInfo.packageName, r.app.pid,
+                                        r.appInfo.uid, r, false);
+                                EventLog.writeEvent(0x534e4554, ""183147114"",
+                                        r.appInfo.uid,
+                                        ""call setFgsRestrictionLocked again due to ""
+                                                + ""startForegroundTimeout"");
+                            }
+                        }
+                    } else if (r.mStartForegroundCount >= 1) {
+                        // The second or later time startForeground() is called after service is
+                        // started. Check for app state again.
+                        final long delayMs = SystemClock.elapsedRealtime() -
+                                r.mLastSetFgsRestrictionTime;
+                        if (delayMs > mAm.mConstants.mFgsStartForegroundTimeoutMs) {
+                            resetFgsRestrictionLocked(r);
+                            setFgsRestrictionLocked(r.serviceInfo.packageName, r.app.pid,
+                                    r.appInfo.uid, r, false);
+                            EventLog.writeEvent(0x534e4554, ""183147114"", r.appInfo.uid,
+                                    ""call setFgsRestrictionLocked for ""
+                                            + (r.mStartForegroundCount + 1) + ""th startForeground"");
+                        }
+                    }
+                    // If the foreground service is not started from TOP process, do not allow it to
+                    // have while-in-use location/camera/microphone access.
+                    if (!r.mAllowWhileInUsePermissionInFgs) {
+                        Slog.w(TAG,
+                                ""Foreground service started from background can not have ""
+                                        + ""location/camera/microphone access: service ""
+                                        + r.shortInstanceName);
+                    }
+                }
+
                 // Apps under strict background restrictions simply don't get to have foreground
                 // services, so now that we've enforced the startForegroundService() contract
                 // we only do the machinery of making the service foreground when the app
@@ -1501,6 +1541,7 @@ public final class ActiveServices {
                             active.mNumActive++;
                         }
                         r.isForeground = true;
+                        r.mStartForegroundCount++;
                         if (!stopProcStatsOp) {
                             ServiceState stracker = r.getTracker();
                             if (stracker != null) {
@@ -1559,6 +1600,7 @@ public final class ActiveServices {
                     decActiveForegroundAppLocked(smap, r);
                 }
                 r.isForeground = false;
+                resetFgsRestrictionLocked(r);
                 ServiceState stracker = r.getTracker();
                 if (stracker != null) {
                     stracker.setForeground(false, mAm.mProcessStats.getMemFactorLocked(),
@@ -2118,12 +2160,7 @@ public final class ActiveServices {
                 }
             }
 
-            if (!s.mAllowWhileInUsePermissionInFgs) {
-                s.mAllowWhileInUsePermissionInFgs =
-                        shouldAllowWhileInUsePermissionInFgsLocked(callingPackage,
-                                callingPid, callingUid,
-                                service, s, false);
-            }
+            setFgsRestrictionLocked(callingPackage, callingPid, callingUid, s, false);
 
             if (s.app != null) {
                 if ((flags&Context.BIND_TREAT_LIKE_ACTIVITY) != 0) {
@@ -3419,7 +3456,7 @@ public final class ActiveServices {
         r.isForeground = false;
         r.foregroundId = 0;
         r.foregroundNoti = null;
-        r.mAllowWhileInUsePermissionInFgs = false;
+        resetFgsRestrictionLocked(r);
 
         // Clear start entries.
         r.clearDeliveredStartsLocked();
@@ -4900,7 +4937,7 @@ public final class ActiveServices {
      * @return true if allow, false otherwise.
      */
     private boolean shouldAllowWhileInUsePermissionInFgsLocked(String callingPackage,
-            int callingPid, int callingUid, Intent intent, ServiceRecord r,
+            int callingPid, int callingUid, ServiceRecord r,
             boolean allowBackgroundActivityStarts) {
         // Is the background FGS start restriction turned on?
         if (!mAm.mConstants.mFlagBackgroundFgsStartRestrictionEnabled) {
@@ -4982,4 +5019,32 @@ public final class ActiveServices {
         }
         return false;
     }
+
+    boolean canAllowWhileInUsePermissionInFgsLocked(int callingPid, int callingUid,
+            String callingPackage) {
+        return shouldAllowWhileInUsePermissionInFgsLocked(
+                callingPackage, callingPid, callingUid, null, false);
+    }
+
+    /**
+     * In R, mAllowWhileInUsePermissionInFgs is to allow while-in-use permissions in foreground
+     *  service or not. while-in-use permissions in FGS started from background might be restricted.
+     * @param callingPackage caller app's package name.
+     * @param callingUid caller app's uid.
+     * @param r the service to start.
+     * @return true if allow, false otherwise.
+     */
+    private void setFgsRestrictionLocked(String callingPackage,
+            int callingPid, int callingUid, ServiceRecord r,
+            boolean allowBackgroundActivityStarts) {
+        r.mLastSetFgsRestrictionTime = SystemClock.elapsedRealtime();
+        if (!r.mAllowWhileInUsePermissionInFgs) {
+            r.mAllowWhileInUsePermissionInFgs = shouldAllowWhileInUsePermissionInFgsLocked(
+                    callingPackage, callingPid, callingUid, r, allowBackgroundActivityStarts);
+        }
+    }
+
+    private void resetFgsRestrictionLocked(ServiceRecord r) {
+        r.mAllowWhileInUsePermissionInFgs = false;
+    }
 }
",86,21,"ActiveServices::setServiceForegroundInnerLocked, ActiveServices::shouldAllowWhileInUsePermissionInFgsLocked, ActiveServices::shouldAllowWhileInUsePermissionInFgsLocked, ActiveServices::resetFgsRestrictionLocked, ActiveServices::canAllowWhileInUsePermissionInFgsLocked, ActiveServices::bindServiceLocked, ActiveServices::bringDownServiceLocked, ActiveServices::startServiceLocked, ActiveServices::setFgsRestrictionLocked"
128,b64352d7c66e93ddc2b448f556e265178309d730,ActivityManagerConstants.java,"@@ -88,6 +88,7 @@ final class ActivityManagerConstants extends ContentObserver {
     static final String KEY_PROCESS_START_ASYNC = ""process_start_async"";
     static final String KEY_MEMORY_INFO_THROTTLE_TIME = ""memory_info_throttle_time"";
     static final String KEY_TOP_TO_FGS_GRACE_DURATION = ""top_to_fgs_grace_duration"";
+    static final String KEY_FGS_START_FOREGROUND_TIMEOUT = ""fgs_start_foreground_timeout"";
     static final String KEY_PENDINGINTENT_WARNING_THRESHOLD = ""pendingintent_warning_threshold"";
 
     private static final int DEFAULT_MAX_CACHED_PROCESSES = 32;
@@ -121,6 +122,7 @@ final class ActivityManagerConstants extends ContentObserver {
     private static final boolean DEFAULT_PROCESS_START_ASYNC = true;
     private static final long DEFAULT_MEMORY_INFO_THROTTLE_TIME = 5*60*1000;
     private static final long DEFAULT_TOP_TO_FGS_GRACE_DURATION = 15 * 1000;
+    private static final int DEFAULT_FGS_START_FOREGROUND_TIMEOUT_MS = 10 * 1000;
     private static final int DEFAULT_PENDINGINTENT_WARNING_THRESHOLD = 2000;
 
     // Flag stored in the DeviceConfig API.
@@ -273,6 +275,12 @@ final class ActivityManagerConstants extends ContentObserver {
     // this long.
     public long TOP_TO_FGS_GRACE_DURATION = DEFAULT_TOP_TO_FGS_GRACE_DURATION;
 
+    /**
+     * When service started from background, before the timeout it can be promoted to FGS by calling
+     * Service.startForeground().
+     */
+    volatile long mFgsStartForegroundTimeoutMs = DEFAULT_FGS_START_FOREGROUND_TIMEOUT_MS;
+
     // Indicates whether the activity starts logging is enabled.
     // Controlled by Settings.Global.ACTIVITY_STARTS_LOGGING_ENABLED
     volatile boolean mFlagActivityStartsLoggingEnabled;
@@ -421,6 +429,9 @@ final class ActivityManagerConstants extends ContentObserver {
                             case KEY_MIN_ASSOC_LOG_DURATION:
                                 updateMinAssocLogDuration();
                                 break;
+                            case KEY_FGS_START_FOREGROUND_TIMEOUT:
+                                updateFgsStartForegroundTimeout();
+                                break;
                             default:
                                 break;
                         }
@@ -697,6 +708,13 @@ final class ActivityManagerConstants extends ContentObserver {
                 /* defaultValue */ DEFAULT_MIN_ASSOC_LOG_DURATION);
     }
 
+    private void updateFgsStartForegroundTimeout() {
+        mFgsStartForegroundTimeoutMs = DeviceConfig.getLong(
+                DeviceConfig.NAMESPACE_ACTIVITY_MANAGER,
+                KEY_FGS_START_FOREGROUND_TIMEOUT,
+                DEFAULT_FGS_START_FOREGROUND_TIMEOUT_MS);
+    }
+
     void dump(PrintWriter pw) {
         pw.println(""ACTIVITY MANAGER SETTINGS (dumpsys activity settings) ""
                 + Settings.Global.ACTIVITY_MANAGER_CONSTANTS + "":"");
@@ -769,6 +787,8 @@ final class ActivityManagerConstants extends ContentObserver {
         pw.println(Arrays.toString(IMPERCEPTIBLE_KILL_EXEMPT_PACKAGES.toArray()));
         pw.print(""  ""); pw.print(KEY_MIN_ASSOC_LOG_DURATION); pw.print(""="");
         pw.println(MIN_ASSOC_LOG_DURATION);
+        pw.print(""  ""); pw.print(KEY_FGS_START_FOREGROUND_TIMEOUT); pw.print(""="");
+        pw.println(mFgsStartForegroundTimeoutMs);
 
         pw.println();
         if (mOverrideMaxCachedProcesses >= 0) {
",20,0,"ActivityManagerConstants::dump, ActivityManagerConstants::OnPropertiesChangedListener, ActivityManagerConstants::updateFgsStartForegroundTimeout"
129,b64352d7c66e93ddc2b448f556e265178309d730,ServiceRecord.java,"@@ -142,6 +142,10 @@ final class ServiceRecord extends Binder implements ComponentName.WithComponentN
     // allow while-in-use permissions in foreground service or not.
     // while-in-use permissions in FGS started from background might be restricted.
     boolean mAllowWhileInUsePermissionInFgs;
+    // The number of times Service.startForeground() is called;
+    int mStartForegroundCount;
+    // Last time mAllowWhileInUsePermissionInFgs is set.
+    long mLastSetFgsRestrictionTime;
 
     // the most recent package that start/bind this service.
     String mRecentCallingPackage;
@@ -406,6 +410,8 @@ final class ServiceRecord extends Binder implements ComponentName.WithComponentN
         }
         pw.print(prefix); pw.print(""allowWhileInUsePermissionInFgs="");
                 pw.println(mAllowWhileInUsePermissionInFgs);
+        pw.print(prefix); pw.print(""startForegroundCount="");
+        pw.println(mStartForegroundCount);
         pw.print(prefix); pw.print(""recentCallingPackage="");
                 pw.println(mRecentCallingPackage);
         if (delayed) {
",6,0,ServiceRecord::dump
130,14749db61674efa5030fcb5bb96b23410d582200,KeyEvent.java,"@@ -1216,6 +1216,12 @@ public class KeyEvent extends InputEvent implements Parcelable {
      */
     public static final int FLAG_FALLBACK = 0x400;
 
+    /**
+     * Private flag that indicates that event was sent from EdgeBackGestureHandler.
+     * @hide
+     */
+    public static final int FLAG_LONG_SWIPE = 0x800;
+
     /**
      * Signifies that the key is being predispatched.
      * @hide
",6,0,
131,14749db61674efa5030fcb5bb96b23410d582200,EdgeBackGestureHandler.java,"@@ -235,9 +235,9 @@ public class EdgeBackGestureHandler extends CurrentUserTracker implements Displa
                 @Override
                 public void triggerBack(boolean isLongPress) {
                     sendEvent(KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_BACK,
-                            isLongPress ? KeyEvent.FLAG_LONG_PRESS : 0);
+                            isLongPress ? KeyEvent.FLAG_LONG_SWIPE : 0);
                     sendEvent(KeyEvent.ACTION_UP, KeyEvent.KEYCODE_BACK,
-                            isLongPress ? KeyEvent.FLAG_LONG_PRESS : 0);
+                            isLongPress ? KeyEvent.FLAG_LONG_SWIPE : 0);
 
                     mOverviewProxyService.notifyBackAction(true, (int) mDownPoint.x,
                             (int) mDownPoint.y, false /* isButton */, !mIsOnLeftEdge);
",2,2,EdgeBackGestureHandler::BackCallback
132,14749db61674efa5030fcb5bb96b23410d582200,PhoneWindowManager.java,"@@ -719,8 +719,6 @@ public class PhoneWindowManager implements WindowManagerPolicy {
     private PendingIntent mTorchOffPendingIntent;
 
     private boolean mLongSwipeDown;
-    private static final int LONG_SWIPE_FLAGS = KeyEvent.FLAG_LONG_PRESS
-            | KeyEvent.FLAG_FROM_SYSTEM | KeyEvent.FLAG_VIRTUAL_HARD_KEY;
 
     private LineageHardwareManager mLineageHardware;
 
@@ -4263,7 +4261,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
         // Handle special keys.
         switch (keyCode) {
             case KeyEvent.KEYCODE_BACK: {
-                boolean isLongSwipe = (event.getFlags() & LONG_SWIPE_FLAGS) == LONG_SWIPE_FLAGS;
+                boolean isLongSwipe = (event.getFlags() & KeyEvent.FLAG_LONG_SWIPE) != 0;
                 if (mLongSwipeDown && isLongSwipe && !down) {
                     // Trigger long swipe action
                     performKeyAction(mEdgeLongSwipeAction, event);
",1,3,PhoneWindowManager::interceptKeyBeforeQueueing
133,255c6ea6a8be49084c5ffd5a850e476a4368f422,QSPanel.java,"@@ -664,8 +664,8 @@ public class QSPanel extends LinearLayout implements Tunable, Callback, Brightne
         return mUsingMediaPlayer && mMediaHost.getVisible()
                 && getResources().getConfiguration().orientation
                 == Configuration.ORIENTATION_LANDSCAPE
-                && getResources().getConfiguration().screenWidthDp
-                < 600;
+                && getResources().getConfiguration().screenHeightDp
+                < 480;
     }
 
     protected void reAttachMediaHost() {
",2,2,QSPanel::shouldUseHorizontalLayout
134,7ba7894a364e69cafe9a083b7e33af1bf45fe3d1,VolumeDialogImpl.java,"@@ -573,7 +573,11 @@ public class VolumeDialogImpl implements VolumeDialog,
         if (!vis && stream == mAllyStream) {
             return;
         }
-        Util.setVisOrGone(findRow(stream).view, vis);
+
+        VolumeRow streamRow = findRow(stream);
+        if (streamRow != null && streamRow.view != null) {
+            Util.setVisOrGone(streamRow.view, vis);
+        }
     }
 
     private void updateExpandedRows(boolean expand) {
",5,1,VolumeDialogImpl::setVisOrGone
135,899621a53b404a55baff1e7d4ac3505a0d191c89,PhoneWindowManager.java,"@@ -1024,7 +1024,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
         // Reset back key state for long press
         mBackKeyHandled = false;
 
-        if (hasLongPressOnBackBehavior()) {
+        if (hasLongPressOnBackBehavior() && !mHandler.hasMessages(MSG_BACK_LONG_PRESS)) {
             Message msg = mHandler.obtainMessage(MSG_BACK_LONG_PRESS, event);
             msg.setAsynchronous(true);
             mHandler.sendMessageDelayed(msg,
",1,1,PhoneWindowManager::interceptBackKeyDown
136,f876646c54ec5072412ebb1dfcd6e57956ea7d98,PhoneWindowManager.java,"@@ -4280,6 +4280,12 @@ public class PhoneWindowManager implements WindowManagerPolicy {
 
                 if (down) {
                     interceptBackKeyDown(event);
+
+                    // Don't pass repeated events to app if user has custom long press action
+                    // set up in settings
+                    if (event.getRepeatCount() > 0 && hasLongPressOnBackBehavior()) {
+                        result &= ~ACTION_PASS_TO_USER;
+                    }
                 } else {
                     boolean handled = interceptBackKeyUp(event);
 
",6,0,PhoneWindowManager::interceptKeyBeforeQueueing
137,22ad5e7d8240c949a8a1bd8a7de459582a40bbb5,NetworkPolicyManagerService.java,"@@ -258,6 +258,8 @@ import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
 import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
 import java.io.PrintWriter;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -2213,208 +2215,211 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {
         FileInputStream fis = null;
         try {
             fis = mPolicyFile.openRead();
-            final XmlPullParser in = Xml.newPullParser();
-            in.setInput(fis, StandardCharsets.UTF_8.name());
-
-             // Must save the <restrict-background> tags and convert them to <uid-policy> later,
-             // to skip UIDs that were explicitly blacklisted.
-            final SparseBooleanArray whitelistedRestrictBackground = new SparseBooleanArray();
-
-            int type;
-            int version = VERSION_INIT;
-            boolean insideWhitelist = false;
-            while ((type = in.next()) != END_DOCUMENT) {
-                final String tag = in.getName();
-                if (type == START_TAG) {
-                    if (TAG_POLICY_LIST.equals(tag)) {
-                        final boolean oldValue = mRestrictBackground;
-                        version = readIntAttribute(in, ATTR_VERSION);
-                        mLoadedRestrictBackground = (version >= VERSION_ADDED_RESTRICT_BACKGROUND)
-                                && readBooleanAttribute(in, ATTR_RESTRICT_BACKGROUND);
-                    } else if (TAG_NETWORK_POLICY.equals(tag)) {
-                        final int networkTemplate = readIntAttribute(in, ATTR_NETWORK_TEMPLATE);
-                        final String subscriberId = in.getAttributeValue(null, ATTR_SUBSCRIBER_ID);
-                        final String networkId;
-                        if (version >= VERSION_ADDED_NETWORK_ID) {
-                            networkId = in.getAttributeValue(null, ATTR_NETWORK_ID);
-                        } else {
-                            networkId = null;
-                        }
-                        final RecurrenceRule cycleRule;
-                        if (version >= VERSION_ADDED_CYCLE) {
-                            final String start = readStringAttribute(in, ATTR_CYCLE_START);
-                            final String end = readStringAttribute(in, ATTR_CYCLE_END);
-                            final String period = readStringAttribute(in, ATTR_CYCLE_PERIOD);
-                            cycleRule = new RecurrenceRule(
-                                    RecurrenceRule.convertZonedDateTime(start),
-                                    RecurrenceRule.convertZonedDateTime(end),
-                                    RecurrenceRule.convertPeriod(period));
-                        } else {
-                            final int cycleDay = readIntAttribute(in, ATTR_CYCLE_DAY);
-                            final String cycleTimezone;
-                            if (version >= VERSION_ADDED_TIMEZONE) {
-                                cycleTimezone = in.getAttributeValue(null, ATTR_CYCLE_TIMEZONE);
-                            } else {
-                                cycleTimezone = ""UTC"";
-                            }
-                            cycleRule = NetworkPolicy.buildRule(cycleDay, ZoneId.of(cycleTimezone));
-                        }
-                        final long warningBytes = readLongAttribute(in, ATTR_WARNING_BYTES);
-                        final long limitBytes = readLongAttribute(in, ATTR_LIMIT_BYTES);
-                        final long lastLimitSnooze;
-                        if (version >= VERSION_SPLIT_SNOOZE) {
-                            lastLimitSnooze = readLongAttribute(in, ATTR_LAST_LIMIT_SNOOZE);
-                        } else if (version >= VERSION_ADDED_SNOOZE) {
-                            lastLimitSnooze = readLongAttribute(in, ATTR_LAST_SNOOZE);
-                        } else {
-                            lastLimitSnooze = SNOOZE_NEVER;
-                        }
-                        final boolean metered;
-                        if (version >= VERSION_ADDED_METERED) {
-                            metered = readBooleanAttribute(in, ATTR_METERED);
-                        } else {
-                            switch (networkTemplate) {
-                                case MATCH_MOBILE:
-                                    metered = true;
-                                    break;
-                                default:
-                                    metered = false;
-                            }
-                        }
-                        final long lastWarningSnooze;
-                        if (version >= VERSION_SPLIT_SNOOZE) {
-                            lastWarningSnooze = readLongAttribute(in, ATTR_LAST_WARNING_SNOOZE);
-                        } else {
-                            lastWarningSnooze = SNOOZE_NEVER;
-                        }
-                        final boolean inferred;
-                        if (version >= VERSION_ADDED_INFERRED) {
-                            inferred = readBooleanAttribute(in, ATTR_INFERRED);
-                        } else {
-                            inferred = false;
-                        }
-
-                        final NetworkTemplate template = new NetworkTemplate(networkTemplate,
-                                subscriberId, networkId);
-                        if (template.isPersistable()) {
-                            mNetworkPolicy.put(template, new NetworkPolicy(template, cycleRule,
-                                    warningBytes, limitBytes, lastWarningSnooze,
-                                    lastLimitSnooze, metered, inferred));
-                        }
+            readPolicyXml(fis);
+        } catch (FileNotFoundException e) {
+            // missing policy is okay, probably first boot
+            upgradeDefaultBackgroundDataUL();
+        } catch (Exception e) {
+            Log.wtf(TAG, ""problem reading network policy"", e);
+        } finally {
+            IoUtils.closeQuietly(fis);
+        }
+    }
 
-                    } else if (TAG_SUBSCRIPTION_PLAN.equals(tag)) {
+    private void readPolicyXml(InputStream inputStream) {
+        final XmlPullParser in = Xml.newPullParser();
+        in.setInput(inputStream, StandardCharsets.UTF_8.name());
+
+        // Must save the <restrict-background> tags and convert them to <uid-policy> later,
+        // to skip UIDs that were explicitly blacklisted.
+        final SparseBooleanArray whitelistedRestrictBackground = new SparseBooleanArray();
+
+        int type;
+        int version = VERSION_INIT;
+        boolean insideWhitelist = false;
+        while ((type = in.next()) != END_DOCUMENT) {
+            final String tag = in.getName();
+            if (type == START_TAG) {
+                if (TAG_POLICY_LIST.equals(tag)) {
+                    final boolean oldValue = mRestrictBackground;
+                    version = readIntAttribute(in, ATTR_VERSION);
+                    mLoadedRestrictBackground = (version >= VERSION_ADDED_RESTRICT_BACKGROUND)
+                            && readBooleanAttribute(in, ATTR_RESTRICT_BACKGROUND);
+                } else if (TAG_NETWORK_POLICY.equals(tag)) {
+                    final int networkTemplate = readIntAttribute(in, ATTR_NETWORK_TEMPLATE);
+                    final String subscriberId = in.getAttributeValue(null, ATTR_SUBSCRIBER_ID);
+                    final String networkId;
+                    if (version >= VERSION_ADDED_NETWORK_ID) {
+                        networkId = in.getAttributeValue(null, ATTR_NETWORK_ID);
+                    } else {
+                        networkId = null;
+                    }
+                    final RecurrenceRule cycleRule;
+                    if (version >= VERSION_ADDED_CYCLE) {
                         final String start = readStringAttribute(in, ATTR_CYCLE_START);
                         final String end = readStringAttribute(in, ATTR_CYCLE_END);
                         final String period = readStringAttribute(in, ATTR_CYCLE_PERIOD);
-                        final SubscriptionPlan.Builder builder = new SubscriptionPlan.Builder(
+                        cycleRule = new RecurrenceRule(
                                 RecurrenceRule.convertZonedDateTime(start),
                                 RecurrenceRule.convertZonedDateTime(end),
                                 RecurrenceRule.convertPeriod(period));
-                        builder.setTitle(readStringAttribute(in, ATTR_TITLE));
-                        builder.setSummary(readStringAttribute(in, ATTR_SUMMARY));
-
-                        final long limitBytes = readLongAttribute(in, ATTR_LIMIT_BYTES,
-                                SubscriptionPlan.BYTES_UNKNOWN);
-                        final int limitBehavior = readIntAttribute(in, ATTR_LIMIT_BEHAVIOR,
-                                SubscriptionPlan.LIMIT_BEHAVIOR_UNKNOWN);
-                        if (limitBytes != SubscriptionPlan.BYTES_UNKNOWN
-                                && limitBehavior != SubscriptionPlan.LIMIT_BEHAVIOR_UNKNOWN) {
-                            builder.setDataLimit(limitBytes, limitBehavior);
+                    } else {
+                        final int cycleDay = readIntAttribute(in, ATTR_CYCLE_DAY);
+                        final String cycleTimezone;
+                        if (version >= VERSION_ADDED_TIMEZONE) {
+                            cycleTimezone = in.getAttributeValue(null, ATTR_CYCLE_TIMEZONE);
+                        } else {
+                            cycleTimezone = ""UTC"";
                         }
-
-                        final long usageBytes = readLongAttribute(in, ATTR_USAGE_BYTES,
-                                SubscriptionPlan.BYTES_UNKNOWN);
-                        final long usageTime = readLongAttribute(in, ATTR_USAGE_TIME,
-                                SubscriptionPlan.TIME_UNKNOWN);
-                        if (usageBytes != SubscriptionPlan.BYTES_UNKNOWN
-                                && usageTime != SubscriptionPlan.TIME_UNKNOWN) {
-                            builder.setDataUsage(usageBytes, usageTime);
+                        cycleRule = NetworkPolicy.buildRule(cycleDay, ZoneId.of(cycleTimezone));
+                    }
+                    final long warningBytes = readLongAttribute(in, ATTR_WARNING_BYTES);
+                    final long limitBytes = readLongAttribute(in, ATTR_LIMIT_BYTES);
+                    final long lastLimitSnooze;
+                    if (version >= VERSION_SPLIT_SNOOZE) {
+                        lastLimitSnooze = readLongAttribute(in, ATTR_LAST_LIMIT_SNOOZE);
+                    } else if (version >= VERSION_ADDED_SNOOZE) {
+                        lastLimitSnooze = readLongAttribute(in, ATTR_LAST_SNOOZE);
+                    } else {
+                        lastLimitSnooze = SNOOZE_NEVER;
+                    }
+                    final boolean metered;
+                    if (version >= VERSION_ADDED_METERED) {
+                        metered = readBooleanAttribute(in, ATTR_METERED);
+                    } else {
+                        switch (networkTemplate) {
+                            case MATCH_MOBILE:
+                                metered = true;
+                                break;
+                            default:
+                                metered = false;
                         }
+                    }
+                    final long lastWarningSnooze;
+                    if (version >= VERSION_SPLIT_SNOOZE) {
+                        lastWarningSnooze = readLongAttribute(in, ATTR_LAST_WARNING_SNOOZE);
+                    } else {
+                        lastWarningSnooze = SNOOZE_NEVER;
+                    }
+                    final boolean inferred;
+                    if (version >= VERSION_ADDED_INFERRED) {
+                        inferred = readBooleanAttribute(in, ATTR_INFERRED);
+                    } else {
+                        inferred = false;
+                    }
 
-                        final int subId = readIntAttribute(in, ATTR_SUB_ID);
-                        final String ownerPackage = readStringAttribute(in, ATTR_OWNER_PACKAGE);
-
-                        if (version >= VERSION_ADDED_NETWORK_TYPES) {
-                            final int depth = in.getDepth();
-                            while (XmlUtils.nextElementWithin(in, depth)) {
-                                if (TAG_XML_UTILS_INT_ARRAY.equals(in.getName())
-                                        && ATTR_NETWORK_TYPES.equals(
-                                                readStringAttribute(in, ATTR_XML_UTILS_NAME))) {
-                                    final int[] networkTypes =
-                                            readThisIntArrayXml(in, TAG_XML_UTILS_INT_ARRAY, null);
-                                    builder.setNetworkTypes(networkTypes);
-                                }
-                            }
-                        }
+                    final NetworkTemplate template = new NetworkTemplate(networkTemplate,
+                            subscriberId, networkId);
+                    if (template.isPersistable()) {
+                        mNetworkPolicy.put(template, new NetworkPolicy(template, cycleRule,
+                                warningBytes, limitBytes, lastWarningSnooze,
+                                lastLimitSnooze, metered, inferred));
+                    }
 
-                        final SubscriptionPlan plan = builder.build();
-                        mSubscriptionPlans.put(subId, ArrayUtils.appendElement(
-                                SubscriptionPlan.class, mSubscriptionPlans.get(subId), plan));
-                        mSubscriptionPlansOwner.put(subId, ownerPackage);
-                    } else if (TAG_UID_POLICY.equals(tag)) {
-                        final int uid = readIntAttribute(in, ATTR_UID);
-                        final int policy = readIntAttribute(in, ATTR_POLICY);
+                } else if (TAG_SUBSCRIPTION_PLAN.equals(tag)) {
+                    final String start = readStringAttribute(in, ATTR_CYCLE_START);
+                    final String end = readStringAttribute(in, ATTR_CYCLE_END);
+                    final String period = readStringAttribute(in, ATTR_CYCLE_PERIOD);
+                    final SubscriptionPlan.Builder builder = new SubscriptionPlan.Builder(
+                            RecurrenceRule.convertZonedDateTime(start),
+                            RecurrenceRule.convertZonedDateTime(end),
+                            RecurrenceRule.convertPeriod(period));
+                    builder.setTitle(readStringAttribute(in, ATTR_TITLE));
+                    builder.setSummary(readStringAttribute(in, ATTR_SUMMARY));
+
+                    final long limitBytes = readLongAttribute(in, ATTR_LIMIT_BYTES,
+                            SubscriptionPlan.BYTES_UNKNOWN);
+                    final int limitBehavior = readIntAttribute(in, ATTR_LIMIT_BEHAVIOR,
+                            SubscriptionPlan.LIMIT_BEHAVIOR_UNKNOWN);
+                    if (limitBytes != SubscriptionPlan.BYTES_UNKNOWN
+                            && limitBehavior != SubscriptionPlan.LIMIT_BEHAVIOR_UNKNOWN) {
+                        builder.setDataLimit(limitBytes, limitBehavior);
+                    }
 
-                        if (UserHandle.isApp(uid)) {
-                            setUidPolicyUncheckedUL(uid, policy, false);
-                        } else {
-                            Slog.w(TAG, ""unable to apply policy to UID "" + uid + ""; ignoring"");
-                        }
-                    } else if (TAG_APP_POLICY.equals(tag)) {
-                        final int appId = readIntAttribute(in, ATTR_APP_ID);
-                        final int policy = readIntAttribute(in, ATTR_POLICY);
-
-                        // TODO: set for other users during upgrade
-                        // app policy is deprecated so this is only used in pre system user split.
-                        final int uid = UserHandle.getUid(UserHandle.USER_SYSTEM, appId);
-                        if (UserHandle.isApp(uid)) {
-                            setUidPolicyUncheckedUL(uid, policy, false);
-                        } else {
-                            Slog.w(TAG, ""unable to apply policy to UID "" + uid + ""; ignoring"");
-                        }
-                    } else if (TAG_WHITELIST.equals(tag)) {
-                        insideWhitelist = true;
-                    } else if (TAG_RESTRICT_BACKGROUND.equals(tag) && insideWhitelist) {
-                        final int uid = readIntAttribute(in, ATTR_UID);
-                        whitelistedRestrictBackground.append(uid, true);
-                    } else if (TAG_REVOKED_RESTRICT_BACKGROUND.equals(tag) && insideWhitelist) {
-                        final int uid = readIntAttribute(in, ATTR_UID);
-                        mRestrictBackgroundWhitelistRevokedUids.put(uid, true);
+                    final long usageBytes = readLongAttribute(in, ATTR_USAGE_BYTES,
+                            SubscriptionPlan.BYTES_UNKNOWN);
+                    final long usageTime = readLongAttribute(in, ATTR_USAGE_TIME,
+                            SubscriptionPlan.TIME_UNKNOWN);
+                    if (usageBytes != SubscriptionPlan.BYTES_UNKNOWN
+                            && usageTime != SubscriptionPlan.TIME_UNKNOWN) {
+                        builder.setDataUsage(usageBytes, usageTime);
                     }
-                } else if (type == END_TAG) {
-                    if (TAG_WHITELIST.equals(tag)) {
-                        insideWhitelist = false;
+
+                    final int subId = readIntAttribute(in, ATTR_SUB_ID);
+                    final String ownerPackage = readStringAttribute(in, ATTR_OWNER_PACKAGE);
+
+                    if (version >= VERSION_ADDED_NETWORK_TYPES) {
+                        final int depth = in.getDepth();
+                        while (XmlUtils.nextElementWithin(in, depth)) {
+                            if (TAG_XML_UTILS_INT_ARRAY.equals(in.getName())
+                                    && ATTR_NETWORK_TYPES.equals(
+                                    readStringAttribute(in, ATTR_XML_UTILS_NAME))) {
+                                final int[] networkTypes =
+                                        readThisIntArrayXml(in, TAG_XML_UTILS_INT_ARRAY, null);
+                                builder.setNetworkTypes(networkTypes);
+                            }
+                        }
                     }
 
-                }
-            }
+                    final SubscriptionPlan plan = builder.build();
+                    mSubscriptionPlans.put(subId, ArrayUtils.appendElement(
+                            SubscriptionPlan.class, mSubscriptionPlans.get(subId), plan));
+                    mSubscriptionPlansOwner.put(subId, ownerPackage);
+                } else if (TAG_UID_POLICY.equals(tag)) {
+                    final int uid = readIntAttribute(in, ATTR_UID);
+                    final int policy = readIntAttribute(in, ATTR_POLICY);
 
-            final int size = whitelistedRestrictBackground.size();
-            for (int i = 0; i < size; i++) {
-                final int uid = whitelistedRestrictBackground.keyAt(i);
-                final int policy = mUidPolicy.get(uid, POLICY_NONE);
-                if ((policy & POLICY_REJECT_METERED_BACKGROUND) != 0) {
-                    Slog.w(TAG, ""ignoring restrict-background-whitelist for "" + uid
-                            + "" because its policy is "" + uidPoliciesToString(policy));
-                    continue;
+                    if (UserHandle.isApp(uid)) {
+                        setUidPolicyUncheckedUL(uid, policy, false);
+                    } else {
+                        Slog.w(TAG, ""unable to apply policy to UID "" + uid + ""; ignoring"");
+                    }
+                } else if (TAG_APP_POLICY.equals(tag)) {
+                    final int appId = readIntAttribute(in, ATTR_APP_ID);
+                    final int policy = readIntAttribute(in, ATTR_POLICY);
+
+                    // TODO: set for other users during upgrade
+                    // app policy is deprecated so this is only used in pre system user split.
+                    final int uid = UserHandle.getUid(UserHandle.USER_SYSTEM, appId);
+                    if (UserHandle.isApp(uid)) {
+                        setUidPolicyUncheckedUL(uid, policy, false);
+                    } else {
+                        Slog.w(TAG, ""unable to apply policy to UID "" + uid + ""; ignoring"");
+                    }
+                } else if (TAG_WHITELIST.equals(tag)) {
+                    insideWhitelist = true;
+                } else if (TAG_RESTRICT_BACKGROUND.equals(tag) && insideWhitelist) {
+                    final int uid = readIntAttribute(in, ATTR_UID);
+                    whitelistedRestrictBackground.append(uid, true);
+                } else if (TAG_REVOKED_RESTRICT_BACKGROUND.equals(tag) && insideWhitelist) {
+                    final int uid = readIntAttribute(in, ATTR_UID);
+                    mRestrictBackgroundWhitelistRevokedUids.put(uid, true);
                 }
-                if (UserHandle.isApp(uid)) {
-                    final int newPolicy = policy | POLICY_ALLOW_METERED_BACKGROUND;
-                    if (LOGV)
-                        Log.v(TAG, ""new policy for "" + uid + "": "" + uidPoliciesToString(newPolicy));
-                    setUidPolicyUncheckedUL(uid, newPolicy, false);
-                } else {
-                    Slog.w(TAG, ""unable to update policy on UID "" + uid);
+            } else if (type == END_TAG) {
+                if (TAG_WHITELIST.equals(tag)) {
+                    insideWhitelist = false;
                 }
+
             }
+        }
 
-        } catch (FileNotFoundException e) {
-            // missing policy is okay, probably first boot
-            upgradeDefaultBackgroundDataUL();
-        } catch (Exception e) {
-            Log.wtf(TAG, ""problem reading network policy"", e);
-        } finally {
-            IoUtils.closeQuietly(fis);
+        final int size = whitelistedRestrictBackground.size();
+        for (int i = 0; i < size; i++) {
+            final int uid = whitelistedRestrictBackground.keyAt(i);
+            final int policy = mUidPolicy.get(uid, POLICY_NONE);
+            if ((policy & POLICY_REJECT_METERED_BACKGROUND) != 0) {
+                Slog.w(TAG, ""ignoring restrict-background-whitelist for "" + uid
+                        + "" because its policy is "" + uidPoliciesToString(policy));
+                continue;
+            }
+            if (UserHandle.isApp(uid)) {
+                final int newPolicy = policy | POLICY_ALLOW_METERED_BACKGROUND;
+                if (LOGV)
+                    Log.v(TAG, ""new policy for "" + uid + "": "" + uidPoliciesToString(newPolicy));
+                setUidPolicyUncheckedUL(uid, newPolicy, false);
+            } else {
+                Slog.w(TAG, ""unable to update policy on UID "" + uid);
+            }
         }
     }
 
@@ -2483,114 +2488,118 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {
         try {
             fos = mPolicyFile.startWrite();
 
-            XmlSerializer out = new FastXmlSerializer();
-            out.setOutput(fos, StandardCharsets.UTF_8.name());
-            out.startDocument(null, true);
+            writePolicyXml(fos);
 
-            out.startTag(null, TAG_POLICY_LIST);
-            writeIntAttribute(out, ATTR_VERSION, VERSION_LATEST);
-            writeBooleanAttribute(out, ATTR_RESTRICT_BACKGROUND, mRestrictBackground);
+            mPolicyFile.finishWrite(fos);
+        } catch (IOException e) {
+            if (fos != null) {
+                mPolicyFile.failWrite(fos);
+            }
+        }
+    }
 
-            // write all known network policies
-            for (int i = 0; i < mNetworkPolicy.size(); i++) {
-                final NetworkPolicy policy = mNetworkPolicy.valueAt(i);
-                final NetworkTemplate template = policy.template;
-                if (!template.isPersistable()) continue;
-
-                out.startTag(null, TAG_NETWORK_POLICY);
-                writeIntAttribute(out, ATTR_NETWORK_TEMPLATE, template.getMatchRule());
-                final String subscriberId = template.getSubscriberId();
-                if (subscriberId != null) {
-                    out.attribute(null, ATTR_SUBSCRIBER_ID, subscriberId);
-                }
-                final String networkId = template.getNetworkId();
-                if (networkId != null) {
-                    out.attribute(null, ATTR_NETWORK_ID, networkId);
-                }
+    private void writePolicyXml(OutputStream outputStream) {
+        XmlSerializer out = new FastXmlSerializer();
+        out.setOutput(outputStream, StandardCharsets.UTF_8.name());
+        out.startDocument(null, true);
+
+        out.startTag(null, TAG_POLICY_LIST);
+        writeIntAttribute(out, ATTR_VERSION, VERSION_LATEST);
+        writeBooleanAttribute(out, ATTR_RESTRICT_BACKGROUND, mRestrictBackground);
+
+        // write all known network policies
+        for (int i = 0; i < mNetworkPolicy.size(); i++) {
+            final NetworkPolicy policy = mNetworkPolicy.valueAt(i);
+            final NetworkTemplate template = policy.template;
+            if (!template.isPersistable()) continue;
+
+            out.startTag(null, TAG_NETWORK_POLICY);
+            writeIntAttribute(out, ATTR_NETWORK_TEMPLATE, template.getMatchRule());
+            final String subscriberId = template.getSubscriberId();
+            if (subscriberId != null) {
+                out.attribute(null, ATTR_SUBSCRIBER_ID, subscriberId);
+            }
+            final String networkId = template.getNetworkId();
+            if (networkId != null) {
+                out.attribute(null, ATTR_NETWORK_ID, networkId);
+            }
+            writeStringAttribute(out, ATTR_CYCLE_START,
+                    RecurrenceRule.convertZonedDateTime(policy.cycleRule.start));
+            writeStringAttribute(out, ATTR_CYCLE_END,
+                    RecurrenceRule.convertZonedDateTime(policy.cycleRule.end));
+            writeStringAttribute(out, ATTR_CYCLE_PERIOD,
+                    RecurrenceRule.convertPeriod(policy.cycleRule.period));
+            writeLongAttribute(out, ATTR_WARNING_BYTES, policy.warningBytes);
+            writeLongAttribute(out, ATTR_LIMIT_BYTES, policy.limitBytes);
+            writeLongAttribute(out, ATTR_LAST_WARNING_SNOOZE, policy.lastWarningSnooze);
+            writeLongAttribute(out, ATTR_LAST_LIMIT_SNOOZE, policy.lastLimitSnooze);
+            writeBooleanAttribute(out, ATTR_METERED, policy.metered);
+            writeBooleanAttribute(out, ATTR_INFERRED, policy.inferred);
+            out.endTag(null, TAG_NETWORK_POLICY);
+        }
+
+        // write all known subscription plans
+        for (int i = 0; i < mSubscriptionPlans.size(); i++) {
+            final int subId = mSubscriptionPlans.keyAt(i);
+            final String ownerPackage = mSubscriptionPlansOwner.get(subId);
+            final SubscriptionPlan[] plans = mSubscriptionPlans.valueAt(i);
+            if (ArrayUtils.isEmpty(plans)) continue;
+
+            for (SubscriptionPlan plan : plans) {
+                out.startTag(null, TAG_SUBSCRIPTION_PLAN);
+                writeIntAttribute(out, ATTR_SUB_ID, subId);
+                writeStringAttribute(out, ATTR_OWNER_PACKAGE, ownerPackage);
+                final RecurrenceRule cycleRule = plan.getCycleRule();
                 writeStringAttribute(out, ATTR_CYCLE_START,
-                        RecurrenceRule.convertZonedDateTime(policy.cycleRule.start));
+                        RecurrenceRule.convertZonedDateTime(cycleRule.start));
                 writeStringAttribute(out, ATTR_CYCLE_END,
-                        RecurrenceRule.convertZonedDateTime(policy.cycleRule.end));
+                        RecurrenceRule.convertZonedDateTime(cycleRule.end));
                 writeStringAttribute(out, ATTR_CYCLE_PERIOD,
-                        RecurrenceRule.convertPeriod(policy.cycleRule.period));
-                writeLongAttribute(out, ATTR_WARNING_BYTES, policy.warningBytes);
-                writeLongAttribute(out, ATTR_LIMIT_BYTES, policy.limitBytes);
-                writeLongAttribute(out, ATTR_LAST_WARNING_SNOOZE, policy.lastWarningSnooze);
-                writeLongAttribute(out, ATTR_LAST_LIMIT_SNOOZE, policy.lastLimitSnooze);
-                writeBooleanAttribute(out, ATTR_METERED, policy.metered);
-                writeBooleanAttribute(out, ATTR_INFERRED, policy.inferred);
-                out.endTag(null, TAG_NETWORK_POLICY);
-            }
-
-            // write all known subscription plans
-            for (int i = 0; i < mSubscriptionPlans.size(); i++) {
-                final int subId = mSubscriptionPlans.keyAt(i);
-                final String ownerPackage = mSubscriptionPlansOwner.get(subId);
-                final SubscriptionPlan[] plans = mSubscriptionPlans.valueAt(i);
-                if (ArrayUtils.isEmpty(plans)) continue;
-
-                for (SubscriptionPlan plan : plans) {
-                    out.startTag(null, TAG_SUBSCRIPTION_PLAN);
-                    writeIntAttribute(out, ATTR_SUB_ID, subId);
-                    writeStringAttribute(out, ATTR_OWNER_PACKAGE, ownerPackage);
-                    final RecurrenceRule cycleRule = plan.getCycleRule();
-                    writeStringAttribute(out, ATTR_CYCLE_START,
-                            RecurrenceRule.convertZonedDateTime(cycleRule.start));
-                    writeStringAttribute(out, ATTR_CYCLE_END,
-                            RecurrenceRule.convertZonedDateTime(cycleRule.end));
-                    writeStringAttribute(out, ATTR_CYCLE_PERIOD,
-                            RecurrenceRule.convertPeriod(cycleRule.period));
-                    writeStringAttribute(out, ATTR_TITLE, plan.getTitle());
-                    writeStringAttribute(out, ATTR_SUMMARY, plan.getSummary());
-                    writeLongAttribute(out, ATTR_LIMIT_BYTES, plan.getDataLimitBytes());
-                    writeIntAttribute(out, ATTR_LIMIT_BEHAVIOR, plan.getDataLimitBehavior());
-                    writeLongAttribute(out, ATTR_USAGE_BYTES, plan.getDataUsageBytes());
-                    writeLongAttribute(out, ATTR_USAGE_TIME, plan.getDataUsageTime());
-                    try {
-                        writeIntArrayXml(plan.getNetworkTypes(), ATTR_NETWORK_TYPES, out);
-                    } catch (XmlPullParserException ignored) { }
-                    out.endTag(null, TAG_SUBSCRIPTION_PLAN);
-                }
+                        RecurrenceRule.convertPeriod(cycleRule.period));
+                writeStringAttribute(out, ATTR_TITLE, plan.getTitle());
+                writeStringAttribute(out, ATTR_SUMMARY, plan.getSummary());
+                writeLongAttribute(out, ATTR_LIMIT_BYTES, plan.getDataLimitBytes());
+                writeIntAttribute(out, ATTR_LIMIT_BEHAVIOR, plan.getDataLimitBehavior());
+                writeLongAttribute(out, ATTR_USAGE_BYTES, plan.getDataUsageBytes());
+                writeLongAttribute(out, ATTR_USAGE_TIME, plan.getDataUsageTime());
+                try {
+                    writeIntArrayXml(plan.getNetworkTypes(), ATTR_NETWORK_TYPES, out);
+                } catch (XmlPullParserException ignored) { }
+                out.endTag(null, TAG_SUBSCRIPTION_PLAN);
             }
+        }
 
-            // write all known uid policies
-            for (int i = 0; i < mUidPolicy.size(); i++) {
-                final int uid = mUidPolicy.keyAt(i);
-                final int policy = mUidPolicy.valueAt(i);
+        // write all known uid policies
+        for (int i = 0; i < mUidPolicy.size(); i++) {
+            final int uid = mUidPolicy.keyAt(i);
+            final int policy = mUidPolicy.valueAt(i);
 
-                // skip writing empty policies
-                if (policy == POLICY_NONE) continue;
+            // skip writing empty policies
+            if (policy == POLICY_NONE) continue;
 
-                out.startTag(null, TAG_UID_POLICY);
-                writeIntAttribute(out, ATTR_UID, uid);
-                writeIntAttribute(out, ATTR_POLICY, policy);
-                out.endTag(null, TAG_UID_POLICY);
-            }
-
-            out.endTag(null, TAG_POLICY_LIST);
+            out.startTag(null, TAG_UID_POLICY);
+            writeIntAttribute(out, ATTR_UID, uid);
+            writeIntAttribute(out, ATTR_POLICY, policy);
+            out.endTag(null, TAG_UID_POLICY);
+        }
 
-            // write all whitelists
-            out.startTag(null, TAG_WHITELIST);
+        out.endTag(null, TAG_POLICY_LIST);
 
-            // revoked restrict background whitelist
-            int size = mRestrictBackgroundWhitelistRevokedUids.size();
-            for (int i = 0; i < size; i++) {
-                final int uid = mRestrictBackgroundWhitelistRevokedUids.keyAt(i);
-                out.startTag(null, TAG_REVOKED_RESTRICT_BACKGROUND);
-                writeIntAttribute(out, ATTR_UID, uid);
-                out.endTag(null, TAG_REVOKED_RESTRICT_BACKGROUND);
-            }
+        // write all whitelists
+        out.startTag(null, TAG_WHITELIST);
 
-            out.endTag(null, TAG_WHITELIST);
+        // revoked restrict background whitelist
+        int size = mRestrictBackgroundWhitelistRevokedUids.size();
+        for (int i = 0; i < size; i++) {
+            final int uid = mRestrictBackgroundWhitelistRevokedUids.keyAt(i);
+            out.startTag(null, TAG_REVOKED_RESTRICT_BACKGROUND);
+            writeIntAttribute(out, ATTR_UID, uid);
+            out.endTag(null, TAG_REVOKED_RESTRICT_BACKGROUND);
+        }
 
-            out.endDocument();
+        out.endTag(null, TAG_WHITELIST);
 
-            mPolicyFile.finishWrite(fos);
-        } catch (IOException e) {
-            if (fos != null) {
-                mPolicyFile.failWrite(fos);
-            }
-        }
+        out.endDocument();
     }
 
     @Override
",285,276,"NetworkPolicyManagerService::writePolicyXml, NetworkPolicyManagerService::writePolicyAL, NetworkPolicyManagerService::readPolicyXml, NetworkPolicyManagerService::readPolicyAL"
138,61fac218e22a876eb3506f49b7f375c2d1668983,NetworkPolicyBackupHelper.java,"@@ -0,0 +1,73 @@
+/*
+ * Copyright (C) 2021 The Calyx Institute
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.backup;
+
+import android.app.backup.BlobBackupHelper;
+import android.content.Context;
+import android.net.INetworkPolicyManager;
+import android.os.ServiceManager;
+import android.util.Log;
+import android.util.Slog;
+
+public class NetworkPolicyBackupHelper extends BlobBackupHelper {
+    private static final String TAG = ""NetworkPolicyBackupHelper"";
+    private static final boolean DEBUG = Log.isLoggable(TAG, Log.DEBUG);
+
+    // Current version of the blob schema
+    static final int BLOB_VERSION = 1;
+
+    // Key under which the payload blob is stored
+    static final String KEY_NETWORK_POLICY = ""network_policy"";
+
+    public NetworkPolicyBackupHelper() {
+        super(BLOB_VERSION, KEY_NETWORK_POLICY);
+    }
+
+    @Override
+    protected byte[] getBackupPayload(String key) {
+        byte[] newPayload = null;
+        if (KEY_NETWORK_POLICY.equals(key)) {
+            try {
+                INetworkPolicyManager npm = INetworkPolicyManager.Stub.asInterface(
+                        ServiceManager.getService(Context.NETWORK_POLICY_SERVICE));
+                newPayload = npm.getBackupPayload();
+            } catch (Exception e) {
+                // Treat as no data
+                Slog.e(TAG, ""Couldn't communicate with network policy manager"");
+                newPayload = null;
+            }
+        }
+        return newPayload;
+    }
+
+    @Override
+    protected void applyRestoredPayload(String key, byte[] payload) {
+        if (DEBUG) {
+            Slog.v(TAG, ""Got restore of "" + key);
+        }
+
+        if (KEY_NETWORK_POLICY.equals(key)) {
+            try {
+                INetworkPolicyManager.Stub.asInterface(
+                        ServiceManager.getService(Context.NETWORK_POLICY_SERVICE))
+                        .applyRestore(payload);
+            } catch (Exception e) {
+                Slog.e(TAG, ""Couldn't communicate with network policy manager"");
+            }
+        }
+    }
+}
",73,0,"NetworkPolicyBackupHelper::getBackupPayload, NetworkPolicyBackupHelper::NetworkPolicyBackupHelper, NetworkPolicyBackupHelper::applyRestoredPayload"
139,61fac218e22a876eb3506f49b7f375c2d1668983,SystemBackupAgent.java,"@@ -56,6 +56,7 @@ public class SystemBackupAgent extends BackupAgentHelper {
     private static final String ACCOUNT_MANAGER_HELPER = ""account_manager"";
     private static final String SLICES_HELPER = ""slices"";
     private static final String PEOPLE_HELPER = ""people"";
+    private static final String NETWORK_POLICY_HELPER = ""network_policy"";
 
     // These paths must match what the WallpaperManagerService uses.  The leaf *_FILENAME
     // are also used in the full-backup file format, so must not change unless steps are
@@ -101,6 +102,7 @@ public class SystemBackupAgent extends BackupAgentHelper {
         addHelper(ACCOUNT_MANAGER_HELPER, new AccountManagerBackupHelper());
         addHelper(SLICES_HELPER, new SliceBackupHelper(this));
         addHelper(PEOPLE_HELPER, new PeopleBackupHelper(mUserId));
+        addHelper(NETWORK_POLICY_HELPER, new NetworkPolicyBackupHelper());
     }
 
     @Override
",2,0,SystemBackupAgent::onCreate
140,61fac218e22a876eb3506f49b7f375c2d1668983,NetworkPolicyManagerService.java,"@@ -252,6 +252,8 @@ import org.xmlpull.v1.XmlPullParser;
 import org.xmlpull.v1.XmlPullParserException;
 import org.xmlpull.v1.XmlSerializer;
 
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
 import java.io.File;
 import java.io.FileDescriptor;
 import java.io.FileInputStream;
@@ -377,6 +379,7 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {
     private static final String ATTR_OWNER_PACKAGE = ""ownerPackage"";
     private static final String ATTR_NETWORK_TYPES = ""networkTypes"";
     private static final String ATTR_XML_UTILS_NAME = ""name"";
+    private static final String ATTR_USER_ID = ""userId"";
 
     private static final String ACTION_ALLOW_BACKGROUND =
             ""com.android.server.net.action.ALLOW_BACKGROUND"";
@@ -2215,7 +2218,7 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {
         FileInputStream fis = null;
         try {
             fis = mPolicyFile.openRead();
-            readPolicyXml(fis);
+            readPolicyXml(fis, false);
         } catch (FileNotFoundException e) {
             // missing policy is okay, probably first boot
             upgradeDefaultBackgroundDataUL();
@@ -2226,7 +2229,8 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {
         }
     }
 
-    private void readPolicyXml(InputStream inputStream) {
+    private void readPolicyXml(InputStream inputStream, boolean forRestore) throws IOException,
+            XmlPullParserException {
         final XmlPullParser in = Xml.newPullParser();
         in.setInput(inputStream, StandardCharsets.UTF_8.name());
 
@@ -2366,7 +2370,7 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {
                             SubscriptionPlan.class, mSubscriptionPlans.get(subId), plan));
                     mSubscriptionPlansOwner.put(subId, ownerPackage);
                 } else if (TAG_UID_POLICY.equals(tag)) {
-                    final int uid = readIntAttribute(in, ATTR_UID);
+                    int uid = readUidAttribute(in, forRestore);
                     final int policy = readIntAttribute(in, ATTR_POLICY);
 
                     if (UserHandle.isApp(uid)) {
@@ -2389,10 +2393,10 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {
                 } else if (TAG_WHITELIST.equals(tag)) {
                     insideWhitelist = true;
                 } else if (TAG_RESTRICT_BACKGROUND.equals(tag) && insideWhitelist) {
-                    final int uid = readIntAttribute(in, ATTR_UID);
+                    int uid = readUidAttribute(in, forRestore);
                     whitelistedRestrictBackground.append(uid, true);
                 } else if (TAG_REVOKED_RESTRICT_BACKGROUND.equals(tag) && insideWhitelist) {
-                    final int uid = readIntAttribute(in, ATTR_UID);
+                    int uid = readUidAttribute(in, forRestore);
                     mRestrictBackgroundWhitelistRevokedUids.put(uid, true);
                 }
             } else if (type == END_TAG) {
@@ -2487,9 +2491,7 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {
         FileOutputStream fos = null;
         try {
             fos = mPolicyFile.startWrite();
-
-            writePolicyXml(fos);
-
+            writePolicyXml(fos, false);
             mPolicyFile.finishWrite(fos);
         } catch (IOException e) {
             if (fos != null) {
@@ -2498,7 +2500,7 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {
         }
     }
 
-    private void writePolicyXml(OutputStream outputStream) {
+    private void writePolicyXml(OutputStream outputStream, boolean forBackup) throws IOException {
         XmlSerializer out = new FastXmlSerializer();
         out.setOutput(outputStream, StandardCharsets.UTF_8.name());
         out.startDocument(null, true);
@@ -2578,7 +2580,12 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {
             if (policy == POLICY_NONE) continue;
 
             out.startTag(null, TAG_UID_POLICY);
-            writeIntAttribute(out, ATTR_UID, uid);
+            if (!forBackup) {
+                writeIntAttribute(out, ATTR_UID, uid);
+            } else {
+                writeStringAttribute(out, ATTR_XML_UTILS_NAME, getPackageForUid(uid));
+                writeIntAttribute(out, ATTR_USER_ID, UserHandle.getUserId(uid));
+            }
             writeIntAttribute(out, ATTR_POLICY, policy);
             out.endTag(null, TAG_UID_POLICY);
         }
@@ -2593,7 +2600,12 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {
         for (int i = 0; i < size; i++) {
             final int uid = mRestrictBackgroundWhitelistRevokedUids.keyAt(i);
             out.startTag(null, TAG_REVOKED_RESTRICT_BACKGROUND);
-            writeIntAttribute(out, ATTR_UID, uid);
+            if (!forBackup) {
+                writeIntAttribute(out, ATTR_UID, uid);
+            } else {
+                writeStringAttribute(out, ATTR_XML_UTILS_NAME, getPackageForUid(uid));
+                writeIntAttribute(out, ATTR_USER_ID, UserHandle.getUserId(uid));
+            }
             out.endTag(null, TAG_REVOKED_RESTRICT_BACKGROUND);
         }
 
@@ -2602,6 +2614,44 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {
         out.endDocument();
     }
 
+    @Override
+    public byte[] getBackupPayload() {
+        enforceSystemCaller();
+        if (LOGD) Slog.d(TAG, ""getBackupPayload"");
+        final ByteArrayOutputStream baos = new ByteArrayOutputStream();
+        try {
+            writePolicyXml(baos, true);
+            return baos.toByteArray();
+        } catch (IOException e) {
+            Slog.w(TAG, ""getBackupPayload: error writing payload"", e);
+        }
+        return null;
+    }
+
+    @Override
+    public void applyRestore(byte[] payload) {
+        enforceSystemCaller();
+        if (LOGD) Slog.d(TAG, ""applyRestore payload=""
+                + (payload != null ? new String(payload, StandardCharsets.UTF_8) : null));
+        if (payload == null) {
+            Slog.w(TAG, ""applyRestore: no payload to restore"");
+            return;
+        }
+
+        // clear any existing policy and read from disk
+        mNetworkPolicy.clear();
+        mSubscriptionPlans.clear();
+        mSubscriptionPlansOwner.clear();
+        mUidPolicy.clear();
+
+        final ByteArrayInputStream bais = new ByteArrayInputStream(payload);
+        try {
+            readPolicyXml(bais, true);
+        } catch (IOException | XmlPullParserException e) {
+            Slog.w(TAG, ""applyRestore: error reading payload"", e);
+        }
+    }
+
     @Override
     public void setUidPolicy(int uid, int policy) {
         mContext.enforceCallingOrSelfPermission(MANAGE_NETWORK_POLICY, TAG);
@@ -2810,6 +2860,12 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {
         }
     }
 
+    private void enforceSystemCaller() {
+        if (Binder.getCallingUid() != android.os.Process.SYSTEM_UID) {
+            throw new SecurityException(""Caller must be system"");
+        }
+    }
+
     @Override
     public void registerListener(INetworkPolicyListener listener) {
         // TODO: Remove CONNECTIVITY_INTERNAL and the *AnyPermissionOf methods above after all apps
@@ -5502,6 +5558,19 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {
         }
     }
 
+    private int readUidAttribute(XmlPullParser in, boolean forRestore) throws IOException {
+        if (!forRestore) {
+            return readIntAttribute(in, ATTR_UID);
+        } else {
+            return getUidForPackage(readStringAttribute(in, ATTR_XML_UTILS_NAME),
+                    readIntAttribute(in, ATTR_USER_ID));
+        }
+    }
+
+    private String getPackageForUid(int uid) {
+        return mContext.getPackageManager().getPackagesForUid(uid)[0];
+    }
+
     private int getUidForPackage(String packageName, int userId) {
         try {
             return mContext.getPackageManager().getPackageUidAsUser(packageName,
",80,11,"NetworkPolicyManagerService::writePolicyXml, NetworkPolicyManagerService::writePolicyAL, NetworkPolicyManagerService::readPolicyXml, NetworkPolicyManagerService::applyRestore, NetworkPolicyManagerService::readPolicyXml, NetworkPolicyManagerService::getPackageForUid, NetworkPolicyManagerService::enforceSystemCaller, NetworkPolicyManagerService::writePolicyXml, NetworkPolicyManagerService::readUidAttribute, NetworkPolicyManagerService::readPolicyAL, NetworkPolicyManagerService::getBackupPayload"
141,d2ecc3d161a609cc705413ced4bd34cb0241fe14,Notifier.java,"@@ -816,6 +816,10 @@ public class Notifier {
         final String soundPath = Settings.Global.getString(mContext.getContentResolver(),
                 wireless ? Settings.Global.WIRELESS_CHARGING_STARTED_SOUND
                         : Settings.Global.CHARGING_STARTED_SOUND);
+        if (""silent"".equals(soundPath)) {
+            return;
+        }
+
         final Uri soundUri = Uri.parse(""file://"" + soundPath);
         if (soundUri != null) {
             final Ringtone sfx = RingtoneManager.getRingtone(mContext, soundUri);
",4,0,Notifier::playChargingStartedFeedback
142,861cd0dd435817857bfd9e2f797954f4452a2193,Notifier.java,"@@ -120,6 +120,7 @@ public class Notifier {
     private final SuspendBlocker mSuspendBlocker;
     private final WindowManagerPolicy mPolicy;
     private final ActivityManagerInternal mActivityManagerInternal;
+    private final AudioManager mAudioManager;
     private final InputManagerInternal mInputManagerInternal;
     private final InputMethodManagerInternal mInputMethodManagerInternal;
     @Nullable private final StatusBarManagerInternal mStatusBarManagerInternal;
@@ -172,6 +173,7 @@ public class Notifier {
         mSuspendBlocker = suspendBlocker;
         mPolicy = policy;
         mActivityManagerInternal = LocalServices.getService(ActivityManagerInternal.class);
+        mAudioManager = mContext.getSystemService(AudioManager.class);
         mInputManagerInternal = LocalServices.getService(InputManagerInternal.class);
         mInputMethodManagerInternal = LocalServices.getService(InputMethodManagerInternal.class);
         mStatusBarManagerInternal = LocalServices.getService(StatusBarManagerInternal.class);
@@ -856,7 +858,9 @@ public class Notifier {
         final boolean dndOff = Settings.Global.getInt(mContext.getContentResolver(),
                 Settings.Global.ZEN_MODE, Settings.Global.ZEN_MODE_IMPORTANT_INTERRUPTIONS)
                 == Settings.Global.ZEN_MODE_OFF;
-        return enabled && dndOff;
+        final boolean silentMode = mAudioManager.getRingerModeInternal()
+                == AudioManager.RINGER_MODE_SILENT;
+        return enabled && dndOff && !silentMode;
     }
 
     private final class NotifierHandler extends Handler {
",5,1,"Notifier::Notifier, Notifier::isChargingFeedbackEnabled"
143,5634493a5a3aab4d11bb063bbedc71e1e5d60a99,Notifier.java,"@@ -822,8 +822,11 @@ public class Notifier {
             return;
         }
 
-        final Uri soundUri = Uri.parse(""file://"" + soundPath);
+        Uri soundUri = Uri.parse(soundPath);
         if (soundUri != null) {
+            if (!soundUri.isAbsolute()) {
+                soundUri = Uri.parse(""file://"" + soundPath);
+            }
             final Ringtone sfx = RingtoneManager.getRingtone(mContext, soundUri);
             if (sfx != null) {
                 sfx.setStreamType(AudioManager.STREAM_SYSTEM);
",4,1,Notifier::playChargingStartedFeedback
144,e85caa8d6699d3f54670deaa341a0e641c97e697,Notifier.java,"@@ -94,8 +94,10 @@ public class Notifier {
     private static final int MSG_USER_ACTIVITY = 1;
     private static final int MSG_BROADCAST = 2;
     private static final int MSG_WIRELESS_CHARGING_STARTED = 3;
+    private static final int MSG_WIRELESS_CHARGING_INTERRUPTED = 4;
     private static final int MSG_PROFILE_TIMED_OUT = 5;
     private static final int MSG_WIRED_CHARGING_STARTED = 6;
+    private static final int MSG_WIRED_CHARGING_DISCONNECTED = 7;
 
     private static final long[] CHARGING_VIBRATION_TIME = {
             40, 40, 40, 40, 40, 40, 40, 40, 40, // ramp-up sampling rate = 40ms
@@ -647,6 +649,21 @@ public class Notifier {
         mHandler.sendMessage(msg);
     }
 
+    /**
+     * Called when wireless charging has been interrupted - to provide user feedback (sound only).
+     */
+    public void onWirelessChargingInterrupted(@UserIdInt int userId) {
+        if (DEBUG) {
+            Slog.d(TAG, ""onWirelessChargingInterrupted"");
+        }
+
+        mSuspendBlocker.acquire();
+        Message msg = mHandler.obtainMessage(MSG_WIRELESS_CHARGING_INTERRUPTED);
+        msg.setAsynchronous(true);
+        msg.arg1 = userId;
+        mHandler.sendMessage(msg);
+    }
+
     /**
      * Called when wired charging has started - to provide user feedback
      */
@@ -662,6 +679,21 @@ public class Notifier {
         mHandler.sendMessage(msg);
     }
 
+    /**
+     * Called when wired charging has been disconnected - to provide user feedback
+     */
+    public void onWiredChargingDisconnected(@UserIdInt int userId) {
+        if (DEBUG) {
+            Slog.d(TAG, ""onWiredChargingDisconnected"");
+        }
+
+        mSuspendBlocker.acquire();
+        Message msg = mHandler.obtainMessage(MSG_WIRED_CHARGING_DISCONNECTED);
+        msg.setAsynchronous(true);
+        msg.arg1 = userId;
+        mHandler.sendMessage(msg);
+    }
+
     /**
      * Dumps data for bugreports.
      *
@@ -851,6 +883,11 @@ public class Notifier {
         mSuspendBlocker.release();
     }
 
+    private void showChargingStopped(@UserIdInt int userId, boolean wireless) {
+        playChargingStartedFeedback(userId, wireless);
+        mSuspendBlocker.release();
+    }
+
     private void lockProfile(@UserIdInt int userId) {
         mTrustManager.setDeviceLockedForUser(userId, true /*locked*/);
     }
@@ -880,12 +917,18 @@ public class Notifier {
                 case MSG_BROADCAST:
                     sendNextBroadcast();
                     break;
+                case MSG_WIRELESS_CHARGING_INTERRUPTED:
+                    showChargingStopped(msg.arg1, true /* wireless */);
+                    break;
                 case MSG_WIRELESS_CHARGING_STARTED:
                     showWirelessChargingStarted(msg.arg1, msg.arg2);
                     break;
                 case MSG_PROFILE_TIMED_OUT:
                     lockProfile(msg.arg1);
                     break;
+                case MSG_WIRED_CHARGING_DISCONNECTED:
+                    showChargingStopped(msg.arg1, false /* wireless */);
+                    break;
                 case MSG_WIRED_CHARGING_STARTED:
                     showWiredChargingStarted(msg.arg1);
                     break;
",43,0,"Notifier::onWirelessChargingInterrupted, Notifier::onWiredChargingDisconnected, Notifier::showChargingStopped, Notifier::NotifierHandler::handleMessage"
145,e85caa8d6699d3f54670deaa341a0e641c97e697,PowerManagerService.java,"@@ -2164,6 +2164,12 @@ public final class PowerManagerService extends SystemService
                     if (mIsPowered && !BatteryManager.isPlugWired(oldPlugType)
                             && BatteryManager.isPlugWired(mPlugType)) {
                         mNotifier.onWiredChargingStarted(mUserId);
+                    } else if (wasPowered && !mIsPowered) {
+                        if (oldPlugType == BatteryManager.BATTERY_PLUGGED_WIRELESS) {
+                            mNotifier.onWirelessChargingInterrupted(mUserId);
+                        } else {
+                            mNotifier.onWiredChargingDisconnected(mUserId);
+                        }
                     } else if (dockedOnWirelessCharger) {
                         mNotifier.onWirelessChargingStarted(mBatteryLevel, mUserId);
                     }
",6,0,PowerManagerService::updateIsPoweredLocked
146,4328a0c5c11b7b6c7bfe27d67cc3b7062965f6b0,RotationPolicy.java,"@@ -168,8 +168,8 @@ public final class RotationPolicy {
     }
 
     private static boolean isCurrentRotationAllowed(Context context) {
-        int userRotationAngles = Settings.System.getInt(context.getContentResolver(),
-                Settings.System.ACCELEROMETER_ROTATION_ANGLES, -1);
+        int userRotationAngles = Settings.System.getIntForUser(context.getContentResolver(),
+                Settings.System.ACCELEROMETER_ROTATION_ANGLES, -1, UserHandle.USER_CURRENT);
         boolean allowAllRotations = context.getResources().getBoolean(
                 com.android.internal.R.bool.config_allowAllRotations);
         final IWindowManager wm = WindowManagerGlobal.getWindowManagerService();
",2,2,RotationPolicy::isCurrentRotationAllowed
147,4328a0c5c11b7b6c7bfe27d67cc3b7062965f6b0,DisplayRotation.java,"@@ -1410,8 +1410,8 @@ public class DisplayRotation {
                 shouldUpdateRotation = true;
             }
 
-            final int userRotationAngles = Settings.System.getInt(resolver,
-                    Settings.System.ACCELEROMETER_ROTATION_ANGLES, -1);
+            final int userRotationAngles = Settings.System.getIntForUser(resolver,
+                    Settings.System.ACCELEROMETER_ROTATION_ANGLES, -1, UserHandle.USER_CURRENT);
             if (mUserRotationAngles != userRotationAngles) {
                 mUserRotationAngles = userRotationAngles;
                 shouldUpdateRotation = true;
",2,2,DisplayRotation::updateSettings
148,dc0b1cab5d7d79aa500ace0d618ed523cdfbc41a,KeyguardPINView.java,"@@ -17,6 +17,7 @@
 package com.android.keyguard;
 
 import android.content.Context;
+import android.os.UserHandle;
 import android.util.AttributeSet;
 import android.view.View;
 import android.view.ViewGroup;
@@ -132,8 +133,9 @@ public class KeyguardPINView extends KeyguardPinBasedInputView {
             });
         }
 
-        mScramblePin = LineageSettings.System.getInt(getContext().getContentResolver(),
-                LineageSettings.System.LOCKSCREEN_PIN_SCRAMBLE_LAYOUT, 0) == 1;
+        mScramblePin = LineageSettings.System.getIntForUser(getContext().getContentResolver(),
+                LineageSettings.System.LOCKSCREEN_PIN_SCRAMBLE_LAYOUT, 0,
+                UserHandle.USER_CURRENT) == 1;
         if (mScramblePin) {
             Collections.shuffle(sNumbers);
             // get all children who are NumPadKey's
",4,2,KeyguardPINView::onFinishInflate
149,dc0b1cab5d7d79aa500ace0d618ed523cdfbc41a,NumPadKey.java,"@@ -20,6 +20,7 @@ import android.content.Context;
 import android.content.res.TypedArray;
 import android.os.PowerManager;
 import android.os.SystemClock;
+import android.os.UserHandle;
 import android.util.AttributeSet;
 import android.view.HapticFeedbackConstants;
 import android.view.LayoutInflater;
@@ -115,8 +116,10 @@ public class NumPadKey extends ViewGroup {
     }
 
     private void updateText() {
-        boolean scramblePin = (LineageSettings.System.getInt(getContext().getContentResolver(),
-                LineageSettings.System.LOCKSCREEN_PIN_SCRAMBLE_LAYOUT, 0) == 1);
+        boolean scramblePin = LineageSettings.System.getIntForUser(
+                getContext().getContentResolver(),
+                LineageSettings.System.LOCKSCREEN_PIN_SCRAMBLE_LAYOUT, 0,
+                UserHandle.USER_CURRENT) == 1;
         if (mDigit >= 0) {
             mDigitText.setText(Integer.toString(mDigit));
             if (sKlondike == null) {
",5,2,NumPadKey::updateText
150,e68894cd604b9c2ac01a3dce16c97b1816b1c006,BrightnessController.java,"@@ -46,6 +46,7 @@ import android.widget.ImageView;
 import com.android.internal.BrightnessSynchronizer;
 import com.android.internal.logging.MetricsLogger;
 import com.android.internal.logging.nano.MetricsProto.MetricsEvent;
+import com.android.settingslib.RestrictedLockUtils;
 import com.android.settingslib.RestrictedLockUtilsInternal;
 import com.android.systemui.Dependency;
 import com.android.systemui.broadcast.BroadcastDispatcher;
@@ -62,6 +63,7 @@ public class BrightnessController implements ToggleSlider.Listener {
     private static final int MSG_ATTACH_LISTENER = 3;
     private static final int MSG_DETACH_LISTENER = 4;
     private static final int MSG_VR_MODE_CHANGED = 5;
+    private static final int MSG_BRIGHTNESS_RESTRICTION = 6;
 
     private static final Uri BRIGHTNESS_MODE_URI =
             Settings.System.getUriFor(Settings.System.SCREEN_BRIGHTNESS_MODE);
@@ -292,6 +294,10 @@ public class BrightnessController implements ToggleSlider.Listener {
                     case MSG_VR_MODE_CHANGED:
                         updateVrMode(msg.arg1 != 0);
                         break;
+                    case MSG_BRIGHTNESS_RESTRICTION:
+                        ((ToggleSliderView)mControl).setEnforcedAdmin(
+                                (RestrictedLockUtils.EnforcedAdmin) msg.obj);
+                        break;
                     default:
                         super.handleMessage(msg);
                 }
@@ -426,15 +432,10 @@ public class BrightnessController implements ToggleSlider.Listener {
     }
 
     public void checkRestrictionAndSetEnabled() {
-        mBackgroundHandler.post(new Runnable() {
-            @Override
-            public void run() {
-                ((ToggleSliderView)mControl).setEnforcedAdmin(
-                        RestrictedLockUtilsInternal.checkIfRestrictionEnforced(mContext,
-                                UserManager.DISALLOW_CONFIG_BRIGHTNESS,
-                                mUserTracker.getCurrentUserId()));
-            }
-        });
+        mHandler.obtainMessage(MSG_BRIGHTNESS_RESTRICTION,
+                RestrictedLockUtilsInternal.checkIfRestrictionEnforced(mContext,
+                        UserManager.DISALLOW_CONFIG_BRIGHTNESS,
+                        mUserTracker.getCurrentUserId())).sendToTarget();
     }
 
     private void setMode(int mode) {
",10,9,"BrightnessController::checkRestrictionAndSetEnabled, BrightnessController::Handler"
151,898ecaa0899aac72cd8e99a201a0ff6c06224dcd,TextServicesManagerService.java,"@@ -43,6 +43,8 @@ import android.service.textservice.SpellCheckerService;
 import android.text.TextUtils;
 import android.util.Slog;
 import android.util.SparseArray;
+import android.view.inputmethod.InputMethodManager;
+import android.view.inputmethod.InputMethodSubtype;
 import android.view.textservice.SpellCheckerInfo;
 import android.view.textservice.SpellCheckerSubtype;
 
@@ -543,19 +545,37 @@ public class TextServicesManagerService extends ITextServicesManager.Stub {
 
         // subtypeHashCode == 0 means spell checker language settings is ""auto""
 
-        if (systemLocale == null) {
+        Locale candidateLocale = null;
+        final InputMethodManager imm = mContext.getSystemService(InputMethodManager.class);
+        if (imm != null) {
+            final InputMethodSubtype currentInputMethodSubtype =
+                    imm.getCurrentInputMethodSubtype();
+            if (currentInputMethodSubtype != null) {
+                final String localeString = currentInputMethodSubtype.getLocale();
+                if (!TextUtils.isEmpty(localeString)) {
+                    // 1. Use keyboard locale if available in the spell checker
+                    candidateLocale = SubtypeLocaleUtils.constructLocaleFromString(localeString);
+                }
+            }
+        }
+        if (candidateLocale == null) {
+            // 2. Use System locale if available in the spell checker
+            candidateLocale = systemLocale;
+        }
+
+        if (candidateLocale == null) {
             return null;
         }
         SpellCheckerSubtype firstLanguageMatchingSubtype = null;
         for (int i = 0; i < sci.getSubtypeCount(); ++i) {
             final SpellCheckerSubtype scs = sci.getSubtypeAt(i);
             final Locale scsLocale = scs.getLocaleObject();
-            if (Objects.equals(scsLocale, systemLocale)) {
+            if (Objects.equals(scsLocale, candidateLocale)) {
                 // Exact match wins.
                 return scs;
             }
             if (firstLanguageMatchingSubtype == null && scsLocale != null
-                    && TextUtils.equals(systemLocale.getLanguage(), scsLocale.getLanguage())) {
+                    && TextUtils.equals(candidateLocale.getLanguage(), scsLocale.getLanguage())) {
                 // Remember as a fall back candidate
                 firstLanguageMatchingSubtype = scs;
             }
",23,3,TextServicesManagerService::getCurrentSpellCheckerSubtype
152,703986fd5b7e6549cdaff662c06a7ae526c46ddb,Clock.java,"@@ -16,7 +16,9 @@
 
 package com.android.systemui.statusbar.policy;
 
+import android.app.ActivityManager;
 import android.app.StatusBarManager;
+import android.app.WindowConfiguration;
 import android.content.BroadcastReceiver;
 import android.content.Context;
 import android.content.Intent;
@@ -47,6 +49,8 @@ import com.android.systemui.broadcast.BroadcastDispatcher;
 import com.android.systemui.plugins.DarkIconDispatcher;
 import com.android.systemui.plugins.DarkIconDispatcher.DarkReceiver;
 import com.android.systemui.settings.CurrentUserTracker;
+import com.android.systemui.shared.system.ActivityManagerWrapper;
+import com.android.systemui.shared.system.TaskStackChangeListener;
 import com.android.systemui.statusbar.CommandQueue;
 import com.android.systemui.statusbar.policy.ConfigurationController.ConfigurationListener;
 import com.android.systemui.tuner.TunerService;
@@ -70,6 +74,8 @@ public class Clock extends TextView implements DemoMode, Tunable, CommandQueue.C
     public static final String CLOCK_SECONDS = ""clock_seconds"";
     private static final String CLOCK_STYLE =
             ""lineagesystem:"" + LineageSettings.System.STATUS_BAR_AM_PM;
+    private static final String CLOCK_AUTO_HIDE =
+            ""lineagesystem:"" + LineageSettings.System.STATUS_BAR_CLOCK_AUTO_HIDE;
     private static final String CLOCK_SUPER_PARCELABLE = ""clock_super_parcelable"";
     private static final String CURRENT_USER_ID = ""current_user_id"";
     private static final String VISIBLE_BY_POLICY = ""visible_by_policy"";
@@ -83,6 +89,8 @@ public class Clock extends TextView implements DemoMode, Tunable, CommandQueue.C
 
     private boolean mClockVisibleByPolicy = true;
     private boolean mClockVisibleByUser = getVisibility() == View.VISIBLE;
+    private boolean mClockAutoHide = false;
+    private TaskStackListenerImpl mTaskStackListener = null;
 
     private boolean mAttached;
     private boolean mScreenReceiverRegistered;
@@ -194,7 +202,8 @@ public class Clock extends TextView implements DemoMode, Tunable, CommandQueue.C
             // The receiver will return immediately if the view does not have a Handler yet.
             mBroadcastDispatcher.registerReceiverWithHandler(mIntentReceiver, filter,
                     Dependency.get(Dependency.TIME_TICK_HANDLER), UserHandle.ALL);
-            Dependency.get(TunerService.class).addTunable(this, CLOCK_SECONDS, CLOCK_STYLE);
+            Dependency.get(TunerService.class).addTunable(this,
+                    CLOCK_SECONDS, CLOCK_STYLE, CLOCK_AUTO_HIDE);
             mCommandQueue.addCallback(this);
             if (mShowDark) {
                 Dependency.get(DarkIconDispatcher.class).addDarkReceiver(this);
@@ -233,6 +242,17 @@ public class Clock extends TextView implements DemoMode, Tunable, CommandQueue.C
                 Dependency.get(DarkIconDispatcher.class).removeDarkReceiver(this);
             }
             mCurrentUserTracker.stopTracking();
+            handleTaskStackListener(false);
+        }
+    }
+
+    private void handleTaskStackListener(boolean register) {
+        if (register && mTaskStackListener == null) {
+            mTaskStackListener = new TaskStackListenerImpl();
+            ActivityManagerWrapper.getInstance().registerTaskStackListener(mTaskStackListener);
+        } else if (!register && mTaskStackListener != null) {
+            ActivityManagerWrapper.getInstance().unregisterTaskStackListener(mTaskStackListener);
+            mTaskStackListener = null;
         }
     }
 
@@ -287,7 +307,7 @@ public class Clock extends TextView implements DemoMode, Tunable, CommandQueue.C
     }
 
     public boolean shouldBeVisible() {
-        return mClockVisibleByPolicy && mClockVisibleByUser;
+        return !mClockAutoHide && mClockVisibleByPolicy && mClockVisibleByUser;
     }
 
     private void updateClockVisibility() {
@@ -312,6 +332,8 @@ public class Clock extends TextView implements DemoMode, Tunable, CommandQueue.C
             mAmPmStyle = TunerService.parseInteger(newValue, AM_PM_STYLE_GONE);
             mClockFormatString = """"; // force refresh
             updateClock();
+        } else if (CLOCK_AUTO_HIDE.equals(key)) {
+            handleTaskStackListener(TunerService.parseIntegerSwitch(newValue, false));
         }
     }
 
@@ -390,6 +412,19 @@ public class Clock extends TextView implements DemoMode, Tunable, CommandQueue.C
         }
     }
 
+    private void updateShowClock() {
+        ActivityManager.RunningTaskInfo runningTask =
+                ActivityManagerWrapper.getInstance().getRunningTask();
+        final int activityType = runningTask != null
+                ? runningTask.configuration.windowConfiguration.getActivityType()
+                : WindowConfiguration.ACTIVITY_TYPE_UNDEFINED;
+        final boolean clockAutoHide = activityType == WindowConfiguration.ACTIVITY_TYPE_HOME;
+        if (mClockAutoHide != clockAutoHide) {
+            mClockAutoHide = clockAutoHide;
+            updateClockVisibility();
+        }
+    }
+
     private final CharSequence getSmallTime() {
         Context context = getContext();
         boolean is24 = DateFormat.is24HourFormat(context, mCurrentUserId);
@@ -521,5 +556,22 @@ public class Clock extends TextView implements DemoMode, Tunable, CommandQueue.C
             mSecondsHandler.postAtTime(this, SystemClock.uptimeMillis() / 1000 * 1000 + 1000);
         }
     };
+
+    private class TaskStackListenerImpl extends TaskStackChangeListener {
+        @Override
+        public void onTaskStackChanged() {
+            updateShowClock();
+        }
+
+        @Override
+        public void onTaskRemoved(int taskId) {
+            updateShowClock();
+        }
+
+        @Override
+        public void onTaskMovedToFront(int taskId) {
+            updateShowClock();
+        }
+    }
 }
 
",54,2,"Clock::onAttachedToWindow, Clock::TaskStackListenerImpl::onTaskStackChanged, Clock::updateShowClock, Clock::shouldBeVisible, Clock::onDetachedFromWindow, Clock::TaskStackListenerImpl::onTaskRemoved, Clock::onTuningChanged, Clock::TaskStackListenerImpl::onTaskMovedToFront, Clock::handleTaskStackListener"
153,c4214cf241a3bf3fc7d0ea0a5360964effcaa7db,NetworkPolicyManagerShellCommand.java,"@@ -19,6 +19,9 @@ package com.android.server.net;
 import static android.net.NetworkPolicyManager.POLICY_ALLOW_METERED_BACKGROUND;
 import static android.net.NetworkPolicyManager.POLICY_NONE;
 import static android.net.NetworkPolicyManager.POLICY_REJECT_METERED_BACKGROUND;
+import static android.net.NetworkPolicyManager.POLICY_REJECT_WIFI;
+import static android.net.NetworkPolicyManager.POLICY_REJECT_CELLULAR;
+import static android.net.NetworkPolicyManager.POLICY_REJECT_VPN;
 
 import android.content.Context;
 import android.net.NetworkPolicyManager;
@@ -83,6 +86,12 @@ class NetworkPolicyManagerShellCommand extends ShellCommand {
         pw.println(""    Adds a UID to the whitelist for restrict background usage."");
         pw.println(""  add restrict-background-blacklist UID"");
         pw.println(""    Adds a UID to the blacklist for restrict background usage."");
+        pw.println(""  add restrict-wifi-data-blacklist UID"");
+        pw.println(""    Adds a UID to the blacklist for restrict Wi-Fi data usage."");
+        pw.println(""  add restrict-mobile-data-blacklist UID"");
+        pw.println(""    Adds a UID to the blacklist for restrict Mobile data usage."");
+        pw.println(""  add restrict-vpn-data-blacklist UID"");
+        pw.println(""    Adds a UID to the blacklist for restrict VPN data usage."");
         pw.println(""  add app-idle-whitelist UID"");
         pw.println(""    Adds a UID to the temporary app idle whitelist."");
         pw.println(""  get restrict-background"");
@@ -95,10 +104,22 @@ class NetworkPolicyManagerShellCommand extends ShellCommand {
         pw.println(""    Lists UIDs that are whitelisted for restrict background usage."");
         pw.println(""  list restrict-background-blacklist"");
         pw.println(""    Lists UIDs that are blacklisted for restrict background usage."");
+        pw.println(""  list restrict-wifi-data-blacklist"");
+        pw.println(""    Lists UIDs that are blacklisted for restrict Wi-Fi data usage."");
+        pw.println(""  list restrict-mobile-data-blacklist"");
+        pw.println(""    Lists UIDs that are blacklisted for restrict Mobile data usage."");
+        pw.println(""  list restrict-vpn-data-blacklist"");
+        pw.println(""    Lists UIDs that are blacklisted for restrict VPN data usage."");
         pw.println(""  remove restrict-background-whitelist UID"");
         pw.println(""    Removes a UID from the whitelist for restrict background usage."");
         pw.println(""  remove restrict-background-blacklist UID"");
         pw.println(""    Removes a UID from the blacklist for restrict background usage."");
+        pw.println(""  remove restrict-wifi-data-blacklist UID"");
+        pw.println(""    Removes a UID from the blacklist for restrict Wi-Fi data usage."");
+        pw.println(""  remove restrict-mobile-data-blacklist UID"");
+        pw.println(""    Removes a UID from the blacklist for restrict Mobile data usage."");
+        pw.println(""  remove restrict-vpn-data-blacklist UID"");
+        pw.println(""    Removes a UID from the blacklist for restrict VPN data usage."");
         pw.println(""  remove app-idle-whitelist UID"");
         pw.println(""    Removes a UID from the temporary app idle whitelist."");
         pw.println(""  set metered-network ID [undefined|true|false]"");
@@ -159,6 +180,12 @@ class NetworkPolicyManagerShellCommand extends ShellCommand {
                 return listRestrictBackgroundWhitelist();
             case ""restrict-background-blacklist"":
                 return listRestrictBackgroundBlacklist();
+            case ""restrict-wifi-data-blacklist"":
+                return listRestrictWiFiDataBlacklist();
+            case ""restrict-mobile-data-blacklist"":
+                return listRestrictCellularDataBlacklist();
+            case ""restrict-vpn-data-blacklist"":
+                return listRestrictVpnDataBlacklist();
         }
         pw.println(""Error: unknown list type '"" + type + ""'"");
         return -1;
@@ -176,6 +203,12 @@ class NetworkPolicyManagerShellCommand extends ShellCommand {
                 return addRestrictBackgroundWhitelist();
             case ""restrict-background-blacklist"":
                 return addRestrictBackgroundBlacklist();
+            case ""restrict-wifi-data-blacklist"":
+                return addRestrictWiFiDataBlacklist();
+            case ""restrict-mobile-data-blacklist"":
+                return addRestrictCellularDataBlacklist();
+            case ""restrict-vpn-data-blacklist"":
+                return addRestrictVpnDataBlacklist();
             case ""app-idle-whitelist"":
                 return addAppIdleWhitelist();
         }
@@ -195,6 +228,12 @@ class NetworkPolicyManagerShellCommand extends ShellCommand {
                 return removeRestrictBackgroundWhitelist();
             case ""restrict-background-blacklist"":
                 return removeRestrictBackgroundBlacklist();
+            case ""restrict-wifi-data-blacklist"":
+                return removeRestrictWiFiDataBlacklist();
+            case ""restrict-mobile-data-blacklist"":
+                return removeRestrictCellularDataBlacklist();
+            case ""restrict-vpn-data-blacklist"":
+                return removeRestrictVpnDataBlacklist();
             case ""app-idle-whitelist"":
                 return removeAppIdleWhitelist();
         }
@@ -249,6 +288,21 @@ class NetworkPolicyManagerShellCommand extends ShellCommand {
                 POLICY_REJECT_METERED_BACKGROUND);
     }
 
+    private int listRestrictWiFiDataBlacklist() throws RemoteException {
+        return listUidPolicies(""Restrict Wi-Fi data blacklisted UIDs"",
+                POLICY_REJECT_WIFI);
+    }
+
+    private int listRestrictCellularDataBlacklist() throws RemoteException {
+        return listUidPolicies(""Restrict Mobile data blacklisted UIDs"",
+                POLICY_REJECT_CELLULAR);
+    }
+
+    private int listRestrictVpnDataBlacklist() throws RemoteException {
+        return listUidPolicies(""Restrict VPN data blacklisted UIDs"",
+                POLICY_REJECT_VPN);
+    }
+
     private int listAppIdleWhitelist() throws RemoteException {
         final PrintWriter pw = getOutPrintWriter();
         final int[] uids = mInterface.getAppIdleWhitelist();
@@ -314,10 +368,34 @@ class NetworkPolicyManagerShellCommand extends ShellCommand {
         return setUidPolicy(POLICY_REJECT_METERED_BACKGROUND);
     }
 
+    private int addRestrictWiFiDataBlacklist() throws RemoteException {
+        return setUidPolicy(POLICY_REJECT_WIFI);
+    }
+
+    private int addRestrictCellularDataBlacklist() throws RemoteException {
+        return setUidPolicy(POLICY_REJECT_CELLULAR);
+    }
+
+    private int addRestrictVpnDataBlacklist() throws RemoteException {
+        return setUidPolicy(POLICY_REJECT_VPN);
+    }
+
     private int removeRestrictBackgroundBlacklist() throws RemoteException {
         return resetUidPolicy(""not blacklisted"", POLICY_REJECT_METERED_BACKGROUND);
     }
 
+    private int removeRestrictWiFiDataBlacklist() throws RemoteException {
+        return resetUidPolicy(""not blacklisted"", POLICY_REJECT_WIFI);
+    }
+
+    private int removeRestrictCellularDataBlacklist() throws RemoteException {
+        return resetUidPolicy(""not blacklisted"", POLICY_REJECT_CELLULAR);
+    }
+
+    private int removeRestrictVpnDataBlacklist() throws RemoteException {
+        return resetUidPolicy(""not blacklisted"", POLICY_REJECT_VPN);
+    }
+
     private int setAppIdleWhitelist(boolean isWhitelisted) {
         final int uid = getUidFromNextArg();
         if (uid < 0) {
",78,0,"NetworkPolicyManagerShellCommand::removeRestrictCellularDataBlacklist, NetworkPolicyManagerShellCommand::removeRestrictVpnDataBlacklist, NetworkPolicyManagerShellCommand::listRestrictCellularDataBlacklist, NetworkPolicyManagerShellCommand::onHelp, NetworkPolicyManagerShellCommand::runList, NetworkPolicyManagerShellCommand::listRestrictVpnDataBlacklist, NetworkPolicyManagerShellCommand::addRestrictVpnDataBlacklist, NetworkPolicyManagerShellCommand::addRestrictCellularDataBlacklist, NetworkPolicyManagerShellCommand::removeRestrictWiFiDataBlacklist, NetworkPolicyManagerShellCommand::runAdd, NetworkPolicyManagerShellCommand::runRemove, NetworkPolicyManagerShellCommand::listRestrictWiFiDataBlacklist, NetworkPolicyManagerShellCommand::addRestrictWiFiDataBlacklist"
154,98f3c37439e30ed5e22f94340766821a31d8bdd9,GlobalActionsDialog.java,"@@ -1002,7 +1002,9 @@ public class GlobalActionsDialog implements DialogInterface.OnDismissListener,
     @VisibleForTesting
     final class RestartAction extends SinglePressAction implements LongPressAction {
         private RestartAction() {
-            super(R.drawable.ic_restart, R.string.global_action_restart);
+            super(R.drawable.ic_restart, shouldShowRestartSubmenu()
+                    ? com.android.systemui.R.string.global_action_restart_more
+                    : R.string.global_action_restart);
         }
 
         @Override
",3,1,GlobalActionsDialog::RestartAction::RestartAction
155,0d7e68d8748745327610a39be8d57a3256ccb15e,NetworkPolicyManagerShellCommand.java,"@@ -18,6 +18,7 @@ package com.android.server.net;
 
 import static android.net.NetworkPolicyManager.POLICY_ALLOW_METERED_BACKGROUND;
 import static android.net.NetworkPolicyManager.POLICY_NONE;
+import static android.net.NetworkPolicyManager.POLICY_REJECT_ALL;
 import static android.net.NetworkPolicyManager.POLICY_REJECT_METERED_BACKGROUND;
 import static android.net.NetworkPolicyManager.POLICY_REJECT_WIFI;
 import static android.net.NetworkPolicyManager.POLICY_REJECT_CELLULAR;
@@ -86,6 +87,8 @@ class NetworkPolicyManagerShellCommand extends ShellCommand {
         pw.println(""    Adds a UID to the whitelist for restrict background usage."");
         pw.println(""  add restrict-background-blacklist UID"");
         pw.println(""    Adds a UID to the blacklist for restrict background usage."");
+        pw.println(""  add restrict-network-usage-blacklist UID"");
+        pw.println(""    Adds a UID to the blacklist for restrict network usage."");
         pw.println(""  add restrict-wifi-data-blacklist UID"");
         pw.println(""    Adds a UID to the blacklist for restrict Wi-Fi data usage."");
         pw.println(""  add restrict-mobile-data-blacklist UID"");
@@ -104,6 +107,8 @@ class NetworkPolicyManagerShellCommand extends ShellCommand {
         pw.println(""    Lists UIDs that are whitelisted for restrict background usage."");
         pw.println(""  list restrict-background-blacklist"");
         pw.println(""    Lists UIDs that are blacklisted for restrict background usage."");
+        pw.println(""  list restrict-network-usage-blacklist"");
+        pw.println(""    Lists UIDs that are blacklisted for restrict network usage."");
         pw.println(""  list restrict-wifi-data-blacklist"");
         pw.println(""    Lists UIDs that are blacklisted for restrict Wi-Fi data usage."");
         pw.println(""  list restrict-mobile-data-blacklist"");
@@ -114,6 +119,8 @@ class NetworkPolicyManagerShellCommand extends ShellCommand {
         pw.println(""    Removes a UID from the whitelist for restrict background usage."");
         pw.println(""  remove restrict-background-blacklist UID"");
         pw.println(""    Removes a UID from the blacklist for restrict background usage."");
+        pw.println(""  remove restrict-network-usage-blacklist UID"");
+        pw.println(""    Removes a UID from the blacklist for restrict network usage."");
         pw.println(""  remove restrict-wifi-data-blacklist UID"");
         pw.println(""    Removes a UID from the blacklist for restrict Wi-Fi data usage."");
         pw.println(""  remove restrict-mobile-data-blacklist UID"");
@@ -180,6 +187,8 @@ class NetworkPolicyManagerShellCommand extends ShellCommand {
                 return listRestrictBackgroundWhitelist();
             case ""restrict-background-blacklist"":
                 return listRestrictBackgroundBlacklist();
+            case ""restrict-network-usage-blacklist"":
+                return listRestrictNetworkUsageBlacklist();
             case ""restrict-wifi-data-blacklist"":
                 return listRestrictWiFiDataBlacklist();
             case ""restrict-mobile-data-blacklist"":
@@ -203,6 +212,8 @@ class NetworkPolicyManagerShellCommand extends ShellCommand {
                 return addRestrictBackgroundWhitelist();
             case ""restrict-background-blacklist"":
                 return addRestrictBackgroundBlacklist();
+            case ""restrict-network-usage-blacklist"":
+                return addRestrictNetworkUsageBlacklist();
             case ""restrict-wifi-data-blacklist"":
                 return addRestrictWiFiDataBlacklist();
             case ""restrict-mobile-data-blacklist"":
@@ -228,6 +239,8 @@ class NetworkPolicyManagerShellCommand extends ShellCommand {
                 return removeRestrictBackgroundWhitelist();
             case ""restrict-background-blacklist"":
                 return removeRestrictBackgroundBlacklist();
+            case ""restrict-network-usage-blacklist"":
+                return removeRestrictNetworkUsageBlacklist();
             case ""restrict-wifi-data-blacklist"":
                 return removeRestrictWiFiDataBlacklist();
             case ""restrict-mobile-data-blacklist"":
@@ -288,6 +301,11 @@ class NetworkPolicyManagerShellCommand extends ShellCommand {
                 POLICY_REJECT_METERED_BACKGROUND);
     }
 
+    private int listRestrictNetworkUsageBlacklist() throws RemoteException {
+        return listUidPolicies(""Restrict network usage blacklisted UIDs"",
+                POLICY_REJECT_ALL);
+    }
+
     private int listRestrictWiFiDataBlacklist() throws RemoteException {
         return listUidPolicies(""Restrict Wi-Fi data blacklisted UIDs"",
                 POLICY_REJECT_WIFI);
@@ -368,6 +386,10 @@ class NetworkPolicyManagerShellCommand extends ShellCommand {
         return setUidPolicy(POLICY_REJECT_METERED_BACKGROUND);
     }
 
+    private int addRestrictNetworkUsageBlacklist() throws RemoteException {
+        return setUidPolicy(POLICY_REJECT_ALL);
+    }
+
     private int addRestrictWiFiDataBlacklist() throws RemoteException {
         return setUidPolicy(POLICY_REJECT_WIFI);
     }
@@ -384,6 +406,10 @@ class NetworkPolicyManagerShellCommand extends ShellCommand {
         return resetUidPolicy(""not blacklisted"", POLICY_REJECT_METERED_BACKGROUND);
     }
 
+    private int removeRestrictNetworkUsageBlacklist() throws RemoteException {
+        return resetUidPolicy(""not blacklisted"", POLICY_REJECT_ALL);
+    }
+
     private int removeRestrictWiFiDataBlacklist() throws RemoteException {
         return resetUidPolicy(""not blacklisted"", POLICY_REJECT_WIFI);
     }
",26,0,"NetworkPolicyManagerShellCommand::addRestrictNetworkUsageBlacklist, NetworkPolicyManagerShellCommand::runAdd, NetworkPolicyManagerShellCommand::onHelp, NetworkPolicyManagerShellCommand::runRemove, NetworkPolicyManagerShellCommand::removeRestrictNetworkUsageBlacklist, NetworkPolicyManagerShellCommand::listRestrictNetworkUsageBlacklist, NetworkPolicyManagerShellCommand::runList"
156,1c97e4e394a23dc505a2efa4bfd555ae625688b2,GlobalActionsDialog.java,"@@ -956,6 +956,11 @@ public class GlobalActionsDialog implements DialogInterface.OnDismissListener,
         public boolean showBeforeProvisioning() {
             return true;
         }
+
+        @Override
+        public boolean shouldShow() {
+            return mHasTelephony;
+        }
     }
 
     private class EmergencyAffordanceAction extends EmergencyAction {
",5,0,GlobalActionsDialog::EmergencyAction::shouldShow
157,93beccf9967cec9e84fa493b6ce9d23a02ec93e7,NvAppProfile.java,"@@ -0,0 +1,65 @@
+package com.nvidia.NvCPLSvc;
+
+import android.net.ProxyInfo;
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.util.SparseArray;
+
+public class NvAppProfile implements Parcelable {
+    public static final Creator<NvAppProfile> CREATOR = new Creator<NvAppProfile>() {
+        public NvAppProfile createFromParcel(Parcel parcel) {
+            return NvAppProfile.createFromParcel(parcel);
+        }
+
+        public NvAppProfile[] newArray(int size) {
+            return new NvAppProfile[size];
+        }
+    };
+    public final String pkgName;
+    public final String pkgVersion;
+    public final int typeId;
+    public SparseArray<String> settings;
+
+    public NvAppProfile(int typeId, String pkgName, String pkgVersion,
+            SparseArray<String> settings) {
+        this.typeId = typeId;
+        this.pkgName = pkgName;
+        this.pkgVersion = pkgVersion;
+        this.settings = settings;
+    }
+
+    private static NvAppProfile createFromParcel(Parcel parcel) {
+        int typeId = parcel.readInt();
+        String pkgName = decodeNull(parcel.readString());
+        String pkgVersion = decodeNull(parcel.readString());
+        int numSettings = parcel.readInt();
+        SparseArray<String> settings = new SparseArray();
+        for (int i = 0; i < numSettings; i++) {
+            settings.append(parcel.readInt(), parcel.readString());
+        }
+        return new NvAppProfile(typeId, pkgName, pkgVersion, settings);
+    }
+
+    private static String encodeNull(String string) {
+        return string != null ? string : ProxyInfo.LOCAL_EXCL_LIST;
+    }
+
+    private static String decodeNull(String string) {
+        return !string.equals(ProxyInfo.LOCAL_EXCL_LIST) ? string : null;
+    }
+
+    public int describeContents() {
+        return 0;
+    }
+
+    public void writeToParcel(Parcel parcel, int flag) {
+        parcel.writeInt(this.typeId);
+        parcel.writeString(encodeNull(this.pkgName));
+        parcel.writeString(encodeNull(this.pkgVersion));
+        parcel.writeInt(this.settings.size());
+        for (int i = 0; i < this.settings.size(); i++) {
+            parcel.writeInt(this.settings.keyAt(i));
+            parcel.writeString((String) this.settings.valueAt(i));
+        }
+    }
+}
",65,0,"NvAppProfile::decodeNull, NvAppProfile::encodeNull, NvAppProfile::NvAppProfile, NvAppProfile::Creator<NvAppProfile>, NvAppProfile::describeContents, NvAppProfile::writeToParcel, NvAppProfile::createFromParcel"
158,93beccf9967cec9e84fa493b6ce9d23a02ec93e7,NvSaverAppInfo.java,"@@ -0,0 +1,166 @@
+package com.nvidia.NvCPLSvc;
+
+import android.graphics.drawable.Drawable;
+import android.os.Parcel;
+import android.os.Parcelable;
+
+public class NvSaverAppInfo implements Parcelable {
+    public static final Creator<NvSaverAppInfo> CREATOR = new Creator<NvSaverAppInfo>() {
+        public NvSaverAppInfo createFromParcel(Parcel source) {
+            return new NvSaverAppInfo(source);
+        }
+
+        public NvSaverAppInfo[] newArray(int size) {
+            return new NvSaverAppInfo[size];
+        }
+    };
+
+    public static final int NVSAVER_ACTIVITY_HIGH = 1;
+    public static final int NVSAVER_ACTIVITY_LOW = 3;
+    public static final int NVSAVER_ACTIVITY_MIDIUM = 2;
+    public static final int NVSAVER_LIST_BLACKLIST = 3;
+    public static final int NVSAVER_LIST_NONE = 1;
+    public static final int NVSAVER_LIST_WHITELIST = 2;
+    public static final int NV_APP_OPTIMIZE_LIST = 4;
+    public int mAppList;
+    public String mPkgName;
+    public long mTotalWakeupStatsTime;
+    public int mUid;
+    public long mWakeupStatsTime;
+    public int mWakeupTimes;
+    public int mWowWakeupTimes;
+    private int mAppActivity;
+    private Drawable mAppIcon;
+    private String mAppLabel;
+    private float mPowerSaver;
+
+    public NvSaverAppInfo(Parcel pl) {
+        mUid = pl.readInt();
+        mAppList = pl.readInt();
+        mWakeupTimes = pl.readInt();
+        mWowWakeupTimes = pl.readInt();
+        mPkgName = pl.readString();
+        mWakeupStatsTime = pl.readLong();
+        mTotalWakeupStatsTime = pl.readLong();
+        mAppLabel = null;
+        mAppIcon = null;
+        mAppActivity = 0;
+        mPowerSaver = 0.0f;
+    }
+
+    public NvSaverAppInfo(int u, int a, int w, int wow, String pkg, long t1, long t2) {
+        mUid = u;
+        mAppList = a;
+        mWakeupTimes = w;
+        mWowWakeupTimes = wow;
+        mPkgName = pkg;
+        mWakeupStatsTime = t1;
+        mTotalWakeupStatsTime = t2;
+        mAppLabel = null;
+        mAppIcon = null;
+        mAppActivity = 0;
+        mPowerSaver = 0.0f;
+    }
+
+    public String getAppLabel() {
+        return mAppLabel;
+    }
+
+    public void setAppLabel(String appLabel) {
+        mAppLabel = appLabel;
+    }
+
+    public Drawable getAppIcon() {
+        return mAppIcon;
+    }
+
+    public void setAppIcon(Drawable appIcon) {
+        mAppIcon = appIcon;
+    }
+
+    public int getAppActivity() {
+        return mAppActivity;
+    }
+
+    public void setAppActivity(int activity) {
+        mAppActivity = activity;
+    }
+
+    public String getPkgName() {
+        return mPkgName;
+    }
+
+    public void setPkgName(String pkgName) {
+        mPkgName = pkgName;
+    }
+
+    public int getUid() {
+        return mUid;
+    }
+
+    public void setUid(int uid) {
+        mUid = uid;
+    }
+
+    public int getWakeupTimes() {
+        return mWakeupTimes;
+    }
+
+    public void setWakeupTimes(int wakeupTimes) {
+        mWakeupTimes = wakeupTimes;
+    }
+
+    public int getWowWakeupTimes() {
+        return mWowWakeupTimes;
+    }
+
+    public void setWowWakeupTimes(int wowWakeupTimes) {
+        mWowWakeupTimes = wowWakeupTimes;
+    }
+
+    public long getTotalWakeupStatsTime() {
+        return mTotalWakeupStatsTime;
+    }
+
+    public void setTotalWakeupStatsTime(long totalWakeupStatsTime) {
+        mTotalWakeupStatsTime = totalWakeupStatsTime;
+    }
+
+    public long getWakeupStatsTime() {
+        return mWakeupStatsTime;
+    }
+
+    public void setWakeupStatsTime(long wakeupStatsTime) {
+        mWakeupStatsTime = wakeupStatsTime;
+    }
+
+    public int getAppList() {
+        return mAppList;
+    }
+
+    public void setAppList(int appList) {
+        mAppList = appList;
+    }
+
+    public float getPowerSaver() {
+        return mPowerSaver;
+    }
+
+    public void setPowerSaver(float powerSaver) {
+        mPowerSaver = powerSaver;
+    }
+
+    public int describeContents() {
+        return 0;
+    }
+
+    public void writeToParcel(Parcel dest, int flags) {
+        dest.writeInt(mUid);
+        dest.writeInt(mAppList);
+        dest.writeInt(mWakeupTimes);
+        dest.writeInt(mWowWakeupTimes);
+        dest.writeString(mPkgName);
+        dest.writeLong(mWakeupStatsTime);
+        dest.writeLong(mTotalWakeupStatsTime);
+    }
+}
",166,0,"NvSaverAppInfo::setWakeupStatsTime, NvSaverAppInfo::setTotalWakeupStatsTime, NvSaverAppInfo::getPkgName, NvSaverAppInfo::setWowWakeupTimes, NvSaverAppInfo::setPowerSaver, NvSaverAppInfo::setAppLabel, NvSaverAppInfo::setPkgName, NvSaverAppInfo::getUid, NvSaverAppInfo::setAppActivity, NvSaverAppInfo::NvSaverAppInfo, NvSaverAppInfo::writeToParcel, NvSaverAppInfo::getAppIcon, NvSaverAppInfo::setAppList, NvSaverAppInfo::getPowerSaver, NvSaverAppInfo::getWowWakeupTimes, NvSaverAppInfo::describeContents, NvSaverAppInfo::getWakeupTimes, NvSaverAppInfo::NvSaverAppInfo, NvSaverAppInfo::getAppList, NvSaverAppInfo::setWakeupTimes, NvSaverAppInfo::setUid, NvSaverAppInfo::getWakeupStatsTime, NvSaverAppInfo::getAppActivity, NvSaverAppInfo::getAppLabel, NvSaverAppInfo::Creator<NvSaverAppInfo>, NvSaverAppInfo::getTotalWakeupStatsTime, NvSaverAppInfo::setAppIcon"
159,3aa91ba5a999c38f82b3cf43414026dc9bbfa894,ApplicationPackageManager.java,"@@ -104,6 +104,8 @@ import com.android.internal.annotations.VisibleForTesting;
 import com.android.internal.os.SomeArgs;
 import com.android.internal.util.UserIcons;
 
+import com.nvidia.NvAppProfileService;
+
 import dalvik.system.VMRuntime;
 
 import libcore.util.EmptyArray;
@@ -149,6 +151,7 @@ public class ApplicationPackageManager extends PackageManager {
     private UserManager mUserManager;
     @GuardedBy(""mLock"")
     private PackageInstaller mInstaller;
+    private NvAppProfileService mAppProfileService;
     @GuardedBy(""mLock"")
     private ArtManager mArtManager;
 
@@ -406,6 +409,15 @@ public class ApplicationPackageManager extends PackageManager {
                 com.android.internal.R.bool.config_wirelessConsentRequired);
     }
 
+    /** @hide */
+    @Override
+    public NvAppProfileService getAppProfileService() {
+        if (mAppProfileService == null) {
+            mAppProfileService = new NvAppProfileService(mContext);
+        }
+        return mAppProfileService;
+    }
+
     @Override
     public ApplicationInfo getApplicationInfo(String packageName, int flags)
             throws NameNotFoundException {
",12,0,ApplicationPackageManager::getAppProfileService
160,3aa91ba5a999c38f82b3cf43414026dc9bbfa894,PackageManager.java,"@@ -76,6 +76,8 @@ import android.util.Log;
 
 import com.android.internal.util.ArrayUtils;
 
+import com.nvidia.NvAppProfileService;
+
 import dalvik.system.VMRuntime;
 
 import java.io.File;
@@ -4048,6 +4050,9 @@ public abstract class PackageManager {
     public abstract List<PermissionGroupInfo> getAllPermissionGroups(
             @PermissionGroupInfoFlags int flags);
 
+    /** @hide */
+    public abstract NvAppProfileService getAppProfileService();
+
     /**
      * Retrieve all of the information we know about a particular
      * package/application.
",5,0,
161,3aa91ba5a999c38f82b3cf43414026dc9bbfa894,PackageParser.java,"@@ -98,6 +98,8 @@ import com.android.internal.os.ClassLoaderFactory;
 import com.android.internal.util.ArrayUtils;
 import com.android.internal.util.XmlUtils;
 
+import com.nvidia.NvAppProfileService;
+
 import libcore.io.IoUtils;
 import libcore.util.EmptyArray;
 import libcore.util.HexEncoding;
@@ -578,6 +580,7 @@ public class PackageParser {
      * a package.
      */
     public interface Callback {
+        NvAppProfileService getAppProfileService();
         boolean hasFeature(String feature);
     }
 
@@ -592,6 +595,10 @@ public class PackageParser {
             mPm = pm;
         }
 
+        @Override public NvAppProfileService getAppProfileService() {
+            return mPm.getAppProfileService();
+        }
+
         @Override public boolean hasFeature(String feature) {
             return mPm.hasSystemFeature(feature);
         }
",7,0,PackageParser::CallbackImpl::getAppProfileService
162,3aa91ba5a999c38f82b3cf43414026dc9bbfa894,NvAppProfileService.java,"@@ -0,0 +1,246 @@
+/*
+ * Copyright (c) 2012 - 2014 NVIDIA Corporation.  All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * Class structure based upon Camera in Camera.java:
+ * Copyright (C) 2009 The Android Open Source Project
+ */
+
+package com.nvidia;
+
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.PackageManager;
+import android.content.res.Resources;
+import android.graphics.drawable.Drawable;
+import android.os.SystemProperties;
+import android.os.UserHandle;
+import android.util.Log;
+
+import com.nvidia.profilemanager.NvAppProfileSettingId;
+
+/**
+ * @hide
+ */
+public class NvAppProfileService {
+    private static final String TAG = ""NvAppProfileService"";
+    private static final String APP_START_ACTION =
+            ""com.nvidia.NvAppProfileService.action.APP_START"";
+    private static final String APP_START_TARGET_PACKAGE = ""com.nvidia.peripheralservice"";
+    private static final String FEATURE_POWER_BUDGET_CONTROL =
+            ""nvidia.feature.power_budget_control"";
+    private static final String FEATURE_FAN_ON_DEVICE = ""nvidia.feature.fan_on_device"";
+
+    private final NvAppProfiles mAppProfile;
+    private final NvWhitelistService mWhitelistService;
+    private final Context mContext;
+
+    private boolean mInitialisedAppProfiles = false;
+    private boolean mFanCapEnabled = false;
+    private boolean mPbcEnabled = false;
+
+    public NvAppProfileService(Context context) {
+        Context appContext = context.getApplicationContext();
+        if (appContext == null) {
+            mContext = context;
+        } else {
+            mContext = appContext;
+        }
+
+        mAppProfile = new NvAppProfiles(mContext);
+        mWhitelistService = new NvWhitelistService(mContext);
+    }
+
+    private static String getPackageName(String appName) {
+        int index = appName.indexOf('/');
+        if (index < 0) {
+            Log.e(TAG, ""appName does not contain '/'. "" +
+                    ""The packageName cannot be extracted from appName!"");
+            return null;
+        }
+        return appName.substring(0, index);
+    }
+
+    /*
+     * These are functions that depend on NvAppProfiles and may or may not
+     * be supported for certain platforms. In the latter case, these methods
+     * should return -1.
+     */
+    public boolean getAppProfileFRCEnable(String packageName) {
+        return packageName != null && mAppProfile.getApplicationProfile(packageName,
+                NvAppProfileSettingId.VIDEO_FRC_ENABLE) == 1;
+    }
+
+    public boolean getAppProfileCreateSecureDecoder(String packageName) {
+        return packageName != null && mAppProfile.getApplicationProfile(packageName,
+                NvAppProfileSettingId.VIDEO_SECURE_DECODE) == 1;
+    }
+
+    public boolean getAppProfileTSFilterEnable(String packageName) {
+        return packageName != null && mAppProfile.getApplicationProfile(packageName,
+                NvAppProfileSettingId.VIDEO_TS_FILTERING) == 1;
+    }
+
+    public boolean getAppProfileMediaEnableMsdHal(String packageName) {
+        return packageName != null && this.mAppProfile.getApplicationProfile(packageName,
+                NvAppProfileSettingId.MEDIA_ENABLE_MSD_HAL) == 1;
+    }
+
+    public boolean getAppProfileNvidiaCertification(String packageName) {
+        return packageName != null && mAppProfile.getApplicationProfile(packageName,
+                NvAppProfileSettingId.NVIDIA_VIDEO_CERTIFICATION_ENABLED) == 1;
+    }
+
+    public String customizeAppBanner(String packageName) {
+        if (packageName == null) return null;
+
+        final String bannerName = mAppProfile.getApplicationProfileString(packageName,
+                NvAppProfileSettingId.WHITELIST_CUSTOMIZE_BANNER);
+        if (bannerName != null) return bannerName;
+
+        return mWhitelistService.getBannerName(packageName);
+    }
+
+    public Drawable getBannerDrawable(String packageName) {
+        final String bannerName = customizeAppBanner(packageName);
+        if (bannerName == null || bannerName.length() == 0) {
+            return null;
+        }
+
+        final Resources systemResources = mContext.getResources().getSystem();
+        final int drawableResourceId = systemResources.getIdentifier(bannerName,
+                ""drawable"", ""android"");
+        if (drawableResourceId == 0) return null;
+
+        return systemResources.getDrawable(drawableResourceId);
+    }
+
+    public NvWhitelistService getWhitelistService() {
+        return mWhitelistService;
+    }
+
+    public boolean getAppProfileDisableApp(String packageName) {
+        return packageName != null && mAppProfile.getApplicationProfile(packageName,
+                NvAppProfileSettingId.DISABLE_APP) == 1;
+    }
+
+    private int getAppProfileCpuScalingMinFreq(String packageName) {
+        return mAppProfile.getApplicationProfile(packageName,
+                NvAppProfileSettingId.SCALING_MIN_FREQ);
+    }
+
+    private int getAppProfileCpuCoreBias(String packageName) {
+        return mAppProfile.getApplicationProfile(packageName, NvAppProfileSettingId.CORE_BIAS);
+    }
+
+    private int getAppProfileGpuScaling(String packageName) {
+        return mAppProfile.getApplicationProfile(packageName, NvAppProfileSettingId.GPU_SCALING);
+    }
+
+    private int getAppProfileCpuMaxNormalFreq(String packageName) {
+        return mAppProfile.getApplicationProfile(packageName, NvAppProfileSettingId.CPU_FREQ_BIAS);
+    }
+
+    private int getAppProfileCpuMaxNormalFreqPercent(String packageName) {
+        return mAppProfile.getApplicationProfile(packageName,
+                NvAppProfileSettingId.MAX_CPU_FREQ_PCT);
+    }
+
+    private int getAppProfileCpuMinCore(String packageName) {
+        return mAppProfile.getApplicationProfile(packageName, NvAppProfileSettingId.MIN_CPU_CORES);
+    }
+
+    private int getAppProfileCpuMaxCore(String packageName) {
+        return mAppProfile.getApplicationProfile(packageName, NvAppProfileSettingId.MAX_CPU_CORES);
+    }
+
+    private int getAppProfileGpuCbusCapLevel(String packageName) {
+        return mAppProfile.getApplicationProfile(packageName, NvAppProfileSettingId.GPU_CORE_CAP);
+    }
+
+    private int getAppProfileEdpMode(String packageName) {
+        return mAppProfile.getApplicationProfile(packageName, NvAppProfileSettingId.EDP_MODE);
+    }
+
+    private int getAppProfilePbcPwr(String packageName) {
+        if (!mPbcEnabled) return -1;
+
+        return mAppProfile.getApplicationProfile(packageName, NvAppProfileSettingId.PBC_PWR_LIMIT);
+    }
+
+    private int getAppProfileFanCap(String packageName) {
+        if (!mFanCapEnabled) return -1;
+
+        return mAppProfile.getApplicationProfile(packageName, NvAppProfileSettingId.FAN_PWM_CAP);
+    }
+
+    private int getAppProfileVoltTempMode(String packageName) {
+        return mAppProfile.getApplicationProfile(packageName, NvAppProfileSettingId.VOLT_TEMP_MODE);
+    }
+
+    private int getAppProfileAggresivePrismEnable(String packageName) {
+        return mAppProfile.getApplicationProfile(packageName,
+                NvAppProfileSettingId.AGGRESSIVE_PRISM_ENABLE);
+    }
+
+    private int getAppProfileDevicePowerMode(String packageName) {
+        return mAppProfile.getApplicationProfile(packageName,
+                NvAppProfileSettingId.SYSTEM_POWER_MODE);
+    }
+
+    public String getAppProfileRegionEnableList(String packageName) {
+        return mAppProfile.getApplicationProfileString(packageName,
+                NvAppProfileSettingId.SET_REGION_LIST);
+    }
+
+    public int getAppProfileNvidiaBBCApps(String packageName) {
+        return mAppProfile.getApplicationProfile(packageName, NvAppProfileSettingId.BBC_APPS);
+    }
+
+    private int retrievePowerMode() {
+        final String powerMode = SystemProperties.get(NvConstants.NvPowerModeProperty);
+        if (powerMode != null) {
+            try {
+                return Integer.parseInt(powerMode);
+            } catch (NumberFormatException ex) {
+                // Fallthrough to error case
+            }
+        }
+
+        return -1;
+    }
+
+    /**
+     * Interface for the caller
+     */
+    public void setAppProfile(String packageName) {
+        // Greedy initialization of App Profiles
+        if (!mInitialisedAppProfiles) {
+            PackageManager pm = mContext.getPackageManager();
+            mPbcEnabled = pm.hasSystemFeature(FEATURE_POWER_BUDGET_CONTROL);
+            mFanCapEnabled = pm.hasSystemFeature(FEATURE_FAN_ON_DEVICE);
+
+            Log.w(TAG, ""Enabled"");
+            mInitialisedAppProfiles = true;
+        }
+
+        mAppProfile.powerHint(packageName);
+
+        Intent intent = new Intent(APP_START_ACTION);
+        intent.setPackage(APP_START_TARGET_PACKAGE);
+        intent.putExtra(""AppStartId"", packageName);
+        mContext.sendBroadcastAsUser(intent, UserHandle.CURRENT,
+                ""nvidia.permission.READ_APP_START_INFO"");
+    }
+}
",246,0,"NvAppProfileService::getAppProfileCpuMaxNormalFreqPercent, NvAppProfileService::getAppProfileTSFilterEnable, NvAppProfileService::getAppProfileCpuScalingMinFreq, NvAppProfileService::getAppProfileDisableApp, NvAppProfileService::getAppProfileRegionEnableList, NvAppProfileService::getAppProfileNvidiaCertification, NvAppProfileService::getAppProfileCpuMaxNormalFreq, NvAppProfileService::getAppProfileAggresivePrismEnable, NvAppProfileService::getAppProfileGpuCbusCapLevel, NvAppProfileService::getAppProfileDevicePowerMode, NvAppProfileService::getAppProfileVoltTempMode, NvAppProfileService::getAppProfilePbcPwr, NvAppProfileService::getPackageName, NvAppProfileService::getBannerDrawable, NvAppProfileService::getAppProfileEdpMode, NvAppProfileService::NvAppProfileService, NvAppProfileService::getAppProfileFanCap, NvAppProfileService::retrievePowerMode, NvAppProfileService::getAppProfileFRCEnable, NvAppProfileService::customizeAppBanner, NvAppProfileService::getAppProfileMediaEnableMsdHal, NvAppProfileService::getWhitelistService, NvAppProfileService::getAppProfileNvidiaBBCApps, NvAppProfileService::getAppProfileCpuMinCore, NvAppProfileService::getAppProfileGpuScaling, NvAppProfileService::getAppProfileCpuCoreBias, NvAppProfileService::getAppProfileCpuMaxCore, NvAppProfileService::getAppProfileCreateSecureDecoder, NvAppProfileService::setAppProfile"
163,3aa91ba5a999c38f82b3cf43414026dc9bbfa894,NvAppProfiles.java,"@@ -0,0 +1,96 @@
+package com.nvidia;
+
+import android.content.Context;
+import android.content.Intent;
+import android.os.IBinder;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.util.Log;
+
+import com.nvidia.NvCPLSvc.INvCPLRemoteService;
+
+public class NvAppProfiles {
+    /**
+     * Unique name used for NvCPLSvc to whitelist this class
+     */
+    static final String NV_APP_PROFILES_NAME = ""Frameworks_NvAppProfiles"";
+    static final boolean DEBUG = false;
+    private static final String TAG = ""NvAppProfiles"";
+    private final Context mContext;
+    private INvCPLRemoteService mNvCPLSvc = null;
+    private IBinder mNvCPLSvcBinder = null;
+
+    /**
+     * Callback class given by the NvCPLService
+     */
+
+    public NvAppProfiles(Context context) {
+        mContext = context;
+    }
+
+    public int getApplicationProfile(String packageName, int settingId) {
+        getNvCPLService();
+        if (mNvCPLSvc != null) {
+            try {
+                return mNvCPLSvc.getAppProfileSettingInt(packageName, settingId);
+            } catch (RemoteException ex) {
+                Log.w(TAG, ""Failed to retrieve profile setting. Error="" + ex.getMessage());
+            }
+        }
+
+        return -1;
+    }
+
+    public String getApplicationProfileString(String packageName, int settingId) {
+        getNvCPLService();
+        if (mNvCPLSvc != null) {
+            try {
+                return mNvCPLSvc.getAppProfileSettingString(packageName, settingId);
+            } catch (RemoteException ex) {
+                Log.w(TAG, ""Failed to retrieve profile setting. Error="" + ex.getMessage());
+            }
+        }
+
+        return null;
+    }
+
+    public void setPowerMode(int index) {
+        if (DEBUG) Log.w(TAG, ""Setting power mode: "" + String.valueOf(index));
+
+        Intent intent = new Intent();
+        intent.setClassName(NvConstants.NvCPLSvc, NvConstants.NvCPLService);
+        intent.putExtra(NvConstants.NvOrigin, 1);
+        intent.putExtra(NvConstants.NvPowerMode , String.valueOf(index));
+
+        handleIntent(intent);
+    }
+
+    public void powerHint(String packageName) {
+        getNvCPLService();
+        if (mNvCPLSvc != null) {
+            try {
+                mNvCPLSvc.powerHint(packageName);
+            } catch (RemoteException ex) {
+                Log.w(TAG, ""Failed to send power hint. Error="" + ex.getMessage());
+            }
+        }
+    }
+
+    public void handleIntent(Intent intent) {
+        getNvCPLService();
+        if (mNvCPLSvc != null) {
+            try {
+                mNvCPLSvc.handleIntent(intent);
+            } catch (RemoteException ex) {
+                Log.w(TAG, ""Failed to handle intent. Error="" + ex.getMessage());
+            }
+        }
+    }
+
+    private void getNvCPLService() {
+        if (mNvCPLSvc == null || mNvCPLSvcBinder == null || !mNvCPLSvcBinder.isBinderAlive()) {
+            mNvCPLSvcBinder = ServiceManager.getService(""nvcpl"");
+            mNvCPLSvc = INvCPLRemoteService.Stub.asInterface(mNvCPLSvcBinder);
+        }
+    }
+}
",96,0,"NvAppProfiles::powerHint, NvAppProfiles::setPowerMode, NvAppProfiles::getApplicationProfileString, NvAppProfiles::NvAppProfiles, NvAppProfiles::handleIntent, NvAppProfiles::getNvCPLService, NvAppProfiles::getApplicationProfile"
164,3aa91ba5a999c38f82b3cf43414026dc9bbfa894,NvConstants.java,"@@ -0,0 +1,18 @@
+package com.nvidia;
+
+public class NvConstants {
+    public static final String NvAppClose = ""com.nvidia.app.close"";
+    public static final String NvBatteryMonitor = ""com.nvidia.NvCPLSvc.BatteryMonitor"";
+    public static final String NvCPLService = ""com.nvidia.NvCPLSvc.NvCPLService"";
+    public static final String NvCPLSvc = ""com.nvidia.NvCPLSvc"";
+    public static final String NvMaxGpuMode = ""com.nvidia.NvCPLSvc.MaxGpuMode"";
+    public static final String NvOrigin = ""com.nvidia.NvCPLSvc.Origin"";
+    public static final String NvPowerMode = ""com.nvidia.NvCPLSvc.NV_POWER_MODE"";
+    public static final String NvPowerModeProperty = ""persist.vendor.sys.NV_POWER_MODE"";
+    public static final String NvStateId = ""com.nvidia.NvCPLSvc.StateID"";
+    public static final String NvTCPDivisor = ""com.nvidia.NvCPLSvc.NV_TCPDIVISOR"";
+    public static final String NvThermalStats = ""com.nvidia.peripheralservice.NvThermalStats"";
+    public static final int NV_POWER_MODE_MAX_PERF = 0;
+    public static final int NV_POWER_MODE_OPTIMIZED = 1;
+    public static final int NV_POWER_MODE_BATTERY_SAVER = 2;
+}
",18,0,
165,3aa91ba5a999c38f82b3cf43414026dc9bbfa894,NvWhitelistService.java,"@@ -0,0 +1,112 @@
+package com.nvidia;
+
+import android.content.Context;
+import android.content.res.XmlResourceParser;
+import android.util.Log;
+
+import com.android.internal.R;
+
+import java.util.ArrayList;
+import java.io.IOException;
+
+import org.json.JSONObject;
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.xmlpull.v1.XmlPullParserException;
+
+public class NvWhitelistService {
+    private static final String TAG = ""NvWhitelistService"";
+    private JSONArray mWhiteListArray;
+    private Context mContext;
+
+    public NvWhitelistService(Context context) {
+        Context appContext = context.getApplicationContext();
+        mContext = appContext != null ? appContext : context;
+        mWhiteListArray =
+                parseXml(mContext.getResources().getXml(R.xml.tv_launcher_app_white_list));
+    }
+
+    public boolean isWhiteApp(String pkgName) {
+        if (mWhiteListArray == null) return false;
+
+        for (int i = 0; i < mWhiteListArray.length(); i++) {
+            try {
+                if (pkgName.equals(mWhiteListArray.getJSONObject(i).getString(""packageName""))) {
+                    return true;
+                }
+            } catch (JSONException ex) {
+                Log.w(TAG, ex.getMessage());
+            }
+        }
+
+        return false;
+    }
+
+    public boolean isTvGame(String pkgName) {
+        if (mWhiteListArray == null) return false;
+
+        for (int i = 0; i < mWhiteListArray.length(); i++) {
+            try {
+                if (mWhiteListArray.getJSONObject(i).getString(""packageName"").equals(pkgName) &&
+                        mWhiteListArray.getJSONObject(i).getString(""isGame"").equals(""true"")) {
+                    return true;
+                }
+            } catch (JSONException ex) {
+                Log.w(TAG, ex.getMessage());
+            }
+        }
+
+        return false;
+    }
+
+    public String getBannerName(String pkgName) {
+        for (int i = 0; i < mWhiteListArray.length(); i++) {
+            try {
+                if (mWhiteListArray.getJSONObject(i).getString(""packageName"").equals(pkgName)) {
+                    return mWhiteListArray.getJSONObject(i).getString(""bannerName"");
+                }
+            } catch (JSONException ex) {
+                Log.w(TAG, ex.getMessage());
+            }
+        }
+
+        return """";
+    }
+
+    private JSONArray parseXml(XmlResourceParser xmlParser) {
+        if (xmlParser == null) return null;
+
+        JSONObject jsonObj = null;
+        ArrayList<JSONObject> widgetConfigs = new ArrayList<>();
+        try {
+            int type = xmlParser.getEventType();
+            while (type != XmlResourceParser.END_DOCUMENT) {
+                switch (type) {
+                    case XmlResourceParser.START_TAG:
+                        if (xmlParser.getName().equals(""app"")) {
+                            jsonObj = new JSONObject();
+                            for (int i = 0; i < xmlParser.getAttributeCount(); i++) {
+                                jsonObj.put(xmlParser.getAttributeName(i),
+                                        xmlParser.getAttributeValue(i));
+                            }
+                            break;
+                        }
+                        break;
+                    case XmlResourceParser.END_TAG:
+                        if (xmlParser.getName().equals(""app"") && jsonObj != null) {
+                            widgetConfigs.add(jsonObj);
+                            break;
+                        }
+                        break;
+                    default:
+                        break;
+                }
+                type = xmlParser.next();
+            }
+        } catch (IOException | JSONException | XmlPullParserException e) {
+            e.printStackTrace();
+        }
+
+        return new JSONArray(widgetConfigs);
+    }
+}
",112,0,"NvWhitelistService::isWhiteApp, NvWhitelistService::isTvGame, NvWhitelistService::getBannerName, NvWhitelistService::parseXml, NvWhitelistService::NvWhitelistService"
166,3aa91ba5a999c38f82b3cf43414026dc9bbfa894,NvAppProfileSettingId.java,"@@ -0,0 +1,93 @@
+package com.nvidia.profilemanager;
+
+public class NvAppProfileSettingId {
+    public static int RESOVERRIDE_SCALE_FACTOR = 5;
+    public static int STEREO_PERF_WIDTH = 7;
+    public static int RESOVERRIDE_PERF_WIDTH = 8;
+    public static int FORCE_HW_UI = 9;
+    public static int CORE_BIAS = 17;
+    public static int CPU_FREQ_BIAS = 18;
+    public static int GPU_CORE_CAP = 19;
+    public static int SCALING_MIN_FREQ = 20;
+    public static int GPU_SCALING = 21;
+    public static int PBC_PWR_LIMIT = 22;
+    public static int FAN_PWM_CAP = 23;
+    public static int VOLT_TEMP_MODE = 24;
+    public static int FRAME_RATE_LIMIT = 26;
+    public static int DISABLE_APM = 29;
+    public static int EDP_MODE = 30;
+    public static int GPU_MODE = 35;
+    public static int STYLUS_FINGER_ONLY_MODE = 40;
+    public static int STEREO_PERF_SCALE_FACTOR = 43;
+    public static int DISABLE_BUFFER_AGE = 47;
+    public static int SYSTEM_POWER_MODE = 48;
+    public static int CUSTOM_PROFILE_BLACKLIST = 51;
+    public static int BLOCK_NETWORK_ACCESS = 53;
+    public static int MAX_CPU_CORES = 58;
+    public static int AGGRESSIVE_PRISM_ENABLE = 59;
+    public static int BLOCK_ON_NETWORK = 60;
+    public static int MAX_CPU_FREQ_PCT = 61;
+    public static int DEPTH_COMPRESSION = 62;
+    public static int OGL_THREADCONTROL = 63;
+    public static int OGL_SKIP_ENABLED_UNSET_ARRAY = 64;
+    public static int CMU_GTM_MAPPING_LUT = 65;
+    public static int OGL_CLEAR_METERING = 66;
+    public static int KILL_PROCESS_BELOW_ADJ = 67;
+    public static int EGL_REPORT_ES1_CONFIG_ONLY = 69;
+    public static int VIDEO_IQ = 70;
+    public static int CAMERA_MEMORY = 71;
+    public static int PERF_FP = 72;
+    public static int MIN_CPU_CORES = 73;
+    public static int PROMOTE_SURFACE_TO_32BIT = 74;
+    public static int AFFINITY_DAEMON_ENABLE = 75;
+    public static int CUSTOM_PROFILE_SYSTEM_WHITELIST = 76;
+    public static int FORCEONCPU = 77;
+    public static int KEY_DEVICE_ID_HASH = 78;
+    public static int GSYNC_WHITELIST = 79;
+    public static int GSYNC_BLACKLIST = 80;
+    public static int TOUCH_MODE = 81;
+    public static int DISPLAY_UPSCALE_HEIGHT = 82;
+    public static int DISPLAY_UPSCALE_WIDTH = 83;
+    public static int OGL_APP_RUNTIME_VERTEX_ATTRIB_SOURCING = 84;
+    public static int MAXWELL_TILEDCACHE = 85;
+    public static int OGL_HIDE_EXTENSIONS_STRING = 86;
+    public static int NVIDIA_WEBVIEW = 87;
+    public static int OGL_HIDE_EXTENSIONS = 88;
+    public static int HDD_DIALOG_FREQ = 89;
+    public static int HDD_DIALOG_TEXT = 90;
+    public static int HDD_DIALOG_THRESHOLD = 91;
+    public static int HDD_DIALOG_ENABLE = 92;
+    public static int TCP_DIVISOR = 93;
+    public static int BBC_APPS = 94;
+    public static int HDD_STATS_ENABLE = 95;
+    public static int HDD_DIALOG_REMIND_ME_LATER_FREQ = 96;
+    public static int HDD_STATS_FREQ = 97;
+    public static int HDD_DIALOG_STR_THRESHOLD = 98;
+    public static int OGL_VERSION_OVERRIDE = 99;
+    public static int OGL_ES_VERSION_OVERRIDE = 100;
+    public static int MULTI_CHANNEL_SWITCH_MODE = 101;
+    public static int VIDEO_FRC_ENABLE = 102;
+    public static int VIDEO_SECURE_DECODE = 103;
+    public static int VIDEO_TS_FILTERING = 104;
+    public static int NVIDIA_VIDEO_CERTIFICATION_ENABLED = 105;
+    public static int OGL_SHADER_PORTABILITY_WARNINGS = 106;
+    public static int OGL_THREADCONTROL2 = 107;
+    public static int OGL_EXTRA_CGC_OPTION = 108;
+    public static int DISABLE_APP = 109;
+    public static int SET_REGION_LIST = 110;
+    public static int PINNING_ENABLE = 111;
+    public static int PINNING_ORDER = 112;
+    public static int GPU_MODESET_ENABLE = 113;
+    public static int AVS_DELAY_ENABLE = 114;
+    public static int BLACKLIST_USB_30 = 115;
+    public static int DRM_DIALOG_ENABLE = 116;
+    public static int FILTER_EGLCONFIGS = 117;
+    public static int SHIELD_LOGGING = 118;
+    public static int APP_AUDIO_SWITCH_TO_STEREO = 119;
+    public static int WHITELIST_CUSTOMIZE_BANNER = 120;
+    public static int NV_MAPPER_GAME_LIST = 121;
+    public static int NV_MULTI_CAPTURE_MOD = 122;
+    public static int MEDIA_ENABLE_MSD_HAL = 123;
+    public static int DEEPISP_DISABLED = 124;
+    public static int OGL_GPFIFO_SIZE_ENTRIES = 125;
+}
",93,0,
167,3aa91ba5a999c38f82b3cf43414026dc9bbfa894,ProfileTypeId.java,"@@ -0,0 +1,11 @@
+package com.nvidia.profilemanager;
+
+public class ProfileTypeId {
+    public static int LAST_RESERVED_TYPE = 9999;
+
+    public static int DEFAULT = 0;
+    public static int OEM_OVERRIDE = 1;
+    public static int DEV_OVERRIDE = 2;
+    public static int USER = 10000;
+    public static int OPTIMIZED = 10001;
+}
",11,0,
168,3aa91ba5a999c38f82b3cf43414026dc9bbfa894,PackageManagerService.java,"@@ -379,6 +379,8 @@ import com.android.server.uri.UriGrantsManagerInternal;
 import com.android.server.utils.TimingsTraceAndSlog;
 import com.android.server.wm.ActivityTaskManagerInternal;
 
+import com.nvidia.NvAppProfileService;
+
 import dalvik.system.CloseGuard;
 import dalvik.system.VMRuntime;
 
@@ -1153,6 +1155,8 @@ public class PackageManagerService extends IPackageManager.Stub
 
     final PackageInstallerService mInstallerService;
 
+    private NvAppProfileService mAppProfileService;
+
     final ArtManagerService mArtManagerService;
 
     private final PackageDexOptimizer mPackageDexOptimizer;
@@ -2889,6 +2893,13 @@ public class PackageManagerService extends IPackageManager.Stub
             public boolean hasFeature(String feature) {
                 return PackageManagerService.this.hasSystemFeature(feature, 0);
             }
+
+            public NvAppProfileService getAppProfileService() {
+                if (mAppProfileService == null) {
+                    mAppProfileService = new NvAppProfileService(mContext);
+                }
+                return mAppProfileService;
+            }
         };
 
         // CHECKSTYLE:ON IndentationCheck
",11,0,PackageManagerService::PackageManagerService
169,3aa91ba5a999c38f82b3cf43414026dc9bbfa894,MockPackageManager.java,"@@ -55,6 +55,8 @@ import android.os.PersistableBundle;
 import android.os.UserHandle;
 import android.os.storage.VolumeInfo;
 
+import com.nvidia.NvAppProfileService;
+
 import java.util.List;
 import java.util.Set;
 
@@ -178,6 +180,12 @@ public class MockPackageManager extends PackageManager {
         throw new UnsupportedOperationException();
     }
 
+    /** @hide */
+    @Override
+    public NvAppProfileService getAppProfileService() {
+        throw new UnsupportedOperationException();
+    }
+
     @Override
     public ApplicationInfo getApplicationInfo(String packageName, int flags)
             throws NameNotFoundException {
",8,0,MockPackageManager::getAppProfileService
170,3a5099942f76f671bd01dacce2b191514388e480,LockIcon.java,"@@ -171,7 +171,7 @@ public class LockIcon extends KeyguardAffordanceView {
         int iconRes = isAnim ? getThemedAnimationResId(lockAnimIndex) : getIconForState(newState);
 
         if (!mDrawableCache.contains(iconRes)) {
-            mDrawableCache.put(iconRes, getResources().getDrawable(iconRes));
+            mDrawableCache.put(iconRes, getContext().getDrawable(iconRes));
         }
 
         return mDrawableCache.get(iconRes);
",1,1,LockIcon::getIcon
171,89c54c83bd8bfeeb2ba214f522afbf11bdc516fc,AudioFormat.java,"@@ -254,8 +254,8 @@ public final class AudioFormat implements Parcelable {
 
     /** Audio data format: compressed audio wrapped in PCM for HDMI
      * or S/PDIF passthrough.
-     * IEC61937 uses a stereo stream of 16-bit samples as the wrapper.
-     * So the channel mask for the track must be {@link #CHANNEL_OUT_STEREO}.
+     * For devices whose SDK version is less than {@link android.os.Build.VERSION_CODES#S}, the
+     * channel mask of IEC61937 track must be {@link #CHANNEL_OUT_STEREO}.
      * Data should be written to the stream in a short[] array.
      * If the data is written in a byte[] array then there may be endian problems
      * on some platforms when converting to short internally.
",2,2,
172,89c54c83bd8bfeeb2ba214f522afbf11bdc516fc,AudioTrack.java,"@@ -1648,13 +1648,11 @@ public class AudioTrack extends PlayerBase
         }
         mSampleRate = sampleRateInHz;
 
-        // IEC61937 is based on stereo. We could coerce it to stereo.
-        // But the application needs to know the stream is stereo so that
-        // it is encoded and played correctly. So better to just reject it.
         if (audioFormat == AudioFormat.ENCODING_IEC61937
-                && channelConfig != AudioFormat.CHANNEL_OUT_STEREO) {
-            throw new IllegalArgumentException(
-                    ""ENCODING_IEC61937 must be configured as CHANNEL_OUT_STEREO"");
+                && channelConfig != AudioFormat.CHANNEL_OUT_STEREO
+                && AudioFormat.channelCountFromOutChannelMask(channelConfig) != 8) {
+            Log.w(TAG, ""ENCODING_IEC61937 is configured with channel mask as "" + channelConfig
+                    + "", which is not 2 or 8 channels"");
         }
 
         //--------------
",4,6,AudioTrack::audioParamCheck
173,f2aeff22fcf2165087246ab161da639c474953b5,ActiveServices.java,"@@ -734,8 +734,11 @@ public final class ActiveServices {
         }
         ComponentName cmp = startServiceInnerLocked(smap, service, r, callerFg, addToStarting);
 
-        setFgsRestrictionLocked(callingPackage, callingPid, callingUid, r,
-                allowBackgroundActivityStarts);
+        if (!r.mAllowWhileInUsePermissionInFgs) {
+            r.mAllowWhileInUsePermissionInFgs =
+                    shouldAllowWhileInUsePermissionInFgsLocked(callingPackage, callingPid,
+                            callingUid, service, r, allowBackgroundActivityStarts);
+        }
 
         return cmp;
     }
@@ -1408,6 +1411,14 @@ public final class ActiveServices {
                         +  String.format(""0x%08X"", manifestType)
                         + "" in service element of manifest file"");
                 }
+                // If the foreground service is not started from TOP process, do not allow it to
+                // have while-in-use location/camera/microphone access.
+                if (!r.mAllowWhileInUsePermissionInFgs) {
+                    Slog.w(TAG,
+                            ""Foreground service started from background can not have ""
+                                    + ""location/camera/microphone access: service ""
+                                    + r.shortInstanceName);
+                }
             }
             boolean alreadyStartedOp = false;
             boolean stopProcStatsOp = false;
@@ -1455,57 +1466,6 @@ public final class ActiveServices {
                     ignoreForeground = true;
                 }
 
-                if (!ignoreForeground) {
-                    if (r.mStartForegroundCount == 0) {
-                        /*
-                        If the service was started with startService(), not
-                        startForegroundService(), and if startForeground() isn't called within
-                        mFgsStartForegroundTimeoutMs, then we check the state of the app
-                        (who owns the service, which is the app that called startForeground())
-                        again. If the app is in the foreground, or in any other cases where
-                        FGS-starts are allowed, then we still allow the FGS to be started.
-                        Otherwise, startForeground() would fail.
-
-                        If the service was started with startForegroundService(), then the service
-                        must call startForeground() within a timeout anyway, so we don't need this
-                        check.
-                        */
-                        if (!r.fgRequired) {
-                            final long delayMs = SystemClock.elapsedRealtime() - r.createRealTime;
-                            if (delayMs > mAm.mConstants.mFgsStartForegroundTimeoutMs) {
-                                resetFgsRestrictionLocked(r);
-                                setFgsRestrictionLocked(r.serviceInfo.packageName, r.app.pid,
-                                        r.appInfo.uid, r, false);
-                                EventLog.writeEvent(0x534e4554, ""183147114"",
-                                        r.appInfo.uid,
-                                        ""call setFgsRestrictionLocked again due to ""
-                                                + ""startForegroundTimeout"");
-                            }
-                        }
-                    } else if (r.mStartForegroundCount >= 1) {
-                        // The second or later time startForeground() is called after service is
-                        // started. Check for app state again.
-                        final long delayMs = SystemClock.elapsedRealtime() -
-                                r.mLastSetFgsRestrictionTime;
-                        if (delayMs > mAm.mConstants.mFgsStartForegroundTimeoutMs) {
-                            resetFgsRestrictionLocked(r);
-                            setFgsRestrictionLocked(r.serviceInfo.packageName, r.app.pid,
-                                    r.appInfo.uid, r, false);
-                            EventLog.writeEvent(0x534e4554, ""183147114"", r.appInfo.uid,
-                                    ""call setFgsRestrictionLocked for ""
-                                            + (r.mStartForegroundCount + 1) + ""th startForeground"");
-                        }
-                    }
-                    // If the foreground service is not started from TOP process, do not allow it to
-                    // have while-in-use location/camera/microphone access.
-                    if (!r.mAllowWhileInUsePermissionInFgs) {
-                        Slog.w(TAG,
-                                ""Foreground service started from background can not have ""
-                                        + ""location/camera/microphone access: service ""
-                                        + r.shortInstanceName);
-                    }
-                }
-
                 // Apps under strict background restrictions simply don't get to have foreground
                 // services, so now that we've enforced the startForegroundService() contract
                 // we only do the machinery of making the service foreground when the app
@@ -1541,7 +1501,6 @@ public final class ActiveServices {
                             active.mNumActive++;
                         }
                         r.isForeground = true;
-                        r.mStartForegroundCount++;
                         if (!stopProcStatsOp) {
                             ServiceState stracker = r.getTracker();
                             if (stracker != null) {
@@ -1600,7 +1559,6 @@ public final class ActiveServices {
                     decActiveForegroundAppLocked(smap, r);
                 }
                 r.isForeground = false;
-                resetFgsRestrictionLocked(r);
                 ServiceState stracker = r.getTracker();
                 if (stracker != null) {
                     stracker.setForeground(false, mAm.mProcessStats.getMemFactorLocked(),
@@ -2160,7 +2118,12 @@ public final class ActiveServices {
                 }
             }
 
-            setFgsRestrictionLocked(callingPackage, callingPid, callingUid, s, false);
+            if (!s.mAllowWhileInUsePermissionInFgs) {
+                s.mAllowWhileInUsePermissionInFgs =
+                        shouldAllowWhileInUsePermissionInFgsLocked(callingPackage,
+                                callingPid, callingUid,
+                                service, s, false);
+            }
 
             if (s.app != null) {
                 if ((flags&Context.BIND_TREAT_LIKE_ACTIVITY) != 0) {
@@ -3456,7 +3419,7 @@ public final class ActiveServices {
         r.isForeground = false;
         r.foregroundId = 0;
         r.foregroundNoti = null;
-        resetFgsRestrictionLocked(r);
+        r.mAllowWhileInUsePermissionInFgs = false;
 
         // Clear start entries.
         r.clearDeliveredStartsLocked();
@@ -4937,7 +4900,7 @@ public final class ActiveServices {
      * @return true if allow, false otherwise.
      */
     private boolean shouldAllowWhileInUsePermissionInFgsLocked(String callingPackage,
-            int callingPid, int callingUid, ServiceRecord r,
+            int callingPid, int callingUid, Intent intent, ServiceRecord r,
             boolean allowBackgroundActivityStarts) {
         // Is the background FGS start restriction turned on?
         if (!mAm.mConstants.mFlagBackgroundFgsStartRestrictionEnabled) {
@@ -5019,32 +4982,4 @@ public final class ActiveServices {
         }
         return false;
     }
-
-    boolean canAllowWhileInUsePermissionInFgsLocked(int callingPid, int callingUid,
-            String callingPackage) {
-        return shouldAllowWhileInUsePermissionInFgsLocked(
-                callingPackage, callingPid, callingUid, null, false);
-    }
-
-    /**
-     * In R, mAllowWhileInUsePermissionInFgs is to allow while-in-use permissions in foreground
-     *  service or not. while-in-use permissions in FGS started from background might be restricted.
-     * @param callingPackage caller app's package name.
-     * @param callingUid caller app's uid.
-     * @param r the service to start.
-     * @return true if allow, false otherwise.
-     */
-    private void setFgsRestrictionLocked(String callingPackage,
-            int callingPid, int callingUid, ServiceRecord r,
-            boolean allowBackgroundActivityStarts) {
-        r.mLastSetFgsRestrictionTime = SystemClock.elapsedRealtime();
-        if (!r.mAllowWhileInUsePermissionInFgs) {
-            r.mAllowWhileInUsePermissionInFgs = shouldAllowWhileInUsePermissionInFgsLocked(
-                    callingPackage, callingPid, callingUid, r, allowBackgroundActivityStarts);
-        }
-    }
-
-    private void resetFgsRestrictionLocked(ServiceRecord r) {
-        r.mAllowWhileInUsePermissionInFgs = false;
-    }
 }
",21,86,"ActiveServices::setServiceForegroundInnerLocked, ActiveServices::shouldAllowWhileInUsePermissionInFgsLocked, ActiveServices::shouldAllowWhileInUsePermissionInFgsLocked, ActiveServices::resetFgsRestrictionLocked, ActiveServices::canAllowWhileInUsePermissionInFgsLocked, ActiveServices::bindServiceLocked, ActiveServices::bringDownServiceLocked, ActiveServices::startServiceLocked, ActiveServices::setFgsRestrictionLocked"
174,f2aeff22fcf2165087246ab161da639c474953b5,ActivityManagerConstants.java,"@@ -88,7 +88,6 @@ final class ActivityManagerConstants extends ContentObserver {
     static final String KEY_PROCESS_START_ASYNC = ""process_start_async"";
     static final String KEY_MEMORY_INFO_THROTTLE_TIME = ""memory_info_throttle_time"";
     static final String KEY_TOP_TO_FGS_GRACE_DURATION = ""top_to_fgs_grace_duration"";
-    static final String KEY_FGS_START_FOREGROUND_TIMEOUT = ""fgs_start_foreground_timeout"";
     static final String KEY_PENDINGINTENT_WARNING_THRESHOLD = ""pendingintent_warning_threshold"";
 
     private static final int DEFAULT_MAX_CACHED_PROCESSES = 32;
@@ -122,7 +121,6 @@ final class ActivityManagerConstants extends ContentObserver {
     private static final boolean DEFAULT_PROCESS_START_ASYNC = true;
     private static final long DEFAULT_MEMORY_INFO_THROTTLE_TIME = 5*60*1000;
     private static final long DEFAULT_TOP_TO_FGS_GRACE_DURATION = 15 * 1000;
-    private static final int DEFAULT_FGS_START_FOREGROUND_TIMEOUT_MS = 10 * 1000;
     private static final int DEFAULT_PENDINGINTENT_WARNING_THRESHOLD = 2000;
 
     // Flag stored in the DeviceConfig API.
@@ -275,12 +273,6 @@ final class ActivityManagerConstants extends ContentObserver {
     // this long.
     public long TOP_TO_FGS_GRACE_DURATION = DEFAULT_TOP_TO_FGS_GRACE_DURATION;
 
-    /**
-     * When service started from background, before the timeout it can be promoted to FGS by calling
-     * Service.startForeground().
-     */
-    volatile long mFgsStartForegroundTimeoutMs = DEFAULT_FGS_START_FOREGROUND_TIMEOUT_MS;
-
     // Indicates whether the activity starts logging is enabled.
     // Controlled by Settings.Global.ACTIVITY_STARTS_LOGGING_ENABLED
     volatile boolean mFlagActivityStartsLoggingEnabled;
@@ -429,9 +421,6 @@ final class ActivityManagerConstants extends ContentObserver {
                             case KEY_MIN_ASSOC_LOG_DURATION:
                                 updateMinAssocLogDuration();
                                 break;
-                            case KEY_FGS_START_FOREGROUND_TIMEOUT:
-                                updateFgsStartForegroundTimeout();
-                                break;
                             default:
                                 break;
                         }
@@ -708,13 +697,6 @@ final class ActivityManagerConstants extends ContentObserver {
                 /* defaultValue */ DEFAULT_MIN_ASSOC_LOG_DURATION);
     }
 
-    private void updateFgsStartForegroundTimeout() {
-        mFgsStartForegroundTimeoutMs = DeviceConfig.getLong(
-                DeviceConfig.NAMESPACE_ACTIVITY_MANAGER,
-                KEY_FGS_START_FOREGROUND_TIMEOUT,
-                DEFAULT_FGS_START_FOREGROUND_TIMEOUT_MS);
-    }
-
     void dump(PrintWriter pw) {
         pw.println(""ACTIVITY MANAGER SETTINGS (dumpsys activity settings) ""
                 + Settings.Global.ACTIVITY_MANAGER_CONSTANTS + "":"");
@@ -787,8 +769,6 @@ final class ActivityManagerConstants extends ContentObserver {
         pw.println(Arrays.toString(IMPERCEPTIBLE_KILL_EXEMPT_PACKAGES.toArray()));
         pw.print(""  ""); pw.print(KEY_MIN_ASSOC_LOG_DURATION); pw.print(""="");
         pw.println(MIN_ASSOC_LOG_DURATION);
-        pw.print(""  ""); pw.print(KEY_FGS_START_FOREGROUND_TIMEOUT); pw.print(""="");
-        pw.println(mFgsStartForegroundTimeoutMs);
 
         pw.println();
         if (mOverrideMaxCachedProcesses >= 0) {
",0,20,"ActivityManagerConstants::dump, ActivityManagerConstants::OnPropertiesChangedListener, ActivityManagerConstants::updateFgsStartForegroundTimeout"
175,f2aeff22fcf2165087246ab161da639c474953b5,ServiceRecord.java,"@@ -142,10 +142,6 @@ final class ServiceRecord extends Binder implements ComponentName.WithComponentN
     // allow while-in-use permissions in foreground service or not.
     // while-in-use permissions in FGS started from background might be restricted.
     boolean mAllowWhileInUsePermissionInFgs;
-    // The number of times Service.startForeground() is called;
-    int mStartForegroundCount;
-    // Last time mAllowWhileInUsePermissionInFgs is set.
-    long mLastSetFgsRestrictionTime;
 
     // the most recent package that start/bind this service.
     String mRecentCallingPackage;
@@ -410,8 +406,6 @@ final class ServiceRecord extends Binder implements ComponentName.WithComponentN
         }
         pw.print(prefix); pw.print(""allowWhileInUsePermissionInFgs="");
                 pw.println(mAllowWhileInUsePermissionInFgs);
-        pw.print(prefix); pw.print(""startForegroundCount="");
-        pw.println(mStartForegroundCount);
         pw.print(prefix); pw.print(""recentCallingPackage="");
                 pw.println(mRecentCallingPackage);
         if (delayed) {
",0,6,ServiceRecord::dump
176,a7e586e207b316ac0c8a89fefb04e1a2cafcbe2c,PowerNotificationWarnings.java,"@@ -18,6 +18,7 @@ package com.android.systemui.power;
 
 import android.app.KeyguardManager;
 import android.app.Notification;
+import android.app.NotificationChannel;
 import android.app.NotificationManager;
 import android.app.PendingIntent;
 import android.content.ActivityNotFoundException;
@@ -27,6 +28,7 @@ import android.content.Context;
 import android.content.DialogInterface;
 import android.content.Intent;
 import android.content.IntentFilter;
+import android.content.pm.PackageManager;
 import android.media.AudioAttributes;
 import android.net.Uri;
 import android.os.Bundle;
@@ -80,6 +82,8 @@ public class PowerNotificationWarnings implements PowerUI.WarningsUI {
     private static final String TAG = PowerUI.TAG + "".Notification"";
     private static final boolean DEBUG = PowerUI.DEBUG;
 
+    private static final String BATTERY_NOTIF_CHANNEL_ID_TV = ""powernotifications.battery.tv"";
+
     private static final String TAG_BATTERY = ""low_battery"";
     private static final String TAG_TEMPERATURE = ""high_temp"";
     private static final String TAG_AUTO_SAVER = ""auto_saver"";
@@ -167,6 +171,13 @@ public class PowerNotificationWarnings implements PowerUI.WarningsUI {
         mKeyguard = mContext.getSystemService(KeyguardManager.class);
         mReceiver.init();
         mActivityStarter = activityStarter;
+
+        if (isTv()) {
+            // TV-specific notification channel
+            mNoMan.createNotificationChannel(new NotificationChannel(BATTERY_NOTIF_CHANNEL_ID_TV,
+                    mContext.getString(R.string.battery_notification_channel_tv),
+                    NotificationManager.IMPORTANCE_HIGH));
+        }
     }
 
     @Override
@@ -234,6 +245,10 @@ public class PowerNotificationWarnings implements PowerUI.WarningsUI {
         }
     }
 
+    private boolean isTv() {
+        return mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_LEANBACK);
+    }
+
     private void showInvalidChargerNotification() {
         final Notification.Builder nb =
                 new Notification.Builder(mContext, NotificationChannels.ALERTS)
@@ -277,7 +292,9 @@ public class PowerNotificationWarnings implements PowerUI.WarningsUI {
                         .setOnlyAlertOnce(true)
                         .setDeleteIntent(pendingBroadcast(ACTION_DISMISSED_WARNING))
                         .setStyle(new Notification.BigTextStyle().bigText(contentText))
-                        .setVisibility(Notification.VISIBILITY_PUBLIC);
+                        .setVisibility(Notification.VISIBILITY_PUBLIC)
+                        .extend(new Notification.TvExtender()
+                                .setChannelId(BATTERY_NOTIF_CHANNEL_ID_TV));
         if (hasBatterySettings()) {
             nb.setContentIntent(pendingBroadcast(ACTION_SHOW_BATTERY_SETTINGS));
         }
",18,1,"PowerNotificationWarnings::showWarningNotification, PowerNotificationWarnings::PowerNotificationWarnings, PowerNotificationWarnings::isTv"
