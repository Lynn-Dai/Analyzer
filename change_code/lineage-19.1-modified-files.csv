,hash,filename,diff,added_lines,deleted_lines,changed_methods
0,23b641c5793bcbe559e56588016b9fb7555ae6ff,CollapsedStatusBarFragment.java,"@@ -231,7 +231,7 @@ public class CollapsedStatusBarFragment extends Fragment implements CommandQueue
         mBlockedIcons.addAll(Arrays.asList(getResources().getStringArray(
                 R.array.config_collapsed_statusbar_icon_blocklist)));
 
-        if (mSecureSettings.getInt(Settings.Secure.STATUS_BAR_SHOW_VIBRATE_ICON, 0) == 0) {
+        if (mSecureSettings.getInt(Settings.Secure.STATUS_BAR_SHOW_VIBRATE_ICON, 1) == 0) {
             mBlockedIcons.add(getString(com.android.internal.R.string.status_bar_volume));
         }
 
",1,1,CollapsedStatusBarFragment::updateBlockedIcons
1,ba528922c37f982e6533939b98852373848446a1,Dependency.java,"@@ -40,6 +40,7 @@ import com.android.systemui.accessibility.AccessibilityButtonTargetsObserver;
 import com.android.systemui.accessibility.floatingmenu.AccessibilityFloatingMenuController;
 import com.android.systemui.appops.AppOpsController;
 import com.android.systemui.assist.AssistManager;
+import com.android.systemui.biometrics.AuthController;
 import com.android.systemui.broadcast.BroadcastDispatcher;
 import com.android.systemui.colorextraction.SysuiColorExtractor;
 import com.android.systemui.dagger.SysUISingleton;
@@ -370,6 +371,7 @@ public class Dependency {
     @Inject Lazy<AmbientState> mAmbientStateLazy;
     @Inject Lazy<GroupMembershipManager> mGroupMembershipManagerLazy;
     @Inject Lazy<GroupExpansionManager> mGroupExpansionManagerLazy;
+    @Inject Lazy<AuthController> mAuthController;
 
     @Inject
     public Dependency() {
@@ -591,6 +593,8 @@ public class Dependency {
         mProviders.put(GroupMembershipManager.class, mGroupMembershipManagerLazy::get);
         mProviders.put(GroupExpansionManager.class, mGroupExpansionManagerLazy::get);
 
+        mProviders.put(AuthController.class, mAuthController::get);
+
         Dependency.setInstance(this);
     }
 
",4,0,Dependency::start
2,1726a9eda3299ea04660d5109fea4b55375f0798,OverlayManagerSettings.java,"@@ -235,8 +235,8 @@ final class OverlayManagerSettings {
     }
 
     private static boolean isImmutableFrameworkOverlay(@NonNull SettingsItem item) {
-        return !item.isMutable() && ""android"".equals(item.getTargetPackageName())
-               && ""lineageos.platform"".equals(item.getTargetPackageName());
+        return !item.isMutable() && (""android"".equals(item.getTargetPackageName())
+               || ""lineageos.platform"".equals(item.getTargetPackageName()));
     }
 
     /**
",2,2,OverlayManagerSettings::isImmutableFrameworkOverlay
3,9d31f5ad45805fd692ffd797dde13e6f16ed73e8,ScreenDecorations.java,"@@ -667,6 +667,13 @@ public class ScreenDecorations extends SystemUI implements Tunable {
             updateRoundedCornerRadii();
             if (DEBUG) Log.i(TAG, ""onConfigChanged from rot "" + oldRotation + "" to "" + mRotation);
             setupDecorations();
+            if (mCutoutViews != null) {
+                for (DisplayCutoutView dcv : mCutoutViews) {
+                    if (dcv != null) {
+                        dcv.update();
+                    }
+                }
+            }
             if (mOverlays != null) {
                 // Updating the layout params ensures that ViewRootImpl will call relayoutWindow(),
                 // which ensures that the forced seamless rotation will end, even if we updated
",7,0,ScreenDecorations::onConfigurationChanged
4,a5ca55c94e60a2036d1affb05072492a92b6b240,MediaOutputController.java,"@@ -494,7 +494,7 @@ public class MediaOutputController implements LocalMediaManager.DeviceCallback {
     }
 
     private boolean isPlayBackInfoLocal() {
-        return mMediaController.getPlaybackInfo() != null
+        return mMediaController != null && mMediaController.getPlaybackInfo() != null
                 && mMediaController.getPlaybackInfo().getPlaybackType()
                         == MediaController.PlaybackInfo.PLAYBACK_TYPE_LOCAL;
     }
",1,1,MediaOutputController::isPlayBackInfoLocal
5,1ce45bc32ce80fbe3c6cc2fb14ccfabc566347f4,ScreenshotController.java,"@@ -445,15 +445,8 @@ public class ScreenshotController {
      */
     void takeScreenshotPartial(ComponentName topComponent,
             final Consumer<Uri> finisher, RequestCallback requestCallback) {
-        mScreenshotView.reset();
-        mCurrentRequestCallback = requestCallback;
-
-        attachWindow();
-        mWindow.setContentView(mScreenshotView);
-        mScreenshotView.requestApplyInsets();
-
-        mScreenshotView.takePartialScreenshot(
-                rect -> takeScreenshotInternal(topComponent, finisher, rect));
+        startPartialScreenshotActivity();
+        finisher.accept(null);
     }
 
     /**
@@ -594,6 +587,13 @@ public class ScreenshotController {
         return screenshot;
     }
 
+    private Bitmap captureScreenshot() {
+        DisplayMetrics displayMetrics = new DisplayMetrics();
+        getDefaultDisplay().getRealMetrics(displayMetrics);
+        return captureScreenshot(
+                new Rect(0, 0, displayMetrics.widthPixels, displayMetrics.heightPixels));
+    }
+
     private void saveScreenshot(Bitmap screenshot, Consumer<Uri> finisher, Rect screenRect,
             Insets screenInsets, ComponentName topComponent, boolean showFlash) {
         if (mAccessibilityManager.isEnabled()) {
@@ -702,6 +702,40 @@ public class ScreenshotController {
                 onScrollCaptureResponseReady(mLastScrollCaptureRequest), mMainExecutor);
     }
 
+    public void startLongScreenshotActivity(ScrollCaptureController.LongScreenshot longScreenshot) {
+        mLongScreenshotHolder.setLongScreenshot(longScreenshot);
+        mLongScreenshotHolder.setTransitionDestinationCallback(
+                (transitionDestination, onTransitionEnd) ->
+                        mScreenshotView.startLongScreenshotTransition(
+                                transitionDestination, onTransitionEnd,
+                                longScreenshot));
+        mLongScreenshotHolder.setForegroundAppName(getForegroundAppLabel());
+
+        final Intent intent = new Intent(mContext, LongScreenshotActivity.class);
+        intent.setFlags(
+                Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP);
+
+        mContext.startActivity(intent,
+                ActivityOptions.makeCustomAnimation(mContext, 0, 0).toBundle());
+        RemoteAnimationAdapter runner = new RemoteAnimationAdapter(
+                SCREENSHOT_REMOTE_RUNNER, 0, 0);
+        try {
+            WindowManagerGlobal.getWindowManagerService()
+                    .overridePendingAppTransitionRemote(runner, DEFAULT_DISPLAY);
+        } catch (Exception e) {
+            Log.e(TAG, ""Error overriding screenshot app transition"", e);
+        }
+    }
+
+    private void startPartialScreenshotActivity() {
+        Bitmap newScreenshot = captureScreenshot();
+
+        ScrollCaptureController.BitmapScreenshot bitmapScreenshot =
+            new ScrollCaptureController.BitmapScreenshot(mContext, newScreenshot);
+
+        startLongScreenshotActivity(bitmapScreenshot);
+    }
+
     private void onScrollCaptureResponseReady(Future<ScrollCaptureResponse> responseFuture) {
         try {
             if (mLastScrollCaptureResponse != null) {
@@ -751,28 +785,7 @@ public class ScreenshotController {
                             return;
                         }
 
-                        mLongScreenshotHolder.setLongScreenshot(longScreenshot);
-                        mLongScreenshotHolder.setTransitionDestinationCallback(
-                                (transitionDestination, onTransitionEnd) ->
-                                        mScreenshotView.startLongScreenshotTransition(
-                                                transitionDestination, onTransitionEnd,
-                                                longScreenshot));
-                        mLongScreenshotHolder.setForegroundAppName(getForegroundAppLabel());
-
-                        final Intent intent = new Intent(mContext, LongScreenshotActivity.class);
-                        intent.setFlags(
-                                Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP);
-
-                        mContext.startActivity(intent,
-                                ActivityOptions.makeCustomAnimation(mContext, 0, 0).toBundle());
-                        RemoteAnimationAdapter runner = new RemoteAnimationAdapter(
-                                SCREENSHOT_REMOTE_RUNNER, 0, 0);
-                        try {
-                            WindowManagerGlobal.getWindowManagerService()
-                                    .overridePendingAppTransitionRemote(runner, DEFAULT_DISPLAY);
-                        } catch (Exception e) {
-                            Log.e(TAG, ""Error overriding screenshot app transition"", e);
-                        }
+                        startLongScreenshotActivity(longScreenshot);
                     }, mMainExecutor);
                 });
             });
",44,31,"ScreenshotController::onScrollCaptureResponseReady, ScreenshotController::startPartialScreenshotActivity, ScreenshotController::captureScreenshot, ScreenshotController::takeScreenshotPartial, ScreenshotController::startLongScreenshotActivity"
6,1ce45bc32ce80fbe3c6cc2fb14ccfabc566347f4,ScrollCaptureController.java,"@@ -20,6 +20,7 @@ import android.content.Context;
 import android.graphics.Bitmap;
 import android.graphics.Rect;
 import android.graphics.drawable.Drawable;
+import android.graphics.drawable.BitmapDrawable;
 import android.provider.Settings;
 import android.util.Log;
 import android.view.ScrollCaptureResponse;
@@ -136,6 +137,73 @@ public class ScrollCaptureController {
         }
     }
 
+    static class BitmapScreenshot extends LongScreenshot {
+        private final BitmapDrawable mBitmapDrawable;
+        private final Bitmap mBitmap;
+
+        BitmapScreenshot(Context context, Bitmap bitmap) {
+            super(null, null);
+
+            mBitmap = bitmap;
+            mBitmapDrawable = new BitmapDrawable(context.getResources(), bitmap);
+        }
+
+        @Override
+        public Bitmap toBitmap() {
+            return mBitmap;
+        }
+
+        @Override
+        public Bitmap toBitmap(Rect bounds) {
+            // Not used anywhere
+            return mBitmap;
+        }
+
+        @Override
+        public void release() {
+        }
+
+        @Override
+        public int getLeft() {
+            return 0;
+        }
+
+        @Override
+        public int getTop() {
+            return 0;
+        }
+
+        @Override
+        public int getBottom() {
+            return getHeight();
+        }
+
+        @Override
+        public int getWidth() {
+            return mBitmap.getWidth();
+        }
+
+        @Override
+        public int getHeight() {
+            return mBitmap.getHeight();
+        }
+
+        @Override
+        public int getPageHeight() {
+            return getHeight();
+        }
+
+        @Override
+        public String toString() {
+            return ""BitmapScrenshot{w="" + getWidth() + "", h="" + getHeight() + ""}"";
+        }
+
+        @Override
+        public Drawable getDrawable() {
+            return mBitmapDrawable;
+        }
+    }
+
     @Inject
     ScrollCaptureController(Context context, @Background Executor bgExecutor,
             ScrollCaptureClient client, ImageTileSet imageTileSet, UiEventLogger logger) {
",68,0,"ScrollCaptureController::BitmapScreenshot::getWidth, ScrollCaptureController::BitmapScreenshot::BitmapScreenshot, ScrollCaptureController::BitmapScreenshot::getHeight, ScrollCaptureController::BitmapScreenshot::getLeft, ScrollCaptureController::BitmapScreenshot::getDrawable, ScrollCaptureController::BitmapScreenshot::toBitmap, ScrollCaptureController::BitmapScreenshot::toBitmap, ScrollCaptureController::BitmapScreenshot::getBottom, ScrollCaptureController::BitmapScreenshot::toString, ScrollCaptureController::BitmapScreenshot::release, ScrollCaptureController::BitmapScreenshot::getTop, ScrollCaptureController::BitmapScreenshot::getPageHeight"
7,13429c61674c3b1cfbc71d5d22853cebbe7706a2,LongScreenshotActivity.java,"@@ -442,7 +442,6 @@ public class LongScreenshotActivity extends Activity {
             mCropView.setExtraPadding(extraPadding + mPreview.getPaddingTop(),
                     extraPadding + mPreview.getPaddingBottom());
             imageTop += (previewHeight - imageHeight) / 2;
-            mCropView.setExtraPadding(extraPadding, extraPadding);
             mCropView.setImageWidth(previewWidth);
             scale = previewWidth / (float) mPreview.getDrawable().getIntrinsicWidth();
         } else {
",0,1,LongScreenshotActivity::updateImageDimensions
8,e110cba8fecf449207bca80f8696fe73af1d6e31,CropView.java,"@@ -78,8 +78,6 @@ public class CropView extends View {
     private float mMovementStartValue;
     private float mStartingY;  // y coordinate of ACTION_DOWN
     private float mStartingX;
-    // The allowable values for the current boundary being dragged
-    private Range<Float> mMotionRange;
 
     // Value [0,1] indicating progress in animateEntrance()
     private float mEntranceInterpolation = 1f;
@@ -172,7 +170,6 @@ public class CropView extends View {
                     mStartingX = event.getX();
                     mMovementStartValue = getBoundaryPosition(mCurrentDraggingBoundary);
                     updateListener(MotionEvent.ACTION_DOWN, event.getX());
-                    mMotionRange = getAllowedValues(mCurrentDraggingBoundary);
                 }
                 return true;
             case MotionEvent.ACTION_MOVE:
@@ -185,8 +182,7 @@ public class CropView extends View {
                                 : event.getX(pointerIndex) - mStartingX;
                         float delta = pixelDistanceToFraction((int) deltaPx,
                                 mCurrentDraggingBoundary);
-                        setBoundaryPosition(mCurrentDraggingBoundary,
-                                mMotionRange.clamp(mMovementStartValue + delta));
+                        setBoundaryPosition(mCurrentDraggingBoundary, mMovementStartValue + delta);
                         updateListener(MotionEvent.ACTION_MOVE, event.getX(pointerIndex));
                         invalidate();
                     }
",1,5,CropView::onTouchEvent
9,834defa7e31a7d75de18de2fb148a7f845989830,CropView.java,"@@ -57,7 +57,10 @@ public class CropView extends View {
     private static final String TAG = ""CropView"";
 
     public enum CropBoundary {
-        NONE, TOP, BOTTOM, LEFT, RIGHT
+        NONE, TOP, BOTTOM, LEFT, RIGHT,
+        TOP_LEFT, TOP_RIGHT, BOTTOM_LEFT, BOTTOM_RIGHT,
+        // Middle crop boundary is used for dragging
+        MIDDLE,
     }
 
     private final float mCropTouchMargin;
@@ -75,7 +78,8 @@ public class CropView extends View {
     private CropBoundary mCurrentDraggingBoundary = CropBoundary.NONE;
     private int mActivePointerId;
     // The starting value of mCurrentDraggingBoundary's crop, used to compute touch deltas.
-    private float mMovementStartValue;
+    private float mMovementStartValueX;
+    private float mMovementStartValueY;
     private float mStartingY;  // y coordinate of ACTION_DOWN
     private float mStartingX;
 
@@ -168,7 +172,10 @@ public class CropView extends View {
                     mActivePointerId = event.getPointerId(0);
                     mStartingY = event.getY();
                     mStartingX = event.getX();
-                    mMovementStartValue = getBoundaryPosition(mCurrentDraggingBoundary);
+                    CropBoundary hBoundary = getHorizontalBoundary(mCurrentDraggingBoundary);
+                    CropBoundary vBoundary = getVerticalBoundary(mCurrentDraggingBoundary);
+                    mMovementStartValueX = getBoundaryPosition(hBoundary);
+                    mMovementStartValueY = getBoundaryPosition(vBoundary);
                     updateListener(MotionEvent.ACTION_DOWN, event.getX());
                 }
                 return true;
@@ -177,12 +184,14 @@ public class CropView extends View {
                     int pointerIndex = event.findPointerIndex(mActivePointerId);
                     if (pointerIndex >= 0) {
                         // Original pointer still active, do the move.
-                        float deltaPx = isVertical(mCurrentDraggingBoundary)
-                                ? event.getY(pointerIndex) - mStartingY
-                                : event.getX(pointerIndex) - mStartingX;
-                        float delta = pixelDistanceToFraction((int) deltaPx,
-                                mCurrentDraggingBoundary);
-                        setBoundaryPosition(mCurrentDraggingBoundary, mMovementStartValue + delta);
+                        CropBoundary hBoundary = getHorizontalBoundary(mCurrentDraggingBoundary);
+                        CropBoundary vBoundary = getVerticalBoundary(mCurrentDraggingBoundary);
+                        float deltaPxX = event.getX(pointerIndex) - mStartingX;
+                        float deltaPxY = event.getY(pointerIndex) - mStartingY;
+                        float deltaX = pixelDistanceToFraction((int) deltaPxX, hBoundary);
+                        float deltaY = pixelDistanceToFraction((int) deltaPxY, vBoundary);
+                        setBoundaryPosition(hBoundary, mMovementStartValueX + deltaX);
+                        setBoundaryPosition(vBoundary, mMovementStartValueY + deltaY);
                         updateListener(MotionEvent.ACTION_MOVE, event.getX(pointerIndex));
                         invalidate();
                     }
@@ -238,15 +247,29 @@ public class CropView extends View {
      * Set the given boundary to the given value without animation.
      */
     public void setBoundaryPosition(CropBoundary boundary, float position) {
+        if (boundary == CropBoundary.NONE) {
+            return;
+        }
+
         position = (float) getAllowedValues(boundary).clamp(position);
         switch (boundary) {
             case TOP:
+                if (mCurrentDraggingBoundary == CropBoundary.MIDDLE) {
+                    // If the current dragging boundary is the middle, reposition the bottom side of
+                    // the selection too, so that the selection appears to be moving.
+                    mCrop.bottom = position + (mCrop.bottom - mCrop.top);
+                }
                 mCrop.top = position;
                 break;
             case BOTTOM:
                 mCrop.bottom = position;
                 break;
             case LEFT:
+                if (mCurrentDraggingBoundary == CropBoundary.MIDDLE) {
+                    // If the current dragging boundary is the middle, reposition the right side of
+                    // the selection too, so that the selection appears to be moving.
+                    mCrop.right = position + (mCrop.right - mCrop.left);
+                }
                 mCrop.left = position;
                 break;
             case RIGHT:
@@ -274,6 +297,38 @@ public class CropView extends View {
         return 0;
     }
 
+    private CropBoundary getVerticalBoundary(CropBoundary boundary) {
+        switch (boundary) {
+            case TOP:
+            case TOP_LEFT:
+            case TOP_RIGHT:
+            case MIDDLE:
+                return CropBoundary.TOP;
+            case BOTTOM:
+            case BOTTOM_LEFT:
+            case BOTTOM_RIGHT:
+                return CropBoundary.BOTTOM;
+            default:
+                return CropBoundary.NONE;
+        }
+    }
+
+    private CropBoundary getHorizontalBoundary(CropBoundary boundary) {
+        switch (boundary) {
+            case LEFT:
+            case TOP_LEFT:
+            case BOTTOM_LEFT:
+            case MIDDLE:
+                return CropBoundary.LEFT;
+            case RIGHT:
+            case TOP_RIGHT:
+            case BOTTOM_RIGHT:
+                return CropBoundary.RIGHT;
+            default:
+                return CropBoundary.NONE;
+        }
+    }
+
     private static boolean isVertical(CropBoundary boundary) {
         return boundary == CropBoundary.TOP || boundary == CropBoundary.BOTTOM;
     }
@@ -349,6 +404,11 @@ public class CropView extends View {
     private Range getAllowedValues(CropBoundary boundary) {
         switch (boundary) {
             case TOP:
+                if (mCurrentDraggingBoundary == CropBoundary.MIDDLE) {
+                    // When the current dragging boundary is the middle, do not let the user move
+                    // the selection past the bottom edge.
+                    return new Range<>(0f, 1f - (mCrop.bottom - mCrop.top));
+                }
                 return new Range<>(0f,
                         mCrop.bottom - pixelDistanceToFraction(mCropTouchMargin,
                                 CropBoundary.BOTTOM));
@@ -357,6 +417,11 @@ public class CropView extends View {
                         mCrop.top + pixelDistanceToFraction(mCropTouchMargin,
                                 CropBoundary.TOP), 1f);
             case LEFT:
+                if (mCurrentDraggingBoundary == CropBoundary.MIDDLE) {
+                    // When the current dragging boundary is the middle, do not let the user move
+                    // the selection past the right edge.
+                    return new Range<>(0f, 1f - (mCrop.right - mCrop.left));
+                }
                 return new Range<>(0f,
                         mCrop.right - pixelDistanceToFraction(mCropTouchMargin,
                                 CropBoundary.RIGHT));
@@ -373,16 +438,17 @@ public class CropView extends View {
      * @param x coordinate of the relevant pointer.
      */
     private void updateListener(int action, float x) {
-        if (mCropInteractionListener != null && isVertical(mCurrentDraggingBoundary)) {
-            float boundaryPosition = getBoundaryPosition(mCurrentDraggingBoundary);
+        CropBoundary boundary = getVerticalBoundary(mCurrentDraggingBoundary);
+        if (mCropInteractionListener != null && boundary != CropBoundary.NONE) {
+            float boundaryPosition = getBoundaryPosition(boundary);
             switch (action) {
                 case MotionEvent.ACTION_DOWN:
-                    mCropInteractionListener.onCropDragStarted(mCurrentDraggingBoundary,
+                    mCropInteractionListener.onCropDragStarted(boundary,
                             boundaryPosition, fractionToVerticalPixels(boundaryPosition),
                             (mCrop.left + mCrop.right) / 2, x);
                     break;
                 case MotionEvent.ACTION_MOVE:
-                    mCropInteractionListener.onCropDragMoved(mCurrentDraggingBoundary,
+                    mCropInteractionListener.onCropDragMoved(boundary,
                             boundaryPosition, fractionToVerticalPixels(boundaryPosition),
                             (mCrop.left + mCrop.right) / 2, x);
                     break;
@@ -462,10 +528,25 @@ public class CropView extends View {
 
     private CropBoundary nearestBoundary(MotionEvent event, int topPx, int bottomPx, int leftPx,
             int rightPx) {
+        boolean isCloseToLeft = Math.abs(event.getX() - leftPx) < mCropTouchMargin;
+        boolean isCloseToRight = Math.abs(event.getX() - rightPx) < mCropTouchMargin;
+
         if (Math.abs(event.getY() - topPx) < mCropTouchMargin) {
+            if (isCloseToLeft) {
+                return CropBoundary.TOP_LEFT;
+            }
+            if (isCloseToRight) {
+                return CropBoundary.TOP_RIGHT;
+            }
             return CropBoundary.TOP;
         }
         if (Math.abs(event.getY() - bottomPx) < mCropTouchMargin) {
+            if (isCloseToLeft) {
+                return CropBoundary.BOTTOM_LEFT;
+            }
+            if (isCloseToRight) {
+                return CropBoundary.BOTTOM_RIGHT;
+            }
             return CropBoundary.BOTTOM;
         }
         if (event.getY() > topPx || event.getY() < bottomPx) {
@@ -476,6 +557,13 @@ public class CropView extends View {
                 return CropBoundary.RIGHT;
             }
         }
+
+        float x = event.getX();
+        float y = event.getY();
+        if (x > leftPx && x < rightPx && y > topPx && y < bottomPx) {
+            return CropBoundary.MIDDLE;
+        }
+
         return CropBoundary.NONE;
     }
 
",101,13,"CropView::getAllowedValues, CropView::getVerticalBoundary, CropView::updateListener, CropView::getHorizontalBoundary, CropView::setBoundaryPosition, CropView::onTouchEvent, CropView::nearestBoundary"
10,92abcecfe2bd5a84a601a5eafd3ddf75c3968d38,LongScreenshotActivity.java,"@@ -181,6 +181,7 @@ public class LongScreenshotActivity extends Activity {
             mCacheLoadFuture = null;
         } else {
             LongScreenshot longScreenshot = mLongScreenshotHolder.takeLongScreenshot();
+            setMagnification(mLongScreenshotHolder.getNeedsMagnification());
             if (longScreenshot != null) {
                 onLongScreenshotReceived(longScreenshot);
             } else {
@@ -190,6 +191,14 @@ public class LongScreenshotActivity extends Activity {
         }
     }
 
+    private void setMagnification(boolean status) {
+        if (status) {
+            mCropView.setCropInteractionListener(mMagnifierView);
+        } else {
+            mCropView.setCropInteractionListener(null);
+        }
+    }
+
     private void onLongScreenshotReceived(LongScreenshot longScreenshot) {
         Log.i(TAG, ""Completed: "" + longScreenshot);
         mLongScreenshot = longScreenshot;
",9,0,"LongScreenshotActivity::setMagnification, LongScreenshotActivity::onStart"
11,92abcecfe2bd5a84a601a5eafd3ddf75c3968d38,LongScreenshotData.java,"@@ -32,6 +32,7 @@ public class LongScreenshotData {
     private final AtomicReference<ScreenshotController.TransitionDestination>
             mTransitionDestinationCallback;
     private String mForegroundAppName;
+    private boolean mNeedsMagnification;
 
     @Inject
     public LongScreenshotData() {
@@ -88,4 +89,12 @@ public class LongScreenshotData {
     public String getForegroundAppName() {
         return mForegroundAppName;
     }
+
+    public void setNeedsMagnification(boolean status) {
+        mNeedsMagnification = status;
+    }
+
+    public boolean getNeedsMagnification() {
+        return mNeedsMagnification;
+    }
 }
",9,0,"LongScreenshotData::getNeedsMagnification, LongScreenshotData::setNeedsMagnification"
12,92abcecfe2bd5a84a601a5eafd3ddf75c3968d38,ScreenshotController.java,"@@ -733,6 +733,7 @@ public class ScreenshotController {
         ScrollCaptureController.BitmapScreenshot bitmapScreenshot =
             new ScrollCaptureController.BitmapScreenshot(mContext, newScreenshot);
 
+        mLongScreenshotHolder.setNeedsMagnification(false);
         startLongScreenshotActivity(bitmapScreenshot);
     }
 
@@ -785,6 +786,7 @@ public class ScreenshotController {
                             return;
                         }
 
+                        mLongScreenshotHolder.setNeedsMagnification(true);
                         startLongScreenshotActivity(longScreenshot);
                     }, mMainExecutor);
                 });
",2,0,"ScreenshotController::startPartialScreenshotActivity, ScreenshotController::onScrollCaptureResponseReady"
13,45cefae04e40dc0de22e2dcdfcb1854431055edb,ScreenshotController.java,"@@ -90,6 +90,7 @@ import android.window.WindowContext;
 import com.android.internal.app.ChooserActivity;
 import com.android.internal.logging.UiEventLogger;
 import com.android.internal.policy.PhoneWindow;
+import com.android.internal.statusbar.IStatusBarService;
 import com.android.settingslib.applications.InterestingConfigChanges;
 import com.android.systemui.R;
 import com.android.systemui.dagger.qualifiers.Main;
@@ -263,6 +264,7 @@ public class ScreenshotController {
     private final PhoneWindow mWindow;
     private final DisplayManager mDisplayManager;
     private final ScrollCaptureController mScrollCaptureController;
+    private final IStatusBarService mStatusBarService;
     private final LongScreenshotData mLongScreenshotHolder;
     private final Vibrator mVibrator;
     private final boolean mIsLowRamDevice;
@@ -341,6 +343,7 @@ public class ScreenshotController {
             ImageExporter imageExporter,
             @Main Executor mainExecutor,
             ScrollCaptureController scrollCaptureController,
+            IStatusBarService statusBarService,
             LongScreenshotData longScreenshotHolder,
             ActivityManager activityManager) {
         mScreenshotSmartActions = screenshotSmartActions;
@@ -350,6 +353,7 @@ public class ScreenshotController {
         mImageExporter = imageExporter;
         mMainExecutor = mainExecutor;
         mScrollCaptureController = scrollCaptureController;
+        mStatusBarService = statusBarService;
         mLongScreenshotHolder = longScreenshotHolder;
         mIsLowRamDevice = activityManager.isLowRamDevice();
         mBgExecutor = Executors.newSingleThreadExecutor();
@@ -725,6 +729,12 @@ public class ScreenshotController {
         } catch (Exception e) {
             Log.e(TAG, ""Error overriding screenshot app transition"", e);
         }
+
+        try {
+            mStatusBarService.collapsePanels();
+        } catch (RemoteException e) {
+            Log.e(TAG, ""Error during collapsing panels"", e);
+        }
     }
 
     private void startPartialScreenshotActivity() {
",10,0,"ScreenshotController::startLongScreenshotActivity, ScreenshotController::ScreenshotController"
14,484c59b972c1772f75a4b1b9fce7512eee517dcb,GlobalActionsDialogLite.java,"@@ -1131,8 +1131,7 @@ public class GlobalActionsDialogLite implements DialogInterface.OnDismissListene
             super(R.drawable.ic_screenshot, R.string.global_action_screenshot);
         }
 
-        @Override
-        public void onPress() {
+        private void takeScreenshot(int type) {
             // Add a little delay before executing, to give the
             // dialog a chance to go away before it takes a
             // screenshot.
@@ -1140,7 +1139,7 @@ public class GlobalActionsDialogLite implements DialogInterface.OnDismissListene
             mHandler.postDelayed(new Runnable() {
                 @Override
                 public void run() {
-                    mScreenshotHelper.takeScreenshot(TAKE_SCREENSHOT_FULLSCREEN, true, true,
+                    mScreenshotHelper.takeScreenshot(type, true, true,
                             SCREENSHOT_GLOBAL_ACTIONS, mHandler, null);
                     mMetricsLogger.action(MetricsEvent.ACTION_SCREENSHOT_POWER_MENU);
                     mUiEventLogger.log(GlobalActionsEvent.GA_SCREENSHOT_PRESS);
@@ -1148,10 +1147,15 @@ public class GlobalActionsDialogLite implements DialogInterface.OnDismissListene
             }, mDialogPressDelay);
         }
 
+        @Override
+        public void onPress() {
+            takeScreenshot(TAKE_SCREENSHOT_FULLSCREEN);
+        }
+
         @Override
         public boolean onLongPress() {
-            mScreenshotHelper.takeScreenshot(TAKE_SCREENSHOT_SELECTED_REGION, true, true,
-                    SCREENSHOT_GLOBAL_ACTIONS, mHandler, null);
+            takeScreenshot(TAKE_SCREENSHOT_SELECTED_REGION);
+
             return true;
         }
 
",9,5,"GlobalActionsDialogLite::ScreenshotAction::onPress, GlobalActionsDialogLite::ScreenshotAction::takeScreenshot, GlobalActionsDialogLite::ScreenshotAction::onLongPress"
15,1b62ea8bfae85099b20f48509f97f37d70149b43,FragmentHostManager.java,"@@ -53,7 +53,8 @@ public class FragmentHostManager {
     private final View mRootView;
     private final InterestingConfigChanges mConfigChanges = new InterestingConfigChanges(
             ActivityInfo.CONFIG_FONT_SCALE | ActivityInfo.CONFIG_LOCALE
-                | ActivityInfo.CONFIG_SCREEN_LAYOUT | ActivityInfo.CONFIG_ASSETS_PATHS);
+                | ActivityInfo.CONFIG_SCREEN_LAYOUT | ActivityInfo.CONFIG_ASSETS_PATHS
+                | ActivityInfo.CONFIG_UI_MODE);
     private final FragmentService mManager;
     private final ExtensionFragmentManager mPlugins = new ExtensionFragmentManager();
 
",2,1,
16,3e99d1767968a27405a5656a47c6bc87c12d684c,ScrimController.java,"@@ -704,7 +704,7 @@ public class ScrimController implements ViewTreeObserver.OnPreDrawListener, Dump
                 mNotificationsAlpha = behindAlpha;
                 mNotificationsTint = behindTint;
                 mBehindAlpha = 1;
-                mBehindTint = Color.BLACK;
+                mBehindTint = Color.TRANSPARENT;
             } else {
                 mBehindAlpha = behindAlpha;
                 if (mState == ScrimState.SHADE_LOCKED) {
",1,1,ScrimController::applyState
17,3e99d1767968a27405a5656a47c6bc87c12d684c,ScrimState.java,"@@ -82,7 +82,7 @@ public enum ScrimState {
             mBehindAlpha = mClipQsScrim ? 1 : mScrimBehindAlphaKeyguard;
             mNotifAlpha = mClipQsScrim ? mScrimBehindAlphaKeyguard : 0;
             if (mClipQsScrim) {
-                updateScrimColor(mScrimBehind, 1f /* alpha */, Color.BLACK);
+                updateScrimColor(mScrimBehind, 1f /* alpha */, Color.TRANSPARENT);
             }
         }
     },
@@ -119,7 +119,7 @@ public enum ScrimState {
         @Override
         public void prepare(ScrimState previousState) {
             mBehindAlpha = mClipQsScrim ? 1 : mDefaultScrimAlpha;
-            mBehindTint = mClipQsScrim ? Color.BLACK : Color.TRANSPARENT;
+            mBehindTint = Color.TRANSPARENT;
             mNotifAlpha = mClipQsScrim ? mDefaultScrimAlpha : 0;
             mNotifTint = Color.TRANSPARENT;
             mFrontAlpha = 0f;
@@ -143,17 +143,17 @@ public enum ScrimState {
             mBehindAlpha = mClipQsScrim ? 1 : mDefaultScrimAlpha;
             mNotifAlpha = 1f;
             mFrontAlpha = 0f;
-            mBehindTint = Color.BLACK;
+            mBehindTint = Color.TRANSPARENT;
 
             if (mClipQsScrim) {
-                updateScrimColor(mScrimBehind, 1f /* alpha */, Color.BLACK);
+                updateScrimColor(mScrimBehind, 1f /* alpha */, Color.TRANSPARENT);
             }
         }
 
         // to make sure correct color is returned before ""prepare"" is called
         @Override
         public int getBehindTint() {
-            return Color.BLACK;
+            return Color.TRANSPARENT;
         }
     },
 
@@ -244,22 +244,22 @@ public enum ScrimState {
             mAnimateChange = !mLaunchingAffordanceWithPreview && !fromAod;
 
             mFrontTint = Color.TRANSPARENT;
-            mBehindTint = Color.BLACK;
+            mBehindTint = Color.TRANSPARENT;
             mBlankScreen = false;
 
             if (previousState == ScrimState.AOD) {
                 // Set all scrims black, before they fade transparent.
                 updateScrimColor(mScrimInFront, 1f /* alpha */, Color.BLACK /* tint */);
-                updateScrimColor(mScrimBehind, 1f /* alpha */, Color.BLACK /* tint */);
+                updateScrimColor(mScrimBehind, 1f /* alpha */, Color.TRANSPARENT /* tint */);
 
                 // Scrims should still be black at the end of the transition.
                 mFrontTint = Color.BLACK;
-                mBehindTint = Color.BLACK;
+                mBehindTint = Color.TRANSPARENT;
                 mBlankScreen = true;
             }
 
             if (mClipQsScrim) {
-                updateScrimColor(mScrimBehind, 1f /* alpha */, Color.BLACK);
+                updateScrimColor(mScrimBehind, 1f /* alpha */, Color.TRANSPARENT);
             }
         }
     };
",9,9,"prepare, getBehindTint"
18,13ddb603f5c0cfd8cd8999938b55fd06991c5133,QSTile.java,"@@ -148,7 +148,7 @@ public interface QSTile {
     @ProvidesInterface(version = State.VERSION)
     public static class State {
         public static final int VERSION = 1;
-        public static final int DEFAULT_STATE = Tile.STATE_ACTIVE;
+        public static final int DEFAULT_STATE = Tile.STATE_INACTIVE;
 
         public Icon icon;
         public Supplier<Icon> iconSupplier;
",1,1,
19,efdefe7d7daf1d403b11a1d5fcd391000e8d2047,ScrimController.java,"@@ -180,6 +180,7 @@ public class ScrimController implements ViewTreeObserver.OnPreDrawListener, Dump
     private UnlockedScreenOffAnimationController mUnlockedScreenOffAnimationController;
 
     private GradientColors mColors;
+    private GradientColors mBehindColors;
     private boolean mNeedsDrawableColorUpdate;
 
     private float mScrimBehindAlphaKeyguard = KEYGUARD_SCRIM_ALPHA;
@@ -276,6 +277,7 @@ public class ScrimController implements ViewTreeObserver.OnPreDrawListener, Dump
         );
 
         mColors = new GradientColors();
+        mBehindColors = new GradientColors();
     }
 
     /**
@@ -874,7 +876,7 @@ public class ScrimController implements ViewTreeObserver.OnPreDrawListener, Dump
                     && !mBlankScreen;
 
             mScrimInFront.setColors(mColors, animateScrimInFront);
-            mScrimBehind.setColors(mColors, animateBehindScrim);
+            mScrimBehind.setColors(mBehindColors, animateBehindScrim);
             mNotificationsScrim.setColors(mColors, animateScrimNotifications);
 
             dispatchBackScrimState(mScrimBehind.getViewAlpha());
@@ -1214,11 +1216,19 @@ public class ScrimController implements ViewTreeObserver.OnPreDrawListener, Dump
         if (mScrimBehind == null) return;
         int background = Utils.getColorAttr(mScrimBehind.getContext(),
                 android.R.attr.colorBackgroundFloating).getDefaultColor();
+        int surfaceBackground = Utils.getColorAttr(mScrimBehind.getContext(),
+                com.android.internal.R.attr.colorSurfaceHeader).getDefaultColor();
         int accent = Utils.getColorAccent(mScrimBehind.getContext()).getDefaultColor();
         mColors.setMainColor(background);
         mColors.setSecondaryColor(accent);
         mColors.setSupportsDarkText(
                 ColorUtils.calculateContrast(mColors.getMainColor(), Color.WHITE) > 4.5);
+
+        mBehindColors.setMainColor(surfaceBackground);
+        mBehindColors.setSecondaryColor(accent);
+        mBehindColors.setSupportsDarkText(
+                ColorUtils.calculateContrast(mBehindColors.getMainColor(), Color.WHITE) > 4.5);
+
         mNeedsDrawableColorUpdate = true;
     }
 
",11,1,"ScrimController::updateScrims, ScrimController::updateThemeColors, ScrimController::ScrimController"
20,643d46cefd3548dab0b55cadfb52c5d7247d601c,QuickStatusBarHeader.java,"@@ -198,7 +198,7 @@ public class QuickStatusBarHeader extends FrameLayout implements TunerService.Tu
         super.onMeasure(widthMeasureSpec, heightMeasureSpec);
         if (mDatePrivacyView.getMeasuredHeight() != mTopViewMeasureHeight) {
             mTopViewMeasureHeight = mDatePrivacyView.getMeasuredHeight();
-            post(this::updateAnimators);
+            updateAnimators();
         }
     }
 
",1,1,QuickStatusBarHeader::onMeasure
21,2f6486cc1099224384bebd611cea9e5291f08a6d,PagedTileLayout.java,"@@ -111,12 +111,16 @@ public class PagedTileLayout extends ViewPager implements QSTileLayout {
 
     @Override
     public int getTilesHeight() {
-        // Use the first page as that is the maximum height we need to show.
-        TileLayout tileLayout = mPages.get(0);
-        if (tileLayout == null) {
-            return 0;
+        // Find the maximum height among all pages.
+        int height = 0;
+        for (int i = 0; i < mPages.size(); i++) {
+            TileLayout tileLayout = mPages.get(i);
+            if (tileLayout != null) {
+                height = Math.max(height, tileLayout.getTilesHeight());
+            }
         }
-        return tileLayout.getTilesHeight();
+        if (DEBUG) Log.d(TAG, ""getTilesHeight ret="" + height);
+        return height;
     }
 
     @Override
",9,5,PagedTileLayout::getTilesHeight
22,22b7fd2e39b0e133437788f234a978144b06485d,GlobalActionsDialogLite.java,"@@ -787,6 +787,15 @@ public class GlobalActionsDialogLite implements DialogInterface.OnDismissListene
                 && (currentUser == null || currentUser.isPrimary());
     }
 
+    @Override
+    public void onUiModeChanged() {
+        // Colors may change, depending on UI mode
+        mContext.getTheme().applyStyle(mContext.getThemeResId(), true);
+        if (mDialog != null && mDialog.isShowing()) {
+            mDialog.refreshDialog();
+        }
+    }
+
     @Override
     public void onConfigChanged(Configuration newConfig) {
         if (mDialog != null && mDialog.isShowing()
",9,0,GlobalActionsDialogLite::onUiModeChanged
23,3367784f32d5faced63c893824bb996f39bfa9d3,ThemeOverlayController.java,"@@ -66,6 +66,8 @@ import com.android.systemui.flags.FeatureFlags;
 import com.android.systemui.keyguard.WakefulnessLifecycle;
 import com.android.systemui.monet.ColorScheme;
 import com.android.systemui.settings.UserTracker;
+import com.android.systemui.statusbar.policy.ConfigurationController;
+import com.android.systemui.statusbar.policy.ConfigurationController.ConfigurationListener;
 import com.android.systemui.statusbar.policy.DeviceProvisionedController;
 import com.android.systemui.statusbar.policy.DeviceProvisionedController.DeviceProvisionedListener;
 import com.android.systemui.util.settings.SecureSettings;
@@ -111,6 +113,7 @@ public class ThemeOverlayController extends SystemUI implements Dumpable {
     private final Handler mBgHandler;
     private final boolean mIsMonetEnabled;
     private final UserTracker mUserTracker;
+    private final ConfigurationController mConfigurationController;
     private final DeviceProvisionedController mDeviceProvisionedController;
     // Current wallpaper colors associated to a user.
     private final SparseArray<WallpaperColors> mCurrentColors = new SparseArray<>();
@@ -139,6 +142,15 @@ public class ThemeOverlayController extends SystemUI implements Dumpable {
     // Determines if we should ignore THEME_CUSTOMIZATION_OVERLAY_PACKAGES setting changes.
     private boolean mSkipSettingChange;
 
+    private final ConfigurationListener mConfigurationListener =
+            new ConfigurationListener() {
+                @Override
+                public void onUiModeChanged() {
+                    Log.i(TAG, ""Re-applying theme on UI change"");
+                    reevaluateSystemTheme(true /* forceReload */);
+                }
+            };
+
     private final DeviceProvisionedListener mDeviceProvisionedListener =
             new DeviceProvisionedListener() {
                 @Override
@@ -342,10 +354,12 @@ public class ThemeOverlayController extends SystemUI implements Dumpable {
             SecureSettings secureSettings, WallpaperManager wallpaperManager,
             UserManager userManager, DeviceProvisionedController deviceProvisionedController,
             UserTracker userTracker, DumpManager dumpManager, FeatureFlags featureFlags,
-            WakefulnessLifecycle wakefulnessLifecycle) {
+            WakefulnessLifecycle wakefulnessLifecycle, ConfigurationController
+            configurationController) {
         super(context);
 
         mIsMonetEnabled = featureFlags.isMonetEnabled();
+        mConfigurationController = configurationController;
         mDeviceProvisionedController = deviceProvisionedController;
         mBroadcastDispatcher = broadcastDispatcher;
         mUserManager = userManager;
@@ -400,6 +414,7 @@ public class ThemeOverlayController extends SystemUI implements Dumpable {
 
         mUserTracker.addCallback(mUserTrackerCallback, mMainExecutor);
 
+        mConfigurationController.addCallback(mConfigurationListener);
         mDeviceProvisionedController.addCallback(mDeviceProvisionedListener);
 
         // Upon boot, make sure we have the most up to date colors
",16,1,"ThemeOverlayController::ThemeOverlayController, ThemeOverlayController::ConfigurationListener, ThemeOverlayController::start, ThemeOverlayController::ThemeOverlayController"
24,2efc6aaec9b71e0e0d1a050cedce746edc38a74e,QuickStatusBarHeader.java,"@@ -18,10 +18,12 @@ import static android.app.StatusBarManager.DISABLE2_QUICK_SETTINGS;
 import static android.view.ViewGroup.LayoutParams.WRAP_CONTENT;
 
 import android.content.Context;
+import android.content.Intent;
 import android.content.res.Configuration;
 import android.content.res.Resources;
 import android.graphics.Color;
 import android.graphics.Rect;
+import android.provider.AlarmClock;
 import android.util.AttributeSet;
 import android.util.Pair;
 import android.view.DisplayCutout;
@@ -39,6 +41,7 @@ import com.android.settingslib.Utils;
 import com.android.systemui.Dependency;
 import com.android.systemui.R;
 import com.android.systemui.battery.BatteryMeterView;
+import com.android.systemui.plugins.ActivityStarter;
 import com.android.systemui.qs.QSDetail.Callback;
 import com.android.systemui.statusbar.phone.StatusBarContentInsetsProvider;
 import com.android.systemui.statusbar.phone.StatusBarIconController;
@@ -64,6 +67,8 @@ public class QuickStatusBarHeader extends FrameLayout implements TunerService.Tu
     private TouchAnimator mIconsAlphaAnimator;
     private TouchAnimator mIconsAlphaAnimatorFixed;
 
+    private final ActivityStarter mActivityStarter;
+
     protected QuickQSPanel mHeaderQsPanel;
     private View mDatePrivacyView;
     private View mDateView;
@@ -110,6 +115,7 @@ public class QuickStatusBarHeader extends FrameLayout implements TunerService.Tu
 
     public QuickStatusBarHeader(Context context, AttributeSet attrs) {
         super(context, attrs);
+        mActivityStarter = Dependency.get(ActivityStarter.class);
     }
 
     /**
@@ -142,9 +148,15 @@ public class QuickStatusBarHeader extends FrameLayout implements TunerService.Tu
 
         mClockContainer = findViewById(R.id.clock_container);
         mClockView = findViewById(R.id.clock);
+        mClockView.setOnClickListener(
+                v -> mActivityStarter.postStartActivityDismissingKeyguard(
+                        new Intent(AlarmClock.ACTION_SHOW_ALARMS), 0));
         mDatePrivacySeparator = findViewById(R.id.space);
         // Tint for the battery icons are handled in setupHost()
         mBatteryRemainingIcon = findViewById(R.id.batteryRemainingIcon);
+        mBatteryRemainingIcon.setOnClickListener(
+                v -> mActivityStarter.postStartActivityDismissingKeyguard(
+                        new Intent(Intent.ACTION_POWER_USAGE_SUMMARY), 0));
 
         updateResources();
         Configuration config = mContext.getResources().getConfiguration();
",12,0,"QuickStatusBarHeader::onFinishInflate, QuickStatusBarHeader::QuickStatusBarHeader"
25,aa8742f84e8a269409d97b8385f0601d7df9e0b1,VolumeDialogImpl.java,"@@ -1579,7 +1579,9 @@ public class VolumeDialogImpl implements VolumeDialog,
                     mDialog.dismiss();
                     tryToRemoveCaptionsTooltip();
                     mExpanded = false;
-                    mExpandRows.setExpanded(mExpanded);
+                    if (mExpandRows != null) {
+                        mExpandRows.setExpanded(mExpanded);
+                    }
                     mAnimatingRows = 0;
                     mDefaultRow = null;
                     mIsAnimatingDismiss = false;
",3,1,VolumeDialogImpl::dismissH
26,83340a2f4915f90d76ec23d51bc1c7d8e8d26a3c,StatusBarMobileView.java,"@@ -186,7 +186,7 @@ public class StatusBarMobileView extends FrameLayout implements DarkReceiver,
 
         setContentDescription(state.contentDescription);
         int newVisibility = state.visible && !mForceHidden ? View.VISIBLE : View.GONE;
-        if (newVisibility != mMobileGroup.getVisibility()) {
+        if (newVisibility != mMobileGroup.getVisibility() && STATE_ICON == mVisibleState) {
             mMobileGroup.setVisibility(newVisibility);
             needsLayout = true;
         }
",1,1,StatusBarMobileView::updateState
27,faf136b1bdd0464352e654f58e751c0c19feaf96,ThemeOverlayController.java,"@@ -71,6 +71,9 @@ import com.android.systemui.statusbar.policy.ConfigurationController.Configurati
 import com.android.systemui.statusbar.policy.DeviceProvisionedController;
 import com.android.systemui.statusbar.policy.DeviceProvisionedController.DeviceProvisionedListener;
 import com.android.systemui.util.settings.SecureSettings;
+import com.android.systemui.util.settings.SystemSettings;
+
+import lineageos.providers.LineageSettings;
 
 import org.json.JSONException;
 import org.json.JSONObject;
@@ -99,6 +102,8 @@ import javax.inject.Inject;
 @SysUISingleton
 public class ThemeOverlayController extends SystemUI implements Dumpable {
     protected static final String TAG = ""ThemeOverlayController"";
+    protected static final String OVERLAY_BERRY_BLACK_THEME =
+            ""org.lineageos.overlay.customization.blacktheme"";
     private static final boolean DEBUG = true;
 
     protected static final int NEUTRAL = 0;
@@ -109,6 +114,7 @@ public class ThemeOverlayController extends SystemUI implements Dumpable {
     private final BroadcastDispatcher mBroadcastDispatcher;
     private final Executor mBgExecutor;
     private final SecureSettings mSecureSettings;
+    private final SystemSettings mSystemSettings;
     private final Executor mMainExecutor;
     private final Handler mBgHandler;
     private final boolean mIsMonetEnabled;
@@ -245,6 +251,11 @@ public class ThemeOverlayController extends SystemUI implements Dumpable {
         return false;
     }
 
+    private boolean isNightMode() {
+        return (mContext.getResources().getConfiguration().uiMode
+                & Configuration.UI_MODE_NIGHT_MASK) == Configuration.UI_MODE_NIGHT_YES;
+    }
+
     private void handleWallpaperColors(WallpaperColors wallpaperColors, int flags, int userId) {
         final int currentUser = mUserTracker.getUserId();
         final boolean hadWallpaperColors = mCurrentColors.get(userId) != null;
@@ -355,7 +366,7 @@ public class ThemeOverlayController extends SystemUI implements Dumpable {
             UserManager userManager, DeviceProvisionedController deviceProvisionedController,
             UserTracker userTracker, DumpManager dumpManager, FeatureFlags featureFlags,
             WakefulnessLifecycle wakefulnessLifecycle, ConfigurationController
-            configurationController) {
+            configurationController, SystemSettings systemSettings) {
         super(context);
 
         mIsMonetEnabled = featureFlags.isMonetEnabled();
@@ -368,6 +379,7 @@ public class ThemeOverlayController extends SystemUI implements Dumpable {
         mBgHandler = bgHandler;
         mThemeManager = themeOverlayApplier;
         mSecureSettings = secureSettings;
+        mSystemSettings = systemSettings;
         mWallpaperManager = wallpaperManager;
         mUserTracker = userTracker;
         mWakefulnessLifecycle = wakefulnessLifecycle;
@@ -408,6 +420,27 @@ public class ThemeOverlayController extends SystemUI implements Dumpable {
                 },
                 UserHandle.USER_ALL);
 
+        mSystemSettings.registerContentObserverForUser(
+                LineageSettings.System.getUriFor(LineageSettings.System.BERRY_BLACK_THEME),
+                false,
+                new ContentObserver(mBgHandler) {
+                    @Override
+                    public void onChange(boolean selfChange, Collection<Uri> collection, int flags,
+                            int userId) {
+                        if (DEBUG) Log.d(TAG, ""Overlay changed for user: "" + userId);
+                        if (mUserTracker.getUserId() != userId) {
+                            return;
+                        }
+                        if (!mDeviceProvisionedController.isUserSetup(userId)) {
+                            Log.i(TAG, ""Theme application deferred when setting changed."");
+                            mDeferredThemeEvaluation = true;
+                            return;
+                        }
+                        reevaluateSystemTheme(true /* forceReload */);
+                    }
+                },
+                UserHandle.USER_ALL);
+
         if (!mIsMonetEnabled) {
             return;
         }
@@ -507,10 +540,7 @@ public class ThemeOverlayController extends SystemUI implements Dumpable {
      * Given a color candidate, return an overlay definition.
      */
     protected @Nullable FabricatedOverlay getOverlay(int color, int type) {
-        boolean nightMode = (mContext.getResources().getConfiguration().uiMode
-                & Configuration.UI_MODE_NIGHT_MASK) == Configuration.UI_MODE_NIGHT_YES;
-
-        mColorScheme = new ColorScheme(color, nightMode);
+        mColorScheme = new ColorScheme(color, isNightMode());
         List<Integer> colorShades = type == ACCENT
                 ? mColorScheme.getAllAccentColors() : mColorScheme.getAllNeutralColors();
         String name = type == ACCENT ? ""accent"" : ""neutral"";
@@ -625,6 +655,14 @@ public class ThemeOverlayController extends SystemUI implements Dumpable {
             categoryToPackage.put(OVERLAY_CATEGORY_ACCENT_COLOR, mSecondaryOverlay.getIdentifier());
         }
 
+        boolean isBlackMode = (LineageSettings.System.getIntForUser(
+                mContext.getContentResolver(), LineageSettings.System.BERRY_BLACK_THEME,
+                0, currentUser) == 1) && isNightMode();
+        if (categoryToPackage.containsKey(OVERLAY_CATEGORY_SYSTEM_PALETTE) && isBlackMode) {
+            OverlayIdentifier blackTheme = new OverlayIdentifier(OVERLAY_BERRY_BLACK_THEME);
+            categoryToPackage.put(OVERLAY_CATEGORY_SYSTEM_PALETTE, blackTheme);
+        }
+
         Set<UserHandle> managedProfiles = new HashSet<>();
         for (UserInfo userInfo : mUserManager.getEnabledProfiles(currentUser)) {
             if (userInfo.isManagedProfile()) {
",43,5,"ThemeOverlayController::isNightMode, ThemeOverlayController::ThemeOverlayController, ThemeOverlayController::updateThemeOverlays, ThemeOverlayController::start, ThemeOverlayController::ThemeOverlayController, ThemeOverlayController::getOverlay"
28,100058582558ae6500303c8c4af54561da4e75c6,DozeSensors.java,"@@ -492,6 +492,7 @@ public class DozeSensors {
         private final boolean mSettingDefault;
         private final boolean mRequiresTouchscreen;
         private final boolean mRequiresProx;
+        private final boolean mPerformsProxCheck;
 
         protected boolean mRequested;
         protected boolean mRegistered;
@@ -506,6 +507,26 @@ public class DozeSensors {
                 int pulseReason,
                 boolean reportsTouchCoordinates,
                 boolean requiresTouchscreen
+        ) {
+            this(
+                sensor,
+                setting,
+                configured,
+                pulseReason,
+                reportsTouchCoordinates,
+                requiresTouchscreen,
+                true
+            );
+        }
+
+        TriggerSensor(
+                Sensor sensor,
+                String setting,
+                boolean configured,
+                int pulseReason,
+                boolean reportsTouchCoordinates,
+                boolean requiresTouchscreen,
+                boolean performsProxCheck
         ) {
             this(
                     sensor,
@@ -516,7 +537,8 @@ public class DozeSensors {
                     reportsTouchCoordinates,
                     requiresTouchscreen,
                     false /* ignoresSetting */,
-                    false /* requiresProx */
+                    false /* requiresProx */,
+                    performsProxCheck
             );
         }
 
@@ -530,6 +552,32 @@ public class DozeSensors {
                 boolean requiresTouchscreen,
                 boolean ignoresSetting,
                 boolean requiresProx
+        ) {
+            this(
+                    sensor,
+                    setting,
+                    settingDef,
+                    configured,
+                    pulseReason,
+                    reportsTouchCoordinates,
+                    requiresTouchscreen,
+                    ignoresSetting,
+                    requiresProx,
+                    true
+            );
+        }
+
+        TriggerSensor(
+                Sensor sensor,
+                String setting,
+                boolean settingDef,
+                boolean configured,
+                int pulseReason,
+                boolean reportsTouchCoordinates,
+                boolean requiresTouchscreen,
+                boolean ignoresSetting,
+                boolean requiresProx,
+                boolean performsProxCheck
         ) {
             this(
                     new Sensor[]{ sensor },
@@ -541,6 +589,7 @@ public class DozeSensors {
                     requiresTouchscreen,
                     ignoresSetting,
                     requiresProx,
+                    performsProxCheck,
                     DevicePostureController.DEVICE_POSTURE_UNKNOWN
             );
         }
@@ -556,6 +605,34 @@ public class DozeSensors {
                 boolean ignoresSetting,
                 boolean requiresProx,
                 @DevicePostureController.DevicePostureInt int posture
+        ) {
+            this(
+                    sensors,
+                    setting,
+                    settingDef,
+                    configured,
+                    pulseReason,
+                    reportsTouchCoordinates,
+                    requiresTouchscreen,
+                    ignoresSetting,
+                    requiresProx,
+                    true,
+                    posture
+            );
+        }
+
+        TriggerSensor(
+                @NonNull Sensor[] sensors,
+                String setting,
+                boolean settingDef,
+                boolean configured,
+                int pulseReason,
+                boolean reportsTouchCoordinates,
+                boolean requiresTouchscreen,
+                boolean ignoresSetting,
+                boolean requiresProx,
+                boolean performsProxCheck,
+                @DevicePostureController.DevicePostureInt int posture
         ) {
             mSensors = sensors;
             mSetting = setting;
@@ -566,6 +643,7 @@ public class DozeSensors {
             mRequiresTouchscreen = requiresTouchscreen;
             mIgnoresSetting = ignoresSetting;
             mRequiresProx = requiresProx;
+            mPerformsProxCheck = performsProxCheck;
             mPosture = posture;
         }
 
@@ -701,13 +779,23 @@ public class DozeSensors {
                     screenX = event.values[0];
                     screenY = event.values[1];
                 }
-                mSensorCallback.onSensorPulse(mPulseReason, screenX, screenY, event.values);
+                mSensorCallback.onSensorPulse(mPulseReason, mPerformsProxCheck,
+                        screenX, screenY, event.values);
                 if (!mRegistered) {
                     updateListening();  // reregister, this sensor only fires once
                 }
             }));
         }
 
+        /**
+         * If the sensor itself performs proximity checks, to avoid pocket dialing.
+         * Gated sensors don't need to be stopped when the {@link DozeMachine} is
+         * {@link DozeMachine.State#DOZE_AOD_PAUSED}.
+         */
+        public boolean performsProxCheck() {
+            return mPerformsProxCheck;
+        }
+
         public void registerSettingsObserver(ContentObserver settingsObserver) {
             if (mConfigured && !TextUtils.isEmpty(mSetting)) {
                 mSecureSettings.registerContentObserverForUser(
@@ -802,7 +890,8 @@ public class DozeSensors {
                     return;
                 }
                 if (DEBUG) Log.d(TAG, ""onSensorEvent: "" + triggerEventToString(event));
-                mSensorCallback.onSensorPulse(mPulseReason, -1, -1, event.getValues());
+                mSensorCallback.onSensorPulse(mPulseReason, true /* sensorPerformsProxCheck */,
+                        -1, -1, event.getValues());
             }));
         }
     }
@@ -847,11 +936,13 @@ public class DozeSensors {
         /**
          * Called when a sensor requests a pulse
          * @param pulseReason Requesting sensor, e.g. {@link DozeLog#REASON_SENSOR_PICKUP}
+         * @param sensorPerformedProxCheck true if the sensor already checked for FAR proximity.
          * @param screenX the location on the screen where the sensor fired or -1
          *                if the sensor doesn't support reporting screen locations.
          * @param screenY the location on the screen where the sensor fired or -1
          * @param rawValues raw values array from the event.
          */
-        void onSensorPulse(int pulseReason, float screenX, float screenY, float[] rawValues);
+        void onSensorPulse(int pulseReason, boolean sensorPerformedProxCheck,
+                float screenX, float screenY, float[] rawValues);
     }
 }
",95,4,"DozeSensors::TriggerSensor::TriggerSensor, DozeSensors::PluginSensor::onSensorChanged, DozeSensors::TriggerSensor::TriggerSensor, DozeSensors::TriggerSensor::TriggerSensor, DozeSensors::TriggerSensor::TriggerSensor, DozeSensors::TriggerSensor::TriggerSensor, DozeSensors::TriggerSensor::performsProxCheck, DozeSensors::TriggerSensor::TriggerSensor, DozeSensors::TriggerSensor::onTrigger"
29,100058582558ae6500303c8c4af54561da4e75c6,DozeTriggers.java,"@@ -282,7 +282,8 @@ public class DozeTriggers implements DozeMachine.Part {
     }
 
     @VisibleForTesting
-    void onSensor(int pulseReason, float screenX, float screenY, float[] rawValues) {
+    void onSensor(int pulseReason, boolean sensorPerformedProxCheck,
+            float screenX, float screenY, float[] rawValues) {
         boolean isDoubleTap = pulseReason == DozeLog.REASON_SENSOR_DOUBLE_TAP;
         boolean isTap = pulseReason == DozeLog.REASON_SENSOR_TAP;
         boolean isPickup = pulseReason == DozeLog.REASON_SENSOR_PICKUP;
@@ -299,11 +300,11 @@ public class DozeTriggers implements DozeMachine.Part {
                     mMachine.isExecutingTransition() ? null : mMachine.getState(),
                     pulseReason);
         } else if (isLongPress) {
-            requestPulse(pulseReason, true /* alreadyPerformedProxCheck */,
+            requestPulse(pulseReason, sensorPerformedProxCheck /* alreadyPerformedProxCheck */,
                     null /* onPulseSuppressedListener */);
         } else if (isWakeOnReach || isQuickPickup) {
             if (isWakeDisplayEvent) {
-                requestPulse(pulseReason, true /* alreadyPerformedProxCheck */,
+                requestPulse(pulseReason, sensorPerformedProxCheck /* alreadyPerformedProxCheck */,
                         null /* onPulseSuppressedListener */);
             }
         } else {
@@ -338,7 +339,7 @@ public class DozeTriggers implements DozeMachine.Part {
                 } else {
                     mDozeHost.extendPulse(pulseReason);
                 }
-            }, true /* alreadyPerformedProxCheck */, pulseReason);
+            }, sensorPerformedProxCheck /* alreadyPerformedProxCheck */, pulseReason);
         }
 
         if (isPickup && !shouldDropPickupEvent()) {
",5,4,"DozeTriggers::onSensor, DozeTriggers::onSensor"
30,a4b357c9dd7c372c08cbe782ea6e1b09380f88a1,DozeSensors.java,"@@ -200,7 +200,8 @@ public class DozeSensors {
                         true /* configured */,
                         DozeLog.REASON_SENSOR_DOUBLE_TAP,
                         dozeParameters.doubleTapReportsTouchCoordinates(),
-                        true /* touchscreen */),
+                        true /* touchscreen */,
+                        !dozeParameters.doubleTapNeedsProximityCheck() /* performsProxCheck */),
                 new TriggerSensor(
                         findSensors(config.tapSensorTypeMapping()),
                         Settings.Secure.DOZE_TAP_SCREEN_GESTURE,
",2,1,DozeSensors::DozeSensors
31,a4b357c9dd7c372c08cbe782ea6e1b09380f88a1,DozeParameters.java,"@@ -298,6 +298,10 @@ public class DozeParameters implements
         return 2 * getPulseVisibleDuration();
     }
 
+    public boolean doubleTapNeedsProximityCheck() {
+        return mResources.getBoolean(R.bool.doze_double_tap_proximity_check);
+    }
+
     public boolean doubleTapReportsTouchCoordinates() {
         return mResources.getBoolean(R.bool.doze_double_tap_reports_touch_coordinates);
     }
",4,0,DozeParameters::doubleTapNeedsProximityCheck
32,3dd1c0ac07e72905c64cb43366edd571b2bdae9d,DozeSensors.java,"@@ -222,7 +222,8 @@ public class DozeSensors {
                         true /* reports touch coordinates */,
                         true /* touchscreen */,
                         false /* ignoresSetting */,
-                        dozeParameters.longPressUsesProx() /* requiresProx */),
+                        dozeParameters.longPressUsesProx() /* requiresProx */,
+                        !dozeParameters.longPressNeedsProximityCheck() /* performsProxCheck */),
                 new TriggerSensor(
                         findSensor(config.udfpsLongPressSensorType()),
                         ""doze_pulse_on_auth"",
@@ -232,7 +233,8 @@ public class DozeSensors {
                         true /* reports touch coordinates */,
                         true /* touchscreen */,
                         false /* ignoresSetting */,
-                        dozeParameters.longPressUsesProx()),
+                        dozeParameters.longPressUsesProx(),
+                        !dozeParameters.longPressNeedsProximityCheck() /* performsProxCheck */),
                 new PluginSensor(
                         new SensorManagerPlugin.Sensor(TYPE_WAKE_DISPLAY),
                         Settings.Secure.DOZE_WAKE_DISPLAY_GESTURE,
",4,2,DozeSensors::DozeSensors
33,3dd1c0ac07e72905c64cb43366edd571b2bdae9d,DozeParameters.java,"@@ -324,6 +324,10 @@ public class DozeParameters implements
         return mResources.getBoolean(R.bool.doze_single_tap_uses_prox);
     }
 
+    public boolean longPressNeedsProximityCheck() {
+        return mResources.getBoolean(R.bool.doze_long_press_proximity_check);
+    }
+
     /**
      * Whether the long press sensor uses the proximity sensor.
      */
",4,0,DozeParameters::longPressNeedsProximityCheck
34,d7f1a80214c2f4fa03f55ffd99e494e31f20c53b,PackageParser.java,"@@ -603,7 +603,9 @@ public class PackageParser {
      * a package.
      */
     public interface Callback {
-        NvAppProfileService getAppProfileService();
+        default NvAppProfileService getAppProfileService() {
+            return null;
+        }
         boolean hasFeature(String feature);
     }
 
",3,1,PackageParser::getAppProfileService
35,f606ff9c46f6e54b287c692e6b2eee9f7e8fc02c,BluetoothAdapter.java,"@@ -3278,6 +3278,7 @@ public final class BluetoothAdapter {
             case BluetoothProfile.LE_AUDIO:
                 BluetoothLeAudio leAudio = (BluetoothLeAudio) proxy;
                 leAudio.close();
+                break;
             case BluetoothProfile.GROUP_CLIENT:
                 BluetoothDeviceGroup groupClient = (BluetoothDeviceGroup) proxy;
                 groupClient.close();
",1,0,BluetoothAdapter::closeProfileProxy
36,ad25de41b4b152426c9b72315f349b9e91ef773d,ChooserActivity.java,"@@ -1394,13 +1394,16 @@ public class ChooserActivity extends ResolverActivity implements
 
         final ViewGroup actionRow =
                 (ViewGroup) contentPreviewLayout.findViewById(R.id.chooser_action_row);
+        String action = targetIntent.getAction();
+
         //TODO: addActionButton(actionRow, createCopyButton());
         addActionButton(actionRow, createNearbyButton(targetIntent));
-        addActionButton(actionRow, createEditButton(targetIntent));
+        if (!Intent.ACTION_SEND_MULTIPLE.equals(action)) {
+            addActionButton(actionRow, createEditButton(targetIntent));
+        }
 
         mPreviewCoord = new ContentPreviewCoordinator(contentPreviewLayout, false);
 
-        String action = targetIntent.getAction();
         if (Intent.ACTION_SEND.equals(action)) {
             Uri uri = targetIntent.getParcelableExtra(Intent.EXTRA_STREAM);
             imagePreview.findViewById(R.id.content_preview_image_1_large)
",5,2,ChooserActivity::displayImageContentPreview
37,01364b249e36ceba72fba3acc14197062a1fbbd6,QuickStatusBarHeader.java,"@@ -198,6 +198,9 @@ public class QuickStatusBarHeader extends FrameLayout implements TunerService.Tu
 
     void setIsSingleCarrier(boolean isSingleCarrier) {
         mIsSingleCarrier = isSingleCarrier;
+        if (mIsSingleCarrier) {
+            mIconContainer.removeIgnoredSlots(mRssiIgnoredSlots);
+        }
         updateAlphaAnimator();
     }
 
",3,0,QuickStatusBarHeader::setIsSingleCarrier
38,14cec8935c61ea3ce0db7a31bf8d00690ce8753a,BatteryMeterView.java,"@@ -63,9 +63,6 @@ import java.text.NumberFormat;
 
 public class BatteryMeterView extends LinearLayout implements DarkReceiver {
 
-    protected static final String STATUS_BAR_BATTERY_STYLE =
-            ""lineagesystem:"" + LineageSettings.System.STATUS_BAR_BATTERY_STYLE;
-
     protected static final int BATTERY_STYLE_PORTRAIT = 0;
     protected static final int BATTERY_STYLE_CIRCLE = 1;
     protected static final int BATTERY_STYLE_TEXT = 2;
@@ -93,8 +90,6 @@ public class BatteryMeterView extends LinearLayout implements DarkReceiver {
     // Lazily-loaded since this is expected to be a rare-if-ever state
     private Drawable mUnknownStateDrawable;
 
-    private int mBatteryStyle = BATTERY_STYLE_PORTRAIT;
-
     private DualToneHandler mDualToneHandler;
 
     private int mNonAdaptedSingleToneColor;
@@ -125,9 +120,11 @@ public class BatteryMeterView extends LinearLayout implements DarkReceiver {
         setupLayoutTransition();
 
         mBatteryIconView = new ImageView(context);
-        mBatteryIconView.setImageDrawable(mThemedDrawable);
+        updateDrawable();
         final MarginLayoutParams mlp = new MarginLayoutParams(
-                getResources().getDimensionPixelSize(R.dimen.status_bar_battery_icon_width),
+                getBatteryStyle() == BATTERY_STYLE_PORTRAIT ? getResources().getDimensionPixelSize(
+                R.dimen.status_bar_battery_icon_width) : getResources().getDimensionPixelSize(
+                R.dimen.status_bar_battery_icon_circle_width),
                 getResources().getDimensionPixelSize(R.dimen.status_bar_battery_icon_height));
         mlp.setMargins(0, 0, 0,
                 getResources().getDimensionPixelOffset(R.dimen.battery_margin_bottom));
@@ -157,11 +154,10 @@ public class BatteryMeterView extends LinearLayout implements DarkReceiver {
         setLayoutTransition(transition);
     }
 
-    protected void setBatteryStyle(int batteryStyle) {
-        if (batteryStyle == mBatteryStyle) return;
-        mBatteryStyle = batteryStyle;
-        updateBatteryStyle();
-        updateShowPercent();
+    protected void updateBatteryStyle() {
+        updateDrawable();
+        scaleBatteryMeterViews();
+        updatePercentView();
     }
 
     public void setForceShowPercent(boolean show) {
@@ -186,7 +182,7 @@ public class BatteryMeterView extends LinearLayout implements DarkReceiver {
     @Override
     protected void onConfigurationChanged(Configuration newConfig) {
         super.onConfigurationChanged(newConfig);
-        updatePercentView();
+        updateBatteryStyle();
     }
 
     public void setColorsFromContext(Context context) {
@@ -303,7 +299,7 @@ public class BatteryMeterView extends LinearLayout implements DarkReceiver {
                 showBatteryPercent == 2;
         boolean shouldShow =
                 (drawPercentOnly && (!drawPercentInside || mCharging) ||
-                mBatteryStyle == BATTERY_STYLE_TEXT);
+                getBatteryStyle() == BATTERY_STYLE_TEXT);
         shouldShow = shouldShow && !mBatteryStateUnknown;
 
         if (shouldShow) {
@@ -321,7 +317,7 @@ public class BatteryMeterView extends LinearLayout implements DarkReceiver {
                                 LayoutParams.WRAP_CONTENT,
                                 LayoutParams.MATCH_PARENT));
             }
-            if (mBatteryStyle == BATTERY_STYLE_TEXT) {
+            if (getBatteryStyle() == BATTERY_STYLE_TEXT) {
                 mBatteryPercentView.setPaddingRelative(0, 0, 0, 0);
             } else {
                 Resources res = getContext().getResources();
@@ -358,7 +354,7 @@ public class BatteryMeterView extends LinearLayout implements DarkReceiver {
         if (mBatteryStateUnknown) {
             mBatteryIconView.setImageDrawable(getUnknownStateDrawable());
         } else {
-            updateBatteryStyle();
+            updateDrawable();
         }
 
         updateShowPercent();
@@ -375,7 +371,7 @@ public class BatteryMeterView extends LinearLayout implements DarkReceiver {
         float iconScaleFactor = typedValue.getFloat();
 
         int batteryHeight = res.getDimensionPixelSize(R.dimen.status_bar_battery_icon_height);
-        int batteryWidth = mBatteryStyle == BATTERY_STYLE_CIRCLE ?
+        int batteryWidth = getBatteryStyle() == BATTERY_STYLE_CIRCLE ?
                 res.getDimensionPixelSize(R.dimen.status_bar_battery_icon_circle_width) :
                 res.getDimensionPixelSize(R.dimen.status_bar_battery_icon_width);
         int marginBottom = res.getDimensionPixelSize(R.dimen.battery_margin_bottom);
@@ -387,17 +383,15 @@ public class BatteryMeterView extends LinearLayout implements DarkReceiver {
         mBatteryIconView.setLayoutParams(scaledLayoutParams);
     }
 
-    private void updateBatteryStyle() {
-        switch (mBatteryStyle) {
+    private void updateDrawable() {
+        switch (getBatteryStyle()) {
             case BATTERY_STYLE_PORTRAIT:
                 mBatteryIconView.setImageDrawable(mThemedDrawable);
                 mBatteryIconView.setVisibility(View.VISIBLE);
-                scaleBatteryMeterViews();
                 break;
             case BATTERY_STYLE_CIRCLE:
                 mBatteryIconView.setImageDrawable(mCircleDrawable);
                 mBatteryIconView.setVisibility(View.VISIBLE);
-                scaleBatteryMeterViews();
                 break;
             case BATTERY_STYLE_TEXT:
                 mBatteryIconView.setVisibility(View.GONE);
@@ -406,6 +400,12 @@ public class BatteryMeterView extends LinearLayout implements DarkReceiver {
         }
     }
 
+    private int getBatteryStyle() {
+        return LineageSettings.System.getIntForUser(getContext().getContentResolver(),
+                LineageSettings.System.STATUS_BAR_BATTERY_STYLE, BATTERY_STYLE_PORTRAIT,
+                UserHandle.USER_CURRENT);
+    }
+
     @Override
     public void onDarkChanged(Rect area, float darkIntensity, int tint) {
         float intensity = DarkIconDispatcher.isInArea(area, this) ? darkIntensity : 0;
",21,21,"BatteryMeterView::BatteryMeterView, BatteryMeterView::updateShowPercent, BatteryMeterView::updateDrawable, BatteryMeterView::getBatteryStyle, BatteryMeterView::setBatteryStyle, BatteryMeterView::updateBatteryStyle, BatteryMeterView::onBatteryUnknownStateChanged, BatteryMeterView::scaleBatteryMeterViews, BatteryMeterView::onConfigurationChanged"
39,14cec8935c61ea3ce0db7a31bf8d00690ce8753a,BatteryMeterViewController.java,"@@ -15,6 +15,7 @@
  */
 package com.android.systemui.battery;
 
+import static lineageos.providers.LineageSettings.System.STATUS_BAR_BATTERY_STYLE;
 import static lineageos.providers.LineageSettings.System.STATUS_BAR_SHOW_BATTERY_PERCENT;
 
 import android.app.ActivityManager;
@@ -67,10 +68,8 @@ public class BatteryMeterViewController extends ViewController<BatteryMeterView>
                         getContext(), newValue);
                 mBatteryHidden = icons.contains(mSlotBattery);
                 mView.setVisibility(mBatteryHidden ? View.GONE : View.VISIBLE);
-            } else if (BatteryMeterView.STATUS_BAR_BATTERY_STYLE.equals(key)) {
                 if (!mBatteryHidden) {
-                    mView.setBatteryStyle(TunerService.parseInteger(newValue,
-                            BatteryMeterView.BATTERY_STYLE_PORTRAIT));
+                    mView.updateBatteryStyle();
                 }
             }
         }
@@ -166,8 +165,7 @@ public class BatteryMeterViewController extends ViewController<BatteryMeterView>
             return;
         }
 
-        mTunerService.addTunable(mTunable, StatusBarIconController.ICON_HIDE_LIST,
-                BatteryMeterView.STATUS_BAR_BATTERY_STYLE);
+        mTunerService.addTunable(mTunable, StatusBarIconController.ICON_HIDE_LIST);
         mIsSubscribedForTunerUpdates = true;
     }
 
@@ -186,6 +184,11 @@ public class BatteryMeterViewController extends ViewController<BatteryMeterView>
                 false,
                 mSettingObserver,
                 user);
+        mContentResolver.registerContentObserver(
+                LineageSettings.System.getUriFor(STATUS_BAR_BATTERY_STYLE),
+                false,
+                mSettingObserver,
+                user);
     }
 
     private void registerGlobalBatteryUpdateObserver() {
@@ -209,6 +212,9 @@ public class BatteryMeterViewController extends ViewController<BatteryMeterView>
                 // update the text for sure if the estimate in the cache was updated
                 mView.updatePercentText();
             }
+            if (TextUtils.equals(uri.getLastPathSegment(), STATUS_BAR_BATTERY_STYLE)) {
+                mView.updateBatteryStyle();
+            }
         }
     }
 }
",11,5,"BatteryMeterViewController::subscribeForTunerUpdates, BatteryMeterViewController::Tunable, BatteryMeterViewController::SettingObserver::onChange, BatteryMeterViewController::registerShowBatteryPercentObserver"
40,14cec8935c61ea3ce0db7a31bf8d00690ce8753a,QuickStatusBarHeader.java,"@@ -23,6 +23,7 @@ import android.content.res.Configuration;
 import android.content.res.Resources;
 import android.graphics.Color;
 import android.graphics.Rect;
+import android.os.UserHandle;
 import android.provider.AlarmClock;
 import android.util.AttributeSet;
 import android.util.Pair;
@@ -51,6 +52,8 @@ import com.android.systemui.statusbar.policy.Clock;
 import com.android.systemui.statusbar.policy.VariableDateView;
 import com.android.systemui.tuner.TunerService;
 
+import lineageos.providers.LineageSettings;
+
 import java.util.List;
 
 /**
@@ -291,7 +294,11 @@ public class QuickStatusBarHeader extends FrameLayout implements TunerService.Tu
 
         int textColor = Utils.getColorAttrDefaultColor(mContext, android.R.attr.textColorPrimary);
         if (textColor != mTextColorPrimary) {
+            boolean isCircleBattery = LineageSettings.System.getIntForUser(
+                    mContext.getContentResolver(), LineageSettings.System.STATUS_BAR_BATTERY_STYLE,
+                    0, UserHandle.USER_CURRENT) == 1;
             int textColorSecondary = Utils.getColorAttrDefaultColor(mContext,
+                    isCircleBattery ? android.R.attr.textColorHint :
                     android.R.attr.textColorSecondary);
             mTextColorPrimary = textColor;
             mClockView.setTextColor(textColor);
",7,0,QuickStatusBarHeader::updateResources
41,14cec8935c61ea3ce0db7a31bf8d00690ce8753a,ThemeOverlayController.java,"@@ -441,6 +441,33 @@ public class ThemeOverlayController extends SystemUI implements Dumpable {
                 },
                 UserHandle.USER_ALL);
 
+        mSystemSettings.registerContentObserverForUser(
+                LineageSettings.System.getUriFor(LineageSettings.System.STATUS_BAR_BATTERY_STYLE),
+                false,
+                new ContentObserver(mBgHandler) {
+                    @Override
+                    public void onChange(boolean selfChange, Collection<Uri> collection, int flags,
+                            int userId) {
+                        if (DEBUG) Log.d(TAG, ""Overlay changed for user: "" + userId);
+                        if (mUserTracker.getUserId() != userId) {
+                            return;
+                        }
+                        if (!mDeviceProvisionedController.isUserSetup(userId)) {
+                            Log.i(TAG, ""Theme application deferred when setting changed."");
+                            mDeferredThemeEvaluation = true;
+                            return;
+                        }
+                        boolean isCircleBattery = LineageSettings.System.getIntForUser(
+                                mContext.getContentResolver(),
+                                LineageSettings.System.STATUS_BAR_BATTERY_STYLE,
+                                0, UserHandle.USER_CURRENT) == 1;
+                        if (isCircleBattery) {
+                            reevaluateSystemTheme(true /* forceReload */);
+                        }
+                    }
+                },
+                UserHandle.USER_ALL);
+
         if (!mIsMonetEnabled) {
             return;
         }
",27,0,ThemeOverlayController::start
42,26066d9ee84bc90aa8f5f77cb6a2dfe5dc4be78c,KeyguardUpdateMonitor.java,"@@ -114,6 +114,8 @@ import com.android.systemui.util.RingerModeTracker;
 
 import com.google.android.collect.Lists;
 
+import lineageos.providers.LineageSettings;
+
 import java.io.FileDescriptor;
 import java.io.PrintWriter;
 import java.lang.ref.WeakReference;
@@ -306,6 +308,7 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener, Dumpab
             mCallbacks = Lists.newArrayList();
     private ContentObserver mDeviceProvisionedObserver;
     private ContentObserver mTimeFormatChangeObserver;
+    private ContentObserver mSettingsChangeObserver;
 
     private boolean mSwitchingUser;
 
@@ -339,7 +342,7 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener, Dumpab
     private SensorPrivacyManager mSensorPrivacyManager;
     private int mFaceAuthUserId;
 
-    private final boolean mFingerprintWakeAndUnlock;
+    private boolean mFingerprintWakeAndUnlock;
 
     /**
      * Short delay before restarting fingerprint authentication after a successful try. This should
@@ -1826,8 +1829,6 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener, Dumpab
         mTelephonyListenerManager = telephonyListenerManager;
         mDeviceProvisioned = isDeviceProvisionedInSettingsDb();
         mStrongAuthTracker = new StrongAuthTracker(context, this::notifyStrongAuthStateChanged);
-        mFingerprintWakeAndUnlock = mContext.getResources().getBoolean(
-                com.android.systemui.R.bool.config_fingerprintWakeAndUnlock);
         mBackgroundExecutor = backgroundExecutor;
         mBroadcastDispatcher = broadcastDispatcher;
         mInteractionJankMonitor = interactionJankMonitor;
@@ -1841,6 +1842,8 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener, Dumpab
         dumpManager.registerDumpable(getClass().getName(), this);
         mSensorPrivacyManager = context.getSystemService(SensorPrivacyManager.class);
 
+        updateFingerprintSettings();
+
         mHandler = new Handler(mainLooper) {
             @Override
             public void handleMessage(Message msg) {
@@ -2113,6 +2116,32 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener, Dumpab
         mContext.getContentResolver().registerContentObserver(
                 Settings.System.getUriFor(Settings.System.TIME_12_24),
                 false, mTimeFormatChangeObserver, UserHandle.USER_ALL);
+
+        mSettingsChangeObserver = new ContentObserver(mHandler) {
+            @Override
+            public void onChange(boolean selfChange) {
+                updateFingerprintSettings();
+            }
+        };
+        mContext.getContentResolver().registerContentObserver(
+                LineageSettings.System.getUriFor(LineageSettings.System.FINGERPRINT_WAKE_UNLOCK),
+                false, mSettingsChangeObserver, UserHandle.USER_ALL);
+    }
+
+    private void updateFingerprintSettings() {
+        boolean defFingerprintSettings = mContext.getResources().getBoolean(
+                com.android.systemui.R.bool.config_fingerprintWakeAndUnlock);
+        if (defFingerprintSettings) {
+            mFingerprintWakeAndUnlock = LineageSettings.System.getIntForUser(
+                    mContext.getContentResolver(), LineageSettings.System.FINGERPRINT_WAKE_UNLOCK,
+                    1, UserHandle.USER_CURRENT) == 1;
+        } else {
+            mFingerprintWakeAndUnlock = defFingerprintSettings;
+            // if its false, the device meant to be used like that, disable toggle with 2.
+            LineageSettings.System.putIntForUser(mContext.getContentResolver(),
+                    LineageSettings.System.FINGERPRINT_WAKE_UNLOCK,
+                    2, UserHandle.USER_CURRENT);
+        }
     }
 
     private void updateUdfpsEnrolled(int userId) {
@@ -3462,6 +3491,10 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener, Dumpab
             mContext.getContentResolver().unregisterContentObserver(mTimeFormatChangeObserver);
         }
 
+        if (mSettingsChangeObserver != null) {
+            mContext.getContentResolver().unregisterContentObserver(mSettingsChangeObserver);
+        }
+
         try {
             ActivityManager.getService().unregisterUserSwitchObserver(mUserSwitchObserver);
         } catch (RemoteException e) {
",36,3,"KeyguardUpdateMonitor::destroy, KeyguardUpdateMonitor::updateFingerprintSettings, KeyguardUpdateMonitor::KeyguardUpdateMonitor"
43,92ebedf7b4cf1b3fe3f6bd0db1f8cecc2425f012,ActionProxyReceiver.java,"@@ -20,6 +20,7 @@ import static android.view.Display.DEFAULT_DISPLAY;
 
 import static com.android.systemui.screenshot.ScreenshotController.ACTION_TYPE_EDIT;
 import static com.android.systemui.screenshot.ScreenshotController.ACTION_TYPE_SHARE;
+import static com.android.systemui.screenshot.ScreenshotController.ACTION_TYPE_VIEW;
 import static com.android.systemui.screenshot.ScreenshotController.EXTRA_ACTION_INTENT;
 import static com.android.systemui.screenshot.ScreenshotController.EXTRA_DISALLOW_ENTER_PIP;
 import static com.android.systemui.screenshot.ScreenshotController.EXTRA_ID;
@@ -98,9 +99,15 @@ public class ActionProxyReceiver extends BroadcastReceiver {
         }
 
         if (intent.getBooleanExtra(EXTRA_SMART_ACTIONS_ENABLED, false)) {
-            String actionType = Intent.ACTION_EDIT.equals(intent.getAction())
-                    ? ACTION_TYPE_EDIT
-                    : ACTION_TYPE_SHARE;
+            String action = intent.getAction();
+            String actionType;
+            if (Intent.ACTION_VIEW.equals(action)) {
+                actionType = ACTION_TYPE_VIEW;
+            } else if (Intent.ACTION_EDIT.equals(action)) {
+                actionType = ACTION_TYPE_EDIT;
+            } else {
+                actionType = ACTION_TYPE_SHARE;
+            }
             mScreenshotSmartActions.notifyScreenshotAction(
                     context, intent.getStringExtra(EXTRA_ID), actionType, false, null);
         }
",10,3,ActionProxyReceiver::onReceive
44,92ebedf7b4cf1b3fe3f6bd0db1f8cecc2425f012,SaveImageInBackgroundTask.java,"@@ -166,6 +166,7 @@ class SaveImageInBackgroundTask extends AsyncTask<String, Void, Void> {
 
             mImageData.uri = uri;
             mImageData.smartActions = smartActions;
+            mImageData.viewTransition = createViewAction(mContext, mContext.getResources(), uri);
             mImageData.shareTransition = createShareAction(mContext, mContext.getResources(), uri);
             mImageData.editTransition = createEditAction(mContext, mContext.getResources(), uri);
             mImageData.deleteAction = createDeleteAction(mContext, mContext.getResources(), uri);
@@ -221,6 +222,51 @@ class SaveImageInBackgroundTask extends AsyncTask<String, Void, Void> {
         mParams.clearImage();
     }
 
+    @VisibleForTesting
+    Supplier<ActionTransition> createViewAction(Context context, Resources r, Uri uri) {
+        return () -> {
+            ActionTransition transition = mSharedElementTransition.get();
+            // Note: the view, share and edit actions are proxied through ActionProxyReceiver in
+            // order to do some common work like dismissing the keyguard and sending
+            // closeSystemWindows
+
+            // Create an edit intent, if a specific package is provided as the editor, then
+            // launch that directly
+            Intent viewIntent = new Intent(Intent.ACTION_VIEW);
+            viewIntent.setDataAndType(uri, ""image/png"");
+            viewIntent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
+            viewIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);
+
+            PendingIntent pendingIntent = PendingIntent.getActivityAsUser(
+                    context, 0, viewIntent, PendingIntent.FLAG_IMMUTABLE,
+                    transition.bundle, UserHandle.CURRENT);
+
+            // Make sure pending intents for the system user are still unique across users
+            // by setting the (otherwise unused) request code to the current user id.
+            int requestCode = mContext.getUserId();
+
+            // Create a view action
+            PendingIntent viewAction = PendingIntent.getBroadcastAsUser(context, requestCode,
+                    new Intent(context, ActionProxyReceiver.class)
+                            .putExtra(ScreenshotController.EXTRA_ACTION_INTENT, pendingIntent)
+                            .putExtra(ScreenshotController.EXTRA_ID, mScreenshotId)
+                            .putExtra(ScreenshotController.EXTRA_SMART_ACTIONS_ENABLED,
+                                    mSmartActionsEnabled)
+                            .putExtra(ScreenshotController.EXTRA_OVERRIDE_TRANSITION, true)
+                            .setAction(Intent.ACTION_VIEW)
+                            .addFlags(Intent.FLAG_RECEIVER_FOREGROUND),
+                    PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_IMMUTABLE,
+                    UserHandle.SYSTEM);
+            Notification.Action.Builder editActionBuilder = new Notification.Action.Builder(
+                    Icon.createWithResource(r, com.android.internal.R.drawable.ic_screenshot),
+                    r.getString(com.android.internal.R.string.global_action_screenshot),
+                    viewAction);
+
+            transition.action = editActionBuilder.build();
+            return transition;
+        };
+    }
+
     /**
      * Assumes that the action intent is sent immediately after being supplied.
      */
",46,0,"SaveImageInBackgroundTask::createViewAction, SaveImageInBackgroundTask::doInBackground"
45,92ebedf7b4cf1b3fe3f6bd0db1f8cecc2425f012,ScreenshotController.java,"@@ -166,6 +166,7 @@ public class ScreenshotController {
      */
     static class SavedImageData {
         public Uri uri;
+        public Supplier<ActionTransition> viewTransition;
         public Supplier<ActionTransition> shareTransition;
         public Supplier<ActionTransition> editTransition;
         public Notification.Action deleteAction;
@@ -229,6 +230,7 @@ public class ScreenshotController {
     // ScreenshotNotificationSmartActionsProvider.
     static final String EXTRA_ACTION_TYPE = ""android:screenshot_action_type"";
     static final String EXTRA_ID = ""android:screenshot_id"";
+    static final String ACTION_TYPE_VIEW = ""View"";
     static final String ACTION_TYPE_DELETE = ""Delete"";
     static final String ACTION_TYPE_SHARE = ""Share"";
     static final String ACTION_TYPE_EDIT = ""Edit"";
",2,0,
46,92ebedf7b4cf1b3fe3f6bd0db1f8cecc2425f012,ScreenshotView.java,"@@ -722,7 +722,7 @@ public class ScreenshotView extends FrameLayout implements
         mScreenshotPreview.setOnClickListener(v -> {
             mUiEventLogger.log(ScreenshotEvent.SCREENSHOT_PREVIEW_TAPPED, 0, mPackageName);
             startSharedTransition(
-                    imageData.editTransition.get());
+                    imageData.viewTransition.get());
         });
         if (mQuickShareChip != null) {
             mQuickShareChip.setPendingIntent(imageData.quickShareAction.actionIntent,
",1,1,ScreenshotView::setChipIntents
47,92ebedf7b4cf1b3fe3f6bd0db1f8cecc2425f012,ScreenshotNotificationSmartActionsTest.java,"@@ -169,6 +169,34 @@ public class ScreenshotNotificationSmartActionsTest extends SysuiTestCase {
         assertEquals(smartActions.size(), 0);
     }
 
+    // Tests for view action extras
+    @Test
+    public void testViewActionExtras() {
+        if (Looper.myLooper() == null) {
+            Looper.prepare();
+        }
+
+        ScreenshotController.SaveImageInBackgroundData
+                data = new ScreenshotController.SaveImageInBackgroundData();
+        data.image = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+        data.finisher = null;
+        data.mActionsReadyListener = null;
+        SaveImageInBackgroundTask task =
+                new SaveImageInBackgroundTask(mContext, null, mScreenshotSmartActions, data,
+                        ActionTransition::new);
+
+        Notification.Action viewAction = task.createViewAction(mContext, mContext.getResources(),
+                Uri.parse(""Screenshot_123.png"")).get().action;
+
+        Intent intent = viewAction.actionIntent.getIntent();
+        assertNotNull(intent);
+        Bundle bundle = intent.getExtras();
+        assertTrue(bundle.containsKey(ScreenshotController.EXTRA_ID));
+        assertTrue(bundle.containsKey(ScreenshotController.EXTRA_SMART_ACTIONS_ENABLED));
+        assertEquals(ScreenshotController.ACTION_TYPE_VIEW, viewAction.title);
+        assertEquals(Intent.ACTION_VIEW, intent.getAction());
+    }
+
     // Tests for share action extras
     @Test
     public void testShareActionExtras() {
",28,0,ScreenshotNotificationSmartActionsTest::testViewActionExtras
48,f85097863810e3bc65597c29689932eb707d65e8,NotificationManagerService.java,"@@ -249,6 +249,7 @@ import android.util.Log;
 import android.util.Pair;
 import android.util.Slog;
 import android.util.SparseArray;
+import android.util.SparseBooleanArray;
 import android.util.StatsEvent;
 import android.util.TypedXmlPullParser;
 import android.util.TypedXmlSerializer;
@@ -280,6 +281,7 @@ import com.android.internal.util.DumpUtils;
 import com.android.internal.util.Preconditions;
 import com.android.internal.util.XmlUtils;
 import com.android.internal.util.function.TriPredicate;
+import com.android.internal.widget.LockPatternUtils;
 import com.android.server.DeviceIdleInternal;
 import com.android.server.EventLogTags;
 import com.android.server.IoThread;
@@ -1904,6 +1906,54 @@ public class NotificationManagerService extends SystemService {
     private SettingsObserver mSettingsObserver;
     protected ZenModeHelper mZenModeHelper;
 
+    protected class StrongAuthTracker extends LockPatternUtils.StrongAuthTracker {
+
+        SparseBooleanArray mUserInLockDownMode = new SparseBooleanArray();
+        boolean mIsInLockDownMode = false;
+
+        StrongAuthTracker(Context context) {
+            super(context);
+        }
+
+        private boolean containsFlag(int haystack, int needle) {
+            return (haystack & needle) != 0;
+        }
+
+        public boolean isInLockDownMode() {
+            return mIsInLockDownMode;
+        }
+
+        @Override
+        public synchronized void onStrongAuthRequiredChanged(int userId) {
+            boolean userInLockDownModeNext = containsFlag(getStrongAuthForUser(userId),
+                    STRONG_AUTH_REQUIRED_AFTER_USER_LOCKDOWN);
+            mUserInLockDownMode.put(userId, userInLockDownModeNext);
+            boolean isInLockDownModeNext = mUserInLockDownMode.indexOfValue(true) != -1;
+
+            if (mIsInLockDownMode == isInLockDownModeNext) {
+                return;
+            }
+
+            if (isInLockDownModeNext) {
+                cancelNotificationsWhenEnterLockDownMode();
+            }
+
+            // When the mIsInLockDownMode is true, both notifyPostedLocked and
+            // notifyRemovedLocked will be dismissed. So we shall call
+            // cancelNotificationsWhenEnterLockDownMode before we set mIsInLockDownMode
+            // as true and call postNotificationsWhenExitLockDownMode after we set
+            // mIsInLockDownMode as false.
+            mIsInLockDownMode = isInLockDownModeNext;
+
+            if (!isInLockDownModeNext) {
+                postNotificationsWhenExitLockDownMode();
+            }
+        }
+    }
+
+    private LockPatternUtils mLockPatternUtils;
+    private StrongAuthTracker mStrongAuthTracker;
+
     public NotificationManagerService(Context context) {
         this(context,
                 new NotificationRecordLoggerImpl(),
@@ -1926,6 +1976,11 @@ public class NotificationManagerService extends SystemService {
         mAudioManager = audioMananger;
     }
 
+    @VisibleForTesting
+    void setStrongAuthTracker(StrongAuthTracker strongAuthTracker) {
+        mStrongAuthTracker = strongAuthTracker;
+    }
+
     @VisibleForTesting
     void setKeyguardManager(KeyguardManager keyguardManager) {
         mKeyguardManager = keyguardManager;
@@ -2113,6 +2168,8 @@ public class NotificationManagerService extends SystemService {
                 ServiceManager.getService(Context.PLATFORM_COMPAT_SERVICE));
 
         mUiHandler = new Handler(UiThread.get().getLooper());
+        mLockPatternUtils = new LockPatternUtils(getContext());
+        mStrongAuthTracker = new StrongAuthTracker(getContext());
         String[] extractorNames;
         try {
             extractorNames = resources.getStringArray(R.array.config_notificationSignalExtractors);
@@ -2597,6 +2654,7 @@ public class NotificationManagerService extends SystemService {
                 bubbsExtractor.setShortcutHelper(mShortcutHelper);
             }
             registerNotificationPreferencesPullers();
+            mLockPatternUtils.registerStrongAuthTracker(mStrongAuthTracker);
         } else if (phase == SystemService.PHASE_THIRD_PARTY_APPS_CAN_START) {
             // This observer will force an update when observe is called, causing us to
             // bind to listener services.
@@ -9210,6 +9268,29 @@ public class NotificationManagerService extends SystemService {
         }
     }
 
+    private void cancelNotificationsWhenEnterLockDownMode() {
+        synchronized (mNotificationLock) {
+            int numNotifications = mNotificationList.size();
+            for (int i = 0; i < numNotifications; i++) {
+                NotificationRecord rec = mNotificationList.get(i);
+                mListeners.notifyRemovedLocked(rec, REASON_CANCEL_ALL,
+                        rec.getStats());
+            }
+
+        }
+    }
+
+    private void postNotificationsWhenExitLockDownMode() {
+        synchronized (mNotificationLock) {
+            int numNotifications = mNotificationList.size();
+            for (int i = 0; i < numNotifications; i++) {
+                NotificationRecord rec = mNotificationList.get(i);
+                mListeners.notifyPostedLocked(rec, rec);
+            }
+
+        }
+    }
+
     private void updateNotificationPulse() {
         synchronized (mNotificationLock) {
             updateLightsLocked();
@@ -9445,6 +9526,10 @@ public class NotificationManagerService extends SystemService {
                 rankings.toArray(new NotificationListenerService.Ranking[0]));
     }
 
+    boolean isInLockDownMode() {
+        return mStrongAuthTracker.isInLockDownMode();
+    }
+
     boolean hasCompanionDevice(ManagedServiceInfo info) {
         if (mCompanionManager == null) {
             mCompanionManager = getCompanionManager();
@@ -10496,8 +10581,12 @@ public class NotificationManagerService extends SystemService {
          *                           targetting <= O_MR1
          */
         @GuardedBy(""mNotificationLock"")
-        private void notifyPostedLocked(NotificationRecord r, NotificationRecord old,
+        void notifyPostedLocked(NotificationRecord r, NotificationRecord old,
                 boolean notifyAllListeners) {
+            if (isInLockDownMode()) {
+                return;
+            }
+
             try {
                 // Lazily initialized snapshots of the notification.
                 StatusBarNotification sbn = r.getSbn();
@@ -10595,6 +10684,10 @@ public class NotificationManagerService extends SystemService {
         @GuardedBy(""mNotificationLock"")
         public void notifyRemovedLocked(NotificationRecord r, int reason,
                 NotificationStats notificationStats) {
+            if (isInLockDownMode()) {
+                return;
+            }
+
             final StatusBarNotification sbn = r.getSbn();
 
             // make a copy in case changes are made to the underlying Notification object
@@ -10640,6 +10733,10 @@ public class NotificationManagerService extends SystemService {
          */
         @GuardedBy(""mNotificationLock"")
         public void notifyRankingUpdateLocked(List<NotificationRecord> changedHiddenNotifications) {
+            if (isInLockDownMode()) {
+                return;
+            }
+
             boolean isHiddenRankingUpdate = changedHiddenNotifications != null
                     && changedHiddenNotifications.size() > 0;
             // TODO (b/73052211): if the ranking update changed the notification type,
",98,1,"NotificationManagerService::StrongAuthTracker::StrongAuthTracker, NotificationManagerService::onBootPhase, NotificationManagerService::postNotificationsWhenExitLockDownMode, NotificationManagerService::NotificationListeners::notifyRemovedLocked, NotificationManagerService::StrongAuthTracker::onStrongAuthRequiredChanged, NotificationManagerService::NotificationListeners::notifyPostedLocked, NotificationManagerService::setStrongAuthTracker, NotificationManagerService::StrongAuthTracker::isInLockDownMode, NotificationManagerService::cancelNotificationsWhenEnterLockDownMode, NotificationManagerService::StrongAuthTracker::containsFlag, NotificationManagerService::NotificationListeners::notifyRankingUpdateLocked, NotificationManagerService::isInLockDownMode, NotificationManagerService::init"
49,f85097863810e3bc65597c29689932eb707d65e8,NotificationListenersTest.java,"@@ -27,12 +27,13 @@ import static com.google.common.truth.Truth.assertThat;
 import static junit.framework.Assert.assertFalse;
 import static junit.framework.Assert.assertTrue;
 
-import static org.mockito.ArgumentMatchers.any;
-import static org.mockito.ArgumentMatchers.anyInt;
 import static org.mockito.ArgumentMatchers.eq;
 import static org.mockito.ArgumentMatchers.nullable;
+import static org.mockito.Mockito.atLeast;
 import static org.mockito.Mockito.doNothing;
 import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.reset;
 import static org.mockito.Mockito.spy;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
@@ -47,10 +48,11 @@ import android.os.Bundle;
 import android.os.UserHandle;
 import android.service.notification.NotificationListenerFilter;
 import android.service.notification.NotificationListenerService;
+import android.service.notification.NotificationStats;
+import android.service.notification.StatusBarNotification;
 import android.testing.TestableContext;
 import android.util.ArraySet;
 import android.util.Pair;
-import android.util.Slog;
 import android.util.TypedXmlPullParser;
 import android.util.TypedXmlSerializer;
 import android.util.Xml;
@@ -61,11 +63,13 @@ import org.junit.Before;
 import org.junit.Test;
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
+import org.mockito.internal.util.reflection.FieldSetter;
 
 import java.io.BufferedInputStream;
 import java.io.BufferedOutputStream;
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
+import java.util.List;
 
 public class NotificationListenersTest extends UiServiceTestCase {
 
@@ -374,4 +378,66 @@ public class NotificationListenersTest extends UiServiceTestCase {
         verify(mContext).sendBroadcastAsUser(
                 any(), eq(UserHandle.of(userId)), nullable(String.class));
     }
+
+    @Test
+    public void testNotifyPostedLockedInLockdownMode() {
+        NotificationRecord r = mock(NotificationRecord.class);
+        NotificationRecord old = mock(NotificationRecord.class);
+
+        // before the lockdown mode
+        when(mNm.isInLockDownMode()).thenReturn(false);
+        mListeners.notifyPostedLocked(r, old, true);
+        mListeners.notifyPostedLocked(r, old, false);
+        verify(r, atLeast(2)).getSbn();
+
+        // in the lockdown mode
+        reset(r);
+        reset(old);
+        when(mNm.isInLockDownMode()).thenReturn(true);
+        mListeners.notifyPostedLocked(r, old, true);
+        mListeners.notifyPostedLocked(r, old, false);
+        verify(r, never()).getSbn();
+    }
+
+    @Test
+    public void testnotifyRankingUpdateLockedInLockdownMode() {
+        List chn = mock(List.class);
+
+        // before the lockdown mode
+        when(mNm.isInLockDownMode()).thenReturn(false);
+        mListeners.notifyRankingUpdateLocked(chn);
+        verify(chn, atLeast(1)).size();
+
+        // in the lockdown mode
+        reset(chn);
+        when(mNm.isInLockDownMode()).thenReturn(true);
+        mListeners.notifyRankingUpdateLocked(chn);
+        verify(chn, never()).size();
+    }
+
+    @Test
+    public void testNotifyRemovedLockedInLockdownMode() throws NoSuchFieldException {
+        NotificationRecord r = mock(NotificationRecord.class);
+        NotificationStats rs = mock(NotificationStats.class);
+        StatusBarNotification sbn = mock(StatusBarNotification.class);
+        FieldSetter.setField(mNm,
+                NotificationManagerService.class.getDeclaredField(""mHandler""),
+                mock(NotificationManagerService.WorkerHandler.class));
+
+        // before the lockdown mode
+        when(mNm.isInLockDownMode()).thenReturn(false);
+        when(r.getSbn()).thenReturn(sbn);
+        mListeners.notifyRemovedLocked(r, 0, rs);
+        mListeners.notifyRemovedLocked(r, 0, rs);
+        verify(r, atLeast(2)).getSbn();
+
+        // in the lockdown mode
+        reset(r);
+        reset(rs);
+        when(mNm.isInLockDownMode()).thenReturn(true);
+        when(r.getSbn()).thenReturn(sbn);
+        mListeners.notifyRemovedLocked(r, 0, rs);
+        mListeners.notifyRemovedLocked(r, 0, rs);
+        verify(r, never()).getSbn();
+    }
 }
",69,3,"NotificationListenersTest::testNotifyRemovedLockedInLockdownMode, NotificationListenersTest::testNotifyPostedLockedInLockdownMode, NotificationListenersTest::testnotifyRankingUpdateLockedInLockdownMode"
50,f85097863810e3bc65597c29689932eb707d65e8,NotificationManagerServiceTest.java,"@@ -58,10 +58,13 @@ import static android.service.notification.Adjustment.KEY_USER_SENTIMENT;
 import static android.service.notification.NotificationListenerService.FLAG_FILTER_TYPE_ALERTING;
 import static android.service.notification.NotificationListenerService.FLAG_FILTER_TYPE_CONVERSATIONS;
 import static android.service.notification.NotificationListenerService.FLAG_FILTER_TYPE_ONGOING;
+import static android.service.notification.NotificationListenerService.REASON_CANCEL_ALL;
 import static android.service.notification.NotificationListenerService.Ranking.USER_SENTIMENT_NEGATIVE;
 import static android.service.notification.NotificationListenerService.Ranking.USER_SENTIMENT_NEUTRAL;
 import static android.view.WindowManager.LayoutParams.TYPE_TOAST;
 
+import static com.android.internal.widget.LockPatternUtils.StrongAuthTracker.STRONG_AUTH_REQUIRED_AFTER_USER_LOCKDOWN;
+
 import static com.google.common.truth.Truth.assertThat;
 
 import static junit.framework.Assert.assertEquals;
@@ -223,7 +226,6 @@ import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
 import java.util.Map;
-import java.util.Set;
 import java.util.concurrent.CountDownLatch;
 import java.util.function.Consumer;
 
@@ -409,8 +411,26 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {
         interface NotificationAssistantAccessGrantedCallback {
             void onGranted(ComponentName assistant, int userId, boolean granted, boolean userSet);
         }
+
+        class StrongAuthTrackerFake extends NotificationManagerService.StrongAuthTracker {
+            private int mGetStrongAuthForUserReturnValue = 0;
+            StrongAuthTrackerFake(Context context) {
+                super(context);
+            }
+
+            public void setGetStrongAuthForUserReturnValue(int val) {
+                mGetStrongAuthForUserReturnValue = val;
+            }
+
+            @Override
+            public int getStrongAuthForUser(int userId) {
+                return mGetStrongAuthForUserReturnValue;
+            }
+        }
     }
 
+    TestableNotificationManagerService.StrongAuthTrackerFake mStrongAuthTracker;
+
     private class TestableToastCallback extends ITransientNotification.Stub {
         @Override
         public void show(IBinder windowToken) {
@@ -530,6 +550,9 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {
 
         mService.setAudioManager(mAudioManager);
 
+        mStrongAuthTracker = mService.new StrongAuthTrackerFake(mContext);
+        mService.setStrongAuthTracker(mStrongAuthTracker);
+
         mShortcutHelper = mService.getShortcutHelper();
         mShortcutHelper.setLauncherApps(mLauncherApps);
         mShortcutHelper.setShortcutServiceInternal(mShortcutServiceInternal);
@@ -8354,4 +8377,44 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {
             }
         }
     }
+
+    @Test
+    public void testStrongAuthTracker_isInLockDownMode() {
+        mStrongAuthTracker.setGetStrongAuthForUserReturnValue(
+                STRONG_AUTH_REQUIRED_AFTER_USER_LOCKDOWN);
+        mStrongAuthTracker.onStrongAuthRequiredChanged(mContext.getUserId());
+        assertTrue(mStrongAuthTracker.isInLockDownMode());
+        mStrongAuthTracker.setGetStrongAuthForUserReturnValue(0);
+        mStrongAuthTracker.onStrongAuthRequiredChanged(mContext.getUserId());
+        assertFalse(mStrongAuthTracker.isInLockDownMode());
+    }
+
+    @Test
+    public void testCancelAndPostNotificationsWhenEnterAndExitLockDownMode() {
+        // post 2 notifications from 2 packages
+        NotificationRecord pkgA = new NotificationRecord(mContext,
+                generateSbn(""a"", 1000, 9, 0), mTestNotificationChannel);
+        mService.addNotification(pkgA);
+        NotificationRecord pkgB = new NotificationRecord(mContext,
+                generateSbn(""b"", 1001, 9, 0), mTestNotificationChannel);
+        mService.addNotification(pkgB);
+
+        // when entering the lockdown mode, cancel the 2 notifications.
+        mStrongAuthTracker.setGetStrongAuthForUserReturnValue(
+                STRONG_AUTH_REQUIRED_AFTER_USER_LOCKDOWN);
+        mStrongAuthTracker.onStrongAuthRequiredChanged(mContext.getUserId());
+        assertTrue(mStrongAuthTracker.isInLockDownMode());
+
+        // the notifyRemovedLocked function is called twice due to REASON_LOCKDOWN.
+        ArgumentCaptor<Integer> captor = ArgumentCaptor.forClass(Integer.class);
+        verify(mListeners, times(2)).notifyRemovedLocked(any(), captor.capture(), any());
+        assertEquals(REASON_CANCEL_ALL, captor.getValue().intValue());
+
+        // exit lockdown mode.
+        mStrongAuthTracker.setGetStrongAuthForUserReturnValue(0);
+        mStrongAuthTracker.onStrongAuthRequiredChanged(mContext.getUserId());
+
+        // the notifyPostedLocked function is called twice.
+        verify(mListeners, times(2)).notifyPostedLocked(any(), any());
+    }
 }
",64,1,"NotificationManagerServiceTest::setUp, NotificationManagerServiceTest::TestableNotificationManagerService::StrongAuthTrackerFake::StrongAuthTrackerFake, NotificationManagerServiceTest::TestableNotificationManagerService::StrongAuthTrackerFake::getStrongAuthForUser, NotificationManagerServiceTest::testCancelAndPostNotificationsWhenEnterAndExitLockDownMode, NotificationManagerServiceTest::TestableNotificationManagerService::StrongAuthTrackerFake::setGetStrongAuthForUserReturnValue, NotificationManagerServiceTest::testStrongAuthTracker_isInLockDownMode"
51,26a39ef345e111ca509a00f34d50c823461225aa,ActiveServices.java,"@@ -5999,10 +5999,16 @@ public final class ActiveServices {
         }
 
         if (ret == REASON_DENIED) {
-            final boolean isAllowedPackage =
-                    mAllowListWhileInUsePermissionInFgs.contains(callingPackage);
-            if (isAllowedPackage) {
-                ret = REASON_ALLOWLISTED_PACKAGE;
+            if (verifyPackage(callingPackage, callingUid)) {
+                final boolean isAllowedPackage =
+                        mAllowListWhileInUsePermissionInFgs.contains(callingPackage);
+                if (isAllowedPackage) {
+                    ret = REASON_ALLOWLISTED_PACKAGE;
+                }
+            } else {
+                EventLog.writeEvent(0x534e4554, ""215003903"", callingUid,
+                        ""callingPackage:"" + callingPackage + "" does not belong to callingUid:""
+                                + callingUid);
             }
         }
 
@@ -6385,4 +6391,21 @@ public final class ActiveServices {
                 /* allowBackgroundActivityStarts */ false)
                 != REASON_DENIED;
     }
+
+    /**
+     * Checks if a given packageName belongs to a given uid.
+     * @param packageName the package of the caller
+     * @param uid the uid of the caller
+     * @return true or false
+     */
+    private boolean verifyPackage(String packageName, int uid) {
+        if (uid == ROOT_UID || uid == SYSTEM_UID) {
+            //System and Root are always allowed
+            return true;
+        }
+        final int userId = UserHandle.getUserId(uid);
+        final int packageUid = mAm.getPackageManagerInternal()
+                .getPackageUid(packageName, PackageManager.MATCH_DEBUG_TRIAGED_MISSING, userId);
+        return UserHandle.isSameApp(uid, packageUid);
+    }
 }
",27,4,"ActiveServices::verifyPackage, ActiveServices::shouldAllowFgsWhileInUsePermissionLocked"
52,66d3d4b687cac1c00ada8b66de974c4643b29691,Vpn.java,"@@ -2627,6 +2627,9 @@ public class Vpn {
                         return; // VPN has been shut down.
                     }
 
+                    // Clear mInterface to prevent Ikev2VpnRunner being cleared when
+                    // interfaceRemoved() is called.
+                    mInterface = null;
                     // Without MOBIKE, we have no way to seamlessly migrate. Close on old
                     // (non-default) network, and start the new one.
                     resetIkeState();
",3,0,Vpn::IkeV2VpnRunner::onDefaultNetworkChanged
53,b29568f8b9948aed6562b205fc569d7ba6a77f96,LocationManagerService.java,"@@ -17,6 +17,7 @@
 package com.android.server.location;
 
 import static android.Manifest.permission.ACCESS_FINE_LOCATION;
+import static android.Manifest.permission.INTERACT_ACROSS_USERS;
 import static android.app.compat.CompatChanges.isChangeEnabled;
 import static android.content.pm.PackageManager.MATCH_DIRECT_BOOT_AWARE;
 import static android.content.pm.PackageManager.MATCH_SYSTEM_ONLY;
@@ -39,6 +40,7 @@ import android.Manifest;
 import android.Manifest.permission;
 import android.annotation.NonNull;
 import android.annotation.Nullable;
+import android.annotation.RequiresPermission;
 import android.app.ActivityManager;
 import android.app.AppOpsManager;
 import android.app.PendingIntent;
@@ -1063,8 +1065,10 @@ public class LocationManagerService extends ILocationManager.Stub implements
 
     @Override
     public void addProviderRequestListener(IProviderRequestListener listener) {
-        for (LocationProviderManager manager : mProviderManagers) {
-            manager.addProviderRequestListener(listener);
+        if (mContext.checkCallingOrSelfPermission(INTERACT_ACROSS_USERS) == PERMISSION_GRANTED) {
+            for (LocationProviderManager manager : mProviderManagers) {
+                manager.addProviderRequestListener(listener);
+            }
         }
     }
 
",6,2,LocationManagerService::addProviderRequestListener
54,475c5c8015d9437456c1741e77d54d465bc45fb0,AppOpsManager.java,"@@ -2463,8 +2463,8 @@ public class AppOpsManager {
      * restriction} for a certain app-op.
      */
     private static RestrictionBypass[] sOpAllowSystemRestrictionBypass = new RestrictionBypass[] {
-            new RestrictionBypass(true, false), //COARSE_LOCATION
-            new RestrictionBypass(true, false), //FINE_LOCATION
+            null, //COARSE_LOCATION
+            null, //FINE_LOCATION
             null, //GPS
             null, //VIBRATE
             null, //READ_CONTACTS
",2,2,
55,9642f85f5b777567389007f222d031e9b81dc3b7,AppOpsManager.java,"@@ -2463,8 +2463,8 @@ public class AppOpsManager {
      * restriction} for a certain app-op.
      */
     private static RestrictionBypass[] sOpAllowSystemRestrictionBypass = new RestrictionBypass[] {
-            null, //COARSE_LOCATION
-            null, //FINE_LOCATION
+            new RestrictionBypass(true, false, false), //COARSE_LOCATION
+            new RestrictionBypass(true, false, false), //FINE_LOCATION
             null, //GPS
             null, //VIBRATE
             null, //READ_CONTACTS
@@ -2473,7 +2473,7 @@ public class AppOpsManager {
             null, //WRITE_CALL_LOG
             null, //READ_CALENDAR
             null, //WRITE_CALENDAR
-            new RestrictionBypass(true, false), //WIFI_SCAN
+            new RestrictionBypass(false, true, false), //WIFI_SCAN
             null, //POST_NOTIFICATION
             null, //NEIGHBORING_CELLS
             null, //CALL_PHONE
@@ -2487,10 +2487,10 @@ public class AppOpsManager {
             null, //READ_ICC_SMS
             null, //WRITE_ICC_SMS
             null, //WRITE_SETTINGS
-            new RestrictionBypass(true, false), //SYSTEM_ALERT_WINDOW
+            new RestrictionBypass(false, true, false), //SYSTEM_ALERT_WINDOW
             null, //ACCESS_NOTIFICATIONS
             null, //CAMERA
-            new RestrictionBypass(false, true), //RECORD_AUDIO
+            new RestrictionBypass(false, false, true), //RECORD_AUDIO
             null, //PLAY_AUDIO
             null, //READ_CLIPBOARD
             null, //WRITE_CLIPBOARD
@@ -2508,7 +2508,7 @@ public class AppOpsManager {
             null, //MONITOR_HIGH_POWER_LOCATION
             null, //GET_USAGE_STATS
             null, //MUTE_MICROPHONE
-            new RestrictionBypass(true, false), //TOAST_WINDOW
+            new RestrictionBypass(false, true, false), //TOAST_WINDOW
             null, //PROJECT_MEDIA
             null, //ACTIVATE_VPN
             null, //WALLPAPER
@@ -2540,7 +2540,7 @@ public class AppOpsManager {
             null, // ACCEPT_HANDOVER
             null, // MANAGE_IPSEC_HANDOVERS
             null, // START_FOREGROUND
-            new RestrictionBypass(true, false), // BLUETOOTH_SCAN
+            new RestrictionBypass(false, true, false), // BLUETOOTH_SCAN
             null, // USE_BIOMETRIC
             null, // ACTIVITY_RECOGNITION
             null, // SMS_FINANCIAL_TRANSACTIONS
@@ -3105,6 +3105,9 @@ public class AppOpsManager {
      * @hide
      */
     public static class RestrictionBypass {
+        /** Does the app need to be system uid to bypass the restriction */
+        public boolean isSystemUid;
+
         /** Does the app need to be privileged to bypass the restriction */
         public boolean isPrivileged;
 
@@ -3114,12 +3117,14 @@ public class AppOpsManager {
          */
         public boolean isRecordAudioRestrictionExcept;
 
-        public RestrictionBypass(boolean isPrivileged, boolean isRecordAudioRestrictionExcept) {
+        public RestrictionBypass(boolean isSystemUid, boolean isPrivileged,
+                boolean isRecordAudioRestrictionExcept) {
+            this.isSystemUid = isSystemUid;
             this.isPrivileged = isPrivileged;
             this.isRecordAudioRestrictionExcept = isRecordAudioRestrictionExcept;
         }
 
-        public static RestrictionBypass UNRESTRICTED = new RestrictionBypass(true, true);
+        public static RestrictionBypass UNRESTRICTED = new RestrictionBypass(false, true, true);
     }
 
     /**
",14,9,"AppOpsManager::RestrictionBypass::RestrictionBypass, AppOpsManager::RestrictionBypass::RestrictionBypass"
56,9642f85f5b777567389007f222d031e9b81dc3b7,AppOpsService.java,"@@ -4502,8 +4502,9 @@ public class AppOpsService extends IAppOpsService.Stub {
      * @return The restriction matching the package
      */
     private RestrictionBypass getBypassforPackage(@NonNull AndroidPackage pkg) {
-        return new RestrictionBypass(pkg.isPrivileged(), mContext.checkPermission(
-                android.Manifest.permission.EXEMPT_FROM_AUDIO_RECORD_RESTRICTIONS, -1, pkg.getUid())
+        return new RestrictionBypass(pkg.getUid() == Process.SYSTEM_UID, pkg.isPrivileged(),
+                mContext.checkPermission(android.Manifest.permission
+                        .EXEMPT_FROM_AUDIO_RECORD_RESTRICTIONS, -1, pkg.getUid())
                 == PackageManager.PERMISSION_GRANTED);
     }
 
@@ -4785,6 +4786,9 @@ public class AppOpsService extends IAppOpsService.Stub {
                 if (opBypass != null) {
                     // If we are the system, bypass user restrictions for certain codes
                     synchronized (this) {
+                        if (opBypass.isSystemUid && appBypass != null && appBypass.isSystemUid) {
+                            return false;
+                        }
                         if (opBypass.isPrivileged && appBypass != null && appBypass.isPrivileged) {
                             return false;
                         }
",6,2,"AppOpsService::isOpRestrictedLocked, AppOpsService::getBypassforPackage"
57,092156bc632dce1a6a3c56fcec8f45d6cce25afb,AppOpsService.java,"@@ -3242,7 +3242,7 @@ public class AppOpsService extends IAppOpsService.Stub {
             return AppOpsManager.MODE_IGNORED;
         }
         synchronized (this) {
-            if (isOpRestrictedLocked(uid, code, packageName, attributionTag, pvr.bypass)) {
+            if (isOpRestrictedLocked(uid, code, packageName, attributionTag, pvr.bypass, true)) {
                 return AppOpsManager.MODE_IGNORED;
             }
             code = AppOpsManager.opToSwitch(code);
@@ -3459,7 +3459,7 @@ public class AppOpsService extends IAppOpsService.Stub {
 
             final int switchCode = AppOpsManager.opToSwitch(code);
             final UidState uidState = ops.uidState;
-            if (isOpRestrictedLocked(uid, code, packageName, attributionTag, pvr.bypass)) {
+            if (isOpRestrictedLocked(uid, code, packageName, attributionTag, pvr.bypass, false)) {
                 attributedOp.rejected(uidState.state, flags);
                 scheduleOpNotedIfNeededLocked(code, uid, packageName, attributionTag, flags,
                         AppOpsManager.MODE_IGNORED);
@@ -3973,7 +3973,8 @@ public class AppOpsService extends IAppOpsService.Stub {
             final Op op = getOpLocked(ops, code, uid, true);
             final AttributedOp attributedOp = op.getOrCreateAttribution(op, attributionTag);
             final UidState uidState = ops.uidState;
-            isRestricted = isOpRestrictedLocked(uid, code, packageName, attributionTag, pvr.bypass);
+            isRestricted = isOpRestrictedLocked(uid, code, packageName, attributionTag, pvr.bypass,
+                    false);
             final int switchCode = AppOpsManager.opToSwitch(code);
             // If there is a non-default per UID policy (we set UID op mode only if
             // non-default) it takes over, otherwise use the per package policy.
@@ -4764,7 +4765,7 @@ public class AppOpsService extends IAppOpsService.Stub {
     }
 
     private boolean isOpRestrictedLocked(int uid, int code, String packageName,
-            String attributionTag, @Nullable RestrictionBypass appBypass) {
+            String attributionTag, @Nullable RestrictionBypass appBypass, boolean isCheckOp) {
         int restrictionSetCount = mOpGlobalRestrictions.size();
 
         for (int i = 0; i < restrictionSetCount; i++) {
@@ -4781,7 +4782,8 @@ public class AppOpsService extends IAppOpsService.Stub {
             // For each client, check that the given op is not restricted, or that the given
             // package is exempt from the restriction.
             ClientUserRestrictionState restrictionState = mOpUserRestrictions.valueAt(i);
-            if (restrictionState.hasRestriction(code, packageName, attributionTag, userHandle)) {
+            if (restrictionState.hasRestriction(code, packageName, attributionTag, userHandle,
+                    isCheckOp)) {
                 RestrictionBypass opBypass = opAllowSystemBypassRestriction(code);
                 if (opBypass != null) {
                     // If we are the system, bypass user restrictions for certain codes
@@ -7141,7 +7143,7 @@ public class AppOpsService extends IAppOpsService.Stub {
         }
 
         public boolean hasRestriction(int restriction, String packageName, String attributionTag,
-                int userId) {
+                int userId, boolean isCheckOp) {
             if (perUserRestrictions == null) {
                 return false;
             }
@@ -7160,6 +7162,9 @@ public class AppOpsService extends IAppOpsService.Stub {
                 return true;
             }
 
+            if (isCheckOp) {
+                return !perUserExclusions.includes(packageName);
+            }
             return !perUserExclusions.contains(packageName, attributionTag);
         }
 
@@ -7326,7 +7331,8 @@ public class AppOpsService extends IAppOpsService.Stub {
                 int numRestrictions = mOpUserRestrictions.size();
                 for (int i = 0; i < numRestrictions; i++) {
                     if (mOpUserRestrictions.valueAt(i)
-                            .hasRestriction(code, pkg, attributionTag, user.getIdentifier())) {
+                            .hasRestriction(code, pkg, attributionTag, user.getIdentifier(),
+                                    false)) {
                         number++;
                     }
                 }
",13,7,"AppOpsService::AppOpsManagerInternalImpl::getOpRestrictionCount, AppOpsService::ClientUserRestrictionState::hasRestriction, AppOpsService::ClientUserRestrictionState::hasRestriction, AppOpsService::isOpRestrictedLocked, AppOpsService::isOpRestrictedLocked, AppOpsService::noteOperationUnchecked, AppOpsService::startOperationUnchecked, AppOpsService::checkOperationUnchecked"
58,e9e40c316783a0f9529ea5203096e8bceba6d26e,NotificationAccessConfirmationActivityContract.java,"@@ -28,18 +28,15 @@ import com.android.internal.R;
 public final class NotificationAccessConfirmationActivityContract {
     public static final String EXTRA_USER_ID = ""user_id"";
     public static final String EXTRA_COMPONENT_NAME = ""component_name"";
-    public static final String EXTRA_PACKAGE_TITLE = ""package_title"";
 
     /**
      * Creates a launcher intent for NotificationAccessConfirmationActivity.
      */
-    public static Intent launcherIntent(Context context, int userId, ComponentName component,
-            String packageTitle) {
+    public static Intent launcherIntent(Context context, int userId, ComponentName component) {
         return new Intent()
                 .setComponent(ComponentName.unflattenFromString(context.getString(
                         R.string.config_notificationAccessConfirmationActivity)))
                 .putExtra(EXTRA_USER_ID, userId)
-                .putExtra(EXTRA_COMPONENT_NAME, component)
-                .putExtra(EXTRA_PACKAGE_TITLE, packageTitle);
+                .putExtra(EXTRA_COMPONENT_NAME, component);
     }
 }
",2,5,"NotificationAccessConfirmationActivityContract::launcherIntent, NotificationAccessConfirmationActivityContract::launcherIntent"
59,e9e40c316783a0f9529ea5203096e8bceba6d26e,CompanionDeviceManagerService.java,"@@ -74,7 +74,6 @@ import android.content.IntentFilter;
 import android.content.SharedPreferences;
 import android.content.pm.FeatureInfo;
 import android.content.pm.PackageInfo;
-import android.content.pm.PackageItemInfo;
 import android.content.pm.PackageManager;
 import android.content.pm.PackageManagerInternal;
 import android.content.pm.ResolveInfo;
@@ -556,20 +555,12 @@ public class CompanionDeviceManagerService extends SystemService implements Bind
             String callingPackage = component.getPackageName();
             checkCanCallNotificationApi(callingPackage);
             int userId = getCallingUserId();
-            String packageTitle = BidiFormatter.getInstance().unicodeWrap(
-                    getPackageInfo(callingPackage, userId)
-                            .applicationInfo
-                            .loadSafeLabel(getContext().getPackageManager(),
-                                    PackageItemInfo.DEFAULT_MAX_LABEL_SIZE_PX,
-                                    PackageItemInfo.SAFE_LABEL_FLAG_TRIM
-                                            | PackageItemInfo.SAFE_LABEL_FLAG_FIRST_LINE)
-                            .toString());
             final long identity = Binder.clearCallingIdentity();
             try {
                 return PendingIntent.getActivityAsUser(getContext(),
                         0 /* request code */,
                         NotificationAccessConfirmationActivityContract.launcherIntent(
-                                getContext(), userId, component, packageTitle),
+                                getContext(), userId, component),
                         PendingIntent.FLAG_IMMUTABLE | PendingIntent.FLAG_ONE_SHOT
                                 | PendingIntent.FLAG_CANCEL_CURRENT,
                         null /* options */,
",1,10,CompanionDeviceManagerService::CompanionDeviceManagerImpl::requestNotificationAccess
60,b1f5b79a62453d38179ae1fca1b89797ac03bd1b,PacProxyService.java,"@@ -44,6 +44,7 @@ import android.os.SystemClock;
 import android.os.SystemProperties;
 import android.provider.Settings;
 import android.util.Log;
+import android.webkit.URLUtil;
 
 import com.android.internal.annotations.GuardedBy;
 import com.android.internal.util.TrafficStatsConstants;
@@ -232,8 +233,22 @@ public class PacProxyService extends IPacProxyManager.Stub {
      * @throws IOException if the URL is malformed, or the PAC file is too big.
      */
     private static String get(Uri pacUri) throws IOException {
-        URL url = new URL(pacUri.toString());
-        URLConnection urlConnection = url.openConnection(java.net.Proxy.NO_PROXY);
+        if (!URLUtil.isValidUrl(pacUri.toString()))  {
+            throw new IOException(""Malformed URL:"" + pacUri);
+        }
+
+        final URL url = new URL(pacUri.toString());
+        URLConnection urlConnection;
+        try {
+            urlConnection = url.openConnection(java.net.Proxy.NO_PROXY);
+            // Catch the possible exceptions and rethrow as IOException to not to crash the system
+            // for illegal input.
+        } catch (IllegalArgumentException e) {
+            throw new IOException(""Incorrect proxy type for "" + pacUri);
+        } catch (UnsupportedOperationException e) {
+            throw new IOException(""Unsupported URL connection type for "" + pacUri);
+        }
+
         long contentLength = -1;
         try {
             contentLength = Long.parseLong(urlConnection.getHeaderField(""Content-Length""));
",17,2,PacProxyService::get
61,7b5fce10d191dd819048edee9ed01433efea9e72,AbstractThreadedSyncAdapter.java,"@@ -21,6 +21,7 @@ import static com.android.internal.util.function.pooled.PooledLambda.obtainMessa
 import android.accounts.Account;
 import android.annotation.MainThread;
 import android.annotation.NonNull;
+import android.os.Binder;
 import android.os.Build;
 import android.os.Bundle;
 import android.os.Handler;
@@ -171,8 +172,20 @@ public abstract class AbstractThreadedSyncAdapter {
     }
 
     private class ISyncAdapterImpl extends ISyncAdapter.Stub {
+        private boolean isCallerSystem() {
+            final long callingUid = Binder.getCallingUid();
+            if (callingUid != Process.SYSTEM_UID) {
+                android.util.EventLog.writeEvent(0x534e4554, ""203229608"", -1, """");
+                return false;
+            }
+            return true;
+        }
+
         @Override
         public void onUnsyncableAccount(ISyncAdapterUnsyncableAccountCallback cb) {
+            if (!isCallerSystem()) {
+                return;
+            }
             Handler.getMain().sendMessage(obtainMessage(
                     AbstractThreadedSyncAdapter::handleOnUnsyncableAccount,
                     AbstractThreadedSyncAdapter.this, cb));
@@ -181,12 +194,16 @@ public abstract class AbstractThreadedSyncAdapter {
         @Override
         public void startSync(ISyncContext syncContext, String authority, Account account,
                 Bundle extras) {
+            if (!isCallerSystem()) {
+                return;
+            }
             if (ENABLE_LOG) {
                 if (extras != null) {
                     extras.size(); // Unparcel so its toString() will show the contents.
                 }
                 Log.d(TAG, ""startSync() start "" + authority + "" "" + account + "" "" + extras);
             }
+
             try {
                 final SyncContext syncContextClient = new SyncContext(syncContext);
 
@@ -242,6 +259,9 @@ public abstract class AbstractThreadedSyncAdapter {
 
         @Override
         public void cancelSync(ISyncContext syncContext) {
+            if (!isCallerSystem()) {
+                return;
+            }
             try {
                 // synchronize to make sure that mSyncThreads doesn't change between when we
                 // check it and when we use it
",20,0,"AbstractThreadedSyncAdapter::ISyncAdapterImpl::startSync, AbstractThreadedSyncAdapter::ISyncAdapterImpl::cancelSync, AbstractThreadedSyncAdapter::ISyncAdapterImpl::onUnsyncableAccount, AbstractThreadedSyncAdapter::ISyncAdapterImpl::isCallerSystem"
62,57d3806348f9bf2c8d3b33e171869bdd46515bcd,MediaSessionRecord.java,"@@ -1155,6 +1155,9 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR
         public void sendCommand(String packageName, int pid, int uid, String command, Bundle args,
                 ResultReceiver cb) {
             try {
+                final String reason = TAG + "":"" + command;
+                mService.tempAllowlistTargetPkgIfPossible(getUid(), getPackageName(),
+                        pid, uid, packageName, reason);
                 mCb.onCommand(packageName, pid, uid, command, args, cb);
             } catch (RemoteException e) {
                 Log.e(TAG, ""Remote failure in sendCommand."", e);
@@ -1164,6 +1167,9 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR
         public void sendCustomAction(String packageName, int pid, int uid, String action,
                 Bundle args) {
             try {
+                final String reason = TAG + "":custom-"" + action;
+                mService.tempAllowlistTargetPkgIfPossible(getUid(), getPackageName(),
+                        pid, uid, packageName, reason);
                 mCb.onCustomAction(packageName, pid, uid, action, args);
             } catch (RemoteException e) {
                 Log.e(TAG, ""Remote failure in sendCustomAction."", e);
@@ -1172,6 +1178,9 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR
 
         public void prepare(String packageName, int pid, int uid) {
             try {
+                final String reason = TAG + "":prepare"";
+                mService.tempAllowlistTargetPkgIfPossible(getUid(), getPackageName(),
+                        pid, uid, packageName, reason);
                 mCb.onPrepare(packageName, pid, uid);
             } catch (RemoteException e) {
                 Log.e(TAG, ""Remote failure in prepare."", e);
@@ -1181,6 +1190,9 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR
         public void prepareFromMediaId(String packageName, int pid, int uid, String mediaId,
                 Bundle extras) {
             try {
+                final String reason = TAG + "":prepareFromMediaId"";
+                mService.tempAllowlistTargetPkgIfPossible(getUid(), getPackageName(),
+                        pid, uid, packageName, reason);
                 mCb.onPrepareFromMediaId(packageName, pid, uid, mediaId, extras);
             } catch (RemoteException e) {
                 Log.e(TAG, ""Remote failure in prepareFromMediaId."", e);
@@ -1190,6 +1202,9 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR
         public void prepareFromSearch(String packageName, int pid, int uid, String query,
                 Bundle extras) {
             try {
+                final String reason = TAG + "":prepareFromSearch"";
+                mService.tempAllowlistTargetPkgIfPossible(getUid(), getPackageName(),
+                        pid, uid, packageName, reason);
                 mCb.onPrepareFromSearch(packageName, pid, uid, query, extras);
             } catch (RemoteException e) {
                 Log.e(TAG, ""Remote failure in prepareFromSearch."", e);
@@ -1198,6 +1213,9 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR
 
         public void prepareFromUri(String packageName, int pid, int uid, Uri uri, Bundle extras) {
             try {
+                final String reason = TAG + "":prepareFromUri"";
+                mService.tempAllowlistTargetPkgIfPossible(getUid(), getPackageName(),
+                        pid, uid, packageName, reason);
                 mCb.onPrepareFromUri(packageName, pid, uid, uri, extras);
             } catch (RemoteException e) {
                 Log.e(TAG, ""Remote failure in prepareFromUri."", e);
@@ -1206,6 +1224,9 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR
 
         public void play(String packageName, int pid, int uid) {
             try {
+                final String reason = TAG + "":play"";
+                mService.tempAllowlistTargetPkgIfPossible(getUid(), getPackageName(),
+                        pid, uid, packageName, reason);
                 mCb.onPlay(packageName, pid, uid);
             } catch (RemoteException e) {
                 Log.e(TAG, ""Remote failure in play."", e);
@@ -1215,6 +1236,9 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR
         public void playFromMediaId(String packageName, int pid, int uid, String mediaId,
                 Bundle extras) {
             try {
+                final String reason = TAG + "":playFromMediaId"";
+                mService.tempAllowlistTargetPkgIfPossible(getUid(), getPackageName(),
+                        pid, uid, packageName, reason);
                 mCb.onPlayFromMediaId(packageName, pid, uid, mediaId, extras);
             } catch (RemoteException e) {
                 Log.e(TAG, ""Remote failure in playFromMediaId."", e);
@@ -1224,6 +1248,9 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR
         public void playFromSearch(String packageName, int pid, int uid, String query,
                 Bundle extras) {
             try {
+                final String reason = TAG + "":playFromSearch"";
+                mService.tempAllowlistTargetPkgIfPossible(getUid(), getPackageName(),
+                        pid, uid, packageName, reason);
                 mCb.onPlayFromSearch(packageName, pid, uid, query, extras);
             } catch (RemoteException e) {
                 Log.e(TAG, ""Remote failure in playFromSearch."", e);
@@ -1232,6 +1259,9 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR
 
         public void playFromUri(String packageName, int pid, int uid, Uri uri, Bundle extras) {
             try {
+                final String reason = TAG + "":playFromUri"";
+                mService.tempAllowlistTargetPkgIfPossible(getUid(), getPackageName(),
+                        pid, uid, packageName, reason);
                 mCb.onPlayFromUri(packageName, pid, uid, uri, extras);
             } catch (RemoteException e) {
                 Log.e(TAG, ""Remote failure in playFromUri."", e);
@@ -1240,6 +1270,9 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR
 
         public void skipToTrack(String packageName, int pid, int uid, long id) {
             try {
+                final String reason = TAG + "":skipToTrack"";
+                mService.tempAllowlistTargetPkgIfPossible(getUid(), getPackageName(),
+                        pid, uid, packageName, reason);
                 mCb.onSkipToTrack(packageName, pid, uid, id);
             } catch (RemoteException e) {
                 Log.e(TAG, ""Remote failure in skipToTrack"", e);
@@ -1248,6 +1281,9 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR
 
         public void pause(String packageName, int pid, int uid) {
             try {
+                final String reason = TAG + "":pause"";
+                mService.tempAllowlistTargetPkgIfPossible(getUid(), getPackageName(),
+                        pid, uid, packageName, reason);
                 mCb.onPause(packageName, pid, uid);
             } catch (RemoteException e) {
                 Log.e(TAG, ""Remote failure in pause."", e);
@@ -1256,6 +1292,9 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR
 
         public void stop(String packageName, int pid, int uid) {
             try {
+                final String reason = TAG + "":stop"";
+                mService.tempAllowlistTargetPkgIfPossible(getUid(), getPackageName(),
+                        pid, uid, packageName, reason);
                 mCb.onStop(packageName, pid, uid);
             } catch (RemoteException e) {
                 Log.e(TAG, ""Remote failure in stop."", e);
@@ -1264,6 +1303,9 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR
 
         public void next(String packageName, int pid, int uid) {
             try {
+                final String reason = TAG + "":next"";
+                mService.tempAllowlistTargetPkgIfPossible(getUid(), getPackageName(),
+                        pid, uid, packageName, reason);
                 mCb.onNext(packageName, pid, uid);
             } catch (RemoteException e) {
                 Log.e(TAG, ""Remote failure in next."", e);
@@ -1272,6 +1314,9 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR
 
         public void previous(String packageName, int pid, int uid) {
             try {
+                final String reason = TAG + "":previous"";
+                mService.tempAllowlistTargetPkgIfPossible(getUid(), getPackageName(),
+                        pid, uid, packageName, reason);
                 mCb.onPrevious(packageName, pid, uid);
             } catch (RemoteException e) {
                 Log.e(TAG, ""Remote failure in previous."", e);
@@ -1280,6 +1325,9 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR
 
         public void fastForward(String packageName, int pid, int uid) {
             try {
+                final String reason = TAG + "":fastForward"";
+                mService.tempAllowlistTargetPkgIfPossible(getUid(), getPackageName(),
+                        pid, uid, packageName, reason);
                 mCb.onFastForward(packageName, pid, uid);
             } catch (RemoteException e) {
                 Log.e(TAG, ""Remote failure in fastForward."", e);
@@ -1288,6 +1336,9 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR
 
         public void rewind(String packageName, int pid, int uid) {
             try {
+                final String reason = TAG + "":rewind"";
+                mService.tempAllowlistTargetPkgIfPossible(getUid(), getPackageName(),
+                        pid, uid, packageName, reason);
                 mCb.onRewind(packageName, pid, uid);
             } catch (RemoteException e) {
                 Log.e(TAG, ""Remote failure in rewind."", e);
@@ -1296,6 +1347,9 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR
 
         public void seekTo(String packageName, int pid, int uid, long pos) {
             try {
+                final String reason = TAG + "":seekTo"";
+                mService.tempAllowlistTargetPkgIfPossible(getUid(), getPackageName(),
+                        pid, uid, packageName, reason);
                 mCb.onSeekTo(packageName, pid, uid, pos);
             } catch (RemoteException e) {
                 Log.e(TAG, ""Remote failure in seekTo."", e);
@@ -1304,6 +1358,9 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR
 
         public void rate(String packageName, int pid, int uid, Rating rating) {
             try {
+                final String reason = TAG + "":rate"";
+                mService.tempAllowlistTargetPkgIfPossible(getUid(), getPackageName(),
+                        pid, uid, packageName, reason);
                 mCb.onRate(packageName, pid, uid, rating);
             } catch (RemoteException e) {
                 Log.e(TAG, ""Remote failure in rate."", e);
@@ -1312,6 +1369,9 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR
 
         public void setPlaybackSpeed(String packageName, int pid, int uid, float speed) {
             try {
+                final String reason = TAG + "":setPlaybackSpeed"";
+                mService.tempAllowlistTargetPkgIfPossible(getUid(), getPackageName(),
+                        pid, uid, packageName, reason);
                 mCb.onSetPlaybackSpeed(packageName, pid, uid, speed);
             } catch (RemoteException e) {
                 Log.e(TAG, ""Remote failure in setPlaybackSpeed."", e);
@@ -1321,6 +1381,9 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR
         public void adjustVolume(String packageName, int pid, int uid, boolean asSystemService,
                 int direction) {
             try {
+                final String reason = TAG + "":adjustVolume"";
+                mService.tempAllowlistTargetPkgIfPossible(getUid(), getPackageName(),
+                        pid, uid, packageName, reason);
                 if (asSystemService) {
                     mCb.onAdjustVolume(mContext.getPackageName(), Process.myPid(),
                             Process.SYSTEM_UID, direction);
@@ -1334,6 +1397,9 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR
 
         public void setVolumeTo(String packageName, int pid, int uid, int value) {
             try {
+                final String reason = TAG + "":setVolumeTo"";
+                mService.tempAllowlistTargetPkgIfPossible(getUid(), getPackageName(),
+                        pid, uid, packageName, reason);
                 mCb.onSetVolumeTo(packageName, pid, uid, value);
             } catch (RemoteException e) {
                 Log.e(TAG, ""Remote failure in setVolumeTo."", e);
",66,0,"MediaSessionRecord::SessionCb::sendCommand, MediaSessionRecord::SessionCb::playFromSearch, MediaSessionRecord::SessionCb::next, MediaSessionRecord::SessionCb::prepareFromUri, MediaSessionRecord::SessionCb::fastForward, MediaSessionRecord::SessionCb::playFromMediaId, MediaSessionRecord::SessionCb::pause, MediaSessionRecord::SessionCb::sendCustomAction, MediaSessionRecord::SessionCb::stop, MediaSessionRecord::SessionCb::prepare, MediaSessionRecord::SessionCb::prepareFromMediaId, MediaSessionRecord::SessionCb::seekTo, MediaSessionRecord::SessionCb::playFromUri, MediaSessionRecord::SessionCb::setVolumeTo, MediaSessionRecord::SessionCb::play, MediaSessionRecord::SessionCb::rate, MediaSessionRecord::SessionCb::prepareFromSearch, MediaSessionRecord::SessionCb::previous, MediaSessionRecord::SessionCb::skipToTrack, MediaSessionRecord::SessionCb::rewind, MediaSessionRecord::SessionCb::setPlaybackSpeed, MediaSessionRecord::SessionCb::adjustVolume"
63,f6d0f9e8ca43ab65ebaa9247ec388bd0af70c0f3,MediaSessionService.java,"@@ -40,6 +40,7 @@ import android.content.Context;
 import android.content.Intent;
 import android.content.IntentFilter;
 import android.content.pm.PackageManager;
+import android.content.pm.PackageManagerInternal;
 import android.media.AudioManager;
 import android.media.AudioPlaybackConfiguration;
 import android.media.AudioSystem;
@@ -85,6 +86,7 @@ import android.view.ViewConfiguration;
 import com.android.internal.R;
 import com.android.internal.annotations.GuardedBy;
 import com.android.server.LocalManagerRegistry;
+import com.android.server.LocalServices;
 import com.android.server.SystemService;
 import com.android.server.Watchdog;
 import com.android.server.Watchdog.Monitor;
@@ -538,14 +540,19 @@ public class MediaSessionService extends SystemService implements Monitor {
         if (TextUtils.isEmpty(packageName)) {
             throw new IllegalArgumentException(""packageName may not be empty"");
         }
-        String[] packages = mContext.getPackageManager().getPackagesForUid(uid);
-        final int packageCount = packages.length;
-        for (int i = 0; i < packageCount; i++) {
-            if (packageName.equals(packages[i])) {
-                return;
-            }
+        if (uid == Process.ROOT_UID || uid == Process.SHELL_UID) {
+            // If the caller is shell, then trust the packageName given and allow it
+            // to proceed.
+            return;
+        }
+        final PackageManagerInternal packageManagerInternal =
+                LocalServices.getService(PackageManagerInternal.class);
+        final int actualUid = packageManagerInternal.getPackageUid(
+                packageName, 0 /* flags */, UserHandle.getUserId(uid));
+        if (!UserHandle.isSameApp(uid, actualUid)) {
+            throw new IllegalArgumentException(""packageName does not belong to the calling uid; ""
+                    + ""pkg="" + packageName + "", uid="" + uid);
         }
-        throw new IllegalArgumentException(""packageName is not owned by the calling process"");
     }
 
     void tempAllowlistTargetPkgIfPossible(int targetUid, String targetPackage,
",14,7,MediaSessionService::enforcePackageName
64,bbcb4157d8acc45e3fbdf212bcdaa8d002eff446,SplashScreenExceptionList.java,"@@ -81,7 +81,7 @@ class SplashScreenExceptionList {
     @SuppressWarnings(""AndroidFrameworkCompatChange"") // Target sdk check
     public boolean isException(@NonNull String packageName, int targetSdk,
             @Nullable Supplier<ApplicationInfo> infoSupplier) {
-        if (targetSdk >= Build.VERSION_CODES.S) {
+        if (targetSdk > Build.VERSION_CODES.S_V2) {
             return false;
         }
 
",1,1,SplashScreenExceptionList::isException
65,bbcb4157d8acc45e3fbdf212bcdaa8d002eff446,ActivityRecordTests.java,"@@ -2528,7 +2528,9 @@ public class ActivityRecordTests extends WindowTestsBase {
             DeviceConfig.setProperty(DeviceConfig.NAMESPACE_WINDOW_MANAGER,
                     ""splash_screen_exception_list"", DEFAULT_COMPONENT_PACKAGE_NAME, false);
             testLegacySplashScreen(Build.VERSION_CODES.R, TYPE_PARAMETER_LEGACY_SPLASH_SCREEN);
-            testLegacySplashScreen(Build.VERSION_CODES.S, 0);
+            testLegacySplashScreen(Build.VERSION_CODES.S, TYPE_PARAMETER_LEGACY_SPLASH_SCREEN);
+            testLegacySplashScreen(Build.VERSION_CODES.S_V2, TYPE_PARAMETER_LEGACY_SPLASH_SCREEN);
+            testLegacySplashScreen(Build.VERSION_CODES.S_V2 + 1, 0);
         } finally {
             try {
                 DeviceConfig.setProperties(properties);
",3,1,ActivityRecordTests::testCreateRemoveLegacySplashScreenWindow
66,bbcb4157d8acc45e3fbdf212bcdaa8d002eff446,SplashScreenExceptionListTest.java,"@@ -80,13 +80,19 @@ public class SplashScreenExceptionListTest {
     public void packageFromDeviceConfigIgnored() {
         setExceptionListAndWaitForCallback(""com.test.nosplashscreen1,com.test.nosplashscreen2"");
 
-        assertIsException(""com.test.nosplashscreen1"", null);
-        assertIsException(""com.test.nosplashscreen2"", null);
-
-        assertIsNotException(""com.test.nosplashscreen1"", VERSION_CODES.S, null);
-        assertIsNotException(""com.test.nosplashscreen2"", VERSION_CODES.S, null);
-        assertIsNotException(""com.test.splashscreen"", VERSION_CODES.S, null);
-        assertIsNotException(""com.test.splashscreen"", VERSION_CODES.R, null);
+        // In list, up to SC-V2 included
+        assertIsException(""com.test.nosplashscreen1"", VERSION_CODES.R);
+        assertIsException(""com.test.nosplashscreen1"", VERSION_CODES.S);
+        assertIsException(""com.test.nosplashscreen1"", VERSION_CODES.S_V2);
+
+        // In list, after SC-V2
+        assertIsNotException(""com.test.nosplashscreen2"", VERSION_CODES.S_V2 + 1);
+        assertIsNotException(""com.test.nosplashscreen2"", VERSION_CODES.CUR_DEVELOPMENT);
+
+        // Not in list, up to SC-V2 included
+        assertIsNotException(""com.test.splashscreen"", VERSION_CODES.R);
+        assertIsNotException(""com.test.splashscreen"", VERSION_CODES.S);
+        assertIsNotException(""com.test.splashscreen"", VERSION_CODES.S_V2);
     }
 
     private void setExceptionListAndWaitForCallback(String commaSeparatedList) {
@@ -123,16 +129,26 @@ public class SplashScreenExceptionListTest {
         metaData.putBoolean(""android.splashscreen.exception_opt_out"", true);
         assertIsNotException(packageName, VERSION_CODES.R, activityInfo);
         assertIsNotException(packageName, VERSION_CODES.S, activityInfo);
+        assertIsNotException(packageName, VERSION_CODES.S_V2, activityInfo);
 
-        // Exception Pre S
+        // Exception up to T
         metaData.putBoolean(""android.splashscreen.exception_opt_out"", false);
-        assertIsException(packageName, activityInfo);
-        assertIsNotException(packageName, VERSION_CODES.S, activityInfo);
+        assertIsException(packageName, VERSION_CODES.R, activityInfo);
+        assertIsException(packageName, VERSION_CODES.S, activityInfo);
+        assertIsException(packageName, VERSION_CODES.S_V2, activityInfo);
+
+        // No Exception after T
+        assertIsNotException(packageName, VERSION_CODES.S_V2 + 1, activityInfo);
+        assertIsNotException(packageName, VERSION_CODES.CUR_DEVELOPMENT, activityInfo);
 
         // Edge Cases
         activityInfo.metaData = null;
-        assertIsException(packageName, activityInfo);
-        assertIsException(packageName, null);
+        assertIsException(packageName, VERSION_CODES.R, activityInfo);
+        assertIsException(packageName, VERSION_CODES.R);
+    }
+
+    private void assertIsNotException(String packageName, int targetSdk) {
+        assertIsNotException(packageName, targetSdk, null);
     }
 
     private void assertIsNotException(String packageName, int targetSdk,
@@ -142,10 +158,14 @@ public class SplashScreenExceptionListTest {
                 mList.isException(packageName, targetSdk, () -> activityInfo));
     }
 
-    private void assertIsException(String packageName,
+    private void assertIsException(String packageName, int targetSdk) {
+        assertIsException(packageName, targetSdk, null);
+    }
+
+    private void assertIsException(String packageName, int targetSdk,
             ApplicationInfo activityInfo) {
         assertTrue(String.format(""%s (sdk=%d) should have been considered as an exception"",
-                packageName, VERSION_CODES.R),
-                mList.isException(packageName, VERSION_CODES.R, () -> activityInfo));
+                packageName, targetSdk),
+                mList.isException(packageName, targetSdk, () -> activityInfo));
     }
 }
",35,15,"SplashScreenExceptionListTest::assertIsException, SplashScreenExceptionListTest::metaDataOptOut, SplashScreenExceptionListTest::packageFromDeviceConfigIgnored, SplashScreenExceptionListTest::assertIsException, SplashScreenExceptionListTest::assertIsNotException, SplashScreenExceptionListTest::assertIsException"
67,e2c024f96fe049e275d3af61170b0878135e9e9c,VolumeDialogImpl.java,"@@ -1240,22 +1240,25 @@ public class VolumeDialogImpl implements VolumeDialog,
                 == BluetoothProfile.STATE_CONNECTED;
     }
 
+    private boolean isMediaControllerAvailable(MediaController mediaController) {
+        return mediaController != null && !TextUtils.isEmpty(mediaController.getPackageName());
+    }
+
     public void initSettingsH() {
         if (mSettingsView != null) {
             mSettingsView.setVisibility(mDeviceProvisionedController.isCurrentUserSetup()
                     && mActivityManager.getLockTaskModeState() == LOCK_TASK_MODE_NONE
-                    && isBluetoothA2dpConnected()
+                    && (isMediaControllerAvailable(getActiveLocalMediaController())
+                            || isBluetoothA2dpConnected())
                     ? VISIBLE : GONE);
         }
         if (mSettingsIcon != null) {
             mSettingsIcon.setOnClickListener(v -> {
                 Events.writeEvent(Events.EVENT_SETTINGS_CLICK);
                 final MediaController mediaController = getActiveLocalMediaController();
-                String packageName =
-                        mediaController != null
-                                && !TextUtils.isEmpty(mediaController.getPackageName())
-                                ? mediaController.getPackageName()
-                                : """";
+                String packageName = isMediaControllerAvailable(mediaController)
+                        ? mediaController.getPackageName()
+                        : """";
                 mMediaOutputDialogFactory.create(packageName, false, mDialogView);
                 dismissH(DISMISS_REASON_SETTINGS_CLICKED);
             });
",9,6,"VolumeDialogImpl::isMediaControllerAvailable, VolumeDialogImpl::initSettingsH"
68,e26a2ead9dc146ffffa63406963fc4e8a8687202,VolumeDialogImpl.java,"@@ -1259,7 +1259,7 @@ public class VolumeDialogImpl implements VolumeDialog,
                 String packageName = isMediaControllerAvailable(mediaController)
                         ? mediaController.getPackageName()
                         : """";
-                mMediaOutputDialogFactory.create(packageName, false, mDialogView);
+                mMediaOutputDialogFactory.create(packageName, true, mDialogView);
                 dismissH(DISMISS_REASON_SETTINGS_CLICKED);
             });
         }
",1,1,VolumeDialogImpl::initSettingsH
69,33a0c1ca661a4bbd707442713a308be9f606a864,VolumeDialogImpl.java,"@@ -1590,13 +1590,13 @@ public class VolumeDialogImpl implements VolumeDialog,
                     mIsAnimatingDismiss = false;
 
                     hideRingerDrawer();
+                    mController.notifyVisible(false);
                 }, 50));
         if (!shouldSlideInVolumeTray()) {
             animator.translationX(getTranslationForPanelLocation() * mDialogView.getWidth() / 2.0f);
         }
         animator.start();
         checkODICaptionsTooltip(true);
-        mController.notifyVisible(false);
         synchronized (mSafetyWarningLock) {
             if (mSafetyWarning != null) {
                 if (D.BUG) Log.d(TAG, ""SafetyWarning dismissed"");
",1,1,VolumeDialogImpl::dismissH
70,4b55896265e4283636c0297d7a37d14771ed6ff9,UsbDeviceManager.java,"@@ -1520,7 +1520,7 @@ public class UsbDeviceManager implements ActivityTaskManagerInternal.ScreenObser
 
         public void setTrustRestrictUsb() {
             final int restrictUsb = LineageSettings.Global.getInt(mContentResolver,
-                    LineageSettings.Global.TRUST_RESTRICT_USB, 1);
+                    LineageSettings.Global.TRUST_RESTRICT_USB, 0);
             // Effective immediately, ejects any connected USB devices.
             // If the restriction is set to ""only when locked"", only execute once USB is
             // disconnected and keyguard is showing, to avoid ejecting connected devices
",1,1,UsbDeviceManager::UsbHandler::setTrustRestrictUsb
71,16a2ea48ae337131c0825eb4c1d054f41d3bcb4a,DisplayPowerController.java,"@@ -433,14 +433,6 @@ final class DisplayPowerController implements AutomaticBrightnessController.Call
     // PowerManager.BRIGHTNESS_INVALID_FLOAT when there's no temporary adjustment set.
     private float mTemporaryAutoBrightnessAdjustment;
 
-    // Whether reduce bright colors (rbc) has been turned on, or a change in strength has been
-    // requested. We want to retain the current backlight level when rbc is toggled, since rbc
-    // additionally makes the screen appear dimmer using screen colors rather than backlight levels,
-    // and therefore we don't actually want to compensate for this by then in/decreasing the
-    // backlight when toggling this feature.
-    // This should be false during system start up.
-    private boolean mPendingRbcOnOrChanged = false;
-
     // Whether auto brightness is applied one shot when screen is turned on
     private boolean mAutoBrightnessOneShot;
 
@@ -583,35 +575,29 @@ final class DisplayPowerController implements AutomaticBrightnessController.Call
                 @Override
                 public void onReduceBrightColorsActivationChanged(boolean activated,
                         boolean userInitiated) {
-                    applyReduceBrightColorsSplineAdjustment(
-                            /* rbcStrengthChanged= */ false, activated);
+                    applyReduceBrightColorsSplineAdjustment();
 
                 }
 
                 @Override
                 public void onReduceBrightColorsStrengthChanged(int strength) {
-                    applyReduceBrightColorsSplineAdjustment(
-                            /* rbcStrengthChanged= */ true, /* justActivated= */ false);
+                    applyReduceBrightColorsSplineAdjustment();
                 }
             });
             if (active) {
-                applyReduceBrightColorsSplineAdjustment(
-                        /* rbcStrengthChanged= */ false,  /* justActivated= */ false);
+                applyReduceBrightColorsSplineAdjustment();
             }
         } else {
             mCdsi = null;
         }
     }
 
-    private void applyReduceBrightColorsSplineAdjustment(
-            boolean rbcStrengthChanged, boolean justActivated) {
-        final int strengthChanged = rbcStrengthChanged ? 1 : 0;
-        final int activated = justActivated ? 1 : 0;
-        mHandler.obtainMessage(MSG_UPDATE_RBC, strengthChanged, activated).sendToTarget();
+    private void applyReduceBrightColorsSplineAdjustment() {
+        mHandler.obtainMessage(MSG_UPDATE_RBC).sendToTarget();
         sendUpdatePowerState();
     }
 
-    private void handleRbcChanged(boolean strengthChanged, boolean justActivated) {
+    private void handleRbcChanged() {
         if (mBrightnessMapper == null) {
             Log.w(TAG, ""No brightness mapping available to recalculate splines"");
             return;
@@ -623,12 +609,12 @@ final class DisplayPowerController implements AutomaticBrightnessController.Call
         }
         mBrightnessMapper.recalculateSplines(mCdsi.isReduceBrightColorsActivated(), adjustedNits);
 
-        mPendingRbcOnOrChanged = strengthChanged || justActivated;
 
-        // Reset model if strength changed OR rbc is turned off
-        if ((strengthChanged || !justActivated) && mAutomaticBrightnessController != null) {
-            mAutomaticBrightnessController.resetShortTermModel();
-        }
+        // If rbc is turned on, off or there is a change in strength, we want to reset the short
+        // term model. Since the nits range at which brightness now operates has changed due to
+        // RBC/strength change, any short term model based on the previous range should be
+        // invalidated.
+        mAutomaticBrightnessController.resetShortTermModel();
     }
 
     /**
@@ -977,8 +963,7 @@ final class DisplayPowerController implements AutomaticBrightnessController.Call
 
     private void reloadReduceBrightColours() {
         if (mCdsi != null && mCdsi.isReduceBrightColorsActivated()) {
-            applyReduceBrightColorsSplineAdjustment(
-                    /* rbcStrengthChanged= */ false, /* justActivated= */ false);
+            applyReduceBrightColorsSplineAdjustment();
         }
     }
 
@@ -2155,23 +2140,17 @@ final class DisplayPowerController implements AutomaticBrightnessController.Call
     }
 
     // We want to return true if the user has set the screen brightness.
-    // If they have just turned RBC on (and therefore added that interaction to the curve),
-    // or changed the brightness another way, then we should return true.
+    // RBC on, off, and intensity changes will return false.
+    // Slider interactions whilst in RBC will return true, just as when in non-rbc.
     private boolean updateUserSetScreenBrightness() {
-        final boolean treatAsIfUserChanged = mPendingRbcOnOrChanged;
-        if (treatAsIfUserChanged && !Float.isNaN(mCurrentScreenBrightnessSetting)) {
-            mLastUserSetScreenBrightness = mCurrentScreenBrightnessSetting;
-        }
-        mPendingRbcOnOrChanged = false;
-
         if ((Float.isNaN(mPendingScreenBrightnessSetting)
                 || mPendingScreenBrightnessSetting < 0.0f)) {
-            return treatAsIfUserChanged;
+            return false;
         }
         if (mCurrentScreenBrightnessSetting == mPendingScreenBrightnessSetting) {
             mPendingScreenBrightnessSetting = PowerManager.BRIGHTNESS_INVALID_FLOAT;
             mTemporaryScreenBrightness = PowerManager.BRIGHTNESS_INVALID_FLOAT;
-            return treatAsIfUserChanged;
+            return false;
         }
         setCurrentScreenBrightness(mPendingScreenBrightnessSetting);
         mLastUserSetScreenBrightness = mPendingScreenBrightnessSetting;
@@ -2515,9 +2494,7 @@ final class DisplayPowerController implements AutomaticBrightnessController.Call
                     break;
 
                 case MSG_UPDATE_RBC:
-                    final int strengthChanged = msg.arg1;
-                    final int justActivated = msg.arg2;
-                    handleRbcChanged(strengthChanged == 1, justActivated == 1);
+                    handleRbcChanged();
                     break;
             }
         }
",17,40,"DisplayPowerController::handleRbcChanged, DisplayPowerController::reloadReduceBrightColours, DisplayPowerController::applyReduceBrightColorsSplineAdjustment, DisplayPowerController::DisplayPowerController, DisplayPowerController::applyReduceBrightColorsSplineAdjustment, DisplayPowerController::DisplayControllerHandler::handleMessage, DisplayPowerController::handleRbcChanged, DisplayPowerController::updateUserSetScreenBrightness"
72,f27493ca32186a10cc091634bf3e7ee637dcb4b4,ParsingPackageUtils.java,"@@ -20,6 +20,7 @@ import static android.content.pm.ActivityInfo.FLAG_SUPPORTS_PICTURE_IN_PICTURE;
 import static android.content.pm.ActivityInfo.RESIZE_MODE_UNRESIZEABLE;
 import static android.content.pm.PackageManager.INSTALL_PARSE_FAILED_BAD_MANIFEST;
 import static android.content.pm.PackageManager.INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES;
+import static android.content.pm.PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
 import static android.content.pm.PackageManager.INSTALL_PARSE_FAILED_ONLY_COREAPP_ALLOWED;
 import static android.content.pm.PackageManager.INSTALL_PARSE_FAILED_RESOURCES_ARSC_COMPRESSED;
 import static android.content.pm.PackageManager.INSTALL_PARSE_FAILED_UNEXPECTED_EXCEPTION;
@@ -905,6 +906,13 @@ public class ParsingPackageUtils {
             );
         }
 
+        if (ParsedPermissionUtils.declareDuplicatePermission(pkg)) {
+            return input.error(
+                    INSTALL_PARSE_FAILED_MANIFEST_MALFORMED,
+                    ""Declare duplicate permissions with different protection levels or group.""
+            );
+        }
+
         convertNewPermissions(pkg);
 
         convertSplitPermissions(pkg);
",8,0,ParsingPackageUtils::parseBaseApkTags
73,f27493ca32186a10cc091634bf3e7ee637dcb4b4,ParsedPermissionUtils.java,"@@ -25,6 +25,8 @@ import android.content.pm.parsing.result.ParseResult;
 import android.content.res.Resources;
 import android.content.res.TypedArray;
 import android.content.res.XmlResourceParser;
+import android.util.ArrayMap;
+import android.util.EventLog;
 import android.util.Slog;
 
 import com.android.internal.R;
@@ -32,6 +34,8 @@ import com.android.internal.R;
 import org.xmlpull.v1.XmlPullParserException;
 
 import java.io.IOException;
+import java.util.List;
+import java.util.Objects;
 
 /** @hide */
 public class ParsedPermissionUtils {
@@ -233,4 +237,50 @@ public class ParsedPermissionUtils {
         return ComponentParseUtils.parseAllMetaData(pkg, res, parser, tag, permissionGroup,
                 input);
     }
+
+    /**
+     * Determines if a duplicate permission is malformed .i.e. defines different protection level
+     * or group
+     */
+    private static boolean isMalformedDuplicate(ParsedPermission p1, ParsedPermission p2) {
+        // Since a permission tree is also added as a permission with normal protection
+        // level, we need to skip if the parsedPermission is a permission tree.
+        if (p1 == null || p2 == null || p1.isTree() || p2.isTree()) {
+            return false;
+        }
+
+        if (p1.getProtectionLevel() != p2.getProtectionLevel()) {
+            return true;
+        }
+        if (!Objects.equals(p1.getGroup(), p2.getGroup())) {
+            return true;
+        }
+
+        return false;
+    }
+
+    /**
+     * @return {@code true} if the package declares malformed duplicate permissions.
+     *
+     */
+    public static boolean declareDuplicatePermission(@NonNull ParsingPackage pkg) {
+        final List<ParsedPermission> permissions = pkg.getPermissions();
+        final int size = permissions.size();
+        if (size > 0) {
+            final ArrayMap<String, ParsedPermission> checkDuplicatePerm = new ArrayMap<>(size);
+            for (int i = 0; i < size; i++) {
+                final ParsedPermission parsedPermission = permissions.get(i);
+                final String name = parsedPermission.getName();
+                final ParsedPermission perm = checkDuplicatePerm.get(name);
+                if (isMalformedDuplicate(parsedPermission, perm)) {
+                    // Fix for b/213323615
+                    EventLog.writeEvent(0x534e4554, ""213323615"",
+                            ""The package "" + pkg.getPackageName() + "" seems malicious"");
+                    return true;
+                }
+                checkDuplicatePerm.put(name, parsedPermission);
+            }
+        }
+        return false;
+    }
 }
",50,0,"ParsedPermissionUtils::declareDuplicatePermission, ParsedPermissionUtils::isMalformedDuplicate"
74,d42ec4c0e5ad85792f526cc90d8830b02febc1b0,ParsedPermissionUtils.java,"@@ -274,8 +274,7 @@ public class ParsedPermissionUtils {
                 final ParsedPermission perm = checkDuplicatePerm.get(name);
                 if (isMalformedDuplicate(parsedPermission, perm)) {
                     // Fix for b/213323615
-                    EventLog.writeEvent(0x534e4554, ""213323615"",
-                            ""The package "" + pkg.getPackageName() + "" seems malicious"");
+                    EventLog.writeEvent(0x534e4554, ""213323615"");
                     return true;
                 }
                 checkDuplicatePerm.put(name, parsedPermission);
",1,2,ParsedPermissionUtils::declareDuplicatePermission
75,3792f09dcbd496d6c30558d7b26ceff2a6e742d2,DozeSensors.java,"@@ -47,6 +47,7 @@ import com.android.internal.logging.UiEvent;
 import com.android.internal.logging.UiEventLogger;
 import com.android.internal.logging.UiEventLoggerImpl;
 import com.android.keyguard.KeyguardUpdateMonitor;
+import com.android.systemui.R;
 import com.android.systemui.biometrics.AuthController;
 import com.android.systemui.plugins.SensorManagerPlugin;
 import com.android.systemui.statusbar.phone.DozeParameters;
@@ -262,13 +263,15 @@ public class DozeSensors {
                         false /* ignoresSetting */,
                         false /* requiresProx */),
         };
-        setProxListening(false);  // Don't immediately start listening when we register.
-        mProximitySensor.register(
-                proximityEvent -> {
-                    if (proximityEvent != null) {
-                        mProxCallback.accept(!proximityEvent.getBelow());
-                    }
-                });
+        if (context.getResources().getBoolean(R.bool.doze_proximity_sensor_supported)) {
+            setProxListening(false);  // Don't immediately start listening when we register.
+            mProximitySensor.register(
+                    proximityEvent -> {
+                        if (proximityEvent != null) {
+                            mProxCallback.accept(!proximityEvent.getBelow());
+                        }
+                    });
+        }
 
         mDevicePostureController.addCallback(mDevicePostureCallback);
     }
",10,7,DozeSensors::DozeSensors
76,263c70d638de51184f95e4e376c109908fd89dae,NetworkPolicyManagerService.java,"@@ -4252,9 +4252,11 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {
     }
 
     private boolean hasRestrictedModeAccess(int uid) {
+        final long token = Binder.clearCallingIdentity();
         try {
             NetworkCapabilities nc = mConnManager.getNetworkCapabilities(
                     mConnManager.getActiveNetwork());
+            Binder.restoreCallingIdentity(token);
             int policy = getUidPolicy(uid);
             if (nc != null
                     && ((nc.hasTransport(TRANSPORT_VPN) && ((policy & POLICY_REJECT_VPN) != 0))
@@ -4274,6 +4276,8 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {
                     == PERMISSION_GRANTED;
         } catch (RemoteException e) {
             return false;
+        } finally {
+            Binder.restoreCallingIdentity(token);
         }
     }
 
",4,0,NetworkPolicyManagerService::hasRestrictedModeAccess
77,8ba3b2ecf62593344757329e9934db6f2a574276,NetworkPolicyManagerService.java,"@@ -62,6 +62,7 @@ import static android.net.INetd.FIREWALL_RULE_ALLOW;
 import static android.net.INetd.FIREWALL_RULE_DENY;
 import static android.net.NetworkCapabilities.NET_CAPABILITY_NOT_METERED;
 import static android.net.NetworkCapabilities.NET_CAPABILITY_NOT_ROAMING;
+import static android.net.NetworkCapabilities.NET_CAPABILITY_NOT_VPN;
 import static android.net.NetworkCapabilities.TRANSPORT_CELLULAR;
 import static android.net.NetworkCapabilities.TRANSPORT_VPN;
 import static android.net.NetworkCapabilities.TRANSPORT_WIFI;
@@ -626,6 +627,9 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {
     /** Map from network ID to last observed roaming state */
     @GuardedBy(""mNetworkPoliciesSecondLock"")
     private final SparseBooleanArray mNetworkRoaming = new SparseBooleanArray();
+    /** Map from network ID to last observed transports state */
+    @GuardedBy(""mNetworkPoliciesSecondLock"")
+    private final SparseArray<int[]> mNetworkTransports = new SparseArray<>();
 
     /** Map from netId to subId as of last update */
     @GuardedBy(""mNetworkPoliciesSecondLock"")
@@ -1027,6 +1031,14 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {
                     ACTION_CARRIER_CONFIG_CHANGED);
             mContext.registerReceiver(mCarrierConfigReceiver, carrierConfigFilter, null, mHandler);
 
+            for (UserInfo userInfo : mUserManager.getAliveUsers()) {
+                mConnManager.registerDefaultNetworkCallbackForUid(
+                        UserHandle.getUid(userInfo.id, Process.myUid()),
+                        mDefaultNetworkCallback,
+                        mUidEventHandler
+                );
+            }
+
             // listen for meteredness changes
             mConnManager.registerNetworkCallback(
                     new NetworkRequest.Builder().build(), mNetworkCallback);
@@ -1207,6 +1219,11 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {
                                 ConnectivitySettingsManager.getUidsAllowedOnRestrictedNetworks(
                                         mContext);
                         if (action == ACTION_USER_ADDED) {
+                            mConnManager.registerDefaultNetworkCallbackForUid(
+                                    UserHandle.getUid(userId, Process.myUid()),
+                                    mDefaultNetworkCallback,
+                                    mUidEventHandler
+                            );
                             // Add apps that are allowed by default.
                             addDefaultRestrictBackgroundAllowlistUidsUL(userId);
                             try {
@@ -1311,6 +1328,35 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {
         return changed;
     }
 
+    private static boolean updateTransportChange(SparseArray<int[]> lastValues, int[] newValue,
+            Network network) {
+        final int[] lastValue = lastValues.get(network.getNetId(), new int[]{});
+        final boolean changed = (!Arrays.equals(lastValue, newValue))
+                || lastValues.indexOfKey(network.getNetId()) < 0;
+        if (changed) {
+            lastValues.put(network.getNetId(), newValue);
+        }
+        return changed;
+    }
+
+    private final NetworkCallback mDefaultNetworkCallback = new NetworkCallback() {
+        @Override
+        public void onAvailable(@NonNull Network network) {
+            updateRestrictedModeAllowlistUL();
+        }
+
+        @Override
+        public void onCapabilitiesChanged(@NonNull Network network,
+                @NonNull NetworkCapabilities networkCapabilities) {
+            final int[] newTransports = networkCapabilities.getTransportTypes();
+            final boolean transportsChanged = updateTransportChange(
+                    mNetworkTransports, newTransports, network);
+            if (transportsChanged) {
+                updateRestrictedModeAllowlistUL();
+            }
+        }
+    };
+
     private final NetworkCallback mNetworkCallback = new NetworkCallback() {
         @Override
         public void onCapabilitiesChanged(Network network,
@@ -1332,7 +1378,6 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {
                     mLogger.meterednessChanged(network.getNetId(), newMetered);
                     updateNetworkRulesNL();
                 }
-                updateRestrictedModeAllowlistUL();
             }
         }
     };
@@ -4252,32 +4297,50 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {
     }
 
     private boolean hasRestrictedModeAccess(int uid) {
-        final long token = Binder.clearCallingIdentity();
         try {
-            NetworkCapabilities nc = mConnManager.getNetworkCapabilities(
-                    mConnManager.getActiveNetwork());
-            Binder.restoreCallingIdentity(token);
-            int policy = getUidPolicy(uid);
-            if (nc != null
-                    && ((nc.hasTransport(TRANSPORT_VPN) && ((policy & POLICY_REJECT_VPN) != 0))
-                    || (nc.hasTransport(TRANSPORT_CELLULAR) && ((policy & POLICY_REJECT_CELLULAR)
-                    != 0))
-                    || (nc.hasTransport(TRANSPORT_WIFI) && ((policy & POLICY_REJECT_WIFI) != 0)))) {
-                return false;
-            }
             // TODO: this needs to be kept in sync with
             // PermissionMonitor#hasRestrictedNetworkPermission
-            return ConnectivitySettingsManager.getUidsAllowedOnRestrictedNetworks(mContext)
+            // Check for restricted-networking-mode status
+            final boolean isUidAllowedOnRestrictedNetworks =
+                    ConnectivitySettingsManager.getUidsAllowedOnRestrictedNetworks(mContext)
                     .contains(uid)
                     || mIPm.checkUidPermission(CONNECTIVITY_USE_RESTRICTED_NETWORKS, uid)
                     == PERMISSION_GRANTED
                     || mIPm.checkUidPermission(NETWORK_STACK, uid) == PERMISSION_GRANTED
                     || mIPm.checkUidPermission(PERMISSION_MAINLINE_NETWORK_STACK, uid)
                     == PERMISSION_GRANTED;
+
+            // Check for other policies (data-restrictions)
+            final long token = Binder.clearCallingIdentity();
+            NetworkCapabilities nc;
+            try {
+                nc = mConnManager.getNetworkCapabilities(mConnManager.getActiveNetwork());
+            } finally {
+                Binder.restoreCallingIdentity(token);
+            }
+            boolean isUidRestrictedByPolicy = false;
+            if (isUidAllowedOnRestrictedNetworks && nc != null) {
+                int policy = getUidPolicy(uid);
+                final boolean isUidAllowedOnVpn = nc.hasTransport(TRANSPORT_VPN)
+                        && ((policy & POLICY_REJECT_VPN) == 0);
+                if (!isUidAllowedOnVpn) {
+                    final boolean isUidRestrictedOnCell = nc.hasTransport(TRANSPORT_CELLULAR)
+                            && ((policy & POLICY_REJECT_CELLULAR) != 0);
+                    final boolean isUidRestrictedOnVpn = nc.hasTransport(TRANSPORT_VPN)
+                            && ((policy & POLICY_REJECT_VPN) != 0);
+                    final boolean isUidRestrictedOnWifi = nc.hasTransport(TRANSPORT_WIFI)
+                            && ((policy & POLICY_REJECT_WIFI) != 0);
+                    if (isUidRestrictedOnVpn || isUidRestrictedOnCell || isUidRestrictedOnWifi) {
+                            isUidRestrictedByPolicy = true;
+                    }
+                }
+            }
+            // If app is restricted (aka not on the allowlist), it's not allowed to use the internet
+            // If it is on the allowlist, then we also check its networking is not blocked
+            // (aka active network is not null) and then other policies
+            return isUidAllowedOnRestrictedNetworks && nc != null && !isUidRestrictedByPolicy;
         } catch (RemoteException e) {
             return false;
-        } finally {
-            Binder.restoreCallingIdentity(token);
         }
     }
 
",79,16,"NetworkPolicyManagerService::NetworkCallback, NetworkPolicyManagerService::updateTransportChange, NetworkPolicyManagerService::initService, NetworkPolicyManagerService::hasRestrictedModeAccess, NetworkPolicyManagerService::BroadcastReceiver"
78,94af8f82a44c09f7cafabc7bffa06b2e52ca787b,NetworkPolicyManagerService.java,"@@ -1158,10 +1158,10 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {
             if (ACTION_PACKAGE_ADDED.equals(action)) {
                 // update rules for UID, since it might be subject to
                 // global background data policy
-                if (LOGV) Slog.v(TAG, ""ACTION_PACKAGE_ADDED for uid="" + uid);
                 // Clear the cache for the app
                 synchronized (mUidRulesFirstLock) {
                     if (hasInternetPermissionUL(uid)) {
+                        Slog.i(TAG, ""ACTION_PACKAGE_ADDED for uid="" + uid);
                         Set<Integer> uids =
                                 ConnectivitySettingsManager.getUidsAllowedOnRestrictedNetworks(
                                         context);
",1,1,NetworkPolicyManagerService::BroadcastReceiver
79,cd997ae00ace81cd210ef028032de27462eb7ce4,NetworkPolicyManagerService.java,"@@ -1185,7 +1185,7 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {
             if (uid == -1) return;
 
             // remove any policy and update rules to clean up
-            if (LOGV) Slog.v(TAG, ""ACTION_UID_REMOVED for uid="" + uid);
+            Slog.i(TAG, ""ACTION_UID_REMOVED for uid="" + uid);
             synchronized (mUidRulesFirstLock) {
                 onUidDeletedUL(uid);
                 synchronized (mNetworkPoliciesSecondLock) {
",1,1,NetworkPolicyManagerService::BroadcastReceiver
80,9d57437aaeaaafbf9de681afed1fbd406935a8d8,NetworkPolicyManagerService.java,"@@ -33,6 +33,7 @@ import static android.content.Intent.ACTION_PACKAGE_ADDED;
 import static android.content.Intent.ACTION_UID_REMOVED;
 import static android.content.Intent.ACTION_USER_ADDED;
 import static android.content.Intent.ACTION_USER_REMOVED;
+import static android.content.Intent.EXTRA_REPLACING;
 import static android.content.Intent.EXTRA_UID;
 import static android.content.pm.PackageManager.MATCH_ANY_USER;
 import static android.content.pm.PackageManager.MATCH_DIRECT_BOOT_AWARE;
@@ -1155,6 +1156,11 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {
             final int uid = intent.getIntExtra(EXTRA_UID, -1);
             if (uid == -1) return;
 
+            if (intent.getBooleanExtra(EXTRA_REPLACING, false)) {
+                if (LOGV) Slog.v(TAG, ""ACTION_PACKAGE_ADDED Not new app, skip it uid="" + uid);
+                return;
+            }
+
             if (ACTION_PACKAGE_ADDED.equals(action)) {
                 // update rules for UID, since it might be subject to
                 // global background data policy
",6,0,NetworkPolicyManagerService::BroadcastReceiver
81,759bccdedd80beb711ae950d38d5ddbbd88c7e30,NetworkPolicyManager.java,"@@ -103,6 +103,10 @@ public class NetworkPolicyManager {
      * @hide
      */
     public static final int POLICY_REJECT_ALL = 0x40000;
+    /** Reject network usage on all networks, migration helper
+     * @hide
+     */
+    public static final int POLICY_REJECT_ALL_MIGRATED = 0x80000;
 
     /*
      * Rules defining whether an uid has access to a network given its type (metered / non-metered).
",4,0,
82,759bccdedd80beb711ae950d38d5ddbbd88c7e30,NetworkPolicyManagerService.java,"@@ -89,6 +89,7 @@ import static android.net.NetworkPolicyManager.MASK_RESTRICTED_MODE_NETWORKS;
 import static android.net.NetworkPolicyManager.POLICY_ALLOW_METERED_BACKGROUND;
 import static android.net.NetworkPolicyManager.POLICY_NONE;
 import static android.net.NetworkPolicyManager.POLICY_REJECT_ALL;
+import static android.net.NetworkPolicyManager.POLICY_REJECT_ALL_MIGRATED;
 import static android.net.NetworkPolicyManager.POLICY_REJECT_CELLULAR;
 import static android.net.NetworkPolicyManager.POLICY_REJECT_METERED_BACKGROUND;
 import static android.net.NetworkPolicyManager.POLICY_REJECT_VPN;
@@ -2477,6 +2478,7 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {
 
         // Clear policy to avoid future conflicts
         for (int uid : uidsToDeny) {
+            addUidPolicy(uid, POLICY_REJECT_ALL_MIGRATED);
             removeUidPolicy(uid, POLICY_REJECT_ALL);
         }
     }
",2,0,NetworkPolicyManagerService::migrateNetworkIsolation
83,f507e578bb9e8539493dce829307b28b865fdc2a,NetworkPolicyBackupHelper.java,"@@ -33,8 +33,11 @@ public class NetworkPolicyBackupHelper extends BlobBackupHelper {
     // Key under which the payload blob is stored
     static final String KEY_NETWORK_POLICY = ""network_policy"";
 
-    public NetworkPolicyBackupHelper() {
+    private final int mUserId;
+
+    public NetworkPolicyBackupHelper(int userId) {
         super(BLOB_VERSION, KEY_NETWORK_POLICY);
+        mUserId = userId;
     }
 
     @Override
@@ -44,10 +47,10 @@ public class NetworkPolicyBackupHelper extends BlobBackupHelper {
             try {
                 INetworkPolicyManager npm = INetworkPolicyManager.Stub.asInterface(
                         ServiceManager.getService(Context.NETWORK_POLICY_SERVICE));
-                newPayload = npm.getBackupPayload();
+                newPayload = npm.getBackupPayload(mUserId);
             } catch (Exception e) {
                 // Treat as no data
-                Slog.e(TAG, ""Couldn't communicate with network policy manager"");
+                Slog.e(TAG, ""Couldn't communicate with network policy manager"", e);
                 newPayload = null;
             }
         }
@@ -64,9 +67,9 @@ public class NetworkPolicyBackupHelper extends BlobBackupHelper {
             try {
                 INetworkPolicyManager.Stub.asInterface(
                         ServiceManager.getService(Context.NETWORK_POLICY_SERVICE))
-                        .applyRestore(payload);
+                        .applyRestore(payload, mUserId);
             } catch (Exception e) {
-                Slog.e(TAG, ""Couldn't communicate with network policy manager"");
+                Slog.e(TAG, ""Couldn't communicate with network policy manager"", e);
             }
         }
     }
",8,5,"NetworkPolicyBackupHelper::NetworkPolicyBackupHelper, NetworkPolicyBackupHelper::NetworkPolicyBackupHelper, NetworkPolicyBackupHelper::getBackupPayload, NetworkPolicyBackupHelper::applyRestoredPayload"
84,f507e578bb9e8539493dce829307b28b865fdc2a,SystemBackupAgent.java,"@@ -84,7 +84,7 @@ public class SystemBackupAgent extends BackupAgentHelper {
     private static final String WALLPAPER_IMAGE_KEY = WallpaperBackupHelper.WALLPAPER_IMAGE_KEY;
 
     private static final Set<String> sEligibleForMultiUser = Sets.newArraySet(
-            PERMISSION_HELPER, NOTIFICATION_HELPER, SYNC_SETTINGS_HELPER);
+            PERMISSION_HELPER, NOTIFICATION_HELPER, SYNC_SETTINGS_HELPER, NETWORK_POLICY_HELPER);
 
     private int mUserId = UserHandle.USER_SYSTEM;
 
@@ -103,7 +103,7 @@ public class SystemBackupAgent extends BackupAgentHelper {
         addHelper(ACCOUNT_MANAGER_HELPER, new AccountManagerBackupHelper());
         addHelper(SLICES_HELPER, new SliceBackupHelper(this));
         addHelper(PEOPLE_HELPER, new PeopleBackupHelper(mUserId));
-        addHelper(NETWORK_POLICY_HELPER, new NetworkPolicyBackupHelper());
+        addHelper(NETWORK_POLICY_HELPER, new NetworkPolicyBackupHelper(mUserId));
     }
 
     @Override
",2,2,SystemBackupAgent::onCreate
85,f507e578bb9e8539493dce829307b28b865fdc2a,NetworkPolicyManagerService.java,"@@ -426,7 +426,6 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {
     private static final String ATTR_OWNER_PACKAGE = ""ownerPackage"";
     private static final String ATTR_NETWORK_TYPES = ""networkTypes"";
     private static final String ATTR_XML_UTILS_NAME = ""name"";
-    private static final String ATTR_USER_ID = ""userId"";
 
     private static final String ACTION_ALLOW_BACKGROUND =
             ""com.android.server.net.action.ALLOW_BACKGROUND"";
@@ -2496,7 +2495,7 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {
         FileInputStream fis = null;
         try {
             fis = mPolicyFile.openRead();
-            readPolicyXml(fis, false);
+            readPolicyXml(fis, false, UserHandle.USER_ALL);
         } catch (FileNotFoundException e) {
             // missing policy is okay, probably first boot
             upgradeDefaultBackgroundDataUL();
@@ -2510,8 +2509,8 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {
         migrateNetworkIsolation();
     }
 
-    private void readPolicyXml(InputStream inputStream, boolean forRestore) throws IOException,
-            XmlPullParserException {
+    private void readPolicyXml(InputStream inputStream, boolean forRestore, int userId)
+            throws IOException, XmlPullParserException {
         final TypedXmlPullParser in = Xml.resolvePullParser(inputStream);
 
          // Must save the <restrict-background> tags and convert them to <uid-policy> later,
@@ -2671,7 +2670,7 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {
                             SubscriptionPlan.class, mSubscriptionPlans.get(subId), plan));
                     mSubscriptionPlansOwner.put(subId, ownerPackage);
                 } else if (TAG_UID_POLICY.equals(tag)) {
-                    int uid = readUidAttribute(in, forRestore);
+                    int uid = readUidAttribute(in, forRestore, userId);
                     final int policy = readIntAttribute(in, ATTR_POLICY);
 
                     if (UserHandle.isApp(uid)) {
@@ -2694,10 +2693,10 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {
                 } else if (TAG_WHITELIST.equals(tag)) {
                     insideAllowlist = true;
                 } else if (TAG_RESTRICT_BACKGROUND.equals(tag) && insideAllowlist) {
-                    int uid = readUidAttribute(in, forRestore);
+                    int uid = readUidAttribute(in, forRestore, userId);
                     restrictBackgroundAllowedUids.append(uid, true);
                 } else if (TAG_REVOKED_RESTRICT_BACKGROUND.equals(tag) && insideAllowlist) {
-                    int uid = readUidAttribute(in, forRestore);
+                    int uid = readUidAttribute(in, forRestore, userId);
                     mRestrictBackgroundAllowlistRevokedUids.put(uid, true);
                 }
             } else if (type == END_TAG) {
@@ -2801,7 +2800,7 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {
         FileOutputStream fos = null;
         try {
             fos = mPolicyFile.startWrite();
-            writePolicyXml(fos, false);
+            writePolicyXml(fos, false, UserHandle.USER_ALL);
             mPolicyFile.finishWrite(fos);
         } catch (IOException e) {
             if (fos != null) {
@@ -2810,10 +2809,64 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {
         }
     }
 
-    private void writePolicyXml(OutputStream outputStream, boolean forBackup) throws IOException {
+    private void writePolicyXml(OutputStream outputStream, boolean forBackup, int userId)
+            throws IOException {
         TypedXmlSerializer out = Xml.resolveSerializer(outputStream);
         out.startDocument(null, true);
 
+        // only write UID-independent attributes during normal operation or system user backups
+        if (!forBackup || userId == UserHandle.USER_SYSTEM) {
+            writeUidIndependentAttributes(out);
+        }
+
+        // write all known uid policies
+        for (int i = 0; i < mUidPolicy.size(); i++) {
+            final int uid = mUidPolicy.keyAt(i);
+            final int policy = mUidPolicy.valueAt(i);
+
+            // skip writing policies belonging to other users
+            if (forBackup && UserHandle.getUserId(uid) != userId) {
+                continue;
+            }
+            // skip writing empty policies
+            if (policy == POLICY_NONE) continue;
+
+            out.startTag(null, TAG_UID_POLICY);
+            if (!forBackup) {
+                writeIntAttribute(out, ATTR_UID, uid);
+            } else {
+                writeStringAttribute(out, ATTR_XML_UTILS_NAME, getPackageForUid(uid));
+            }
+            writeIntAttribute(out, ATTR_POLICY, policy);
+            out.endTag(null, TAG_UID_POLICY);
+        }
+
+        // write all allowlists
+        out.startTag(null, TAG_WHITELIST);
+
+        // revoked restrict background allowlist
+        int size = mRestrictBackgroundAllowlistRevokedUids.size();
+        for (int i = 0; i < size; i++) {
+            final int uid = mRestrictBackgroundAllowlistRevokedUids.keyAt(i);
+            // skip writing policies belonging to other users
+            if (forBackup && UserHandle.getUserId(uid) != userId) {
+                continue;
+            }
+            out.startTag(null, TAG_REVOKED_RESTRICT_BACKGROUND);
+            if (!forBackup) {
+                writeIntAttribute(out, ATTR_UID, uid);
+            } else {
+                writeStringAttribute(out, ATTR_XML_UTILS_NAME, getPackageForUid(uid));
+            }
+            out.endTag(null, TAG_REVOKED_RESTRICT_BACKGROUND);
+        }
+
+        out.endTag(null, TAG_WHITELIST);
+
+        out.endDocument();
+    }
+
+    private void writeUidIndependentAttributes(TypedXmlSerializer out) throws IOException {
         out.startTag(null, TAG_POLICY_LIST);
         writeIntAttribute(out, ATTR_VERSION, VERSION_LATEST);
         writeBooleanAttribute(out, ATTR_RESTRICT_BACKGROUND, mRestrictBackground);
@@ -2880,89 +2933,43 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {
                 writeLongAttribute(out, ATTR_USAGE_TIME, plan.getDataUsageTime());
                 try {
                     writeIntArrayXml(plan.getNetworkTypes(), ATTR_NETWORK_TYPES, out);
-                } catch (XmlPullParserException ignored) { }
+                } catch (XmlPullParserException ignored) {
+                }
                 out.endTag(null, TAG_SUBSCRIPTION_PLAN);
             }
         }
-
-        // write all known uid policies
-        for (int i = 0; i < mUidPolicy.size(); i++) {
-            final int uid = mUidPolicy.keyAt(i);
-            final int policy = mUidPolicy.valueAt(i);
-
-            // skip writing empty policies
-            if (policy == POLICY_NONE) continue;
-
-            out.startTag(null, TAG_UID_POLICY);
-            if (!forBackup) {
-                writeIntAttribute(out, ATTR_UID, uid);
-            } else {
-                writeStringAttribute(out, ATTR_XML_UTILS_NAME, getPackageForUid(uid));
-                writeIntAttribute(out, ATTR_USER_ID, UserHandle.getUserId(uid));
-            }
-            writeIntAttribute(out, ATTR_POLICY, policy);
-            out.endTag(null, TAG_UID_POLICY);
-        }
-
         out.endTag(null, TAG_POLICY_LIST);
-
-        // write all allowlists
-        out.startTag(null, TAG_WHITELIST);
-
-        // revoked restrict background allowlist
-        int size = mRestrictBackgroundAllowlistRevokedUids.size();
-        for (int i = 0; i < size; i++) {
-            final int uid = mRestrictBackgroundAllowlistRevokedUids.keyAt(i);
-            out.startTag(null, TAG_REVOKED_RESTRICT_BACKGROUND);
-            if (!forBackup) {
-                writeIntAttribute(out, ATTR_UID, uid);
-            } else {
-                writeStringAttribute(out, ATTR_XML_UTILS_NAME, getPackageForUid(uid));
-                writeIntAttribute(out, ATTR_USER_ID, UserHandle.getUserId(uid));
-            }
-            out.endTag(null, TAG_REVOKED_RESTRICT_BACKGROUND);
-        }
-
-        out.endTag(null, TAG_WHITELIST);
-
-        out.endDocument();
     }
 
     @Override
-    public byte[] getBackupPayload() {
+    public byte[] getBackupPayload(int user) {
         enforceSystemCaller();
-        if (LOGD) Slog.d(TAG, ""getBackupPayload"");
+        if (LOGD) Slog.d(TAG, ""getBackupPayload u= "" + user);
         final ByteArrayOutputStream baos = new ByteArrayOutputStream();
         try {
-            writePolicyXml(baos, true);
+            writePolicyXml(baos, true, user);
             return baos.toByteArray();
         } catch (IOException e) {
-            Slog.w(TAG, ""getBackupPayload: error writing payload"", e);
+            Slog.w(TAG, ""getBackupPayload: error writing payload for user "" + user, e);
         }
         return null;
     }
 
     @Override
-    public void applyRestore(byte[] payload) {
+    public void applyRestore(byte[] payload, int user) {
         enforceSystemCaller();
-        if (LOGD) Slog.d(TAG, ""applyRestore payload=""
+        if (LOGD) Slog.d(TAG, ""applyRestore u="" + user + "" payload=""
                 + (payload != null ? new String(payload, StandardCharsets.UTF_8) : null));
         if (payload == null) {
-            Slog.w(TAG, ""applyRestore: no payload to restore"");
+            Slog.w(TAG, ""applyRestore: no payload to restore for user "" + user);
             return;
         }
 
-        // clear any existing policy and read from disk
-        mNetworkPolicy.clear();
-        mSubscriptionPlans.clear();
-        mSubscriptionPlansOwner.clear();
-        mUidPolicy.clear();
-
         final ByteArrayInputStream bais = new ByteArrayInputStream(payload);
         try {
-            readPolicyXml(bais, true);
+            readPolicyXml(bais, true, user);
         } catch (IOException | XmlPullParserException e) {
-            Slog.w(TAG, ""applyRestore: error reading payload"", e);
+            Slog.w(TAG, ""applyRestore: error reading payload for user "" + user, e);
         }
 
         // Migrate from pre-12 network-isolation to restricted-networking-mode
@@ -6096,17 +6103,21 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {
         }
     }
 
-    private int readUidAttribute(TypedXmlPullParser in, boolean forRestore) throws IOException {
+    private int readUidAttribute(TypedXmlPullParser in, boolean forRestore, int userId)
+            throws IOException {
         if (!forRestore) {
             return readIntAttribute(in, ATTR_UID);
         } else {
-            return getUidForPackage(readStringAttribute(in, ATTR_XML_UTILS_NAME),
-                    readIntAttribute(in, ATTR_USER_ID));
+            return getUidForPackage(readStringAttribute(in, ATTR_XML_UTILS_NAME), userId);
         }
     }
 
     private String getPackageForUid(int uid) {
-        return mContext.getPackageManager().getPackagesForUid(uid)[0];
+        try {
+            return mContext.getPackageManager().getPackagesForUid(uid)[0];
+        } catch (Exception e) {
+            return null;
+        }
     }
 
     private int getUidForPackage(String packageName, int userId) {
",81,70,"NetworkPolicyManagerService::writeUidIndependentAttributes, NetworkPolicyManagerService::readPolicyXml, NetworkPolicyManagerService::readPolicyAL, NetworkPolicyManagerService::readUidAttribute, NetworkPolicyManagerService::writePolicyAL, NetworkPolicyManagerService::getBackupPayload, NetworkPolicyManagerService::writePolicyXml, NetworkPolicyManagerService::applyRestore, NetworkPolicyManagerService::getPackageForUid, NetworkPolicyManagerService::readPolicyXml, NetworkPolicyManagerService::getBackupPayload, NetworkPolicyManagerService::writePolicyXml, NetworkPolicyManagerService::readUidAttribute, NetworkPolicyManagerService::applyRestore"
86,7d859aa90a381d80da2580e9b384c72c1e668859,NetworkPolicyManagerService.java,"@@ -2841,6 +2841,26 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {
             out.endTag(null, TAG_UID_POLICY);
         }
 
+        if (forBackup) {
+            try {
+                List<PackageInfo> packages = mIPm.getPackagesHoldingPermissions(
+                        new String[]{android.Manifest.permission.INTERNET}, 0, userId
+                ).getList();
+                List<Integer> uids = packages.stream().map(packageInfo ->
+                        packageInfo.applicationInfo.uid).collect(Collectors.toList());
+                uids.removeAll(
+                        ConnectivitySettingsManager.getUidsAllowedOnRestrictedNetworks(mContext));
+                for (int uid : uids) {
+                    out.startTag(null, TAG_UID_POLICY);
+                    writeStringAttribute(out, ATTR_XML_UTILS_NAME, getPackageForUid(uid));
+                    writeIntAttribute(out, ATTR_POLICY, POLICY_REJECT_ALL);
+                    out.endTag(null, TAG_UID_POLICY);
+                }
+            } catch (RemoteException ignored) {
+
+            }
+        }
+
         // write all allowlists
         out.startTag(null, TAG_WHITELIST);
 
",20,0,NetworkPolicyManagerService::writePolicyXml
87,e1f5dc7e844cf7171c89766800cce8e55462461e,QuickStatusBarHeaderController.java,"@@ -18,10 +18,8 @@ package com.android.systemui.qs;
 
 import android.os.Bundle;
 
-import com.android.internal.colorextraction.ColorExtractor;
 import com.android.systemui.R;
 import com.android.systemui.battery.BatteryMeterViewController;
-import com.android.systemui.colorextraction.SysuiColorExtractor;
 import com.android.systemui.demomode.DemoMode;
 import com.android.systemui.demomode.DemoModeController;
 import com.android.systemui.flags.FeatureFlags;
@@ -64,9 +62,6 @@ class QuickStatusBarHeaderController extends ViewController<QuickStatusBarHeader
 
     private boolean mListening;
 
-    private SysuiColorExtractor mColorExtractor;
-    private ColorExtractor.OnColorsChangedListener mOnColorsChangedListener;
-
     @Inject
     QuickStatusBarHeaderController(QuickStatusBarHeader view,
             HeaderPrivacyIconsController headerPrivacyIconsController,
@@ -74,7 +69,6 @@ class QuickStatusBarHeaderController extends ViewController<QuickStatusBarHeader
             DemoModeController demoModeController,
             QuickQSPanelController quickQSPanelController,
             QSCarrierGroupController.Builder qsCarrierGroupControllerBuilder,
-            SysuiColorExtractor colorExtractor,
             QSExpansionPathInterpolator qsExpansionPathInterpolator,
             BatteryMeterViewController batteryMeterViewController,
             FeatureFlags featureFlags,
@@ -104,12 +98,6 @@ class QuickStatusBarHeaderController extends ViewController<QuickStatusBarHeader
 
         mIconManager = new StatusBarIconController.TintedIconManager(mIconContainer, featureFlags);
         mDemoModeReceiver = new ClockDemoModeReceiver(mClockView);
-        mColorExtractor = colorExtractor;
-        mOnColorsChangedListener = (extractor, which) -> {
-            final boolean lightTheme = mColorExtractor.getNeutralColors().supportsDarkText();
-            mClockView.onColorsChanged(lightTheme);
-        };
-        mColorExtractor.addOnColorsChangedListener(mOnColorsChangedListener);
 
         // Don't need to worry about tuner settings for this icon
         mBatteryMeterViewController.ignoreTunerUpdates();
@@ -157,7 +145,6 @@ class QuickStatusBarHeaderController extends ViewController<QuickStatusBarHeader
 
     @Override
     protected void onViewDetached() {
-        mColorExtractor.removeOnColorsChangedListener(mOnColorsChangedListener);
         mPrivacyIconsController.onParentInvisible();
         mStatusBarIconController.removeIconGroup(mIconManager);
         mQSCarrierGroupController.setOnSingleCarrierChangedListener(null);
",0,13,"QuickStatusBarHeaderController::onViewDetached, QuickStatusBarHeaderController::QuickStatusBarHeaderController"
88,e1f5dc7e844cf7171c89766800cce8e55462461e,Clock.java,"@@ -37,12 +37,10 @@ import android.text.format.DateFormat;
 import android.text.style.CharacterStyle;
 import android.text.style.RelativeSizeSpan;
 import android.util.AttributeSet;
-import android.view.ContextThemeWrapper;
 import android.view.Display;
 import android.view.View;
 import android.widget.TextView;
 
-import com.android.settingslib.Utils;
 import com.android.systemui.Dependency;
 import com.android.systemui.FontSizeUtils;
 import com.android.systemui.R;
@@ -343,13 +341,6 @@ public class Clock extends TextView implements
         setTextColor(mNonAdaptedColor);
     }
 
-    // Update text color based when shade scrim changes color.
-    public void onColorsChanged(boolean lightTheme) {
-        final Context context = new ContextThemeWrapper(mContext,
-                lightTheme ? R.style.Theme_SystemUI_LightWallpaper : R.style.Theme_SystemUI);
-        setTextColor(Utils.getColorAttrDefaultColor(context, R.attr.wallpaperTextColor));
-    }
-
     @Override
     public void onDensityOrFontScaleChanged() {
         FontSizeUtils.updateFontSize(this, R.dimen.status_bar_clock_size);
",0,9,Clock::onColorsChanged
89,a66abdde6d19431ac16ed009e492e2c7aa63a4fc,QSCustomizer.java,"@@ -20,6 +20,9 @@ import android.animation.Animator.AnimatorListener;
 import android.animation.AnimatorListenerAdapter;
 import android.content.Context;
 import android.content.res.Configuration;
+import android.graphics.Color;
+import android.text.SpannableString;
+import android.text.style.ForegroundColorSpan;
 import android.util.AttributeSet;
 import android.util.TypedValue;
 import android.view.LayoutInflater;
@@ -73,8 +76,11 @@ public class QSCustomizer extends LinearLayout {
         toolbar.setNavigationIcon(
                 getResources().getDrawable(value.resourceId, mContext.getTheme()));
 
-        toolbar.getMenu().add(Menu.NONE, MENU_RESET, 0,
+        SpannableString resetText = new SpannableString(
                 mContext.getString(com.android.internal.R.string.reset));
+        resetText.setSpan(new ForegroundColorSpan(isNightMode() ?
+                Color.WHITE : Color.BLACK), 0, resetText.length(), 0);
+        toolbar.getMenu().add(Menu.NONE, MENU_RESET, 0, resetText);
         toolbar.setTitle(R.string.qs_edit);
         mRecyclerView = findViewById(android.R.id.list);
         mTransparentView = findViewById(R.id.customizer_transparent_view);
@@ -83,6 +89,11 @@ public class QSCustomizer extends LinearLayout {
         mRecyclerView.setItemAnimator(animator);
     }
 
+    private boolean isNightMode() {
+        return (mContext.getResources().getConfiguration().uiMode
+                & Configuration.UI_MODE_NIGHT_MASK) == Configuration.UI_MODE_NIGHT_YES;
+    }
+
     void updateResources() {
         LayoutParams lp = (LayoutParams) mTransparentView.getLayoutParams();
         lp.height = Utils.getQsHeaderSystemIconsAreaHeight(mContext);
",12,1,"QSCustomizer::QSCustomizer, QSCustomizer::isNightMode"
90,c8c129afe16f5b4c9da9bf4c07a0bbeba4e4f697,InputMethodManager.java,"@@ -2958,7 +2958,7 @@ public final class InputMethodManager {
     @UnsupportedAppUsage
     public int getInputMethodWindowVisibleHeight() {
         try {
-            return mService.getInputMethodWindowVisibleHeight();
+            return mService.getInputMethodWindowVisibleHeight(mClient);
         } catch (RemoteException e) {
             throw e.rethrowFromSystemServer();
         }
",1,1,InputMethodManager::getInputMethodWindowVisibleHeight
91,c8c129afe16f5b4c9da9bf4c07a0bbeba4e4f697,InputMethodManagerService.java,"@@ -124,6 +124,7 @@ import android.util.Pair;
 import android.util.PrintWriterPrinter;
 import android.util.Printer;
 import android.util.Slog;
+import android.util.SparseBooleanArray;
 import android.util.imetracing.ImeTracing;
 import android.util.proto.ProtoOutputStream;
 import android.view.IWindowManager;
@@ -303,6 +304,8 @@ public class InputMethodManagerService extends IInputMethodManager.Stub
     final InputMethodSettings mSettings;
     final SettingsObserver mSettingsObserver;
     final IWindowManager mIWindowManager;
+    private final SparseBooleanArray mLoggedDeniedGetInputMethodWindowVisibleHeightForUid =
+            new SparseBooleanArray(0);
     final WindowManagerInternal mWindowManagerInternal;
     final PackageManagerInternal mPackageManagerInternal;
     final InputManagerInternal mInputManagerInternal;
@@ -1364,6 +1367,13 @@ public class InputMethodManagerService extends IInputMethodManager.Stub
             clearPackageChangeState();
         }
 
+        @Override
+        public void onUidRemoved(int uid) {
+            synchronized (mMethodMap) {
+                mLoggedDeniedGetInputMethodWindowVisibleHeightForUid.delete(uid);
+            }
+        }
+
         private void clearPackageChangeState() {
             // No need to lock them because we access these fields only on getRegisteredHandler().
             mChangedPackages.clear();
@@ -3127,21 +3137,8 @@ public class InputMethodManagerService extends IInputMethodManager.Stub
             }
             final long ident = Binder.clearCallingIdentity();
             try {
-                if (mCurClient == null || client == null
-                        || mCurClient.client.asBinder() != client.asBinder()) {
-                    // We need to check if this is the current client with
-                    // focus in the window manager, to allow this call to
-                    // be made before input is started in it.
-                    final ClientState cs = mClients.get(client.asBinder());
-                    if (cs == null) {
-                        throw new IllegalArgumentException(
-                                ""unknown client "" + client.asBinder());
-                    }
-                    if (!mWindowManagerInternal.isInputMethodClientFocus(cs.uid, cs.pid,
-                            cs.selfReportedDisplayId)) {
-                        Slog.w(TAG, ""Ignoring showSoftInput of uid "" + uid + "": "" + client);
-                        return false;
-                    }
+                if (!canInteractWithImeLocked(uid, client, ""showSoftInput"")) {
+                    return false;
                 }
                 if (DEBUG) Slog.v(TAG, ""Client requesting input be shown"");
                 return showCurrentInputLocked(windowToken, flags, resultReceiver, reason);
@@ -3966,9 +3963,46 @@ public class InputMethodManagerService extends IInputMethodManager.Stub
      * @return {@link WindowManagerInternal#getInputMethodWindowVisibleHeight(int)}
      */
     @Override
-    public int getInputMethodWindowVisibleHeight() {
-        // TODO(yukawa): Should we verify the display ID?
-        return mWindowManagerInternal.getInputMethodWindowVisibleHeight(mCurTokenDisplayId);
+    @Deprecated
+    public int getInputMethodWindowVisibleHeight(@NonNull IInputMethodClient client) {
+        int callingUid = Binder.getCallingUid();
+        return Binder.withCleanCallingIdentity(() -> {
+            final int curTokenDisplayId;
+            synchronized (mMethodMap) {
+                if (!canInteractWithImeLocked(callingUid, client,
+                        ""getInputMethodWindowVisibleHeight"")) {
+                    if (!mLoggedDeniedGetInputMethodWindowVisibleHeightForUid.get(callingUid)) {
+                        EventLog.writeEvent(0x534e4554, ""204906124"", callingUid, """");
+                        mLoggedDeniedGetInputMethodWindowVisibleHeightForUid.put(callingUid, true);
+                    }
+                    return 0;
+                }
+                // This should probably use the caller's display id, but because this is unsupported
+                // and maintained only for compatibility, there's no point in fixing it.
+                curTokenDisplayId = mCurTokenDisplayId;
+            }
+            return mWindowManagerInternal.getInputMethodWindowVisibleHeight(curTokenDisplayId);
+        });
+    }
+
+    private boolean canInteractWithImeLocked(int callingUid, IInputMethodClient client,
+            String method) {
+        if (mCurClient == null || client == null
+                || mCurClient.client.asBinder() != client.asBinder()) {
+            // We need to check if this is the current client with
+            // focus in the window manager, to allow this call to
+            // be made before input is started in it.
+            final ClientState cs = mClients.get(client.asBinder());
+            if (cs == null) {
+                throw new IllegalArgumentException(""unknown client "" + client.asBinder());
+            }
+            if (!mWindowManagerInternal.isInputMethodClientFocus(cs.uid, cs.pid,
+                    cs.selfReportedDisplayId)) {
+                Slog.w(TAG, ""Ignoring "" + method + "" of uid "" + callingUid + "": "" + client);
+                return false;
+            }
+        }
+        return true;
     }
 
     @Override
",52,18,"InputMethodManagerService::getInputMethodWindowVisibleHeight, InputMethodManagerService::showSoftInput, InputMethodManagerService::canInteractWithImeLocked, InputMethodManagerService::getInputMethodWindowVisibleHeight, InputMethodManagerService::MyPackageMonitor::onUidRemoved"
92,c8c129afe16f5b4c9da9bf4c07a0bbeba4e4f697,MultiClientInputMethodManagerService.java,"@@ -1803,7 +1803,7 @@ public final class MultiClientInputMethodManagerService {
 
         @BinderThread
         @Override
-        public int getInputMethodWindowVisibleHeight() {
+        public int getInputMethodWindowVisibleHeight(IInputMethodClient client) {
             reportNotSupported();
             return 0;
         }
",1,1,"MultiClientInputMethodManagerService::ApiCallbacks::getInputMethodWindowVisibleHeight, MultiClientInputMethodManagerService::ApiCallbacks::getInputMethodWindowVisibleHeight"
93,7a455b258ba1b47318aa6c17b7ac20c6e7bb3453,AlarmManagerService.java,"@@ -104,6 +104,7 @@ import android.text.TextUtils;
 import android.text.format.DateFormat;
 import android.util.ArrayMap;
 import android.util.ArraySet;
+import android.util.EventLog;
 import android.util.IndentingPrintWriter;
 import android.util.Log;
 import android.util.LongArrayQueue;
@@ -2031,7 +2032,11 @@ public class AlarmManagerService extends SystemService {
                                 + "" reached for uid: "" + UserHandle.formatUid(callingUid)
                                 + "", callingPackage: "" + callingPackage;
                 Slog.w(TAG, errorMsg);
-                throw new IllegalStateException(errorMsg);
+                if (callingUid != Process.SYSTEM_UID) {
+                    throw new IllegalStateException(errorMsg);
+                } else {
+                    EventLog.writeEvent(0x534e4554, ""234441463"", -1, errorMsg);
+                }
             }
             setImplLocked(type, triggerAtTime, triggerElapsed, windowLength, interval, operation,
                     directReceiver, listenerTag, flags, workSource, alarmClock, callingUid,
",6,1,AlarmManagerService::setImpl
94,f35e379e1a6a8bfaff6e947d3bfbd0c095879af0,NotificationInterruptStateProviderImpl.java,"@@ -176,9 +176,86 @@ public class NotificationInterruptStateProviderImpl implements NotificationInter
      */
     @Override
     public boolean shouldLaunchFullScreenIntentWhenAdded(NotificationEntry entry) {
-        return entry.getSbn().getNotification().fullScreenIntent != null
-                && (!shouldHeadsUp(entry)
-                || mStatusBarStateController.getState() == StatusBarState.KEYGUARD);
+        if (entry.getSbn().getNotification().fullScreenIntent == null) {
+            return false;
+        }
+
+        // Never show FSI when suppressed by DND
+        if (entry.shouldSuppressFullScreenIntent()) {
+            if (DEBUG) {
+                Log.d(TAG, ""No FullScreenIntent: Suppressed by DND: "" + entry.getKey());
+            }
+            return false;
+        }
+
+        // Never show FSI if importance is not HIGH
+        if (entry.getImportance() < NotificationManager.IMPORTANCE_HIGH) {
+            if (DEBUG) {
+                Log.d(TAG, ""No FullScreenIntent: Not important enough: "" + entry.getKey());
+            }
+            return false;
+        }
+
+        // If the notification has suppressive GroupAlertBehavior, block FSI and warn.
+        StatusBarNotification sbn = entry.getSbn();
+        if (sbn.isGroup() && sbn.getNotification().suppressAlertingDueToGrouping()) {
+            // b/231322873: Detect and report an event when a notification has both an FSI and a
+            // suppressive groupAlertBehavior, and now correctly block the FSI from firing.
+            final int uid = entry.getSbn().getUid();
+            android.util.EventLog.writeEvent(0x534e4554, ""231322873"", uid, ""groupAlertBehavior"");
+            if (DEBUG) {
+                Log.w(TAG, ""No FullScreenIntent: WARNING: GroupAlertBehavior will prevent HUN: ""
+                        + entry.getKey());
+            }
+            return false;
+        }
+
+        // If the screen is off, then launch the FullScreenIntent
+        if (!mPowerManager.isInteractive()) {
+            if (DEBUG) {
+                Log.d(TAG, ""FullScreenIntent: Device is not interactive: "" + entry.getKey());
+            }
+            return true;
+        }
+
+        // If the device is currently dreaming, then launch the FullScreenIntent
+        if (isDreaming()) {
+            if (DEBUG) {
+                Log.d(TAG, ""FullScreenIntent: Device is dreaming: "" + entry.getKey());
+            }
+            return true;
+        }
+
+        // If the keyguard is showing, then launch the FullScreenIntent
+        if (mStatusBarStateController.getState() == StatusBarState.KEYGUARD) {
+            if (DEBUG) {
+                Log.d(TAG, ""FullScreenIntent: Keyguard is showing: "" + entry.getKey());
+            }
+            return true;
+        }
+
+        // If the notification should HUN, then we don't need FSI
+        if (shouldHeadsUp(entry)) {
+            if (DEBUG) {
+                Log.d(TAG, ""No FullScreenIntent: Expected to HUN: "" + entry.getKey());
+            }
+            return false;
+        }
+
+        // If the notification won't HUN for some other reason (DND/snooze/etc), launch FSI.
+        if (DEBUG) {
+            Log.d(TAG, ""FullScreenIntent: Expected not to HUN: "" + entry.getKey());
+        }
+        return true;
+    }
+
+    private boolean isDreaming() {
+        try {
+            return mDreamManager.isDreaming();
+        } catch (RemoteException e) {
+            Log.e(TAG, ""Failed to query dream manager."", e);
+            return false;
+        }
     }
 
     private boolean shouldHeadsUpWhenAwake(NotificationEntry entry) {
@@ -229,13 +306,7 @@ public class NotificationInterruptStateProviderImpl implements NotificationInter
             return false;
         }
 
-        boolean isDreaming = false;
-        try {
-            isDreaming = mDreamManager.isDreaming();
-        } catch (RemoteException e) {
-            Log.e(TAG, ""Failed to query dream manager."", e);
-        }
-        boolean inUse = mPowerManager.isScreenOn() && !isDreaming;
+        boolean inUse = mPowerManager.isScreenOn() && !isDreaming();
 
         if (!inUse) {
             if (DEBUG_HEADS_UP) {
",81,10,"NotificationInterruptStateProviderImpl::shouldLaunchFullScreenIntentWhenAdded, NotificationInterruptStateProviderImpl::shouldHeadsUpWhenAwake, NotificationInterruptStateProviderImpl::isDreaming"
95,f35e379e1a6a8bfaff6e947d3bfbd0c095879af0,NotificationInterruptStateProviderImplTest.java,"@@ -24,6 +24,7 @@ import static android.app.NotificationManager.Policy.SUPPRESSED_EFFECT_AMBIENT;
 import static android.app.NotificationManager.Policy.SUPPRESSED_EFFECT_PEEK;
 
 import static com.android.systemui.statusbar.NotificationEntryHelper.modifyRanking;
+import static com.android.systemui.statusbar.StatusBarState.KEYGUARD;
 import static com.android.systemui.statusbar.StatusBarState.SHADE;
 
 import static com.google.common.truth.Truth.assertThat;
@@ -84,6 +85,8 @@ public class NotificationInterruptStateProviderImplTest extends SysuiTestCase {
     BatteryController mBatteryController;
     @Mock
     Handler mMockHandler;
+    @Mock
+    PendingIntent mPendingIntent;
 
     private NotificationInterruptStateProviderImpl mNotifInterruptionStateProvider;
 
@@ -399,6 +402,97 @@ public class NotificationInterruptStateProviderImplTest extends SysuiTestCase {
         assertThat(mNotifInterruptionStateProvider.shouldHeadsUp(entry)).isFalse();
     }
 
+    @Test
+    public void testShouldNotFullScreen_notPendingIntent() throws RemoteException {
+        NotificationEntry entry = createNotification(IMPORTANCE_HIGH);
+        when(mPowerManager.isInteractive()).thenReturn(true);
+        when(mDreamManager.isDreaming()).thenReturn(false);
+        when(mStatusBarStateController.getState()).thenReturn(SHADE);
+
+        assertThat(mNotifInterruptionStateProvider.shouldLaunchFullScreenIntentWhenAdded(entry))
+                .isFalse();
+    }
+
+    @Test
+    public void testShouldNotFullScreen_notHighImportance() throws RemoteException {
+        NotificationEntry entry = createFsiNotification(IMPORTANCE_DEFAULT, /* silenced */ false);
+        when(mPowerManager.isInteractive()).thenReturn(true);
+        when(mDreamManager.isDreaming()).thenReturn(false);
+        when(mStatusBarStateController.getState()).thenReturn(SHADE);
+
+        assertThat(mNotifInterruptionStateProvider.shouldLaunchFullScreenIntentWhenAdded(entry))
+                .isFalse();
+    }
+
+    @Test
+    public void testShouldNotFullScreen_isGroupAlertSilenced() throws RemoteException {
+        NotificationEntry entry = createFsiNotification(IMPORTANCE_HIGH, /* silenced */ true);
+        when(mPowerManager.isInteractive()).thenReturn(false);
+        when(mDreamManager.isDreaming()).thenReturn(true);
+        when(mStatusBarStateController.getState()).thenReturn(KEYGUARD);
+
+        assertThat(mNotifInterruptionStateProvider.shouldLaunchFullScreenIntentWhenAdded(entry))
+                .isFalse();
+    }
+
+    @Test
+    public void testShouldFullScreen_notInteractive() throws RemoteException {
+        NotificationEntry entry = createFsiNotification(IMPORTANCE_HIGH, /* silenced */ false);
+        when(mPowerManager.isInteractive()).thenReturn(false);
+        when(mDreamManager.isDreaming()).thenReturn(false);
+        when(mStatusBarStateController.getState()).thenReturn(SHADE);
+
+        assertThat(mNotifInterruptionStateProvider.shouldLaunchFullScreenIntentWhenAdded(entry))
+                .isTrue();
+    }
+
+    @Test
+    public void testShouldFullScreen_isDreaming() throws RemoteException {
+        NotificationEntry entry = createFsiNotification(IMPORTANCE_HIGH, /* silenced */ false);
+        when(mPowerManager.isInteractive()).thenReturn(true);
+        when(mDreamManager.isDreaming()).thenReturn(true);
+        when(mStatusBarStateController.getState()).thenReturn(SHADE);
+
+        assertThat(mNotifInterruptionStateProvider.shouldLaunchFullScreenIntentWhenAdded(entry))
+                .isTrue();
+    }
+
+    @Test
+    public void testShouldFullScreen_onKeyguard() throws RemoteException {
+        NotificationEntry entry = createFsiNotification(IMPORTANCE_HIGH, /* silenced */ false);
+        when(mPowerManager.isInteractive()).thenReturn(true);
+        when(mDreamManager.isDreaming()).thenReturn(false);
+        when(mStatusBarStateController.getState()).thenReturn(KEYGUARD);
+
+        assertThat(mNotifInterruptionStateProvider.shouldLaunchFullScreenIntentWhenAdded(entry))
+                .isTrue();
+    }
+
+    @Test
+    public void testShouldNotFullScreen_willHun() throws RemoteException {
+        NotificationEntry entry = createFsiNotification(IMPORTANCE_HIGH, /* silenced */ false);
+        when(mPowerManager.isInteractive()).thenReturn(true);
+        when(mPowerManager.isScreenOn()).thenReturn(true);
+        when(mDreamManager.isDreaming()).thenReturn(false);
+        when(mStatusBarStateController.getState()).thenReturn(SHADE);
+
+        assertThat(mNotifInterruptionStateProvider.shouldLaunchFullScreenIntentWhenAdded(entry))
+                .isFalse();
+    }
+
+    @Test
+    public void testShouldFullScreen_packageSnoozed() throws RemoteException {
+        NotificationEntry entry = createFsiNotification(IMPORTANCE_HIGH, /* silenced */ false);
+        when(mPowerManager.isInteractive()).thenReturn(true);
+        when(mPowerManager.isScreenOn()).thenReturn(true);
+        when(mDreamManager.isDreaming()).thenReturn(false);
+        when(mStatusBarStateController.getState()).thenReturn(SHADE);
+        when(mHeadsUpManager.isSnoozed(""a"")).thenReturn(true);
+
+        assertThat(mNotifInterruptionStateProvider.shouldLaunchFullScreenIntentWhenAdded(entry))
+                .isTrue();
+    }
+
     /**
      * Bubbles can happen.
      */
@@ -503,6 +597,10 @@ public class NotificationInterruptStateProviderImplTest extends SysuiTestCase {
                 .setContentText(""content text"")
                 .build();
 
+        return createNotification(importance, n);
+    }
+
+    private NotificationEntry createNotification(int importance, Notification n) {
         return new NotificationEntryBuilder()
                 .setPkg(""a"")
                 .setOpPkg(""a"")
@@ -512,6 +610,20 @@ public class NotificationInterruptStateProviderImplTest extends SysuiTestCase {
                 .build();
     }
 
+    private NotificationEntry createFsiNotification(int importance, boolean silent) {
+        Notification n = new Notification.Builder(getContext(), ""a"")
+                .setContentTitle(""title"")
+                .setContentText(""content text"")
+                .setFullScreenIntent(mPendingIntent, true)
+                .setGroup(""fsi"")
+                .setGroupAlertBehavior(silent
+                        ? Notification.GROUP_ALERT_SUMMARY
+                        : Notification.GROUP_ALERT_ALL)
+                .build();
+
+        return createNotification(importance, n);
+    }
+
     private final NotificationInterruptSuppressor
             mSuppressAwakeHeadsUp =
             new NotificationInterruptSuppressor() {
",112,0,"NotificationInterruptStateProviderImplTest::testShouldFullScreen_packageSnoozed, NotificationInterruptStateProviderImplTest::testShouldNotFullScreen_willHun, NotificationInterruptStateProviderImplTest::createFsiNotification, NotificationInterruptStateProviderImplTest::testShouldFullScreen_isDreaming, NotificationInterruptStateProviderImplTest::testShouldFullScreen_onKeyguard, NotificationInterruptStateProviderImplTest::testShouldNotFullScreen_notHighImportance, NotificationInterruptStateProviderImplTest::testShouldFullScreen_notInteractive, NotificationInterruptStateProviderImplTest::createNotification, NotificationInterruptStateProviderImplTest::testShouldNotFullScreen_notPendingIntent, NotificationInterruptStateProviderImplTest::createNotification, NotificationInterruptStateProviderImplTest::testShouldNotFullScreen_isGroupAlertSilenced"
96,7d466d7b00888dba5270d8064dccd711d1496a1f,NotificationStackScrollLayoutController.java,"@@ -332,6 +332,13 @@ public class NotificationStackScrollLayoutController {
         }
     };
 
+    /**
+     * Recalculate sensitiveness without animation; called when waking up while keyguard occluded.
+     */
+    public void updateSensitivenessForOccludedWakeup() {
+        mView.updateSensitiveness(false, mLockscreenUserManager.isAnyProfilePublicMode());
+    }
+
     /**
      * Set the overexpansion of the panel to be applied to the view.
      */
",7,0,NotificationStackScrollLayoutController::updateSensitivenessForOccludedWakeup
97,7d466d7b00888dba5270d8064dccd711d1496a1f,StatusBar.java,"@@ -3779,6 +3779,17 @@ public class StatusBar extends SystemUI implements
             mWakeUpCoordinator.setFullyAwake(true);
             mBypassHeadsUpNotifier.setFullyAwake(true);
             mWakeUpCoordinator.setWakingUp(false);
+            if (isOccluded() && !mDozeParameters.canControlUnlockedScreenOff()) {
+                // When the keyguard is occluded we don't use the KEYGUARD state which would
+                // normally cause these redaction updates.  If AOD is on, the KEYGUARD state is used
+                // to show the doze, AND UnlockedScreenOffAnimationController.onFinishedWakingUp()
+                // would force a KEYGUARD state that would take care of recalculating redaction.
+                // So if AOD is off or unsupported we need to trigger these updates at screen on
+                // when the keyguard is occluded.
+                mLockscreenUserManager.updatePublicMode();
+                mNotificationPanelViewController.getNotificationStackScrollLayoutController()
+                        .updateSensitivenessForOccludedWakeup();
+            }
             if (mLaunchCameraWhenFinishedWaking) {
                 mNotificationPanelViewController.launchCamera(
                         false /* animate */, mLastCameraLaunchSource);
",11,0,StatusBar::Observer
98,b0e48bda617e40866e9cde2cf8958bcc160fd6af,ZenModeHelper.java,"@@ -326,7 +326,8 @@ public class ZenModeHelper {
             int newRuleInstanceCount = getCurrentInstanceCount(automaticZenRule.getOwner())
                     + getCurrentInstanceCount(automaticZenRule.getConfigurationActivity())
                     + 1;
-            if (newRuleInstanceCount > RULE_LIMIT_PER_PACKAGE
+            int newPackageRuleCount = getPackageRuleCount(pkg) + 1;
+            if (newPackageRuleCount > RULE_LIMIT_PER_PACKAGE
                     || (ruleInstanceLimit > 0 && ruleInstanceLimit < newRuleInstanceCount)) {
                 throw new IllegalArgumentException(""Rule instance limit exceeded"");
             }
@@ -507,6 +508,23 @@ public class ZenModeHelper {
         return count;
     }
 
+    // Equivalent method to getCurrentInstanceCount, but for all rules associated with a specific
+    // package rather than a condition provider service or activity.
+    private int getPackageRuleCount(String pkg) {
+        if (pkg == null) {
+            return 0;
+        }
+        int count = 0;
+        synchronized (mConfig) {
+            for (ZenRule rule : mConfig.automaticRules.values()) {
+                if (pkg.equals(rule.getPkg())) {
+                    count++;
+                }
+            }
+        }
+        return count;
+    }
+
     public boolean canManageAutomaticZenRule(ZenRule rule) {
         final int callingUid = Binder.getCallingUid();
         if (callingUid == 0 || callingUid == Process.SYSTEM_UID) {
",19,1,"ZenModeHelper::addAutomaticZenRule, ZenModeHelper::getPackageRuleCount"
99,b0e48bda617e40866e9cde2cf8958bcc160fd6af,ZenModeHelperTest.java,"@@ -1618,7 +1618,9 @@ public class ZenModeHelperTest extends UiServiceTestCase {
                     ZenModeConfig.toScheduleConditionId(si),
                     new ZenPolicy.Builder().build(),
                     NotificationManager.INTERRUPTION_FILTER_PRIORITY, true);
-            String id = mZenModeHelperSpy.addAutomaticZenRule(""android"", zenRule, ""test"");
+            // We need the package name to be something that's not ""android"" so there aren't any
+            // existing rules under that package.
+            String id = mZenModeHelperSpy.addAutomaticZenRule(""pkgname"", zenRule, ""test"");
             assertNotNull(id);
         }
         try {
@@ -1628,12 +1630,41 @@ public class ZenModeHelperTest extends UiServiceTestCase {
                     ZenModeConfig.toScheduleConditionId(new ScheduleInfo()),
                     new ZenPolicy.Builder().build(),
                     NotificationManager.INTERRUPTION_FILTER_PRIORITY, true);
-            String id = mZenModeHelperSpy.addAutomaticZenRule(""android"", zenRule, ""test"");
+            String id = mZenModeHelperSpy.addAutomaticZenRule(""pkgname"", zenRule, ""test"");
             fail(""allowed too many rules to be created"");
         } catch (IllegalArgumentException e) {
             // yay
         }
+    }
 
+    @Test
+    public void testAddAutomaticZenRule_beyondSystemLimit_differentComponents() {
+        // Make sure the system limit is enforced per-package even with different component provider
+        // names.
+        for (int i = 0; i < RULE_LIMIT_PER_PACKAGE; i++) {
+            ScheduleInfo si = new ScheduleInfo();
+            si.startHour = i;
+            AutomaticZenRule zenRule = new AutomaticZenRule(""name"" + i,
+                    null,
+                    new ComponentName(""android"", ""ScheduleConditionProvider"" + i),
+                    ZenModeConfig.toScheduleConditionId(si),
+                    new ZenPolicy.Builder().build(),
+                    NotificationManager.INTERRUPTION_FILTER_PRIORITY, true);
+            String id = mZenModeHelperSpy.addAutomaticZenRule(""pkgname"", zenRule, ""test"");
+            assertNotNull(id);
+        }
+        try {
+            AutomaticZenRule zenRule = new AutomaticZenRule(""name"",
+                    null,
+                    new ComponentName(""android"", ""ScheduleConditionProviderFinal""),
+                    ZenModeConfig.toScheduleConditionId(new ScheduleInfo()),
+                    new ZenPolicy.Builder().build(),
+                    NotificationManager.INTERRUPTION_FILTER_PRIORITY, true);
+            String id = mZenModeHelperSpy.addAutomaticZenRule(""pkgname"", zenRule, ""test"");
+            fail(""allowed too many rules to be created"");
+        } catch (IllegalArgumentException e) {
+            // yay
+        }
     }
 
     @Test
",33,2,"ZenModeHelperTest::testAddAutomaticZenRule_beyondSystemLimit, ZenModeHelperTest::testAddAutomaticZenRule_beyondSystemLimit_differentComponents"
100,2f2dd97c1ee430c36d69e16b644641c03be46520,ActivityOptions.java,"@@ -1352,6 +1352,11 @@ public class ActivityOptions {
         return mRemoteTransition;
     }
 
+    /** @hide */
+    public void setRemoteTransition(@Nullable RemoteTransition remoteTransition) {
+        mRemoteTransition = remoteTransition;
+    }
+
     /** @hide */
     public static ActivityOptions fromBundle(Bundle bOptions) {
         return bOptions != null ? new ActivityOptions(bOptions) : null;
",5,0,ActivityOptions::setRemoteTransition
101,2f2dd97c1ee430c36d69e16b644641c03be46520,ActivityRecord.java,"@@ -4630,8 +4630,12 @@ final class ActivityRecord extends WindowToken implements WindowManagerService.A
     ActivityOptions takeOptions() {
         if (DEBUG_TRANSITION) Slog.i(TAG, ""Taking options for "" + this + "" callers=""
                 + Debug.getCallers(6));
+        if (mPendingOptions == null) return null;
         final ActivityOptions opts = mPendingOptions;
         mPendingOptions = null;
+        // Strip sensitive information from options before sending it to app.
+        opts.setRemoteTransition(null);
+        opts.setRemoteAnimationAdapter(null);
         return opts;
     }
 
",4,0,ActivityRecord::takeOptions
102,b24ae4fee23abb04a6f320ddfad0139a072df451,CameraCaptureSessionImpl.java,"@@ -222,7 +222,8 @@ public class CameraCaptureSessionImpl extends CameraCaptureSession
         } else if (request.isReprocess() && !isReprocessable()) {
             throw new IllegalArgumentException(""this capture session cannot handle reprocess "" +
                     ""requests"");
-        } else if (request.isReprocess() && request.getReprocessableSessionId() != mId) {
+        } else if (!mDeviceImpl.isPrivilegedApp() &&
+                request.isReprocess() && request.getReprocessableSessionId() != mId) {
             throw new IllegalArgumentException(""capture request was created for another session"");
         }
     }
",2,1,CameraCaptureSessionImpl::checkCaptureRequest
103,b24ae4fee23abb04a6f320ddfad0139a072df451,CameraDeviceImpl.java,"@@ -22,6 +22,7 @@ import android.annotation.NonNull;
 import android.content.Context;
 import android.graphics.ImageFormat;
 import android.hardware.ICameraService;
+import android.app.ActivityThread;
 import android.hardware.camera2.CameraAccessException;
 import android.hardware.camera2.CameraCaptureSession;
 import android.hardware.camera2.CameraCharacteristics;
@@ -53,6 +54,8 @@ import android.os.Looper;
 import android.os.RemoteException;
 import android.os.ServiceSpecificException;
 import android.os.SystemClock;
+import android.os.SystemProperties;
+import android.text.TextUtils;
 import android.util.Log;
 import android.util.Range;
 import android.util.Size;
@@ -151,6 +154,7 @@ public class CameraDeviceImpl extends CameraDevice
     private int mNextSessionId = 0;
 
     private final int mAppTargetSdkVersion;
+    private boolean mIsPrivilegedApp = false;
 
     private ExecutorService mOfflineSwitchService;
     private CameraOfflineSessionImpl mOfflineSessionImpl;
@@ -301,6 +305,7 @@ public class CameraDeviceImpl extends CameraDevice
         } else {
             mTotalPartialCount = partialCount;
         }
+        mIsPrivilegedApp = checkPrivilegedAppList();
     }
 
     public CameraDeviceCallbacks getCallbacks() {
@@ -1503,6 +1508,27 @@ public class CameraDeviceImpl extends CameraDevice
         return false;
     }
 
+    private boolean checkPrivilegedAppList() {
+        String packageName = ActivityThread.currentOpPackageName();
+        String packageList = SystemProperties.get(""persist.vendor.camera.privapp.list"");
+
+        if (packageList.length() > 0) {
+            TextUtils.StringSplitter splitter = new TextUtils.SimpleStringSplitter(',');
+            splitter.setString(packageList);
+            for (String str : splitter) {
+                if (packageName.equals(str)) {
+                    return true;
+                }
+            }
+        }
+
+        return false;
+    }
+
+    public boolean isPrivilegedApp() {
+        return mIsPrivilegedApp;
+    }
+
     private void checkInputConfiguration(InputConfiguration inputConfig) {
         if (inputConfig == null) {
             return;
@@ -1540,6 +1566,15 @@ public class CameraDeviceImpl extends CameraDevice
                         inputConfig.getWidth() + ""x"" + inputConfig.getHeight() + "" is not valid"");
             }
         } else {
+            /*
+             * don't check input format and size,
+             * if the package name is in the white list
+             */
+            if (isPrivilegedApp()) {
+                Log.w(TAG, ""ignore input format/size check for white listed app"");
+                return;
+            }
+
             if (!checkInputConfigurationWithStreamConfigurations(inputConfig, /*maxRes*/false) &&
                     !checkInputConfigurationWithStreamConfigurations(inputConfig, /*maxRes*/true)) {
                 throw new IllegalArgumentException(""Input config with format "" +
",35,0,"CameraDeviceImpl::checkPrivilegedAppList, CameraDeviceImpl::isPrivilegedApp, CameraDeviceImpl::checkInputConfiguration, CameraDeviceImpl::CameraDeviceImpl"
104,11b0c7005af679db65872bd45c1a3b5234aee04c,QuickStatusBarHeader.java,"@@ -157,9 +157,6 @@ public class QuickStatusBarHeader extends FrameLayout implements TunerService.Tu
         mDatePrivacySeparator = findViewById(R.id.space);
         // Tint for the battery icons are handled in setupHost()
         mBatteryRemainingIcon = findViewById(R.id.batteryRemainingIcon);
-        mBatteryRemainingIcon.setOnClickListener(
-                v -> mActivityStarter.postStartActivityDismissingKeyguard(
-                        new Intent(Intent.ACTION_POWER_USAGE_SUMMARY), 0));
 
         updateResources();
         Configuration config = mContext.getResources().getConfiguration();
@@ -404,10 +401,12 @@ public class QuickStatusBarHeader extends FrameLayout implements TunerService.Tu
             // Animates the icons and battery indicator from alpha 0 to 1, when the chip is visible
             mIconsAlphaAnimator = mIconsAlphaAnimatorFixed;
             mIconsAlphaAnimator.setPosition(mKeyguardExpansionFraction);
+            setBatteryRemainingOnClick(false);
         } else {
             mIconsAlphaAnimator = null;
             mIconContainer.setAlpha(1);
             mBatteryRemainingIcon.setAlpha(1);
+            setBatteryRemainingOnClick(true);
         }
 
     }
@@ -568,6 +567,9 @@ public class QuickStatusBarHeader extends FrameLayout implements TunerService.Tu
 
     public void updateEverything() {
         post(() -> setClickable(!mExpanded));
+        if (mExpanded) {
+            setBatteryRemainingOnClick(true);
+        }
     }
 
     public void setCallback(Callback qsPanelCallback) {
@@ -596,4 +598,16 @@ public class QuickStatusBarHeader extends FrameLayout implements TunerService.Tu
         mClockView.setClockVisibleByUser(!StatusBarIconController.getIconHideList(
                 mContext, newValue).contains(""clock""));
     }
+
+    private void setBatteryRemainingOnClick(boolean enable) {
+        if (enable) {
+            mBatteryRemainingIcon.setOnClickListener(
+                    v -> mActivityStarter.postStartActivityDismissingKeyguard(
+                            new Intent(Intent.ACTION_POWER_USAGE_SUMMARY), 0));
+            mBatteryRemainingIcon.setClickable(true);
+        } else {
+            mBatteryRemainingIcon.setOnClickListener(null);
+            mBatteryRemainingIcon.setClickable(false);
+        }
+    }
 }
",17,3,"QuickStatusBarHeader::onFinishInflate, QuickStatusBarHeader::setChipVisibility, QuickStatusBarHeader::updateEverything, QuickStatusBarHeader::setBatteryRemainingOnClick"
105,b9f57cb67636f526f50e544f1462bce4640b2e4a,Account.java,"@@ -31,7 +31,6 @@ import android.util.Log;
 
 import com.android.internal.annotations.GuardedBy;
 
-import java.util.Objects;
 import java.util.Set;
 
 /**
@@ -87,12 +86,6 @@ public class Account implements Parcelable {
         if (TextUtils.isEmpty(type)) {
             throw new IllegalArgumentException(""the type must not be empty: "" + type);
         }
-        if (name.length() > 200) {
-            throw new IllegalArgumentException(""account name is longer than 200 characters"");
-        }
-        if (type.length() > 200) {
-            throw new IllegalArgumentException(""account type is longer than 200 characters"");
-        }
         this.name = name;
         this.type = type;
         this.accessId = accessId;
",0,7,Account::Account
106,b9f57cb67636f526f50e544f1462bce4640b2e4a,AccountManagerService.java,"@@ -1819,6 +1819,14 @@ public class AccountManagerService
         if (account == null) {
             return false;
         }
+        if (account.name != null && account.name.length() > 200) {
+            Log.w(TAG, ""Account cannot be added - Name longer than 200 chars"");
+            return false;
+        }
+        if (account.type != null && account.type.length() > 200) {
+            Log.w(TAG, ""Account cannot be added - Name longer than 200 chars"");
+            return false;
+        }
         if (!isLocalUnlockedUser(accounts.userId)) {
             Log.w(TAG, ""Account "" + account.toSafeString() + "" cannot be added - user ""
                     + accounts.userId + "" is locked. callingUid="" + callingUid);
@@ -2064,6 +2072,10 @@ public class AccountManagerService
                 + "", pid "" + Binder.getCallingPid());
         }
         if (accountToRename == null) throw new IllegalArgumentException(""account is null"");
+        if (newName != null && newName.length() > 200) {
+            Log.e(TAG, ""renameAccount failed - account name longer than 200"");
+            throw new IllegalArgumentException(""account name longer than 200"");
+        }
         int userId = UserHandle.getCallingUserId();
         if (!isAccountManagedByCaller(accountToRename.type, callingUid, userId)) {
             String msg = String.format(
",12,0,"AccountManagerService::renameAccount, AccountManagerService::addAccountInternal"
107,b9f57cb67636f526f50e544f1462bce4640b2e4a,AccountManagerServiceTest.java,"@@ -36,6 +36,7 @@ import android.accounts.CantAddAccountActivity;
 import android.accounts.IAccountManagerResponse;
 import android.app.AppOpsManager;
 import android.app.INotificationManager;
+import android.app.PropertyInvalidatedCache;
 import android.app.admin.DevicePolicyManager;
 import android.app.admin.DevicePolicyManagerInternal;
 import android.content.BroadcastReceiver;
@@ -132,6 +133,8 @@ public class AccountManagerServiceTest extends AndroidTestCase {
     protected void setUp() throws Exception {
         MockitoAnnotations.initMocks(this);
 
+        PropertyInvalidatedCache.disableForTestMode();
+
         when(mMockPackageManager.checkSignatures(anyInt(), anyInt()))
                     .thenReturn(PackageManager.SIGNATURE_MATCH);
         final UserInfo ui = new UserInfo(UserHandle.USER_SYSTEM, ""user0"", 0);
@@ -247,6 +250,27 @@ public class AccountManagerServiceTest extends AndroidTestCase {
         assertEquals(a31, accounts[1]);
     }
 
+    @SmallTest
+    public void testCheckAddAccountLongName() throws Exception {
+        unlockSystemUser();
+        //test comment
+        String longString = ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa""
+                + ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa""
+                + ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa""
+                + ""aaaaa"";
+        Account a11 = new Account(longString, AccountManagerServiceTestFixtures.ACCOUNT_TYPE_1);
+
+        mAms.addAccountExplicitly(
+                a11, /* password= */ ""p11"", /* extras= */ null, /* callerPackage= */ null);
+
+        String[] list = new String[]{AccountManagerServiceTestFixtures.CALLER_PACKAGE};
+        when(mMockPackageManager.getPackagesForUid(anyInt())).thenReturn(list);
+        Account[] accounts = mAms.getAccountsAsUser(null,
+                UserHandle.getCallingUserId(), mContext.getOpPackageName());
+        assertEquals(0, accounts.length);
+    }
+
+
     @SmallTest
     public void testPasswords() throws Exception {
         unlockSystemUser();
",24,0,"AccountManagerServiceTest::testCheckAddAccountLongName, AccountManagerServiceTest::setUp"
108,5c68b1333bb3d3a2522bc6f2631c9fa91b8eff47,TelecomManager.java,"@@ -1274,7 +1274,7 @@ public class TelecomManager {
         if (service != null) {
             try {
                 return service.getPhoneAccountsSupportingScheme(uriScheme,
-                        mContext.getOpPackageName());
+                        mContext.getOpPackageName()).getList();
             } catch (RemoteException e) {
                 Log.e(TAG, ""Error calling ITelecomService#getPhoneAccountsSupportingScheme"", e);
             }
@@ -1316,7 +1316,7 @@ public class TelecomManager {
         if (service != null) {
             try {
                 return service.getSelfManagedPhoneAccounts(mContext.getOpPackageName(),
-                        mContext.getAttributionTag());
+                        mContext.getAttributionTag()).getList();
             } catch (RemoteException e) {
                 Log.e(TAG, ""Error calling ITelecomService#getSelfManagedPhoneAccounts()"", e);
             }
@@ -1342,7 +1342,7 @@ public class TelecomManager {
         if (service != null) {
             try {
                 return service.getCallCapablePhoneAccounts(includeDisabledAccounts,
-                        mContext.getOpPackageName(), mContext.getAttributionTag());
+                        mContext.getOpPackageName(), mContext.getAttributionTag()).getList();
             } catch (RemoteException e) {
                 Log.e(TAG, ""Error calling ITelecomService#getCallCapablePhoneAccounts(""
                         + includeDisabledAccounts + "")"", e);
@@ -1366,7 +1366,7 @@ public class TelecomManager {
         ITelecomService service = getTelecomService();
         if (service != null) {
             try {
-                return service.getPhoneAccountsForPackage(mContext.getPackageName());
+                return service.getPhoneAccountsForPackage(mContext.getPackageName()).getList();
             } catch (RemoteException e) {
                 Log.e(TAG, ""Error calling ITelecomService#getPhoneAccountsForPackage"", e);
             }
@@ -1426,7 +1426,7 @@ public class TelecomManager {
         ITelecomService service = getTelecomService();
         if (service != null) {
             try {
-                return service.getAllPhoneAccounts();
+                return service.getAllPhoneAccounts().getList();
             } catch (RemoteException e) {
                 Log.e(TAG, ""Error calling ITelecomService#getAllPhoneAccounts"", e);
             }
@@ -1445,7 +1445,7 @@ public class TelecomManager {
         ITelecomService service = getTelecomService();
         if (service != null) {
             try {
-                return service.getAllPhoneAccountHandles();
+                return service.getAllPhoneAccountHandles().getList();
             } catch (RemoteException e) {
                 Log.e(TAG, ""Error calling ITelecomService#getAllPhoneAccountHandles"", e);
             }
",6,6,"TelecomManager::getAllPhoneAccountHandles, TelecomManager::getAllPhoneAccounts, TelecomManager::getCallCapablePhoneAccounts, TelecomManager::getSelfManagedPhoneAccounts, TelecomManager::getPhoneAccountsSupportingScheme, TelecomManager::getPhoneAccountsForPackage"
109,8a2bb82716fc44049e5bff9fdbb2044c1ff59daa,Task.java,"@@ -5475,7 +5475,23 @@ class Task extends TaskFragment {
                     parentLaunchMode == ActivityInfo.LAUNCH_SINGLE_TASK ||
                     parentLaunchMode == ActivityInfo.LAUNCH_SINGLE_TOP ||
                     (destIntentFlags & Intent.FLAG_ACTIVITY_CLEAR_TOP) != 0) {
-                parent.deliverNewIntentLocked(callingUid, destIntent, destGrants, srec.packageName);
+                boolean abort;
+                try {
+                    abort = !mTaskSupervisor.checkStartAnyActivityPermission(destIntent,
+                            parent.info, null /* resultWho */, -1 /* requestCode */, srec.getPid(),
+                            callingUid, srec.info.packageName, null /* callingFeatureId */,
+                            false /* ignoreTargetSecurity */, false /* launchingInTask */, srec.app,
+                            null /* resultRecord */, null /* resultRootTask */);
+                } catch (SecurityException e) {
+                    abort = true;
+                }
+                if (abort) {
+                    android.util.EventLog.writeEvent(0x534e4554, ""238605611"", callingUid, """");
+                    foundParentInTask = false;
+                } else {
+                    parent.deliverNewIntentLocked(callingUid, destIntent, destGrants,
+                            srec.packageName);
+                }
             } else {
                 try {
                     ActivityInfo aInfo = AppGlobals.getPackageManager().getActivityInfo(
",17,1,Task::navigateUpTo
110,c9a0b9b3fa30d1a24537b8d68a8d3e9ad4e87ffe,NotificationManagerService.java,"@@ -7426,7 +7426,8 @@ public class NotificationManagerService extends SystemService {
                 && (record.getSuppressedVisualEffects() & SUPPRESSED_EFFECT_STATUS_BAR) != 0;
         if (!record.isUpdate
                 && record.getImportance() > IMPORTANCE_MIN
-                && !suppressedByDnd) {
+                && !suppressedByDnd
+                && isNotificationForCurrentUser(record)) {
             sendAccessibilityEvent(record);
             sentAccessibilityEvent = true;
         }
",2,1,NotificationManagerService::buzzBeepBlinkLocked
111,c9a0b9b3fa30d1a24537b8d68a8d3e9ad4e87ffe,BuzzBeepBlinkTest.java,"@@ -1299,6 +1299,21 @@ public class BuzzBeepBlinkTest extends UiServiceTestCase {
         verify(mAccessibilityService, times(1)).sendAccessibilityEvent(any(), anyInt());
     }
 
+    @Test
+    public void testA11yCrossUserEventNotSent() throws Exception {
+        final Notification n = new Builder(getContext(), ""test"")
+                .setSmallIcon(android.R.drawable.sym_def_app_icon).build();
+        int userId = mUser.getIdentifier() + 1;
+        StatusBarNotification sbn = new StatusBarNotification(mPkg, mPkg, 0, mTag, mUid,
+                mPid, n, UserHandle.of(userId), null, System.currentTimeMillis());
+        NotificationRecord r = new NotificationRecord(getContext(), sbn,
+                new NotificationChannel(""test"", ""test"", IMPORTANCE_HIGH));
+
+        mService.buzzBeepBlinkLocked(r);
+
+        verify(mAccessibilityService, never()).sendAccessibilityEvent(any(), anyInt());
+    }
+
     @Test
     public void testLightsScreenOn() {
         mService.mScreenOn = true;
",15,0,BuzzBeepBlinkTest::testA11yCrossUserEventNotSent
112,a1865c2b63ad8204cd29634820004bb729b50490,PermissionManagerService.java,"@@ -2764,7 +2764,6 @@ public class PermissionManagerService extends IPermissionManager.Stub {
                     final Permission bp = mRegistry.getPermission(permName);
                     final boolean appSupportsRuntimePermissions =
                             pkg.getTargetSdkVersion() >= Build.VERSION_CODES.M;
-                    String legacyActivityRecognitionPermission = null;
 
                     if (DEBUG_INSTALL && bp != null) {
                         Log.i(TAG, ""Package "" + friendlyName
@@ -2788,47 +2787,12 @@ public class PermissionManagerService extends IPermissionManager.Stub {
                     // Cache newImplicitPermissions before modifing permissionsState as for the
                     // shared uids the original and new state are the same object
                     if (!origState.hasPermissionState(permName)
-                            && (pkg.getImplicitPermissions().contains(permName)
-                            || (permName.equals(Manifest.permission.ACTIVITY_RECOGNITION)))) {
-                        if (pkg.getImplicitPermissions().contains(permName)) {
+                            && (pkg.getImplicitPermissions().contains(permName))) {
                             // If permName is an implicit permission, try to auto-grant
                             newImplicitPermissions.add(permName);
-
                             if (DEBUG_PERMISSIONS) {
                                 Slog.i(TAG, permName + "" is newly added for "" + friendlyName);
                             }
-                        } else {
-                            // Special case for Activity Recognition permission. Even if AR
-                            // permission is not an implicit permission we want to add it to the
-                            // list (try to auto-grant it) if the app was installed on a device
-                            // before AR permission was split, regardless of if the app now requests
-                            // the new AR permission or has updated its target SDK and AR is no
-                            // longer implicit to it. This is a compatibility workaround for apps
-                            // when AR permission was split in Q.
-                            // TODO(zhanghai): This calls into SystemConfig, which generally
-                            //  shouldn't  cause deadlock, but maybe we should keep a cache of the
-                            //  split permission  list and just eliminate the possibility.
-                            final List<PermissionManager.SplitPermissionInfo> permissionList =
-                                    getSplitPermissionInfos();
-                            int numSplitPerms = permissionList.size();
-                            for (int splitPermNum = 0; splitPermNum < numSplitPerms;
-                                    splitPermNum++) {
-                                PermissionManager.SplitPermissionInfo sp = permissionList.get(
-                                        splitPermNum);
-                                String splitPermName = sp.getSplitPermission();
-                                if (sp.getNewPermissions().contains(permName)
-                                        && origState.isPermissionGranted(splitPermName)) {
-                                    legacyActivityRecognitionPermission = splitPermName;
-                                    newImplicitPermissions.add(permName);
-
-                                    if (DEBUG_PERMISSIONS) {
-                                        Slog.i(TAG, permName + "" is newly added for ""
-                                                + friendlyName);
-                                    }
-                                    break;
-                                }
-                            }
-                        }
                     }
 
                     // TODO(b/140256621): The package instant app method has been removed
@@ -2959,8 +2923,7 @@ public class PermissionManagerService extends IPermissionManager.Stub {
                             // Hard restricted permissions cannot be held.
                             } else if (!permissionPolicyInitialized
                                     || (!hardRestricted || restrictionExempt)) {
-                                if ((origPermState != null && origPermState.isGranted())
-                                        || legacyActivityRecognitionPermission != null) {
+                                if ((origPermState != null && origPermState.isGranted())) {
                                     if (!uidState.grantPermission(bp)) {
                                         wasChanged = true;
                                     }
",2,39,PermissionManagerService::restorePermissionState
113,e12b1a456b8736ecc10550562c413c33b5591f4b,ZenModeHelper.java,"@@ -310,7 +310,7 @@ public class ZenModeHelper {
 
     public String addAutomaticZenRule(String pkg, AutomaticZenRule automaticZenRule,
             String reason) {
-        if (!isSystemRule(automaticZenRule)) {
+        if (!ZenModeConfig.SYSTEM_AUTHORITY.equals(pkg)) {
             PackageItemInfo component = getServiceInfo(automaticZenRule.getOwner());
             if (component == null) {
                 component = getActivityInfo(automaticZenRule.getConfigurationActivity());
@@ -566,11 +566,6 @@ public class ZenModeHelper {
         }
     }
 
-    private boolean isSystemRule(AutomaticZenRule rule) {
-        return rule.getOwner() != null
-                && ZenModeConfig.SYSTEM_AUTHORITY.equals(rule.getOwner().getPackageName());
-    }
-
     private ServiceInfo getServiceInfo(ComponentName owner) {
         Intent queryIntent = new Intent();
         queryIntent.setComponent(owner);
",1,6,"ZenModeHelper::addAutomaticZenRule, ZenModeHelper::isSystemRule"
114,e12b1a456b8736ecc10550562c413c33b5591f4b,ZenModeHelperTest.java,"@@ -1667,6 +1667,36 @@ public class ZenModeHelperTest extends UiServiceTestCase {
         }
     }
 
+    @Test
+    public void testAddAutomaticZenRule_claimedSystemOwner() {
+        // Make sure anything that claims to have a ""system"" owner but not actually part of the
+        // system package still gets limited on number of rules
+        for (int i = 0; i < RULE_LIMIT_PER_PACKAGE; i++) {
+            ScheduleInfo si = new ScheduleInfo();
+            si.startHour = i;
+            AutomaticZenRule zenRule = new AutomaticZenRule(""name"" + i,
+                    new ComponentName(""android"", ""ScheduleConditionProvider"" + i),
+                    null, // configuration activity
+                    ZenModeConfig.toScheduleConditionId(si),
+                    new ZenPolicy.Builder().build(),
+                    NotificationManager.INTERRUPTION_FILTER_PRIORITY, true);
+            String id = mZenModeHelperSpy.addAutomaticZenRule(""pkgname"", zenRule, ""test"");
+            assertNotNull(id);
+        }
+        try {
+            AutomaticZenRule zenRule = new AutomaticZenRule(""name"",
+                    new ComponentName(""android"", ""ScheduleConditionProviderFinal""),
+                    null, // configuration activity
+                    ZenModeConfig.toScheduleConditionId(new ScheduleInfo()),
+                    new ZenPolicy.Builder().build(),
+                    NotificationManager.INTERRUPTION_FILTER_PRIORITY, true);
+            String id = mZenModeHelperSpy.addAutomaticZenRule(""pkgname"", zenRule, ""test"");
+            fail(""allowed too many rules to be created"");
+        } catch (IllegalArgumentException e) {
+            // yay
+        }
+    }
+
     @Test
     public void testAddAutomaticZenRule_CA() {
         AutomaticZenRule zenRule = new AutomaticZenRule(""name"",
",30,0,ZenModeHelperTest::testAddAutomaticZenRule_claimedSystemOwner
115,6011fb5153c26340a71c28bd1f97270f46b25de2,AutomaticZenRule.java,"@@ -47,6 +47,13 @@ public final class AutomaticZenRule implements Parcelable {
     private boolean mModified = false;
     private String mPkg;
 
+    /**
+     * The maximum string length for any string contained in this automatic zen rule. This pertains
+     * both to fields in the rule itself (such as its name) and items with sub-fields.
+     * @hide
+     */
+    public static final int MAX_STRING_LENGTH = 1000;
+
     /**
      * Creates an automatic zen rule.
      *
@@ -93,10 +100,10 @@ public final class AutomaticZenRule implements Parcelable {
     public AutomaticZenRule(@NonNull String name, @Nullable ComponentName owner,
             @Nullable ComponentName configurationActivity, @NonNull Uri conditionId,
             @Nullable ZenPolicy policy, int interruptionFilter, boolean enabled) {
-        this.name = name;
-        this.owner = owner;
-        this.configurationActivity = configurationActivity;
-        this.conditionId = conditionId;
+        this.name = getTrimmedString(name);
+        this.owner = getTrimmedComponentName(owner);
+        this.configurationActivity = getTrimmedComponentName(configurationActivity);
+        this.conditionId = getTrimmedUri(conditionId);
         this.interruptionFilter = interruptionFilter;
         this.enabled = enabled;
         this.mZenPolicy = policy;
@@ -115,12 +122,12 @@ public final class AutomaticZenRule implements Parcelable {
     public AutomaticZenRule(Parcel source) {
         enabled = source.readInt() == ENABLED;
         if (source.readInt() == ENABLED) {
-            name = source.readString();
+            name = getTrimmedString(source.readString());
         }
         interruptionFilter = source.readInt();
         conditionId = source.readParcelable(null);
-        owner = source.readParcelable(null);
-        configurationActivity = source.readParcelable(null);
+        owner = getTrimmedComponentName(source.readParcelable(null));
+        configurationActivity = getTrimmedComponentName(source.readParcelable(null));
         creationTime = source.readLong();
         mZenPolicy = source.readParcelable(null);
         mModified = source.readInt() == ENABLED;
@@ -196,7 +203,7 @@ public final class AutomaticZenRule implements Parcelable {
      * Sets the representation of the state that causes this rule to become active.
      */
     public void setConditionId(Uri conditionId) {
-        this.conditionId = conditionId;
+        this.conditionId = getTrimmedUri(conditionId);
     }
 
     /**
@@ -211,7 +218,7 @@ public final class AutomaticZenRule implements Parcelable {
      * Sets the name of this rule.
      */
     public void setName(String name) {
-        this.name = name;
+        this.name = getTrimmedString(name);
     }
 
     /**
@@ -243,7 +250,7 @@ public final class AutomaticZenRule implements Parcelable {
      * that are not backed by {@link android.service.notification.ConditionProviderService}.
      */
     public void setConfigurationActivity(@Nullable ComponentName componentName) {
-        this.configurationActivity = componentName;
+        this.configurationActivity = getTrimmedComponentName(componentName);
     }
 
     /**
@@ -333,4 +340,35 @@ public final class AutomaticZenRule implements Parcelable {
             return new AutomaticZenRule[size];
         }
     };
+
+    /**
+     * If the package or class name of the provided ComponentName are longer than MAX_STRING_LENGTH,
+     * return a trimmed version that truncates each of the package and class name at the max length.
+     */
+    private static ComponentName getTrimmedComponentName(ComponentName cn) {
+        if (cn == null) return null;
+        return new ComponentName(getTrimmedString(cn.getPackageName()),
+                getTrimmedString(cn.getClassName()));
+    }
+
+    /**
+     * Returns a truncated copy of the string if the string is longer than MAX_STRING_LENGTH.
+     */
+    private static String getTrimmedString(String input) {
+        if (input != null && input.length() > MAX_STRING_LENGTH) {
+            return input.substring(0, MAX_STRING_LENGTH);
+        }
+        return input;
+    }
+
+    /**
+     * Returns a truncated copy of the Uri by trimming the string representation to the maximum
+     * string length.
+     */
+    private static Uri getTrimmedUri(Uri input) {
+        if (input != null && input.toString().length() > MAX_STRING_LENGTH) {
+            return Uri.parse(getTrimmedString(input.toString()));
+        }
+        return input;
+    }
 }
",48,10,"AutomaticZenRule::getTrimmedString, AutomaticZenRule::setConfigurationActivity, AutomaticZenRule::setName, AutomaticZenRule::AutomaticZenRule, AutomaticZenRule::getTrimmedComponentName, AutomaticZenRule::AutomaticZenRule, AutomaticZenRule::setConditionId, AutomaticZenRule::getTrimmedUri"
116,6011fb5153c26340a71c28bd1f97270f46b25de2,AutomaticZenRuleTest.java,"@@ -0,0 +1,153 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.app;
+
+import static junit.framework.Assert.assertEquals;
+import static junit.framework.Assert.fail;
+
+import android.content.ComponentName;
+import android.net.Uri;
+import android.os.Parcel;
+
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import androidx.test.filters.SmallTest;
+
+import com.google.common.base.Strings;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.lang.reflect.Field;
+
+@RunWith(AndroidJUnit4.class)
+@SmallTest
+public class AutomaticZenRuleTest {
+    private static final String CLASS = ""android.app.AutomaticZenRule"";
+
+    @Test
+    public void testLongFields_inConstructor() {
+        String longString = Strings.repeat(""A"", 65536);
+        Uri longUri = Uri.parse(""uri://"" + Strings.repeat(""A"", 65530));
+
+        // test both variants where there's an owner, and where there's a configuration activity
+        AutomaticZenRule rule1 = new AutomaticZenRule(
+                longString, // name
+                new ComponentName(""pkg"", longString), // owner
+                null,  // configuration activity
+                longUri, // conditionId
+                null, // zen policy
+                0, // interruption filter
+                true); // enabled
+
+        assertEquals(AutomaticZenRule.MAX_STRING_LENGTH, rule1.getName().length());
+        assertEquals(AutomaticZenRule.MAX_STRING_LENGTH,
+                rule1.getConditionId().toString().length());
+        assertEquals(AutomaticZenRule.MAX_STRING_LENGTH, rule1.getOwner().getClassName().length());
+
+        AutomaticZenRule rule2 = new AutomaticZenRule(
+                longString, // name
+                null, // owner
+                new ComponentName(longString, ""SomeClassName""), // configuration activity
+                longUri, // conditionId
+                null, // zen policy
+                0, // interruption filter
+                false); // enabled
+
+        assertEquals(AutomaticZenRule.MAX_STRING_LENGTH, rule2.getName().length());
+        assertEquals(AutomaticZenRule.MAX_STRING_LENGTH,
+                rule2.getConditionId().toString().length());
+        assertEquals(AutomaticZenRule.MAX_STRING_LENGTH,
+                rule2.getConfigurationActivity().getPackageName().length());
+    }
+
+    @Test
+    public void testLongFields_inSetters() {
+        String longString = Strings.repeat(""A"", 65536);
+        Uri longUri = Uri.parse(""uri://"" + Strings.repeat(""A"", 65530));
+
+        AutomaticZenRule rule = new AutomaticZenRule(
+                ""sensible name"",
+                new ComponentName(""pkg"", ""ShortClass""),
+                null,
+                Uri.parse(""uri://short""),
+                null, 0, true);
+
+        rule.setName(longString);
+        rule.setConditionId(longUri);
+        rule.setConfigurationActivity(new ComponentName(longString, longString));
+
+        assertEquals(AutomaticZenRule.MAX_STRING_LENGTH, rule.getName().length());
+        assertEquals(AutomaticZenRule.MAX_STRING_LENGTH,
+                rule.getConditionId().toString().length());
+        assertEquals(AutomaticZenRule.MAX_STRING_LENGTH,
+                rule.getConfigurationActivity().getPackageName().length());
+        assertEquals(AutomaticZenRule.MAX_STRING_LENGTH,
+                rule.getConfigurationActivity().getClassName().length());
+    }
+
+    @Test
+    public void testLongInputsFromParcel() {
+        // Create a rule with long fields, set directly via reflection so that we can confirm that
+        // a rule with too-long fields that comes in via a parcel has its fields truncated directly.
+        AutomaticZenRule rule = new AutomaticZenRule(
+                ""placeholder"",
+                new ComponentName(""place"", ""holder""),
+                null,
+                Uri.parse(""uri://placeholder""),
+                null, 0, true);
+
+        try {
+            String longString = Strings.repeat(""A"", 65536);
+            Uri longUri = Uri.parse(""uri://"" + Strings.repeat(""A"", 65530));
+            Field name = Class.forName(CLASS).getDeclaredField(""name"");
+            name.setAccessible(true);
+            name.set(rule, longString);
+            Field conditionId = Class.forName(CLASS).getDeclaredField(""conditionId"");
+            conditionId.setAccessible(true);
+            conditionId.set(rule, longUri);
+            Field owner = Class.forName(CLASS).getDeclaredField(""owner"");
+            owner.setAccessible(true);
+            owner.set(rule, new ComponentName(longString, longString));
+            Field configActivity = Class.forName(CLASS).getDeclaredField(""configurationActivity"");
+            configActivity.setAccessible(true);
+            configActivity.set(rule, new ComponentName(longString, longString));
+        } catch (NoSuchFieldException e) {
+            fail(e.toString());
+        } catch (ClassNotFoundException e) {
+            fail(e.toString());
+        } catch (IllegalAccessException e) {
+            fail(e.toString());
+        }
+
+        Parcel parcel = Parcel.obtain();
+        rule.writeToParcel(parcel, 0);
+        parcel.setDataPosition(0);
+
+        AutomaticZenRule fromParcel = new AutomaticZenRule(parcel);
+        assertEquals(AutomaticZenRule.MAX_STRING_LENGTH, fromParcel.getName().length());
+        assertEquals(AutomaticZenRule.MAX_STRING_LENGTH,
+                fromParcel.getConditionId().toString().length());
+        assertEquals(AutomaticZenRule.MAX_STRING_LENGTH,
+                fromParcel.getConfigurationActivity().getPackageName().length());
+        assertEquals(AutomaticZenRule.MAX_STRING_LENGTH,
+                fromParcel.getConfigurationActivity().getClassName().length());
+        assertEquals(AutomaticZenRule.MAX_STRING_LENGTH,
+                fromParcel.getOwner().getPackageName().length());
+        assertEquals(AutomaticZenRule.MAX_STRING_LENGTH,
+                fromParcel.getOwner().getClassName().length());
+    }
+}
",153,0,"AutomaticZenRuleTest::testLongFields_inConstructor, AutomaticZenRuleTest::testLongInputsFromParcel, AutomaticZenRuleTest::testLongFields_inSetters"
117,7fcd9a37fa797b2f0d6c5fabfb9d1b0e52009ab7,NotificationManagerService.java,"@@ -4812,7 +4812,16 @@ public class NotificationManagerService extends SystemService {
             }
             enforcePolicyAccess(Binder.getCallingUid(), ""addAutomaticZenRule"");
 
-            return mZenModeHelper.addAutomaticZenRule(pkg, automaticZenRule,
+            // If the caller is system, take the package name from the rule's owner rather than
+            // from the caller's package.
+            String rulePkg = pkg;
+            if (isCallingUidSystem()) {
+                if (automaticZenRule.getOwner() != null) {
+                    rulePkg = automaticZenRule.getOwner().getPackageName();
+                }
+            }
+
+            return mZenModeHelper.addAutomaticZenRule(rulePkg, automaticZenRule,
                     ""addAutomaticZenRule"");
         }
 
",10,1,NotificationManagerService::Stub
118,7fcd9a37fa797b2f0d6c5fabfb9d1b0e52009ab7,NotificationManagerServiceTest.java,"@@ -6683,6 +6683,43 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {
         mBinderService.addAutomaticZenRule(rule, mContext.getPackageName());
     }
 
+    @Test
+    public void testAddAutomaticZenRule_systemCallTakesPackageFromOwner() throws Exception {
+        mService.isSystemUid = true;
+        ZenModeHelper mockZenModeHelper = mock(ZenModeHelper.class);
+        when(mConditionProviders.isPackageOrComponentAllowed(anyString(), anyInt()))
+                .thenReturn(true);
+        mService.setZenHelper(mockZenModeHelper);
+        ComponentName owner = new ComponentName(""android"", ""ProviderName"");
+        ZenPolicy zenPolicy = new ZenPolicy.Builder().allowAlarms(true).build();
+        boolean isEnabled = true;
+        AutomaticZenRule rule = new AutomaticZenRule(""test"", owner, owner, mock(Uri.class),
+                zenPolicy, NotificationManager.INTERRUPTION_FILTER_PRIORITY, isEnabled);
+        mBinderService.addAutomaticZenRule(rule, ""com.android.settings"");
+
+        // verify that zen mode helper gets passed in a package name of ""android""
+        verify(mockZenModeHelper).addAutomaticZenRule(eq(""android""), eq(rule), anyString());
+    }
+
+    @Test
+    public void testAddAutomaticZenRule_nonSystemCallTakesPackageFromArg() throws Exception {
+        mService.isSystemUid = false;
+        ZenModeHelper mockZenModeHelper = mock(ZenModeHelper.class);
+        when(mConditionProviders.isPackageOrComponentAllowed(anyString(), anyInt()))
+                .thenReturn(true);
+        mService.setZenHelper(mockZenModeHelper);
+        ComponentName owner = new ComponentName(""android"", ""ProviderName"");
+        ZenPolicy zenPolicy = new ZenPolicy.Builder().allowAlarms(true).build();
+        boolean isEnabled = true;
+        AutomaticZenRule rule = new AutomaticZenRule(""test"", owner, owner, mock(Uri.class),
+                zenPolicy, NotificationManager.INTERRUPTION_FILTER_PRIORITY, isEnabled);
+        mBinderService.addAutomaticZenRule(rule, ""another.package"");
+
+        // verify that zen mode helper gets passed in the package name from the arg, not the owner
+        verify(mockZenModeHelper).addAutomaticZenRule(
+                eq(""another.package""), eq(rule), anyString());
+    }
+
     @Test
     public void testAreNotificationsEnabledForPackage_crossUser() throws Exception {
         try {
",37,0,"NotificationManagerServiceTest::testAddAutomaticZenRule_systemCallTakesPackageFromOwner, NotificationManagerServiceTest::testAddAutomaticZenRule_nonSystemCallTakesPackageFromArg"
119,f3bb6da05eeb2280356c87c87fbf7a41601dd66b,BroadcastQueue.java,"@@ -768,6 +768,54 @@ public final class BroadcastQueue {
             }
         }
 
+        // Check that the receiver does *not* have any excluded permissions
+        if (!skip && r.excludedPermissions != null && r.excludedPermissions.length > 0) {
+            for (int i = 0; i < r.excludedPermissions.length; i++) {
+                String excludedPermission = r.excludedPermissions[i];
+                final int perm = mService.checkComponentPermission(excludedPermission,
+                        filter.receiverList.pid, filter.receiverList.uid, -1, true);
+
+                int appOp = AppOpsManager.permissionToOpCode(excludedPermission);
+                if (appOp != AppOpsManager.OP_NONE) {
+                    // When there is an app op associated with the permission,
+                    // skip when both the permission and the app op are
+                    // granted.
+                    if ((perm == PackageManager.PERMISSION_GRANTED) && (
+                            mService.getAppOpsManager().checkOpNoThrow(appOp,
+                                    filter.receiverList.uid,
+                                    filter.packageName)
+                                    == AppOpsManager.MODE_ALLOWED)) {
+                        Slog.w(TAG, ""Appop Denial: receiving ""
+                                + r.intent.toString()
+                                + "" to "" + filter.receiverList.app
+                                + "" (pid="" + filter.receiverList.pid
+                                + "", uid="" + filter.receiverList.uid + "")""
+                                + "" excludes appop "" + AppOpsManager.permissionToOp(
+                                excludedPermission)
+                                + "" due to sender "" + r.callerPackage
+                                + "" (uid "" + r.callingUid + "")"");
+                        skip = true;
+                        break;
+                    }
+                } else {
+                    // When there is no app op associated with the permission,
+                    // skip when permission is granted.
+                    if (perm == PackageManager.PERMISSION_GRANTED) {
+                        Slog.w(TAG, ""Permission Denial: receiving ""
+                                + r.intent.toString()
+                                + "" to "" + filter.receiverList.app
+                                + "" (pid="" + filter.receiverList.pid
+                                + "", uid="" + filter.receiverList.uid + "")""
+                                + "" excludes "" + excludedPermission
+                                + "" due to sender "" + r.callerPackage
+                                + "" (uid "" + r.callingUid + "")"");
+                        skip = true;
+                        break;
+                    }
+                }
+            }
+        }
+
         // Check that the receiver does *not* belong to any of the excluded packages
         if (!skip && r.excludedPackages != null && r.excludedPackages.length > 0) {
             if (ArrayUtils.contains(r.excludedPackages, filter.packageName)) {
",48,0,BroadcastQueue::deliverToRegisteredReceiverLocked
120,c0353314847735082aa8a51557361d2081f5cdbc,AdminSecondaryLockScreenController.java,"@@ -33,6 +33,7 @@ import android.view.SurfaceView;
 import android.view.ViewGroup;
 
 import com.android.internal.annotations.VisibleForTesting;
+import com.android.keyguard.KeyguardSecurityModel.SecurityMode;
 import com.android.keyguard.dagger.KeyguardBouncerScope;
 import com.android.systemui.dagger.qualifiers.Main;
 
@@ -208,7 +209,7 @@ public class AdminSecondaryLockScreenController {
             hide();
             if (mKeyguardCallback != null) {
                 mKeyguardCallback.dismiss(/* securityVerified= */ true, userId,
-                        /* bypassSecondaryLockScreen= */true);
+                        /* bypassSecondaryLockScreen= */true, SecurityMode.Invalid);
             }
         }
     }
",2,1,AdminSecondaryLockScreenController::dismiss
121,c0353314847735082aa8a51557361d2081f5cdbc,KeyguardAbsKeyInputViewController.java,"@@ -174,7 +174,7 @@ public abstract class KeyguardAbsKeyInputViewController<T extends KeyguardAbsKey
             if (dismissKeyguard) {
                 mDismissing = true;
                 mLatencyTracker.onActionStart(LatencyTracker.ACTION_LOCKSCREEN_UNLOCK);
-                getKeyguardSecurityCallback().dismiss(true, userId);
+                getKeyguardSecurityCallback().dismiss(true, userId, getSecurityMode());
             }
         } else {
             if (isValidPassword) {
",1,1,KeyguardAbsKeyInputViewController::onPasswordChecked
122,c0353314847735082aa8a51557361d2081f5cdbc,KeyguardHostViewController.java,"@@ -93,7 +93,7 @@ public class KeyguardHostViewController extends ViewController<KeyguardHostView>
                                 Log.i(TAG, ""TrustAgent dismissed Keyguard."");
                             }
                             mSecurityCallback.dismiss(false /* authenticated */, userId,
-                                    /* bypassSecondaryLockScreen */ false);
+                                    /* bypassSecondaryLockScreen */ false, SecurityMode.Invalid);
                         } else {
                             mViewMediatorCallback.playTrustedSound();
                         }
@@ -105,9 +105,9 @@ public class KeyguardHostViewController extends ViewController<KeyguardHostView>
 
         @Override
         public boolean dismiss(boolean authenticated, int targetUserId,
-                boolean bypassSecondaryLockScreen) {
+                boolean bypassSecondaryLockScreen, SecurityMode expectedSecurityMode) {
             return mKeyguardSecurityContainerController.showNextSecurityScreenOrFinish(
-                    authenticated, targetUserId, bypassSecondaryLockScreen);
+                    authenticated, targetUserId, bypassSecondaryLockScreen, expectedSecurityMode);
         }
 
         @Override
@@ -215,7 +215,8 @@ public class KeyguardHostViewController extends ViewController<KeyguardHostView>
      * @return True if the keyguard is done.
      */
     public boolean dismiss(int targetUserId) {
-        return mSecurityCallback.dismiss(false, targetUserId, false);
+        return mSecurityCallback.dismiss(false, targetUserId, false,
+                getCurrentSecurityMode());
     }
 
     /**
@@ -356,10 +357,10 @@ public class KeyguardHostViewController extends ViewController<KeyguardHostView>
     }
 
     public boolean handleBackKey() {
-        if (mKeyguardSecurityContainerController.getCurrentSecurityMode()
-                != SecurityMode.None) {
+        SecurityMode securityMode = mKeyguardSecurityContainerController.getCurrentSecurityMode();
+        if (securityMode != SecurityMode.None) {
             mKeyguardSecurityContainerController.dismiss(
-                    false, KeyguardUpdateMonitor.getCurrentUser());
+                    false, KeyguardUpdateMonitor.getCurrentUser(), securityMode);
             return true;
         }
         return false;
",8,7,"KeyguardHostViewController::dismiss, KeyguardHostViewController::KeyguardUpdateMonitorCallback, KeyguardHostViewController::handleBackKey, KeyguardHostViewController::SecurityCallback"
123,c0353314847735082aa8a51557361d2081f5cdbc,KeyguardInputViewController.java,"@@ -59,10 +59,11 @@ public abstract class KeyguardInputViewController<T extends KeyguardInputView>
             return false;
         }
         @Override
-        public void dismiss(boolean securityVerified, int targetUserId) { }
+        public void dismiss(boolean securityVerified, int targetUserId,
+                SecurityMode expectedSecurityMode) { }
         @Override
         public void dismiss(boolean authenticated, int targetId,
-                boolean bypassSecondaryLockScreen) { }
+                boolean bypassSecondaryLockScreen, SecurityMode expectedSecurityMode) { }
         @Override
         public void onUserInput() { }
         @Override
",3,2,KeyguardInputViewController::KeyguardSecurityCallback
124,c0353314847735082aa8a51557361d2081f5cdbc,KeyguardPatternViewController.java,"@@ -170,7 +170,7 @@ public class KeyguardPatternViewController
                 if (dismissKeyguard) {
                     mLockPatternView.setDisplayMode(LockPatternView.DisplayMode.Correct);
                     mLatencyTracker.onActionStart(LatencyTracker.ACTION_LOCKSCREEN_UNLOCK);
-                    getKeyguardSecurityCallback().dismiss(true, userId);
+                    getKeyguardSecurityCallback().dismiss(true, userId, SecurityMode.Pattern);
                 }
             } else {
                 mLockPatternView.setDisplayMode(LockPatternView.DisplayMode.Wrong);
",1,1,KeyguardPatternViewController::UnlockPatternListener::onPatternChecked
125,c0353314847735082aa8a51557361d2081f5cdbc,KeyguardSecurityCallback.java,"@@ -15,14 +15,17 @@
  */
 package com.android.keyguard;
 
+import com.android.keyguard.KeyguardSecurityModel.SecurityMode;
+
 public interface KeyguardSecurityCallback {
 
     /**
      * Dismiss the given security screen.
      * @param securityVerified true if the user correctly entered credentials for the given screen.
      * @param targetUserId a user that needs to be the foreground user at the dismissal completion.
+     * @param expectedSecurityMode The security mode that is invoking this dismiss.
      */
-    void dismiss(boolean securityVerified, int targetUserId);
+    void dismiss(boolean securityVerified, int targetUserId, SecurityMode expectedSecurityMode);
 
     /**
      * Dismiss the given security screen.
@@ -30,8 +33,10 @@ public interface KeyguardSecurityCallback {
      * @param targetUserId a user that needs to be the foreground user at the dismissal completion.
      * @param bypassSecondaryLockScreen true if the user can bypass the secondary lock screen,
      *                                  if any, during this dismissal.
+     * @param expectedSecurityMode The security mode that is invoking this dismiss.
      */
-    void dismiss(boolean securityVerified, int targetUserId, boolean bypassSecondaryLockScreen);
+    void dismiss(boolean securityVerified, int targetUserId, boolean bypassSecondaryLockScreen,
+            SecurityMode expectedSecurityMode);
 
     /**
      * Manually report user activity to keep the device awake.
",7,2,
126,c0353314847735082aa8a51557361d2081f5cdbc,KeyguardSecurityContainer.java,"@@ -181,7 +181,12 @@ public class KeyguardSecurityContainer extends FrameLayout {
 
     // Used to notify the container when something interesting happens.
     public interface SecurityCallback {
-        boolean dismiss(boolean authenticated, int targetUserId, boolean bypassSecondaryLockScreen);
+        /**
+         * Potentially dismiss the current security screen, after validating that all device
+         * security has been unlocked. Otherwise show the next screen.
+         */
+        boolean dismiss(boolean authenticated, int targetUserId, boolean bypassSecondaryLockScreen,
+                SecurityMode expectedSecurityMode);
 
         void userActivity();
 
",6,1,
127,c0353314847735082aa8a51557361d2081f5cdbc,KeyguardSecurityContainerController.java,"@@ -136,14 +136,17 @@ public class KeyguardSecurityContainerController extends ViewController<Keyguard
         }
 
         @Override
-        public void dismiss(boolean authenticated, int targetId) {
-            dismiss(authenticated, targetId, /* bypassSecondaryLockScreen */ false);
+        public void dismiss(boolean authenticated, int targetId,
+                SecurityMode expectedSecurityMode) {
+            dismiss(authenticated, targetId, /* bypassSecondaryLockScreen */ false,
+                    expectedSecurityMode);
         }
 
         @Override
         public void dismiss(boolean authenticated, int targetId,
-                boolean bypassSecondaryLockScreen) {
-            mSecurityCallback.dismiss(authenticated, targetId, bypassSecondaryLockScreen);
+                boolean bypassSecondaryLockScreen, SecurityMode expectedSecurityMode) {
+            mSecurityCallback.dismiss(authenticated, targetId, bypassSecondaryLockScreen,
+                    expectedSecurityMode);
         }
 
         public boolean isVerifyUnlockOnly() {
@@ -307,8 +310,13 @@ public class KeyguardSecurityContainerController extends ViewController<Keyguard
         return mCurrentSecurityMode;
     }
 
-    public void dismiss(boolean authenticated, int targetUserId) {
-        mKeyguardSecurityCallback.dismiss(authenticated, targetUserId);
+    /**
+     * Potentially dismiss the current security screen, after validating that all device
+     * security has been unlocked. Otherwise show the next screen.
+     */
+    public void dismiss(boolean authenticated, int targetUserId,
+            SecurityMode expectedSecurityMode) {
+        mKeyguardSecurityCallback.dismiss(authenticated, targetUserId, expectedSecurityMode);
     }
 
     public void reset() {
@@ -367,12 +375,21 @@ public class KeyguardSecurityContainerController extends ViewController<Keyguard
      *     completion.
      * @param bypassSecondaryLockScreen true if the user is allowed to bypass the secondary
      *     secondary lock screen requirement, if any.
+     * @param expectedSecurityMode SecurityMode that is invoking this request. SecurityMode.Invalid
+     *      indicates that no check should be done
      * @return true if keyguard is done
      */
     public boolean showNextSecurityScreenOrFinish(boolean authenticated, int targetUserId,
-            boolean bypassSecondaryLockScreen) {
+            boolean bypassSecondaryLockScreen, SecurityMode expectedSecurityMode) {
 
         if (DEBUG) Log.d(TAG, ""showNextSecurityScreenOrFinish("" + authenticated + "")"");
+        if (expectedSecurityMode != SecurityMode.Invalid
+                && expectedSecurityMode != getCurrentSecurityMode()) {
+            Log.w(TAG, ""Attempted to invoke showNextSecurityScreenOrFinish with securityMode ""
+                    + expectedSecurityMode + "", but current mode is "" + getCurrentSecurityMode());
+            return false;
+        }
+
         boolean finish = false;
         boolean strongAuth = false;
         int eventSubtype = -1;
",24,7,"KeyguardSecurityContainerController::dismiss, KeyguardSecurityContainerController::dismiss, KeyguardSecurityContainerController::showNextSecurityScreenOrFinish, KeyguardSecurityContainerController::showNextSecurityScreenOrFinish, KeyguardSecurityContainerController::KeyguardSecurityCallback"
128,c0353314847735082aa8a51557361d2081f5cdbc,KeyguardSimPinViewController.java,"@@ -162,7 +162,8 @@ public class KeyguardSimPinViewController
                             mRemainingAttempts = -1;
                             mShowDefaultMessage = true;
                             getKeyguardSecurityCallback().dismiss(
-                                    true, KeyguardUpdateMonitor.getCurrentUser());
+                                    true, KeyguardUpdateMonitor.getCurrentUser(),
+                                    SecurityMode.SimPin);
                         } else {
                             mShowDefaultMessage = false;
                             if (result.getResult() == PinResult.PIN_RESULT_TYPE_INCORRECT) {
",2,1,KeyguardSimPinViewController::verifyPasswordAndUnlock
129,c0353314847735082aa8a51557361d2081f5cdbc,KeyguardSimPukViewController.java,"@@ -69,7 +69,8 @@ public class KeyguardSimPukViewController
             if (simState == TelephonyManager.SIM_STATE_READY) {
                 mRemainingAttempts = -1;
                 mShowDefaultMessage = true;
-                getKeyguardSecurityCallback().dismiss(true, KeyguardUpdateMonitor.getCurrentUser());
+                getKeyguardSecurityCallback().dismiss(true, KeyguardUpdateMonitor.getCurrentUser(),
+                        SecurityMode.SimPuk);
             } else {
                 resetState();
             }
@@ -274,7 +275,8 @@ public class KeyguardSimPukViewController
                             mShowDefaultMessage = true;
 
                             getKeyguardSecurityCallback().dismiss(
-                                    true, KeyguardUpdateMonitor.getCurrentUser());
+                                    true, KeyguardUpdateMonitor.getCurrentUser(),
+                                    SecurityMode.SimPuk);
                         } else {
                             mShowDefaultMessage = false;
                             if (result.getResult() == PinResult.PIN_RESULT_TYPE_INCORRECT) {
",4,2,"KeyguardSimPukViewController::updateSim, KeyguardSimPukViewController::KeyguardUpdateMonitorCallback"
130,c0353314847735082aa8a51557361d2081f5cdbc,AdminSecondaryLockScreenControllerTest.java,"@@ -44,6 +44,7 @@ import android.view.SurfaceView;
 
 import androidx.test.filters.SmallTest;
 
+import com.android.keyguard.KeyguardSecurityModel.SecurityMode;
 import com.android.systemui.SysuiTestCase;
 
 import org.junit.After;
@@ -190,7 +191,7 @@ public class AdminSecondaryLockScreenControllerTest extends SysuiTestCase {
 
     private void verifyViewDismissed(SurfaceView v) throws Exception {
         verify(mKeyguardSecurityContainer).removeView(v);
-        verify(mKeyguardCallback).dismiss(true, TARGET_USER_ID, true);
+        verify(mKeyguardCallback).dismiss(true, TARGET_USER_ID, true, SecurityMode.Invalid);
         assertThat(mContext.isBound(mComponentName)).isFalse();
     }
 }
",2,1,AdminSecondaryLockScreenControllerTest::verifyViewDismissed
131,c0353314847735082aa8a51557361d2081f5cdbc,KeyguardSecurityContainerControllerTest.java,"@@ -18,6 +18,8 @@ package com.android.keyguard;
 
 import static android.view.WindowInsets.Type.ime;
 
+import static com.google.common.truth.Truth.assertThat;
+
 import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.ArgumentMatchers.anyBoolean;
 import static org.mockito.ArgumentMatchers.anyInt;
@@ -62,6 +64,7 @@ import org.mockito.junit.MockitoRule;
 @RunWith(AndroidTestingRunner.class)
 @TestableLooper.RunWithLooper()
 public class KeyguardSecurityContainerControllerTest extends SysuiTestCase {
+    private static final int TARGET_USER_ID = 100;
     private static final int VIEW_WIDTH = 1600;
 
     @Rule
@@ -330,4 +333,42 @@ public class KeyguardSecurityContainerControllerTest extends SysuiTestCase {
                 R.bool.can_use_one_handed_bouncer))
                 .thenReturn(sysuiResourceCanUseOneHandedKeyguard);
     }
+
+    @Test
+    public void showNextSecurityScreenOrFinish_setsSecurityScreenToPinAfterSimPinUnlock() {
+        // GIVEN the current security method is SimPin
+        when(mKeyguardUpdateMonitor.getUserHasTrust(anyInt())).thenReturn(false);
+        when(mKeyguardUpdateMonitor.getUserUnlockedWithBiometric(TARGET_USER_ID)).thenReturn(false);
+        mKeyguardSecurityContainerController.showSecurityScreen(SecurityMode.SimPin);
+
+        // WHEN a request is made from the SimPin screens to show the next security method
+        when(mKeyguardSecurityModel.getSecurityMode(TARGET_USER_ID)).thenReturn(SecurityMode.PIN);
+        mKeyguardSecurityContainerController.showNextSecurityScreenOrFinish(
+                /* authenticated= */true,
+                TARGET_USER_ID,
+                /* bypassSecondaryLockScreen= */true,
+                SecurityMode.SimPin);
+
+        // THEN the next security method of PIN is set, and the keyguard is not marked as done
+        verify(mSecurityCallback, never()).finish(anyBoolean(), anyInt());
+        assertThat(mKeyguardSecurityContainerController.getCurrentSecurityMode())
+                .isEqualTo(SecurityMode.PIN);
+    }
+
+    @Test
+    public void showNextSecurityScreenOrFinish_ignoresCallWhenSecurityMethodHasChanged() {
+        //GIVEN current security mode has been set to PIN
+        mKeyguardSecurityContainerController.showSecurityScreen(SecurityMode.PIN);
+
+        //WHEN a request comes from SimPin to dismiss the security screens
+        boolean keyguardDone = mKeyguardSecurityContainerController.showNextSecurityScreenOrFinish(
+                /* authenticated= */true,
+                TARGET_USER_ID,
+                /* bypassSecondaryLockScreen= */true,
+                SecurityMode.SimPin);
+
+        //THEN no action has happened, which will not dismiss the security screens
+        assertThat(keyguardDone).isEqualTo(false);
+        verify(mKeyguardUpdateMonitor, never()).getUserHasTrust(anyInt());
+    }
 }
",41,0,"KeyguardSecurityContainerControllerTest::showNextSecurityScreenOrFinish_ignoresCallWhenSecurityMethodHasChanged, KeyguardSecurityContainerControllerTest::showNextSecurityScreenOrFinish_setsSecurityScreenToPinAfterSimPinUnlock"
132,b6ce47054c0770ce028e44b165610a65417dfd33,NotificationManagerService.java,"@@ -6751,6 +6751,7 @@ public class NotificationManagerService extends SystemService {
 
         @GuardedBy(""mNotificationLock"")
         void snoozeLocked(NotificationRecord r) {
+            final List<NotificationRecord> recordsToSnooze = new ArrayList<>();
             if (r.getSbn().isGroup()) {
                 final List<NotificationRecord> groupNotifications =
                         findCurrentAndSnoozedGroupNotificationsLocked(
@@ -6759,8 +6760,8 @@ public class NotificationManagerService extends SystemService {
                 if (r.getNotification().isGroupSummary()) {
                     // snooze all children
                     for (int i = 0; i < groupNotifications.size(); i++) {
-                        if (mKey != groupNotifications.get(i).getKey()) {
-                            snoozeNotificationLocked(groupNotifications.get(i));
+                        if (!mKey.equals(groupNotifications.get(i).getKey())) {
+                            recordsToSnooze.add(groupNotifications.get(i));
                         }
                     }
                 } else {
@@ -6770,8 +6771,8 @@ public class NotificationManagerService extends SystemService {
                         if (groupNotifications.size() == 2) {
                             // snooze summary and the one child
                             for (int i = 0; i < groupNotifications.size(); i++) {
-                                if (mKey != groupNotifications.get(i).getKey()) {
-                                    snoozeNotificationLocked(groupNotifications.get(i));
+                                if (!mKey.equals(groupNotifications.get(i).getKey())) {
+                                    recordsToSnooze.add(groupNotifications.get(i));
                                 }
                             }
                         }
@@ -6779,7 +6780,15 @@ public class NotificationManagerService extends SystemService {
                 }
             }
             // snooze the notification
-            snoozeNotificationLocked(r);
+            recordsToSnooze.add(r);
+
+            if (mSnoozeHelper.canSnooze(recordsToSnooze.size())) {
+                for (int i = 0; i < recordsToSnooze.size(); i++) {
+                    snoozeNotificationLocked(recordsToSnooze.get(i));
+                }
+            } else {
+                Log.w(TAG, ""Cannot snooze "" + r.getKey() + "": too many snoozed notifications"");
+            }
 
         }
 
",14,5,NotificationManagerService::SnoozeNotificationRunnable::snoozeLocked
133,b6ce47054c0770ce028e44b165610a65417dfd33,SnoozeHelper.java,"@@ -62,6 +62,8 @@ import java.util.Set;
 public class SnoozeHelper {
     public static final int XML_SNOOZED_NOTIFICATION_VERSION = 1;
 
+    static final int CONCURRENT_SNOOZE_LIMIT = 500;
+
     protected static final String XML_TAG_NAME = ""snoozed-notifications"";
 
     private static final String XML_SNOOZED_NOTIFICATION = ""notification"";
@@ -134,6 +136,15 @@ public class SnoozeHelper {
         }
     }
 
+    protected boolean canSnooze(int numberToSnooze) {
+        synchronized (mLock) {
+            if ((mPackages.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT) {
+                return false;
+            }
+        }
+        return true;
+    }
+
     @NonNull
     protected Long getSnoozeTimeForUnpostedNotification(int userId, String pkg, String key) {
         Long time = null;
",11,0,SnoozeHelper::canSnooze
134,b6ce47054c0770ce028e44b165610a65417dfd33,NotificationManagerServiceTest.java,"@@ -2798,20 +2798,81 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {
                 any(NotificationManagerService.SnoozeNotificationRunnable.class));
     }
 
+    @Test
+    public void testSnoozeRunnable_tooManySnoozed_singleNotification() {
+        final NotificationRecord notification = generateNotificationRecord(
+                mTestNotificationChannel, 1, null, true);
+        mService.addNotification(notification);
+
+        when(mSnoozeHelper.canSnooze(anyInt())).thenReturn(true);
+        when(mSnoozeHelper.canSnooze(1)).thenReturn(false);
+
+        NotificationManagerService.SnoozeNotificationRunnable snoozeNotificationRunnable =
+                mService.new SnoozeNotificationRunnable(
+                        notification.getKey(), 100, null);
+        snoozeNotificationRunnable.run();
+
+        verify(mSnoozeHelper, never()).snooze(any(NotificationRecord.class), anyLong());
+        assertEquals(1, mService.getNotificationRecordCount());
+    }
+
+    @Test
+    public void testSnoozeRunnable_tooManySnoozed_singleGroupChildNotification() {
+        final NotificationRecord notification = generateNotificationRecord(
+                mTestNotificationChannel, 1, ""group"", true);
+        final NotificationRecord notificationChild = generateNotificationRecord(
+                mTestNotificationChannel, 1, ""group"", false);
+        mService.addNotification(notification);
+        mService.addNotification(notificationChild);
+
+        when(mSnoozeHelper.canSnooze(anyInt())).thenReturn(true);
+        when(mSnoozeHelper.canSnooze(2)).thenReturn(false);
+
+        NotificationManagerService.SnoozeNotificationRunnable snoozeNotificationRunnable =
+                mService.new SnoozeNotificationRunnable(
+                        notificationChild.getKey(), 100, null);
+        snoozeNotificationRunnable.run();
+
+        verify(mSnoozeHelper, never()).snooze(any(NotificationRecord.class), anyLong());
+        assertEquals(2, mService.getNotificationRecordCount());
+    }
+
+    @Test
+    public void testSnoozeRunnable_tooManySnoozed_summaryNotification() {
+        final NotificationRecord notification = generateNotificationRecord(
+                mTestNotificationChannel, 1, ""group"", true);
+        final NotificationRecord notificationChild = generateNotificationRecord(
+                mTestNotificationChannel, 12, ""group"", false);
+        final NotificationRecord notificationChild2 = generateNotificationRecord(
+                mTestNotificationChannel, 13, ""group"", false);
+        mService.addNotification(notification);
+        mService.addNotification(notificationChild);
+        mService.addNotification(notificationChild2);
+
+        when(mSnoozeHelper.canSnooze(anyInt())).thenReturn(true);
+        when(mSnoozeHelper.canSnooze(3)).thenReturn(false);
+
+        NotificationManagerService.SnoozeNotificationRunnable snoozeNotificationRunnable =
+                mService.new SnoozeNotificationRunnable(
+                        notification.getKey(), 100, null);
+        snoozeNotificationRunnable.run();
+
+        verify(mSnoozeHelper, never()).snooze(any(NotificationRecord.class), anyLong());
+        assertEquals(3, mService.getNotificationRecordCount());
+    }
+
     @Test
     public void testSnoozeRunnable_reSnoozeASingleSnoozedNotification() throws Exception {
         final NotificationRecord notification = generateNotificationRecord(
                 mTestNotificationChannel, 1, null, true);
         mService.addNotification(notification);
         when(mSnoozeHelper.getNotification(any())).thenReturn(notification);
+        when(mSnoozeHelper.canSnooze(anyInt())).thenReturn(true);
 
         NotificationManagerService.SnoozeNotificationRunnable snoozeNotificationRunnable =
                 mService.new SnoozeNotificationRunnable(
                 notification.getKey(), 100, null);
         snoozeNotificationRunnable.run();
-        NotificationManagerService.SnoozeNotificationRunnable snoozeNotificationRunnable2 =
-                mService.new SnoozeNotificationRunnable(
-                notification.getKey(), 100, null);
         snoozeNotificationRunnable.run();
 
         // snooze twice
@@ -2819,19 +2880,17 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {
     }
 
     @Test
-    public void testSnoozeRunnable_reSnoozeASnoozedNotificationWithGroupKey() throws Exception {
+    public void testSnoozeRunnable_reSnoozeASnoozedNotificationWithGroupKey() {
         final NotificationRecord notification = generateNotificationRecord(
                 mTestNotificationChannel, 1, ""group"", true);
         mService.addNotification(notification);
         when(mSnoozeHelper.getNotification(any())).thenReturn(notification);
+        when(mSnoozeHelper.canSnooze(anyInt())).thenReturn(true);
 
         NotificationManagerService.SnoozeNotificationRunnable snoozeNotificationRunnable =
                 mService.new SnoozeNotificationRunnable(
                 notification.getKey(), 100, null);
         snoozeNotificationRunnable.run();
-        NotificationManagerService.SnoozeNotificationRunnable snoozeNotificationRunnable2 =
-                mService.new SnoozeNotificationRunnable(
-                notification.getKey(), 100, null);
         snoozeNotificationRunnable.run();
 
         // snooze twice
@@ -2849,6 +2908,7 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {
         when(mSnoozeHelper.getNotification(any())).thenReturn(notification);
         when(mSnoozeHelper.getNotifications(
                 anyString(), anyString(), anyInt())).thenReturn(new ArrayList<>());
+        when(mSnoozeHelper.canSnooze(anyInt())).thenReturn(true);
 
         NotificationManagerService.SnoozeNotificationRunnable snoozeNotificationRunnable =
                 mService.new SnoozeNotificationRunnable(
@@ -2858,8 +2918,8 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {
                 .thenReturn(new ArrayList<>(Arrays.asList(notification, notification2)));
         NotificationManagerService.SnoozeNotificationRunnable snoozeNotificationRunnable2 =
                 mService.new SnoozeNotificationRunnable(
-                        notification.getKey(), 100, null);
-        snoozeNotificationRunnable.run();
+                        notification2.getKey(), 100, null);
+        snoozeNotificationRunnable2.run();
 
         // snooze twice
         verify(mSnoozeHelper, times(4)).snooze(any(NotificationRecord.class), anyLong());
@@ -2873,6 +2933,7 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {
                 mTestNotificationChannel, 2, ""group"", false);
         mService.addNotification(grouped);
         mService.addNotification(nonGrouped);
+        when(mSnoozeHelper.canSnooze(anyInt())).thenReturn(true);
 
         NotificationManagerService.SnoozeNotificationRunnable snoozeNotificationRunnable =
                 mService.new SnoozeNotificationRunnable(
@@ -2902,6 +2963,7 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {
         mService.addNotification(parent);
         mService.addNotification(child);
         mService.addNotification(child2);
+        when(mSnoozeHelper.canSnooze(anyInt())).thenReturn(true);
 
         NotificationManagerService.SnoozeNotificationRunnable snoozeNotificationRunnable =
                 mService.new SnoozeNotificationRunnable(
@@ -2923,6 +2985,7 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {
         mService.addNotification(parent);
         mService.addNotification(child);
         mService.addNotification(child2);
+        when(mSnoozeHelper.canSnooze(anyInt())).thenReturn(true);
 
         NotificationManagerService.SnoozeNotificationRunnable snoozeNotificationRunnable =
                 mService.new SnoozeNotificationRunnable(
@@ -2948,6 +3011,7 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {
                 mTestNotificationChannel, 2, ""group"", false);
         mService.addNotification(parent);
         mService.addNotification(child);
+        when(mSnoozeHelper.canSnooze(anyInt())).thenReturn(true);
 
         NotificationManagerService.SnoozeNotificationRunnable snoozeNotificationRunnable =
                 mService.new SnoozeNotificationRunnable(
@@ -2975,6 +3039,7 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {
         final NotificationRecord child = generateNotificationRecord(
                 mTestNotificationChannel, 2, ""group"", false);
         mService.addNotification(child);
+        when(mSnoozeHelper.canSnooze(anyInt())).thenReturn(true);
 
         NotificationManagerService.SnoozeNotificationRunnable snoozeNotificationRunnable =
                 mService.new SnoozeNotificationRunnable(
",74,9,"NotificationManagerServiceTest::testSnoozeRunnable_tooManySnoozed_singleNotification, NotificationManagerServiceTest::testSnoozeRunnable_reSnoozeASnoozedNotificationWithGroupKey, NotificationManagerServiceTest::testSnoozeRunnable_snoozeGroupChild_fellowChildren, NotificationManagerServiceTest::testSnoozeRunnable_snoozeGroupChild_onlyChildOfSummary, NotificationManagerServiceTest::testSnoozeRunnable_tooManySnoozed_summaryNotification, NotificationManagerServiceTest::testSnoozeRunnable_snoozeSummary_withChildren, NotificationManagerServiceTest::testSnoozeRunnable_snoozeGroupChild_noOthersInGroup, NotificationManagerServiceTest::testSnoozeRunnable_tooManySnoozed_singleGroupChildNotification, NotificationManagerServiceTest::testSnoozeRunnable_reSnoozeMultipleNotificationsWithGroupKey, NotificationManagerServiceTest::testSnoozeRunnable_reSnoozeASingleSnoozedNotification, NotificationManagerServiceTest::testSnoozeRunnable_snoozeNonGrouped"
135,b6ce47054c0770ce028e44b165610a65417dfd33,SnoozeHelperTest.java,"@@ -15,6 +15,7 @@
  */
 package com.android.server.notification;
 
+import static com.android.server.notification.SnoozeHelper.CONCURRENT_SNOOZE_LIMIT;
 import static com.android.server.notification.SnoozeHelper.EXTRA_KEY;
 
 import static junit.framework.Assert.assertEquals;
@@ -280,6 +281,22 @@ public class SnoozeHelperTest extends UiServiceTestCase {
                 UserHandle.USER_SYSTEM, r.getSbn().getPackageName(), r.getKey()));
     }
 
+    @Test
+    public void testSnoozeLimit() {
+        for (int i = 0; i < CONCURRENT_SNOOZE_LIMIT; i++ ) {
+            NotificationRecord r = getNotificationRecord(""pkg"", i, i+"""", UserHandle.SYSTEM);
+
+            assertTrue(""cannot snooze record "" + i, mSnoozeHelper.canSnooze(1));
+
+            if (i % 2 == 0) {
+                mSnoozeHelper.snooze(r, null);
+            } else {
+                mSnoozeHelper.snooze(r, 9000);
+            }
+        }
+        assertFalse(mSnoozeHelper.canSnooze(1));
+    }
+
     @Test
     public void testCancelByApp() throws Exception {
         NotificationRecord r = getNotificationRecord(""pkg"", 1, ""one"", UserHandle.SYSTEM);
",17,0,SnoozeHelperTest::testSnoozeLimit
136,ea88f4dacab25b56ef333ec24362200e9b8dfd47,SurfaceUtils.java,"@@ -20,11 +20,14 @@ import static android.system.OsConstants.EINVAL;
 
 import static com.android.internal.util.Preconditions.checkNotNull;
 
+import android.app.ActivityThread;
 import android.compat.annotation.UnsupportedAppUsage;
 import android.graphics.ImageFormat;
 import android.graphics.PixelFormat;
 import android.hardware.HardwareBuffer;
 import android.hardware.camera2.params.StreamConfigurationMap;
+import android.os.SystemProperties;
+import android.text.TextUtils;
 import android.util.Range;
 import android.util.Size;
 import android.view.Surface;
@@ -241,6 +244,11 @@ public class SurfaceUtils {
                     + "" the size must be 1 or 2"");
         }
 
+        if (isPrivilegedApp()) {
+            //skip checks for privileged apps
+            return;
+        }
+
         List<Size> highSpeedSizes = null;
         if (fpsRange == null) {
             highSpeedSizes = Arrays.asList(config.getHighSpeedVideoSizes());
@@ -303,4 +311,21 @@ public class SurfaceUtils {
             /*out*/int[/*2*/] dimens);
 
     private static native long nativeGetSurfaceId(Surface surface);
+
+    private static boolean isPrivilegedApp() {
+        String packageName = ActivityThread.currentOpPackageName();
+        String packageList = SystemProperties.get(""persist.vendor.camera.privapp.list"");
+
+        if (packageList.length() > 0) {
+            TextUtils.StringSplitter splitter = new TextUtils.SimpleStringSplitter(',');
+            splitter.setString(packageList);
+            for (String str : splitter) {
+                if (packageName.equals(str)) {
+                    return true;
+                }
+            }
+        }
+
+        return false;
+    }
 }
",25,0,"SurfaceUtils::isPrivilegedApp, SurfaceUtils::checkConstrainedHighSpeedSurfaces"
137,0c648fbdfd607a586fd411c7036cbf7cac0efba3,NotificationMediaManager.java,"@@ -166,7 +166,7 @@ public class NotificationMediaManager implements Dumpable, TunerService.Tunable
                 }
                 findAndUpdateMediaNotifications();
                 mStatusBarOptionalLazy.get().map(StatusBar::getVisualizerView).ifPresent(
-                        v -> v.setOccluded(state.getState() == PlaybackState.STATE_PLAYING));
+                        v -> v.setPlaying(state.getState() == PlaybackState.STATE_PLAYING));
             }
         }
 
",1,1,NotificationMediaManager::Callback
138,17f77d49d8f311f2b6e159847799500b329e7bb1,PackageManagerService.java,"@@ -21739,16 +21739,6 @@ public class PackageManagerService extends IPackageManager.Stub
                 return PackageManager.DELETE_FAILED_INTERNAL_ERROR;
             }
 
-            if (isSystemApp(uninstalledPs)) {
-                UserInfo userInfo = mUserManager.getUserInfo(userId);
-                if (userInfo == null || !userInfo.isAdmin()) {
-                    Slog.w(TAG, ""Not removing package "" + packageName
-                            + "" as only admin user may downgrade system apps"");
-                    EventLog.writeEvent(0x534e4554, ""170646036"", -1, packageName);
-                    return PackageManager.DELETE_FAILED_USER_RESTRICTED;
-                }
-            }
-
             disabledSystemPs = mSettings.getDisabledSystemPkgLPr(packageName);
             // Static shared libs can be declared by any package, so let us not
             // allow removing a package if it provides a lib others depend on.
",0,10,PackageManagerService::deletePackageX
139,1064ad0a0ec5eafc1fd7c14d42d546b3fc480245,EditUserPhotoController.java,"@@ -21,8 +21,6 @@ import android.content.ClipData;
 import android.content.ContentResolver;
 import android.content.Context;
 import android.content.Intent;
-import android.content.pm.ActivityInfo;
-import android.content.pm.PackageManager;
 import android.database.Cursor;
 import android.graphics.Bitmap;
 import android.graphics.Bitmap.Config;
@@ -85,7 +83,6 @@ public class EditUserPhotoController {
     private static final int DEFAULT_PHOTO_SIZE = 500;
 
     private static final String IMAGES_DIR = ""multi_user"";
-    private static final String PRE_CROP_PICTURE_FILE_NAME = ""PreCropEditUserPhoto.jpg"";
     private static final String CROP_PICTURE_FILE_NAME = ""CropEditUserPhoto.jpg"";
     private static final String TAKE_PICTURE_FILE_NAME = ""TakeEditUserPhoto.jpg"";
     private static final String NEW_USER_PHOTO_FILE_NAME = ""NewUserPhoto.png"";
@@ -98,7 +95,6 @@ public class EditUserPhotoController {
     private final String mFileAuthority;
 
     private final File mImagesDir;
-    private final Uri mPreCropPictureUri;
     private final Uri mCropPictureUri;
     private final Uri mTakePictureUri;
 
@@ -114,7 +110,6 @@ public class EditUserPhotoController {
 
         mImagesDir = new File(activity.getCacheDir(), IMAGES_DIR);
         mImagesDir.mkdir();
-        mPreCropPictureUri = createTempImageUri(activity, PRE_CROP_PICTURE_FILE_NAME, !waiting);
         mCropPictureUri = createTempImageUri(activity, CROP_PICTURE_FILE_NAME, !waiting);
         mTakePictureUri = createTempImageUri(activity, TAKE_PICTURE_FILE_NAME, !waiting);
         mPhotoSize = getPhotoSize(activity);
@@ -148,7 +143,7 @@ public class EditUserPhotoController {
             case REQUEST_CODE_CHOOSE_PHOTO:
                 if (mTakePictureUri.equals(pictureUri)) {
                     if (PhotoCapabilityUtils.canCropPhoto(mActivity)) {
-                        cropPhoto(pictureUri);
+                        cropPhoto();
                     } else {
                         onPhotoNotCropped(pictureUri);
                     }
@@ -229,7 +224,7 @@ public class EditUserPhotoController {
             protected Void doInBackground(Void... params) {
                 final ContentResolver cr = mActivity.getContentResolver();
                 try (InputStream in = cr.openInputStream(pictureUri);
-                        OutputStream out = cr.openOutputStream(mPreCropPictureUri)) {
+                     OutputStream out = cr.openOutputStream(mTakePictureUri)) {
                     Streams.copy(in, out);
                 } catch (IOException e) {
                     Log.w(TAG, ""Failed to copy photo"", e);
@@ -240,41 +235,28 @@ public class EditUserPhotoController {
             @Override
             protected void onPostExecute(Void result) {
                 if (!mActivity.isFinishing() && !mActivity.isDestroyed()) {
-                    cropPhoto(mPreCropPictureUri);
+                    cropPhoto();
                 }
             }
         }.execute();
     }
 
-    private void cropPhoto(final Uri pictureUri) {
+    private void cropPhoto() {
         // TODO: Use a public intent, when there is one.
         Intent intent = new Intent(""com.android.camera.action.CROP"");
-        intent.setDataAndType(pictureUri, ""image/*"");
+        intent.setDataAndType(mTakePictureUri, ""image/*"");
         appendOutputExtra(intent, mCropPictureUri);
         appendCropExtras(intent);
-        try {
-            StrictMode.disableDeathOnFileUriExposure();
-            if (startSystemActivityForResult(intent, REQUEST_CODE_CROP_PHOTO)) {
-                return;
+        if (intent.resolveActivity(mActivity.getPackageManager()) != null) {
+            try {
+                StrictMode.disableDeathOnFileUriExposure();
+                mActivityStarter.startActivityForResult(intent, REQUEST_CODE_CROP_PHOTO);
+            } finally {
+                StrictMode.enableDeathOnFileUriExposure();
             }
-        } finally {
-            StrictMode.enableDeathOnFileUriExposure();
-        }
-
-        onPhotoNotCropped(mTakePictureUri);
-
-    }
-
-    private boolean startSystemActivityForResult(Intent intent, int code) {
-        ActivityInfo info = intent.resolveActivityInfo(mActivity.getPackageManager(),
-                PackageManager.MATCH_SYSTEM_ONLY);
-        if (info == null) {
-            Log.w(TAG, ""No system package activity could be found for code "" + code);
-            return false;
+        } else {
+            onPhotoNotCropped(mTakePictureUri);
         }
-        intent.setPackage(info.packageName);
-        mActivityStarter.startActivityForResult(intent, code);
-        return true;
     }
 
     private void appendOutputExtra(Intent intent, Uri pictureUri) {
",13,31,"EditUserPhotoController::cropPhoto, EditUserPhotoController::EditUserPhotoController, EditUserPhotoController::cropPhoto, EditUserPhotoController::onActivityResult, EditUserPhotoController::startSystemActivityForResult, EditUserPhotoController::copyAndCropPhoto"
140,40d09c7983dc8f5053123f0045ba5b4fa4494a10,PackageManagerService.java,"@@ -21739,6 +21739,17 @@ public class PackageManagerService extends IPackageManager.Stub
                 return PackageManager.DELETE_FAILED_INTERNAL_ERROR;
             }
 
+            if (isSystemApp(uninstalledPs)
+                    && (deleteFlags & PackageManager.DELETE_SYSTEM_APP) == 0) {
+                UserInfo userInfo = mUserManager.getUserInfo(userId);
+                if (userInfo == null || !userInfo.isAdmin()) {
+                    Slog.w(TAG, ""Not removing package "" + packageName
+                            + "" as only admin user may downgrade system apps"");
+                    EventLog.writeEvent(0x534e4554, ""170646036"", -1, packageName);
+                    return PackageManager.DELETE_FAILED_USER_RESTRICTED;
+                }
+            }
+
             disabledSystemPs = mSettings.getDisabledSystemPkgLPr(packageName);
             // Static shared libs can be declared by any package, so let us not
             // allow removing a package if it provides a lib others depend on.
",11,0,PackageManagerService::deletePackageX
141,adeaf8cc25530afb8a92e4a04127651c0995bedd,NotificationChannel.java,"@@ -124,8 +124,13 @@ public final class NotificationChannel implements Parcelable {
     /**
      * The maximum length for text fields in a NotificationChannel. Fields will be truncated at this
      * limit.
+     * @hide
      */
-    private static final int MAX_TEXT_LENGTH = 1000;
+    public static final int MAX_TEXT_LENGTH = 1000;
+    /**
+     * @hide
+     */
+    public static final int MAX_VIBRATION_LENGTH = 1000;
 
     private static final String TAG_CHANNEL = ""channel"";
     private static final String ATT_NAME = ""name"";
@@ -284,17 +289,17 @@ public final class NotificationChannel implements Parcelable {
      */
     protected NotificationChannel(Parcel in) {
         if (in.readByte() != 0) {
-            mId = in.readString();
+            mId = getTrimmedString(in.readString());
         } else {
             mId = null;
         }
         if (in.readByte() != 0) {
-            mName = in.readString();
+            mName = getTrimmedString(in.readString());
         } else {
             mName = null;
         }
         if (in.readByte() != 0) {
-            mDesc = in.readString();
+            mDesc = getTrimmedString(in.readString());
         } else {
             mDesc = null;
         }
@@ -303,18 +308,22 @@ public final class NotificationChannel implements Parcelable {
         mLockscreenVisibility = in.readInt();
         if (in.readByte() != 0) {
             mSound = Uri.CREATOR.createFromParcel(in);
+            mSound = Uri.parse(getTrimmedString(mSound.toString()));
         } else {
             mSound = null;
         }
         mLights = in.readByte() != 0;
         mVibration = in.createLongArray();
+        if (mVibration != null && mVibration.length > MAX_VIBRATION_LENGTH) {
+            mVibration = Arrays.copyOf(mVibration, MAX_VIBRATION_LENGTH);
+        }
         mUserLockedFields = in.readInt();
         mFgServiceShown = in.readByte() != 0;
         mVibrationEnabled = in.readByte() != 0;
         mShowBadge = in.readByte() != 0;
         mDeleted = in.readByte() != 0;
         if (in.readByte() != 0) {
-            mGroup = in.readString();
+            mGroup = getTrimmedString(in.readString());
         } else {
             mGroup = null;
         }
@@ -324,8 +333,8 @@ public final class NotificationChannel implements Parcelable {
         mAllowBubbles = in.readInt();
         mImportanceLockedByOEM = in.readBoolean();
         mOriginalImportance = in.readInt();
-        mParentId = in.readString();
-        mConversationId = in.readString();
+        mParentId = getTrimmedString(in.readString());
+        mConversationId = getTrimmedString(in.readString());
         mDemoted = in.readBoolean();
         mImportantConvo = in.readBoolean();
         mDeletedTime = in.readLong();
",16,7,NotificationChannel::NotificationChannel
142,adeaf8cc25530afb8a92e4a04127651c0995bedd,NotificationChannelGroup.java,"@@ -43,8 +43,9 @@ public final class NotificationChannelGroup implements Parcelable {
     /**
      * The maximum length for text fields in a NotificationChannelGroup. Fields will be truncated at
      * this limit.
+     * @hide
      */
-    private static final int MAX_TEXT_LENGTH = 1000;
+    public static final int MAX_TEXT_LENGTH = 1000;
 
     private static final String TAG_GROUP = ""channelGroup"";
     private static final String ATT_NAME = ""name"";
@@ -90,13 +91,14 @@ public final class NotificationChannelGroup implements Parcelable {
      */
     protected NotificationChannelGroup(Parcel in) {
         if (in.readByte() != 0) {
-            mId = in.readString();
+            mId = getTrimmedString(in.readString());
         } else {
             mId = null;
         }
         mName = TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(in);
+        mName = getTrimmedString(mName.toString());
         if (in.readByte() != 0) {
-            mDescription = in.readString();
+            mDescription = getTrimmedString(in.readString());
         } else {
             mDescription = null;
         }
@@ -120,7 +122,7 @@ public final class NotificationChannelGroup implements Parcelable {
         } else {
             dest.writeByte((byte) 0);
         }
-        TextUtils.writeToParcel(mName, dest, flags);
+        TextUtils.writeToParcel(mName.toString(), dest, flags);
         if (mDescription != null) {
             dest.writeByte((byte) 1);
             dest.writeString(mDescription);
",6,4,"NotificationChannelGroup::NotificationChannelGroup, NotificationChannelGroup::writeToParcel"
143,adeaf8cc25530afb8a92e4a04127651c0995bedd,NotificationChannelGroupTest.java,"@@ -0,0 +1,73 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.app;
+
+import static junit.framework.TestCase.assertEquals;
+
+import android.os.Parcel;
+import android.test.AndroidTestCase;
+
+import androidx.test.filters.SmallTest;
+import androidx.test.runner.AndroidJUnit4;
+
+import com.google.common.base.Strings;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.lang.reflect.Field;
+
+@RunWith(AndroidJUnit4.class)
+@SmallTest
+public class NotificationChannelGroupTest {
+    private final String CLASS = ""android.app.NotificationChannelGroup"";
+
+    @Test
+    public void testLongStringFields() {
+        NotificationChannelGroup group = new NotificationChannelGroup(""my_group_01"", ""groupName"");
+
+        try {
+            String longString = Strings.repeat(""A"", 65536);
+            Field mName = Class.forName(CLASS).getDeclaredField(""mName"");
+            mName.setAccessible(true);
+            mName.set(group, longString);
+            Field mId = Class.forName(CLASS).getDeclaredField(""mId"");
+            mId.setAccessible(true);
+            mId.set(group, longString);
+            Field mDescription = Class.forName(CLASS).getDeclaredField(""mDescription"");
+            mDescription.setAccessible(true);
+            mDescription.set(group, longString);
+        } catch (NoSuchFieldException e) {
+            e.printStackTrace();
+        } catch (ClassNotFoundException e) {
+            e.printStackTrace();
+        } catch (IllegalAccessException e) {
+            e.printStackTrace();
+        }
+
+        Parcel parcel = Parcel.obtain();
+        group.writeToParcel(parcel, 0);
+        parcel.setDataPosition(0);
+
+        NotificationChannelGroup fromParcel =
+                NotificationChannelGroup.CREATOR.createFromParcel(parcel);
+        assertEquals(NotificationChannelGroup.MAX_TEXT_LENGTH, fromParcel.getId().length());
+        assertEquals(NotificationChannelGroup.MAX_TEXT_LENGTH, fromParcel.getName().length());
+        assertEquals(NotificationChannelGroup.MAX_TEXT_LENGTH,
+                fromParcel.getDescription().length());
+    }
+}
",73,0,NotificationChannelGroupTest::testLongStringFields
144,adeaf8cc25530afb8a92e4a04127651c0995bedd,NotificationChannelTest.java,"@@ -0,0 +1,106 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.app;
+
+import static junit.framework.TestCase.assertEquals;
+
+import android.net.Uri;
+import android.os.Parcel;
+
+import androidx.test.filters.SmallTest;
+import androidx.test.runner.AndroidJUnit4;
+
+import com.google.common.base.Strings;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.lang.reflect.Field;
+
+@RunWith(AndroidJUnit4.class)
+@SmallTest
+public class NotificationChannelTest {
+    private final String CLASS = ""android.app.NotificationChannel"";
+
+    @Test
+    public void testLongStringFields() {
+        NotificationChannel channel = new NotificationChannel(""id"", ""name"", 3);
+
+        try {
+            String longString = Strings.repeat(""A"", 65536);
+            Field mName = Class.forName(CLASS).getDeclaredField(""mName"");
+            mName.setAccessible(true);
+            mName.set(channel, longString);
+            Field mId = Class.forName(CLASS).getDeclaredField(""mId"");
+            mId.setAccessible(true);
+            mId.set(channel, longString);
+            Field mDesc = Class.forName(CLASS).getDeclaredField(""mDesc"");
+            mDesc.setAccessible(true);
+            mDesc.set(channel, longString);
+            Field mParentId = Class.forName(CLASS).getDeclaredField(""mParentId"");
+            mParentId.setAccessible(true);
+            mParentId.set(channel, longString);
+            Field mGroup = Class.forName(CLASS).getDeclaredField(""mGroup"");
+            mGroup.setAccessible(true);
+            mGroup.set(channel, longString);
+            Field mConversationId = Class.forName(CLASS).getDeclaredField(""mConversationId"");
+            mConversationId.setAccessible(true);
+            mConversationId.set(channel, longString);
+        } catch (NoSuchFieldException e) {
+            e.printStackTrace();
+        } catch (ClassNotFoundException e) {
+            e.printStackTrace();
+        } catch (IllegalAccessException e) {
+            e.printStackTrace();
+        }
+
+        Parcel parcel = Parcel.obtain();
+        channel.writeToParcel(parcel, 0);
+        parcel.setDataPosition(0);
+
+        NotificationChannel fromParcel = NotificationChannel.CREATOR.createFromParcel(parcel);
+        assertEquals(NotificationChannel.MAX_TEXT_LENGTH, fromParcel.getId().length());
+        assertEquals(NotificationChannel.MAX_TEXT_LENGTH, fromParcel.getName().length());
+        assertEquals(NotificationChannel.MAX_TEXT_LENGTH,
+                fromParcel.getDescription().length());
+        assertEquals(NotificationChannel.MAX_TEXT_LENGTH,
+                fromParcel.getParentChannelId().length());
+        assertEquals(NotificationChannel.MAX_TEXT_LENGTH,
+                fromParcel.getGroup().length());
+        assertEquals(NotificationChannel.MAX_TEXT_LENGTH,
+                fromParcel.getConversationId().length());
+    }
+
+    @Test
+    public void testLongAlertFields() {
+        NotificationChannel channel = new NotificationChannel(""id"", ""name"", 3);
+
+        channel.setSound(Uri.parse(""content://"" + Strings.repeat(""A"",65536)),
+                Notification.AUDIO_ATTRIBUTES_DEFAULT);
+        channel.setVibrationPattern(new long[65550/2]);
+
+        Parcel parcel = Parcel.obtain();
+        channel.writeToParcel(parcel, 0);
+        parcel.setDataPosition(0);
+
+        NotificationChannel fromParcel = NotificationChannel.CREATOR.createFromParcel(parcel);
+        assertEquals(NotificationChannel.MAX_VIBRATION_LENGTH,
+                fromParcel.getVibrationPattern().length);
+        assertEquals(NotificationChannel.MAX_TEXT_LENGTH,
+                fromParcel.getSound().toString().length());
+    }
+}
",106,0,"NotificationChannelTest::testLongStringFields, NotificationChannelTest::testLongAlertFields"
145,cfe51c00cd4c0b412d321bbb967a1faddcaa2216,AccessibilityManagerService.java,"@@ -935,7 +935,8 @@ public class AccessibilityManagerService extends IAccessibilityManager.Stub
             final List<AccessibilityServiceInfo> result = new ArrayList<>(serviceCount);
             for (int i = 0; i < serviceCount; ++i) {
                 final AccessibilityServiceConnection service = services.get(i);
-                if ((service.mFeedbackType & feedbackType) != 0) {
+                if ((service.mFeedbackType & feedbackType) != 0
+                        || feedbackType == AccessibilityServiceInfo.FEEDBACK_ALL_MASK) {
                     result.add(service.getServiceInfo());
                 }
             }
",2,1,AccessibilityManagerService::getEnabledAccessibilityServiceList
146,62d9be5800c460e7c1f323898306fc75ac37d66a,PackageManagerService.java,"@@ -21436,6 +21436,20 @@ public class PackageManagerService extends IPackageManager.Stub
 
         final String packageName = versionedPackage.getPackageName();
         final long versionCode = versionedPackage.getLongVersionCode();
+
+        if (mProtectedPackages.isPackageStateProtected(userId, packageName)) {
+            mHandler.post(() -> {
+                try {
+                    Slog.w(TAG, ""Attempted to delete protected package: "" + packageName);
+                    observer.onPackageDeleted(packageName,
+                            PackageManager.DELETE_FAILED_INTERNAL_ERROR, null);
+                } catch (RemoteException re) {
+                }
+            });
+            return;
+        }
+
+
         final String internalPackageName;
 
         try {
",14,0,PackageManagerService::deletePackageVersionedInternal
147,78f58b477987e157ac4d73db4f99a19ecebd33bd,Condition.java,"@@ -90,6 +90,12 @@ public final class Condition implements Parcelable {
     public final int flags;
     public final int icon;
 
+    /**
+     * The maximum string length for any string contained in this condition.
+     * @hide
+     */
+    public static final int MAX_STRING_LENGTH = 1000;
+
     /**
      * An object representing the current state of a {@link android.app.AutomaticZenRule}.
      * @param id the {@link android.app.AutomaticZenRule#getConditionId()} of the zen rule
@@ -104,16 +110,19 @@ public final class Condition implements Parcelable {
         if (id == null) throw new IllegalArgumentException(""id is required"");
         if (summary == null) throw new IllegalArgumentException(""summary is required"");
         if (!isValidState(state)) throw new IllegalArgumentException(""state is invalid: "" + state);
-        this.id = id;
-        this.summary = summary;
-        this.line1 = line1;
-        this.line2 = line2;
+        this.id = getTrimmedUri(id);
+        this.summary = getTrimmedString(summary);
+        this.line1 = getTrimmedString(line1);
+        this.line2 = getTrimmedString(line2);
         this.icon = icon;
         this.state = state;
         this.flags = flags;
     }
 
     public Condition(Parcel source) {
+        // This constructor passes all fields directly into the constructor that takes all the
+        // fields as arguments; that constructor will trim each of the input strings to
+        // max length if necessary.
         this((Uri)source.readParcelable(Condition.class.getClassLoader()),
                 source.readString(),
                 source.readString(),
@@ -240,4 +249,25 @@ public final class Condition implements Parcelable {
             return new Condition[size];
         }
     };
+
+    /**
+     * Returns a truncated copy of the string if the string is longer than MAX_STRING_LENGTH.
+     */
+    private static String getTrimmedString(String input) {
+        if (input != null && input.length() > MAX_STRING_LENGTH) {
+            return input.substring(0, MAX_STRING_LENGTH);
+        }
+        return input;
+    }
+
+    /**
+     * Returns a truncated copy of the Uri by trimming the string representation to the maximum
+     * string length.
+     */
+    private static Uri getTrimmedUri(Uri input) {
+        if (input != null && input.toString().length() > MAX_STRING_LENGTH) {
+            return Uri.parse(getTrimmedString(input.toString()));
+        }
+        return input;
+    }
 }
",34,4,"Condition::getTrimmedUri, Condition::Condition, Condition::getTrimmedString, Condition::Condition"
148,78f58b477987e157ac4d73db4f99a19ecebd33bd,ConditionTest.java,"@@ -0,0 +1,101 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.service.notification;
+
+import static junit.framework.Assert.assertEquals;
+import static junit.framework.Assert.fail;
+
+import android.net.Uri;
+import android.os.Parcel;
+
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import androidx.test.filters.SmallTest;
+
+import com.google.common.base.Strings;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.lang.reflect.Field;
+
+@RunWith(AndroidJUnit4.class)
+@SmallTest
+public class ConditionTest {
+    private static final String CLASS = ""android.service.notification.Condition"";
+
+    @Test
+    public void testLongFields_inConstructors() {
+        String longString = Strings.repeat(""A"", 65536);
+        Uri longUri = Uri.parse(""uri://"" + Strings.repeat(""A"", 65530));
+
+        // Confirm strings are truncated via short constructor
+        Condition cond1 = new Condition(longUri, longString, Condition.STATE_TRUE);
+
+        assertEquals(Condition.MAX_STRING_LENGTH, cond1.id.toString().length());
+        assertEquals(Condition.MAX_STRING_LENGTH, cond1.summary.length());
+
+        // Confirm strings are truncated via long constructor
+        Condition cond2 = new Condition(longUri, longString, longString, longString,
+                -1, Condition.STATE_TRUE, Condition.FLAG_RELEVANT_ALWAYS);
+
+        assertEquals(Condition.MAX_STRING_LENGTH, cond2.id.toString().length());
+        assertEquals(Condition.MAX_STRING_LENGTH, cond2.summary.length());
+        assertEquals(Condition.MAX_STRING_LENGTH, cond2.line1.length());
+        assertEquals(Condition.MAX_STRING_LENGTH, cond2.line2.length());
+    }
+
+    @Test
+    public void testLongFields_viaParcel() {
+        // Set fields via reflection to force them to be long, then parcel and unparcel to make sure
+        // it gets truncated upon unparcelling.
+        Condition cond = new Condition(Uri.parse(""uri://placeholder""), ""placeholder"",
+                Condition.STATE_TRUE);
+
+        try {
+            String longString = Strings.repeat(""A"", 65536);
+            Uri longUri = Uri.parse(""uri://"" + Strings.repeat(""A"", 65530));
+            Field id = Class.forName(CLASS).getDeclaredField(""id"");
+            id.setAccessible(true);
+            id.set(cond, longUri);
+            Field summary = Class.forName(CLASS).getDeclaredField(""summary"");
+            summary.setAccessible(true);
+            summary.set(cond, longString);
+            Field line1 = Class.forName(CLASS).getDeclaredField(""line1"");
+            line1.setAccessible(true);
+            line1.set(cond, longString);
+            Field line2 = Class.forName(CLASS).getDeclaredField(""line2"");
+            line2.setAccessible(true);
+            line2.set(cond, longString);
+        } catch (NoSuchFieldException e) {
+            fail(e.toString());
+        } catch (ClassNotFoundException e) {
+            fail(e.toString());
+        } catch (IllegalAccessException e) {
+            fail(e.toString());
+        }
+
+        Parcel parcel = Parcel.obtain();
+        cond.writeToParcel(parcel, 0);
+        parcel.setDataPosition(0);
+
+        Condition fromParcel = new Condition(parcel);
+        assertEquals(Condition.MAX_STRING_LENGTH, fromParcel.id.toString().length());
+        assertEquals(Condition.MAX_STRING_LENGTH, fromParcel.summary.length());
+        assertEquals(Condition.MAX_STRING_LENGTH, fromParcel.line1.length());
+        assertEquals(Condition.MAX_STRING_LENGTH, fromParcel.line2.length());
+    }
+}
",101,0,"ConditionTest::testLongFields_inConstructors, ConditionTest::testLongFields_viaParcel"
149,d0b5819a37b7a06b07385d898742d558aac4e7da,NotificationChannelGroup.java,"@@ -95,8 +95,11 @@ public final class NotificationChannelGroup implements Parcelable {
         } else {
             mId = null;
         }
-        mName = TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(in);
-        mName = getTrimmedString(mName.toString());
+        if (in.readByte() != 0) {
+            mName = getTrimmedString(in.readString());
+        } else {
+            mName = """";
+        }
         if (in.readByte() != 0) {
             mDescription = getTrimmedString(in.readString());
         } else {
@@ -122,7 +125,12 @@ public final class NotificationChannelGroup implements Parcelable {
         } else {
             dest.writeByte((byte) 0);
         }
-        TextUtils.writeToParcel(mName.toString(), dest, flags);
+        if (mName != null) {
+            dest.writeByte((byte) 1);
+            dest.writeString(mName.toString());
+        } else {
+            dest.writeByte((byte) 0);
+        }
         if (mDescription != null) {
             dest.writeByte((byte) 1);
             dest.writeString(mDescription);
",11,3,"NotificationChannelGroup::NotificationChannelGroup, NotificationChannelGroup::writeToParcel"
150,d0b5819a37b7a06b07385d898742d558aac4e7da,NotificationChannelGroupTest.java,"@@ -17,9 +17,11 @@
 package android.app;
 
 import static junit.framework.TestCase.assertEquals;
+import static junit.framework.TestCase.assertTrue;
 
 import android.os.Parcel;
 import android.test.AndroidTestCase;
+import android.text.TextUtils;
 
 import androidx.test.filters.SmallTest;
 import androidx.test.runner.AndroidJUnit4;
@@ -70,4 +72,18 @@ public class NotificationChannelGroupTest {
         assertEquals(NotificationChannelGroup.MAX_TEXT_LENGTH,
                 fromParcel.getDescription().length());
     }
+
+    @Test
+    public void testNullableFields() {
+        NotificationChannelGroup group = new NotificationChannelGroup(""my_group_01"", null);
+
+        Parcel parcel = Parcel.obtain();
+        group.writeToParcel(parcel, 0);
+        parcel.setDataPosition(0);
+
+        NotificationChannelGroup fromParcel =
+                NotificationChannelGroup.CREATOR.createFromParcel(parcel);
+        assertEquals(group.getId(), fromParcel.getId());
+        assertTrue(TextUtils.isEmpty(fromParcel.getName()));
+    }
 }
",16,0,NotificationChannelGroupTest::testNullableFields
151,82e4c08288424015d447681815554397cf793a1e,AppWidgetManager.java,"@@ -1130,7 +1130,9 @@ public class AppWidgetManager {
      * @param intent        The intent of the service which will be providing the data to the
      *                      RemoteViewsAdapter.
      * @param connection    The callback interface to be notified when a connection is made or lost.
-     * @param flags         Flags used for binding to the service
+     * @param flags         Flags used for binding to the service. Currently only
+     *                     {@link Context#BIND_AUTO_CREATE} and
+     *                     {@link Context#BIND_FOREGROUND_SERVICE_WHILE_AWAKE} are supported.
      *
      * @see Context#getServiceDispatcher(ServiceConnection, Handler, int)
      * @hide
",3,1,
152,82e4c08288424015d447681815554397cf793a1e,AppWidgetServiceImpl.java,"@@ -1199,11 +1199,12 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku
             try {
                 // Ask ActivityManager to bind it. Notice that we are binding the service with the
                 // caller app instead of DevicePolicyManagerService.
-                if(ActivityManager.getService().bindService(
+                if (ActivityManager.getService().bindService(
                         caller, activtiyToken, intent,
                         intent.resolveTypeIfNeeded(mContext.getContentResolver()),
-                        connection, flags, mContext.getOpPackageName(),
-                        widget.provider.getUserId()) != 0) {
+                        connection, flags & (Context.BIND_AUTO_CREATE
+                                | Context.BIND_FOREGROUND_SERVICE_WHILE_AWAKE),
+                        mContext.getOpPackageName(), widget.provider.getUserId()) != 0) {
 
                     // Add it to the mapping of RemoteViewsService to appWidgetIds so that we
                     // can determine when we can call back to the RemoteViewsService later to
",4,3,AppWidgetServiceImpl::bindRemoteViewsService
153,67b29ab4020e94c433391aedc23d8457f79fe40b,ResetTargetTaskHelper.java,"@@ -146,15 +146,16 @@ class ResetTargetTaskHelper {
             return false;
 
         } else {
-            mResultActivities.add(r);
             if (r.resultTo != null) {
                 // If this activity is sending a reply to a previous activity, we can't do
                 // anything with it now until we reach the start of the reply chain.
                 // NOTE: that we are assuming the result is always to the previous activity,
                 // which is almost always the case but we really shouldn't count on.
+                mResultActivities.add(r);
                 return false;
             } else if (mTargetTaskFound && allowTaskReparenting && mTargetTask.affinity != null
                     && mTargetTask.affinity.equals(r.taskAffinity)) {
+                mResultActivities.add(r);
                 // This activity has an affinity for our task. Either remove it if we are
                 // clearing or move it over to our task. Note that we currently punt on the case
                 // where we are resetting a task that is not at the top but who has activities
",2,1,ResetTargetTaskHelper::processActivity
154,a8afb70ebc208f6e6a285e83cf44b53202a7869e,NotificationShadeWindowControllerImpl.java,"@@ -29,6 +29,7 @@ import android.content.pm.ActivityInfo;
 import android.database.ContentObserver;
 import android.graphics.PixelFormat;
 import android.os.Binder;
+import android.os.Build;
 import android.os.Handler;
 import android.os.RemoteException;
 import android.os.Trace;
@@ -343,6 +344,16 @@ public class NotificationShadeWindowControllerImpl implements NotificationShadeW
             Trace.setCounter(""display_max_refresh_rate"",
                     (long) mLpChanged.preferredMaxDisplayRefreshRate);
         }
+
+        if (state.mBouncerShowing && !isDebuggable()) {
+            mLpChanged.flags |= LayoutParams.FLAG_SECURE;
+        } else {
+            mLpChanged.flags &= ~LayoutParams.FLAG_SECURE;
+        }
+    }
+
+    protected boolean isDebuggable() {
+        return Build.IS_DEBUGGABLE;
     }
 
     private void adjustScreenOrientation(State state) {
",11,0,"NotificationShadeWindowControllerImpl::applyKeyguardFlags, NotificationShadeWindowControllerImpl::isDebuggable"
155,a8afb70ebc208f6e6a285e83cf44b53202a7869e,NotificationShadeWindowControllerImplTest.java,"@@ -18,6 +18,7 @@ package com.android.systemui.statusbar.phone;
 
 import static android.view.WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM;
 import static android.view.WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
+import static android.view.WindowManager.LayoutParams.FLAG_SECURE;
 import static android.view.WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER;
 
 import static com.google.common.truth.Truth.assertThat;
@@ -90,7 +91,12 @@ public class NotificationShadeWindowControllerImplTest extends SysuiTestCase {
                 mWindowManager, mActivityManager, mDozeParameters, mStatusBarStateController,
                 mConfigurationController, mKeyguardViewMediator, mKeyguardBypassController,
                 mColorExtractor, mDumpManager, mKeyguardStateController,
-                mUnlockedScreenOffAnimationController, mAuthController);
+                mUnlockedScreenOffAnimationController, mAuthController) {
+                    @Override
+                    protected boolean isDebuggable() {
+                        return false;
+                    }
+            };
         mNotificationShadeWindowController.setScrimsVisibilityListener((visibility) -> {});
         mNotificationShadeWindowController.setNotificationShadeView(mNotificationShadeWindowView);
 
@@ -239,4 +245,20 @@ public class NotificationShadeWindowControllerImplTest extends SysuiTestCase {
         });
         verify(mWindowManager).updateViewLayout(any(), any());
     }
+
+    @Test
+    public void setKeyguardShowing_enablesSecureFlag() {
+        mNotificationShadeWindowController.setBouncerShowing(true);
+
+        verify(mWindowManager).updateViewLayout(any(), mLayoutParameters.capture());
+        assertThat((mLayoutParameters.getValue().flags & FLAG_SECURE) != 0).isTrue();
+    }
+
+    @Test
+    public void setKeyguardNotShowing_disablesSecureFlag() {
+        mNotificationShadeWindowController.setBouncerShowing(false);
+
+        verify(mWindowManager).updateViewLayout(any(), mLayoutParameters.capture());
+        assertThat((mLayoutParameters.getValue().flags & FLAG_SECURE) == 0).isTrue();
+    }
 }
",23,1,"NotificationShadeWindowControllerImplTest::setUp, NotificationShadeWindowControllerImplTest::setKeyguardShowing_enablesSecureFlag, NotificationShadeWindowControllerImplTest::setKeyguardNotShowing_disablesSecureFlag"
156,ec5b5e1dfa1406a29e719430a3cd05a4f960f41a,EditUserPhotoController.java,"@@ -21,6 +21,8 @@ import android.content.ClipData;
 import android.content.ContentResolver;
 import android.content.Context;
 import android.content.Intent;
+import android.content.pm.PackageManager;
+import android.content.pm.ResolveInfo;
 import android.database.Cursor;
 import android.graphics.Bitmap;
 import android.graphics.Bitmap.Config;
@@ -83,6 +85,7 @@ public class EditUserPhotoController {
     private static final int DEFAULT_PHOTO_SIZE = 500;
 
     private static final String IMAGES_DIR = ""multi_user"";
+    private static final String PRE_CROP_PICTURE_FILE_NAME = ""PreCropEditUserPhoto.jpg"";
     private static final String CROP_PICTURE_FILE_NAME = ""CropEditUserPhoto.jpg"";
     private static final String TAKE_PICTURE_FILE_NAME = ""TakeEditUserPhoto.jpg"";
     private static final String NEW_USER_PHOTO_FILE_NAME = ""NewUserPhoto.png"";
@@ -95,6 +98,7 @@ public class EditUserPhotoController {
     private final String mFileAuthority;
 
     private final File mImagesDir;
+    private final Uri mPreCropPictureUri;
     private final Uri mCropPictureUri;
     private final Uri mTakePictureUri;
 
@@ -110,6 +114,7 @@ public class EditUserPhotoController {
 
         mImagesDir = new File(activity.getCacheDir(), IMAGES_DIR);
         mImagesDir.mkdir();
+        mPreCropPictureUri = createTempImageUri(activity, PRE_CROP_PICTURE_FILE_NAME, !waiting);
         mCropPictureUri = createTempImageUri(activity, CROP_PICTURE_FILE_NAME, !waiting);
         mTakePictureUri = createTempImageUri(activity, TAKE_PICTURE_FILE_NAME, !waiting);
         mPhotoSize = getPhotoSize(activity);
@@ -143,7 +148,7 @@ public class EditUserPhotoController {
             case REQUEST_CODE_CHOOSE_PHOTO:
                 if (mTakePictureUri.equals(pictureUri)) {
                     if (PhotoCapabilityUtils.canCropPhoto(mActivity)) {
-                        cropPhoto();
+                        cropPhoto(pictureUri);
                     } else {
                         onPhotoNotCropped(pictureUri);
                     }
@@ -224,7 +229,7 @@ public class EditUserPhotoController {
             protected Void doInBackground(Void... params) {
                 final ContentResolver cr = mActivity.getContentResolver();
                 try (InputStream in = cr.openInputStream(pictureUri);
-                     OutputStream out = cr.openOutputStream(mTakePictureUri)) {
+                        OutputStream out = cr.openOutputStream(mPreCropPictureUri)) {
                     Streams.copy(in, out);
                 } catch (IOException e) {
                     Log.w(TAG, ""Failed to copy photo"", e);
@@ -235,28 +240,41 @@ public class EditUserPhotoController {
             @Override
             protected void onPostExecute(Void result) {
                 if (!mActivity.isFinishing() && !mActivity.isDestroyed()) {
-                    cropPhoto();
+                    cropPhoto(mPreCropPictureUri);
                 }
             }
         }.execute();
     }
 
-    private void cropPhoto() {
+    private void cropPhoto(final Uri pictureUri) {
         // TODO: Use a public intent, when there is one.
         Intent intent = new Intent(""com.android.camera.action.CROP"");
-        intent.setDataAndType(mTakePictureUri, ""image/*"");
+        intent.setDataAndType(pictureUri, ""image/*"");
         appendOutputExtra(intent, mCropPictureUri);
         appendCropExtras(intent);
-        if (intent.resolveActivity(mActivity.getPackageManager()) != null) {
-            try {
-                StrictMode.disableDeathOnFileUriExposure();
-                mActivityStarter.startActivityForResult(intent, REQUEST_CODE_CROP_PHOTO);
-            } finally {
-                StrictMode.enableDeathOnFileUriExposure();
+        try {
+            StrictMode.disableDeathOnFileUriExposure();
+            if (startSystemActivityForResult(intent, REQUEST_CODE_CROP_PHOTO)) {
+                return;
             }
-        } else {
-            onPhotoNotCropped(mTakePictureUri);
+        } finally {
+            StrictMode.enableDeathOnFileUriExposure();
+        }
+
+        onPhotoNotCropped(mTakePictureUri);
+
+    }
+
+    private boolean startSystemActivityForResult(Intent intent, int code) {
+        List<ResolveInfo> resolveInfos = mActivity.getPackageManager()
+                .queryIntentActivities(intent, PackageManager.MATCH_SYSTEM_ONLY);
+        if (resolveInfos.isEmpty()) {
+            Log.w(TAG, ""No system package activity could be found for code "" + code);
+            return false;
         }
+        intent.setPackage(resolveInfos.get(0).activityInfo.packageName);
+        mActivityStarter.startActivityForResult(intent, code);
+        return true;
     }
 
     private void appendOutputExtra(Intent intent, Uri pictureUri) {
",31,13,"EditUserPhotoController::EditUserPhotoController, EditUserPhotoController::cropPhoto, EditUserPhotoController::cropPhoto, EditUserPhotoController::onActivityResult, EditUserPhotoController::startSystemActivityForResult, EditUserPhotoController::copyAndCropPhoto"
157,a0024d7805bc14fa7371124e9c9650df82be2513,ShortcutPackage.java,"@@ -1967,10 +1967,15 @@ class ShortcutPackage extends ShortcutPackageItem {
 
                         continue;
                     case TAG_SHORTCUT:
-                        final ShortcutInfo si = parseShortcut(parser, packageName,
-                                shortcutUser.getUserId(), fromBackup);
-                        // Don't use addShortcut(), we don't need to save the icon.
-                        ret.mShortcuts.put(si.getId(), si);
+                        try {
+                            final ShortcutInfo si = parseShortcut(parser, packageName,
+                                    shortcutUser.getUserId(), fromBackup);
+                            // Don't use addShortcut(), we don't need to save the icon.
+                            ret.mShortcuts.put(si.getId(), si);
+                        } catch (Exception e) {
+                            // b/246540168 malformed shortcuts should be ignored
+                            Slog.e(TAG, ""Failed parsing shortcut."", e);
+                        }
                         continue;
                     case TAG_SHARE_TARGET:
                         ret.mShareTargets.add(ShareTargetInfo.loadFromXml(parser));
",9,4,ShortcutPackage::loadFromXml
158,2d54a3bf75eae8280ffa37e6435d9dcdffcbc6a2,PreferencesHelper.java,"@@ -97,7 +97,7 @@ public class PreferencesHelper implements RankingConfig {
     private static final String NON_BLOCKABLE_CHANNEL_DELIM = "":"";
 
     @VisibleForTesting
-    static final int NOTIFICATION_CHANNEL_COUNT_LIMIT = 50000;
+    static final int NOTIFICATION_CHANNEL_COUNT_LIMIT = 5000;
 
     private static final int NOTIFICATION_PREFERENCES_PULL_LIMIT = 1000;
     private static final int NOTIFICATION_CHANNEL_PULL_LIMIT = 2000;
",1,1,
159,1aa63338540fb0ada2b87ae7bbcdecd5d8bc08fc,PackageManagerService.java,"@@ -24250,6 +24250,9 @@ public class PackageManagerService extends IPackageManager.Stub
                     } else {
                         Slog.w(TAG, ""Failed setComponentEnabledSetting: component class ""
                                 + className + "" does not exist in "" + packageName);
+                        // Safetynet logging for b/240936919
+                        EventLog.writeEvent(0x534e4554, ""240936919"", callingUid);
+                        return;
                     }
                 }
                 switch (newState) {
",3,0,PackageManagerService::setEnabledSetting
160,8565487dae2587227a32526de58b4b2898100bbe,AccountManagerService.java,"@@ -88,6 +88,7 @@ import android.os.UserHandle;
 import android.os.UserManager;
 import android.stats.devicepolicy.DevicePolicyEnums;
 import android.text.TextUtils;
+import android.util.EventLog;
 import android.util.Log;
 import android.util.Pair;
 import android.util.Slog;
@@ -3097,7 +3098,7 @@ public class AccountManagerService
                              */
                             if (!checkKeyIntent(
                                     Binder.getCallingUid(),
-                                    intent)) {
+                                    result)) {
                                 onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,
                                         ""invalid intent in bundle returned"");
                                 return;
@@ -3516,7 +3517,7 @@ public class AccountManagerService
                     && (intent = result.getParcelable(AccountManager.KEY_INTENT)) != null) {
                 if (!checkKeyIntent(
                         Binder.getCallingUid(),
-                        intent)) {
+                        result)) {
                     onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,
                             ""invalid intent in bundle returned"");
                     return;
@@ -4867,7 +4868,13 @@ public class AccountManagerService
          * into launching arbitrary intents on the device via by tricking to click authenticator
          * supplied entries in the system Settings app.
          */
-         protected boolean checkKeyIntent(int authUid, Intent intent) {
+        protected boolean checkKeyIntent(int authUid, Bundle bundle) {
+            if (!checkKeyIntentParceledCorrectly(bundle)) {
+            	EventLog.writeEvent(0x534e4554, ""250588548"", authUid, """");
+                return false;
+            }
+
+            Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT);
             // Explicitly set an empty ClipData to ensure that we don't offer to
             // promote any Uris contained inside for granting purposes
             if (intent.getClipData() == null) {
@@ -4904,6 +4911,25 @@ public class AccountManagerService
             }
         }
 
+        /**
+         * Simulate the client side's deserialization of KEY_INTENT value, to make sure they don't
+         * violate our security policy.
+         *
+         * In particular we want to make sure the Authenticator doesn't trick users
+         * into launching arbitrary intents on the device via exploiting any other Parcel read/write
+         * mismatch problems.
+         */
+        private boolean checkKeyIntentParceledCorrectly(Bundle bundle) {
+            Parcel p = Parcel.obtain();
+            p.writeBundle(bundle);
+            p.setDataPosition(0);
+            Bundle simulateBundle = p.readBundle();
+            p.recycle();
+            Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT);
+            Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT);
+            return (intent.filterEquals(simulateIntent));
+        }
+
         private boolean isExportedSystemActivity(ActivityInfo activityInfo) {
             String className = activityInfo.name;
             return ""android"".equals(activityInfo.packageName) &&
@@ -5050,7 +5076,7 @@ public class AccountManagerService
                     && (intent = result.getParcelable(AccountManager.KEY_INTENT)) != null) {
                 if (!checkKeyIntent(
                         Binder.getCallingUid(),
-                        intent)) {
+                        result)) {
                     onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,
                             ""invalid intent in bundle returned"");
                     return;
",30,4,"AccountManagerService::StartAccountSession::onResult, AccountManagerService::getAuthToken, AccountManagerService::Session::checkKeyIntent, AccountManagerService::Session::checkKeyIntentParceledCorrectly, AccountManagerService::Session::checkKeyIntent, AccountManagerService::Session::onResult"
161,1c5e4928dcfb254c0204f78c60ecfe6b219a852d,UserManagerService.java,"@@ -88,6 +88,7 @@ import android.stats.devicepolicy.DevicePolicyEnums;
 import android.util.ArrayMap;
 import android.util.ArraySet;
 import android.util.AtomicFile;
+import android.util.EventLog;
 import android.util.IndentingPrintWriter;
 import android.util.IntArray;
 import android.util.Slog;
@@ -4499,6 +4500,13 @@ public class UserManagerService extends IUserManager.Stub {
     public void setApplicationRestrictions(String packageName, Bundle restrictions,
             @UserIdInt int userId) {
         checkSystemOrRoot(""set application restrictions"");
+        String validationResult = validateName(packageName);
+        if (validationResult != null) {
+            if (packageName.contains(""../"")) {
+                EventLog.writeEvent(0x534e4554, ""239701237"", -1, """");
+            }
+            throw new IllegalArgumentException(""Invalid package name: "" + validationResult);
+        }
         if (restrictions != null) {
             restrictions.setDefusable(true);
         }
@@ -4525,6 +4533,39 @@ public class UserManagerService extends IUserManager.Stub {
         mContext.sendBroadcastAsUser(changeIntent, UserHandle.of(userId));
     }
 
+    /**
+     * Check if the given name is valid.
+     *
+     * Note: the logic is taken from FrameworkParsingPackageUtils in master, edited to remove
+     * unnecessary parts. Copied here for a security fix.
+     *
+     * @param name The name to check.
+     * @return null if it's valid, error message if not
+     */
+    @VisibleForTesting
+    static String validateName(String name) {
+        final int n = name.length();
+        boolean front = true;
+        for (int i = 0; i < n; i++) {
+            final char c = name.charAt(i);
+            if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) {
+                front = false;
+                continue;
+            }
+            if (!front) {
+                if ((c >= '0' && c <= '9') || c == '_') {
+                    continue;
+                }
+                if (c == '.') {
+                    front = true;
+                    continue;
+                }
+            }
+            return ""bad character '"" + c + ""'"";
+        }
+        return null;
+    }
+
     private int getUidForPackage(String packageName) {
         final long ident = Binder.clearCallingIdentity();
         try {
",41,0,"UserManagerService::validateName, UserManagerService::setApplicationRestrictions"
162,1c5e4928dcfb254c0204f78c60ecfe6b219a852d,UserManagerServiceTest.java,"@@ -86,6 +86,13 @@ public class UserManagerServiceTest extends AndroidTestCase {
         }
     }
 
+    public void testValidateName() {
+        assertNull(UserManagerService.validateName(""android""));
+        assertNull(UserManagerService.validateName(""com.company.myapp""));
+        assertNotNull(UserManagerService.validateName(""/../../data""));
+        assertNotNull(UserManagerService.validateName(""/dir""));
+    }
+
     private Bundle createBundle() {
         Bundle result = new Bundle();
         // Tests for 6 allowed types: Integer, Boolean, String, String[], Bundle and Parcelable[]
",7,0,UserManagerServiceTest::testValidateName
163,1832677b9a1dfd01c424b6d9090b6cf6183652b5,NotificationManagerService.java,"@@ -4812,16 +4812,7 @@ public class NotificationManagerService extends SystemService {
             }
             enforcePolicyAccess(Binder.getCallingUid(), ""addAutomaticZenRule"");
 
-            // If the caller is system, take the package name from the rule's owner rather than
-            // from the caller's package.
-            String rulePkg = pkg;
-            if (isCallingUidSystem()) {
-                if (automaticZenRule.getOwner() != null) {
-                    rulePkg = automaticZenRule.getOwner().getPackageName();
-                }
-            }
-
-            return mZenModeHelper.addAutomaticZenRule(rulePkg, automaticZenRule,
+            return mZenModeHelper.addAutomaticZenRule(pkg, automaticZenRule,
                     ""addAutomaticZenRule"");
         }
 
",1,10,NotificationManagerService::Stub
164,1832677b9a1dfd01c424b6d9090b6cf6183652b5,NotificationManagerServiceTest.java,"@@ -6748,43 +6748,6 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {
         mBinderService.addAutomaticZenRule(rule, mContext.getPackageName());
     }
 
-    @Test
-    public void testAddAutomaticZenRule_systemCallTakesPackageFromOwner() throws Exception {
-        mService.isSystemUid = true;
-        ZenModeHelper mockZenModeHelper = mock(ZenModeHelper.class);
-        when(mConditionProviders.isPackageOrComponentAllowed(anyString(), anyInt()))
-                .thenReturn(true);
-        mService.setZenHelper(mockZenModeHelper);
-        ComponentName owner = new ComponentName(""android"", ""ProviderName"");
-        ZenPolicy zenPolicy = new ZenPolicy.Builder().allowAlarms(true).build();
-        boolean isEnabled = true;
-        AutomaticZenRule rule = new AutomaticZenRule(""test"", owner, owner, mock(Uri.class),
-                zenPolicy, NotificationManager.INTERRUPTION_FILTER_PRIORITY, isEnabled);
-        mBinderService.addAutomaticZenRule(rule, ""com.android.settings"");
-
-        // verify that zen mode helper gets passed in a package name of ""android""
-        verify(mockZenModeHelper).addAutomaticZenRule(eq(""android""), eq(rule), anyString());
-    }
-
-    @Test
-    public void testAddAutomaticZenRule_nonSystemCallTakesPackageFromArg() throws Exception {
-        mService.isSystemUid = false;
-        ZenModeHelper mockZenModeHelper = mock(ZenModeHelper.class);
-        when(mConditionProviders.isPackageOrComponentAllowed(anyString(), anyInt()))
-                .thenReturn(true);
-        mService.setZenHelper(mockZenModeHelper);
-        ComponentName owner = new ComponentName(""android"", ""ProviderName"");
-        ZenPolicy zenPolicy = new ZenPolicy.Builder().allowAlarms(true).build();
-        boolean isEnabled = true;
-        AutomaticZenRule rule = new AutomaticZenRule(""test"", owner, owner, mock(Uri.class),
-                zenPolicy, NotificationManager.INTERRUPTION_FILTER_PRIORITY, isEnabled);
-        mBinderService.addAutomaticZenRule(rule, ""another.package"");
-
-        // verify that zen mode helper gets passed in the package name from the arg, not the owner
-        verify(mockZenModeHelper).addAutomaticZenRule(
-                eq(""another.package""), eq(rule), anyString());
-    }
-
     @Test
     public void testAreNotificationsEnabledForPackage_crossUser() throws Exception {
         try {
",0,37,"NotificationManagerServiceTest::testAddAutomaticZenRule_systemCallTakesPackageFromOwner, NotificationManagerServiceTest::testAddAutomaticZenRule_nonSystemCallTakesPackageFromArg"
165,44fa57d2ebaa9ae4c41f94d9889115671dc82438,ZenModeHelper.java,"@@ -310,7 +310,7 @@ public class ZenModeHelper {
 
     public String addAutomaticZenRule(String pkg, AutomaticZenRule automaticZenRule,
             String reason) {
-        if (!ZenModeConfig.SYSTEM_AUTHORITY.equals(pkg)) {
+        if (!isSystemRule(automaticZenRule)) {
             PackageItemInfo component = getServiceInfo(automaticZenRule.getOwner());
             if (component == null) {
                 component = getActivityInfo(automaticZenRule.getConfigurationActivity());
@@ -566,6 +566,11 @@ public class ZenModeHelper {
         }
     }
 
+    private boolean isSystemRule(AutomaticZenRule rule) {
+        return rule.getOwner() != null
+                && ZenModeConfig.SYSTEM_AUTHORITY.equals(rule.getOwner().getPackageName());
+    }
+
     private ServiceInfo getServiceInfo(ComponentName owner) {
         Intent queryIntent = new Intent();
         queryIntent.setComponent(owner);
",6,1,"ZenModeHelper::addAutomaticZenRule, ZenModeHelper::isSystemRule"
166,44fa57d2ebaa9ae4c41f94d9889115671dc82438,ZenModeHelperTest.java,"@@ -1667,36 +1667,6 @@ public class ZenModeHelperTest extends UiServiceTestCase {
         }
     }
 
-    @Test
-    public void testAddAutomaticZenRule_claimedSystemOwner() {
-        // Make sure anything that claims to have a ""system"" owner but not actually part of the
-        // system package still gets limited on number of rules
-        for (int i = 0; i < RULE_LIMIT_PER_PACKAGE; i++) {
-            ScheduleInfo si = new ScheduleInfo();
-            si.startHour = i;
-            AutomaticZenRule zenRule = new AutomaticZenRule(""name"" + i,
-                    new ComponentName(""android"", ""ScheduleConditionProvider"" + i),
-                    null, // configuration activity
-                    ZenModeConfig.toScheduleConditionId(si),
-                    new ZenPolicy.Builder().build(),
-                    NotificationManager.INTERRUPTION_FILTER_PRIORITY, true);
-            String id = mZenModeHelperSpy.addAutomaticZenRule(""pkgname"", zenRule, ""test"");
-            assertNotNull(id);
-        }
-        try {
-            AutomaticZenRule zenRule = new AutomaticZenRule(""name"",
-                    new ComponentName(""android"", ""ScheduleConditionProviderFinal""),
-                    null, // configuration activity
-                    ZenModeConfig.toScheduleConditionId(new ScheduleInfo()),
-                    new ZenPolicy.Builder().build(),
-                    NotificationManager.INTERRUPTION_FILTER_PRIORITY, true);
-            String id = mZenModeHelperSpy.addAutomaticZenRule(""pkgname"", zenRule, ""test"");
-            fail(""allowed too many rules to be created"");
-        } catch (IllegalArgumentException e) {
-            // yay
-        }
-    }
-
     @Test
     public void testAddAutomaticZenRule_CA() {
         AutomaticZenRule zenRule = new AutomaticZenRule(""name"",
",0,30,ZenModeHelperTest::testAddAutomaticZenRule_claimedSystemOwner
167,2a05a951ba34fa2b690a676dcd5744716c27499c,ParsingPackageImpl.java,"@@ -1695,6 +1695,9 @@ public class ParsingPackageImpl implements ParsingPackage, Parcelable {
         for (int i = component.getIntents().size() - 1; i >= 0; i--) {
             IntentFilter filter = component.getIntents().get(i);
             for (int groupIndex = filter.countMimeGroups() - 1; groupIndex >= 0; groupIndex--) {
+                if (mimeGroups != null && mimeGroups.size() > 500) {
+                    throw new IllegalStateException(""Max limit on number of MIME Groups reached"");
+                }
                 mimeGroups = ArrayUtils.add(mimeGroups, filter.getMimeGroup(groupIndex));
             }
         }
",3,0,ParsingPackageImpl::addMimeGroupsFromComponent
168,2a05a951ba34fa2b690a676dcd5744716c27499c,PackageSetting.java,"@@ -328,11 +328,20 @@ public class PackageSetting extends PackageSettingBase {
     }
 
     public boolean setMimeGroup(String mimeGroup, List<String> mimeTypes) {
+        for (String mimeType : mimeTypes) {
+            if (mimeType.length() > 255) {
+                throw new IllegalArgumentException(""MIME type length exceeds 255 characters"");
+            }
+        }
         ArraySet<String> oldMimeTypes = getMimeGroupInternal(mimeGroup);
         if (oldMimeTypes == null) {
             throw new IllegalArgumentException(""Unknown MIME group "" + mimeGroup
                     + "" for package "" + name);
         }
+        if (mimeTypes.size() > 500) {
+            throw new IllegalStateException(""Max limit on MIME types for MIME group ""
+                    + mimeGroup + "" exceeded for package "" + name);
+        }
 
         ArraySet<String> newMimeTypes = new ArraySet<>(mimeTypes);
         boolean hasChanges = !newMimeTypes.equals(oldMimeTypes);
",9,0,PackageSetting::setMimeGroup
169,f30e24fbc849472d74b7a600a83881a23196667f,AccessibilityManagerService.java,"@@ -506,25 +506,27 @@ public class AccessibilityManagerService extends IAccessibilityManager.Stub
                     userState.mBindingServices.removeIf(filter);
                     userState.mCrashedServices.removeIf(filter);
                     final Iterator<ComponentName> it = userState.mEnabledServices.iterator();
+                    boolean anyServiceRemoved = false;
                     while (it.hasNext()) {
                         final ComponentName comp = it.next();
                         final String compPkg = comp.getPackageName();
                         if (compPkg.equals(packageName)) {
                             it.remove();
-                            // Update the enabled services setting.
-                            persistComponentNamesToSettingLocked(
-                                    Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES,
-                                    userState.mEnabledServices, userId);
-                            // Update the touch exploration granted services setting.
                             userState.mTouchExplorationGrantedServices.remove(comp);
-                            persistComponentNamesToSettingLocked(
-                                    Settings.Secure.
-                                    TOUCH_EXPLORATION_GRANTED_ACCESSIBILITY_SERVICES,
-                                    userState.mTouchExplorationGrantedServices, userId);
-                            onUserStateChangedLocked(userState);
-                            return;
+                            anyServiceRemoved = true;
                         }
                     }
+                    if (anyServiceRemoved) {
+                        // Update the enabled services setting.
+                        persistComponentNamesToSettingLocked(
+                                Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES,
+                                userState.mEnabledServices, userId);
+                        // Update the touch exploration granted services setting.
+                        persistComponentNamesToSettingLocked(
+                                Settings.Secure.TOUCH_EXPLORATION_GRANTED_ACCESSIBILITY_SERVICES,
+                                userState.mTouchExplorationGrantedServices, userId);
+                        onUserStateChangedLocked(userState);
+                    }
                 }
             }
 
",13,11,AccessibilityManagerService::registerBroadcastReceivers
170,19702ea591fc2fe045ed9366127e5d824bfba474,AutomaticZenRule.java,"@@ -125,7 +125,7 @@ public final class AutomaticZenRule implements Parcelable {
             name = getTrimmedString(source.readString());
         }
         interruptionFilter = source.readInt();
-        conditionId = source.readParcelable(null);
+        conditionId = getTrimmedUri(source.readParcelable(null));
         owner = getTrimmedComponentName(source.readParcelable(null));
         configurationActivity = getTrimmedComponentName(source.readParcelable(null));
         creationTime = source.readLong();
",1,1,AutomaticZenRule::AutomaticZenRule
171,d10614e8de0f69aae3abbcb9439606305696286a,SettingsState.java,"@@ -375,9 +375,11 @@ final class SettingsState {
             Setting newSetting = new Setting(name, oldSetting.getValue(), null,
                     oldSetting.getPackageName(), oldSetting.getTag(), false,
                     oldSetting.getId());
-            mSettings.put(name, newSetting);
-            updateMemoryUsagePerPackageLocked(newSetting.getPackageName(), oldValue,
+            int newSize = getNewMemoryUsagePerPackageLocked(newSetting.getPackageName(), oldValue,
                     newSetting.getValue(), oldDefaultValue, newSetting.getDefaultValue());
+            checkNewMemoryUsagePerPackageLocked(newSetting.getPackageName(), newSize);
+            mSettings.put(name, newSetting);
+            updateMemoryUsagePerPackageLocked(newSetting.getPackageName(), newSize);
             scheduleWriteIfNeededLocked();
         }
     }
@@ -410,6 +412,12 @@ final class SettingsState {
         Setting oldState = mSettings.get(name);
         String oldValue = (oldState != null) ? oldState.value : null;
         String oldDefaultValue = (oldState != null) ? oldState.defaultValue : null;
+        String newDefaultValue = makeDefault ? value : oldDefaultValue;
+
+        int newSize = getNewMemoryUsagePerPackageLocked(packageName, oldValue, value,
+                oldDefaultValue, newDefaultValue);
+        checkNewMemoryUsagePerPackageLocked(packageName, newSize);
+
         Setting newState;
 
         if (oldState != null) {
@@ -430,8 +438,7 @@ final class SettingsState {
 
         addHistoricalOperationLocked(HISTORICAL_OPERATION_UPDATE, newState);
 
-        updateMemoryUsagePerPackageLocked(packageName, oldValue, value,
-                oldDefaultValue, newState.getDefaultValue());
+        updateMemoryUsagePerPackageLocked(packageName, newSize);
 
         scheduleWriteIfNeededLocked();
 
@@ -552,13 +559,14 @@ final class SettingsState {
         }
 
         Setting oldState = mSettings.remove(name);
+        int newSize = getNewMemoryUsagePerPackageLocked(oldState.packageName, oldState.value,
+                null, oldState.defaultValue, null);
 
         FrameworkStatsLog.write(FrameworkStatsLog.SETTING_CHANGED, name, /* value= */ """",
                 /* newValue= */ """", oldState.value, /* tag */ """", false, getUserIdFromKey(mKey),
                 FrameworkStatsLog.SETTING_CHANGED__REASON__DELETED);
 
-        updateMemoryUsagePerPackageLocked(oldState.packageName, oldState.value,
-                null, oldState.defaultValue, null);
+        updateMemoryUsagePerPackageLocked(oldState.packageName, newSize);
 
         addHistoricalOperationLocked(HISTORICAL_OPERATION_DELETE, oldState);
 
@@ -579,16 +587,18 @@ final class SettingsState {
         Setting oldSetting = new Setting(setting);
         String oldValue = setting.getValue();
         String oldDefaultValue = setting.getDefaultValue();
+        String newValue = oldDefaultValue;
+        String newDefaultValue = oldDefaultValue;
+
+        int newSize = getNewMemoryUsagePerPackageLocked(setting.packageName, oldValue,
+                newValue, oldDefaultValue, newDefaultValue);
+        checkNewMemoryUsagePerPackageLocked(setting.packageName, newSize);
 
         if (!setting.reset()) {
             return false;
         }
 
-        String newValue = setting.getValue();
-        String newDefaultValue = setting.getDefaultValue();
-
-        updateMemoryUsagePerPackageLocked(setting.packageName, oldValue,
-                newValue, oldDefaultValue, newDefaultValue);
+        updateMemoryUsagePerPackageLocked(setting.packageName, newSize);
 
         addHistoricalOperationLocked(HISTORICAL_OPERATION_RESET, oldSetting);
 
@@ -696,38 +706,49 @@ final class SettingsState {
     }
 
     @GuardedBy(""mLock"")
-    private void updateMemoryUsagePerPackageLocked(String packageName, String oldValue,
-            String newValue, String oldDefaultValue, String newDefaultValue) {
-        if (mMaxBytesPerAppPackage == MAX_BYTES_PER_APP_PACKAGE_UNLIMITED) {
-            return;
-        }
+    private boolean isExemptFromMemoryUsageCap(String packageName) {
+        return mMaxBytesPerAppPackage == MAX_BYTES_PER_APP_PACKAGE_UNLIMITED
+                || SYSTEM_PACKAGE_NAME.equals(packageName);
+    }
 
-        if (SYSTEM_PACKAGE_NAME.equals(packageName)) {
+    @GuardedBy(""mLock"")
+    private void checkNewMemoryUsagePerPackageLocked(String packageName, int newSize)
+            throws IllegalStateException {
+        if (isExemptFromMemoryUsageCap(packageName)) {
             return;
         }
+        if (newSize > mMaxBytesPerAppPackage) {
+            throw new IllegalStateException(""You are adding too many system settings. ""
+                    + ""You should stop using system settings for app specific data""
+                    + "" package: "" + packageName);
+        }
+    }
 
+    @GuardedBy(""mLock"")
+    private int getNewMemoryUsagePerPackageLocked(String packageName, String oldValue,
+            String newValue, String oldDefaultValue, String newDefaultValue) {
+        if (isExemptFromMemoryUsageCap(packageName)) {
+            return 0;
+        }
+        final Integer currentSize = mPackageToMemoryUsage.get(packageName);
         final int oldValueSize = (oldValue != null) ? oldValue.length() : 0;
         final int newValueSize = (newValue != null) ? newValue.length() : 0;
         final int oldDefaultValueSize = (oldDefaultValue != null) ? oldDefaultValue.length() : 0;
         final int newDefaultValueSize = (newDefaultValue != null) ? newDefaultValue.length() : 0;
         final int deltaSize = newValueSize + newDefaultValueSize
                 - oldValueSize - oldDefaultValueSize;
+        return Math.max((currentSize != null) ? currentSize + deltaSize : deltaSize, 0);
+    }
 
-        Integer currentSize = mPackageToMemoryUsage.get(packageName);
-        final int newSize = Math.max((currentSize != null)
-                ? currentSize + deltaSize : deltaSize, 0);
-
-        if (newSize > mMaxBytesPerAppPackage) {
-            throw new IllegalStateException(""You are adding too many system settings. ""
-                    + ""You should stop using system settings for app specific data""
-                    + "" package: "" + packageName);
+    @GuardedBy(""mLock"")
+    private void updateMemoryUsagePerPackageLocked(String packageName, int newSize) {
+        if (isExemptFromMemoryUsageCap(packageName)) {
+            return;
         }
-
         if (DEBUG) {
             Slog.i(LOG_TAG, ""Settings for package: "" + packageName
                     + "" size: "" + newSize + "" bytes."");
         }
-
         mPackageToMemoryUsage.put(packageName, newSize);
     }
 
",48,27,"SettingsState::updateMemoryUsagePerPackageLocked, SettingsState::deleteSettingLocked, SettingsState::resetSettingLocked, SettingsState::updateMemoryUsagePerPackageLocked, SettingsState::resetSettingDefaultValueLocked, SettingsState::insertSettingLocked, SettingsState::getNewMemoryUsagePerPackageLocked, SettingsState::checkNewMemoryUsagePerPackageLocked, SettingsState::isExemptFromMemoryUsageCap"
172,d10614e8de0f69aae3abbcb9439606305696286a,SettingsStateTest.java,"@@ -20,6 +20,8 @@ import android.test.AndroidTestCase;
 import android.util.TypedXmlSerializer;
 import android.util.Xml;
 
+import com.google.common.base.Strings;
+
 import java.io.ByteArrayOutputStream;
 import java.io.File;
 import java.io.FileOutputStream;
@@ -276,4 +278,40 @@ public class SettingsStateTest extends AndroidTestCase {
         settingsState.setVersionLocked(SettingsState.SETTINGS_VERSION_NEW_ENCODING);
         return settingsState;
     }
+
+    public void testInsertSetting_memoryUsage() {
+        SettingsState settingsState = new SettingsState(getContext(), mLock, mSettingsFile, 1,
+                SettingsState.MAX_BYTES_PER_APP_PACKAGE_UNLIMITED, Looper.getMainLooper());
+        // No exception should be thrown when there is no cap
+        settingsState.insertSettingLocked(SETTING_NAME, Strings.repeat(""A"", 20001),
+                null, false, ""p1"");
+        settingsState.deleteSettingLocked(SETTING_NAME);
+
+        settingsState = new SettingsState(getContext(), mLock, mSettingsFile, 1,
+                SettingsState.MAX_BYTES_PER_APP_PACKAGE_LIMITED, Looper.getMainLooper());
+        // System package doesn't have memory usage limit
+        settingsState.insertSettingLocked(SETTING_NAME, Strings.repeat(""A"", 20001),
+                null, false, SYSTEM_PACKAGE);
+        settingsState.deleteSettingLocked(SETTING_NAME);
+
+        // Should not throw if usage is under the cap
+        settingsState.insertSettingLocked(SETTING_NAME, Strings.repeat(""A"", 19999),
+                null, false, ""p1"");
+        settingsState.deleteSettingLocked(SETTING_NAME);
+        try {
+            settingsState.insertSettingLocked(SETTING_NAME, Strings.repeat(""A"", 20001),
+                    null, false, ""p1"");
+            fail(""Should throw because it exceeded per package memory usage"");
+        } catch (IllegalStateException ex) {
+            assertTrue(ex.getMessage().contains(""p1""));
+        }
+        try {
+            settingsState.insertSettingLocked(SETTING_NAME, Strings.repeat(""A"", 20001),
+                    null, false, ""p1"");
+            fail(""Should throw because it exceeded per package memory usage"");
+        } catch (IllegalStateException ex) {
+            assertTrue(ex.getMessage().contains(""p1""));
+        }
+        assertTrue(settingsState.getSettingLocked(SETTING_NAME).isNull());
+    }
 }
",38,0,SettingsStateTest::testInsertSetting_memoryUsage
173,33c13c17865d57cb5e55f301ae8eaa7fdf5b8f9c,LauncherApps.java,"@@ -752,7 +752,8 @@ public class LauncherApps {
         }
         try {
             // due to b/209607104, startActivityOptions will be ignored
-            return mService.getActivityLaunchIntent(component, null /* opts */, user);
+            return mService.getActivityLaunchIntent(mContext.getPackageName(), component,
+                    null /* opts */, user);
         } catch (RemoteException re) {
             throw re.rethrowFromSystemServer();
         }
",2,1,LauncherApps::getMainActivityLaunchIntent
174,33c13c17865d57cb5e55f301ae8eaa7fdf5b8f9c,LauncherAppsService.java,"@@ -1098,8 +1098,9 @@ public class LauncherAppsService extends SystemService {
         }
 
         @Override
-        public PendingIntent getActivityLaunchIntent(ComponentName component, Bundle opts,
-                UserHandle user) {
+        public PendingIntent getActivityLaunchIntent(String callingPackage, ComponentName component,
+                Bundle opts, UserHandle user) {
+            ensureShortcutPermission(callingPackage);
             if (!canAccessProfile(user.getIdentifier(), ""Cannot start activity"")) {
                 throw new ActivityNotFoundException(""Activity could not be found"");
             }
",3,2,"LauncherAppsService::LauncherAppsImpl::getActivityLaunchIntent, LauncherAppsService::LauncherAppsImpl::getActivityLaunchIntent"
175,53ece2aea297fb9a5c78a7bffaf3dad485908736,PermissionManagerService.java,"@@ -657,8 +657,8 @@ public class PermissionManagerService extends IPermissionManager.Stub {
             Permission bp = mRegistry.getPermission(info.name);
             added = bp == null;
             int fixedLevel = PermissionInfo.fixProtectionLevel(info.protectionLevel);
+            enforcePermissionCapLocked(info, tree);
             if (added) {
-                enforcePermissionCapLocked(info, tree);
                 bp = new Permission(info.name, tree.getPackageName(), Permission.TYPE_DYNAMIC);
             } else if (!bp.isDynamic()) {
                 throw new SecurityException(""Not allowed to modify non-dynamic permission ""
",1,1,PermissionManagerService::addPermission
176,14bf3cb0902a769dcf700e6c1f596f5c1d5eefe6,SettingsState.java,"@@ -47,6 +47,7 @@ import android.util.Xml;
 import android.util.proto.ProtoOutputStream;
 
 import com.android.internal.annotations.GuardedBy;
+import com.android.internal.annotations.VisibleForTesting;
 import com.android.internal.util.FrameworkStatsLog;
 
 import libcore.io.IoUtils;
@@ -375,8 +376,8 @@ final class SettingsState {
             Setting newSetting = new Setting(name, oldSetting.getValue(), null,
                     oldSetting.getPackageName(), oldSetting.getTag(), false,
                     oldSetting.getId());
-            int newSize = getNewMemoryUsagePerPackageLocked(newSetting.getPackageName(), oldValue,
-                    newSetting.getValue(), oldDefaultValue, newSetting.getDefaultValue());
+            int newSize = getNewMemoryUsagePerPackageLocked(newSetting.getPackageName(), 0,
+                    oldValue, newSetting.getValue(), oldDefaultValue, newSetting.getDefaultValue());
             checkNewMemoryUsagePerPackageLocked(newSetting.getPackageName(), newSize);
             mSettings.put(name, newSetting);
             updateMemoryUsagePerPackageLocked(newSetting.getPackageName(), newSize);
@@ -414,8 +415,9 @@ final class SettingsState {
         String oldDefaultValue = (oldState != null) ? oldState.defaultValue : null;
         String newDefaultValue = makeDefault ? value : oldDefaultValue;
 
-        int newSize = getNewMemoryUsagePerPackageLocked(packageName, oldValue, value,
-                oldDefaultValue, newDefaultValue);
+        int newSize = getNewMemoryUsagePerPackageLocked(packageName,
+                oldValue == null ? name.length() : 0 /* deltaKeySize */,
+                oldValue, value, oldDefaultValue, newDefaultValue);
         checkNewMemoryUsagePerPackageLocked(packageName, newSize);
 
         Setting newState;
@@ -559,8 +561,12 @@ final class SettingsState {
         }
 
         Setting oldState = mSettings.remove(name);
-        int newSize = getNewMemoryUsagePerPackageLocked(oldState.packageName, oldState.value,
-                null, oldState.defaultValue, null);
+        if (oldState == null) {
+            return false;
+        }
+        int newSize = getNewMemoryUsagePerPackageLocked(oldState.packageName,
+                -name.length() /* deltaKeySize */,
+                oldState.value, null, oldState.defaultValue, null);
 
         FrameworkStatsLog.write(FrameworkStatsLog.SETTING_CHANGED, name, /* value= */ """",
                 /* newValue= */ """", oldState.value, /* tag */ """", false, getUserIdFromKey(mKey),
@@ -583,15 +589,16 @@ final class SettingsState {
         }
 
         Setting setting = mSettings.get(name);
+        if (setting == null) {
+            return false;
+        }
 
         Setting oldSetting = new Setting(setting);
         String oldValue = setting.getValue();
         String oldDefaultValue = setting.getDefaultValue();
-        String newValue = oldDefaultValue;
-        String newDefaultValue = oldDefaultValue;
 
-        int newSize = getNewMemoryUsagePerPackageLocked(setting.packageName, oldValue,
-                newValue, oldDefaultValue, newDefaultValue);
+        int newSize = getNewMemoryUsagePerPackageLocked(setting.packageName, 0, oldValue,
+                oldDefaultValue, oldDefaultValue, oldDefaultValue);
         checkNewMemoryUsagePerPackageLocked(setting.packageName, newSize);
 
         if (!setting.reset()) {
@@ -725,8 +732,8 @@ final class SettingsState {
     }
 
     @GuardedBy(""mLock"")
-    private int getNewMemoryUsagePerPackageLocked(String packageName, String oldValue,
-            String newValue, String oldDefaultValue, String newDefaultValue) {
+    private int getNewMemoryUsagePerPackageLocked(String packageName, int deltaKeySize,
+            String oldValue, String newValue, String oldDefaultValue, String newDefaultValue) {
         if (isExemptFromMemoryUsageCap(packageName)) {
             return 0;
         }
@@ -735,7 +742,7 @@ final class SettingsState {
         final int newValueSize = (newValue != null) ? newValue.length() : 0;
         final int oldDefaultValueSize = (oldDefaultValue != null) ? oldDefaultValue.length() : 0;
         final int newDefaultValueSize = (newDefaultValue != null) ? newDefaultValue.length() : 0;
-        final int deltaSize = newValueSize + newDefaultValueSize
+        final int deltaSize = deltaKeySize + newValueSize + newDefaultValueSize
                 - oldValueSize - oldDefaultValueSize;
         return Math.max((currentSize != null) ? currentSize + deltaSize : deltaSize, 0);
     }
@@ -1556,4 +1563,11 @@ final class SettingsState {
         }
         return false;
     }
+
+    @VisibleForTesting
+    public int getMemoryUsage(String packageName) {
+        synchronized (mLock) {
+            return mPackageToMemoryUsage.getOrDefault(packageName, 0);
+        }
+    }
 }
",27,13,"SettingsState::deleteSettingLocked, SettingsState::resetSettingLocked, SettingsState::getMemoryUsage, SettingsState::getNewMemoryUsagePerPackageLocked, SettingsState::resetSettingDefaultValueLocked, SettingsState::insertSettingLocked, SettingsState::getNewMemoryUsagePerPackageLocked"
177,14bf3cb0902a769dcf700e6c1f596f5c1d5eefe6,SettingsStateTest.java,"@@ -295,7 +295,7 @@ public class SettingsStateTest extends AndroidTestCase {
         settingsState.deleteSettingLocked(SETTING_NAME);
 
         // Should not throw if usage is under the cap
-        settingsState.insertSettingLocked(SETTING_NAME, Strings.repeat(""A"", 19999),
+        settingsState.insertSettingLocked(SETTING_NAME, Strings.repeat(""A"", 19975),
                 null, false, ""p1"");
         settingsState.deleteSettingLocked(SETTING_NAME);
         try {
@@ -313,5 +313,97 @@ public class SettingsStateTest extends AndroidTestCase {
             assertTrue(ex.getMessage().contains(""p1""));
         }
         assertTrue(settingsState.getSettingLocked(SETTING_NAME).isNull());
+        try {
+            settingsState.insertSettingLocked(Strings.repeat(""A"", 20001), """",
+                    null, false, ""p1"");
+            fail(""Should throw because it exceeded per package memory usage"");
+        } catch (IllegalStateException ex) {
+            assertTrue(ex.getMessage().contains(""You are adding too many system settings""));
+        }
+    }
+
+    public void testMemoryUsagePerPackage() {
+        SettingsState settingsState = new SettingsState(getContext(), mLock, mSettingsFile, 1,
+                SettingsState.MAX_BYTES_PER_APP_PACKAGE_LIMITED, Looper.getMainLooper());
+
+        // Test inserting one key with default
+        final String testKey1 = SETTING_NAME;
+        final String testValue1 = Strings.repeat(""A"", 100);
+        settingsState.insertSettingLocked(testKey1, testValue1, null, true, TEST_PACKAGE);
+        int expectedMemUsage = testKey1.length() + testValue1.length()
+                + testValue1.length() /* size for default */;
+        assertEquals(expectedMemUsage, settingsState.getMemoryUsage(TEST_PACKAGE));
+
+        // Test inserting another key
+        final String testKey2 = SETTING_NAME + ""2"";
+        settingsState.insertSettingLocked(testKey2, testValue1, null, false, TEST_PACKAGE);
+        expectedMemUsage += testKey2.length() + testValue1.length();
+        assertEquals(expectedMemUsage, settingsState.getMemoryUsage(TEST_PACKAGE));
+
+        // Test updating first key with new default
+        final String testValue2 = Strings.repeat(""A"", 300);
+        settingsState.insertSettingLocked(testKey1, testValue2, null, true, TEST_PACKAGE);
+        expectedMemUsage += (testValue2.length() - testValue1.length()) * 2;
+        assertEquals(expectedMemUsage, settingsState.getMemoryUsage(TEST_PACKAGE));
+
+        // Test updating first key without new default
+        final String testValue3 = Strings.repeat(""A"", 50);
+        settingsState.insertSettingLocked(testKey1, testValue3, null, false, TEST_PACKAGE);
+        expectedMemUsage -= testValue2.length() - testValue3.length();
+        assertEquals(expectedMemUsage, settingsState.getMemoryUsage(TEST_PACKAGE));
+
+        // Test updating second key
+        settingsState.insertSettingLocked(testKey2, testValue2, null, false, TEST_PACKAGE);
+        expectedMemUsage -= testValue1.length() - testValue2.length();
+        assertEquals(expectedMemUsage, settingsState.getMemoryUsage(TEST_PACKAGE));
+
+        // Test resetting key
+        settingsState.resetSettingLocked(testKey1);
+        expectedMemUsage += testValue2.length() - testValue3.length();
+        assertEquals(expectedMemUsage, settingsState.getMemoryUsage(TEST_PACKAGE));
+
+        // Test resetting default value
+        settingsState.resetSettingDefaultValueLocked(testKey1);
+        expectedMemUsage -= testValue2.length();
+        assertEquals(expectedMemUsage, settingsState.getMemoryUsage(TEST_PACKAGE));
+
+        // Test deletion
+        settingsState.deleteSettingLocked(testKey2);
+        expectedMemUsage -= testValue2.length() + testKey2.length() /* key is deleted too */;
+        assertEquals(expectedMemUsage, settingsState.getMemoryUsage(TEST_PACKAGE));
+
+        // Test another package with a different key
+        final String testPackage2 = TEST_PACKAGE + ""2"";
+        final String testKey3 = SETTING_NAME + ""3"";
+        settingsState.insertSettingLocked(testKey3, testValue1, null, true, testPackage2);
+        assertEquals(expectedMemUsage, settingsState.getMemoryUsage(TEST_PACKAGE));
+        final int expectedMemUsage2 = testKey3.length() + testValue1.length() * 2;
+        assertEquals(expectedMemUsage2, settingsState.getMemoryUsage(testPackage2));
+
+        // Test system package
+        settingsState.insertSettingLocked(testKey1, testValue1, null, true, SYSTEM_PACKAGE);
+        assertEquals(expectedMemUsage, settingsState.getMemoryUsage(TEST_PACKAGE));
+        assertEquals(expectedMemUsage2, settingsState.getMemoryUsage(testPackage2));
+        assertEquals(0, settingsState.getMemoryUsage(SYSTEM_PACKAGE));
+
+        // Test invalid value
+        try {
+            settingsState.insertSettingLocked(testKey1, Strings.repeat(""A"", 20001), null, false,
+                    TEST_PACKAGE);
+            fail(""Should throw because it exceeded per package memory usage"");
+        } catch (IllegalStateException ex) {
+            assertTrue(ex.getMessage().contains(""You are adding too many system settings""));
+        }
+        assertEquals(expectedMemUsage, settingsState.getMemoryUsage(TEST_PACKAGE));
+
+        // Test invalid key
+        try {
+            settingsState.insertSettingLocked(Strings.repeat(""A"", 20001), """", null, false,
+                    TEST_PACKAGE);
+            fail(""Should throw because it exceeded per package memory usage"");
+        } catch (IllegalStateException ex) {
+            assertTrue(ex.getMessage().contains(""You are adding too many system settings""));
+        }
+        assertEquals(expectedMemUsage, settingsState.getMemoryUsage(TEST_PACKAGE));
     }
 }
",93,1,"SettingsStateTest::testMemoryUsagePerPackage, SettingsStateTest::testInsertSetting_memoryUsage"
178,b1dacbcb32d699c8e68ec630c25a457d9684ef03,AppTaskImpl.java,"@@ -84,7 +84,7 @@ class AppTaskImpl extends IAppTask.Stub {
                     throw new IllegalArgumentException(""Unable to find task ID "" + mTaskId);
                 }
                 return mService.getRecentTasks().createRecentTaskInfo(task,
-                        false /* stripExtras */);
+                        false /* stripExtras */, true /* getTasksAllowed */);
             } finally {
                 Binder.restoreCallingIdentity(origId);
             }
",1,1,AppTaskImpl::getTaskInfo
179,b1dacbcb32d699c8e68ec630c25a457d9684ef03,RecentTasks.java,"@@ -974,7 +974,7 @@ class RecentTasks {
                 continue;
             }
 
-            res.add(createRecentTaskInfo(task, true /* stripExtras */));
+            res.add(createRecentTaskInfo(task, true /* stripExtras */, getTasksAllowed));
         }
         return res;
     }
@@ -1890,7 +1890,8 @@ class RecentTasks {
     /**
      * Creates a new RecentTaskInfo from a Task.
      */
-    ActivityManager.RecentTaskInfo createRecentTaskInfo(Task tr, boolean stripExtras) {
+    ActivityManager.RecentTaskInfo createRecentTaskInfo(Task tr, boolean stripExtras,
+            boolean getTasksAllowed) {
         final ActivityManager.RecentTaskInfo rti = new ActivityManager.RecentTaskInfo();
         // If the recent Task is detached, we consider it will be re-attached to the default
         // TaskDisplayArea because we currently only support recent overview in the default TDA.
@@ -1902,6 +1903,9 @@ class RecentTasks {
         rti.id = rti.isRunning ? rti.taskId : INVALID_TASK_ID;
         rti.persistentId = rti.taskId;
         rti.lastSnapshotData.set(tr.mLastTaskSnapshotData);
+        if (!getTasksAllowed) {
+            Task.trimIneffectiveInfo(tr, rti);
+        }
 
         // Fill in organized child task info for the task created by organizer.
         if (tr.mCreatedByOrganizer) {
",6,2,"RecentTasks::createRecentTaskInfo, RecentTasks::createRecentTaskInfo, RecentTasks::getRecentTasksImpl"
180,b1dacbcb32d699c8e68ec630c25a457d9684ef03,RunningTasks.java,"@@ -150,6 +150,10 @@ class RunningTasks {
         task.fillTaskInfo(rti, !mKeepIntentExtra);
         // Fill in some deprecated values
         rti.id = rti.taskId;
+
+        if (!mAllowed) {
+            Task.trimIneffectiveInfo(task, rti);
+        }
         return rti;
     }
 }
",4,0,RunningTasks::createRunningTaskInfo
181,b1dacbcb32d699c8e68ec630c25a457d9684ef03,Task.java,"@@ -3484,6 +3484,27 @@ class Task extends TaskFragment {
         info.mTopActivityLocusId = topRecord != null ? topRecord.getLocusId() : null;
     }
 
+    /**
+     * Removes the activity info if the activity belongs to a different uid, which is
+     * different from the app that hosts the task.
+     */
+    static void trimIneffectiveInfo(Task task, TaskInfo info) {
+        final ActivityRecord baseActivity = task.getActivity(r -> !r.finishing,
+                false /* traverseTopToBottom */);
+        final int baseActivityUid =
+                baseActivity != null ? baseActivity.getUid() : task.effectiveUid;
+
+        if (info.topActivityInfo != null
+                && task.effectiveUid != info.topActivityInfo.applicationInfo.uid) {
+            info.topActivity = null;
+            info.topActivityInfo = null;
+        }
+
+        if (task.effectiveUid != baseActivityUid) {
+            info.baseActivity = null;
+        }
+    }
+
     @Nullable PictureInPictureParams getPictureInPictureParams() {
         return getPictureInPictureParams(getTopMostTask());
     }
",21,0,Task::trimIneffectiveInfo
182,b1dacbcb32d699c8e68ec630c25a457d9684ef03,RecentTasksTest.java,"@@ -30,6 +30,7 @@ import static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;
 import static android.content.pm.ActivityInfo.LAUNCH_MULTIPLE;
 import static android.content.pm.ActivityInfo.LAUNCH_SINGLE_INSTANCE;
 import static android.content.res.Configuration.ORIENTATION_PORTRAIT;
+import static android.os.Process.NOBODY_UID;
 
 import static com.android.dx.mockito.inline.extended.ExtendedMockito.doNothing;
 import static com.android.dx.mockito.inline.extended.ExtendedMockito.doReturn;
@@ -1195,21 +1196,35 @@ public class RecentTasksTest extends WindowTestsBase {
 
     @Test
     public void testCreateRecentTaskInfo_detachedTask() {
-        final Task task = createTaskBuilder("".Task"").setCreateActivity(true).build();
+        final Task task = createTaskBuilder("".Task"").build();
+        new ActivityBuilder(mSupervisor.mService)
+                .setTask(task)
+                .setUid(NOBODY_UID)
+                .setComponent(new ComponentName(""com.foo"", "".BarActivity""))
+                .build();
         final TaskDisplayArea tda = task.getDisplayArea();
 
         assertTrue(task.isAttached());
         assertTrue(task.supportsMultiWindow());
 
-        RecentTaskInfo info = mRecentTasks.createRecentTaskInfo(task, true);
+        RecentTaskInfo info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,
+                true /* getTasksAllowed */);
 
         assertTrue(info.supportsMultiWindow);
         assertTrue(info.supportsSplitScreenMultiWindow);
 
+        info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,
+                false /* getTasksAllowed */);
+
+        assertTrue(info.topActivity == null);
+        assertTrue(info.topActivityInfo == null);
+        assertTrue(info.baseActivity == null);
+
         // The task can be put in split screen even if it is not attached now.
         task.removeImmediately();
 
-        info = mRecentTasks.createRecentTaskInfo(task, true);
+        info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,
+                true /* getTasksAllowed */);
 
         assertTrue(info.supportsMultiWindow);
         assertTrue(info.supportsSplitScreenMultiWindow);
@@ -1219,7 +1234,8 @@ public class RecentTasksTest extends WindowTestsBase {
         doReturn(false).when(tda).supportsNonResizableMultiWindow();
         doReturn(false).when(task).isResizeable();
 
-        info = mRecentTasks.createRecentTaskInfo(task, true);
+        info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,
+                true /* getTasksAllowed */);
 
         assertFalse(info.supportsMultiWindow);
         assertFalse(info.supportsSplitScreenMultiWindow);
@@ -1228,7 +1244,8 @@ public class RecentTasksTest extends WindowTestsBase {
         // the device supports it.
         doReturn(true).when(tda).supportsNonResizableMultiWindow();
 
-        info = mRecentTasks.createRecentTaskInfo(task, true);
+        info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,
+                true /* getTasksAllowed */);
 
         assertTrue(info.supportsMultiWindow);
         assertTrue(info.supportsSplitScreenMultiWindow);
",22,5,RecentTasksTest::testCreateRecentTaskInfo_detachedTask
183,ce0a326a0c700a2d71b697219bc39fb7b3eb1038,PermissionManagerService.java,"@@ -2248,6 +2248,46 @@ public class PermissionManagerService extends IPermissionManager.Stub {
 
     }
 
+    /**
+     * If the package was below api 23, got the SYSTEM_ALERT_WINDOW permission automatically, and
+     * then updated past api 23, and the app does not satisfy any of the other SAW permission flags,
+     * the permission should be revoked.
+     *
+     * @param newPackage The new package that was installed
+     * @param oldPackage The old package that was updated
+     */
+    private void revokeSystemAlertWindowIfUpgradedPast23(
+            @NonNull AndroidPackage newPackage,
+            @NonNull AndroidPackage oldPackage) {
+        if (oldPackage.getTargetSdkVersion() >= Build.VERSION_CODES.M
+                || newPackage.getTargetSdkVersion() < Build.VERSION_CODES.M
+                || !newPackage.getRequestedPermissions()
+                .contains(Manifest.permission.SYSTEM_ALERT_WINDOW)) {
+            return;
+        }
+
+        Permission saw;
+        synchronized (mLock) {
+            saw = mRegistry.getPermission(Manifest.permission.SYSTEM_ALERT_WINDOW);
+        }
+        final PackageSetting ps = (PackageSetting)
+                mPackageManagerInt.getPackageSetting(newPackage.getPackageName());
+        if (shouldGrantPermissionByProtectionFlags(newPackage, ps, saw, new ArraySet<>())
+                    || shouldGrantPermissionBySignature(newPackage, saw)) {
+            return;
+        }
+        for (int userId : getAllUserIds()) {
+            try {
+                revokePermissionFromPackageForUser(newPackage.getPackageName(),
+                        Manifest.permission.SYSTEM_ALERT_WINDOW, false, userId,
+                        mDefaultPermissionCallback);
+            } catch (IllegalStateException | SecurityException e) {
+                Log.e(TAG, ""unable to revoke SYSTEM_ALERT_WINDOW for ""
+                        + newPackage.getPackageName() + "" user "" + userId, e);
+            }
+        }
+    }
+
     /**
      * We might auto-grant permissions if any permission of the group is already granted. Hence if
      * the group of a granted permission changes we need to revoke it to avoid having permissions of
@@ -4814,6 +4854,7 @@ public class PermissionManagerService extends IPermissionManager.Stub {
                 if (hasOldPkg) {
                     revokeRuntimePermissionsIfGroupChangedInternal(pkg, oldPkg);
                     revokeStoragePermissionsIfScopeExpandedInternal(pkg, oldPkg);
+                    revokeSystemAlertWindowIfUpgradedPast23(pkg, oldPkg);
                 }
                 if (hasPermissionDefinitionChanges) {
                     revokeRuntimePermissionsIfPermissionDefinitionChangedInternal(
",41,0,"PermissionManagerService::onPackageAddedInternal, PermissionManagerService::revokeSystemAlertWindowIfUpgradedPast23"
184,f089bd6a11e3afcbcdfc5a2c286bc78d79be0600,UsbDeviceConnection.java,"@@ -107,6 +107,34 @@ public class UsbDeviceConnection {
         }
     }
 
+    /**
+     * This is meant to be called by UsbRequest's queue() in order to synchronize on
+     * UsbDeviceConnection's mLock to prevent the connection being closed while queueing.
+     */
+    /* package */ boolean queueRequest(UsbRequest request, ByteBuffer buffer, int length) {
+        synchronized (mLock) {
+            if (!isOpen()) {
+                return false;
+            }
+
+            return request.queueIfConnectionOpen(buffer, length);
+        }
+    }
+
+    /**
+     * This is meant to be called by UsbRequest's queue() in order to synchronize on
+     * UsbDeviceConnection's mLock to prevent the connection being closed while queueing.
+     */
+    /* package */ boolean queueRequest(UsbRequest request, @Nullable ByteBuffer buffer) {
+        synchronized (mLock) {
+            if (!isOpen()) {
+                return false;
+            }
+
+            return request.queueIfConnectionOpen(buffer);
+        }
+    }
+
     /**
      * Releases all system resources related to the device.
      * Once the object is closed it cannot be used again.
",28,0,"UsbDeviceConnection::queueRequest, UsbDeviceConnection::queueRequest"
185,f089bd6a11e3afcbcdfc5a2c286bc78d79be0600,UsbRequest.java,"@@ -113,11 +113,13 @@ public class UsbRequest {
      * Releases all resources related to this request.
      */
     public void close() {
-        if (mNativeContext != 0) {
-            mEndpoint = null;
-            mConnection = null;
-            native_close();
-            mCloseGuard.close();
+        synchronized (mLock) {
+            if (mNativeContext != 0) {
+                mEndpoint = null;
+                mConnection = null;
+                native_close();
+                mCloseGuard.close();
+            }
         }
     }
 
@@ -191,10 +193,32 @@ public class UsbRequest {
      */
     @Deprecated
     public boolean queue(ByteBuffer buffer, int length) {
+        UsbDeviceConnection connection = mConnection;
+        if (connection == null) {
+            // The expected exception by CTS Verifier - USB Device test
+            throw new NullPointerException(""invalid connection"");
+        }
+
+        // Calling into the underlying UsbDeviceConnection to synchronize on its lock, to prevent
+        // the connection being closed while queueing.
+        return connection.queueRequest(this, buffer, length);
+    }
+
+    /**
+     * This is meant to be called from UsbDeviceConnection after synchronizing using the lock over
+     * there, to prevent the connection being closed while queueing.
+     */
+    /* package */ boolean queueIfConnectionOpen(ByteBuffer buffer, int length) {
+        UsbDeviceConnection connection = mConnection;
+        if (connection == null || !connection.isOpen()) {
+            // The expected exception by CTS Verifier - USB Device test
+            throw new NullPointerException(""invalid connection"");
+        }
+
         boolean out = (mEndpoint.getDirection() == UsbConstants.USB_DIR_OUT);
         boolean result;
 
-        if (mConnection.getContext().getApplicationInfo().targetSdkVersion < Build.VERSION_CODES.P
+        if (connection.getContext().getApplicationInfo().targetSdkVersion < Build.VERSION_CODES.P
                 && length > MAX_USBFS_BUFFER_SIZE) {
             length = MAX_USBFS_BUFFER_SIZE;
         }
@@ -243,6 +267,28 @@ public class UsbRequest {
      * @return true if the queueing operation succeeded
      */
     public boolean queue(@Nullable ByteBuffer buffer) {
+        UsbDeviceConnection connection = mConnection;
+        if (connection == null) {
+            // The expected exception by CTS Verifier - USB Device test
+            throw new IllegalStateException(""invalid connection"");
+        }
+
+        // Calling into the underlying UsbDeviceConnection to synchronize on its lock, to prevent
+        // the connection being closed while queueing.
+        return connection.queueRequest(this, buffer);
+    }
+
+    /**
+     * This is meant to be called from UsbDeviceConnection after synchronizing using the lock over
+     * there, to prevent the connection being closed while queueing.
+     */
+    /* package */ boolean queueIfConnectionOpen(@Nullable ByteBuffer buffer) {
+        UsbDeviceConnection connection = mConnection;
+        if (connection == null || !connection.isOpen()) {
+            // The expected exception by CTS Verifier - USB Device test
+            throw new IllegalStateException(""invalid connection"");
+        }
+
         // Request need to be initialized
         Preconditions.checkState(mNativeContext != 0, ""request is not initialized"");
 
@@ -260,7 +306,7 @@ public class UsbRequest {
                 mIsUsingNewQueue = true;
                 wasQueued = native_queue(null, 0, 0);
             } else {
-                if (mConnection.getContext().getApplicationInfo().targetSdkVersion
+                if (connection.getContext().getApplicationInfo().targetSdkVersion
                         < Build.VERSION_CODES.P) {
                     // Can only send/receive MAX_USBFS_BUFFER_SIZE bytes at once
                     Preconditions.checkArgumentInRange(buffer.remaining(), 0, MAX_USBFS_BUFFER_SIZE,
@@ -363,11 +409,12 @@ public class UsbRequest {
      * @return true if cancelling succeeded
      */
     public boolean cancel() {
-        if (mConnection == null) {
+        UsbDeviceConnection connection = mConnection;
+        if (connection == null) {
             return false;
         }
 
-        return mConnection.cancelRequest(this);
+        return connection.cancelRequest(this);
     }
 
     /**
@@ -382,7 +429,8 @@ public class UsbRequest {
      * @return true if cancelling succeeded.
      */
     /* package */ boolean cancelIfOpen() {
-        if (mNativeContext == 0 || (mConnection != null && !mConnection.isOpen())) {
+        UsbDeviceConnection connection = mConnection;
+        if (mNativeContext == 0 || (connection != null && !connection.isOpen())) {
             Log.w(TAG,
                     ""Detected attempt to cancel a request on a connection which isn't open"");
             return false;
",58,10,"UsbRequest::queue, UsbRequest::cancelIfOpen, UsbRequest::close, UsbRequest::queue, UsbRequest::queueIfConnectionOpen, UsbRequest::queueIfConnectionOpen, UsbRequest::cancel"
186,b0acd540cd5194b529aedaf87e00dff377da4448,ResolverActivity.java,"@@ -1227,9 +1227,6 @@ public class ResolverActivity extends Activity implements
         }
 
         if (target != null) {
-            if (intent != null && isLaunchingTargetInOtherProfile()) {
-                prepareIntentForCrossProfileLaunch(intent);
-            }
             safelyStartActivity(target);
 
             // Rely on the ActivityManager to pop up a dialog regarding app suspension
@@ -1242,15 +1239,6 @@ public class ResolverActivity extends Activity implements
         return true;
     }
 
-    private void prepareIntentForCrossProfileLaunch(Intent intent) {
-        intent.fixUris(UserHandle.myUserId());
-    }
-
-    private boolean isLaunchingTargetInOtherProfile() {
-        return mMultiProfilePagerAdapter.getCurrentUserHandle().getIdentifier()
-                != UserHandle.myUserId();
-    }
-
     @VisibleForTesting
     public void safelyStartActivity(TargetInfo cti) {
         // We're dispatching intents that might be coming from legacy apps, so
",0,12,"ResolverActivity::prepareIntentForCrossProfileLaunch, ResolverActivity::isLaunchingTargetInOtherProfile, ResolverActivity::onTargetSelected"
187,b0acd540cd5194b529aedaf87e00dff377da4448,DisplayResolveInfo.java,"@@ -181,6 +181,7 @@ public class DisplayResolveInfo implements TargetInfo, Parcelable {
         if (ENABLE_CHOOSER_DELEGATE) {
             return activity.startAsCallerImpl(mResolvedIntent, options, false, userId);
         } else {
+            TargetInfo.prepareIntentForCrossProfileLaunch(mResolvedIntent, userId);
             activity.startActivityAsCaller(mResolvedIntent, options, null, false, userId);
             return true;
         }
@@ -188,6 +189,7 @@ public class DisplayResolveInfo implements TargetInfo, Parcelable {
 
     @Override
     public boolean startAsUser(Activity activity, Bundle options, UserHandle user) {
+        TargetInfo.prepareIntentForCrossProfileLaunch(mResolvedIntent, user.getIdentifier());
         activity.startActivityAsUser(mResolvedIntent, options, user);
         return false;
     }
",2,0,"DisplayResolveInfo::startAsUser, DisplayResolveInfo::startAsCaller"
188,b0acd540cd5194b529aedaf87e00dff377da4448,SelectableTargetInfo.java,"@@ -229,6 +229,7 @@ public final class SelectableTargetInfo implements ChooserTargetInfo {
         }
         intent.setComponent(mChooserTarget.getComponentName());
         intent.putExtras(mChooserTarget.getIntentExtras());
+        TargetInfo.prepareIntentForCrossProfileLaunch(intent, userId);
 
         // Important: we will ignore the target security checks in ActivityManager
         // if and only if the ChooserTarget's target package is the same package
",1,0,SelectableTargetInfo::startAsCaller
189,b0acd540cd5194b529aedaf87e00dff377da4448,TargetInfo.java,"@@ -130,4 +130,15 @@ public interface TargetInfo {
      * @return true if this target should be pinned to the front by the request of the user
      */
     boolean isPinned();
+
+    /**
+     * Fix the URIs in {@code intent} if cross-profile sharing is required. This should be called
+     * before launching the intent as another user.
+     */
+    static void prepareIntentForCrossProfileLaunch(Intent intent, int targetUserId) {
+        final int currentUserId = UserHandle.myUserId();
+        if (targetUserId != currentUserId) {
+            intent.fixUris(currentUserId);
+        }
+    }
 }
",11,0,prepareIntentForCrossProfileLaunch
190,57cc81a61b64c23a84e5a232e0aa822e90b85241,PendingIntentRecord.java,"@@ -350,11 +350,16 @@ public final class PendingIntentRecord extends IIntentSender.Stub {
                 resolvedType = key.requestResolvedType;
             }
 
-            // Apply any launch flags from the ActivityOptions. This is to ensure that the caller
-            // can specify a consistent launch mode even if the PendingIntent is immutable
+            // Apply any launch flags from the ActivityOptions. This is used only by SystemUI
+            // to ensure that we can launch the pending intent with a consistent launch mode even
+            // if the provided PendingIntent is immutable (ie. to force an activity to launch into
+            // a new task, or to launch multiple instances if supported by the app)
             final ActivityOptions opts = ActivityOptions.fromBundle(options);
             if (opts != null) {
-                finalIntent.addFlags(opts.getPendingIntentLaunchFlags());
+                // TODO(b/254490217): Move this check into SafeActivityOptions
+                if (controller.mAtmInternal.isCallerRecents(Binder.getCallingUid())) {
+                    finalIntent.addFlags(opts.getPendingIntentLaunchFlags());
+                }
             }
 
             // Extract options before clearing calling identity
",8,3,PendingIntentRecord::sendInner
191,b702b280e4cbf89243d6d1e272cdd7869dce2d07,BiometricPrompt.java,"@@ -420,6 +420,18 @@ public class BiometricPrompt implements BiometricAuthenticator, BiometricConstan
             return this;
         }
 
+        /**
+         * Set if BiometricPrompt is being used by the legacy fingerprint manager API.
+         * @param sensorId sensor id
+         * @return This builder.
+         * @hide
+         */
+        @NonNull
+        public Builder setIsForLegacyFingerprintManager(int sensorId) {
+            mPromptInfo.setIsForLegacyFingerprintManager(sensorId);
+            return this;
+        }
+
         /**
          * Creates a {@link BiometricPrompt}.
          *
@@ -861,28 +873,36 @@ public class BiometricPrompt implements BiometricAuthenticator, BiometricConstan
             @NonNull @CallbackExecutor Executor executor,
             @NonNull AuthenticationCallback callback,
             int userId) {
-        authenticateUserForOperation(cancel, executor, callback, userId, 0 /* operationId */);
+        if (cancel == null) {
+            throw new IllegalArgumentException(""Must supply a cancellation signal"");
+        }
+        if (executor == null) {
+            throw new IllegalArgumentException(""Must supply an executor"");
+        }
+        if (callback == null) {
+            throw new IllegalArgumentException(""Must supply a callback"");
+        }
+
+        authenticateInternal(0 /* operationId */, cancel, executor, callback, userId);
     }
 
     /**
-     * Authenticates for the given user and keystore operation.
+     * Authenticates for the given keystore operation.
      *
      * @param cancel An object that can be used to cancel authentication
      * @param executor An executor to handle callback events
      * @param callback An object to receive authentication events
-     * @param userId The user to authenticate
      * @param operationId The keystore operation associated with authentication
      *
      * @return A requestId that can be used to cancel this operation.
      *
      * @hide
      */
-    @RequiresPermission(USE_BIOMETRIC_INTERNAL)
-    public long authenticateUserForOperation(
+    @RequiresPermission(USE_BIOMETRIC)
+    public long authenticateForOperation(
             @NonNull CancellationSignal cancel,
             @NonNull @CallbackExecutor Executor executor,
             @NonNull AuthenticationCallback callback,
-            int userId,
             long operationId) {
         if (cancel == null) {
             throw new IllegalArgumentException(""Must supply a cancellation signal"");
@@ -894,7 +914,7 @@ public class BiometricPrompt implements BiometricAuthenticator, BiometricConstan
             throw new IllegalArgumentException(""Must supply a callback"");
         }
 
-        return authenticateInternal(operationId, cancel, executor, callback, userId);
+        return authenticateInternal(operationId, cancel, executor, callback, mContext.getUserId());
     }
 
     /**
@@ -1028,7 +1048,7 @@ public class BiometricPrompt implements BiometricAuthenticator, BiometricConstan
     private void cancelAuthentication(long requestId) {
         if (mService != null) {
             try {
-                mService.cancelAuthentication(mToken, mContext.getOpPackageName(), requestId);
+                mService.cancelAuthentication(mToken, mContext.getPackageName(), requestId);
             } catch (RemoteException e) {
                 Log.e(TAG, ""Unable to cancel authentication"", e);
             }
@@ -1087,7 +1107,7 @@ public class BiometricPrompt implements BiometricAuthenticator, BiometricConstan
             }
 
             final long authId = mService.authenticate(mToken, operationId, userId,
-                    mBiometricServiceReceiver, mContext.getOpPackageName(), promptInfo);
+                    mBiometricServiceReceiver, mContext.getPackageName(), promptInfo);
             cancel.setOnCancelListener(new OnAuthenticationCancelListener(authId));
             return authId;
         } catch (RemoteException e) {
",29,9,"BiometricPrompt::cancelAuthentication, BiometricPrompt::authenticateInternal, BiometricPrompt::authenticateForOperation, BiometricPrompt::Builder::setIsForLegacyFingerprintManager, BiometricPrompt::authenticateUser, BiometricPrompt::authenticateUserForOperation"
192,b702b280e4cbf89243d6d1e272cdd7869dce2d07,PromptInfo.java,"@@ -46,6 +46,7 @@ public class PromptInfo implements Parcelable {
     @NonNull private List<Integer> mAllowedSensorIds = new ArrayList<>();
     private boolean mAllowBackgroundAuthentication;
     private boolean mIgnoreEnrollmentState;
+    private boolean mIsForLegacyFingerprintManager = false;
 
     public PromptInfo() {
 
@@ -68,6 +69,7 @@ public class PromptInfo implements Parcelable {
         mAllowedSensorIds = in.readArrayList(Integer.class.getClassLoader());
         mAllowBackgroundAuthentication = in.readBoolean();
         mIgnoreEnrollmentState = in.readBoolean();
+        mIsForLegacyFingerprintManager = in.readBoolean();
     }
 
     public static final Creator<PromptInfo> CREATOR = new Creator<PromptInfo>() {
@@ -105,10 +107,15 @@ public class PromptInfo implements Parcelable {
         dest.writeList(mAllowedSensorIds);
         dest.writeBoolean(mAllowBackgroundAuthentication);
         dest.writeBoolean(mIgnoreEnrollmentState);
+        dest.writeBoolean(mIsForLegacyFingerprintManager);
     }
 
     public boolean containsTestConfigurations() {
-        if (!mAllowedSensorIds.isEmpty()) {
+        if (mIsForLegacyFingerprintManager
+                && mAllowedSensorIds.size() == 1
+                && !mAllowBackgroundAuthentication) {
+            return false;
+        } else if (!mAllowedSensorIds.isEmpty()) {
             return true;
         } else if (mAllowBackgroundAuthentication) {
             return true;
@@ -188,7 +195,8 @@ public class PromptInfo implements Parcelable {
     }
 
     public void setAllowedSensorIds(@NonNull List<Integer> sensorIds) {
-        mAllowedSensorIds = sensorIds;
+        mAllowedSensorIds.clear();
+        mAllowedSensorIds.addAll(sensorIds);
     }
 
     public void setAllowBackgroundAuthentication(boolean allow) {
@@ -199,6 +207,12 @@ public class PromptInfo implements Parcelable {
         mIgnoreEnrollmentState = ignoreEnrollmentState;
     }
 
+    public void setIsForLegacyFingerprintManager(int sensorId) {
+        mIsForLegacyFingerprintManager = true;
+        mAllowedSensorIds.clear();
+        mAllowedSensorIds.add(sensorId);
+    }
+
     // Getters
 
     public CharSequence getTitle() {
@@ -272,4 +286,8 @@ public class PromptInfo implements Parcelable {
     public boolean isIgnoreEnrollmentState() {
         return mIgnoreEnrollmentState;
     }
+
+    public boolean isForLegacyFingerprintManager() {
+        return mIsForLegacyFingerprintManager;
+    }
 }
",20,2,"PromptInfo::setAllowedSensorIds, PromptInfo::writeToParcel, PromptInfo::containsTestConfigurations, PromptInfo::PromptInfo, PromptInfo::setIsForLegacyFingerprintManager, PromptInfo::isForLegacyFingerprintManager"
193,b702b280e4cbf89243d6d1e272cdd7869dce2d07,AuthController.java,"@@ -134,7 +134,7 @@ public class AuthController extends SystemUI implements CommandQueue.Callbacks,
     private class BiometricTaskStackListener extends TaskStackListener {
         @Override
         public void onTaskStackChanged() {
-            mHandler.post(AuthController.this::handleTaskStackChanged);
+            mHandler.post(AuthController.this::cancelIfOwnerIsNotInForeground);
         }
     }
 
@@ -181,7 +181,7 @@ public class AuthController extends SystemUI implements CommandQueue.Callbacks,
         }
     };
 
-    private void handleTaskStackChanged() {
+    private void cancelIfOwnerIsNotInForeground() {
         mExecution.assertIsMainThread();
         if (mCurrentDialog != null) {
             try {
@@ -193,7 +193,7 @@ public class AuthController extends SystemUI implements CommandQueue.Callbacks,
                     final String topPackage = runningTasks.get(0).topActivity.getPackageName();
                     if (!topPackage.contentEquals(clientPackage)
                             && !Utils.isSystem(mContext, clientPackage)) {
-                        Log.w(TAG, ""Evicting client due to: "" + topPackage);
+                        Log.e(TAG, ""Evicting client due to: "" + topPackage);
                         mCurrentDialog.dismissWithoutCallback(true /* animate */);
                         mCurrentDialog = null;
                         mOrientationListener.disable();
@@ -814,6 +814,10 @@ public class AuthController extends SystemUI implements CommandQueue.Callbacks,
         mCurrentDialog = newDialog;
         mCurrentDialog.show(mWindowManager, savedState);
         mOrientationListener.enable();
+
+        if (!promptInfo.isAllowBackgroundAuthentication()) {
+            mHandler.post(this::cancelIfOwnerIsNotInForeground);
+        }
     }
 
     private void onDialogDismissed(@DismissedReason int reason) {
",7,3,"AuthController::handleTaskStackChanged, AuthController::showDialog, AuthController::BiometricTaskStackListener::onTaskStackChanged, AuthController::cancelIfOwnerIsNotInForeground"
194,b702b280e4cbf89243d6d1e272cdd7869dce2d07,AuthControllerTest.java,"@@ -554,16 +554,26 @@ public class AuthControllerTest extends SysuiTestCase {
                 mAuthController.mLastBiometricPromptInfo.getAuthenticators());
     }
 
+    @Test
+    public void testClientNotified_whenTaskStackChangesDuringShow() throws Exception {
+        switchTask(""other_package"");
+        showDialog(new int[] {1} /* sensorIds */, false /* credentialAllowed */);
+
+        waitForIdleSync();
+
+        assertNull(mAuthController.mCurrentDialog);
+        assertNull(mAuthController.mReceiver);
+        verify(mDialog1).dismissWithoutCallback(true /* animate */);
+        verify(mReceiver).onDialogDismissed(
+                eq(BiometricPrompt.DISMISSED_REASON_USER_CANCEL),
+                eq(null) /* credentialAttestation */);
+    }
+
     @Test
     public void testClientNotified_whenTaskStackChangesDuringAuthentication() throws Exception {
         showDialog(new int[] {1} /* sensorIds */, false /* credentialAllowed */);
 
-        List<ActivityManager.RunningTaskInfo> tasks = new ArrayList<>();
-        ActivityManager.RunningTaskInfo taskInfo = mock(ActivityManager.RunningTaskInfo.class);
-        taskInfo.topActivity = mock(ComponentName.class);
-        when(taskInfo.topActivity.getPackageName()).thenReturn(""other_package"");
-        tasks.add(taskInfo);
-        when(mActivityTaskManager.getTasks(anyInt())).thenReturn(tasks);
+        switchTask(""other_package"");
 
         mAuthController.mTaskStackListener.onTaskStackChanged();
         mTestableLooper.processAllMessages();
@@ -640,6 +650,16 @@ public class AuthControllerTest extends SysuiTestCase {
                 BIOMETRIC_MULTI_SENSOR_FACE_THEN_FINGERPRINT);
     }
 
+    private void switchTask(String packageName) {
+        final List<ActivityManager.RunningTaskInfo> tasks = new ArrayList<>();
+        final ActivityManager.RunningTaskInfo taskInfo =
+                mock(ActivityManager.RunningTaskInfo.class);
+        taskInfo.topActivity = mock(ComponentName.class);
+        when(taskInfo.topActivity.getPackageName()).thenReturn(packageName);
+        tasks.add(taskInfo);
+        when(mActivityTaskManager.getTasks(anyInt())).thenReturn(tasks);
+    }
+
     private PromptInfo createTestPromptInfo() {
         PromptInfo promptInfo = new PromptInfo();
 
",26,6,"AuthControllerTest::switchTask, AuthControllerTest::testClientNotified_whenTaskStackChangesDuringAuthentication, AuthControllerTest::testClientNotified_whenTaskStackChangesDuringShow"
195,b702b280e4cbf89243d6d1e272cdd7869dce2d07,AuthenticationClient.java,"@@ -118,7 +118,7 @@ public abstract class AuthenticationClient<T> extends AcquisitionClient<T>
         mIsStrongBiometric = isStrongBiometric;
         mOperationId = operationId;
         mRequireConfirmation = requireConfirmation;
-        mActivityTaskManager = ActivityTaskManager.getInstance();
+        mActivityTaskManager = getActivityTaskManager();
         mBiometricManager = context.getSystemService(BiometricManager.class);
         mTaskStackListener = taskStackListener;
         mLockoutTracker = lockoutTracker;
@@ -146,6 +146,10 @@ public abstract class AuthenticationClient<T> extends AcquisitionClient<T>
         return mStartTimeMs;
     }
 
+    protected ActivityTaskManager getActivityTaskManager() {
+        return ActivityTaskManager.getInstance();
+    }
+
     @Override
     public void binderDied() {
         final boolean clearListener = !isBiometricPrompt();
@@ -322,45 +326,50 @@ public abstract class AuthenticationClient<T> extends AcquisitionClient<T>
                     sendCancelOnly(listener);
                 }
             });
-        } else {
-            // Allow system-defined limit of number of attempts before giving up
-            final @LockoutTracker.LockoutMode int lockoutMode =
-                    handleFailedAttempt(getTargetUserId());
-            if (lockoutMode != LockoutTracker.LOCKOUT_NONE) {
-                markAlreadyDone();
-            }
-
-            final CoexCoordinator coordinator = CoexCoordinator.getInstance();
-            coordinator.onAuthenticationRejected(SystemClock.uptimeMillis(), this, lockoutMode,
-                    new CoexCoordinator.Callback() {
-                @Override
-                public void sendAuthenticationResult(boolean addAuthTokenIfStrong) {
-                    if (listener != null) {
-                        try {
-                            listener.onAuthenticationFailed(getSensorId());
-                        } catch (RemoteException e) {
-                            Slog.e(TAG, ""Unable to notify listener"", e);
-                        }
-                    }
+        } else { // not authenticated
+            if (isBackgroundAuth) {
+                Slog.e(TAG, ""cancelling due to background auth"");
+                cancel();
+            } else {
+                // Allow system-defined limit of number of attempts before giving up
+                final @LockoutTracker.LockoutMode int lockoutMode =
+                        handleFailedAttempt(getTargetUserId());
+                if (lockoutMode != LockoutTracker.LOCKOUT_NONE) {
+                    markAlreadyDone();
                 }
 
-                @Override
-                public void sendHapticFeedback() {
-                    if (listener != null && mShouldVibrate) {
-                        vibrateError();
-                    }
-                }
+                final CoexCoordinator coordinator = CoexCoordinator.getInstance();
+                coordinator.onAuthenticationRejected(SystemClock.uptimeMillis(), this, lockoutMode,
+                        new CoexCoordinator.Callback() {
+                            @Override
+                            public void sendAuthenticationResult(boolean addAuthTokenIfStrong) {
+                                if (listener != null) {
+                                    try {
+                                        listener.onAuthenticationFailed(getSensorId());
+                                    } catch (RemoteException e) {
+                                        Slog.e(TAG, ""Unable to notify listener"", e);
+                                    }
+                                }
+                            }
 
-                @Override
-                public void handleLifecycleAfterAuth() {
-                    AuthenticationClient.this.handleLifecycleAfterAuth(false /* authenticated */);
-                }
+                            @Override
+                            public void sendHapticFeedback() {
+                                if (listener != null && mShouldVibrate) {
+                                    vibrateError();
+                                }
+                            }
 
-                @Override
-                public void sendAuthenticationCanceled() {
-                    sendCancelOnly(listener);
-                }
-            });
+                            @Override
+                            public void handleLifecycleAfterAuth() {
+                                AuthenticationClient.this.handleLifecycleAfterAuth(false /* authenticated */);
+                            }
+
+                            @Override
+                            public void sendAuthenticationCanceled() {
+                                sendCancelOnly(listener);
+                            }
+                        });
+            }
         }
     }
 
",45,36,"AuthenticationClient::AuthenticationClient, AuthenticationClient::onAuthenticated, AuthenticationClient::getActivityTaskManager"
196,b702b280e4cbf89243d6d1e272cdd7869dce2d07,FingerprintService.java,"@@ -331,12 +331,11 @@ public class FingerprintService extends SystemService {
                     provider.second.getSensorProperties(sensorId);
             if (!isKeyguard && !Utils.isSettings(getContext(), opPackageName)
                     && sensorProps != null && sensorProps.isAnyUdfpsType()) {
-                identity = Binder.clearCallingIdentity();
                 try {
                     return authenticateWithPrompt(operationId, sensorProps, userId, receiver,
-                            ignoreEnrollmentState);
-                } finally {
-                    Binder.restoreCallingIdentity(identity);
+                            ignoreEnrollmentState, opPackageName);
+                } catch (PackageManager.NameNotFoundException e) {
+                    Slog.e(TAG, ""Invalid package"", e);
                 }
             }
             return provider.second.scheduleAuthenticate(provider.first, token, operationId, userId,
@@ -349,12 +348,15 @@ public class FingerprintService extends SystemService {
                 @NonNull final FingerprintSensorPropertiesInternal props,
                 final int userId,
                 final IFingerprintServiceReceiver receiver,
-                boolean ignoreEnrollmentState) {
+                boolean ignoreEnrollmentState,
+                final String opPackageName) throws PackageManager.NameNotFoundException {
 
             final Context context = getUiContext();
+            final Context promptContext = context.createPackageContextAsUser(
+                    opPackageName, 0 /* flags */, UserHandle.getUserHandleForUid(userId));
             final Executor executor = context.getMainExecutor();
 
-            final BiometricPrompt biometricPrompt = new BiometricPrompt.Builder(context)
+            final BiometricPrompt biometricPrompt = new BiometricPrompt.Builder(promptContext)
                     .setTitle(context.getString(R.string.biometric_dialog_default_title))
                     .setSubtitle(context.getString(R.string.fingerprint_dialog_default_subtitle))
                     .setNegativeButton(
@@ -368,8 +370,7 @@ public class FingerprintService extends SystemService {
                                     Slog.e(TAG, ""Remote exception in negative button onClick()"", e);
                                 }
                             })
-                    .setAllowedSensorIds(new ArrayList<>(
-                            Collections.singletonList(props.sensorId)))
+                    .setIsForLegacyFingerprintManager(props.sensorId)
                     .setIgnoreEnrollmentState(ignoreEnrollmentState)
                     .build();
 
@@ -423,8 +424,8 @@ public class FingerprintService extends SystemService {
                         }
                     };
 
-            return biometricPrompt.authenticateUserForOperation(
-                    new CancellationSignal(), executor, promptCallback, userId, operationId);
+            return biometricPrompt.authenticateForOperation(
+                    new CancellationSignal(), executor, promptCallback, operationId);
         }
 
         @Override
",11,10,"FingerprintService::FingerprintServiceWrapper::authenticateWithPrompt, FingerprintService::FingerprintServiceWrapper::authenticateWithPrompt, FingerprintService::FingerprintServiceWrapper::authenticate"
197,bbf844775b20357ca64729263aaa75ea64ec2fe3,ActivityRecord.java,"@@ -804,6 +804,13 @@ final class ActivityRecord extends WindowToken implements WindowManagerService.A
 
     private AppSaturationInfo mLastAppSaturationInfo;
 
+    private final ActivityRecordInputSink mActivityRecordInputSink;
+
+    // Activities with this uid are allowed to not create an input sink while being in the same
+    // task and directly above this ActivityRecord. This field is updated whenever a new activity
+    // is launched from this ActivityRecord. Touches are always allowed within the same uid.
+    int mAllowedTouchUid;
+
     private final ColorDisplayService.ColorTransformController mColorTransformController =
             (matrix, translation) -> mWmService.mH.post(() -> {
                 synchronized (mWmService.mGlobalLock) {
@@ -1841,6 +1848,8 @@ final class ActivityRecord extends WindowToken implements WindowManagerService.A
             createTime = _createTime;
         }
         mAtmService.mPackageConfigPersister.updateConfigIfNeeded(this, mUserId, packageName);
+
+        mActivityRecordInputSink = new ActivityRecordInputSink(this, sourceRecord);
     }
 
     /**
@@ -3767,6 +3776,7 @@ final class ActivityRecord extends WindowToken implements WindowManagerService.A
         } else {
             onRemovedFromDisplay();
         }
+        mActivityRecordInputSink.releaseSurfaceControl();
         super.removeImmediately();
     }
 
@@ -6926,6 +6936,9 @@ final class ActivityRecord extends WindowToken implements WindowManagerService.A
             } else if (!show && mLastSurfaceShowing) {
                 getSyncTransaction().hide(mSurfaceControl);
             }
+            if (show) {
+                mActivityRecordInputSink.applyChangesToSurfaceIfChanged(getSyncTransaction());
+            }
         }
         if (mThumbnail != null) {
             mThumbnail.setShowing(getPendingTransaction(), show);
",13,0,"ActivityRecord::prepareSurfaces, ActivityRecord::removeImmediately, ActivityRecord::ActivityRecord"
198,bbf844775b20357ca64729263aaa75ea64ec2fe3,ActivityRecordInputSink.java,"@@ -0,0 +1,113 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.wm;
+
+import android.os.Process;
+import android.view.InputWindowHandle;
+import android.view.SurfaceControl;
+import android.view.WindowManager;
+
+/**
+ * Creates a InputWindowHandle that catches all touches that would otherwise pass through an
+ * Activity.
+ */
+class ActivityRecordInputSink {
+
+    private final ActivityRecord mActivityRecord;
+    private final String mName;
+
+    private InputWindowHandle mInputWindowHandle;
+    private SurfaceControl mSurfaceControl;
+
+    ActivityRecordInputSink(ActivityRecord activityRecord, ActivityRecord sourceRecord) {
+        mActivityRecord = activityRecord;
+        mName = Integer.toHexString(System.identityHashCode(this)) + "" ActivityRecordInputSink ""
+                + mActivityRecord.mActivityComponent.flattenToShortString();
+        if (sourceRecord != null) {
+            sourceRecord.mAllowedTouchUid = mActivityRecord.getUid();
+        }
+    }
+
+    public void applyChangesToSurfaceIfChanged(SurfaceControl.Transaction transaction) {
+        boolean windowHandleChanged = updateInputWindowHandle();
+        if (mSurfaceControl == null) {
+            mSurfaceControl = createSurface(transaction);
+        }
+        if (windowHandleChanged) {
+            transaction.setInputWindowInfo(mSurfaceControl, mInputWindowHandle);
+        }
+    }
+
+    private SurfaceControl createSurface(SurfaceControl.Transaction t) {
+        SurfaceControl surfaceControl = mActivityRecord.makeChildSurface(null)
+                .setName(mName)
+                .setHidden(false)
+                .setCallsite(""ActivityRecordInputSink.createSurface"")
+                .build();
+        // Put layer below all siblings (and the parent surface too)
+        t.setLayer(surfaceControl, Integer.MIN_VALUE);
+        return surfaceControl;
+    }
+
+    private boolean updateInputWindowHandle() {
+        boolean changed = false;
+        if (mInputWindowHandle == null) {
+            mInputWindowHandle = createInputWindowHandle();
+            changed = true;
+        }
+        // Don't block touches from passing through to an activity below us in the same task, if
+        // that activity is either from the same uid or if that activity has launched an activity
+        // in our uid.
+        final ActivityRecord activityBelowInTask =
+                mActivityRecord.getTask().getActivityBelow(mActivityRecord);
+        final boolean allowPassthrough = activityBelowInTask != null && (
+                activityBelowInTask.mAllowedTouchUid == mActivityRecord.getUid()
+                        || activityBelowInTask.isUid(mActivityRecord.getUid()));
+        boolean notTouchable = (mInputWindowHandle.layoutParamsFlags
+                & WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE) != 0;
+        if (allowPassthrough || mActivityRecord.isAppTransitioning()) {
+            mInputWindowHandle.layoutParamsFlags |= WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;
+            changed |= !notTouchable;
+        } else {
+            mInputWindowHandle.layoutParamsFlags &= ~WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;
+            changed |= notTouchable;
+        }
+        return changed;
+    }
+
+    private InputWindowHandle createInputWindowHandle() {
+        InputWindowHandle inputWindowHandle = new InputWindowHandle(null,
+                mActivityRecord.getDisplayId());
+        inputWindowHandle.replaceTouchableRegionWithCrop = true;
+        inputWindowHandle.name = mName;
+        inputWindowHandle.layoutParamsType = WindowManager.LayoutParams.TYPE_INPUT_CONSUMER;
+        inputWindowHandle.ownerUid = Process.myUid();
+        inputWindowHandle.ownerPid = Process.myPid();
+        inputWindowHandle.layoutParamsFlags = WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
+        inputWindowHandle.inputFeatures =
+                WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL;
+        return inputWindowHandle;
+    }
+
+    void releaseSurfaceControl() {
+        if (mSurfaceControl != null) {
+            mSurfaceControl.release();
+            mSurfaceControl = null;
+        }
+    }
+
+}
",113,0,"ActivityRecordInputSink::createSurface, ActivityRecordInputSink::updateInputWindowHandle, ActivityRecordInputSink::applyChangesToSurfaceIfChanged, ActivityRecordInputSink::ActivityRecordInputSink, ActivityRecordInputSink::releaseSurfaceControl, ActivityRecordInputSink::createInputWindowHandle"
199,f64cb7e161e2a2f8e26430f2aec1795ff8f5ab5e,FingerprintService.java,"@@ -332,8 +332,8 @@ public class FingerprintService extends SystemService {
             if (!isKeyguard && !Utils.isSettings(getContext(), opPackageName)
                     && sensorProps != null && sensorProps.isAnyUdfpsType()) {
                 try {
-                    return authenticateWithPrompt(operationId, sensorProps, userId, receiver,
-                            ignoreEnrollmentState, opPackageName);
+                    return authenticateWithPrompt(operationId, sensorProps, callingUid,
+                            callingUserId, receiver, ignoreEnrollmentState, opPackageName);
                 } catch (PackageManager.NameNotFoundException e) {
                     Slog.e(TAG, ""Invalid package"", e);
                 }
@@ -346,6 +346,7 @@ public class FingerprintService extends SystemService {
         private long authenticateWithPrompt(
                 final long operationId,
                 @NonNull final FingerprintSensorPropertiesInternal props,
+                final int uId,
                 final int userId,
                 final IFingerprintServiceReceiver receiver,
                 boolean ignoreEnrollmentState,
@@ -353,7 +354,7 @@ public class FingerprintService extends SystemService {
 
             final Context context = getUiContext();
             final Context promptContext = context.createPackageContextAsUser(
-                    opPackageName, 0 /* flags */, UserHandle.getUserHandleForUid(userId));
+                    opPackageName, 0 /* flags */, UserHandle.getUserHandleForUid(uId));
             final Executor executor = context.getMainExecutor();
 
             final BiometricPrompt biometricPrompt = new BiometricPrompt.Builder(promptContext)
",4,3,"FingerprintService::FingerprintServiceWrapper::authenticateWithPrompt, FingerprintService::FingerprintServiceWrapper::authenticate, FingerprintService::FingerprintServiceWrapper::authenticateWithPrompt"
200,373dc024fe540a11b4167e870733704bd9b877b9,ActivityManagerService.java,"@@ -3544,20 +3544,25 @@ public class ActivityManagerService extends IActivityManager.Stub
                             finishForceStopPackageLocked(packageName, appInfo.uid);
                         }
                     }
-                    final Intent intent = new Intent(Intent.ACTION_PACKAGE_DATA_CLEARED,
-                            Uri.fromParts(""package"", packageName, null));
-                    intent.addFlags(Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);
-                    intent.putExtra(Intent.EXTRA_UID, (appInfo != null) ? appInfo.uid : -1);
-                    intent.putExtra(Intent.EXTRA_USER_HANDLE, resolvedUserId);
-                    if (isInstantApp) {
-                        intent.putExtra(Intent.EXTRA_PACKAGE_NAME, packageName);
-                        broadcastIntentInPackage(""android"", null, SYSTEM_UID, uid, pid, intent,
-                                null, null, 0, null, null, permission.ACCESS_INSTANT_APPS, null,
-                                false, false, resolvedUserId, false, null);
-                    } else {
-                        broadcastIntentInPackage(""android"", null, SYSTEM_UID, uid, pid, intent,
-                                null, null, 0, null, null, null, null, false, false, resolvedUserId,
-                                false, null);
+
+                    if (succeeded) {
+                        final Intent intent = new Intent(Intent.ACTION_PACKAGE_DATA_CLEARED,
+                                Uri.fromParts(""package"", packageName, null /* fragment */));
+                        intent.addFlags(Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);
+                        intent.putExtra(Intent.EXTRA_UID,
+                                (appInfo != null) ? appInfo.uid : INVALID_UID);
+                        intent.putExtra(Intent.EXTRA_USER_HANDLE, resolvedUserId);
+                        if (isInstantApp) {
+                            intent.putExtra(Intent.EXTRA_PACKAGE_NAME, packageName);
+                        }
+
+                        broadcastIntentInPackage(""android"", null /* featureId */, SYSTEM_UID,
+                                uid, pid, intent, null /* resolvedType */, null /* resultTo */,
+                                0 /* resultCode */, null /* resultData */, null /* resultExtras */,
+                                isInstantApp ? permission.ACCESS_INSTANT_APPS : null,
+                                null /* bOptions */, false /* serialized */, false /* sticky */,
+                                resolvedUserId, false /* allowBackgroundActivityStarts */,
+                                null /* backgroundActivityStartsToken */);
                     }
 
                     if (observer != null) {
",19,14,ActivityManagerService::clearApplicationUserData
201,68be9dcda50c0ac555a4a04e6648283c1ee80cc5,ChooseTypeAndAccountActivity.java,"@@ -396,7 +396,7 @@ public class ChooseTypeAndAccountActivity extends Activity
                 mExistingAccounts = AccountManager.get(this).getAccountsForPackage(mCallingPackage,
                         mCallingUid);
                 intent.setFlags(intent.getFlags() & ~Intent.FLAG_ACTIVITY_NEW_TASK);
-                startActivityForResult(intent, REQUEST_ADD_ACCOUNT);
+                startActivityForResult(new Intent(intent), REQUEST_ADD_ACCOUNT);
                 return;
             }
         } catch (OperationCanceledException e) {
",1,1,ChooseTypeAndAccountActivity::run
202,fff7a19e27e1026ad9a20a80d60a809343c6bc34,NotificationManagerService.java,"@@ -4812,7 +4812,16 @@ public class NotificationManagerService extends SystemService {
             }
             enforcePolicyAccess(Binder.getCallingUid(), ""addAutomaticZenRule"");
 
-            return mZenModeHelper.addAutomaticZenRule(pkg, automaticZenRule,
+            // If the calling app is the system (from any user), take the package name from the
+            // rule's owner rather than from the caller's package.
+            String rulePkg = pkg;
+            if (isCallingAppIdSystem()) {
+                if (automaticZenRule.getOwner() != null) {
+                    rulePkg = automaticZenRule.getOwner().getPackageName();
+                }
+            }
+
+            return mZenModeHelper.addAutomaticZenRule(rulePkg, automaticZenRule,
                     ""addAutomaticZenRule"");
         }
 
@@ -9312,6 +9321,12 @@ public class NotificationManagerService extends SystemService {
         return uid == Process.SYSTEM_UID;
     }
 
+    protected boolean isCallingAppIdSystem() {
+        final int uid = Binder.getCallingUid();
+        final int appid = UserHandle.getAppId(uid);
+        return appid == Process.SYSTEM_UID;
+    }
+
     protected boolean isUidSystemOrPhone(int uid) {
         final int appid = UserHandle.getAppId(uid);
         return (appid == Process.SYSTEM_UID || appid == Process.PHONE_UID
",16,1,"NotificationManagerService::Stub, NotificationManagerService::isCallingAppIdSystem"
203,fff7a19e27e1026ad9a20a80d60a809343c6bc34,ZenModeHelper.java,"@@ -310,7 +310,7 @@ public class ZenModeHelper {
 
     public String addAutomaticZenRule(String pkg, AutomaticZenRule automaticZenRule,
             String reason) {
-        if (!isSystemRule(automaticZenRule)) {
+        if (!ZenModeConfig.SYSTEM_AUTHORITY.equals(pkg)) {
             PackageItemInfo component = getServiceInfo(automaticZenRule.getOwner());
             if (component == null) {
                 component = getActivityInfo(automaticZenRule.getConfigurationActivity());
@@ -566,11 +566,6 @@ public class ZenModeHelper {
         }
     }
 
-    private boolean isSystemRule(AutomaticZenRule rule) {
-        return rule.getOwner() != null
-                && ZenModeConfig.SYSTEM_AUTHORITY.equals(rule.getOwner().getPackageName());
-    }
-
     private ServiceInfo getServiceInfo(ComponentName owner) {
         Intent queryIntent = new Intent();
         queryIntent.setComponent(owner);
",1,6,"ZenModeHelper::addAutomaticZenRule, ZenModeHelper::isSystemRule"
204,fff7a19e27e1026ad9a20a80d60a809343c6bc34,NotificationManagerServiceTest.java,"@@ -340,6 +340,7 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {
     private static class TestableNotificationManagerService extends NotificationManagerService {
         int countSystemChecks = 0;
         boolean isSystemUid = true;
+        boolean isSystemAppId = true;
         int countLogSmartSuggestionsVisible = 0;
         @Nullable
         NotificationAssistantAccessGrantedCallback mNotificationAssistantAccessGrantedCallback;
@@ -359,6 +360,12 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {
             return isSystemUid;
         }
 
+        @Override
+        protected boolean isCallingAppIdSystem() {
+            countSystemChecks++;
+            return isSystemUid || isSystemAppId;
+        }
+
         @Override
         protected boolean isCallerSystemOrPhone() {
             countSystemChecks++;
@@ -6748,6 +6755,65 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {
         mBinderService.addAutomaticZenRule(rule, mContext.getPackageName());
     }
 
+    @Test
+    public void testAddAutomaticZenRule_systemCallTakesPackageFromOwner() throws Exception {
+        mService.isSystemUid = true;
+        ZenModeHelper mockZenModeHelper = mock(ZenModeHelper.class);
+        when(mConditionProviders.isPackageOrComponentAllowed(anyString(), anyInt()))
+                .thenReturn(true);
+        mService.setZenHelper(mockZenModeHelper);
+        ComponentName owner = new ComponentName(""android"", ""ProviderName"");
+        ZenPolicy zenPolicy = new ZenPolicy.Builder().allowAlarms(true).build();
+        boolean isEnabled = true;
+        AutomaticZenRule rule = new AutomaticZenRule(""test"", owner, owner, mock(Uri.class),
+                zenPolicy, NotificationManager.INTERRUPTION_FILTER_PRIORITY, isEnabled);
+        mBinderService.addAutomaticZenRule(rule, ""com.android.settings"");
+
+        // verify that zen mode helper gets passed in a package name of ""android""
+        verify(mockZenModeHelper).addAutomaticZenRule(eq(""android""), eq(rule), anyString());
+    }
+
+    @Test
+    public void testAddAutomaticZenRule_systemAppIdCallTakesPackageFromOwner() throws Exception {
+        // The multi-user case: where the calling uid doesn't match the system uid, but the calling
+        // *appid* is the system.
+        mService.isSystemUid = false;
+        mService.isSystemAppId = true;
+        ZenModeHelper mockZenModeHelper = mock(ZenModeHelper.class);
+        when(mConditionProviders.isPackageOrComponentAllowed(anyString(), anyInt()))
+                .thenReturn(true);
+        mService.setZenHelper(mockZenModeHelper);
+        ComponentName owner = new ComponentName(""android"", ""ProviderName"");
+        ZenPolicy zenPolicy = new ZenPolicy.Builder().allowAlarms(true).build();
+        boolean isEnabled = true;
+        AutomaticZenRule rule = new AutomaticZenRule(""test"", owner, owner, mock(Uri.class),
+                zenPolicy, NotificationManager.INTERRUPTION_FILTER_PRIORITY, isEnabled);
+        mBinderService.addAutomaticZenRule(rule, ""com.android.settings"");
+
+        // verify that zen mode helper gets passed in a package name of ""android""
+        verify(mockZenModeHelper).addAutomaticZenRule(eq(""android""), eq(rule), anyString());
+    }
+
+    @Test
+    public void testAddAutomaticZenRule_nonSystemCallTakesPackageFromArg() throws Exception {
+        mService.isSystemUid = false;
+        mService.isSystemAppId = false;
+        ZenModeHelper mockZenModeHelper = mock(ZenModeHelper.class);
+        when(mConditionProviders.isPackageOrComponentAllowed(anyString(), anyInt()))
+                .thenReturn(true);
+        mService.setZenHelper(mockZenModeHelper);
+        ComponentName owner = new ComponentName(""android"", ""ProviderName"");
+        ZenPolicy zenPolicy = new ZenPolicy.Builder().allowAlarms(true).build();
+        boolean isEnabled = true;
+        AutomaticZenRule rule = new AutomaticZenRule(""test"", owner, owner, mock(Uri.class),
+                zenPolicy, NotificationManager.INTERRUPTION_FILTER_PRIORITY, isEnabled);
+        mBinderService.addAutomaticZenRule(rule, ""another.package"");
+
+        // verify that zen mode helper gets passed in the package name from the arg, not the owner
+        verify(mockZenModeHelper).addAutomaticZenRule(
+                eq(""another.package""), eq(rule), anyString());
+    }
+
     @Test
     public void testAreNotificationsEnabledForPackage_crossUser() throws Exception {
         try {
",66,0,"NotificationManagerServiceTest::TestableNotificationManagerService::isCallingAppIdSystem, NotificationManagerServiceTest::testAddAutomaticZenRule_systemAppIdCallTakesPackageFromOwner, NotificationManagerServiceTest::testAddAutomaticZenRule_systemCallTakesPackageFromOwner, NotificationManagerServiceTest::testAddAutomaticZenRule_nonSystemCallTakesPackageFromArg"
205,fff7a19e27e1026ad9a20a80d60a809343c6bc34,ZenModeHelperTest.java,"@@ -1667,6 +1667,36 @@ public class ZenModeHelperTest extends UiServiceTestCase {
         }
     }
 
+    @Test
+    public void testAddAutomaticZenRule_claimedSystemOwner() {
+        // Make sure anything that claims to have a ""system"" owner but not actually part of the
+        // system package still gets limited on number of rules
+        for (int i = 0; i < RULE_LIMIT_PER_PACKAGE; i++) {
+            ScheduleInfo si = new ScheduleInfo();
+            si.startHour = i;
+            AutomaticZenRule zenRule = new AutomaticZenRule(""name"" + i,
+                    new ComponentName(""android"", ""ScheduleConditionProvider"" + i),
+                    null, // configuration activity
+                    ZenModeConfig.toScheduleConditionId(si),
+                    new ZenPolicy.Builder().build(),
+                    NotificationManager.INTERRUPTION_FILTER_PRIORITY, true);
+            String id = mZenModeHelperSpy.addAutomaticZenRule(""pkgname"", zenRule, ""test"");
+            assertNotNull(id);
+        }
+        try {
+            AutomaticZenRule zenRule = new AutomaticZenRule(""name"",
+                    new ComponentName(""android"", ""ScheduleConditionProviderFinal""),
+                    null, // configuration activity
+                    ZenModeConfig.toScheduleConditionId(new ScheduleInfo()),
+                    new ZenPolicy.Builder().build(),
+                    NotificationManager.INTERRUPTION_FILTER_PRIORITY, true);
+            String id = mZenModeHelperSpy.addAutomaticZenRule(""pkgname"", zenRule, ""test"");
+            fail(""allowed too many rules to be created"");
+        } catch (IllegalArgumentException e) {
+            // yay
+        }
+    }
+
     @Test
     public void testAddAutomaticZenRule_CA() {
         AutomaticZenRule zenRule = new AutomaticZenRule(""name"",
",30,0,ZenModeHelperTest::testAddAutomaticZenRule_claimedSystemOwner
206,693e82f72cdf40d65a151c24e9168f345ee551af,AppOpsManager.java,"@@ -8888,8 +8888,9 @@ public class AppOpsManager {
      */
     public int startProxyOpNoThrow(int op, @NonNull AttributionSource attributionSource,
             @Nullable String message, boolean skipProxyOperation) {
-        return startProxyOpNoThrow(op, attributionSource, message, skipProxyOperation,
-                ATTRIBUTION_FLAGS_NONE, ATTRIBUTION_FLAGS_NONE, ATTRIBUTION_CHAIN_ID_NONE);
+        return startProxyOpNoThrow(attributionSource.getToken(), op, attributionSource, message,
+                skipProxyOperation, ATTRIBUTION_FLAGS_NONE, ATTRIBUTION_FLAGS_NONE,
+                ATTRIBUTION_CHAIN_ID_NONE);
     }
 
     /**
@@ -8901,7 +8902,8 @@ public class AppOpsManager {
      *
      * @hide
      */
-    public int startProxyOpNoThrow(int op, @NonNull AttributionSource attributionSource,
+    public int startProxyOpNoThrow(@NonNull IBinder clientId, int op,
+            @NonNull AttributionSource attributionSource,
             @Nullable String message, boolean skipProxyOperation, @AttributionFlags
             int proxyAttributionFlags, @AttributionFlags int proxiedAttributionFlags,
             int attributionChainId) {
@@ -8919,7 +8921,7 @@ public class AppOpsManager {
                 }
             }
 
-            SyncNotedAppOp syncOp = mService.startProxyOperation(op,
+            SyncNotedAppOp syncOp = mService.startProxyOperation(clientId, op,
                     attributionSource, false, collectionMode == COLLECT_ASYNC, message,
                     shouldCollectMessage, skipProxyOperation, proxyAttributionFlags,
                     proxiedAttributionFlags, attributionChainId);
@@ -9017,9 +9019,10 @@ public class AppOpsManager {
      */
     public void finishProxyOp(@NonNull String op, int proxiedUid,
             @NonNull String proxiedPackageName, @Nullable String proxiedAttributionTag) {
-        finishProxyOp(op, new AttributionSource(mContext.getAttributionSource(),
+        IBinder token = mContext.getAttributionSource().getToken();
+        finishProxyOp(token, op, new AttributionSource(mContext.getAttributionSource(),
                 new AttributionSource(proxiedUid, proxiedPackageName,  proxiedAttributionTag,
-                        mContext.getAttributionSource().getToken())), /*skipProxyOperation*/ false);
+                        token)), /*skipProxyOperation*/ false);
     }
 
     /**
@@ -9034,10 +9037,11 @@ public class AppOpsManager {
      *
      * @hide
      */
-    public void finishProxyOp(@NonNull String op, @NonNull AttributionSource attributionSource,
-            boolean skipProxyOperation) {
+    public void finishProxyOp(@NonNull IBinder clientId, @NonNull String op,
+            @NonNull AttributionSource attributionSource, boolean skipProxyOperation) {
         try {
-            mService.finishProxyOperation(strOpToOp(op), attributionSource, skipProxyOperation);
+            mService.finishProxyOperation(clientId, strOpToOp(op), attributionSource,
+                    skipProxyOperation);
         } catch (RemoteException e) {
             throw e.rethrowFromSystemServer();
         }
",13,9,"AppOpsManager::startProxyOpNoThrow, AppOpsManager::startProxyOpNoThrow, AppOpsManager::finishProxyOp, AppOpsManager::startProxyOpNoThrow, AppOpsManager::finishProxyOp, AppOpsManager::finishProxyOp"
207,693e82f72cdf40d65a151c24e9168f345ee551af,AppOpsManagerInternal.java,"@@ -26,13 +26,11 @@ import android.util.SparseArray;
 import android.util.SparseIntArray;
 
 import com.android.internal.app.IAppOpsCallback;
-import com.android.internal.util.function.DecFunction;
 import com.android.internal.util.function.HeptFunction;
 import com.android.internal.util.function.HexFunction;
 import com.android.internal.util.function.QuadFunction;
 import com.android.internal.util.function.QuintConsumer;
 import com.android.internal.util.function.QuintFunction;
-import com.android.internal.util.function.TriFunction;
 import com.android.internal.util.function.UndecFunction;
 
 /**
@@ -135,6 +133,7 @@ public abstract class AppOpsManagerInternal {
         /**
          * Allows overriding start proxy operation behavior.
          *
+         * @param clientId The client calling start, represented by an IBinder
          * @param code The op code to start.
          * @param attributionSource The permission identity of the caller.
          * @param startIfModeDefault Whether to start the op of the mode is default.
@@ -148,11 +147,12 @@ public abstract class AppOpsManagerInternal {
          * @param superImpl The super implementation.
          * @return The app op note result.
          */
-        SyncNotedAppOp startProxyOperation(int code, @NonNull AttributionSource attributionSource,
-                boolean startIfModeDefault, boolean shouldCollectAsyncNotedOp, String message,
-                boolean shouldCollectMessage, boolean skipProxyOperation, @AttributionFlags
-                int proxyAttributionFlags, @AttributionFlags int proxiedAttributionFlags,
-                int attributionChainId, @NonNull DecFunction<Integer, AttributionSource, Boolean,
+        SyncNotedAppOp startProxyOperation(@NonNull IBinder clientId, int code,
+                @NonNull AttributionSource attributionSource, boolean startIfModeDefault,
+                boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,
+                boolean skipProxyOperation, @AttributionFlags int proxyAttributionFlags,
+                @AttributionFlags int proxiedAttributionFlags, int attributionChainId,
+                @NonNull UndecFunction<IBinder, Integer, AttributionSource, Boolean,
                         Boolean, String, Boolean, Boolean, Integer, Integer, Integer,
                         SyncNotedAppOp> superImpl);
 
@@ -176,10 +176,15 @@ public abstract class AppOpsManagerInternal {
          *
          * @param code The op code to finish.
          * @param attributionSource The permission identity of the caller.
+         * @param skipProxyOperation Whether to skip the proxy in the proxy/proxied operation
+         * @param clientId The client calling finishProxyOperation
+         * @param superImpl The ""standard"" implementation to potentially call
          */
-        void finishProxyOperation(int code, @NonNull AttributionSource attributionSource,
+        void finishProxyOperation(@NonNull IBinder clientId, int code,
+                @NonNull AttributionSource attributionSource,
                 boolean skipProxyOperation,
-                @NonNull TriFunction<Integer, AttributionSource, Boolean, Void> superImpl);
+                @NonNull QuadFunction<IBinder, Integer, AttributionSource, Boolean,
+                        Void> superImpl);
     }
 
     /**
",14,9,
208,693e82f72cdf40d65a151c24e9168f345ee551af,ActivityManagerService.java,"@@ -351,12 +351,10 @@ import com.android.internal.util.FastPrintWriter;
 import com.android.internal.util.FrameworkStatsLog;
 import com.android.internal.util.MemInfoReader;
 import com.android.internal.util.Preconditions;
-import com.android.internal.util.function.DecFunction;
 import com.android.internal.util.function.HeptFunction;
 import com.android.internal.util.function.HexFunction;
 import com.android.internal.util.function.QuadFunction;
 import com.android.internal.util.function.QuintFunction;
-import com.android.internal.util.function.TriFunction;
 import com.android.internal.util.function.UndecFunction;
 import com.android.server.AlarmManagerInternal;
 import com.android.server.DeviceIdleInternal;
@@ -17128,19 +17126,20 @@ public class ActivityManagerService extends IActivityManager.Stub
         }
 
         @Override
-        public SyncNotedAppOp startProxyOperation(int code,
+        public SyncNotedAppOp startProxyOperation(@NonNull IBinder clientId, int code,
                 @NonNull AttributionSource attributionSource, boolean startIfModeDefault,
                 boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,
                 boolean skipProxyOperation, @AttributionFlags int proxyAttributionFlags,
                 @AttributionFlags int proxiedAttributionFlags, int attributionChainId,
-                @NonNull DecFunction<Integer, AttributionSource, Boolean, Boolean, String, Boolean,
-                        Boolean, Integer, Integer, Integer, SyncNotedAppOp> superImpl) {
+                @NonNull UndecFunction<IBinder, Integer, AttributionSource,
+                        Boolean, Boolean, String, Boolean, Boolean, Integer, Integer, Integer,
+                        SyncNotedAppOp> superImpl) {
             if (attributionSource.getUid() == mTargetUid && isTargetOp(code)) {
                 final int shellUid = UserHandle.getUid(UserHandle.getUserId(
                         attributionSource.getUid()), Process.SHELL_UID);
                 final long identity = Binder.clearCallingIdentity();
                 try {
-                    return superImpl.apply(code, new AttributionSource(shellUid,
+                    return superImpl.apply(clientId, code, new AttributionSource(shellUid,
                             ""com.android.shell"", attributionSource.getAttributionTag(),
                             attributionSource.getToken(), attributionSource.getNext()),
                             startIfModeDefault, shouldCollectAsyncNotedOp, message,
@@ -17150,21 +17149,22 @@ public class ActivityManagerService extends IActivityManager.Stub
                     Binder.restoreCallingIdentity(identity);
                 }
             }
-            return superImpl.apply(code, attributionSource, startIfModeDefault,
+            return superImpl.apply(clientId, code, attributionSource, startIfModeDefault,
                     shouldCollectAsyncNotedOp, message, shouldCollectMessage, skipProxyOperation,
                     proxyAttributionFlags, proxiedAttributionFlags, attributionChainId);
         }
 
         @Override
-        public void finishProxyOperation(int code, @NonNull AttributionSource attributionSource,
-                boolean skipProxyOperation, @NonNull TriFunction<Integer, AttributionSource,
-                        Boolean, Void> superImpl) {
+        public void finishProxyOperation(@NonNull IBinder clientId, int code,
+                @NonNull AttributionSource attributionSource, boolean skipProxyOperation,
+                @NonNull QuadFunction<IBinder, Integer, AttributionSource, Boolean,
+                        Void> superImpl) {
             if (attributionSource.getUid() == mTargetUid && isTargetOp(code)) {
                 final int shellUid = UserHandle.getUid(UserHandle.getUserId(
                         attributionSource.getUid()), Process.SHELL_UID);
                 final long identity = Binder.clearCallingIdentity();
                 try {
-                    superImpl.apply(code, new AttributionSource(shellUid,
+                    superImpl.apply(clientId, code, new AttributionSource(shellUid,
                             ""com.android.shell"", attributionSource.getAttributionTag(),
                             attributionSource.getToken(), attributionSource.getNext()),
                             skipProxyOperation);
@@ -17172,7 +17172,7 @@ public class ActivityManagerService extends IActivityManager.Stub
                     Binder.restoreCallingIdentity(identity);
                 }
             }
-            superImpl.apply(code, attributionSource, skipProxyOperation);
+            superImpl.apply(clientId, code, attributionSource, skipProxyOperation);
         }
 
         private boolean isTargetOp(int code) {
",12,12,"ActivityManagerService::ShellDelegate::finishProxyOperation, ActivityManagerService::ShellDelegate::startProxyOperation, ActivityManagerService::ShellDelegate::finishProxyOperation, ActivityManagerService::ShellDelegate::startProxyOperation"
209,693e82f72cdf40d65a151c24e9168f345ee551af,AppOpsService.java,"@@ -3839,18 +3839,18 @@ public class AppOpsService extends IAppOpsService.Stub {
     }
 
     @Override
-    public SyncNotedAppOp startProxyOperation(int code,
+    public SyncNotedAppOp startProxyOperation(@NonNull IBinder clientId, int code,
             @NonNull AttributionSource attributionSource, boolean startIfModeDefault,
             boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,
             boolean skipProxyOperation, @AttributionFlags int proxyAttributionFlags,
             @AttributionFlags int proxiedAttributionFlags, int attributionChainId) {
-        return mCheckOpsDelegateDispatcher.startProxyOperation(code, attributionSource,
+        return mCheckOpsDelegateDispatcher.startProxyOperation(clientId, code, attributionSource,
                 startIfModeDefault, shouldCollectAsyncNotedOp, message, shouldCollectMessage,
                 skipProxyOperation, proxyAttributionFlags, proxiedAttributionFlags,
                 attributionChainId);
     }
 
-    private SyncNotedAppOp startProxyOperationImpl(int code,
+    private SyncNotedAppOp startProxyOperationImpl(@NonNull IBinder clientId, int code,
             @NonNull AttributionSource attributionSource,
             boolean startIfModeDefault, boolean shouldCollectAsyncNotedOp, String message,
             boolean shouldCollectMessage, boolean skipProxyOperation, @AttributionFlags
@@ -3859,11 +3859,9 @@ public class AppOpsService extends IAppOpsService.Stub {
         final int proxyUid = attributionSource.getUid();
         final String proxyPackageName = attributionSource.getPackageName();
         final String proxyAttributionTag = attributionSource.getAttributionTag();
-        final IBinder proxyToken = attributionSource.getToken();
         final int proxiedUid = attributionSource.getNextUid();
         final String proxiedPackageName = attributionSource.getNextPackageName();
         final String proxiedAttributionTag = attributionSource.getNextAttributionTag();
-        final IBinder proxiedToken = attributionSource.getNextToken();
 
         verifyIncomingProxyUid(attributionSource);
         verifyIncomingOp(code);
@@ -3902,7 +3900,7 @@ public class AppOpsService extends IAppOpsService.Stub {
 
         if (!skipProxyOperation) {
             // Test if the proxied operation will succeed before starting the proxy operation
-            final SyncNotedAppOp testProxiedOp = startOperationUnchecked(proxiedToken, code,
+            final SyncNotedAppOp testProxiedOp = startOperationUnchecked(clientId, code,
                     proxiedUid, resolvedProxiedPackageName, proxiedAttributionTag, proxyUid,
                     resolvedProxyPackageName, proxyAttributionTag, proxiedFlags, startIfModeDefault,
                     shouldCollectAsyncNotedOp, message, shouldCollectMessage,
@@ -3914,7 +3912,7 @@ public class AppOpsService extends IAppOpsService.Stub {
             final int proxyFlags = isProxyTrusted ? AppOpsManager.OP_FLAG_TRUSTED_PROXY
                     : AppOpsManager.OP_FLAG_UNTRUSTED_PROXY;
 
-            final SyncNotedAppOp proxyAppOp = startOperationUnchecked(proxyToken, code, proxyUid,
+            final SyncNotedAppOp proxyAppOp = startOperationUnchecked(clientId, code, proxyUid,
                     resolvedProxyPackageName, proxyAttributionTag, Process.INVALID_UID, null, null,
                     proxyFlags, startIfModeDefault, !isProxyTrusted, ""proxy "" + message,
                     shouldCollectMessage, proxyAttributionFlags, attributionChainId,
@@ -3924,7 +3922,7 @@ public class AppOpsService extends IAppOpsService.Stub {
             }
         }
 
-        return startOperationUnchecked(proxiedToken, code, proxiedUid, resolvedProxiedPackageName,
+        return startOperationUnchecked(clientId, code, proxiedUid, resolvedProxiedPackageName,
                 proxiedAttributionTag, proxyUid, resolvedProxyPackageName, proxyAttributionTag,
                 proxiedFlags, startIfModeDefault, shouldCollectAsyncNotedOp, message,
                 shouldCollectMessage, proxiedAttributionFlags, attributionChainId,
@@ -4065,22 +4063,20 @@ public class AppOpsService extends IAppOpsService.Stub {
     }
 
     @Override
-    public void finishProxyOperation(int code, @NonNull AttributionSource attributionSource,
-            boolean skipProxyOperation) {
-        mCheckOpsDelegateDispatcher.finishProxyOperation(code, attributionSource,
+    public void finishProxyOperation(@NonNull IBinder clientId, int code,
+            @NonNull AttributionSource attributionSource, boolean skipProxyOperation) {
+        mCheckOpsDelegateDispatcher.finishProxyOperation(clientId, code, attributionSource,
                 skipProxyOperation);
     }
 
-    private Void finishProxyOperationImpl(int code, @NonNull AttributionSource attributionSource,
-            boolean skipProxyOperation) {
+    private Void finishProxyOperationImpl(IBinder clientId, int code,
+            @NonNull AttributionSource attributionSource, boolean skipProxyOperation) {
         final int proxyUid = attributionSource.getUid();
         final String proxyPackageName = attributionSource.getPackageName();
         final String proxyAttributionTag = attributionSource.getAttributionTag();
-        final IBinder proxyToken = attributionSource.getToken();
         final int proxiedUid = attributionSource.getNextUid();
         final String proxiedPackageName = attributionSource.getNextPackageName();
         final String proxiedAttributionTag = attributionSource.getNextAttributionTag();
-        final IBinder proxiedToken = attributionSource.getNextToken();
 
         skipProxyOperation = skipProxyOperation
                 && isCallerAndAttributionTrusted(attributionSource);
@@ -4097,7 +4093,7 @@ public class AppOpsService extends IAppOpsService.Stub {
         }
 
         if (!skipProxyOperation) {
-            finishOperationUnchecked(proxyToken, code, proxyUid, resolvedProxyPackageName,
+            finishOperationUnchecked(clientId, code, proxyUid, resolvedProxyPackageName,
                     proxyAttributionTag);
         }
 
@@ -4107,7 +4103,7 @@ public class AppOpsService extends IAppOpsService.Stub {
             return null;
         }
 
-        finishOperationUnchecked(proxiedToken, code, proxiedUid, resolvedProxiedPackageName,
+        finishOperationUnchecked(clientId, code, proxiedUid, resolvedProxiedPackageName,
                 proxiedAttributionTag);
 
         return null;
@@ -7642,42 +7638,42 @@ public class AppOpsService extends IAppOpsService.Stub {
                     attributionFlags, attributionChainId, AppOpsService.this::startOperationImpl);
         }
 
-        public SyncNotedAppOp startProxyOperation(int code,
+        public SyncNotedAppOp startProxyOperation(@NonNull IBinder clientId, int code,
                 @NonNull AttributionSource attributionSource, boolean startIfModeDefault,
                 boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,
                 boolean skipProxyOperation, @AttributionFlags int proxyAttributionFlags,
                 @AttributionFlags int proxiedAttributionFlags, int attributionChainId) {
             if (mPolicy != null) {
                 if (mCheckOpsDelegate != null) {
-                    return mPolicy.startProxyOperation(code, attributionSource,
+                    return mPolicy.startProxyOperation(clientId, code, attributionSource,
                             startIfModeDefault, shouldCollectAsyncNotedOp, message,
                             shouldCollectMessage, skipProxyOperation, proxyAttributionFlags,
                             proxiedAttributionFlags, attributionChainId,
                             this::startDelegateProxyOperationImpl);
                 } else {
-                    return mPolicy.startProxyOperation(code, attributionSource,
+                    return mPolicy.startProxyOperation(clientId, code, attributionSource,
                             startIfModeDefault, shouldCollectAsyncNotedOp, message,
                             shouldCollectMessage, skipProxyOperation, proxyAttributionFlags,
                             proxiedAttributionFlags, attributionChainId,
                             AppOpsService.this::startProxyOperationImpl);
                 }
             } else if (mCheckOpsDelegate != null) {
-                return startDelegateProxyOperationImpl(code, attributionSource,
+                return startDelegateProxyOperationImpl(clientId, code, attributionSource,
                         startIfModeDefault, shouldCollectAsyncNotedOp, message,
                         shouldCollectMessage, skipProxyOperation, proxyAttributionFlags,
                         proxiedAttributionFlags, attributionChainId);
             }
-            return startProxyOperationImpl(code, attributionSource, startIfModeDefault,
+            return startProxyOperationImpl(clientId, code, attributionSource, startIfModeDefault,
                     shouldCollectAsyncNotedOp, message, shouldCollectMessage, skipProxyOperation,
                     proxyAttributionFlags, proxiedAttributionFlags, attributionChainId);
         }
 
-        private SyncNotedAppOp startDelegateProxyOperationImpl(int code,
+        private SyncNotedAppOp startDelegateProxyOperationImpl(@NonNull IBinder clientId, int code,
                 @NonNull AttributionSource attributionSource, boolean startIfModeDefault,
                 boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,
                 boolean skipProxyOperation, @AttributionFlags int proxyAttributionFlags,
                 @AttributionFlags int proxiedAttributionFlsgs, int attributionChainId) {
-            return mCheckOpsDelegate.startProxyOperation(code, attributionSource,
+            return mCheckOpsDelegate.startProxyOperation(clientId, code, attributionSource,
                     startIfModeDefault, shouldCollectAsyncNotedOp, message, shouldCollectMessage,
                     skipProxyOperation, proxyAttributionFlags, proxiedAttributionFlsgs,
                     attributionChainId, AppOpsService.this::startProxyOperationImpl);
@@ -7706,27 +7702,28 @@ public class AppOpsService extends IAppOpsService.Stub {
                     AppOpsService.this::finishOperationImpl);
         }
 
-        public void finishProxyOperation(int code,
+        public void finishProxyOperation(@NonNull IBinder clientId, int code,
                 @NonNull AttributionSource attributionSource, boolean skipProxyOperation) {
             if (mPolicy != null) {
                 if (mCheckOpsDelegate != null) {
-                    mPolicy.finishProxyOperation(code, attributionSource,
+                    mPolicy.finishProxyOperation(clientId, code, attributionSource,
                             skipProxyOperation, this::finishDelegateProxyOperationImpl);
                 } else {
-                    mPolicy.finishProxyOperation(code, attributionSource,
+                    mPolicy.finishProxyOperation(clientId, code, attributionSource,
                             skipProxyOperation, AppOpsService.this::finishProxyOperationImpl);
                 }
             } else if (mCheckOpsDelegate != null) {
-                finishDelegateProxyOperationImpl(code, attributionSource, skipProxyOperation);
+                finishDelegateProxyOperationImpl(clientId, code, attributionSource,
+                        skipProxyOperation);
             } else {
-                finishProxyOperationImpl(code, attributionSource, skipProxyOperation);
+                finishProxyOperationImpl(clientId, code, attributionSource, skipProxyOperation);
             }
         }
 
-        private Void finishDelegateProxyOperationImpl(int code,
+        private Void finishDelegateProxyOperationImpl(@NonNull IBinder clientId, int code,
                 @NonNull AttributionSource attributionSource, boolean skipProxyOperation) {
-            mCheckOpsDelegate.finishProxyOperation(code, attributionSource, skipProxyOperation,
-                    AppOpsService.this::finishProxyOperationImpl);
+            mCheckOpsDelegate.finishProxyOperation(clientId, code, attributionSource,
+                    skipProxyOperation, AppOpsService.this::finishProxyOperationImpl);
             return null;
         }
     }
",29,32,"AppOpsService::CheckOpsDelegateDispatcher::startProxyOperation, AppOpsService::startProxyOperation, AppOpsService::finishProxyOperation, AppOpsService::finishProxyOperation, AppOpsService::startProxyOperation, AppOpsService::CheckOpsDelegateDispatcher::startDelegateProxyOperationImpl, AppOpsService::CheckOpsDelegateDispatcher::finishDelegateProxyOperationImpl, AppOpsService::finishProxyOperationImpl, AppOpsService::CheckOpsDelegateDispatcher::startProxyOperation, AppOpsService::startProxyOperationImpl, AppOpsService::CheckOpsDelegateDispatcher::startDelegateProxyOperationImpl, AppOpsService::finishProxyOperationImpl, AppOpsService::CheckOpsDelegateDispatcher::finishDelegateProxyOperationImpl, AppOpsService::startProxyOperationImpl, AppOpsService::CheckOpsDelegateDispatcher::finishProxyOperation, AppOpsService::CheckOpsDelegateDispatcher::finishProxyOperation"
210,693e82f72cdf40d65a151c24e9168f345ee551af,PermissionManagerService.java,"@@ -5650,7 +5650,7 @@ public class PermissionManagerService extends IPermissionManager.Stub {
                     if (resolvedPackageName == null) {
                         return;
                     }
-                    appOpsManager.finishOp(accessorSource.getToken(), op,
+                    appOpsManager.finishOp(attributionSourceState.token, op,
                             accessorSource.getUid(), resolvedPackageName,
                             accessorSource.getAttributionTag());
                 } else {
@@ -5659,8 +5659,9 @@ public class PermissionManagerService extends IPermissionManager.Stub {
                     if (resolvedAttributionSource.getPackageName() == null) {
                         return;
                     }
-                    appOpsManager.finishProxyOp(AppOpsManager.opToPublicName(op),
-                            resolvedAttributionSource, skipCurrentFinish);
+                    appOpsManager.finishProxyOp(attributionSourceState.token,
+                            AppOpsManager.opToPublicName(op), resolvedAttributionSource,
+                            skipCurrentFinish);
                 }
 
                 if (next == null || next.getNext() == null) {
@@ -5770,10 +5771,11 @@ public class PermissionManagerService extends IPermissionManager.Stub {
                         && next.getNext() == null);
                 final boolean selfAccess = singleReceiverFromDatasource || next == null;
 
-                final int opMode = performOpTransaction(context, op, current, message,
-                        forDataDelivery, /*startDataDelivery*/ false, skipCurrentChecks,
-                        selfAccess, singleReceiverFromDatasource, AppOpsManager.OP_NONE,
-                        AppOpsManager.ATTRIBUTION_FLAGS_NONE, AppOpsManager.ATTRIBUTION_FLAGS_NONE,
+                final int opMode = performOpTransaction(context, attributionSource.getToken(), op,
+                        current, message, forDataDelivery, /*startDataDelivery*/ false,
+                        skipCurrentChecks, selfAccess, singleReceiverFromDatasource,
+                        AppOpsManager.OP_NONE, AppOpsManager.ATTRIBUTION_FLAGS_NONE,
+                        AppOpsManager.ATTRIBUTION_FLAGS_NONE,
                         AppOpsManager.ATTRIBUTION_CHAIN_ID_NONE);
 
                 switch (opMode) {
@@ -5875,10 +5877,10 @@ public class PermissionManagerService extends IPermissionManager.Stub {
                         attributionSource, next, fromDatasource, startDataDelivery, selfAccess,
                         isLinkTrusted) : ATTRIBUTION_FLAGS_NONE;
 
-                final int opMode = performOpTransaction(context, op, current, message,
-                        forDataDelivery, startDataDelivery, skipCurrentChecks, selfAccess,
-                        singleReceiverFromDatasource, attributedOp, proxyAttributionFlags,
-                        proxiedAttributionFlags, attributionChainId);
+                final int opMode = performOpTransaction(context, attributionSource.getToken(), op,
+                        current, message, forDataDelivery, startDataDelivery, skipCurrentChecks,
+                        selfAccess, singleReceiverFromDatasource, attributedOp,
+                        proxyAttributionFlags, proxiedAttributionFlags, attributionChainId);
 
                 switch (opMode) {
                     case AppOpsManager.MODE_ERRORED: {
@@ -6023,8 +6025,8 @@ public class PermissionManagerService extends IPermissionManager.Stub {
                         attributionSource, next, /*fromDatasource*/ false, startDataDelivery,
                         selfAccess, isLinkTrusted) : ATTRIBUTION_FLAGS_NONE;
 
-                final int opMode = performOpTransaction(context, op, current, message,
-                        forDataDelivery, startDataDelivery, skipCurrentChecks, selfAccess,
+                final int opMode = performOpTransaction(context, current.getToken(), op, current,
+                        message, forDataDelivery, startDataDelivery, skipCurrentChecks, selfAccess,
                         /*fromDatasource*/ false, AppOpsManager.OP_NONE, proxyAttributionFlags,
                         proxiedAttributionFlags, attributionChainId);
 
@@ -6046,7 +6048,8 @@ public class PermissionManagerService extends IPermissionManager.Stub {
         }
 
         @SuppressWarnings(""ConstantConditions"")
-        private static int performOpTransaction(@NonNull Context context, int op,
+        private static int performOpTransaction(@NonNull Context context,
+                @NonNull IBinder chainStartToken, int op,
                 @NonNull AttributionSource attributionSource, @Nullable String message,
                 boolean forDataDelivery, boolean startDataDelivery, boolean skipProxyOperation,
                 boolean selfAccess, boolean singleReceiverFromDatasource, int attributedOp,
@@ -6108,7 +6111,7 @@ public class PermissionManagerService extends IPermissionManager.Stub {
                 if (selfAccess) {
                     try {
                         startedOpResult = appOpsManager.startOpNoThrow(
-                                resolvedAttributionSource.getToken(), startedOp,
+                                chainStartToken, startedOp,
                                 resolvedAttributionSource.getUid(),
                                 resolvedAttributionSource.getPackageName(),
                                 /*startIfModeDefault*/ false,
@@ -6119,12 +6122,12 @@ public class PermissionManagerService extends IPermissionManager.Stub {
                                 + "" platform defined runtime permission ""
                                 + AppOpsManager.opToPermission(op) + "" while not having ""
                                 + Manifest.permission.UPDATE_APP_OPS_STATS);
-                        startedOpResult = appOpsManager.startProxyOpNoThrow(attributedOp,
-                                attributionSource, message, skipProxyOperation,
+                        startedOpResult = appOpsManager.startProxyOpNoThrow(chainStartToken,
+                                attributedOp, attributionSource, message, skipProxyOperation,
                                 proxyAttributionFlags, proxiedAttributionFlags, attributionChainId);
                     }
                 } else {
-                    startedOpResult = appOpsManager.startProxyOpNoThrow(startedOp,
+                    startedOpResult = appOpsManager.startProxyOpNoThrow(chainStartToken, startedOp,
                             resolvedAttributionSource, message, skipProxyOperation,
                             proxyAttributionFlags, proxiedAttributionFlags, attributionChainId);
                 }
",21,18,"PermissionManagerService::PermissionCheckerService::performOpTransaction, PermissionManagerService::PermissionCheckerService::finishDataDelivery, PermissionManagerService::PermissionCheckerService::checkOp, PermissionManagerService::PermissionCheckerService::checkAppOpPermission, PermissionManagerService::PermissionCheckerService::checkRuntimePermission, PermissionManagerService::PermissionCheckerService::performOpTransaction"
211,693e82f72cdf40d65a151c24e9168f345ee551af,AppOpsPolicy.java,"@@ -44,13 +44,11 @@ import android.util.Log;
 import android.util.SparseArray;
 
 import com.android.internal.annotations.GuardedBy;
-import com.android.internal.util.function.DecFunction;
 import com.android.internal.util.function.HeptFunction;
 import com.android.internal.util.function.HexFunction;
 import com.android.internal.util.function.QuadFunction;
 import com.android.internal.util.function.QuintConsumer;
 import com.android.internal.util.function.QuintFunction;
-import com.android.internal.util.function.TriFunction;
 import com.android.internal.util.function.UndecFunction;
 import com.android.server.LocalServices;
 
@@ -255,14 +253,14 @@ public final class AppOpsPolicy implements AppOpsManagerInternal.CheckOpsDelegat
     }
 
     @Override
-    public SyncNotedAppOp startProxyOperation(int code,
+    public SyncNotedAppOp startProxyOperation(@NonNull IBinder clientId, int code,
             @NonNull AttributionSource attributionSource, boolean startIfModeDefault,
             boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,
             boolean skipProxyOperation, @AttributionFlags int proxyAttributionFlags,
             @AttributionFlags int proxiedAttributionFlags, int attributionChainId,
-            @NonNull DecFunction<Integer, AttributionSource, Boolean, Boolean, String, Boolean,
-                    Boolean, Integer, Integer, Integer, SyncNotedAppOp> superImpl) {
-        return superImpl.apply(resolveDatasourceOp(code, attributionSource.getUid(),
+            @NonNull UndecFunction<IBinder, Integer, AttributionSource, Boolean, Boolean, String,
+                    Boolean, Boolean, Integer, Integer, Integer, SyncNotedAppOp> superImpl) {
+        return superImpl.apply(clientId, resolveDatasourceOp(code, attributionSource.getUid(),
                 attributionSource.getPackageName(), attributionSource.getAttributionTag()),
                 attributionSource, startIfModeDefault, shouldCollectAsyncNotedOp, message,
                 shouldCollectMessage, skipProxyOperation, proxyAttributionFlags,
@@ -278,10 +276,10 @@ public final class AppOpsPolicy implements AppOpsManagerInternal.CheckOpsDelegat
     }
 
     @Override
-    public void finishProxyOperation(int code, @NonNull AttributionSource attributionSource,
-            boolean skipProxyOperation, @NonNull TriFunction<Integer, AttributionSource,
-            Boolean, Void> superImpl) {
-        superImpl.apply(resolveDatasourceOp(code, attributionSource.getUid(),
+    public void finishProxyOperation(@NonNull IBinder clientId, int code,
+            @NonNull AttributionSource attributionSource, boolean skipProxyOperation,
+            @NonNull QuadFunction<IBinder, Integer, AttributionSource, Boolean, Void> superImpl) {
+        superImpl.apply(clientId, resolveDatasourceOp(code, attributionSource.getUid(),
                 attributionSource.getPackageName(), attributionSource.getAttributionTag()),
                 attributionSource, skipProxyOperation);
     }
",8,10,"AppOpsPolicy::startProxyOperation, AppOpsPolicy::startProxyOperation, AppOpsPolicy::finishProxyOperation, AppOpsPolicy::finishProxyOperation"
212,39bd18cfa37bcc403288bb6c7fb2219385405312,AppTaskImpl.java,"@@ -84,7 +84,7 @@ class AppTaskImpl extends IAppTask.Stub {
                     throw new IllegalArgumentException(""Unable to find task ID "" + mTaskId);
                 }
                 return mService.getRecentTasks().createRecentTaskInfo(task,
-                        false /* stripExtras */, true /* getTasksAllowed */);
+                        false /* stripExtras */);
             } finally {
                 Binder.restoreCallingIdentity(origId);
             }
",1,1,AppTaskImpl::getTaskInfo
213,39bd18cfa37bcc403288bb6c7fb2219385405312,RecentTasks.java,"@@ -974,7 +974,7 @@ class RecentTasks {
                 continue;
             }
 
-            res.add(createRecentTaskInfo(task, true /* stripExtras */, getTasksAllowed));
+            res.add(createRecentTaskInfo(task, true /* stripExtras */));
         }
         return res;
     }
@@ -1890,8 +1890,7 @@ class RecentTasks {
     /**
      * Creates a new RecentTaskInfo from a Task.
      */
-    ActivityManager.RecentTaskInfo createRecentTaskInfo(Task tr, boolean stripExtras,
-            boolean getTasksAllowed) {
+    ActivityManager.RecentTaskInfo createRecentTaskInfo(Task tr, boolean stripExtras) {
         final ActivityManager.RecentTaskInfo rti = new ActivityManager.RecentTaskInfo();
         // If the recent Task is detached, we consider it will be re-attached to the default
         // TaskDisplayArea because we currently only support recent overview in the default TDA.
@@ -1903,9 +1902,6 @@ class RecentTasks {
         rti.id = rti.isRunning ? rti.taskId : INVALID_TASK_ID;
         rti.persistentId = rti.taskId;
         rti.lastSnapshotData.set(tr.mLastTaskSnapshotData);
-        if (!getTasksAllowed) {
-            Task.trimIneffectiveInfo(tr, rti);
-        }
 
         // Fill in organized child task info for the task created by organizer.
         if (tr.mCreatedByOrganizer) {
",2,6,"RecentTasks::createRecentTaskInfo, RecentTasks::createRecentTaskInfo, RecentTasks::getRecentTasksImpl"
214,39bd18cfa37bcc403288bb6c7fb2219385405312,RunningTasks.java,"@@ -150,10 +150,6 @@ class RunningTasks {
         task.fillTaskInfo(rti, !mKeepIntentExtra);
         // Fill in some deprecated values
         rti.id = rti.taskId;
-
-        if (!mAllowed) {
-            Task.trimIneffectiveInfo(task, rti);
-        }
         return rti;
     }
 }
",0,4,RunningTasks::createRunningTaskInfo
215,39bd18cfa37bcc403288bb6c7fb2219385405312,Task.java,"@@ -3484,27 +3484,6 @@ class Task extends TaskFragment {
         info.mTopActivityLocusId = topRecord != null ? topRecord.getLocusId() : null;
     }
 
-    /**
-     * Removes the activity info if the activity belongs to a different uid, which is
-     * different from the app that hosts the task.
-     */
-    static void trimIneffectiveInfo(Task task, TaskInfo info) {
-        final ActivityRecord baseActivity = task.getActivity(r -> !r.finishing,
-                false /* traverseTopToBottom */);
-        final int baseActivityUid =
-                baseActivity != null ? baseActivity.getUid() : task.effectiveUid;
-
-        if (info.topActivityInfo != null
-                && task.effectiveUid != info.topActivityInfo.applicationInfo.uid) {
-            info.topActivity = null;
-            info.topActivityInfo = null;
-        }
-
-        if (task.effectiveUid != baseActivityUid) {
-            info.baseActivity = null;
-        }
-    }
-
     @Nullable PictureInPictureParams getPictureInPictureParams() {
         return getPictureInPictureParams(getTopMostTask());
     }
",0,21,Task::trimIneffectiveInfo
216,39bd18cfa37bcc403288bb6c7fb2219385405312,RecentTasksTest.java,"@@ -30,7 +30,6 @@ import static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;
 import static android.content.pm.ActivityInfo.LAUNCH_MULTIPLE;
 import static android.content.pm.ActivityInfo.LAUNCH_SINGLE_INSTANCE;
 import static android.content.res.Configuration.ORIENTATION_PORTRAIT;
-import static android.os.Process.NOBODY_UID;
 
 import static com.android.dx.mockito.inline.extended.ExtendedMockito.doNothing;
 import static com.android.dx.mockito.inline.extended.ExtendedMockito.doReturn;
@@ -1196,35 +1195,21 @@ public class RecentTasksTest extends WindowTestsBase {
 
     @Test
     public void testCreateRecentTaskInfo_detachedTask() {
-        final Task task = createTaskBuilder("".Task"").build();
-        new ActivityBuilder(mSupervisor.mService)
-                .setTask(task)
-                .setUid(NOBODY_UID)
-                .setComponent(new ComponentName(""com.foo"", "".BarActivity""))
-                .build();
+        final Task task = createTaskBuilder("".Task"").setCreateActivity(true).build();
         final TaskDisplayArea tda = task.getDisplayArea();
 
         assertTrue(task.isAttached());
         assertTrue(task.supportsMultiWindow());
 
-        RecentTaskInfo info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,
-                true /* getTasksAllowed */);
+        RecentTaskInfo info = mRecentTasks.createRecentTaskInfo(task, true);
 
         assertTrue(info.supportsMultiWindow);
         assertTrue(info.supportsSplitScreenMultiWindow);
 
-        info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,
-                false /* getTasksAllowed */);
-
-        assertTrue(info.topActivity == null);
-        assertTrue(info.topActivityInfo == null);
-        assertTrue(info.baseActivity == null);
-
         // The task can be put in split screen even if it is not attached now.
         task.removeImmediately();
 
-        info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,
-                true /* getTasksAllowed */);
+        info = mRecentTasks.createRecentTaskInfo(task, true);
 
         assertTrue(info.supportsMultiWindow);
         assertTrue(info.supportsSplitScreenMultiWindow);
@@ -1234,8 +1219,7 @@ public class RecentTasksTest extends WindowTestsBase {
         doReturn(false).when(tda).supportsNonResizableMultiWindow();
         doReturn(false).when(task).isResizeable();
 
-        info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,
-                true /* getTasksAllowed */);
+        info = mRecentTasks.createRecentTaskInfo(task, true);
 
         assertFalse(info.supportsMultiWindow);
         assertFalse(info.supportsSplitScreenMultiWindow);
@@ -1244,8 +1228,7 @@ public class RecentTasksTest extends WindowTestsBase {
         // the device supports it.
         doReturn(true).when(tda).supportsNonResizableMultiWindow();
 
-        info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,
-                true /* getTasksAllowed */);
+        info = mRecentTasks.createRecentTaskInfo(task, true);
 
         assertTrue(info.supportsMultiWindow);
         assertTrue(info.supportsSplitScreenMultiWindow);
",5,22,RecentTasksTest::testCreateRecentTaskInfo_detachedTask
217,13e194d35f19d15873aeb2551ba9186d76558b44,NotificationManagerService.java,"@@ -1951,7 +1951,6 @@ public class NotificationManagerService extends SystemService {
         }
     }
 
-    private LockPatternUtils mLockPatternUtils;
     private StrongAuthTracker mStrongAuthTracker;
 
     public NotificationManagerService(Context context) {
@@ -2168,7 +2167,6 @@ public class NotificationManagerService extends SystemService {
                 ServiceManager.getService(Context.PLATFORM_COMPAT_SERVICE));
 
         mUiHandler = new Handler(UiThread.get().getLooper());
-        mLockPatternUtils = new LockPatternUtils(getContext());
         mStrongAuthTracker = new StrongAuthTracker(getContext());
         String[] extractorNames;
         try {
@@ -2654,7 +2652,7 @@ public class NotificationManagerService extends SystemService {
                 bubbsExtractor.setShortcutHelper(mShortcutHelper);
             }
             registerNotificationPreferencesPullers();
-            mLockPatternUtils.registerStrongAuthTracker(mStrongAuthTracker);
+            new LockPatternUtils(getContext()).registerStrongAuthTracker(mStrongAuthTracker);
         } else if (phase == SystemService.PHASE_THIRD_PARTY_APPS_CAN_START) {
             // This observer will force an update when observe is called, causing us to
             // bind to listener services.
",1,3,"NotificationManagerService::onBootPhase, NotificationManagerService::init"
218,5676b94f5ff807eea35ebf63b97f83c3ffb2f7a1,NotificationManagerService.java,"@@ -1919,34 +1919,39 @@ public class NotificationManagerService extends SystemService {
             return (haystack & needle) != 0;
         }
 
-        public boolean isInLockDownMode() {
-            return mIsInLockDownMode;
+        // Return whether the user is in lockdown mode.
+        // If the flag is not set, we assume the user is not in lockdown.
+        public boolean isInLockDownMode(int userId) {
+            return mUserInLockDownMode.get(userId, false);
         }
 
         @Override
         public synchronized void onStrongAuthRequiredChanged(int userId) {
             boolean userInLockDownModeNext = containsFlag(getStrongAuthForUser(userId),
                     STRONG_AUTH_REQUIRED_AFTER_USER_LOCKDOWN);
-            mUserInLockDownMode.put(userId, userInLockDownModeNext);
-            boolean isInLockDownModeNext = mUserInLockDownMode.indexOfValue(true) != -1;
 
-            if (mIsInLockDownMode == isInLockDownModeNext) {
+            // Nothing happens if the lockdown mode of userId keeps the same.
+            if (userInLockDownModeNext == isInLockDownMode(userId)) {
                 return;
             }
 
-            if (isInLockDownModeNext) {
-                cancelNotificationsWhenEnterLockDownMode();
+            // When the lockdown mode is changed, we perform the following steps.
+            // If the userInLockDownModeNext is true, all the function calls to
+            // notifyPostedLocked and notifyRemovedLocked will not be executed.
+            // The cancelNotificationsWhenEnterLockDownMode calls notifyRemovedLocked
+            // and postNotificationsWhenExitLockDownMode calls notifyPostedLocked.
+            // So we shall call cancelNotificationsWhenEnterLockDownMode before
+            // we set mUserInLockDownMode as true.
+            // On the other hand, if the userInLockDownModeNext is false, we shall call
+            // postNotificationsWhenExitLockDownMode after we put false into mUserInLockDownMode
+            if (userInLockDownModeNext) {
+                cancelNotificationsWhenEnterLockDownMode(userId);
             }
 
-            // When the mIsInLockDownMode is true, both notifyPostedLocked and
-            // notifyRemovedLocked will be dismissed. So we shall call
-            // cancelNotificationsWhenEnterLockDownMode before we set mIsInLockDownMode
-            // as true and call postNotificationsWhenExitLockDownMode after we set
-            // mIsInLockDownMode as false.
-            mIsInLockDownMode = isInLockDownModeNext;
+            mUserInLockDownMode.put(userId, userInLockDownModeNext);
 
-            if (!isInLockDownModeNext) {
-                postNotificationsWhenExitLockDownMode();
+            if (!userInLockDownModeNext) {
+                postNotificationsWhenExitLockDownMode(userId);
             }
         }
     }
@@ -9285,11 +9290,14 @@ public class NotificationManagerService extends SystemService {
         }
     }
 
-    private void cancelNotificationsWhenEnterLockDownMode() {
+    private void cancelNotificationsWhenEnterLockDownMode(int userId) {
         synchronized (mNotificationLock) {
             int numNotifications = mNotificationList.size();
             for (int i = 0; i < numNotifications; i++) {
                 NotificationRecord rec = mNotificationList.get(i);
+                if (rec.getUser().getIdentifier() != userId) {
+                    continue;
+                }
                 mListeners.notifyRemovedLocked(rec, REASON_CANCEL_ALL,
                         rec.getStats());
             }
@@ -9297,14 +9305,23 @@ public class NotificationManagerService extends SystemService {
         }
     }
 
-    private void postNotificationsWhenExitLockDownMode() {
+    private void postNotificationsWhenExitLockDownMode(int userId) {
         synchronized (mNotificationLock) {
             int numNotifications = mNotificationList.size();
+            // Set the delay to spread out the burst of notifications.
+            long delay = 0;
             for (int i = 0; i < numNotifications; i++) {
                 NotificationRecord rec = mNotificationList.get(i);
-                mListeners.notifyPostedLocked(rec, rec);
+                if (rec.getUser().getIdentifier() != userId) {
+                    continue;
+                }
+                mHandler.postDelayed(() -> {
+                    synchronized (mNotificationLock) {
+                        mListeners.notifyPostedLocked(rec, rec);
+                    }
+                }, delay);
+                delay += 20;
             }
-
         }
     }
 
@@ -9502,12 +9519,15 @@ public class NotificationManagerService extends SystemService {
      * notifications visible to the given listener.
      */
     @GuardedBy(""mNotificationLock"")
-    private NotificationRankingUpdate makeRankingUpdateLocked(ManagedServiceInfo info) {
+    NotificationRankingUpdate makeRankingUpdateLocked(ManagedServiceInfo info) {
         final int N = mNotificationList.size();
         final ArrayList<NotificationListenerService.Ranking> rankings = new ArrayList<>();
 
         for (int i = 0; i < N; i++) {
             NotificationRecord record = mNotificationList.get(i);
+            if (isInLockDownMode(record.getUser().getIdentifier())) {
+                continue;
+            }
             if (!isVisibleToListener(record.getSbn(), record.getNotificationType(), info)) {
                 continue;
             }
@@ -9549,8 +9569,8 @@ public class NotificationManagerService extends SystemService {
                 rankings.toArray(new NotificationListenerService.Ranking[0]));
     }
 
-    boolean isInLockDownMode() {
-        return mStrongAuthTracker.isInLockDownMode();
+    boolean isInLockDownMode(int userId) {
+        return mStrongAuthTracker.isInLockDownMode(userId);
     }
 
     boolean hasCompanionDevice(ManagedServiceInfo info) {
@@ -10606,7 +10626,7 @@ public class NotificationManagerService extends SystemService {
         @GuardedBy(""mNotificationLock"")
         void notifyPostedLocked(NotificationRecord r, NotificationRecord old,
                 boolean notifyAllListeners) {
-            if (isInLockDownMode()) {
+            if (isInLockDownMode(r.getUser().getIdentifier())) {
                 return;
             }
 
@@ -10707,7 +10727,7 @@ public class NotificationManagerService extends SystemService {
         @GuardedBy(""mNotificationLock"")
         public void notifyRemovedLocked(NotificationRecord r, int reason,
                 NotificationStats notificationStats) {
-            if (isInLockDownMode()) {
+            if (isInLockDownMode(r.getUser().getIdentifier())) {
                 return;
             }
 
@@ -10756,10 +10776,6 @@ public class NotificationManagerService extends SystemService {
          */
         @GuardedBy(""mNotificationLock"")
         public void notifyRankingUpdateLocked(List<NotificationRecord> changedHiddenNotifications) {
-            if (isInLockDownMode()) {
-                return;
-            }
-
             boolean isHiddenRankingUpdate = changedHiddenNotifications != null
                     && changedHiddenNotifications.size() > 0;
             // TODO (b/73052211): if the ranking update changed the notification type,
",44,28,"NotificationManagerService::postNotificationsWhenExitLockDownMode, NotificationManagerService::postNotificationsWhenExitLockDownMode, NotificationManagerService::NotificationListeners::notifyRemovedLocked, NotificationManagerService::NotificationListeners::notifyRankingUpdateLocked, NotificationManagerService::StrongAuthTracker::onStrongAuthRequiredChanged, NotificationManagerService::NotificationListeners::notifyPostedLocked, NotificationManagerService::isInLockDownMode, NotificationManagerService::makeRankingUpdateLocked, NotificationManagerService::StrongAuthTracker::isInLockDownMode, NotificationManagerService::cancelNotificationsWhenEnterLockDownMode, NotificationManagerService::StrongAuthTracker::isInLockDownMode, NotificationManagerService::cancelNotificationsWhenEnterLockDownMode, NotificationManagerService::isInLockDownMode"
219,5676b94f5ff807eea35ebf63b97f83c3ffb2f7a1,NotificationListenersTest.java,"@@ -69,7 +69,6 @@ import java.io.BufferedInputStream;
 import java.io.BufferedOutputStream;
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
-import java.util.List;
 
 public class NotificationListenersTest extends UiServiceTestCase {
 
@@ -381,63 +380,112 @@ public class NotificationListenersTest extends UiServiceTestCase {
 
     @Test
     public void testNotifyPostedLockedInLockdownMode() {
-        NotificationRecord r = mock(NotificationRecord.class);
-        NotificationRecord old = mock(NotificationRecord.class);
-
-        // before the lockdown mode
-        when(mNm.isInLockDownMode()).thenReturn(false);
-        mListeners.notifyPostedLocked(r, old, true);
-        mListeners.notifyPostedLocked(r, old, false);
-        verify(r, atLeast(2)).getSbn();
-
-        // in the lockdown mode
-        reset(r);
-        reset(old);
-        when(mNm.isInLockDownMode()).thenReturn(true);
-        mListeners.notifyPostedLocked(r, old, true);
-        mListeners.notifyPostedLocked(r, old, false);
-        verify(r, never()).getSbn();
-    }
-
-    @Test
-    public void testnotifyRankingUpdateLockedInLockdownMode() {
-        List chn = mock(List.class);
-
-        // before the lockdown mode
-        when(mNm.isInLockDownMode()).thenReturn(false);
-        mListeners.notifyRankingUpdateLocked(chn);
-        verify(chn, atLeast(1)).size();
-
-        // in the lockdown mode
-        reset(chn);
-        when(mNm.isInLockDownMode()).thenReturn(true);
-        mListeners.notifyRankingUpdateLocked(chn);
-        verify(chn, never()).size();
+        NotificationRecord r0 = mock(NotificationRecord.class);
+        NotificationRecord old0 = mock(NotificationRecord.class);
+        UserHandle uh0 = mock(UserHandle.class);
+
+        NotificationRecord r1 = mock(NotificationRecord.class);
+        NotificationRecord old1 = mock(NotificationRecord.class);
+        UserHandle uh1 = mock(UserHandle.class);
+
+        // Neither user0 and user1 is in the lockdown mode
+        when(r0.getUser()).thenReturn(uh0);
+        when(uh0.getIdentifier()).thenReturn(0);
+        when(mNm.isInLockDownMode(0)).thenReturn(false);
+
+        when(r1.getUser()).thenReturn(uh1);
+        when(uh1.getIdentifier()).thenReturn(1);
+        when(mNm.isInLockDownMode(1)).thenReturn(false);
+
+        mListeners.notifyPostedLocked(r0, old0, true);
+        mListeners.notifyPostedLocked(r0, old0, false);
+        verify(r0, atLeast(2)).getSbn();
+
+        mListeners.notifyPostedLocked(r1, old1, true);
+        mListeners.notifyPostedLocked(r1, old1, false);
+        verify(r1, atLeast(2)).getSbn();
+
+        // Reset
+        reset(r0);
+        reset(old0);
+        reset(r1);
+        reset(old1);
+
+        // Only user 0 is in the lockdown mode
+        when(r0.getUser()).thenReturn(uh0);
+        when(uh0.getIdentifier()).thenReturn(0);
+        when(mNm.isInLockDownMode(0)).thenReturn(true);
+
+        when(r1.getUser()).thenReturn(uh1);
+        when(uh1.getIdentifier()).thenReturn(1);
+        when(mNm.isInLockDownMode(1)).thenReturn(false);
+
+        mListeners.notifyPostedLocked(r0, old0, true);
+        mListeners.notifyPostedLocked(r0, old0, false);
+        verify(r0, never()).getSbn();
+
+        mListeners.notifyPostedLocked(r1, old1, true);
+        mListeners.notifyPostedLocked(r1, old1, false);
+        verify(r1, atLeast(2)).getSbn();
     }
 
     @Test
     public void testNotifyRemovedLockedInLockdownMode() throws NoSuchFieldException {
-        NotificationRecord r = mock(NotificationRecord.class);
-        NotificationStats rs = mock(NotificationStats.class);
+        NotificationRecord r0 = mock(NotificationRecord.class);
+        NotificationStats rs0 = mock(NotificationStats.class);
+        UserHandle uh0 = mock(UserHandle.class);
+
+        NotificationRecord r1 = mock(NotificationRecord.class);
+        NotificationStats rs1 = mock(NotificationStats.class);
+        UserHandle uh1 = mock(UserHandle.class);
+
         StatusBarNotification sbn = mock(StatusBarNotification.class);
         FieldSetter.setField(mNm,
                 NotificationManagerService.class.getDeclaredField(""mHandler""),
                 mock(NotificationManagerService.WorkerHandler.class));
 
-        // before the lockdown mode
-        when(mNm.isInLockDownMode()).thenReturn(false);
-        when(r.getSbn()).thenReturn(sbn);
-        mListeners.notifyRemovedLocked(r, 0, rs);
-        mListeners.notifyRemovedLocked(r, 0, rs);
-        verify(r, atLeast(2)).getSbn();
-
-        // in the lockdown mode
-        reset(r);
-        reset(rs);
-        when(mNm.isInLockDownMode()).thenReturn(true);
-        when(r.getSbn()).thenReturn(sbn);
-        mListeners.notifyRemovedLocked(r, 0, rs);
-        mListeners.notifyRemovedLocked(r, 0, rs);
-        verify(r, never()).getSbn();
+        // Neither user0 and user1 is in the lockdown mode
+        when(r0.getUser()).thenReturn(uh0);
+        when(uh0.getIdentifier()).thenReturn(0);
+        when(mNm.isInLockDownMode(0)).thenReturn(false);
+        when(r0.getSbn()).thenReturn(sbn);
+
+        when(r1.getUser()).thenReturn(uh1);
+        when(uh1.getIdentifier()).thenReturn(1);
+        when(mNm.isInLockDownMode(1)).thenReturn(false);
+        when(r1.getSbn()).thenReturn(sbn);
+
+        mListeners.notifyRemovedLocked(r0, 0, rs0);
+        mListeners.notifyRemovedLocked(r0, 0, rs0);
+        verify(r0, atLeast(2)).getSbn();
+
+        mListeners.notifyRemovedLocked(r1, 0, rs1);
+        mListeners.notifyRemovedLocked(r1, 0, rs1);
+        verify(r1, atLeast(2)).getSbn();
+
+        // Reset
+        reset(r0);
+        reset(rs0);
+        reset(r1);
+        reset(rs1);
+
+        // Only user 0 is in the lockdown mode
+        when(r0.getUser()).thenReturn(uh0);
+        when(uh0.getIdentifier()).thenReturn(0);
+        when(mNm.isInLockDownMode(0)).thenReturn(true);
+        when(r0.getSbn()).thenReturn(sbn);
+
+        when(r1.getUser()).thenReturn(uh1);
+        when(uh1.getIdentifier()).thenReturn(1);
+        when(mNm.isInLockDownMode(1)).thenReturn(false);
+        when(r1.getSbn()).thenReturn(sbn);
+
+        mListeners.notifyRemovedLocked(r0, 0, rs0);
+        mListeners.notifyRemovedLocked(r0, 0, rs0);
+        verify(r0, never()).getSbn();
+
+        mListeners.notifyRemovedLocked(r1, 0, rs1);
+        mListeners.notifyRemovedLocked(r1, 0, rs1);
+        verify(r1, atLeast(2)).getSbn();
     }
 }
",98,50,"NotificationListenersTest::testNotifyRemovedLockedInLockdownMode, NotificationListenersTest::testNotifyPostedLockedInLockdownMode, NotificationListenersTest::testnotifyRankingUpdateLockedInLockdownMode"
220,5676b94f5ff807eea35ebf63b97f83c3ffb2f7a1,NotificationManagerServiceTest.java,"@@ -159,6 +159,7 @@ import android.service.notification.Adjustment;
 import android.service.notification.ConversationChannelWrapper;
 import android.service.notification.NotificationListenerFilter;
 import android.service.notification.NotificationListenerService;
+import android.service.notification.NotificationRankingUpdate;
 import android.service.notification.NotificationStats;
 import android.service.notification.StatusBarNotification;
 import android.service.notification.ZenPolicy;
@@ -194,6 +195,7 @@ import com.android.server.SystemService.TargetUser;
 import com.android.server.UiServiceTestCase;
 import com.android.server.lights.LightsManager;
 import com.android.server.lights.LogicalLight;
+import com.android.server.notification.ManagedServices.ManagedServiceInfo;
 import com.android.server.notification.NotificationManagerService.NotificationAssistants;
 import com.android.server.notification.NotificationManagerService.NotificationListeners;
 import com.android.server.pm.PackageManagerService;
@@ -345,6 +347,9 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {
         @Nullable
         NotificationAssistantAccessGrantedCallback mNotificationAssistantAccessGrantedCallback;
 
+        @Nullable
+        Boolean mIsVisibleToListenerReturnValue = null;
+
         TestableNotificationManagerService(Context context, NotificationRecordLogger logger,
                 InstanceIdSequence notificationInstanceIdSequence) {
             super(context, logger, notificationInstanceIdSequence);
@@ -419,6 +424,19 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {
             void onGranted(ComponentName assistant, int userId, boolean granted, boolean userSet);
         }
 
+        protected void setIsVisibleToListenerReturnValue(boolean value) {
+            mIsVisibleToListenerReturnValue = value;
+        }
+
+        @Override
+        boolean isVisibleToListener(StatusBarNotification sbn, int notificationType,
+                ManagedServiceInfo listener) {
+            if (mIsVisibleToListenerReturnValue != null) {
+                return mIsVisibleToListenerReturnValue;
+            }
+            return super.isVisibleToListener(sbn, notificationType, listener);
+        }
+
         class StrongAuthTrackerFake extends NotificationManagerService.StrongAuthTracker {
             private int mGetStrongAuthForUserReturnValue = 0;
             StrongAuthTrackerFake(Context context) {
@@ -8514,10 +8532,10 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {
         mStrongAuthTracker.setGetStrongAuthForUserReturnValue(
                 STRONG_AUTH_REQUIRED_AFTER_USER_LOCKDOWN);
         mStrongAuthTracker.onStrongAuthRequiredChanged(mContext.getUserId());
-        assertTrue(mStrongAuthTracker.isInLockDownMode());
-        mStrongAuthTracker.setGetStrongAuthForUserReturnValue(0);
+        assertTrue(mStrongAuthTracker.isInLockDownMode(mContext.getUserId()));
+        mStrongAuthTracker.setGetStrongAuthForUserReturnValue(mContext.getUserId());
         mStrongAuthTracker.onStrongAuthRequiredChanged(mContext.getUserId());
-        assertFalse(mStrongAuthTracker.isInLockDownMode());
+        assertFalse(mStrongAuthTracker.isInLockDownMode(mContext.getUserId()));
     }
 
     @Test
@@ -8533,8 +8551,8 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {
         // when entering the lockdown mode, cancel the 2 notifications.
         mStrongAuthTracker.setGetStrongAuthForUserReturnValue(
                 STRONG_AUTH_REQUIRED_AFTER_USER_LOCKDOWN);
-        mStrongAuthTracker.onStrongAuthRequiredChanged(mContext.getUserId());
-        assertTrue(mStrongAuthTracker.isInLockDownMode());
+        mStrongAuthTracker.onStrongAuthRequiredChanged(0);
+        assertTrue(mStrongAuthTracker.isInLockDownMode(0));
 
         // the notifyRemovedLocked function is called twice due to REASON_LOCKDOWN.
         ArgumentCaptor<Integer> captor = ArgumentCaptor.forClass(Integer.class);
@@ -8543,9 +8561,45 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {
 
         // exit lockdown mode.
         mStrongAuthTracker.setGetStrongAuthForUserReturnValue(0);
-        mStrongAuthTracker.onStrongAuthRequiredChanged(mContext.getUserId());
+        mStrongAuthTracker.onStrongAuthRequiredChanged(0);
+        assertFalse(mStrongAuthTracker.isInLockDownMode(0));
 
         // the notifyPostedLocked function is called twice.
-        verify(mListeners, times(2)).notifyPostedLocked(any(), any());
+        verify(mWorkerHandler, times(2)).postDelayed(any(Runnable.class), anyLong());
+        //verify(mListeners, times(2)).notifyPostedLocked(any(), any());
+    }
+
+    @Test
+    public void testMakeRankingUpdateLockedInLockDownMode() {
+        // post 2 notifications from a same package
+        NotificationRecord pkgA = new NotificationRecord(mContext,
+                generateSbn(""a"", 1000, 9, 0), mTestNotificationChannel);
+        mService.addNotification(pkgA);
+        NotificationRecord pkgB = new NotificationRecord(mContext,
+                generateSbn(""a"", 1000, 9, 1), mTestNotificationChannel);
+        mService.addNotification(pkgB);
+
+        mService.setIsVisibleToListenerReturnValue(true);
+        NotificationRankingUpdate nru = mService.makeRankingUpdateLocked(null);
+        assertEquals(2, nru.getRankingMap().getOrderedKeys().length);
+
+        // when only user 0 entering the lockdown mode, its notification will be suppressed.
+        mStrongAuthTracker.setGetStrongAuthForUserReturnValue(
+                STRONG_AUTH_REQUIRED_AFTER_USER_LOCKDOWN);
+        mStrongAuthTracker.onStrongAuthRequiredChanged(0);
+        assertTrue(mStrongAuthTracker.isInLockDownMode(0));
+        assertFalse(mStrongAuthTracker.isInLockDownMode(1));
+
+        nru = mService.makeRankingUpdateLocked(null);
+        assertEquals(1, nru.getRankingMap().getOrderedKeys().length);
+
+        // User 0 exits lockdown mode. Its notification will be resumed.
+        mStrongAuthTracker.setGetStrongAuthForUserReturnValue(0);
+        mStrongAuthTracker.onStrongAuthRequiredChanged(0);
+        assertFalse(mStrongAuthTracker.isInLockDownMode(0));
+        assertFalse(mStrongAuthTracker.isInLockDownMode(1));
+
+        nru = mService.makeRankingUpdateLocked(null);
+        assertEquals(2, nru.getRankingMap().getOrderedKeys().length);
     }
 }
",61,7,"NotificationManagerServiceTest::testMakeRankingUpdateLockedInLockDownMode, NotificationManagerServiceTest::TestableNotificationManagerService::setIsVisibleToListenerReturnValue, NotificationManagerServiceTest::testCancelAndPostNotificationsWhenEnterAndExitLockDownMode, NotificationManagerServiceTest::TestableNotificationManagerService::isVisibleToListener, NotificationManagerServiceTest::testStrongAuthTracker_isInLockDownMode"
221,66940e260478b665f3c008dfd53d3b44cd164b89,WorkSource.java,"@@ -128,7 +128,7 @@ public class WorkSource implements Parcelable {
         mNames = in.createStringArray();
 
         int numChains = in.readInt();
-        if (numChains > 0) {
+        if (numChains >= 0) {
             mChains = new ArrayList<>(numChains);
             in.readParcelableList(mChains, WorkChain.class.getClassLoader());
         } else {
",1,1,WorkSource::WorkSource
222,6c86f15ca01aa3b4c0150d6a905dcf82dfc37593,MediaSession.java,"@@ -286,7 +286,7 @@ public final class MediaSession {
     @Deprecated
     public void setMediaButtonReceiver(@Nullable PendingIntent mbr) {
         try {
-            mBinder.setMediaButtonReceiver(mbr, mContext.getPackageName());
+            mBinder.setMediaButtonReceiver(mbr);
         } catch (RemoteException e) {
             Log.wtf(TAG, ""Failure in setMediaButtonReceiver."", e);
         }
",1,1,MediaSession::setMediaButtonReceiver
223,6c86f15ca01aa3b4c0150d6a905dcf82dfc37593,MediaButtonReceiverHolder.java,"@@ -18,6 +18,7 @@ package com.android.server.media;
 
 import android.annotation.IntDef;
 import android.annotation.NonNull;
+import android.annotation.Nullable;
 import android.app.BroadcastOptions;
 import android.app.PendingIntent;
 import android.content.ComponentName;
@@ -37,6 +38,7 @@ import android.view.KeyEvent;
 
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
+import java.util.Collections;
 import java.util.List;
 
 /**
@@ -102,15 +104,19 @@ final class MediaButtonReceiverHolder {
     }
 
     /**
-     * Creates a new instance.
+     * Creates a new instance from a {@link PendingIntent}.
+     *
+     * <p>This method assumes the session package name has been validated and effectively belongs to
+     * the media session's owner.
      *
-     * @param context context
      * @param userId userId
-     * @param pendingIntent pending intent
-     * @return Can be {@code null} if pending intent was null.
+     * @param pendingIntent pending intent that will receive media button events
+     * @param sessionPackageName package name of media session owner
+     * @return {@link MediaButtonReceiverHolder} instance or {@code null} if pending intent was
+     *     null.
      */
-    public static MediaButtonReceiverHolder create(Context context, int userId,
-            PendingIntent pendingIntent, String sessionPackageName) {
+    public static MediaButtonReceiverHolder create(
+            int userId, @Nullable PendingIntent pendingIntent, String sessionPackageName) {
         if (pendingIntent == null) {
             return null;
         }
@@ -312,7 +318,7 @@ final class MediaButtonReceiverHolder {
     }
 
     private static ComponentName getComponentName(PendingIntent pendingIntent, int componentType) {
-        List<ResolveInfo> resolveInfos = null;
+        List<ResolveInfo> resolveInfos = Collections.emptyList();
         switch (componentType) {
             case COMPONENT_TYPE_ACTIVITY:
                 resolveInfos = pendingIntent.queryIntentComponents(
@@ -330,32 +336,37 @@ final class MediaButtonReceiverHolder {
                         PACKAGE_MANAGER_COMMON_FLAGS | PackageManager.GET_RECEIVERS);
                 break;
         }
-        if (resolveInfos != null && !resolveInfos.isEmpty()) {
-            return createComponentName(resolveInfos.get(0));
+
+        for (ResolveInfo resolveInfo : resolveInfos) {
+            ComponentInfo componentInfo = getComponentInfo(resolveInfo);
+            if (componentInfo != null && TextUtils.equals(componentInfo.packageName,
+                    pendingIntent.getCreatorPackage())
+                    && componentInfo.packageName != null && componentInfo.name != null) {
+                return new ComponentName(componentInfo.packageName, componentInfo.name);
+            }
         }
+
         return null;
     }
 
-    private static ComponentName createComponentName(ResolveInfo resolveInfo) {
-        if (resolveInfo == null) {
-            return null;
-        }
-        ComponentInfo componentInfo;
+    /**
+     * Retrieves the {@link ComponentInfo} from a {@link ResolveInfo} instance. Similar to {@link
+     * ResolveInfo#getComponentInfo()}, but returns {@code null} if this {@link ResolveInfo} points
+     * to a content provider.
+     *
+     * @param resolveInfo Where to extract the {@link ComponentInfo} from.
+     * @return Either a non-null {@link ResolveInfo#activityInfo} or {@link
+     *     ResolveInfo#serviceInfo}. Otherwise {@code null} if {@link ResolveInfo#providerInfo} is
+     *     not {@code null}.
+     */
+    private static ComponentInfo getComponentInfo(@NonNull ResolveInfo resolveInfo) {
         // Code borrowed from ResolveInfo#getComponentInfo().
         if (resolveInfo.activityInfo != null) {
-            componentInfo = resolveInfo.activityInfo;
+            return resolveInfo.activityInfo;
         } else if (resolveInfo.serviceInfo != null) {
-            componentInfo = resolveInfo.serviceInfo;
+            return resolveInfo.serviceInfo;
         } else {
-            // We're not interested in content provider.
-            return null;
-        }
-        // Code borrowed from ComponentInfo#getComponentName().
-        try {
-            return new ComponentName(componentInfo.packageName, componentInfo.name);
-        } catch (IllegalArgumentException | NullPointerException e) {
-            // This may be happen if resolveActivity() end up with matching multiple activities.
-            // see PackageManager#resolveActivity().
+            // We're not interested in content providers.
             return null;
         }
     }
",36,25,"MediaButtonReceiverHolder::getComponentInfo, MediaButtonReceiverHolder::create, MediaButtonReceiverHolder::createComponentName, MediaButtonReceiverHolder::create, MediaButtonReceiverHolder::getComponentName"
224,6c86f15ca01aa3b4c0150d6a905dcf82dfc37593,MediaSessionRecord.java,"@@ -932,8 +932,7 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR
         }
 
         @Override
-        public void setMediaButtonReceiver(PendingIntent pi, String sessionPackageName)
-                throws RemoteException {
+        public void setMediaButtonReceiver(PendingIntent pi) throws RemoteException {
             final long token = Binder.clearCallingIdentity();
             try {
                 if ((mPolicies & MediaSessionPolicyProvider.SESSION_POLICY_IGNORE_BUTTON_RECEIVER)
@@ -941,7 +940,7 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR
                     return;
                 }
                 mMediaButtonReceiverHolder =
-                        MediaButtonReceiverHolder.create(mContext, mUserId, pi, sessionPackageName);
+                        MediaButtonReceiverHolder.create(mUserId, pi, mPackageName);
                 mService.onMediaButtonReceiverChanged(MediaSessionRecord.this);
             } finally {
                 Binder.restoreCallingIdentity(token);
",2,3,"MediaSessionRecord::SessionStub::setMediaButtonReceiver, MediaSessionRecord::SessionStub::setMediaButtonReceiver"
225,6c86f15ca01aa3b4c0150d6a905dcf82dfc37593,MediaSessionService.java,"@@ -2253,9 +2253,9 @@ public class MediaSessionService extends SystemService implements Monitor {
                     PendingIntent pi = mCustomMediaKeyDispatcher.getMediaButtonReceiver(keyEvent,
                             uid, asSystemService);
                     if (pi != null) {
-                        mediaButtonReceiverHolder = MediaButtonReceiverHolder.create(mContext,
-                                mCurrentFullUserRecord.mFullUserId, pi,
-                                /* sessionPackageName= */ """");
+                        mediaButtonReceiverHolder =
+                                MediaButtonReceiverHolder.create(
+                                        mCurrentFullUserRecord.mFullUserId, pi, """");
                     }
                 }
             }
",3,3,MediaSessionService::SessionManagerImpl::dispatchMediaKeyEventLocked
226,c4ab6858af6c7c0b2d186c3032b1ec2bf0dc4815,MediaSessionRecord.java,"@@ -53,6 +53,7 @@ import android.os.RemoteException;
 import android.os.ResultReceiver;
 import android.os.SystemClock;
 import android.text.TextUtils;
+import android.util.EventLog;
 import android.util.Log;
 import android.view.KeyEvent;
 
@@ -951,6 +952,14 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR
         public void setMediaButtonBroadcastReceiver(ComponentName receiver) throws RemoteException {
             final long token = Binder.clearCallingIdentity();
             try {
+                //mPackageName has been verified in MediaSessionService.enforcePackageName().
+                if (receiver != null && !TextUtils.equals(
+                        mPackageName, receiver.getPackageName())) {
+                    EventLog.writeEvent(0x534e4554, ""238177121"", -1, """"); // SafetyNet logging.
+                    throw new IllegalArgumentException(""receiver does not belong to ""
+                            + ""package name provided to MediaSessionRecord. Pkg = "" + mPackageName
+                            + "", Receiver Pkg = "" + receiver.getPackageName());
+                }
                 if ((mPolicies & MediaSessionPolicyProvider.SESSION_POLICY_IGNORE_BUTTON_RECEIVER)
                         != 0) {
                     return;
",9,0,MediaSessionRecord::SessionStub::setMediaButtonBroadcastReceiver
227,68ef7c5a725d4f6f4387fde049d7d4ec447f996e,PendingIntentRecord.java,"@@ -350,16 +350,11 @@ public final class PendingIntentRecord extends IIntentSender.Stub {
                 resolvedType = key.requestResolvedType;
             }
 
-            // Apply any launch flags from the ActivityOptions. This is used only by SystemUI
-            // to ensure that we can launch the pending intent with a consistent launch mode even
-            // if the provided PendingIntent is immutable (ie. to force an activity to launch into
-            // a new task, or to launch multiple instances if supported by the app)
+            // Apply any launch flags from the ActivityOptions. This is to ensure that the caller
+            // can specify a consistent launch mode even if the PendingIntent is immutable
             final ActivityOptions opts = ActivityOptions.fromBundle(options);
             if (opts != null) {
-                // TODO(b/254490217): Move this check into SafeActivityOptions
-                if (controller.mAtmInternal.isCallerRecents(Binder.getCallingUid())) {
-                    finalIntent.addFlags(opts.getPendingIntentLaunchFlags());
-                }
+                finalIntent.addFlags(opts.getPendingIntentLaunchFlags());
             }
 
             // Extract options before clearing calling identity
",3,8,PendingIntentRecord::sendInner
228,da40a046caf74dfb789bb5cdd3b7d2847f9c956a,SensorPrivacyService.java,"@@ -29,6 +29,7 @@ import static android.app.AppOpsManager.OP_RECORD_AUDIO;
 import static android.content.Intent.EXTRA_PACKAGE_NAME;
 import static android.content.Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS;
 import static android.content.Intent.FLAG_ACTIVITY_NO_USER_ACTION;
+import static android.content.pm.PackageManager.MATCH_SYSTEM_ONLY;
 import static android.content.pm.PackageManager.PERMISSION_GRANTED;
 import static android.hardware.SensorPrivacyManager.EXTRA_ALL_SENSORS;
 import static android.hardware.SensorPrivacyManager.EXTRA_SENSOR;
@@ -75,6 +76,7 @@ import android.content.Context;
 import android.content.Intent;
 import android.content.IntentFilter;
 import android.content.pm.PackageManager;
+import android.content.pm.PackageManagerInternal;
 import android.content.res.Configuration;
 import android.graphics.drawable.Icon;
 import android.hardware.ISensorPrivacyListener;
@@ -188,6 +190,7 @@ public final class SensorPrivacyService extends SystemService {
     private final AppOpsManager mAppOpsManager;
     private final AppOpsManagerInternal mAppOpsManagerInternal;
     private final TelephonyManager mTelephonyManager;
+    private final PackageManagerInternal mPackageManagerInternal;
 
     private final IBinder mAppOpsRestrictionToken = new Binder();
 
@@ -208,6 +211,7 @@ public final class SensorPrivacyService extends SystemService {
         mActivityManagerInternal = getLocalService(ActivityManagerInternal.class);
         mActivityTaskManager = context.getSystemService(ActivityTaskManager.class);
         mTelephonyManager = context.getSystemService(TelephonyManager.class);
+        mPackageManagerInternal = getLocalService(PackageManagerInternal.class);
         mSensorPrivacyServiceImpl = new SensorPrivacyServiceImpl();
     }
 
@@ -877,6 +881,12 @@ public final class SensorPrivacyService extends SystemService {
          * sensor privacy.
          */
         private void enforceObserveSensorPrivacyPermission() {
+            String systemUIPackage = mContext.getString(R.string.config_systemUi);
+            if (Binder.getCallingUid() == mPackageManagerInternal
+                    .getPackageUid(systemUIPackage, MATCH_SYSTEM_ONLY, UserHandle.USER_SYSTEM)) {
+                // b/221782106, possible race condition with role grant might bootloop device.
+                return;
+            }
             enforcePermission(android.Manifest.permission.OBSERVE_SENSOR_PRIVACY,
                     ""Observing sensor privacy changes requires the following permission: ""
                             + android.Manifest.permission.OBSERVE_SENSOR_PRIVACY);
",10,0,"SensorPrivacyService::SensorPrivacyServiceImpl::enforceObserveSensorPrivacyPermission, SensorPrivacyService::SensorPrivacyService"
229,1645ad8ce3f70201f3e8315bbc329b1e09ff2b49,ActivityManagerService.java,"@@ -13849,6 +13849,17 @@ public class ActivityManagerService extends IActivityManager.Stub
                     throw new SecurityException(msg);
                 }
             }
+            if (!Build.IS_DEBUGGABLE && callingUid != ROOT_UID && callingUid != SHELL_UID
+                    && callingUid != SYSTEM_UID && !hasActiveInstrumentationLocked(callingPid)) {
+                // If it's not debug build and not called from root/shell/system uid, reject it.
+                final String msg = ""Permission Denial: instrumentation test ""
+                        + className + "" from pid="" + callingPid + "", uid="" + callingUid
+                        + "", pkgName="" + getPackageNameByPid(callingPid)
+                        + "" not allowed because it's not started from SHELL"";
+                Slog.wtfQuiet(TAG, msg);
+                reportStartInstrumentationFailureLocked(watcher, className, msg);
+                throw new SecurityException(msg);
+            }
 
             ActiveInstrumentation activeInstr = new ActiveInstrumentation(this);
             activeInstr.mClass = className;
@@ -13947,6 +13958,29 @@ public class ActivityManagerService extends IActivityManager.Stub
         }
     }
 
+    @GuardedBy(""this"")
+    private boolean hasActiveInstrumentationLocked(int pid) {
+        if (pid == 0) {
+            return false;
+        }
+        synchronized (mPidsSelfLocked) {
+            ProcessRecord process = mPidsSelfLocked.get(pid);
+            return process != null && process.getActiveInstrumentation() != null;
+        }
+    }
+
+    private String getPackageNameByPid(int pid) {
+        synchronized (mPidsSelfLocked) {
+            final ProcessRecord app = mPidsSelfLocked.get(pid);
+
+            if (app != null && app.info != null) {
+                return app.info.packageName;
+            }
+
+            return null;
+        }
+    }
+
     private boolean isCallerShell() {
         final int callingUid = Binder.getCallingUid();
         return callingUid == SHELL_UID || callingUid == ROOT_UID;
",34,0,"ActivityManagerService::hasActiveInstrumentationLocked, ActivityManagerService::getPackageNameByPid, ActivityManagerService::startInstrumentation"
230,2e7af97f081b0985e14d63df2c50f948b6f9075d,AccountManagerService.java,"@@ -3513,8 +3513,7 @@ public class AccountManagerService
             Bundle.setDefusable(result, true);
             mNumResults++;
             Intent intent = null;
-            if (result != null
-                    && (intent = result.getParcelable(AccountManager.KEY_INTENT)) != null) {
+            if (result != null) {
                 if (!checkKeyIntent(
                         Binder.getCallingUid(),
                         result)) {
@@ -4873,8 +4872,10 @@ public class AccountManagerService
             	EventLog.writeEvent(0x534e4554, ""250588548"", authUid, """");
                 return false;
             }
-
             Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT);
+            if (intent == null) {
+                return true;
+            }
             // Explicitly set an empty ClipData to ensure that we don't offer to
             // promote any Uris contained inside for granting purposes
             if (intent.getClipData() == null) {
@@ -4927,7 +4928,10 @@ public class AccountManagerService
             p.recycle();
             Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT);
             Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT);
-            return (intent.filterEquals(simulateIntent));
+            if (intent == null) {
+                return (simulateIntent == null);
+            }
+            return intent.filterEquals(simulateIntent);
         }
 
         private boolean isExportedSystemActivity(ActivityInfo activityInfo) {
@@ -5072,8 +5076,7 @@ public class AccountManagerService
                     }
                 }
             }
-            if (result != null
-                    && (intent = result.getParcelable(AccountManager.KEY_INTENT)) != null) {
+            if (result != null) {
                 if (!checkKeyIntent(
                         Binder.getCallingUid(),
                         result)) {
",9,6,"AccountManagerService::StartAccountSession::onResult, AccountManagerService::Session::checkKeyIntentParceledCorrectly, AccountManagerService::Session::checkKeyIntent, AccountManagerService::Session::onResult"
231,54a73e2f6ca472fe66039ab2823fdc2a5ba26cf2,ActiveServices.java,"@@ -3201,6 +3201,11 @@ public final class ActiveServices {
                             throw new SecurityException(""BIND_EXTERNAL_SERVICE failed, ""
                                     + className + "" is not an isolatedProcess"");
                         }
+                        if (AppGlobals.getPackageManager().getPackageUid(callingPackage,
+                                0, userId) != callingUid) {
+                            throw new SecurityException(""BIND_EXTERNAL_SERVICE failed, ""
+                                    + ""calling package not owned by calling UID "");
+                        }
                         // Run the service under the calling package's application.
                         ApplicationInfo aInfo = AppGlobals.getPackageManager().getApplicationInfo(
                                 callingPackage, ActivityManagerService.STOCK_PM_FLAGS, userId);
",5,0,ActiveServices::retrieveServiceLocked
232,299efd901061ccc2a243df9d9b8059dffa9861ea,Intent.java,"@@ -11011,7 +11011,7 @@ public class Intent implements Parcelable, Cloneable {
     private void toUriInner(StringBuilder uri, String scheme, String defAction,
             String defPackage, int flags) {
         if (scheme != null) {
-            uri.append(""scheme="").append(scheme).append(';');
+            uri.append(""scheme="").append(Uri.encode(scheme)).append(';');
         }
         if (mAction != null && !mAction.equals(defAction)) {
             uri.append(""action="").append(Uri.encode(mAction)).append(';');
",1,1,Intent::toUriInner
233,af52e36a81099ffc43e898f74f1e8f70ec1de2e3,AlarmManagerService.java,"@@ -56,6 +56,7 @@ import android.annotation.NonNull;
 import android.annotation.UserIdInt;
 import android.app.Activity;
 import android.app.ActivityManagerInternal;
+import android.app.ActivityOptions;
 import android.app.AlarmManager;
 import android.app.AppOpsManager;
 import android.app.BroadcastOptions;
@@ -317,6 +318,8 @@ public class AlarmManagerService extends SystemService {
     private final SparseBooleanArray mPendingSendNextAlarmClockChangedForUser =
             new SparseBooleanArray();
     private boolean mNextAlarmClockMayChange;
+    ActivityOptions mActivityOptsRestrictBal = ActivityOptions.makeBasic();
+    BroadcastOptions mBroadcastOptsRestrictBal = BroadcastOptions.makeBasic();
 
     @GuardedBy(""mLock"")
     private final Runnable mAlarmClockUpdater = () -> mNextAlarmClockMayChange = true;
@@ -1611,6 +1614,11 @@ public class AlarmManagerService extends SystemService {
     @Override
     public void onStart() {
         mInjector.init();
+        mOptsWithFgs.setPendingIntentBackgroundActivityLaunchAllowed(false);
+        mOptsWithoutFgs.setPendingIntentBackgroundActivityLaunchAllowed(false);
+        mOptsTimeBroadcast.setPendingIntentBackgroundActivityLaunchAllowed(false);
+        mActivityOptsRestrictBal.setPendingIntentBackgroundActivityLaunchAllowed(false);
+        mBroadcastOptsRestrictBal.setPendingIntentBackgroundActivityLaunchAllowed(false);
         mMetricsHelper = new MetricsHelper(getContext(), mLock);
 
         mListenerDeathRecipient = new IBinder.DeathRecipient() {
@@ -4306,6 +4314,14 @@ public class AlarmManagerService extends SystemService {
         return alarm.creatorUid;
     }
 
+    private Bundle getAlarmOperationBundle(Alarm alarm) {
+        if (alarm.mIdleOptions != null) {
+            return alarm.mIdleOptions;
+        } else if (alarm.operation.isActivity()) {
+            return mActivityOptsRestrictBal.toBundle();
+        }
+        return mBroadcastOptsRestrictBal.toBundle();
+    }
 
     @VisibleForTesting
     class AlarmHandler extends Handler {
@@ -4344,7 +4360,11 @@ public class AlarmManagerService extends SystemService {
                     for (int i = 0; i < triggerList.size(); i++) {
                         Alarm alarm = triggerList.get(i);
                         try {
-                            alarm.operation.send();
+                            // Disallow AlarmManager to start random background activity.
+                            final Bundle bundle = getAlarmOperationBundle(alarm);
+                            alarm.operation.send(/* context */ null, /* code */0, /* intent */
+                                    null, /* onFinished */null, /* handler */
+                                    null, /* requiredPermission */ null, bundle);
                         } catch (PendingIntent.CanceledException e) {
                             if (alarm.repeatInterval > 0) {
                                 // This IntentSender is no longer valid, but this
@@ -4908,9 +4928,10 @@ public class AlarmManagerService extends SystemService {
                     mSendCount++;
 
                     try {
+                        final Bundle bundle = getAlarmOperationBundle(alarm);
                         alarm.operation.send(getContext(), 0,
                                 mBackgroundIntent.putExtra(Intent.EXTRA_ALARM_COUNT, alarm.count),
-                                mDeliveryTracker, mHandler, null, alarm.mIdleOptions);
+                                mDeliveryTracker, mHandler, null, bundle);
                     } catch (PendingIntent.CanceledException e) {
                         if (alarm.repeatInterval > 0) {
                             // This IntentSender is no longer valid, but this
",23,2,"AlarmManagerService::onStart, AlarmManagerService::DeliveryTracker::deliverLocked, AlarmManagerService::getAlarmOperationBundle, AlarmManagerService::AlarmHandler::handleMessage"
234,af52e36a81099ffc43e898f74f1e8f70ec1de2e3,ActivityOptions.java,"@@ -69,7 +69,7 @@ import java.util.ArrayList;
  * {@link android.content.Context#startActivity(android.content.Intent, android.os.Bundle)
  * Context.startActivity(Intent, Bundle)} and related methods.
  */
-public class ActivityOptions {
+public class ActivityOptions extends ComponentOptions {
     private static final String TAG = ""ActivityOptions"";
 
     /**
@@ -1081,13 +1081,12 @@ public class ActivityOptions {
     }
 
     private ActivityOptions() {
+        super();
     }
 
     /** @hide */
     public ActivityOptions(Bundle opts) {
-        // If the remote side sent us bad parcelables, they won't get the
-        // results they want, which is their loss.
-        opts.setDefusable(true);
+        super(opts);
 
         mPackageName = opts.getString(KEY_PACKAGE_NAME);
         try {
@@ -1832,8 +1831,9 @@ public class ActivityOptions {
      * object; you must not modify it, but can supply it to the startActivity
      * methods that take an options Bundle.
      */
+    @Override
     public Bundle toBundle() {
-        Bundle b = new Bundle();
+        Bundle b = super.toBundle();
         if (mPackageName != null) {
             b.putString(KEY_PACKAGE_NAME, mPackageName);
         }
",5,5,"ActivityOptions::toBundle, ActivityOptions::ActivityOptions, ActivityOptions::ActivityOptions"
235,af52e36a81099ffc43e898f74f1e8f70ec1de2e3,BroadcastOptions.java,"@@ -34,7 +34,7 @@ import android.os.PowerExemptionManager.TempAllowListType;
  * {@hide}
  */
 @SystemApi
-public class BroadcastOptions {
+public class BroadcastOptions extends ComponentOptions {
     private long mTemporaryAppAllowlistDuration;
     private @TempAllowListType int mTemporaryAppAllowlistType;
     private @ReasonCode int mTemporaryAppAllowlistReasonCode;
@@ -108,12 +108,14 @@ public class BroadcastOptions {
     }
 
     private BroadcastOptions() {
+        super();
         resetTemporaryAppAllowlist();
     }
 
     /** @hide */
     @TestApi
     public BroadcastOptions(@NonNull Bundle opts) {
+        super(opts);
         // Match the logic in toBundle().
         if (opts.containsKey(KEY_TEMPORARY_APP_ALLOWLIST_DURATION)) {
             mTemporaryAppAllowlistDuration = opts.getLong(KEY_TEMPORARY_APP_ALLOWLIST_DURATION);
@@ -190,6 +192,24 @@ public class BroadcastOptions {
         mTemporaryAppAllowlistReason = null;
     }
 
+    /**
+     * Set PendingIntent activity is allowed to be started in the background if the caller
+     * can start background activities.
+     * @hide
+     */
+    public void setPendingIntentBackgroundActivityLaunchAllowed(boolean allowed) {
+        super.setPendingIntentBackgroundActivityLaunchAllowed(allowed);
+    }
+
+    /**
+     * Get PendingIntent activity is allowed to be started in the background if the caller
+     * can start background activities.
+     * @hide
+     */
+    public boolean isPendingIntentBackgroundActivityLaunchAllowed() {
+        return super.isPendingIntentBackgroundActivityLaunchAllowed();
+    }
+
     /**
      * Return {@link #setTemporaryAppAllowlist}.
      * @hide
@@ -308,8 +328,9 @@ public class BroadcastOptions {
      * object; you must not modify it, but can supply it to the sendBroadcast
      * methods that take an options Bundle.
      */
+    @Override
     public Bundle toBundle() {
-        Bundle b = new Bundle();
+        Bundle b = super.toBundle();
         if (isTemporaryAppAllowlistSet()) {
             b.putLong(KEY_TEMPORARY_APP_ALLOWLIST_DURATION, mTemporaryAppAllowlistDuration);
             b.putInt(KEY_TEMPORARY_APP_ALLOWLIST_TYPE, mTemporaryAppAllowlistType);
",23,2,"BroadcastOptions::isPendingIntentBackgroundActivityLaunchAllowed, BroadcastOptions::setPendingIntentBackgroundActivityLaunchAllowed, BroadcastOptions::BroadcastOptions, BroadcastOptions::toBundle, BroadcastOptions::BroadcastOptions"
236,af52e36a81099ffc43e898f74f1e8f70ec1de2e3,ComponentOptions.java,"@@ -0,0 +1,83 @@
+/*
+ * Copyright (C) 2021 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.app;
+
+import android.os.Bundle;
+
+/**
+ * @hide
+ */
+public class ComponentOptions {
+
+    /**
+     * Default value for KEY_PENDING_INTENT_BACKGROUND_ACTIVITY_ALLOWED.
+     * @hide
+     **/
+    public static final boolean PENDING_INTENT_BAL_ALLOWED_DEFAULT = true;
+
+    /**
+     * PendingIntent caller allows activity start even if PendingIntent creator is in background.
+     * This only works if the PendingIntent caller is allowed to start background activities,
+     * for example if it's in the foreground, or has BAL permission.
+     * @hide
+     */
+    public static final String KEY_PENDING_INTENT_BACKGROUND_ACTIVITY_ALLOWED =
+            ""android.pendingIntent.backgroundActivityAllowed"";
+
+    private boolean mPendingIntentBalAllowed = PENDING_INTENT_BAL_ALLOWED_DEFAULT;
+
+    ComponentOptions() {
+    }
+
+    ComponentOptions(Bundle opts) {
+        // If the remote side sent us bad parcelables, they won't get the
+        // results they want, which is their loss.
+        opts.setDefusable(true);
+        setPendingIntentBackgroundActivityLaunchAllowed(
+                opts.getBoolean(KEY_PENDING_INTENT_BACKGROUND_ACTIVITY_ALLOWED,
+                        PENDING_INTENT_BAL_ALLOWED_DEFAULT));
+    }
+
+    /**
+     * Set PendingIntent activity is allowed to be started in the background if the caller
+     * can start background activities.
+     *
+     * @hide
+     */
+    public void setPendingIntentBackgroundActivityLaunchAllowed(boolean allowed) {
+        mPendingIntentBalAllowed = allowed;
+    }
+
+    /**
+     * Get PendingIntent activity is allowed to be started in the background if the caller
+     * can start background activities.
+     *
+     * @hide
+     */
+    public boolean isPendingIntentBackgroundActivityLaunchAllowed() {
+        return mPendingIntentBalAllowed;
+    }
+
+    /**
+     * @hide
+     */
+    public Bundle toBundle() {
+        Bundle bundle = new Bundle();
+        bundle.putBoolean(KEY_PENDING_INTENT_BACKGROUND_ACTIVITY_ALLOWED, mPendingIntentBalAllowed);
+        return bundle;
+    }
+}
",83,0,"ComponentOptions::ComponentOptions, ComponentOptions::setPendingIntentBackgroundActivityLaunchAllowed, ComponentOptions::isPendingIntentBackgroundActivityLaunchAllowed, ComponentOptions::toBundle, ComponentOptions::ComponentOptions"
237,af52e36a81099ffc43e898f74f1e8f70ec1de2e3,PendingIntentRecord.java,"@@ -310,6 +310,25 @@ public final class PendingIntentRecord extends IIntentSender.Stub {
                 requiredPermission, null, null, 0, 0, 0, options);
     }
 
+    /**
+     * Return true if the activity options allows PendingIntent to use caller's BAL permission.
+     */
+    public static boolean isPendingIntentBalAllowedByCaller(
+            @Nullable ActivityOptions activityOptions) {
+        if (activityOptions == null) {
+            return ActivityOptions.PENDING_INTENT_BAL_ALLOWED_DEFAULT;
+        }
+        return isPendingIntentBalAllowedByCaller(activityOptions.toBundle());
+    }
+
+    private static boolean isPendingIntentBalAllowedByCaller(@Nullable Bundle options) {
+        if (options == null) {
+            return ActivityOptions.PENDING_INTENT_BAL_ALLOWED_DEFAULT;
+        }
+        return options.getBoolean(ActivityOptions.KEY_PENDING_INTENT_BACKGROUND_ACTIVITY_ALLOWED,
+                ActivityOptions.PENDING_INTENT_BAL_ALLOWED_DEFAULT);
+    }
+
     public int sendInner(int code, Intent intent, String resolvedType, IBinder allowlistToken,
             IIntentReceiver finishedReceiver, String requiredPermission, IBinder resultTo,
             String resultWho, int requestCode, int flagsMask, int flagsValues, Bundle options) {
@@ -431,7 +450,8 @@ public final class PendingIntentRecord extends IIntentSender.Stub {
             // temporarily allow receivers and services to open activities from background if the
             // PendingIntent.send() caller was foreground at the time of sendInner() call
             final boolean allowTrampoline = uid != callingUid
-                    && controller.mAtmInternal.isUidForeground(callingUid);
+                    && controller.mAtmInternal.isUidForeground(callingUid)
+                    && isPendingIntentBalAllowedByCaller(options);
 
             // note: we on purpose don't pass in the information about the PendingIntent's creator,
             // like pid or ProcessRecord, to the ActivityTaskManagerInternal calls below, because
",21,1,"PendingIntentRecord::isPendingIntentBalAllowedByCaller, PendingIntentRecord::isPendingIntentBalAllowedByCaller, PendingIntentRecord::sendInner"
238,af52e36a81099ffc43e898f74f1e8f70ec1de2e3,ActivityStarter.java,"@@ -989,6 +989,10 @@ class ActivityStarter {
         abort |= !mService.getPermissionPolicyInternal().checkStartActivity(intent, callingUid,
                 callingPackage);
 
+        // Merge the two options bundles, while realCallerOptions takes precedence.
+        ActivityOptions checkedOptions = options != null
+                ? options.getOptions(intent, aInfo, callerApp, mSupervisor) : null;
+
         boolean restrictedBgActivity = false;
         if (!abort) {
             try {
@@ -997,15 +1001,12 @@ class ActivityStarter {
                 restrictedBgActivity = shouldAbortBackgroundActivityStart(callingUid,
                         callingPid, callingPackage, realCallingUid, realCallingPid, callerApp,
                         request.originatingPendingIntent, request.allowBackgroundActivityStart,
-                        intent);
+                        intent, checkedOptions);
             } finally {
                 Trace.traceEnd(Trace.TRACE_TAG_WINDOW_MANAGER);
             }
         }
 
-        // Merge the two options bundles, while realCallerOptions takes precedence.
-        ActivityOptions checkedOptions = options != null
-                ? options.getOptions(intent, aInfo, callerApp, mSupervisor) : null;
         if (request.allowPendingRemoteAnimationRegistryLookup) {
             checkedOptions = mService.getActivityStartController()
                     .getPendingRemoteAnimationRegistry()
@@ -1247,7 +1248,7 @@ class ActivityStarter {
     boolean shouldAbortBackgroundActivityStart(int callingUid, int callingPid,
             final String callingPackage, int realCallingUid, int realCallingPid,
             WindowProcessController callerApp, PendingIntentRecord originatingPendingIntent,
-            boolean allowBackgroundActivityStart, Intent intent) {
+            boolean allowBackgroundActivityStart, Intent intent, ActivityOptions checkedOptions) {
         // don't abort for the most important UIDs
         final int callingAppId = UserHandle.getAppId(callingUid);
         if (callingUid == Process.ROOT_UID || callingAppId == Process.SYSTEM_UID
@@ -1318,9 +1319,12 @@ class ActivityStarter {
                 ? isCallingUidPersistentSystemProcess
                 : (realCallingAppId == Process.SYSTEM_UID)
                         || realCallingUidProcState <= ActivityManager.PROCESS_STATE_PERSISTENT_UI;
-        if (realCallingUid != callingUid) {
-            // don't abort if the realCallingUid has a visible window
-            // TODO(b/171459802): We should check appSwitchAllowed also
+
+        // Legacy behavior allows to use caller foreground state to bypass BAL restriction.
+        final boolean balAllowedByPiSender =
+                PendingIntentRecord.isPendingIntentBalAllowedByCaller(checkedOptions);
+
+        if (balAllowedByPiSender && realCallingUid != callingUid) {
             if (realCallingUidHasAnyVisibleWindow) {
                 if (DEBUG_ACTIVITY_STARTS) {
                     Slog.d(TAG, ""Activity start allowed: realCallingUid ("" + realCallingUid
@@ -1393,9 +1397,9 @@ class ActivityStarter {
         // If we don't have callerApp at this point, no caller was provided to startActivity().
         // That's the case for PendingIntent-based starts, since the creator's process might not be
         // up and alive. If that's the case, we retrieve the WindowProcessController for the send()
-        // caller, so that we can make the decision based on its state.
+        // caller if caller allows, so that we can make the decision based on its state.
         int callerAppUid = callingUid;
-        if (callerApp == null) {
+        if (callerApp == null && balAllowedByPiSender) {
             callerApp = mService.getProcessController(realCallingPid, realCallingUid);
             callerAppUid = realCallingUid;
         }
",14,10,"ActivityStarter::shouldAbortBackgroundActivityStart, ActivityStarter::shouldAbortBackgroundActivityStart, ActivityStarter::executeRequest"
239,af52e36a81099ffc43e898f74f1e8f70ec1de2e3,ActivityTaskManagerService.java,"@@ -2114,7 +2114,7 @@ public class ActivityTaskManagerService extends IActivityTaskManager.Stub {
         final ActivityStarter starter = getActivityStartController().obtainStarter(
                 null /* intent */, ""moveTaskToFront"");
         if (starter.shouldAbortBackgroundActivityStart(callingUid, callingPid, callingPackage, -1,
-                -1, callerApp, null, false, null)) {
+                -1, callerApp, null, false, null, null)) {
             if (!isBackgroundActivityStartsEnabled()) {
                 return;
             }
",1,1,ActivityTaskManagerService::moveTaskToFrontLocked
240,af52e36a81099ffc43e898f74f1e8f70ec1de2e3,AppTaskImpl.java,"@@ -108,7 +108,7 @@ class AppTaskImpl extends IAppTask.Stub {
                 final ActivityStarter starter = mService.getActivityStartController().obtainStarter(
                         null /* intent */, ""moveToFront"");
                 if (starter.shouldAbortBackgroundActivityStart(callingUid, callingPid,
-                        callingPackage, -1, -1, callerApp, null, false, null)) {
+                        callingPackage, -1, -1, callerApp, null, false, null, null)) {
                     if (!mService.isBackgroundActivityStartsEnabled()) {
                         return;
                     }
",1,1,AppTaskImpl::moveToFront
241,af52e36a81099ffc43e898f74f1e8f70ec1de2e3,AlarmManagerServiceTest.java,"@@ -109,6 +109,7 @@ import static org.mockito.Mockito.times;
 
 import android.app.ActivityManager;
 import android.app.ActivityManagerInternal;
+import android.app.ActivityOptions;
 import android.app.AlarmManager;
 import android.app.AppOpsManager;
 import android.app.BroadcastOptions;
@@ -552,13 +553,23 @@ public class AlarmManagerServiceTest {
 
 
     private PendingIntent getNewMockPendingIntent() {
-        return getNewMockPendingIntent(TEST_CALLING_UID, TEST_CALLING_PACKAGE);
+        return getNewMockPendingIntent(false);
+    }
+
+    private PendingIntent getNewMockPendingIntent(boolean isActivity) {
+        return getNewMockPendingIntent(TEST_CALLING_UID, TEST_CALLING_PACKAGE, isActivity);
     }
 
     private PendingIntent getNewMockPendingIntent(int creatorUid, String creatorPackage) {
+        return getNewMockPendingIntent(creatorUid, creatorPackage, false);
+    }
+
+    private PendingIntent getNewMockPendingIntent(int creatorUid, String creatorPackage,
+            boolean isActivity) {
         final PendingIntent mockPi = mock(PendingIntent.class, Answers.RETURNS_DEEP_STUBS);
         when(mockPi.getCreatorUid()).thenReturn(creatorUid);
         when(mockPi.getCreatorPackage()).thenReturn(creatorPackage);
+        when(mockPi.isActivity()).thenReturn(isActivity);
         return mockPi;
     }
 
@@ -2801,21 +2812,53 @@ public class AlarmManagerServiceTest {
                 anyString()));
     }
 
-    @Test
-    public void idleOptionsSentOnExpiration() throws Exception {
+    private void optionsSentOnExpiration(boolean isActivity, Bundle idleOptions)
+            throws Exception {
         final long triggerTime = mNowElapsedTest + 5000;
-        final PendingIntent alarmPi = getNewMockPendingIntent();
-        final Bundle idleOptions = new Bundle();
-        idleOptions.putChar(""TEST_CHAR_KEY"", 'x');
-        idleOptions.putInt(""TEST_INT_KEY"", 53);
+        final PendingIntent alarmPi = getNewMockPendingIntent(isActivity);
         setTestAlarm(ELAPSED_REALTIME_WAKEUP, triggerTime, 0, alarmPi, 0, 0, TEST_CALLING_UID,
                 idleOptions);
 
         mNowElapsedTest = mTestTimer.getElapsed();
         mTestTimer.expire();
 
+        ArgumentCaptor<Bundle> bundleCaptor = ArgumentCaptor.forClass(Bundle.class);
         verify(alarmPi).send(eq(mMockContext), eq(0), any(Intent.class),
-                any(), any(Handler.class), isNull(), eq(idleOptions));
+                any(), any(Handler.class), isNull(), bundleCaptor.capture());
+        if (idleOptions != null) {
+            assertEquals(idleOptions, bundleCaptor.getValue());
+        } else {
+            assertFalse(""BAL flag needs to be false in alarm manager"",
+                    bundleCaptor.getValue().getBoolean(
+                            ActivityOptions.KEY_PENDING_INTENT_BACKGROUND_ACTIVITY_ALLOWED,
+                            true));
+        }
+    }
+
+    @Test
+    public void activityIdleOptionsSentOnExpiration() throws Exception {
+        final Bundle idleOptions = new Bundle();
+        idleOptions.putChar(""TEST_CHAR_KEY"", 'x');
+        idleOptions.putInt(""TEST_INT_KEY"", 53);
+        optionsSentOnExpiration(true, idleOptions);
+    }
+
+    @Test
+    public void broadcastIdleOptionsSentOnExpiration() throws Exception {
+        final Bundle idleOptions = new Bundle();
+        idleOptions.putChar(""TEST_CHAR_KEY"", 'x');
+        idleOptions.putInt(""TEST_INT_KEY"", 53);
+        optionsSentOnExpiration(false, idleOptions);
+    }
+
+    @Test
+    public void emptyActivityOptionsSentOnExpiration() throws Exception {
+        optionsSentOnExpiration(true, null);
+    }
+
+    @Test
+    public void emptyBroadcastOptionsSentOnExpiration() throws Exception {
+        optionsSentOnExpiration(false, null);
     }
 
     @Test
",51,8,"AlarmManagerServiceTest::optionsSentOnExpiration, AlarmManagerServiceTest::emptyActivityOptionsSentOnExpiration, AlarmManagerServiceTest::emptyBroadcastOptionsSentOnExpiration, AlarmManagerServiceTest::getNewMockPendingIntent, AlarmManagerServiceTest::getNewMockPendingIntent, AlarmManagerServiceTest::getNewMockPendingIntent, AlarmManagerServiceTest::broadcastIdleOptionsSentOnExpiration, AlarmManagerServiceTest::idleOptionsSentOnExpiration, AlarmManagerServiceTest::getNewMockPendingIntent, AlarmManagerServiceTest::activityIdleOptionsSentOnExpiration"
242,6d2f7829dd6e3fdcc6ebff0c2d9e16c3a069ad9d,AppTaskImpl.java,"@@ -84,7 +84,7 @@ class AppTaskImpl extends IAppTask.Stub {
                     throw new IllegalArgumentException(""Unable to find task ID "" + mTaskId);
                 }
                 return mService.getRecentTasks().createRecentTaskInfo(task,
-                        false /* stripExtras */);
+                        false /* stripExtras */, true /* getTasksAllowed */);
             } finally {
                 Binder.restoreCallingIdentity(origId);
             }
",1,1,AppTaskImpl::getTaskInfo
243,6d2f7829dd6e3fdcc6ebff0c2d9e16c3a069ad9d,RecentTasks.java,"@@ -974,7 +974,7 @@ class RecentTasks {
                 continue;
             }
 
-            res.add(createRecentTaskInfo(task, true /* stripExtras */));
+            res.add(createRecentTaskInfo(task, true /* stripExtras */, getTasksAllowed));
         }
         return res;
     }
@@ -1890,7 +1890,8 @@ class RecentTasks {
     /**
      * Creates a new RecentTaskInfo from a Task.
      */
-    ActivityManager.RecentTaskInfo createRecentTaskInfo(Task tr, boolean stripExtras) {
+    ActivityManager.RecentTaskInfo createRecentTaskInfo(Task tr, boolean stripExtras,
+            boolean getTasksAllowed) {
         final ActivityManager.RecentTaskInfo rti = new ActivityManager.RecentTaskInfo();
         // If the recent Task is detached, we consider it will be re-attached to the default
         // TaskDisplayArea because we currently only support recent overview in the default TDA.
@@ -1902,6 +1903,9 @@ class RecentTasks {
         rti.id = rti.isRunning ? rti.taskId : INVALID_TASK_ID;
         rti.persistentId = rti.taskId;
         rti.lastSnapshotData.set(tr.mLastTaskSnapshotData);
+        if (!getTasksAllowed) {
+            Task.trimIneffectiveInfo(tr, rti);
+        }
 
         // Fill in organized child task info for the task created by organizer.
         if (tr.mCreatedByOrganizer) {
",6,2,"RecentTasks::createRecentTaskInfo, RecentTasks::createRecentTaskInfo, RecentTasks::getRecentTasksImpl"
244,6d2f7829dd6e3fdcc6ebff0c2d9e16c3a069ad9d,RunningTasks.java,"@@ -150,6 +150,10 @@ class RunningTasks {
         task.fillTaskInfo(rti, !mKeepIntentExtra);
         // Fill in some deprecated values
         rti.id = rti.taskId;
+
+        if (!mAllowed) {
+            Task.trimIneffectiveInfo(task, rti);
+        }
         return rti;
     }
 }
",4,0,RunningTasks::createRunningTaskInfo
245,6d2f7829dd6e3fdcc6ebff0c2d9e16c3a069ad9d,Task.java,"@@ -3484,6 +3484,54 @@ class Task extends TaskFragment {
         info.mTopActivityLocusId = topRecord != null ? topRecord.getLocusId() : null;
     }
 
+    /**
+     * Removes the activity info if the activity belongs to a different uid, which is
+     * different from the app that hosts the task.
+     */
+    static void trimIneffectiveInfo(Task task, TaskInfo info) {
+        final ActivityRecord baseActivity = task.getActivity(r -> !r.finishing,
+                false /* traverseTopToBottom */);
+        final int baseActivityUid =
+                baseActivity != null ? baseActivity.getUid() : task.effectiveUid;
+
+        if (info.topActivityInfo != null
+                && task.effectiveUid != info.topActivityInfo.applicationInfo.uid) {
+            // Making a copy to prevent eliminating the info in the original ActivityRecord.
+            info.topActivityInfo = new ActivityInfo(info.topActivityInfo);
+            info.topActivityInfo.applicationInfo =
+                    new ApplicationInfo(info.topActivityInfo.applicationInfo);
+
+            // Strip the sensitive info.
+            info.topActivity = new ComponentName("""", """");
+            info.topActivityInfo.packageName = """";
+            info.topActivityInfo.taskAffinity = """";
+            info.topActivityInfo.processName = """";
+            info.topActivityInfo.name = """";
+            info.topActivityInfo.parentActivityName = """";
+            info.topActivityInfo.targetActivity = """";
+            info.topActivityInfo.splitName = """";
+            info.topActivityInfo.applicationInfo.className = """";
+            info.topActivityInfo.applicationInfo.credentialProtectedDataDir = """";
+            info.topActivityInfo.applicationInfo.dataDir = """";
+            info.topActivityInfo.applicationInfo.deviceProtectedDataDir = """";
+            info.topActivityInfo.applicationInfo.manageSpaceActivityName = """";
+            info.topActivityInfo.applicationInfo.nativeLibraryDir = """";
+            info.topActivityInfo.applicationInfo.nativeLibraryRootDir = """";
+            info.topActivityInfo.applicationInfo.processName = """";
+            info.topActivityInfo.applicationInfo.publicSourceDir = """";
+            info.topActivityInfo.applicationInfo.scanPublicSourceDir = """";
+            info.topActivityInfo.applicationInfo.scanSourceDir = """";
+            info.topActivityInfo.applicationInfo.sourceDir = """";
+            info.topActivityInfo.applicationInfo.taskAffinity = """";
+            info.topActivityInfo.applicationInfo.name = """";
+            info.topActivityInfo.applicationInfo.packageName = """";
+        }
+
+        if (task.effectiveUid != baseActivityUid) {
+            info.baseActivity = new ComponentName("""", """");
+        }
+    }
+
     @Nullable PictureInPictureParams getPictureInPictureParams() {
         return getPictureInPictureParams(getTopMostTask());
     }
",48,0,Task::trimIneffectiveInfo
246,6d2f7829dd6e3fdcc6ebff0c2d9e16c3a069ad9d,RecentTasksTest.java,"@@ -30,6 +30,7 @@ import static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;
 import static android.content.pm.ActivityInfo.LAUNCH_MULTIPLE;
 import static android.content.pm.ActivityInfo.LAUNCH_SINGLE_INSTANCE;
 import static android.content.res.Configuration.ORIENTATION_PORTRAIT;
+import static android.os.Process.NOBODY_UID;
 
 import static com.android.dx.mockito.inline.extended.ExtendedMockito.doNothing;
 import static com.android.dx.mockito.inline.extended.ExtendedMockito.doReturn;
@@ -1195,21 +1196,36 @@ public class RecentTasksTest extends WindowTestsBase {
 
     @Test
     public void testCreateRecentTaskInfo_detachedTask() {
-        final Task task = createTaskBuilder("".Task"").setCreateActivity(true).build();
+        final Task task = createTaskBuilder("".Task"").build();
+        final ComponentName componentName = new ComponentName(""com.foo"", "".BarActivity"");
+        new ActivityBuilder(mSupervisor.mService)
+                .setTask(task)
+                .setUid(NOBODY_UID)
+                .setComponent(componentName)
+                .build();
         final TaskDisplayArea tda = task.getDisplayArea();
 
         assertTrue(task.isAttached());
         assertTrue(task.supportsMultiWindow());
 
-        RecentTaskInfo info = mRecentTasks.createRecentTaskInfo(task, true);
+        RecentTaskInfo info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,
+                true /* getTasksAllowed */);
 
         assertTrue(info.supportsMultiWindow);
         assertTrue(info.supportsSplitScreenMultiWindow);
 
+        info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,
+                false /* getTasksAllowed */);
+
+        assertFalse(info.topActivity.equals(componentName));
+        assertFalse(info.topActivityInfo.packageName.equals(componentName.getPackageName()));
+        assertFalse(info.baseActivity.equals(componentName));
+
         // The task can be put in split screen even if it is not attached now.
         task.removeImmediately();
 
-        info = mRecentTasks.createRecentTaskInfo(task, true);
+        info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,
+                true /* getTasksAllowed */);
 
         assertTrue(info.supportsMultiWindow);
         assertTrue(info.supportsSplitScreenMultiWindow);
@@ -1219,7 +1235,8 @@ public class RecentTasksTest extends WindowTestsBase {
         doReturn(false).when(tda).supportsNonResizableMultiWindow();
         doReturn(false).when(task).isResizeable();
 
-        info = mRecentTasks.createRecentTaskInfo(task, true);
+        info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,
+                true /* getTasksAllowed */);
 
         assertFalse(info.supportsMultiWindow);
         assertFalse(info.supportsSplitScreenMultiWindow);
@@ -1228,7 +1245,8 @@ public class RecentTasksTest extends WindowTestsBase {
         // the device supports it.
         doReturn(true).when(tda).supportsNonResizableMultiWindow();
 
-        info = mRecentTasks.createRecentTaskInfo(task, true);
+        info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,
+                true /* getTasksAllowed */);
 
         assertTrue(info.supportsMultiWindow);
         assertTrue(info.supportsSplitScreenMultiWindow);
",23,5,RecentTasksTest::testCreateRecentTaskInfo_detachedTask
247,f64311b32d86df04746b885d4ed0111d588fd48b,PreferencesHelper.java,"@@ -98,6 +98,8 @@ public class PreferencesHelper implements RankingConfig {
 
     @VisibleForTesting
     static final int NOTIFICATION_CHANNEL_COUNT_LIMIT = 5000;
+    @VisibleForTesting
+    static final int NOTIFICATION_CHANNEL_GROUP_COUNT_LIMIT = 6000;
 
     private static final int NOTIFICATION_PREFERENCES_PULL_LIMIT = 1000;
     private static final int NOTIFICATION_CHANNEL_PULL_LIMIT = 2000;
@@ -242,6 +244,7 @@ public class PreferencesHelper implements RankingConfig {
                                 }
                             }
                             boolean skipWarningLogged = false;
+                            boolean skipGroupWarningLogged = false;
                             boolean hasSAWPermission = false;
                             if (upgradeForBubbles && uid != UNKNOWN_UID) {
                                 hasSAWPermission = mAppOps.noteOpNoThrow(
@@ -294,6 +297,14 @@ public class PreferencesHelper implements RankingConfig {
                                 String tagName = parser.getName();
                                 // Channel groups
                                 if (TAG_GROUP.equals(tagName)) {
+                                    if (r.groups.size() >= NOTIFICATION_CHANNEL_GROUP_COUNT_LIMIT) {
+                                        if (!skipGroupWarningLogged) {
+                                            Slog.w(TAG, ""Skipping further groups for "" + r.pkg
+                                                    + ""; app has too many"");
+                                            skipGroupWarningLogged = true;
+                                        }
+                                        continue;
+                                    }
                                     String id = parser.getAttributeValue(null, ATT_ID);
                                     CharSequence groupName = parser.getAttributeValue(null,
                                             ATT_NAME);
@@ -807,6 +818,9 @@ public class PreferencesHelper implements RankingConfig {
             }
             if (fromTargetApp) {
                 group.setBlocked(false);
+                if (r.groups.size() >= NOTIFICATION_CHANNEL_GROUP_COUNT_LIMIT) {
+                    throw new IllegalStateException(""Limit exceed; cannot create more groups"");
+                }
             }
             final NotificationChannelGroup oldGroup = r.groups.get(group.getId());
             if (oldGroup != null) {
",14,0,"PreferencesHelper::createNotificationChannelGroup, PreferencesHelper::readXml"
248,f64311b32d86df04746b885d4ed0111d588fd48b,PreferencesHelperTest.java,"@@ -42,6 +42,7 @@ import static com.android.os.AtomsProto.PackageNotificationChannelPreferences.IS
 import static com.android.os.AtomsProto.PackageNotificationChannelPreferences.UID_FIELD_NUMBER;
 import static com.android.server.notification.PreferencesHelper.DEFAULT_BUBBLE_PREFERENCE;
 import static com.android.server.notification.PreferencesHelper.NOTIFICATION_CHANNEL_COUNT_LIMIT;
+import static com.android.server.notification.PreferencesHelper.NOTIFICATION_CHANNEL_GROUP_COUNT_LIMIT;
 import static com.android.server.notification.PreferencesHelper.UNKNOWN_UID;
 
 import static com.google.common.truth.Truth.assertThat;
@@ -3165,6 +3166,52 @@ public class PreferencesHelperTest extends UiServiceTestCase {
         assertNull(mHelper.getNotificationChannel(PKG_O, UID_O, extraChannel1, true));
     }
 
+    @Test
+    public void testTooManyGroups() {
+        for (int i = 0; i < NOTIFICATION_CHANNEL_GROUP_COUNT_LIMIT; i++) {
+            NotificationChannelGroup group = new NotificationChannelGroup(String.valueOf(i),
+                    String.valueOf(i));
+            mHelper.createNotificationChannelGroup(PKG_O, UID_O, group, true);
+        }
+        try {
+            NotificationChannelGroup group = new NotificationChannelGroup(
+                    String.valueOf(NOTIFICATION_CHANNEL_GROUP_COUNT_LIMIT),
+                    String.valueOf(NOTIFICATION_CHANNEL_GROUP_COUNT_LIMIT));
+            mHelper.createNotificationChannelGroup(PKG_O, UID_O, group, true);
+            fail(""Allowed to create too many notification channel groups"");
+        } catch (IllegalStateException e) {
+            // great
+        }
+    }
+
+    @Test
+    public void testTooManyGroups_xml() throws Exception {
+        String extraGroup = ""EXTRA"";
+        String extraGroup1 = ""EXTRA1"";
+
+        // create first... many... directly so we don't need a big xml blob in this test
+        for (int i = 0; i < NOTIFICATION_CHANNEL_GROUP_COUNT_LIMIT; i++) {
+            NotificationChannelGroup group = new NotificationChannelGroup(String.valueOf(i),
+                    String.valueOf(i));
+            mHelper.createNotificationChannelGroup(PKG_O, UID_O, group, true);
+        }
+
+        final String xml = ""<ranking version=\""1\"">\n""
+                + ""<package name=\"""" + PKG_O + ""\"" uid=\"""" + UID_O + ""\"" >\n""
+                + ""<channelGroup id=\"""" + extraGroup + ""\"" name=\""hi\""/>""
+                + ""<channelGroup id=\"""" + extraGroup1 + ""\"" name=\""hi2\""/>""
+                + ""</package>""
+                + ""</ranking>"";
+        TypedXmlPullParser parser = Xml.newFastPullParser();
+        parser.setInput(new BufferedInputStream(new ByteArrayInputStream(xml.getBytes())),
+                null);
+        parser.nextTag();
+        mHelper.readXml(parser, false, UserHandle.USER_ALL);
+
+        assertNull(mHelper.getNotificationChannelGroup(extraGroup, PKG_O, UID_O));
+        assertNull(mHelper.getNotificationChannelGroup(extraGroup1, PKG_O, UID_O));
+    }
+
     @Test
     public void testRestoreMultiUser() throws Exception {
         String pkg = ""restore_pkg"";
",47,0,"PreferencesHelperTest::testTooManyGroups, PreferencesHelperTest::testTooManyGroups_xml"
249,2552ea758a9eb3c0b7f12426214a3c4c7fad0bca,LocationProviderManager.java,"@@ -281,6 +281,7 @@ public class LocationProviderManager extends
         public void deliverOnFlushComplete(int requestCode) throws PendingIntent.CanceledException {
             BroadcastOptions options = BroadcastOptions.makeBasic();
             options.setDontSendToRestrictedApps(true);
+            options.setPendingIntentBackgroundActivityLaunchAllowed(false);
 
             mPendingIntent.send(mContext, 0, new Intent().putExtra(KEY_FLUSH_COMPLETE, requestCode),
                     null, null, null, options.toBundle());
",1,0,LocationProviderManager::LocationPendingIntentTransport::deliverOnFlushComplete
250,8ef7fac04f4331e2c029002d8d99eb2246d74625,IntentSender.java,"@@ -19,6 +19,7 @@ package android.content;
 import android.annotation.Nullable;
 import android.app.ActivityManager;
 import android.app.ActivityManager.PendingIntentInfo;
+import android.app.ActivityOptions;
 import android.compat.annotation.UnsupportedAppUsage;
 import android.os.Bundle;
 import android.os.Handler;
@@ -158,7 +159,7 @@ public class IntentSender implements Parcelable {
      */
     public void sendIntent(Context context, int code, Intent intent,
             OnFinished onFinished, Handler handler) throws SendIntentException {
-        sendIntent(context, code, intent, onFinished, handler, null);
+        sendIntent(context, code, intent, onFinished, handler, null, null /* options */);
     }
 
     /**
@@ -190,6 +191,42 @@ public class IntentSender implements Parcelable {
     public void sendIntent(Context context, int code, Intent intent,
             OnFinished onFinished, Handler handler, String requiredPermission)
             throws SendIntentException {
+        sendIntent(context, code, intent, onFinished, handler, requiredPermission,
+                null /* options */);
+    }
+
+    /**
+     * Perform the operation associated with this IntentSender, allowing the
+     * caller to specify information about the Intent to use and be notified
+     * when the send has completed.
+     *
+     * @param context The Context of the caller.  This may be null if
+     * <var>intent</var> is also null.
+     * @param code Result code to supply back to the IntentSender's target.
+     * @param intent Additional Intent data.  See {@link Intent#fillIn
+     * Intent.fillIn()} for information on how this is applied to the
+     * original Intent.  Use null to not modify the original Intent.
+     * @param onFinished The object to call back on when the send has
+     * completed, or null for no callback.
+     * @param handler Handler identifying the thread on which the callback
+     * should happen.  If null, the callback will happen from the thread
+     * pool of the process.
+     * @param requiredPermission Name of permission that a recipient of the PendingIntent
+     * is required to hold.  This is only valid for broadcast intents, and
+     * corresponds to the permission argument in
+     * {@link Context#sendBroadcast(Intent, String) Context.sendOrderedBroadcast(Intent, String)}.
+     * If null, no permission is required.
+     * @param options Additional options the caller would like to provide to modify the sending
+     * behavior.  May be built from an {@link ActivityOptions} to apply to an activity start.
+     *
+     * @throws SendIntentException Throws CanceledIntentException if the IntentSender
+     * is no longer allowing more intents to be sent through it.
+     * @hide
+     */
+    public void sendIntent(Context context, int code, Intent intent,
+            OnFinished onFinished, Handler handler, String requiredPermission,
+            @Nullable Bundle options)
+            throws SendIntentException {
         try {
             String resolvedType = intent != null ?
                     intent.resolveTypeIfNeeded(context.getContentResolver())
@@ -199,7 +236,7 @@ public class IntentSender implements Parcelable {
                     onFinished != null
                             ? new FinishedDispatcher(this, onFinished, handler)
                             : null,
-                    requiredPermission, null);
+                    requiredPermission, options);
             if (res < 0) {
                 throw new SendIntentException();
             }
",39,2,"IntentSender::sendIntent, IntentSender::sendIntent, IntentSender::sendIntent"
251,8ef7fac04f4331e2c029002d8d99eb2246d74625,PackageInstallerService.java,"@@ -25,6 +25,7 @@ import android.annotation.Nullable;
 import android.app.ActivityManager;
 import android.app.AppGlobals;
 import android.app.AppOpsManager;
+import android.app.BroadcastOptions;
 import android.app.Notification;
 import android.app.NotificationManager;
 import android.app.PackageDeleteObserver;
@@ -1243,7 +1244,10 @@ public class PackageInstallerService extends IPackageInstaller.Stub implements
                     PackageInstaller.STATUS_PENDING_USER_ACTION);
             fillIn.putExtra(Intent.EXTRA_INTENT, intent);
             try {
-                mTarget.sendIntent(mContext, 0, fillIn, null, null);
+                final BroadcastOptions options = BroadcastOptions.makeBasic();
+                options.setPendingIntentBackgroundActivityLaunchAllowed(false);
+                mTarget.sendIntent(mContext, 0, fillIn, null /* onFinished*/,
+                        null /* handler */, null /* requiredPermission */, options.toBundle());
             } catch (SendIntentException ignored) {
             }
         }
@@ -1268,7 +1272,10 @@ public class PackageInstallerService extends IPackageInstaller.Stub implements
                     PackageManager.deleteStatusToString(returnCode, msg));
             fillIn.putExtra(PackageInstaller.EXTRA_LEGACY_STATUS, returnCode);
             try {
-                mTarget.sendIntent(mContext, 0, fillIn, null, null);
+                final BroadcastOptions options = BroadcastOptions.makeBasic();
+                options.setPendingIntentBackgroundActivityLaunchAllowed(false);
+                mTarget.sendIntent(mContext, 0, fillIn, null /* onFinished*/,
+                        null /* handler */, null /* requiredPermission */, options.toBundle());
             } catch (SendIntentException ignored) {
             }
         }
",9,2,"PackageInstallerService::PackageDeleteObserverAdapter::onPackageDeleted, PackageInstallerService::PackageDeleteObserverAdapter::onUserActionRequired"
252,8ef7fac04f4331e2c029002d8d99eb2246d74625,PackageInstallerSession.java,"@@ -50,6 +50,7 @@ import android.annotation.IntDef;
 import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.app.AppOpsManager;
+import android.app.BroadcastOptions;
 import android.app.Notification;
 import android.app.NotificationManager;
 import android.app.admin.DevicePolicyEventLogger;
@@ -1872,7 +1873,11 @@ public class PackageInstallerSession extends IPackageInstallerSession.Stub {
                     }
                 } else if (PackageInstaller.STATUS_PENDING_USER_ACTION == status) {
                     try {
-                        mStatusReceiver.sendIntent(mContext, 0, intent, null, null);
+                        final BroadcastOptions options = BroadcastOptions.makeBasic();
+                        options.setPendingIntentBackgroundActivityLaunchAllowed(false);
+                        mStatusReceiver.sendIntent(mContext, 0, intent,
+                                null /* onFinished*/, null /* handler */,
+                                null /* requiredPermission */, options.toBundle());
                     } catch (IntentSender.SendIntentException ignore) {
                     }
                 } else { // failure, let's forward and clean up this session.
@@ -4375,7 +4380,10 @@ public class PackageInstallerSession extends IPackageInstallerSession.Stub {
         fillIn.putExtra(PackageInstaller.EXTRA_STATUS, PackageInstaller.STATUS_PENDING_USER_ACTION);
         fillIn.putExtra(Intent.EXTRA_INTENT, intent);
         try {
-            target.sendIntent(context, 0, fillIn, null, null);
+            final BroadcastOptions options = BroadcastOptions.makeBasic();
+            options.setPendingIntentBackgroundActivityLaunchAllowed(false);
+            target.sendIntent(context, 0, fillIn, null /* onFinished */,
+                    null /* handler */, null /* requiredPermission */, options.toBundle());
         } catch (IntentSender.SendIntentException ignored) {
         }
     }
@@ -4418,7 +4426,10 @@ public class PackageInstallerSession extends IPackageInstallerSession.Stub {
             }
         }
         try {
-            target.sendIntent(context, 0, fillIn, null, null);
+            final BroadcastOptions options = BroadcastOptions.makeBasic();
+            options.setPendingIntentBackgroundActivityLaunchAllowed(false);
+            target.sendIntent(context, 0, fillIn, null /* onFinished */,
+                    null /* handler */, null /* requiredPermission */, options.toBundle());
         } catch (IntentSender.SendIntentException ignored) {
         }
     }
@@ -4443,7 +4454,10 @@ public class PackageInstallerSession extends IPackageInstallerSession.Stub {
             intent.putExtra(PackageInstaller.EXTRA_STATUS_MESSAGE, ""Staging Image Not Ready"");
         }
         try {
-            target.sendIntent(context, 0, intent, null, null);
+            final BroadcastOptions options = BroadcastOptions.makeBasic();
+            options.setPendingIntentBackgroundActivityLaunchAllowed(false);
+            target.sendIntent(context, 0, intent, null /* onFinished */,
+                    null /* handler */, null /* requiredPermission */, options.toBundle());
         } catch (IntentSender.SendIntentException ignored) {
         }
     }
",18,4,"PackageInstallerSession::sendPendingStreaming, PackageInstallerSession::sendOnPackageInstalled, PackageInstallerSession::sendOnUserActionRequired, PackageInstallerSession::ChildStatusIntentReceiver::statusUpdate"
253,8ef7fac04f4331e2c029002d8d99eb2246d74625,PackageManagerService.java,"@@ -9268,7 +9268,10 @@ public class PackageManagerService extends IPackageManager.Stub
             }
             if (pi != null) {
                 try {
-                    pi.sendIntent(null, success ? 1 : 0, null, null, null);
+                    final BroadcastOptions options = BroadcastOptions.makeBasic();
+                    options.setPendingIntentBackgroundActivityLaunchAllowed(false);
+                    pi.sendIntent(null, success ? 1 : 0, null /* intent */, null /* onFinished*/,
+                            null /* handler */, null /* requiredPermission */, options.toBundle());
                 } catch (SendIntentException e) {
                     Slog.w(TAG, e);
                 }
@@ -16451,7 +16454,10 @@ public class PackageManagerService extends IPackageManager.Stub
         fillIn.putExtra(PackageInstaller.EXTRA_STATUS,
                 PackageManager.installStatusToPublicStatus(returnCode));
         try {
-            target.sendIntent(context, 0, fillIn, null, null);
+            final BroadcastOptions options = BroadcastOptions.makeBasic();
+            options.setPendingIntentBackgroundActivityLaunchAllowed(false);
+            target.sendIntent(context, 0, fillIn, null /* onFinished*/,
+                    null /* handler */, null /* requiredPermission */, options.toBundle());
         } catch (SendIntentException ignored) {
         }
     }
",8,2,"PackageManagerService::freeStorage, PackageManagerService::onRestoreComplete"
254,e026818a26445b2a67b55108e1e3e05ca01ccb7b,ActivityRecord.java,"@@ -804,13 +804,6 @@ final class ActivityRecord extends WindowToken implements WindowManagerService.A
 
     private AppSaturationInfo mLastAppSaturationInfo;
 
-    private final ActivityRecordInputSink mActivityRecordInputSink;
-
-    // Activities with this uid are allowed to not create an input sink while being in the same
-    // task and directly above this ActivityRecord. This field is updated whenever a new activity
-    // is launched from this ActivityRecord. Touches are always allowed within the same uid.
-    int mAllowedTouchUid;
-
     private final ColorDisplayService.ColorTransformController mColorTransformController =
             (matrix, translation) -> mWmService.mH.post(() -> {
                 synchronized (mWmService.mGlobalLock) {
@@ -1848,8 +1841,6 @@ final class ActivityRecord extends WindowToken implements WindowManagerService.A
             createTime = _createTime;
         }
         mAtmService.mPackageConfigPersister.updateConfigIfNeeded(this, mUserId, packageName);
-
-        mActivityRecordInputSink = new ActivityRecordInputSink(this, sourceRecord);
     }
 
     /**
@@ -3776,7 +3767,6 @@ final class ActivityRecord extends WindowToken implements WindowManagerService.A
         } else {
             onRemovedFromDisplay();
         }
-        mActivityRecordInputSink.releaseSurfaceControl();
         super.removeImmediately();
     }
 
@@ -6936,9 +6926,6 @@ final class ActivityRecord extends WindowToken implements WindowManagerService.A
             } else if (!show && mLastSurfaceShowing) {
                 getSyncTransaction().hide(mSurfaceControl);
             }
-            if (show) {
-                mActivityRecordInputSink.applyChangesToSurfaceIfChanged(getSyncTransaction());
-            }
         }
         if (mThumbnail != null) {
             mThumbnail.setShowing(getPendingTransaction(), show);
",0,13,"ActivityRecord::prepareSurfaces, ActivityRecord::removeImmediately, ActivityRecord::ActivityRecord"
255,e026818a26445b2a67b55108e1e3e05ca01ccb7b,ActivityRecordInputSink.java,"@@ -1,113 +0,0 @@
-/*
- * Copyright (C) 2022 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.server.wm;
-
-import android.os.Process;
-import android.view.InputWindowHandle;
-import android.view.SurfaceControl;
-import android.view.WindowManager;
-
-/**
- * Creates a InputWindowHandle that catches all touches that would otherwise pass through an
- * Activity.
- */
-class ActivityRecordInputSink {
-
-    private final ActivityRecord mActivityRecord;
-    private final String mName;
-
-    private InputWindowHandle mInputWindowHandle;
-    private SurfaceControl mSurfaceControl;
-
-    ActivityRecordInputSink(ActivityRecord activityRecord, ActivityRecord sourceRecord) {
-        mActivityRecord = activityRecord;
-        mName = Integer.toHexString(System.identityHashCode(this)) + "" ActivityRecordInputSink ""
-                + mActivityRecord.mActivityComponent.flattenToShortString();
-        if (sourceRecord != null) {
-            sourceRecord.mAllowedTouchUid = mActivityRecord.getUid();
-        }
-    }
-
-    public void applyChangesToSurfaceIfChanged(SurfaceControl.Transaction transaction) {
-        boolean windowHandleChanged = updateInputWindowHandle();
-        if (mSurfaceControl == null) {
-            mSurfaceControl = createSurface(transaction);
-        }
-        if (windowHandleChanged) {
-            transaction.setInputWindowInfo(mSurfaceControl, mInputWindowHandle);
-        }
-    }
-
-    private SurfaceControl createSurface(SurfaceControl.Transaction t) {
-        SurfaceControl surfaceControl = mActivityRecord.makeChildSurface(null)
-                .setName(mName)
-                .setHidden(false)
-                .setCallsite(""ActivityRecordInputSink.createSurface"")
-                .build();
-        // Put layer below all siblings (and the parent surface too)
-        t.setLayer(surfaceControl, Integer.MIN_VALUE);
-        return surfaceControl;
-    }
-
-    private boolean updateInputWindowHandle() {
-        boolean changed = false;
-        if (mInputWindowHandle == null) {
-            mInputWindowHandle = createInputWindowHandle();
-            changed = true;
-        }
-        // Don't block touches from passing through to an activity below us in the same task, if
-        // that activity is either from the same uid or if that activity has launched an activity
-        // in our uid.
-        final ActivityRecord activityBelowInTask =
-                mActivityRecord.getTask().getActivityBelow(mActivityRecord);
-        final boolean allowPassthrough = activityBelowInTask != null && (
-                activityBelowInTask.mAllowedTouchUid == mActivityRecord.getUid()
-                        || activityBelowInTask.isUid(mActivityRecord.getUid()));
-        boolean notTouchable = (mInputWindowHandle.layoutParamsFlags
-                & WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE) != 0;
-        if (allowPassthrough || mActivityRecord.isAppTransitioning()) {
-            mInputWindowHandle.layoutParamsFlags |= WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;
-            changed |= !notTouchable;
-        } else {
-            mInputWindowHandle.layoutParamsFlags &= ~WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;
-            changed |= notTouchable;
-        }
-        return changed;
-    }
-
-    private InputWindowHandle createInputWindowHandle() {
-        InputWindowHandle inputWindowHandle = new InputWindowHandle(null,
-                mActivityRecord.getDisplayId());
-        inputWindowHandle.replaceTouchableRegionWithCrop = true;
-        inputWindowHandle.name = mName;
-        inputWindowHandle.layoutParamsType = WindowManager.LayoutParams.TYPE_INPUT_CONSUMER;
-        inputWindowHandle.ownerUid = Process.myUid();
-        inputWindowHandle.ownerPid = Process.myPid();
-        inputWindowHandle.layoutParamsFlags = WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
-        inputWindowHandle.inputFeatures =
-                WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL;
-        return inputWindowHandle;
-    }
-
-    void releaseSurfaceControl() {
-        if (mSurfaceControl != null) {
-            mSurfaceControl.release();
-            mSurfaceControl = null;
-        }
-    }
-
-}
",0,113,"ActivityRecordInputSink::createSurface, ActivityRecordInputSink::updateInputWindowHandle, ActivityRecordInputSink::applyChangesToSurfaceIfChanged, ActivityRecordInputSink::ActivityRecordInputSink, ActivityRecordInputSink::releaseSurfaceControl, ActivityRecordInputSink::createInputWindowHandle"
256,a0f0bd03a63c7a982209c0997637eb4797d0b3d9,PackageManagerService.java,"@@ -26939,10 +26939,10 @@ public class PackageManagerService extends IPackageManager.Stub
             // will be null whereas dataOwnerPkg will contain information about the package
             // which was uninstalled while keeping its data.
             AndroidPackage dataOwnerPkg = mPackages.get(packageName);
+            PackageSetting dataOwnerPs = mSettings.getPackageLPr(packageName);
             if (dataOwnerPkg  == null) {
-                PackageSetting ps = mSettings.getPackageLPr(packageName);
-                if (ps != null) {
-                    dataOwnerPkg = ps.pkg;
+                if (dataOwnerPs != null) {
+                    dataOwnerPkg = dataOwnerPs.getPkg();
                 }
             }
 
@@ -26966,12 +26966,30 @@ public class PackageManagerService extends IPackageManager.Stub
             if (dataOwnerPkg != null) {
                 if (!PackageManagerServiceUtils.isDowngradePermitted(installFlags,
                         dataOwnerPkg.isDebuggable())) {
+                    // Downgrade is not permitted; a lower version of the app will not be allowed
                     try {
                         checkDowngrade(dataOwnerPkg, pkgLite);
                     } catch (PackageManagerException e) {
                         Slog.w(TAG, ""Downgrade detected: "" + e.getMessage());
                         return PackageManager.INSTALL_FAILED_VERSION_DOWNGRADE;
                     }
+                } else if (dataOwnerPs.isSystem()) {
+                    // Downgrade is permitted, but system apps can't be downgraded below
+                    // the version preloaded onto the system image
+                    final PackageSetting disabledPs = mSettings.getDisabledSystemPkgLPr(
+                            dataOwnerPs);
+                    if (disabledPs != null) {
+                        dataOwnerPkg = disabledPs.getPkg();
+                    }
+                    try {
+                        checkDowngrade(dataOwnerPkg, pkgLite);
+                    } catch (PackageManagerException e) {
+                        String errorMsg = ""System app: "" + packageName + "" cannot be downgraded to""
+                                + "" older than its preloaded version on the system image. ""
+                                + e.getMessage();
+                        Slog.w(TAG, errorMsg);
+                        return PackageManager.INSTALL_FAILED_VERSION_DOWNGRADE;
+                    }
                 }
             }
         }
",21,3,PackageManagerService::verifyReplacingVersionCode
257,84a1cc875280fd7a2b60642303a1755f5edcdfaa,PackageManagerService.java,"@@ -26981,14 +26981,18 @@ public class PackageManagerService extends IPackageManager.Stub
                     if (disabledPs != null) {
                         dataOwnerPkg = disabledPs.getPkg();
                     }
-                    try {
-                        checkDowngrade(dataOwnerPkg, pkgLite);
-                    } catch (PackageManagerException e) {
-                        String errorMsg = ""System app: "" + packageName + "" cannot be downgraded to""
-                                + "" older than its preloaded version on the system image. ""
-                                + e.getMessage();
-                        Slog.w(TAG, errorMsg);
-                        return PackageManager.INSTALL_FAILED_VERSION_DOWNGRADE;
+                    if (!Build.IS_DEBUGGABLE && !dataOwnerPkg.isDebuggable()) {
+                        // Only restrict non-debuggable builds and non-debuggable version of the app
+                        try {
+                            checkDowngrade(dataOwnerPkg, pkgLite);
+                        } catch (PackageManagerException e) {
+                            String errorMsg = ""System app: "" + packageName
+                                    + "" cannot be downgraded to""
+                                    + "" older than its preloaded version on the system image. ""
+                                    + e.getMessage();
+                            Slog.w(TAG, errorMsg);
+                            return PackageManager.INSTALL_FAILED_VERSION_DOWNGRADE;
+                        }
                     }
                 }
             }
",12,8,PackageManagerService::verifyReplacingVersionCode
258,79d93158979161d6d3a842ec9400a03c5074e06f,AccessibilityService.java,"@@ -2054,6 +2054,10 @@ public abstract class AccessibilityService extends Service {
         IAccessibilityServiceConnection connection =
                 AccessibilityInteractionClient.getInstance(this).getConnection(mConnectionId);
         if (mInfo != null && connection != null) {
+            if (!mInfo.isWithinParcelableSize()) {
+                throw new IllegalStateException(
+                        ""Cannot update service info: size is larger than safe parcelable limits."");
+            }
             try {
                 connection.setServiceInfo(mInfo);
                 mInfo = null;
",4,0,AccessibilityService::sendServiceInfo
259,79d93158979161d6d3a842ec9400a03c5074e06f,AccessibilityServiceInfo.java,"@@ -40,6 +40,7 @@ import android.content.res.XmlResourceParser;
 import android.graphics.drawable.Drawable;
 import android.hardware.fingerprint.FingerprintManager;
 import android.os.Build;
+import android.os.IBinder;
 import android.os.Parcel;
 import android.os.Parcelable;
 import android.os.RemoteException;
@@ -1063,6 +1064,15 @@ public class AccessibilityServiceInfo implements Parcelable {
         return 0;
     }
 
+    /** @hide */
+    public final boolean isWithinParcelableSize() {
+        final Parcel parcel = Parcel.obtain();
+        writeToParcel(parcel, 0);
+        final boolean result = parcel.dataSize() <= IBinder.MAX_IPC_SIZE;
+        parcel.recycle();
+        return result;
+    }
+
     public void writeToParcel(Parcel parcel, int flagz) {
         parcel.writeInt(eventTypes);
         parcel.writeStringArray(packageNames);
",10,0,AccessibilityServiceInfo::isWithinParcelableSize
260,79d93158979161d6d3a842ec9400a03c5074e06f,AccessibilityManagerService.java,"@@ -1610,6 +1610,12 @@ public class AccessibilityManagerService extends IAccessibilityManager.Stub
             AccessibilityServiceInfo accessibilityServiceInfo;
             try {
                 accessibilityServiceInfo = new AccessibilityServiceInfo(resolveInfo, mContext);
+                if (!accessibilityServiceInfo.isWithinParcelableSize()) {
+                    Slog.e(LOG_TAG, ""Skipping service ""
+                            + accessibilityServiceInfo.getResolveInfo().getComponentInfo()
+                            + "" because service info size is larger than safe parcelable limits."");
+                    continue;
+                }
                 if (userState.mCrashedServices.contains(serviceInfo.getComponentName())) {
                     // Restore the crashed attribute.
                     accessibilityServiceInfo.crashed = true;
",6,0,AccessibilityManagerService::readInstalledAccessibilityServiceLocked
261,250579138c44374e207d60a71637490e797ef540,Uri.java,"@@ -1205,13 +1205,16 @@ public abstract class Uri implements Parcelable, Comparable<Uri> {
         }
 
         static Uri readFrom(Parcel parcel) {
-            return new HierarchicalUri(
-                parcel.readString8(),
-                Part.readFrom(parcel),
-                PathPart.readFrom(parcel),
-                Part.readFrom(parcel),
-                Part.readFrom(parcel)
-            );
+            final String scheme = parcel.readString8();
+            final Part authority = Part.readFrom(parcel);
+            // In RFC3986 the path should be determined based on whether there is a scheme or
+            // authority present (https://www.rfc-editor.org/rfc/rfc3986.html#section-3.3).
+            final boolean hasSchemeOrAuthority =
+                    (scheme != null && scheme.length() > 0) || !authority.isEmpty();
+            final PathPart path = PathPart.readFrom(hasSchemeOrAuthority, parcel);
+            final Part query = Part.readFrom(parcel);
+            final Part fragment = Part.readFrom(parcel);
+            return new HierarchicalUri(scheme, authority, path, query, fragment);
         }
 
         public int describeContents() {
@@ -2270,6 +2273,11 @@ public abstract class Uri implements Parcelable, Comparable<Uri> {
             }
         }
 
+        static PathPart readFrom(boolean hasSchemeOrAuthority, Parcel parcel) {
+            final PathPart path = readFrom(parcel);
+            return hasSchemeOrAuthority ? makeAbsolute(path) : path;
+        }
+
         /**
          * Creates a path from the encoded string.
          *
",15,7,"Uri::HierarchicalUri::readFrom, Uri::PathPart::readFrom"
262,250579138c44374e207d60a71637490e797ef540,UriTest.java,"@@ -48,6 +48,7 @@ public class UriTest extends TestCase {
     public void testParcelling() {
         parcelAndUnparcel(Uri.parse(""foo:bob%20lee""));
         parcelAndUnparcel(Uri.fromParts(""foo"", ""bob lee"", ""fragment""));
+        parcelAndUnparcel(Uri.fromParts(""https"", ""www.google.com"", null));
         parcelAndUnparcel(new Uri.Builder()
             .scheme(""http"")
             .authority(""crazybob.org"")
@@ -890,9 +891,62 @@ public class UriTest extends TestCase {
             Throwable targetException = expected.getTargetException();
             // Check that the exception was thrown for the correct reason.
             assertEquals(""Unknown representation: 0"", targetException.getMessage());
+        } finally {
+            parcel.recycle();
         }
     }
 
+    private Uri buildUriFromRawParcel(boolean argumentsEncoded,
+                                      String scheme,
+                                      String authority,
+                                      String path,
+                                      String query,
+                                      String fragment) {
+        // Representation value (from AbstractPart.REPRESENTATION_{ENCODED,DECODED}).
+        final int representation = argumentsEncoded ? 1 : 2;
+        Parcel parcel = Parcel.obtain();
+        try {
+            parcel.writeInt(3);  // hierarchical
+            parcel.writeString8(scheme);
+            parcel.writeInt(representation);
+            parcel.writeString8(authority);
+            parcel.writeInt(representation);
+            parcel.writeString8(path);
+            parcel.writeInt(representation);
+            parcel.writeString8(query);
+            parcel.writeInt(representation);
+            parcel.writeString8(fragment);
+            parcel.setDataPosition(0);
+            return Uri.CREATOR.createFromParcel(parcel);
+        } finally {
+            parcel.recycle();
+        }
+    }
+
+    public void testUnparcelMalformedPath() {
+        // Regression tests for b/171966843.
+
+        // Test cases with arguments encoded (covering testing `scheme` * `authority` options).
+        Uri uri0 = buildUriFromRawParcel(true, ""https"", ""google.com"", ""@evil.com"", null, null);
+        assertEquals(""https://google.com/@evil.com"", uri0.toString());
+        Uri uri1 = buildUriFromRawParcel(true, null, ""google.com"", ""@evil.com"", ""name=spark"", ""x"");
+        assertEquals(""//google.com/@evil.com?name=spark#x"", uri1.toString());
+        Uri uri2 = buildUriFromRawParcel(true, ""http:"", null, ""@evil.com"", null, null);
+        assertEquals(""http::/@evil.com"", uri2.toString());
+        Uri uri3 = buildUriFromRawParcel(true, null, null, ""@evil.com"", null, null);
+        assertEquals(""@evil.com"", uri3.toString());
+
+        // Test cases with arguments not encoded (covering testing `scheme` * `authority` options).
+        Uri uriA = buildUriFromRawParcel(false, ""https"", ""google.com"", ""@evil.com"", null, null);
+        assertEquals(""https://google.com/%40evil.com"", uriA.toString());
+        Uri uriB = buildUriFromRawParcel(false, null, ""google.com"", ""@evil.com"", null, null);
+        assertEquals(""//google.com/%40evil.com"", uriB.toString());
+        Uri uriC = buildUriFromRawParcel(false, ""http:"", null, ""@evil.com"", null, null);
+        assertEquals(""http::/%40evil.com"", uriC.toString());
+        Uri uriD = buildUriFromRawParcel(false, null, null, ""@evil.com"", ""name=spark"", ""y"");
+        assertEquals(""%40evil.com?name%3Dspark#y"", uriD.toString());
+    }
+
     public void testToSafeString() {
         checkToSafeString(""tel:xxxxxx"", ""tel:Google"");
         checkToSafeString(""tel:xxxxxxxxxx"", ""tel:1234567890"");
",54,0,"UriTest::testUnparcelMalformedPath, UriTest::buildUriFromRawParcel, UriTest::testParcelling, UriTest::assertUnparcelLegacyPart_fails"
263,e82446502de5989274829c70b84bf43b2d217001,PhoneAccount.java,"@@ -517,6 +517,11 @@ public final class PhoneAccount implements Parcelable {
 
         /**
          * Sets the address. See {@link PhoneAccount#getAddress}.
+         * <p>
+         * Note: The entire URI value is limited to 256 characters. This check is
+         * enforced when registering the PhoneAccount via
+         * {@link TelecomManager#registerPhoneAccount(PhoneAccount)} and will cause an
+         * {@link IllegalArgumentException} to be thrown if URI is over 256.
          *
          * @param value The address of the phone account.
          * @return The builder.
@@ -550,6 +555,10 @@ public final class PhoneAccount implements Parcelable {
 
         /**
          * Sets the icon. See {@link PhoneAccount#getIcon}.
+         * <p>
+         * Note: An {@link IllegalArgumentException} if the Icon cannot be written to memory.
+         * This check is enforced when registering the PhoneAccount via
+         * {@link TelecomManager#registerPhoneAccount(PhoneAccount)}
          *
          * @param icon The icon to set.
          */
@@ -583,6 +592,10 @@ public final class PhoneAccount implements Parcelable {
         /**
          * Specifies an additional URI scheme supported by the {@link PhoneAccount}.
          *
+         * <p>
+         * Each URI scheme is limited to 256 characters.  Adding a scheme over 256 characters will
+         * cause an {@link IllegalArgumentException} to be thrown when the account is registered.
+         *
          * @param uriScheme The URI scheme.
          * @return The builder.
          */
@@ -596,6 +609,12 @@ public final class PhoneAccount implements Parcelable {
         /**
          * Specifies the URI schemes supported by the {@link PhoneAccount}.
          *
+         * <p>
+         * A max of 10 URI schemes can be added per account.  Additionally, each URI scheme is
+         * limited to 256 characters. Adding more than 10 URI schemes or 256 characters on any
+         * scheme will cause an {@link IllegalArgumentException} to be thrown when the account
+         * is registered.
+         *
          * @param uriSchemes The URI schemes.
          * @return The builder.
          */
",19,0,
264,802dbc02ee70de1385060424e42497a22a6a0484,ActivityRecord.java,"@@ -804,6 +804,13 @@ final class ActivityRecord extends WindowToken implements WindowManagerService.A
 
     private AppSaturationInfo mLastAppSaturationInfo;
 
+    private final ActivityRecordInputSink mActivityRecordInputSink;
+
+    // Activities with this uid are allowed to not create an input sink while being in the same
+    // task and directly above this ActivityRecord. This field is updated whenever a new activity
+    // is launched from this ActivityRecord. Touches are always allowed within the same uid.
+    int mAllowedTouchUid;
+
     private final ColorDisplayService.ColorTransformController mColorTransformController =
             (matrix, translation) -> mWmService.mH.post(() -> {
                 synchronized (mWmService.mGlobalLock) {
@@ -1841,6 +1848,8 @@ final class ActivityRecord extends WindowToken implements WindowManagerService.A
             createTime = _createTime;
         }
         mAtmService.mPackageConfigPersister.updateConfigIfNeeded(this, mUserId, packageName);
+
+        mActivityRecordInputSink = new ActivityRecordInputSink(this, sourceRecord);
     }
 
     /**
@@ -3767,6 +3776,7 @@ final class ActivityRecord extends WindowToken implements WindowManagerService.A
         } else {
             onRemovedFromDisplay();
         }
+        mActivityRecordInputSink.releaseSurfaceControl();
         super.removeImmediately();
     }
 
@@ -6926,6 +6936,9 @@ final class ActivityRecord extends WindowToken implements WindowManagerService.A
             } else if (!show && mLastSurfaceShowing) {
                 getSyncTransaction().hide(mSurfaceControl);
             }
+            if (show) {
+                mActivityRecordInputSink.applyChangesToSurfaceIfChanged(getSyncTransaction());
+            }
         }
         if (mThumbnail != null) {
             mThumbnail.setShowing(getPendingTransaction(), show);
",13,0,"ActivityRecord::prepareSurfaces, ActivityRecord::removeImmediately, ActivityRecord::ActivityRecord"
265,802dbc02ee70de1385060424e42497a22a6a0484,ActivityRecordInputSink.java,"@@ -0,0 +1,117 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.wm;
+
+import android.os.Process;
+import android.view.InputWindowHandle;
+import android.view.SurfaceControl;
+import android.view.WindowManager;
+
+/**
+ * Creates a InputWindowHandle that catches all touches that would otherwise pass through an
+ * Activity.
+ */
+class ActivityRecordInputSink {
+
+    private final ActivityRecord mActivityRecord;
+    private final String mName;
+
+    private InputWindowHandle mInputWindowHandle;
+    private SurfaceControl mSurfaceControl;
+
+    ActivityRecordInputSink(ActivityRecord activityRecord, ActivityRecord sourceRecord) {
+        mActivityRecord = activityRecord;
+        mName = Integer.toHexString(System.identityHashCode(this)) + "" ActivityRecordInputSink ""
+                + mActivityRecord.mActivityComponent.flattenToShortString();
+        if (sourceRecord != null) {
+            sourceRecord.mAllowedTouchUid = mActivityRecord.getUid();
+        }
+    }
+
+    public void applyChangesToSurfaceIfChanged(SurfaceControl.Transaction transaction) {
+        boolean windowHandleChanged = updateInputWindowHandle();
+        if (mSurfaceControl == null) {
+            mSurfaceControl = createSurface(transaction);
+        }
+        if (windowHandleChanged) {
+            transaction.setInputWindowInfo(mSurfaceControl, mInputWindowHandle);
+        }
+    }
+
+    private SurfaceControl createSurface(SurfaceControl.Transaction t) {
+        SurfaceControl surfaceControl = mActivityRecord.makeChildSurface(null)
+                .setName(mName)
+                .setHidden(false)
+                .setCallsite(""ActivityRecordInputSink.createSurface"")
+                .build();
+        // Put layer below all siblings (and the parent surface too)
+        t.setLayer(surfaceControl, Integer.MIN_VALUE);
+        return surfaceControl;
+    }
+
+    private boolean updateInputWindowHandle() {
+        boolean changed = false;
+        if (mInputWindowHandle == null) {
+            mInputWindowHandle = createInputWindowHandle();
+            changed = true;
+        }
+        // Don't block touches from passing through to an activity below us in the same task, if
+        // that activity is either from the same uid or if that activity has launched an activity
+        // in our uid.
+        final ActivityRecord activityBelowInTask =
+                mActivityRecord.getTask().getActivityBelow(mActivityRecord);
+        final boolean allowPassthrough = activityBelowInTask != null && (
+                activityBelowInTask.mAllowedTouchUid == mActivityRecord.getUid()
+                        || activityBelowInTask.isUid(mActivityRecord.getUid()));
+        boolean notTouchable = (mInputWindowHandle.layoutParamsFlags
+                & WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE) != 0;
+        if (allowPassthrough || mActivityRecord.isAppTransitioning()) {
+            mInputWindowHandle.layoutParamsFlags |= WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;
+            changed |= !notTouchable;
+        } else {
+            mInputWindowHandle.layoutParamsFlags &= ~WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;
+            changed |= notTouchable;
+        }
+        if (mInputWindowHandle.displayId != mActivityRecord.getDisplayId()) {
+            mInputWindowHandle.displayId = mActivityRecord.getDisplayId();
+            changed = true;
+        }
+        return changed;
+    }
+
+    private InputWindowHandle createInputWindowHandle() {
+        InputWindowHandle inputWindowHandle = new InputWindowHandle(null,
+                mActivityRecord.getDisplayId());
+        inputWindowHandle.replaceTouchableRegionWithCrop = true;
+        inputWindowHandle.name = mName;
+        inputWindowHandle.layoutParamsType = WindowManager.LayoutParams.TYPE_INPUT_CONSUMER;
+        inputWindowHandle.ownerUid = Process.myUid();
+        inputWindowHandle.ownerPid = Process.myPid();
+        inputWindowHandle.layoutParamsFlags = WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
+        inputWindowHandle.inputFeatures =
+                WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL;
+        return inputWindowHandle;
+    }
+
+    void releaseSurfaceControl() {
+        if (mSurfaceControl != null) {
+            mSurfaceControl.release();
+            mSurfaceControl = null;
+        }
+    }
+
+}
",117,0,"ActivityRecordInputSink::createSurface, ActivityRecordInputSink::updateInputWindowHandle, ActivityRecordInputSink::applyChangesToSurfaceIfChanged, ActivityRecordInputSink::ActivityRecordInputSink, ActivityRecordInputSink::releaseSurfaceControl, ActivityRecordInputSink::createInputWindowHandle"
266,6f4c85a9fe2bd0f8f9408df001ea7651e9706dda,SnoozeHelper.java,"@@ -64,6 +64,9 @@ public class SnoozeHelper {
 
     static final int CONCURRENT_SNOOZE_LIMIT = 500;
 
+    // A safe size for strings to be put in persistent storage, to avoid breaking the XML write.
+    static final int MAX_STRING_LENGTH = 1000;
+
     protected static final String XML_TAG_NAME = ""snoozed-notifications"";
 
     private static final String XML_SNOOZED_NOTIFICATION = ""notification"";
@@ -152,7 +155,7 @@ public class SnoozeHelper {
            ArrayMap<String, Long> snoozed =
                    mPersistedSnoozedNotifications.get(getPkgKey(userId, pkg));
            if (snoozed != null) {
-               time = snoozed.get(key);
+               time = snoozed.get(getTrimmedString(key));
            }
         }
         if (time == null) {
@@ -166,7 +169,7 @@ public class SnoozeHelper {
             ArrayMap<String, String> snoozed =
                     mPersistedSnoozedNotificationsWithContext.get(getPkgKey(userId, pkg));
             if (snoozed != null) {
-                return snoozed.get(key);
+                return snoozed.get(getTrimmedString(key));
             }
         }
         return null;
@@ -251,7 +254,8 @@ public class SnoozeHelper {
         scheduleRepost(pkg, key, userId, duration);
         Long activateAt = System.currentTimeMillis() + duration;
         synchronized (mLock) {
-            storeRecordLocked(pkg, key, userId, mPersistedSnoozedNotifications, activateAt);
+            storeRecordLocked(pkg, getTrimmedString(key), userId, mPersistedSnoozedNotifications,
+                    activateAt);
         }
     }
 
@@ -262,8 +266,10 @@ public class SnoozeHelper {
         int userId = record.getUser().getIdentifier();
         if (contextId != null) {
             synchronized (mLock) {
-                storeRecordLocked(record.getSbn().getPackageName(), record.getKey(),
-                        userId, mPersistedSnoozedNotificationsWithContext, contextId);
+                storeRecordLocked(record.getSbn().getPackageName(),
+                        getTrimmedString(record.getKey()),
+                        userId, mPersistedSnoozedNotificationsWithContext,
+                        getTrimmedString(contextId));
             }
         }
         snooze(record);
@@ -280,6 +286,13 @@ public class SnoozeHelper {
         }
     }
 
+    private String getTrimmedString(String key) {
+        if (key != null && key.length() > MAX_STRING_LENGTH) {
+            return key.substring(0, MAX_STRING_LENGTH);
+        }
+        return key;
+    }
+
     private <T> void storeRecordLocked(String pkg, String key, Integer userId,
             ArrayMap<String, ArrayMap<String, T>> targets, T object) {
 
@@ -384,12 +397,14 @@ public class SnoozeHelper {
     }
 
     protected void repost(String key, int userId, boolean muteOnReturn) {
+        final String trimmedKey = getTrimmedString(key);
+
         NotificationRecord record;
         synchronized (mLock) {
             final String pkg = mPackages.remove(key);
             mUsers.remove(key);
-            removeRecordLocked(pkg, key, userId, mPersistedSnoozedNotifications);
-            removeRecordLocked(pkg, key, userId, mPersistedSnoozedNotificationsWithContext);
+            removeRecordLocked(pkg, trimmedKey, userId, mPersistedSnoozedNotifications);
+            removeRecordLocked(pkg, trimmedKey, userId, mPersistedSnoozedNotificationsWithContext);
             ArrayMap<String, NotificationRecord> records =
                     mSnoozedNotifications.get(getPkgKey(userId, pkg));
             if (records == null) {
",22,7,"SnoozeHelper::repost, SnoozeHelper::snooze, SnoozeHelper::getTrimmedString, SnoozeHelper::snooze, SnoozeHelper::getSnoozeTimeForUnpostedNotification, SnoozeHelper::getSnoozeContextForUnpostedNotification"
267,6f4c85a9fe2bd0f8f9408df001ea7651e9706dda,SnoozeHelperTest.java,"@@ -69,6 +69,7 @@ import java.io.BufferedOutputStream;
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
+import java.util.Collections;
 
 @SmallTest
 @RunWith(AndroidJUnit4.class)
@@ -247,6 +248,37 @@ public class SnoozeHelperTest extends UiServiceTestCase {
         assertEquals(""key2"", captor2.getValue().getIntent().getStringExtra(EXTRA_KEY));
     }
 
+    @Test
+    public void testLongTagPersistedNotification() throws Exception {
+        String longTag = String.join("""", Collections.nCopies(66000, ""A""));
+        NotificationRecord r = getNotificationRecord(""pkg"", 1, longTag, UserHandle.SYSTEM);
+        mSnoozeHelper.snooze(r, 0);
+
+        // We store the full key in temp storage.
+        ArgumentCaptor<PendingIntent> captor = ArgumentCaptor.forClass(PendingIntent.class);
+        verify(mAm).setExactAndAllowWhileIdle(anyInt(), anyLong(), captor.capture());
+        assertEquals(66010, captor.getValue().getIntent().getStringExtra(EXTRA_KEY).length());
+
+        TypedXmlSerializer serializer = Xml.newFastSerializer();
+        ByteArrayOutputStream baos = new ByteArrayOutputStream();
+        serializer.setOutput(new BufferedOutputStream(baos), ""utf-8"");
+        serializer.startDocument(null, true);
+        mSnoozeHelper.writeXml(serializer);
+        serializer.endDocument();
+        serializer.flush();
+
+        TypedXmlPullParser parser = Xml.newFastPullParser();
+        parser.setInput(new BufferedInputStream(
+                new ByteArrayInputStream(baos.toByteArray())), ""utf-8"");
+        mSnoozeHelper.readXml(parser, 4);
+
+        mSnoozeHelper.scheduleRepostsForPersistedNotifications(5);
+
+        // We trim the key in persistent storage.
+        verify(mAm, times(2)).setExactAndAllowWhileIdle(anyInt(), anyLong(), captor.capture());
+        assertEquals(1000, captor.getValue().getIntent().getStringExtra(EXTRA_KEY).length());
+    }
+
     @Test
     public void testSnoozeForTime() throws Exception {
         NotificationRecord r = getNotificationRecord(""pkg"", 1, ""one"", UserHandle.SYSTEM);
@@ -595,13 +627,20 @@ public class SnoozeHelperTest extends UiServiceTestCase {
     public void testClearData() {
         // snooze 2 from same package
         NotificationRecord r = getNotificationRecord(""pkg"", 1, ""one"", UserHandle.SYSTEM);
-        NotificationRecord r2 = getNotificationRecord(""pkg"", 2, ""two"", UserHandle.SYSTEM);
+        NotificationRecord r2 = getNotificationRecord(""pkg"", 2,
+                ""two"" + String.join("""", Collections.nCopies(66000, ""2"")), UserHandle.SYSTEM);
         mSnoozeHelper.snooze(r, 1000);
         mSnoozeHelper.snooze(r2, 1000);
         assertTrue(mSnoozeHelper.isSnoozed(
                 UserHandle.USER_SYSTEM, r.getSbn().getPackageName(), r.getKey()));
         assertTrue(mSnoozeHelper.isSnoozed(
                 UserHandle.USER_SYSTEM, r2.getSbn().getPackageName(), r2.getKey()));
+        assertFalse(0L == mSnoozeHelper.getSnoozeTimeForUnpostedNotification(
+                r.getUser().getIdentifier(), r.getSbn().getPackageName(),
+                r.getSbn().getKey()));
+        assertFalse(0L == mSnoozeHelper.getSnoozeTimeForUnpostedNotification(
+                r2.getUser().getIdentifier(), r2.getSbn().getPackageName(),
+                r2.getSbn().getKey()));
 
         // clear data
         mSnoozeHelper.clearData(UserHandle.USER_SYSTEM, ""pkg"");
",40,1,"SnoozeHelperTest::testClearData, SnoozeHelperTest::testLongTagPersistedNotification"
268,a71883f3081348371482d96d71dc119ef2f7d463,ShortcutPackage.java,"@@ -405,6 +405,7 @@ class ShortcutPackage extends ShortcutPackageItem {
             @NonNull List<ShortcutInfo> changedShortcuts) {
         Preconditions.checkArgument(newShortcut.isEnabled(),
                 ""pushDynamicShortcuts() cannot publish disabled shortcuts"");
+        ensureShortcutCountBeforePush();
 
         newShortcut.addFlags(ShortcutInfo.FLAG_DYNAMIC);
 
@@ -412,7 +413,7 @@ class ShortcutPackage extends ShortcutPackageItem {
         final ShortcutInfo oldShortcut = findShortcutById(newShortcut.getId());
         boolean deleted = false;
 
-        if (oldShortcut == null) {
+        if (oldShortcut == null || !oldShortcut.isDynamic()) {
             final ShortcutService service = mShortcutUser.mService;
             final int maxShortcuts = service.getMaxActivityShortcuts();
 
@@ -422,7 +423,6 @@ class ShortcutPackage extends ShortcutPackageItem {
 
             if (activityShortcuts != null && activityShortcuts.size() == maxShortcuts) {
                 // Max has reached. Delete the shortcut with lowest rank.
-
                 // Sort by isManifestShortcut() and getRank().
                 Collections.sort(activityShortcuts, mShortcutTypeAndRankComparator);
 
@@ -437,7 +437,8 @@ class ShortcutPackage extends ShortcutPackageItem {
                 changedShortcuts.add(shortcut);
                 deleted = deleteDynamicWithId(shortcut.getId(), /*ignoreInvisible=*/ true) != null;
             }
-        } else {
+        }
+        if (oldShortcut != null) {
             // It's an update case.
             // Make sure the target is updatable. (i.e. should be mutable.)
             oldShortcut.ensureUpdatableWith(newShortcut, /*isUpdating=*/ false);
@@ -463,6 +464,32 @@ class ShortcutPackage extends ShortcutPackageItem {
         return deleted;
     }
 
+    private void ensureShortcutCountBeforePush() {
+        final ShortcutService service = mShortcutUser.mService;
+        // Ensure the total number of shortcuts doesn't exceed the hard limit per app.
+        final int maxShortcutPerApp = service.getMaxAppShortcuts();
+        synchronized (mLock) {
+            final List<ShortcutInfo> appShortcuts = mShortcuts.values().stream().filter(si ->
+                    !si.isPinned()).collect(Collectors.toList());
+            if (appShortcuts.size() >= maxShortcutPerApp) {
+                // Max has reached. Removes shortcuts until they fall within the hard cap.
+                // Sort by isManifestShortcut(), isDynamic() and getLastChangedTimestamp().
+                Collections.sort(appShortcuts, mShortcutTypeRankAndTimeComparator);
+
+                while (appShortcuts.size() >= maxShortcutPerApp) {
+                    final ShortcutInfo shortcut = appShortcuts.remove(appShortcuts.size() - 1);
+                    if (shortcut.isDeclaredInManifest()) {
+                        // All shortcuts are manifest shortcuts and cannot be removed.
+                        throw new IllegalArgumentException(getPackageName() + "" has published ""
+                                + appShortcuts.size() + "" manifest shortcuts across different""
+                                + "" activities."");
+                    }
+                    forceDeleteShortcutInner(shortcut.getId());
+                }
+            }
+        }
+    }
+
     /**
      * Remove all shortcuts that aren't pinned, cached nor dynamic.
      *
@@ -1368,6 +1395,61 @@ class ShortcutPackage extends ShortcutPackageItem {
         return Integer.compare(a.getRank(), b.getRank());
     };
 
+    /**
+     * To sort by isManifestShortcut(), isDynamic(), getRank() and
+     * getLastChangedTimestamp(). i.e. manifest shortcuts come before non-manifest shortcuts,
+     * dynamic shortcuts come before floating shortcuts, then sort by last changed timestamp.
+     *
+     * This is used to decide which shortcuts to remove when the total number of shortcuts retained
+     * for the app exceeds the limit defined in {@link ShortcutService#getMaxAppShortcuts()}.
+     *
+     * (Note the number of manifest shortcuts is always <= the max number, because if there are
+     * more, ShortcutParser would ignore the rest.)
+     */
+    final Comparator<ShortcutInfo> mShortcutTypeRankAndTimeComparator = (ShortcutInfo a,
+            ShortcutInfo b) -> {
+        if (a.isDeclaredInManifest() && !b.isDeclaredInManifest()) {
+            return -1;
+        }
+        if (!a.isDeclaredInManifest() && b.isDeclaredInManifest()) {
+            return 1;
+        }
+        if (a.isDynamic() && b.isDynamic()) {
+            return Integer.compare(a.getRank(), b.getRank());
+        }
+        if (a.isDynamic()) {
+            return -1;
+        }
+        if (b.isDynamic()) {
+            return 1;
+        }
+        if (a.isCached() && b.isCached()) {
+            // if both shortcuts are cached, prioritize shortcuts cached by people tile,
+            if (a.hasFlags(ShortcutInfo.FLAG_CACHED_PEOPLE_TILE)
+                    && !b.hasFlags(ShortcutInfo.FLAG_CACHED_PEOPLE_TILE)) {
+                return -1;
+            } else if (!a.hasFlags(ShortcutInfo.FLAG_CACHED_PEOPLE_TILE)
+                    && b.hasFlags(ShortcutInfo.FLAG_CACHED_PEOPLE_TILE)) {
+                return 1;
+            }
+            // followed by bubbles.
+            if (a.hasFlags(ShortcutInfo.FLAG_CACHED_BUBBLES)
+                    && !b.hasFlags(ShortcutInfo.FLAG_CACHED_BUBBLES)) {
+                return -1;
+            } else if (!a.hasFlags(ShortcutInfo.FLAG_CACHED_BUBBLES)
+                    && b.hasFlags(ShortcutInfo.FLAG_CACHED_BUBBLES)) {
+                return 1;
+            }
+        }
+        if (a.isCached()) {
+            return -1;
+        }
+        if (b.isCached()) {
+            return 1;
+        }
+        return Long.compare(b.getLastChangedTimestamp(), a.getLastChangedTimestamp());
+    };
+
     /**
      * Build a list of shortcuts for each target activity and return as a map. The result won't
      * contain ""floating"" shortcuts because they don't belong on any activities.
",85,3,"ShortcutPackage::ensureShortcutCountBeforePush, ShortcutPackage::if, ShortcutPackage::if, ShortcutPackage::if, ShortcutPackage::if, ShortcutPackage::if, ShortcutPackage::if, ShortcutPackage::if, ShortcutPackage::pushDynamicShortcut, ShortcutPackage::if"
269,a71883f3081348371482d96d71dc119ef2f7d463,ShortcutService.java,"@@ -179,6 +179,9 @@ public class ShortcutService extends IShortcutService.Stub {
     @VisibleForTesting
     static final int DEFAULT_MAX_SHORTCUTS_PER_ACTIVITY = 15;
 
+    @VisibleForTesting
+    static final int DEFAULT_MAX_SHORTCUTS_PER_APP = 100;
+
     @VisibleForTesting
     static final int DEFAULT_MAX_ICON_DIMENSION_DP = 96;
 
@@ -253,6 +256,11 @@ public class ShortcutService extends IShortcutService.Stub {
          */
         String KEY_MAX_SHORTCUTS = ""max_shortcuts"";
 
+        /**
+         * Key name for the max shortcuts can be retained in system ram per app. (int)
+         */
+        String KEY_MAX_SHORTCUTS_PER_APP = ""max_shortcuts_per_app"";
+
         /**
          * Key name for icon compression quality, 0-100.
          */
@@ -325,10 +333,15 @@ public class ShortcutService extends IShortcutService.Stub {
             new SparseArray<>();
 
     /**
-     * Max number of dynamic + manifest shortcuts that each application can have at a time.
+     * Max number of dynamic + manifest shortcuts that each activity can have at a time.
      */
     private int mMaxShortcuts;
 
+    /**
+     * Max number of shortcuts that can exists in system ram for each application.
+     */
+    private int mMaxShortcutsPerApp;
+
     /**
      * Max number of updating API calls that each application can make during the interval.
      */
@@ -790,6 +803,9 @@ public class ShortcutService extends IShortcutService.Stub {
         mMaxShortcuts = Math.max(0, (int) parser.getLong(
                 ConfigConstants.KEY_MAX_SHORTCUTS, DEFAULT_MAX_SHORTCUTS_PER_ACTIVITY));
 
+        mMaxShortcutsPerApp = Math.max(0, (int) parser.getLong(
+                ConfigConstants.KEY_MAX_SHORTCUTS_PER_APP, DEFAULT_MAX_SHORTCUTS_PER_APP));
+
         final int iconDimensionDp = Math.max(1, injectIsLowRamDevice()
                 ? (int) parser.getLong(
                 ConfigConstants.KEY_MAX_ICON_DIMENSION_DP_LOWRAM,
@@ -1757,6 +1773,13 @@ public class ShortcutService extends IShortcutService.Stub {
         return mMaxShortcuts;
     }
 
+    /**
+     * Return the max number of shortcuts can be retaiend in system ram for each application.
+     */
+    int getMaxAppShortcuts() {
+        return mMaxShortcutsPerApp;
+    }
+
     /**
      * - Sends a notification to LauncherApps
      * - Write to file
",24,1,"ShortcutService::getMaxAppShortcuts, ShortcutService::updateConfigurationLocked"
270,0b338a6b51eb75b6673db99e7aa7a037bfcf6cc8,TaskFragmentOrganizer.java,"@@ -157,15 +157,6 @@ public class TaskFragmentOrganizer extends WindowOrganizer {
         super.applyTransaction(t);
     }
 
-    // Suppress the lint because it is not a registration method.
-    @SuppressWarnings(""ExecutorRegistration"")
-    @Override
-    public int applySyncTransaction(@NonNull WindowContainerTransaction t,
-            @NonNull WindowContainerTransactionCallback callback) {
-        t.setTaskFragmentOrganizer(mInterface);
-        return super.applySyncTransaction(t, callback);
-    }
-
     private final ITaskFragmentOrganizer mInterface = new ITaskFragmentOrganizer.Stub() {
         @Override
         public void onTaskFragmentAppeared(@NonNull TaskFragmentInfo taskFragmentInfo) {
",0,9,TaskFragmentOrganizer::applySyncTransaction
271,0b338a6b51eb75b6673db99e7aa7a037bfcf6cc8,WindowOrganizer.java,"@@ -61,9 +61,7 @@ public class WindowOrganizer {
      * Apply multiple WindowContainer operations at once.
      *
      * Note that using this API requires the caller to hold
-     * {@link android.Manifest.permission#MANAGE_ACTIVITY_TASKS}, unless the caller is using
-     * {@link TaskFragmentOrganizer}, in which case it is allowed to change TaskFragment that is
-     * created by itself.
+     * {@link android.Manifest.permission#MANAGE_ACTIVITY_TASKS}.
      *
      * @param t The transaction to apply.
      * @param callback This transaction will use the synchronization scheme described in
@@ -72,8 +70,7 @@ public class WindowOrganizer {
      * @return An ID for the sync operation which will later be passed to transactionReady callback.
      *         This lets the caller differentiate overlapping sync operations.
      */
-    @RequiresPermission(value = android.Manifest.permission.MANAGE_ACTIVITY_TASKS,
-            conditional = true)
+    @RequiresPermission(value = android.Manifest.permission.MANAGE_ACTIVITY_TASKS)
     public int applySyncTransaction(@NonNull WindowContainerTransaction t,
             @NonNull WindowContainerTransactionCallback callback) {
         try {
",2,5,
272,0b338a6b51eb75b6673db99e7aa7a037bfcf6cc8,WindowOrganizerController.java,"@@ -177,7 +177,7 @@ class WindowOrganizerController extends IWindowOrganizerController.Stub
         if (t == null) {
             throw new IllegalArgumentException(""Null transaction passed to applySyncTransaction"");
         }
-        enforceTaskPermission(""applySyncTransaction()"", t);
+        enforceTaskPermission(""applySyncTransaction()"");
         final CallerInfo caller = new CallerInfo();
         final long ident = Binder.clearCallingIdentity();
         try {
",1,1,WindowOrganizerController::applySyncTransaction
273,0b338a6b51eb75b6673db99e7aa7a037bfcf6cc8,TaskFragmentOrganizerControllerTest.java,"@@ -50,7 +50,6 @@ import android.window.TaskFragmentOrganizer;
 import android.window.TaskFragmentOrganizerToken;
 import android.window.WindowContainerToken;
 import android.window.WindowContainerTransaction;
-import android.window.WindowContainerTransactionCallback;
 
 import androidx.test.filters.SmallTest;
 
@@ -227,19 +226,6 @@ public class TaskFragmentOrganizerControllerTest extends WindowTestsBase {
         assertNull(mController.getRemoteAnimationDefinition(mIOrganizer));
     }
 
-    @Test
-    public void testWindowContainerTransaction_setTaskFragmentOrganizer() {
-        mOrganizer.applyTransaction(mTransaction);
-
-        assertEquals(mIOrganizer, mTransaction.getTaskFragmentOrganizer());
-
-        mTransaction = new WindowContainerTransaction();
-        mOrganizer.applySyncTransaction(
-                mTransaction, mock(WindowContainerTransactionCallback.class));
-
-        assertEquals(mIOrganizer, mTransaction.getTaskFragmentOrganizer());
-    }
-
     @Test
     public void testApplyTransaction_enforceConfigurationChangeOnOrganizedTaskFragment()
             throws RemoteException {
",0,14,TaskFragmentOrganizerControllerTest::testWindowContainerTransaction_setTaskFragmentOrganizer
274,268ad14fea89283f8f1b66902f874d3c1c95fe5b,ActivityRecord.java,"@@ -1386,6 +1386,12 @@ final class ActivityRecord extends WindowToken implements WindowManagerService.A
             mLastReportedMultiWindowMode = inPictureInPictureMode;
             ensureActivityConfiguration(0 /* globalChanges */, PRESERVE_WINDOWS,
                     true /* ignoreVisibility */);
+            if (inPictureInPictureMode && findMainWindow() == null) {
+                // Prevent malicious app entering PiP without valid WindowState, which can in turn
+                // result a non-touchable PiP window since the InputConsumer for PiP requires it.
+                EventLog.writeEvent(0x534e4554, ""265293293"", -1, """");
+                removeImmediately();
+            }
         }
     }
 
",6,0,ActivityRecord::updatePictureInPictureMode
275,b6d4b096665d9d356cadb12f16767d64945ee6e8,NotificationContentInflater.java,"@@ -439,6 +439,7 @@ public class NotificationContentInflater implements NotificationRowContentBinder
         CancellationSignal cancellationSignal = new CancellationSignal();
         cancellationSignal.setOnCancelListener(
                 () -> runningInflations.values().forEach(CancellationSignal::cancel));
+
         return cancellationSignal;
     }
 
@@ -711,6 +712,7 @@ public class NotificationContentInflater implements NotificationRowContentBinder
     public static class AsyncInflationTask extends AsyncTask<Void, Void, InflationProgress>
             implements InflationCallback, InflationTask {
 
+        private static final long IMG_PRELOAD_TIMEOUT_MS = 1000L;
         private final NotificationEntry mEntry;
         private final Context mContext;
         private final boolean mInflateSynchronously;
@@ -804,7 +806,7 @@ public class NotificationContentInflater implements NotificationRowContentBinder
                         recoveredBuilder, mIsLowPriority, mUsesIncreasedHeight,
                         mUsesIncreasedHeadsUpHeight, packageContext);
                 InflatedSmartReplyState previousSmartReplyState = mRow.getExistingSmartReplyState();
-                return inflateSmartReplyViews(
+                InflationProgress result = inflateSmartReplyViews(
                         inflationProgress,
                         mReInflateFlags,
                         mEntry,
@@ -812,6 +814,11 @@ public class NotificationContentInflater implements NotificationRowContentBinder
                         packageContext,
                         previousSmartReplyState,
                         mSmartRepliesInflater);
+
+                // wait for image resolver to finish preloading
+                mRow.getImageResolver().waitForPreloadedImages(IMG_PRELOAD_TIMEOUT_MS);
+
+                return result;
             } catch (Exception e) {
                 mError = e;
                 return null;
@@ -846,6 +853,9 @@ public class NotificationContentInflater implements NotificationRowContentBinder
                 mCallback.handleInflationException(mRow.getEntry(),
                         new InflationException(""Couldn't inflate contentViews"" + e));
             }
+
+            // Cancel any image loading tasks, not useful any more
+            mRow.getImageResolver().cancelRunningTasks();
         }
 
         @Override
@@ -872,6 +882,9 @@ public class NotificationContentInflater implements NotificationRowContentBinder
             // Notify the resolver that the inflation task has finished,
             // try to purge unnecessary cached entries.
             mRow.getImageResolver().purgeCache();
+
+            // Cancel any image loading tasks that have not completed at this point
+            mRow.getImageResolver().cancelRunningTasks();
         }
 
         private static class RtlEnabledContext extends ContextWrapper {
",14,1,"NotificationContentInflater::apply, NotificationContentInflater::AsyncInflationTask::onAsyncInflationFinished, NotificationContentInflater::AsyncInflationTask::handleError, NotificationContentInflater::AsyncInflationTask::doInBackground"
276,b6d4b096665d9d356cadb12f16767d64945ee6e8,NotificationInlineImageCache.java,"@@ -23,8 +23,11 @@ import android.util.Log;
 
 import java.io.IOException;
 import java.util.Set;
+import java.util.concurrent.CancellationException;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ExecutionException;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
 
 /**
  * A cache for inline images of image messages.
@@ -57,12 +60,13 @@ public class NotificationInlineImageCache implements NotificationInlineImageReso
     }
 
     @Override
-    public Drawable get(Uri uri) {
+    public Drawable get(Uri uri, long timeoutMs) {
         Drawable result = null;
         try {
-            result = mCache.get(uri).get();
-        } catch (InterruptedException | ExecutionException ex) {
-            Log.d(TAG, ""get: Failed get image from "" + uri);
+            result = mCache.get(uri).get(timeoutMs, TimeUnit.MILLISECONDS);
+        } catch (InterruptedException | ExecutionException
+                | TimeoutException | CancellationException ex) {
+            Log.d(TAG, ""get: Failed get image from "" + uri + "" "" + ex);
         }
         return result;
     }
@@ -73,6 +77,15 @@ public class NotificationInlineImageCache implements NotificationInlineImageReso
         mCache.entrySet().removeIf(entry -> !wantedSet.contains(entry.getKey()));
     }
 
+    @Override
+    public void cancelRunningTasks() {
+        mCache.forEach((key, value) -> {
+            if (value.getStatus() != AsyncTask.Status.FINISHED) {
+                value.cancel(true);
+            }
+        });
+    }
+
     private static class PreloadImageTask extends AsyncTask<Uri, Void, Drawable> {
         private final NotificationInlineImageResolver mResolver;
 
@@ -87,7 +100,7 @@ public class NotificationInlineImageCache implements NotificationInlineImageReso
 
             try {
                 drawable = mResolver.resolveImage(target);
-            } catch (IOException | SecurityException ex) {
+            } catch (Exception ex) {
                 Log.d(TAG, ""PreloadImageTask: Resolve failed from "" + target, ex);
             }
 
",18,5,"NotificationInlineImageCache::PreloadImageTask::doInBackground, NotificationInlineImageCache::get, NotificationInlineImageCache::cancelRunningTasks, NotificationInlineImageCache::get"
277,b6d4b096665d9d356cadb12f16767d64945ee6e8,NotificationInlineImageResolver.java,"@@ -23,6 +23,7 @@ import android.graphics.drawable.Drawable;
 import android.net.Uri;
 import android.os.Bundle;
 import android.os.Parcelable;
+import android.os.SystemClock;
 import android.util.Log;
 
 import com.android.internal.R;
@@ -46,6 +47,9 @@ import java.util.Set;
 public class NotificationInlineImageResolver implements ImageResolver {
     private static final String TAG = NotificationInlineImageResolver.class.getSimpleName();
 
+    // Timeout for loading images from ImageCache when calling from UI thread
+    private static final long MAX_UI_THREAD_TIMEOUT_MS = 100L;
+
     private final Context mContext;
     private final ImageCache mImageCache;
     private Set<Uri> mWantedUriSet;
@@ -111,30 +115,38 @@ public class NotificationInlineImageResolver implements ImageResolver {
      * To resolve image from specified uri directly. If the resulting image is larger than the
      * maximum allowed size, scale it down.
      * @param uri Uri of the image.
-     * @return Drawable of the image.
-     * @throws IOException Throws if failed at resolving the image.
+     * @return Drawable of the image, or null if unable to load.
      */
-    Drawable resolveImage(Uri uri) throws IOException {
-        return LocalImageResolver.resolveImage(uri, mContext, mMaxImageWidth, mMaxImageHeight);
+    Drawable resolveImage(Uri uri) {
+        try {
+            return LocalImageResolver.resolveImage(uri, mContext, mMaxImageWidth, mMaxImageHeight);
+        } catch (Exception ex) {
+            // Catch general Exception because ContentResolver can re-throw arbitrary Exception
+            // from remote process as a RuntimeException. See: Parcel#readException
+            Log.d(TAG, ""resolveImage: Can't load image from "" + uri, ex);
+        }
+        return null;
     }
 
+    /**
+     * Loads an image from the Uri.
+     * This method is synchronous and is usually called from the Main thread.
+     * It will time-out after MAX_UI_THREAD_TIMEOUT_MS.
+     *
+     * @param uri Uri of the target image.
+     * @return drawable of the image, null if loading failed/timeout
+     */
     @Override
     public Drawable loadImage(Uri uri) {
-        Drawable result = null;
-        try {
-            if (hasCache()) {
-                // if the uri isn't currently cached, try caching it first
-                if (!mImageCache.hasEntry(uri)) {
-                    mImageCache.preload((uri));
-                }
-                result = mImageCache.get(uri);
-            } else {
-                result = resolveImage(uri);
-            }
-        } catch (IOException | SecurityException ex) {
-            Log.d(TAG, ""loadImage: Can't load image from "" + uri, ex);
+        return hasCache() ? loadImageFromCache(uri, MAX_UI_THREAD_TIMEOUT_MS) : resolveImage(uri);
+    }
+
+    private Drawable loadImageFromCache(Uri uri, long timeoutMs) {
+        // if the uri isn't currently cached, try caching it first
+        if (!mImageCache.hasEntry(uri)) {
+            mImageCache.preload((uri));
         }
-        return result;
+        return mImageCache.get(uri, timeoutMs);
     }
 
     /**
@@ -208,6 +220,30 @@ public class NotificationInlineImageResolver implements ImageResolver {
         return mWantedUriSet;
     }
 
+    /**
+     * Wait for a maximum timeout for images to finish preloading
+     * @param timeoutMs total timeout time
+     */
+    void waitForPreloadedImages(long timeoutMs) {
+        if (!hasCache()) {
+            return;
+        }
+        Set<Uri> preloadedUris = getWantedUriSet();
+        if (preloadedUris != null) {
+            // Decrement remaining timeout after each image check
+            long endTimeMs = SystemClock.elapsedRealtime() + timeoutMs;
+            preloadedUris.forEach(
+                    uri -> loadImageFromCache(uri, endTimeMs - SystemClock.elapsedRealtime()));
+        }
+    }
+
+    void cancelRunningTasks() {
+        if (!hasCache()) {
+            return;
+        }
+        mImageCache.cancelRunningTasks();
+    }
+
     /**
      * A interface for internal cache implementation of this resolver.
      */
@@ -217,7 +253,7 @@ public class NotificationInlineImageResolver implements ImageResolver {
          * @param uri The uri of the image.
          * @return Drawable of the image.
          */
-        Drawable get(Uri uri);
+        Drawable get(Uri uri, long timeoutMs);
 
         /**
          * Set the image resolver that actually resolves image from specified uri.
@@ -242,6 +278,11 @@ public class NotificationInlineImageResolver implements ImageResolver {
          * Purge unnecessary entries in the cache.
          */
         void purge();
+
+        /**
+         * Cancel all unfinished image loading tasks
+         */
+        void cancelRunningTasks();
     }
 
 }
",60,19,"NotificationInlineImageResolver::loadImage, NotificationInlineImageResolver::waitForPreloadedImages, NotificationInlineImageResolver::resolveImage, NotificationInlineImageResolver::loadImageFromCache, NotificationInlineImageResolver::cancelRunningTasks"
278,9d3642cadf39793a856274d7f4edeb98151366a6,AppWidgetHostView.java,"@@ -31,6 +31,7 @@ import android.content.pm.LauncherActivityInfo;
 import android.content.pm.LauncherApps;
 import android.content.pm.PackageManager.NameNotFoundException;
 import android.content.res.Resources;
+import android.graphics.Canvas;
 import android.graphics.Color;
 import android.graphics.PointF;
 import android.graphics.Rect;
@@ -312,19 +313,26 @@ public class AppWidgetHostView extends FrameLayout {
             super.onLayout(changed, left, top, right, bottom);
         } catch (final RuntimeException e) {
             Log.e(TAG, ""Remote provider threw runtime exception, using error view instead."", e);
-            removeViewInLayout(mView);
-            View child = getErrorView();
-            prepareView(child);
-            addViewInLayout(child, 0, child.getLayoutParams());
-            measureChild(child, MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.EXACTLY),
-                    MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.EXACTLY));
-            child.layout(0, 0, child.getMeasuredWidth() + mPaddingLeft + mPaddingRight,
-                    child.getMeasuredHeight() + mPaddingTop + mPaddingBottom);
-            mView = child;
-            mViewMode = VIEW_MODE_ERROR;
+            handleViewError();
         }
     }
 
+    /**
+     * Remove bad view and replace with error message view
+     */
+    private void handleViewError() {
+        removeViewInLayout(mView);
+        View child = getErrorView();
+        prepareView(child);
+        addViewInLayout(child, 0, child.getLayoutParams());
+        measureChild(child, MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.EXACTLY),
+                MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.EXACTLY));
+        child.layout(0, 0, child.getMeasuredWidth() + mPaddingLeft + mPaddingRight,
+                child.getMeasuredHeight() + mPaddingTop + mPaddingBottom);
+        mView = child;
+        mViewMode = VIEW_MODE_ERROR;
+    }
+
     /**
      * Provide guidance about the size of this widget to the AppWidgetManager. The widths and
      * heights should correspond to the full area the AppWidgetHostView is given. Padding added by
@@ -940,4 +948,15 @@ public class AppWidgetHostView extends FrameLayout {
             reapplyLastRemoteViews();
         }
     }
+
+    @Override
+    protected void dispatchDraw(@NonNull Canvas canvas) {
+        try {
+            super.dispatchDraw(canvas);
+        } catch (Exception e) {
+            // Catch draw exceptions that may be caused by RemoteViews
+            Log.e(TAG, ""Drawing view failed: "" + e);
+            post(this::handleViewError);
+        }
+    }
 }
",29,10,"AppWidgetHostView::onLayout, AppWidgetHostView::dispatchDraw, AppWidgetHostView::handleViewError"
279,9d3642cadf39793a856274d7f4edeb98151366a6,ExpandableNotificationRow.java,"@@ -70,6 +70,7 @@ import android.widget.ImageView;
 import com.android.internal.annotations.VisibleForTesting;
 import com.android.internal.logging.MetricsLogger;
 import com.android.internal.logging.nano.MetricsProto.MetricsEvent;
+import com.android.internal.statusbar.IStatusBarService;
 import com.android.internal.util.ContrastColorUtil;
 import com.android.internal.widget.CachingIconView;
 import com.android.internal.widget.CallLayout;
@@ -1568,7 +1569,8 @@ public class ExpandableNotificationRow extends ActivatableNotificationView
             PeopleNotificationIdentifier peopleNotificationIdentifier,
             OnUserInteractionCallback onUserInteractionCallback,
             Optional<BubblesManager> bubblesManagerOptional,
-            NotificationGutsManager gutsManager) {
+            NotificationGutsManager gutsManager,
+            IStatusBarService statusBarService) {
         mEntry = entry;
         mAppName = appName;
         if (mMenuRow == null) {
",3,1,"ExpandableNotificationRow::initialize, ExpandableNotificationRow::initialize"
280,9d3642cadf39793a856274d7f4edeb98151366a6,ExpandableNotificationRowController.java,"@@ -25,6 +25,7 @@ import android.view.ViewGroup;
 
 import androidx.annotation.NonNull;
 
+import com.android.internal.statusbar.IStatusBarService;
 import com.android.systemui.R;
 import com.android.systemui.classifier.FalsingCollector;
 import com.android.systemui.plugins.FalsingManager;
@@ -85,6 +86,7 @@ public class ExpandableNotificationRowController implements NodeController {
     private final boolean mAllowLongPress;
     private final PeopleNotificationIdentifier mPeopleNotificationIdentifier;
     private final Optional<BubblesManager> mBubblesManagerOptional;
+    private final IStatusBarService mStatusBarService;
 
     private final ExpandableNotificationRowDragController mDragController;
 
@@ -113,7 +115,8 @@ public class ExpandableNotificationRowController implements NodeController {
             FalsingCollector falsingCollector,
             PeopleNotificationIdentifier peopleNotificationIdentifier,
             Optional<BubblesManager> bubblesManagerOptional,
-            ExpandableNotificationRowDragController dragController) {
+            ExpandableNotificationRowDragController dragController,
+            IStatusBarService statusBarService) {
         mView = view;
         mListContainer = listContainer;
         mActivatableNotificationViewController = activatableNotificationViewController;
@@ -139,6 +142,7 @@ public class ExpandableNotificationRowController implements NodeController {
         mPeopleNotificationIdentifier = peopleNotificationIdentifier;
         mBubblesManagerOptional = bubblesManagerOptional;
         mDragController = dragController;
+        mStatusBarService = statusBarService;
     }
 
     /**
@@ -165,7 +169,8 @@ public class ExpandableNotificationRowController implements NodeController {
                 mPeopleNotificationIdentifier,
                 mOnUserInteractionCallback,
                 mBubblesManagerOptional,
-                mNotificationGutsManager
+                mNotificationGutsManager,
+                mStatusBarService
         );
         mView.setDescendantFocusability(ViewGroup.FOCUS_BLOCK_DESCENDANTS);
         if (mAllowLongPress) {
",7,2,"ExpandableNotificationRowController::init, ExpandableNotificationRowController::ExpandableNotificationRowController, ExpandableNotificationRowController::ExpandableNotificationRowController"
281,9d3642cadf39793a856274d7f4edeb98151366a6,NotificationContentView.java,"@@ -21,10 +21,13 @@ import android.annotation.Nullable;
 import android.app.Notification;
 import android.app.PendingIntent;
 import android.content.Context;
+import android.graphics.Canvas;
 import android.graphics.Rect;
 import android.graphics.drawable.Drawable;
 import android.os.Build;
+import android.os.RemoteException;
 import android.provider.Settings;
+import android.service.notification.StatusBarNotification;
 import android.util.ArrayMap;
 import android.util.AttributeSet;
 import android.util.IndentingPrintWriter;
@@ -41,6 +44,7 @@ import android.widget.LinearLayout;
 
 import com.android.internal.annotations.VisibleForTesting;
 import com.android.systemui.Dependency;
+import com.android.internal.statusbar.IStatusBarService;
 import com.android.systemui.R;
 import com.android.systemui.plugins.statusbar.NotificationMenuRowPlugin;
 import com.android.systemui.statusbar.RemoteInputController;
@@ -127,6 +131,8 @@ public class NotificationContentView extends FrameLayout implements Notification
     private RemoteInputController mRemoteInputController;
     private Runnable mExpandedVisibleListener;
     private PeopleNotificationIdentifier mPeopleIdentifier;
+    private IStatusBarService mStatusBarService;
+
     /**
      * List of listeners for when content views become inactive (i.e. not the showing view).
      */
@@ -180,6 +186,7 @@ public class NotificationContentView extends FrameLayout implements Notification
         mHybridGroupManager = new HybridGroupManager(getContext());
         mSmartReplyConstants = Dependency.get(SmartReplyConstants.class);
         mSmartReplyController = Dependency.get(SmartReplyController.class);
+        mStatusBarService = Dependency.get(IStatusBarService.class);
         initView();
     }
 
@@ -2030,4 +2037,36 @@ public class NotificationContentView extends FrameLayout implements Notification
         }
         return false;
     }
+
+    @Override
+    protected void dispatchDraw(Canvas canvas) {
+        try {
+            super.dispatchDraw(canvas);
+        } catch (Exception e) {
+            // Catch draw exceptions that may be caused by RemoteViews
+            Log.e(TAG, ""Drawing view failed: "" + e);
+            cancelNotification(e);
+        }
+    }
+
+    private void cancelNotification(Exception exception) {
+        try {
+            setVisibility(GONE);
+            final StatusBarNotification sbn = mNotificationEntry.getSbn();
+            if (mStatusBarService != null) {
+                // report notification inflation errors back up
+                // to notification delegates
+                mStatusBarService.onNotificationError(
+                        sbn.getPackageName(),
+                        sbn.getTag(),
+                        sbn.getId(),
+                        sbn.getUid(),
+                        sbn.getInitialPid(),
+                        exception.getMessage(),
+                        sbn.getUser().getIdentifier());
+            }
+        } catch (RemoteException ex) {
+            Log.e(TAG, ""cancelNotification failed: "" + ex);
+        }
+    }
 }
",39,0,"NotificationContentView::cancelNotification, NotificationContentView::dispatchDraw, NotificationContentView::NotificationContentView"
282,9d3642cadf39793a856274d7f4edeb98151366a6,NotificationEntryManagerInflationTest.java,"@@ -271,7 +271,8 @@ public class NotificationEntryManagerInflationTest extends SysuiTestCase {
                                 new FalsingCollectorFake(),
                                 mPeopleNotificationIdentifier,
                                 Optional.of(mock(BubblesManager.class)),
-                                mock(ExpandableNotificationRowDragController.class)
+                                mock(ExpandableNotificationRowDragController.class),
+                                mock(IStatusBarService.class)
                         ));
 
         when(mNotificationRowComponentBuilder.activatableNotificationView(any()))
",2,1,NotificationEntryManagerInflationTest::setUp
283,9d3642cadf39793a856274d7f4edeb98151366a6,NotificationTestHelper.java,"@@ -43,6 +43,7 @@ import android.text.TextUtils;
 import android.view.LayoutInflater;
 import android.widget.RemoteViews;
 
+import com.android.internal.statusbar.IStatusBarService;
 import com.android.systemui.TestableDependency;
 import com.android.systemui.classifier.FalsingCollectorFake;
 import com.android.systemui.classifier.FalsingManagerFake;
@@ -490,7 +491,8 @@ public class NotificationTestHelper {
                 mPeopleNotificationIdentifier,
                 mock(OnUserInteractionCallback.class),
                 Optional.of(mock(BubblesManager.class)),
-                mock(NotificationGutsManager.class));
+                mock(NotificationGutsManager.class),
+                mock(IStatusBarService.class));
 
         row.setAboveShelfChangedListener(aboveShelf -> { });
         mBindStage.getStageParams(entry).requireContentViews(extraInflationFlags);
",3,1,NotificationTestHelper::generateRow
284,f76b124b6ede9ead86eb033d5053850d833f75bb,AccountManagerService.java,"@@ -4881,10 +4881,6 @@ public class AccountManagerService
             if (intent.getClipData() == null) {
                 intent.setClipData(ClipData.newPlainText(null, null));
             }
-            intent.setFlags(intent.getFlags() & ~(Intent.FLAG_GRANT_READ_URI_PERMISSION
-                    | Intent.FLAG_GRANT_WRITE_URI_PERMISSION
-                    | Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION
-                    | Intent.FLAG_GRANT_PREFIX_URI_PERMISSION));
             final long bid = Binder.clearCallingIdentity();
             try {
                 PackageManager pm = mContext.getPackageManager();
@@ -4931,7 +4927,19 @@ public class AccountManagerService
             if (intent == null) {
                 return (simulateIntent == null);
             }
-            return intent.filterEquals(simulateIntent);
+            if (!intent.filterEquals(simulateIntent)) {
+                return false;
+            }
+
+            if (intent.getSelector() != simulateIntent.getSelector()) {
+                return false;
+            }
+
+            int prohibitedFlags = Intent.FLAG_GRANT_READ_URI_PERMISSION
+                    | Intent.FLAG_GRANT_WRITE_URI_PERMISSION
+                    | Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION
+                    | Intent.FLAG_GRANT_PREFIX_URI_PERMISSION;
+            return (simulateIntent.getFlags() & prohibitedFlags) == 0;
         }
 
         private boolean isExportedSystemActivity(ActivityInfo activityInfo) {
",13,5,"AccountManagerService::Session::checkKeyIntent, AccountManagerService::Session::checkKeyIntentParceledCorrectly"
285,f76b124b6ede9ead86eb033d5053850d833f75bb,AccountManagerServiceTest.java,"@@ -18,6 +18,7 @@ package com.android.server.accounts;
 
 import static android.database.sqlite.SQLiteDatabase.deleteDatabase;
 
+import static org.mockito.ArgumentMatchers.contains;
 import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.anyBoolean;
 import static org.mockito.Matchers.anyInt;
@@ -705,6 +706,41 @@ public class AccountManagerServiceTest extends AndroidTestCase {
         assertNotNull(intent.getParcelableExtra(AccountManagerServiceTestFixtures.KEY_CALLBACK));
     }
 
+    @SmallTest
+    public void testStartAddAccountSessionWhereAuthenticatorReturnsIntentWithProhibitedFlags()
+            throws Exception {
+        unlockSystemUser();
+        ResolveInfo resolveInfo = new ResolveInfo();
+        resolveInfo.activityInfo = new ActivityInfo();
+        resolveInfo.activityInfo.applicationInfo = new ApplicationInfo();
+        when(mMockPackageManager.resolveActivityAsUser(
+                any(Intent.class), anyInt(), anyInt())).thenReturn(resolveInfo);
+        when(mMockPackageManager.checkSignatures(
+                anyInt(), anyInt())).thenReturn(PackageManager.SIGNATURE_MATCH);
+
+        final CountDownLatch latch = new CountDownLatch(1);
+        Response response = new Response(latch, mMockAccountManagerResponse);
+        Bundle options = createOptionsWithAccountName(
+                AccountManagerServiceTestFixtures.ACCOUNT_NAME_INTERVENE);
+        int prohibitedFlags = Intent.FLAG_GRANT_READ_URI_PERMISSION
+                | Intent.FLAG_GRANT_WRITE_URI_PERMISSION
+                | Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION
+                | Intent.FLAG_GRANT_PREFIX_URI_PERMISSION;
+        options.putInt(AccountManagerServiceTestFixtures.KEY_INTENT_FLAGS, prohibitedFlags);
+
+        mAms.startAddAccountSession(
+                response, // response
+                AccountManagerServiceTestFixtures.ACCOUNT_TYPE_1, // accountType
+                ""authTokenType"",
+                null, // requiredFeatures
+                true, // expectActivityLaunch
+                options); // optionsIn
+        waitForLatch(latch);
+
+        verify(mMockAccountManagerResponse).onError(
+                eq(AccountManager.ERROR_CODE_INVALID_RESPONSE), contains(""invalid intent""));
+    }
+
     @SmallTest
     public void testStartAddAccountSessionError() throws Exception {
         unlockSystemUser();
",36,0,AccountManagerServiceTest::testStartAddAccountSessionWhereAuthenticatorReturnsIntentWithProhibitedFlags
286,f76b124b6ede9ead86eb033d5053850d833f75bb,AccountManagerServiceTestFixtures.java,"@@ -17,9 +17,6 @@ package com.android.server.accounts;
 
 import android.accounts.Account;
 
-import java.util.ArrayList;
-import java.util.List;
-
 /**
  * Constants shared between test AccountAuthenticators and AccountManagerServiceTest.
  */
@@ -31,6 +28,8 @@ public final class AccountManagerServiceTestFixtures {
             ""account_manager_service_test:account_status_token_key"";
     public static final String KEY_ACCOUNT_PASSWORD =
             ""account_manager_service_test:account_password_key"";
+    public static final String KEY_INTENT_FLAGS =
+            ""account_manager_service_test:intent_flags_key"";
     public static final String KEY_OPTIONS_BUNDLE =
             ""account_manager_service_test:option_bundle_key"";
     public static final String ACCOUNT_NAME_SUCCESS = ""success_on_return@fixture.com"";
",2,3,
287,f76b124b6ede9ead86eb033d5053850d833f75bb,TestAccountType1Authenticator.java,"@@ -24,8 +24,6 @@ import android.content.Context;
 import android.content.Intent;
 import android.os.Bundle;
 
-import com.android.frameworks.servicestests.R;
-
 import java.util.concurrent.atomic.AtomicInteger;
 
 /**
@@ -270,11 +268,13 @@ public class TestAccountType1Authenticator extends AbstractAccountAuthenticator
         String accountName = null;
         Bundle sessionBundle = null;
         String password = null;
+        int intentFlags = 0;
         if (options != null) {
             accountName = options.getString(AccountManagerServiceTestFixtures.KEY_ACCOUNT_NAME);
             sessionBundle = options.getBundle(
                     AccountManagerServiceTestFixtures.KEY_ACCOUNT_SESSION_BUNDLE);
             password = options.getString(AccountManagerServiceTestFixtures.KEY_ACCOUNT_PASSWORD);
+            intentFlags = options.getInt(AccountManagerServiceTestFixtures.KEY_INTENT_FLAGS, 0);
         }
 
         Bundle result = new Bundle();
@@ -302,6 +302,7 @@ public class TestAccountType1Authenticator extends AbstractAccountAuthenticator
             intent.putExtra(AccountManagerServiceTestFixtures.KEY_RESULT,
                     eventualActivityResultData);
             intent.putExtra(AccountManagerServiceTestFixtures.KEY_CALLBACK, response);
+            intent.setFlags(intentFlags);
 
             result.putParcelable(AccountManager.KEY_INTENT, intent);
         } else {
",3,2,TestAccountType1Authenticator::startAddAccountSession
288,b8457600c1b0e1ed4f621bc13fce5088c6ab18c9,JobStore.java,"@@ -733,6 +733,10 @@ public final class JobStore {
                 }
             } catch (XmlPullParserException | IOException e) {
                 Slog.wtf(TAG, ""Error jobstore xml."", e);
+            } catch (Exception e) {
+                // Crashing at this point would result in a boot loop, so live with a general
+                // Exception for system stability's sake.
+                Slog.wtf(TAG, ""Unexpected exception"", e);
             } finally {
                 if (mPersistInfo.countAllJobsLoaded < 0) { // Only set them once.
                     mPersistInfo.countAllJobsLoaded = numJobs;
@@ -869,6 +873,9 @@ public final class JobStore {
             } catch (IOException e) {
                 Slog.d(TAG, ""Error I/O Exception."", e);
                 return null;
+            } catch (IllegalArgumentException e) {
+                Slog.e(TAG, ""Constraints contained invalid data"", e);
+                return null;
             }
 
             parser.next(); // Consume </constraints>
@@ -965,8 +972,14 @@ public final class JobStore {
                 return null;
             }
 
-            PersistableBundle extras = PersistableBundle.restoreFromXml(parser);
-            jobBuilder.setExtras(extras);
+            final PersistableBundle extras;
+            try {
+                extras = PersistableBundle.restoreFromXml(parser);
+                jobBuilder.setExtras(extras);
+            } catch (IllegalArgumentException e) {
+                Slog.e(TAG, ""Persisted extras contained invalid data"", e);
+                return null;
+            }
             parser.nextTag(); // Consume </extras>
 
             final JobInfo builtJob;
",15,2,"JobStore::ReadJobMapFromDiskRunnable::restoreJobFromXml, JobStore::ReadJobMapFromDiskRunnable::run"
289,2510c72e34c660e42599f9866ca846395ba1aebf,ServiceListing.java,"@@ -35,6 +35,7 @@ import android.util.Slog;
 import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.List;
+import java.util.function.Predicate;
 
 /**
  * Class for managing services matching a given intent and requesting a given permission.
@@ -51,12 +52,13 @@ public class ServiceListing {
     private final HashSet<ComponentName> mEnabledServices = new HashSet<>();
     private final List<ServiceInfo> mServices = new ArrayList<>();
     private final List<Callback> mCallbacks = new ArrayList<>();
+    private final Predicate mValidator;
 
     private boolean mListening;
 
     private ServiceListing(Context context, String tag,
             String setting, String intentAction, String permission, String noun,
-            boolean addDeviceLockedFlags) {
+            boolean addDeviceLockedFlags, Predicate validator) {
         mContentResolver = context.getContentResolver();
         mContext = context;
         mTag = tag;
@@ -65,6 +67,7 @@ public class ServiceListing {
         mPermission = permission;
         mNoun = noun;
         mAddDeviceLockedFlags = addDeviceLockedFlags;
+        mValidator = validator;
     }
 
     public void addCallback(Callback callback) {
@@ -137,7 +140,6 @@ public class ServiceListing {
         final PackageManager pmWrapper = mContext.getPackageManager();
         List<ResolveInfo> installedServices = pmWrapper.queryIntentServicesAsUser(
                 new Intent(mIntentAction), flags, user);
-
         for (ResolveInfo resolveInfo : installedServices) {
             ServiceInfo info = resolveInfo.serviceInfo;
 
@@ -148,6 +150,9 @@ public class ServiceListing {
                         + mPermission);
                 continue;
             }
+            if (mValidator != null && !mValidator.test(info)) {
+                continue;
+            }
             mServices.add(info);
         }
         for (Callback callback : mCallbacks) {
@@ -194,6 +199,7 @@ public class ServiceListing {
         private String mPermission;
         private String mNoun;
         private boolean mAddDeviceLockedFlags = false;
+        private Predicate mValidator;
 
         public Builder(Context context) {
             mContext = context;
@@ -224,6 +230,11 @@ public class ServiceListing {
             return this;
         }
 
+        public Builder setValidator(Predicate<ServiceInfo> validator) {
+            mValidator = validator;
+            return this;
+        }
+
         /**
          * Set to true to add support for both MATCH_DIRECT_BOOT_AWARE and
          * MATCH_DIRECT_BOOT_UNAWARE flags when querying PackageManager. Required to get results
@@ -236,7 +247,7 @@ public class ServiceListing {
 
         public ServiceListing build() {
             return new ServiceListing(mContext, mTag, mSetting, mIntentAction, mPermission, mNoun,
-                    mAddDeviceLockedFlags);
+                    mAddDeviceLockedFlags, mValidator);
         }
     }
 }
",14,3,"ServiceListing::Builder::build, ServiceListing::Builder::setValidator, ServiceListing::ServiceListing, ServiceListing::ServiceListing, ServiceListing::reload"
290,2510c72e34c660e42599f9866ca846395ba1aebf,ServiceListingTest.java,"@@ -18,20 +18,35 @@ package com.android.settingslib.applications;
 
 import static com.google.common.truth.Truth.assertThat;
 
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyInt;
 import static org.mockito.ArgumentMatchers.anyList;
 import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.spy;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
 
 import android.content.ComponentName;
+import android.content.Context;
+import android.content.pm.PackageManager;
+import android.content.pm.ResolveInfo;
+import android.content.pm.ServiceInfo;
 import android.provider.Settings;
 
+import androidx.test.core.app.ApplicationProvider;
+
+import com.google.common.collect.ImmutableList;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.RuntimeEnvironment;
 
+import java.util.List;
+
 @RunWith(RobolectricTestRunner.class)
 public class ServiceListingTest {
 
@@ -39,16 +54,97 @@ public class ServiceListingTest {
     private static final String TEST_INTENT = ""com.example.intent"";
 
     private ServiceListing mServiceListing;
+    private Context mContext;
+    private PackageManager mPm;
 
     @Before
     public void setUp() {
-        mServiceListing = new ServiceListing.Builder(RuntimeEnvironment.application)
+        mPm = mock(PackageManager.class);
+        mContext = spy(ApplicationProvider.getApplicationContext());
+        when(mContext.getPackageManager()).thenReturn(mPm);
+
+        mServiceListing = new ServiceListing.Builder(mContext)
+                .setTag(""testTag"")
+                .setSetting(TEST_SETTING)
+                .setNoun(""testNoun"")
+                .setIntentAction(TEST_INTENT)
+                .setPermission(""testPermission"")
+                .build();
+    }
+
+    @Test
+    public void testValidator() {
+        ServiceInfo s1 = new ServiceInfo();
+        s1.permission = ""testPermission"";
+        s1.packageName = ""pkg"";
+        ServiceInfo s2 = new ServiceInfo();
+        s2.permission = ""testPermission"";
+        s2.packageName = ""pkg2"";
+        ResolveInfo r1 = new ResolveInfo();
+        r1.serviceInfo = s1;
+        ResolveInfo r2 = new ResolveInfo();
+        r2.serviceInfo = s2;
+
+        when(mPm.queryIntentServicesAsUser(any(), anyInt(), anyInt())).thenReturn(
+                ImmutableList.of(r1, r2));
+
+        mServiceListing = new ServiceListing.Builder(mContext)
+                .setTag(""testTag"")
+                .setSetting(TEST_SETTING)
+                .setNoun(""testNoun"")
+                .setIntentAction(TEST_INTENT)
+                .setValidator(info -> {
+                    if (info.packageName.equals(""pkg"")) {
+                        return true;
+                    }
+                    return false;
+                })
+                .setPermission(""testPermission"")
+                .build();
+        ServiceListing.Callback callback = mock(ServiceListing.Callback.class);
+        mServiceListing.addCallback(callback);
+        mServiceListing.reload();
+
+        verify(mPm).queryIntentServicesAsUser(any(), anyInt(), anyInt());
+        ArgumentCaptor<List<ServiceInfo>> captor = ArgumentCaptor.forClass(List.class);
+        verify(callback, times(1)).onServicesReloaded(captor.capture());
+
+        assertThat(captor.getValue().size()).isEqualTo(1);
+        assertThat(captor.getValue().get(0)).isEqualTo(s1);
+    }
+
+    @Test
+    public void testNoValidator() {
+        ServiceInfo s1 = new ServiceInfo();
+        s1.permission = ""testPermission"";
+        s1.packageName = ""pkg"";
+        ServiceInfo s2 = new ServiceInfo();
+        s2.permission = ""testPermission"";
+        s2.packageName = ""pkg2"";
+        ResolveInfo r1 = new ResolveInfo();
+        r1.serviceInfo = s1;
+        ResolveInfo r2 = new ResolveInfo();
+        r2.serviceInfo = s2;
+
+        when(mPm.queryIntentServicesAsUser(any(), anyInt(), anyInt())).thenReturn(
+                ImmutableList.of(r1, r2));
+
+        mServiceListing = new ServiceListing.Builder(mContext)
                 .setTag(""testTag"")
                 .setSetting(TEST_SETTING)
                 .setNoun(""testNoun"")
                 .setIntentAction(TEST_INTENT)
                 .setPermission(""testPermission"")
                 .build();
+        ServiceListing.Callback callback = mock(ServiceListing.Callback.class);
+        mServiceListing.addCallback(callback);
+        mServiceListing.reload();
+
+        verify(mPm).queryIntentServicesAsUser(any(), anyInt(), anyInt());
+        ArgumentCaptor<List<ServiceInfo>> captor = ArgumentCaptor.forClass(List.class);
+        verify(callback, times(1)).onServicesReloaded(captor.capture());
+
+        assertThat(captor.getValue().size()).isEqualTo(2);
     }
 
     @Test
",97,1,"ServiceListingTest::testNoValidator, ServiceListingTest::testValidator, ServiceListingTest::setUp"
291,645206dd8566eb1b4ca286b4c0ede04b4e057fd4,AppStandbyInternal.java,"@@ -157,6 +157,8 @@ public interface AppStandbyInternal {
 
     void setActiveAdminApps(Set<String> adminPkgs, int userId);
 
+    void setAdminProtectedPackages(Set<String> packageNames, int userId);
+
     void onAdminDataAvailable();
 
     void clearCarrierPrivilegedApps();
",2,0,
292,645206dd8566eb1b4ca286b4c0ede04b4e057fd4,AppStandbyController.java,"@@ -247,6 +247,10 @@ public class AppStandbyController
     @GuardedBy(""mActiveAdminApps"")
     private final SparseArray<Set<String>> mActiveAdminApps = new SparseArray<>();
 
+    /** List of admin protected packages. Can contain {@link android.os.UserHandle#USER_ALL}. */
+    @GuardedBy(""mAdminProtectedPackages"")
+    private final SparseArray<Set<String>> mAdminProtectedPackages = new SparseArray<>();
+
     /**
      * Set of system apps that are headless (don't have any declared activities, enabled or
      * disabled). Presence in this map indicates that the app is a headless system app.
@@ -1088,6 +1092,9 @@ public class AppStandbyController
             synchronized (mActiveAdminApps) {
                 mActiveAdminApps.remove(userId);
             }
+            synchronized (mAdminProtectedPackages) {
+                mAdminProtectedPackages.remove(userId);
+            }
         }
     }
 
@@ -1177,6 +1184,10 @@ public class AppStandbyController
                 return STANDBY_BUCKET_EXEMPTED;
             }
 
+            if (isAdminProtectedPackages(packageName, userId)) {
+                return STANDBY_BUCKET_EXEMPTED;
+            }
+
             if (isActiveNetworkScorer(packageName)) {
                 return STANDBY_BUCKET_EXEMPTED;
             }
@@ -1583,6 +1594,17 @@ public class AppStandbyController
         }
     }
 
+    private boolean isAdminProtectedPackages(String packageName, int userId) {
+        synchronized (mAdminProtectedPackages) {
+            if (mAdminProtectedPackages.contains(UserHandle.USER_ALL)
+                    && mAdminProtectedPackages.get(UserHandle.USER_ALL).contains(packageName)) {
+                return true;
+            }
+            return mAdminProtectedPackages.contains(userId)
+                    && mAdminProtectedPackages.get(userId).contains(packageName);
+        }
+    }
+
     @Override
     public void addActiveDeviceAdmin(String adminPkg, int userId) {
         synchronized (mActiveAdminApps) {
@@ -1606,6 +1628,17 @@ public class AppStandbyController
         }
     }
 
+    @Override
+    public void setAdminProtectedPackages(Set<String> packageNames, int userId) {
+        synchronized (mAdminProtectedPackages) {
+            if (packageNames == null || packageNames.isEmpty()) {
+                mAdminProtectedPackages.remove(userId);
+            } else {
+                mAdminProtectedPackages.put(userId, packageNames);
+            }
+        }
+    }
+
     @Override
     public void onAdminDataAvailable() {
         mAdminDataAvailableLatch.countDown();
@@ -1628,6 +1661,13 @@ public class AppStandbyController
         }
     }
 
+    @VisibleForTesting
+    Set<String> getAdminProtectedPackagesForTest(int userId) {
+        synchronized (mAdminProtectedPackages) {
+            return mAdminProtectedPackages.get(userId);
+        }
+    }
+
     /**
      * Returns {@code true} if the supplied package is the device provisioning app. Otherwise,
      * returns {@code false}.
",40,0,"AppStandbyController::setAdminProtectedPackages, AppStandbyController::onUserRemoved, AppStandbyController::isAdminProtectedPackages, AppStandbyController::getAdminProtectedPackagesForTest, AppStandbyController::getAppMinBucket"
293,645206dd8566eb1b4ca286b4c0ede04b4e057fd4,DevicePolicyManager.java,"@@ -13573,7 +13573,8 @@ public class DevicePolicyManager {
 
     /**
      * Called by Device owner to disable user control over apps. User will not be able to clear
-     * app data or force-stop packages.
+     * app data or force-stop packages. Packages with user control disabled are exempted from
+     * App Standby Buckets.
      *
      * @param admin which {@link DeviceAdminReceiver} this request is associated with
      * @param packages The package names for the apps.
",2,1,
294,645206dd8566eb1b4ca286b4c0ede04b4e057fd4,UsageStatsManagerInternal.java,"@@ -198,6 +198,16 @@ public abstract class UsageStatsManagerInternal {
      */
     public abstract void setActiveAdminApps(Set<String> adminApps, int userId);
 
+    /**
+     * Called by DevicePolicyManagerService to inform about the protected packages for a user.
+     * User control will be disabled for protected packages.
+     *
+     * @param packageNames the set of protected packages for {@code userId}.
+     * @param userId the userId to which the protected packages belong.
+     */
+    public abstract void setAdminProtectedPackages(@Nullable Set<String> packageNames,
+            @UserIdInt int userId);
+
     /**
      * Called by DevicePolicyManagerService during boot to inform that admin data is loaded and
      * pushed to UsageStatsService.
",10,0,
295,645206dd8566eb1b4ca286b4c0ede04b4e057fd4,DevicePolicyManagerService.java,"@@ -1341,7 +1341,7 @@ public class DevicePolicyManagerService extends BaseIDevicePolicyManager {
         Owners newOwners() {
             return new Owners(getUserManager(), getUserManagerInternal(),
                     getPackageManagerInternal(), getActivityTaskManagerInternal(),
-                    getActivityManagerInternal());
+                    getActivityManagerInternal(), getUsageStatsManagerInternal());
         }
 
         UserManager getUserManager() {
",1,1,DevicePolicyManagerService::Injector::newOwners
296,645206dd8566eb1b4ca286b4c0ede04b4e057fd4,Owners.java,"@@ -24,6 +24,7 @@ import android.app.AppOpsManagerInternal;
 import android.app.admin.DevicePolicyManager.DeviceOwnerType;
 import android.app.admin.SystemUpdateInfo;
 import android.app.admin.SystemUpdatePolicy;
+import android.app.usage.UsageStatsManagerInternal;
 import android.content.ComponentName;
 import android.content.pm.PackageManager;
 import android.content.pm.PackageManagerInternal;
@@ -123,6 +124,7 @@ class Owners {
     private final PackageManagerInternal mPackageManagerInternal;
     private final ActivityTaskManagerInternal mActivityTaskManagerInternal;
     private final ActivityManagerInternal mActivityManagerInternal;
+    private final UsageStatsManagerInternal mUsageStatsManagerInternal;
 
     private boolean mSystemReady;
 
@@ -155,9 +157,11 @@ class Owners {
             UserManagerInternal userManagerInternal,
             PackageManagerInternal packageManagerInternal,
             ActivityTaskManagerInternal activityTaskManagerInternal,
-            ActivityManagerInternal activitykManagerInternal) {
+            ActivityManagerInternal activitykManagerInternal,
+            UsageStatsManagerInternal usageStatsManagerInternal) {
         this(userManager, userManagerInternal, packageManagerInternal,
-                activityTaskManagerInternal, activitykManagerInternal, new Injector());
+                activityTaskManagerInternal, activitykManagerInternal,
+                usageStatsManagerInternal, new Injector());
     }
 
     @VisibleForTesting
@@ -166,12 +170,14 @@ class Owners {
             PackageManagerInternal packageManagerInternal,
             ActivityTaskManagerInternal activityTaskManagerInternal,
             ActivityManagerInternal activityManagerInternal,
+            UsageStatsManagerInternal usageStatsManagerInternal,
             Injector injector) {
         mUserManager = userManager;
         mUserManagerInternal = userManagerInternal;
         mPackageManagerInternal = packageManagerInternal;
         mActivityTaskManagerInternal = activityTaskManagerInternal;
         mActivityManagerInternal = activityManagerInternal;
+        mUsageStatsManagerInternal = usageStatsManagerInternal;
         mInjector = injector;
     }
 
@@ -226,6 +232,8 @@ class Owners {
                     mDeviceOwnerProtectedPackages.entrySet()) {
                 mPackageManagerInternal.setDeviceOwnerProtectedPackages(
                         entry.getKey(), entry.getValue());
+                mUsageStatsManagerInternal.setAdminProtectedPackages(
+                        new ArraySet(entry.getValue()), UserHandle.USER_ALL);
             }
         }
     }
@@ -359,6 +367,8 @@ class Owners {
             if (protectedPackages != null) {
                 mPackageManagerInternal.setDeviceOwnerProtectedPackages(
                         mDeviceOwner.packageName, new ArrayList<>());
+                mUsageStatsManagerInternal.setAdminProtectedPackages(
+                        Collections.emptySet(), UserHandle.USER_ALL);
             }
             mDeviceOwner = null;
             mDeviceOwnerUserId = UserHandle.USER_NULL;
@@ -416,6 +426,8 @@ class Owners {
             if (previousProtectedPackages != null) {
                 mPackageManagerInternal.setDeviceOwnerProtectedPackages(
                         mDeviceOwner.packageName, new ArrayList<>());
+                mUsageStatsManagerInternal.setAdminProtectedPackages(
+                        Collections.emptySet(), UserHandle.USER_ALL);
             }
             // We don't set a name because it's not used anyway.
             // See DevicePolicyManagerService#getDeviceOwnerName
@@ -684,6 +696,8 @@ class Owners {
 
             mDeviceOwnerProtectedPackages.put(packageName, protectedPackages);
             mPackageManagerInternal.setDeviceOwnerProtectedPackages(packageName, protectedPackages);
+            mUsageStatsManagerInternal.setAdminProtectedPackages(
+                        new ArraySet(protectedPackages), UserHandle.USER_ALL);
             writeDeviceOwner();
         }
     }
",16,2,"Owners::Owners, Owners::setDeviceOwnerProtectedPackages, Owners::transferDeviceOwnership, Owners::Owners, Owners::Owners, Owners::clearDeviceOwner, Owners::load"
297,645206dd8566eb1b4ca286b4c0ede04b4e057fd4,DevicePolicyManagerServiceTestable.java,"@@ -69,7 +69,8 @@ public class DevicePolicyManagerServiceTestable extends DevicePolicyManagerServi
         public OwnersTestable(MockSystemServices services) {
             super(services.userManager, services.userManagerInternal,
                     services.packageManagerInternal, services.activityTaskManagerInternal,
-                    services.activityManagerInternal, new MockInjector(services));
+                    services.activityManagerInternal, services.usageStatsManagerInternal,
+                    new MockInjector(services));
         }
 
         static class MockInjector extends Injector {
",2,1,DevicePolicyManagerServiceTestable::OwnersTestable::OwnersTestable
298,645206dd8566eb1b4ca286b4c0ede04b4e057fd4,AppStandbyControllerTests.java,"@@ -152,6 +152,9 @@ public class AppStandbyControllerTests {
     private static final String ADMIN_PKG2 = ""com.android.admin2"";
     private static final String ADMIN_PKG3 = ""com.android.admin3"";
 
+    private static final String ADMIN_PROTECTED_PKG = ""com.android.admin.protected"";
+    private static final String ADMIN_PROTECTED_PKG2 = ""com.android.admin.protected2"";
+
     private static final long MINUTE_MS = 60 * 1000;
     private static final long HOUR_MS = 60 * MINUTE_MS;
     private static final long DAY_MS = 24 * HOUR_MS;
@@ -1631,6 +1634,19 @@ public class AppStandbyControllerTests {
         assertIsNotActiveAdmin(ADMIN_PKG2, USER_ID);
     }
 
+    @Test
+    public void testSetAdminProtectedPackages() {
+        assertAdminProtectedPackagesForTest(USER_ID, (String[]) null);
+        assertAdminProtectedPackagesForTest(USER_ID2, (String[]) null);
+
+        setAdminProtectedPackages(USER_ID, ADMIN_PROTECTED_PKG, ADMIN_PROTECTED_PKG2);
+        assertAdminProtectedPackagesForTest(USER_ID, ADMIN_PROTECTED_PKG, ADMIN_PROTECTED_PKG2);
+        assertAdminProtectedPackagesForTest(USER_ID2, (String[]) null);
+
+        setAdminProtectedPackages(USER_ID, (String[]) null);
+        assertAdminProtectedPackagesForTest(USER_ID, (String[]) null);
+    }
+
     @Test
     @FlakyTest(bugId = 185169504)
     public void testUserInteraction_CrossProfile() throws Exception {
@@ -2025,6 +2041,28 @@ public class AppStandbyControllerTests {
         mController.setActiveAdminApps(new ArraySet<>(Arrays.asList(admins)), userId);
     }
 
+    private void setAdminProtectedPackages(int userId, String... packageNames) {
+        Set<String> adminProtectedPackages = packageNames != null ? new ArraySet<>(
+                Arrays.asList(packageNames)) : null;
+        mController.setAdminProtectedPackages(adminProtectedPackages, userId);
+    }
+
+    private void assertAdminProtectedPackagesForTest(int userId, String... packageNames) {
+        final Set<String> actualAdminProtectedPackages =
+                mController.getAdminProtectedPackagesForTest(userId);
+        if (packageNames == null) {
+            if (actualAdminProtectedPackages != null && !actualAdminProtectedPackages.isEmpty()) {
+                fail(""Admin protected packages should be null; "" + getAdminAppsStr(userId,
+                        actualAdminProtectedPackages));
+            }
+            return;
+        }
+        assertEquals(packageNames.length, actualAdminProtectedPackages.size());
+        for (String adminProtectedPackage : packageNames) {
+            assertTrue(actualAdminProtectedPackages.contains(adminProtectedPackage));
+        }
+    }
+
     private void setAndAssertBucket(String pkg, int user, int bucket, int reason) throws Exception {
         rearmLatch(pkg);
         mController.setAppStandbyBucket(pkg, user, bucket, reason);
",38,0,"AppStandbyControllerTests::testSetAdminProtectedPackages, AppStandbyControllerTests::setAdminProtectedPackages, AppStandbyControllerTests::assertAdminProtectedPackagesForTest"
299,645206dd8566eb1b4ca286b4c0ede04b4e057fd4,UsageStatsService.java,"@@ -2494,6 +2494,11 @@ public class UsageStatsService extends SystemService implements
             mAppStandby.setActiveAdminApps(packageNames, userId);
         }
 
+        @Override
+        public void setAdminProtectedPackages(Set<String> packageNames, int userId) {
+            mAppStandby.setAdminProtectedPackages(packageNames, userId);
+        }
+
         @Override
         public void onAdminDataAvailable() {
             mAppStandby.onAdminDataAvailable();
",5,0,UsageStatsService::LocalService::setAdminProtectedPackages
300,59729e1be98eec30bcfe9600c48248729fc0203b,NotificationInterruptStateProviderImpl.java,"@@ -18,6 +18,7 @@ package com.android.systemui.statusbar.notification.interruption;
 
 import static com.android.systemui.statusbar.StatusBarState.SHADE;
 
+import android.app.Notification;
 import android.app.NotificationManager;
 import android.content.ContentResolver;
 import android.database.ContentObserver;
@@ -210,6 +211,20 @@ public class NotificationInterruptStateProviderImpl implements NotificationInter
             return false;
         }
 
+        // If the notification has suppressive BubbleMetadata, block FSI and warn.
+        Notification.BubbleMetadata bubbleMetadata = sbn.getNotification().getBubbleMetadata();
+        if (bubbleMetadata != null && bubbleMetadata.isNotificationSuppressed()) {
+            // b/274759612: Detect and report an event when a notification has both an FSI and a
+            // suppressive BubbleMetadata, and now correctly block the FSI from firing.
+            final int uid = entry.getSbn().getUid();
+            android.util.EventLog.writeEvent(0x534e4554, ""274759612"", uid, ""bubbleMetadata"");
+            if (DEBUG) {
+                Log.w(TAG, ""No FullScreenIntent: WARNING: BubbleMetadata may prevent HUN: ""
+                        + entry.getKey());
+            }
+            return false;
+        }
+
         // If the screen is off, then launch the FullScreenIntent
         if (!mPowerManager.isInteractive()) {
             if (DEBUG) {
",15,0,NotificationInterruptStateProviderImpl::shouldLaunchFullScreenIntentWhenAdded
301,59729e1be98eec30bcfe9600c48248729fc0203b,NotificationInterruptStateProviderImplTest.java,"@@ -435,9 +435,27 @@ public class NotificationInterruptStateProviderImplTest extends SysuiTestCase {
                 .isFalse();
     }
 
+
+    @Test
+    public void testShouldNotFullScreen_isSuppressedByBubbleMetadata() throws RemoteException {
+        NotificationEntry entry = createFsiNotification(IMPORTANCE_HIGH, /* silenced */ false);
+        Notification.BubbleMetadata bubbleMetadata = new Notification.BubbleMetadata.Builder(""foo"")
+                .setSuppressNotification(true).build();
+        entry.getSbn().getNotification().setBubbleMetadata(bubbleMetadata);
+        when(mPowerManager.isInteractive()).thenReturn(false);
+        when(mDreamManager.isDreaming()).thenReturn(true);
+        when(mStatusBarStateController.getState()).thenReturn(KEYGUARD);
+
+        assertThat(mNotifInterruptionStateProvider.shouldLaunchFullScreenIntentWhenAdded(entry))
+                .isFalse();
+    }
+
     @Test
     public void testShouldFullScreen_notInteractive() throws RemoteException {
         NotificationEntry entry = createFsiNotification(IMPORTANCE_HIGH, /* silenced */ false);
+        Notification.BubbleMetadata bubbleMetadata = new Notification.BubbleMetadata.Builder(""foo"")
+                .setSuppressNotification(false).build();
+        entry.getSbn().getNotification().setBubbleMetadata(bubbleMetadata);
         when(mPowerManager.isInteractive()).thenReturn(false);
         when(mDreamManager.isDreaming()).thenReturn(false);
         when(mStatusBarStateController.getState()).thenReturn(SHADE);
",18,0,"NotificationInterruptStateProviderImplTest::testShouldFullScreen_notInteractive, NotificationInterruptStateProviderImplTest::testShouldNotFullScreen_isSuppressedByBubbleMetadata"
302,fad839e2d005566d74fe8263c223f4c64e586712,ChooserActivity.java,"@@ -16,6 +16,8 @@
 
 package com.android.internal.app;
 
+import static android.content.ContentProvider.getUserIdFromUri;
+
 import static java.lang.annotation.RetentionPolicy.SOURCE;
 
 import android.animation.Animator;
@@ -149,6 +151,7 @@ import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
+import java.util.stream.Collectors;
 
 /**
  * The Chooser Activity handles intent resolution specifically for sharing intents -
@@ -1375,7 +1378,7 @@ public class ChooserActivity extends ResolverActivity implements
 
             ImageView previewThumbnailView = contentPreviewLayout.findViewById(
                     R.id.content_preview_thumbnail);
-            if (previewThumbnail == null) {
+            if (!validForContentPreview(previewThumbnail)) {
                 previewThumbnailView.setVisibility(View.GONE);
             } else {
                 mPreviewCoord = new ContentPreviewCoordinator(contentPreviewLayout, false);
@@ -1406,6 +1409,10 @@ public class ChooserActivity extends ResolverActivity implements
 
         if (Intent.ACTION_SEND.equals(action)) {
             Uri uri = targetIntent.getParcelableExtra(Intent.EXTRA_STREAM);
+            if (!validForContentPreview(uri)) {
+                contentPreviewLayout.setVisibility(View.GONE);
+                return contentPreviewLayout;
+            }
             imagePreview.findViewById(R.id.content_preview_image_1_large)
                     .setTransitionName(ChooserActivity.FIRST_IMAGE_PREVIEW_TRANSITION_NAME);
             mPreviewCoord.loadUriIntoView(R.id.content_preview_image_1_large, uri, 0);
@@ -1415,7 +1422,7 @@ public class ChooserActivity extends ResolverActivity implements
             List<Uri> uris = targetIntent.getParcelableArrayListExtra(Intent.EXTRA_STREAM);
             List<Uri> imageUris = new ArrayList<>();
             for (Uri uri : uris) {
-                if (isImageType(resolver.getType(uri))) {
+                if (validForContentPreview(uri) && isImageType(resolver.getType(uri))) {
                     imageUris.add(uri);
                 }
             }
@@ -1524,9 +1531,16 @@ public class ChooserActivity extends ResolverActivity implements
         String action = targetIntent.getAction();
         if (Intent.ACTION_SEND.equals(action)) {
             Uri uri = targetIntent.getParcelableExtra(Intent.EXTRA_STREAM);
+            if (!validForContentPreview(uri)) {
+                contentPreviewLayout.setVisibility(View.GONE);
+                return contentPreviewLayout;
+            }
             loadFileUriIntoView(uri, contentPreviewLayout);
         } else {
             List<Uri> uris = targetIntent.getParcelableArrayListExtra(Intent.EXTRA_STREAM);
+            uris = uris.stream()
+                    .filter(ChooserActivity::validForContentPreview)
+                    .collect(Collectors.toList());
             int uriCount = uris.size();
 
             if (uriCount == 0) {
@@ -1580,6 +1594,24 @@ public class ChooserActivity extends ResolverActivity implements
         }
     }
 
+    /**
+     * Indicate if the incoming content URI should be allowed.
+     *
+     * @param uri the uri to test
+     * @return true if the URI is allowed for content preview
+     */
+    private static boolean validForContentPreview(Uri uri) throws SecurityException {
+        if (uri == null) {
+            return false;
+        }
+        int userId = getUserIdFromUri(uri, UserHandle.USER_CURRENT);
+        if (userId != UserHandle.USER_CURRENT && userId != UserHandle.myUserId()) {
+            Log.e(TAG, ""dropped invalid content URI belonging to user "" + userId);
+            return false;
+        }
+        return true;
+    }
+
     @VisibleForTesting
     protected boolean isImageType(String mimeType) {
         return mimeType != null && mimeType.startsWith(""image/"");
",34,2,"ChooserActivity::displayTextContentPreview, ChooserActivity::validForContentPreview, ChooserActivity::displayFileContentPreview, ChooserActivity::displayImageContentPreview"
303,ddb8198e65c965ed74fdf4be5144a84d844802e0,ConfirmDialog.java,"@@ -40,12 +40,18 @@ public class ConfirmDialog extends AlertActivity
         implements DialogInterface.OnClickListener, ImageGetter {
     private static final String TAG = ""VpnConfirm"";
 
+    // Usually the label represents the app name, 150 code points might be enough to display the app
+    // name, and 150 code points won't cover the warning message from VpnDialog.
+    static final int MAX_VPN_LABEL_LENGTH = 150;
+
     @VpnManager.VpnType private final int mVpnType;
 
     private String mPackage;
 
     private VpnManager mVm;
 
+    private View mView;
+
     public ConfirmDialog() {
         this(VpnManager.TYPE_VPN_SERVICE);
     }
@@ -54,6 +60,42 @@ public class ConfirmDialog extends AlertActivity
         mVpnType = vpnType;
     }
 
+    /**
+     * This function will use the string resource to combine the VPN label and the package name.
+     *
+     * If the VPN label violates the length restriction, the first 30 code points of VPN label and
+     * the package name will be returned. Or return the VPN label and the package name directly if
+     * the VPN label doesn't violate the length restriction.
+     *
+     * The result will be something like,
+     * - ThisIsAVeryLongVpnAppNameWhich... (com.vpn.app)
+     *   if the VPN label violates the length restriction.
+     * or
+     * - VpnLabelWith&lt;br&gt;HtmlTag (com.vpn.app)
+     *   if the VPN label doesn't violate the length restriction.
+     *
+     */
+    private String getSimplifiedLabel(String vpnLabel, String packageName) {
+        if (vpnLabel.codePointCount(0, vpnLabel.length()) > 30) {
+            return getString(R.string.sanitized_vpn_label_with_ellipsis,
+                vpnLabel.substring(0, vpnLabel.offsetByCodePoints(0, 30)),
+                packageName);
+        }
+
+        return getString(R.string.sanitized_vpn_label, vpnLabel, packageName);
+    }
+
+    protected String getSanitizedVpnLabel(String vpnLabel, String packageName) {
+        final String sanitizedVpnLabel = Html.escapeHtml(vpnLabel);
+        final boolean exceedMaxVpnLabelLength = sanitizedVpnLabel.codePointCount(0,
+            sanitizedVpnLabel.length()) > MAX_VPN_LABEL_LENGTH;
+        if (exceedMaxVpnLabelLength || !vpnLabel.equals(sanitizedVpnLabel)) {
+            return getSimplifiedLabel(sanitizedVpnLabel, packageName);
+        }
+
+        return sanitizedVpnLabel;
+    }
+
     @Override
     protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
@@ -75,15 +117,16 @@ public class ConfirmDialog extends AlertActivity
             finish();
             return;
         }
-        View view = View.inflate(this, R.layout.confirm, null);
-        ((TextView) view.findViewById(R.id.warning)).setText(
-                Html.fromHtml(getString(R.string.warning, getVpnLabel()),
-                        this, null /* tagHandler */));
+        mView = View.inflate(this, R.layout.confirm, null);
+        ((TextView) mView.findViewById(R.id.warning)).setText(
+                Html.fromHtml(getString(R.string.warning, getSanitizedVpnLabel(
+                    getVpnLabel().toString(), mPackage)),
+                    this /* imageGetter */, null /* tagHandler */));
         mAlertParams.mTitle = getText(R.string.prompt);
         mAlertParams.mPositiveButtonText = getText(android.R.string.ok);
         mAlertParams.mPositiveButtonListener = this;
         mAlertParams.mNegativeButtonText = getText(android.R.string.cancel);
-        mAlertParams.mView = view;
+        mAlertParams.mView = mView;
         setupAlert();
 
         getWindow().setCloseOnTouchOutside(false);
",48,5,"ConfirmDialog::onCreate, ConfirmDialog::getSanitizedVpnLabel, ConfirmDialog::getSimplifiedLabel"
304,cdd8435eba6773ff9a71ac90568c71bbad7b51dd,ApkSignatureSchemeV2Verifier.java,"@@ -74,6 +74,11 @@ public class ApkSignatureSchemeV2Verifier {
 
     private static final int APK_SIGNATURE_SCHEME_V2_BLOCK_ID = 0x7109871a;
 
+    /**
+     * The maximum number of signers supported by the v2 APK signature scheme.
+     */
+    private static final int MAX_V2_SIGNERS = 10;
+
     /**
      * Returns {@code true} if the provided APK contains an APK Signature Scheme V2 signature.
      *
@@ -182,6 +187,11 @@ public class ApkSignatureSchemeV2Verifier {
         }
         while (signers.hasRemaining()) {
             signerCount++;
+            if (signerCount > MAX_V2_SIGNERS) {
+                throw new SecurityException(
+                        ""APK Signature Scheme v2 only supports a maximum of "" + MAX_V2_SIGNERS
+                                + "" signers"");
+            }
             try {
                 ByteBuffer signer = getLengthPrefixedSlice(signers);
                 X509Certificate[] certs = verifySigner(signer, contentDigests, certFactory);
",10,0,ApkSignatureSchemeV2Verifier::verify
305,cdd8435eba6773ff9a71ac90568c71bbad7b51dd,StrictJarVerifier.java,"@@ -78,6 +78,11 @@ class StrictJarVerifier {
         ""SHA1"",
     };
 
+    /**
+     * The maximum number of signers supported by the JAR signature scheme.
+     */
+    private static final int MAX_JAR_SIGNERS = 10;
+
     private final String jarName;
     private final StrictJarManifest manifest;
     private final HashMap<String, byte[]> metaEntries;
@@ -293,10 +298,16 @@ class StrictJarVerifier {
             return false;
         }
 
+        int signerCount = 0;
         Iterator<String> it = metaEntries.keySet().iterator();
         while (it.hasNext()) {
             String key = it.next();
             if (key.endsWith("".DSA"") || key.endsWith("".RSA"") || key.endsWith("".EC"")) {
+                if (++signerCount > MAX_JAR_SIGNERS) {
+                    throw new SecurityException(
+                            ""APK Signature Scheme v1 only supports a maximum of "" + MAX_JAR_SIGNERS
+                                    + "" signers"");
+                }
                 verifyCertificate(key);
                 it.remove();
             }
",11,0,StrictJarVerifier::readCertificates
306,477cb8ed3bc58fbac41689cfcdbda05402692c1b,Notification.java,"@@ -2837,6 +2837,14 @@ public class Notification implements Parcelable
             }
         }
 
+        if (isStyle(CallStyle.class) & extras != null) {
+            Person callPerson = extras.getParcelable(EXTRA_CALL_PERSON);
+            if (callPerson != null) {
+                visitor.accept(callPerson.getIconUri());
+            }
+            visitIconUri(visitor, extras.getParcelable(EXTRA_VERIFICATION_ICON));
+        }
+
         if (mBubbleMetadata != null) {
             visitIconUri(visitor, mBubbleMetadata.getIcon());
         }
",8,0,Notification::visitUris
307,477cb8ed3bc58fbac41689cfcdbda05402692c1b,NotificationManagerServiceTest.java,"@@ -4463,6 +4463,29 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {
         verify(visitor, times(1)).accept(eq(backgroundImage));
     }
 
+    @Test
+    public void testVisitUris_callStyle() {
+        Icon personIcon = Icon.createWithContentUri(""content://media/person"");
+        Icon verificationIcon = Icon.createWithContentUri(""content://media/verification"");
+        Person callingPerson = new Person.Builder().setName(""Someone"")
+                .setIcon(personIcon)
+                .build();
+        PendingIntent hangUpIntent = PendingIntent.getActivity(mContext, 0, new Intent(),
+                PendingIntent.FLAG_IMMUTABLE);
+        Notification n = new Notification.Builder(mContext, ""a"")
+                .setStyle(Notification.CallStyle.forOngoingCall(callingPerson, hangUpIntent)
+                        .setVerificationIcon(verificationIcon))
+                .setContentTitle(""Calling..."")
+                .setSmallIcon(android.R.drawable.sym_def_app_icon)
+                .build();
+
+        Consumer<Uri> visitor = (Consumer<Uri>) spy(Consumer.class);
+        n.visitUris(visitor);
+
+        verify(visitor, times(1)).accept(eq(personIcon.getUri()));
+        verify(visitor, times(1)).accept(eq(verificationIcon.getUri()));
+    }
+
     @Test
     public void testVisitUris_audioContentsString() throws Exception {
         final Uri audioContents = Uri.parse(""content://com.example/audio"");
",23,0,NotificationManagerServiceTest::testVisitUris_callStyle
308,796e70d56d9490e78e654e88578699f4d4f71553,ActivityOptions.java,"@@ -20,6 +20,8 @@ import static android.Manifest.permission.CONTROL_REMOTE_APP_TRANSITION_ANIMATIO
 import static android.Manifest.permission.START_TASKS_FROM_RECENTS;
 import static android.app.WindowConfiguration.ACTIVITY_TYPE_UNDEFINED;
 import static android.app.WindowConfiguration.WINDOWING_MODE_UNDEFINED;
+import static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;
+import static android.content.Intent.FLAG_RECEIVER_FOREGROUND;
 import static android.view.Display.INVALID_DISPLAY;
 
 import android.annotation.IntDef;
@@ -1553,7 +1555,9 @@ public class ActivityOptions extends ComponentOptions {
      * @hide
      */
     public int getPendingIntentLaunchFlags() {
-        return mPendingIntentLaunchFlags;
+        // b/243794108: Ignore all flags except the new task flag, to be reconsidered in b/254490217
+        return mPendingIntentLaunchFlags &
+                (FLAG_ACTIVITY_NEW_TASK | FLAG_RECEIVER_FOREGROUND);
     }
 
     /**
",5,1,ActivityOptions::getPendingIntentLaunchFlags
309,37ca905ed529c3bbb624b5dfe244cf09e0fef417,KeyguardSecurityContainerController.java,"@@ -426,7 +426,7 @@ public class KeyguardSecurityContainerController extends ViewController<Keyguard
                 case SimPuk:
                     // Shortcut for SIM PIN/PUK to go to directly to user's security screen or home
                     SecurityMode securityMode = mSecurityModel.getSecurityMode(targetUserId);
-                    if (securityMode == SecurityMode.None && mLockPatternUtils.isLockScreenDisabled(
+                    if (securityMode == SecurityMode.None || mLockPatternUtils.isLockScreenDisabled(
                             KeyguardUpdateMonitor.getCurrentUser())) {
                         finish = true;
                         eventSubtype = BOUNCER_DISMISS_SIM;
",1,1,KeyguardSecurityContainerController::showNextSecurityScreenOrFinish
310,26a1ac33ad29ce6f22acbfcd087d0f882aa0ed40,Notification.java,"@@ -2807,6 +2807,17 @@ public class Notification implements Parcelable
             if (person != null) {
                 visitor.accept(person.getIconUri());
             }
+
+            final RemoteInputHistoryItem[] history = (RemoteInputHistoryItem[])
+                    extras.getParcelableArray(Notification.EXTRA_REMOTE_INPUT_HISTORY_ITEMS);
+            if (history != null) {
+                for (int i = 0; i < history.length; i++) {
+                    RemoteInputHistoryItem item = history[i];
+                    if (item.getUri() != null) {
+                        visitor.accept(item.getUri());
+                    }
+                }
+            }
         }
 
         if (isStyle(MessagingStyle.class) && extras != null) {
",11,0,Notification::visitUris
311,26a1ac33ad29ce6f22acbfcd087d0f882aa0ed40,NotificationManagerServiceTest.java,"@@ -115,6 +115,7 @@ import android.app.NotificationManager;
 import android.app.PendingIntent;
 import android.app.Person;
 import android.app.RemoteInput;
+import android.app.RemoteInputHistoryItem;
 import android.app.StatsManager;
 import android.app.admin.DevicePolicyManagerInternal;
 import android.app.usage.UsageStatsManagerInternal;
@@ -4446,10 +4447,36 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {
     public void testVisitUris() throws Exception {
         final Uri audioContents = Uri.parse(""content://com.example/audio"");
         final Uri backgroundImage = Uri.parse(""content://com.example/background"");
+        final Icon personIcon1 = Icon.createWithContentUri(""content://media/person1"");
+        final Icon personIcon2 = Icon.createWithContentUri(""content://media/person2"");
+        final Icon personIcon3 = Icon.createWithContentUri(""content://media/person3"");
+        final Person person1 = new Person.Builder()
+                .setName(""Messaging Person"")
+                .setIcon(personIcon1)
+                .build();
+        final Person person2 = new Person.Builder()
+                .setName(""People List Person 1"")
+                .setIcon(personIcon2)
+                .build();
+        final Person person3 = new Person.Builder()
+                .setName(""People List Person 2"")
+                .setIcon(personIcon3)
+                .build();
+        final Uri historyUri1 = Uri.parse(""content://com.example/history1"");
+        final Uri historyUri2 = Uri.parse(""content://com.example/history2"");
+        final RemoteInputHistoryItem historyItem1 = new RemoteInputHistoryItem(null, historyUri1,
+                ""a"");
+        final RemoteInputHistoryItem historyItem2 = new RemoteInputHistoryItem(null, historyUri2,
+                ""b"");
 
         Bundle extras = new Bundle();
         extras.putParcelable(Notification.EXTRA_AUDIO_CONTENTS_URI, audioContents);
         extras.putString(Notification.EXTRA_BACKGROUND_IMAGE_URI, backgroundImage.toString());
+        extras.putParcelable(Notification.EXTRA_MESSAGING_PERSON, person1);
+        extras.putParcelableArrayList(Notification.EXTRA_PEOPLE_LIST,
+                new ArrayList<>(Arrays.asList(person2, person3)));
+        extras.putParcelableArray(Notification.EXTRA_REMOTE_INPUT_HISTORY_ITEMS,
+                new RemoteInputHistoryItem[]{historyItem1, historyItem2});
 
         Notification n = new Notification.Builder(mContext, ""a"")
                 .setContentTitle(""notification with uris"")
@@ -4461,6 +4488,11 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {
         n.visitUris(visitor);
         verify(visitor, times(1)).accept(eq(audioContents));
         verify(visitor, times(1)).accept(eq(backgroundImage));
+        verify(visitor, times(1)).accept(eq(personIcon1.getUri()));
+        verify(visitor, times(1)).accept(eq(personIcon2.getUri()));
+        verify(visitor, times(1)).accept(eq(personIcon3.getUri()));
+        verify(visitor, times(1)).accept(eq(historyUri1));
+        verify(visitor, times(1)).accept(eq(historyUri2));
     }
 
     @Test
",32,0,NotificationManagerServiceTest::testVisitUris
312,94cd71b3e35328c30778d02c07ee9a21d3ad6544,ShortcutInfo.java,"@@ -276,6 +276,12 @@ public final class ShortcutInfo implements Parcelable {
      */
     public static final int DISABLED_REASON_OTHER_RESTORE_ISSUE = 103;
 
+    /**
+     * The maximum length of Shortcut ID. IDs will be truncated at this limit.
+     * @hide
+     */
+    public static final int MAX_ID_LENGTH = 1000;
+
     /** @hide */
     @IntDef(prefix = { ""DISABLED_REASON_"" }, value = {
             DISABLED_REASON_NOT_DISABLED,
@@ -453,8 +459,7 @@ public final class ShortcutInfo implements Parcelable {
 
     private ShortcutInfo(Builder b) {
         mUserId = b.mContext.getUserId();
-
-        mId = Preconditions.checkStringNotEmpty(b.mId, ""Shortcut ID must be provided"");
+        mId = getSafeId(Preconditions.checkStringNotEmpty(b.mId, ""Shortcut ID must be provided""));
 
         // Note we can't do other null checks here because SM.updateShortcuts() takes partial
         // information.
@@ -558,6 +563,14 @@ public final class ShortcutInfo implements Parcelable {
         return ret;
     }
 
+    @NonNull
+    private static String getSafeId(@NonNull String id) {
+        if (id.length() > MAX_ID_LENGTH) {
+            return id.substring(0, MAX_ID_LENGTH);
+        }
+        return id;
+    }
+
     /**
      * Throws if any of the mandatory fields is not set.
      *
@@ -2141,7 +2154,8 @@ public final class ShortcutInfo implements Parcelable {
         final ClassLoader cl = getClass().getClassLoader();
 
         mUserId = source.readInt();
-        mId = source.readString8();
+        mId = getSafeId(Preconditions.checkStringNotEmpty(source.readString8(),
+                ""Shortcut ID must be provided""));
         mPackageName = source.readString8();
         mActivity = source.readParcelable(cl);
         mFlags = source.readInt();
",17,3,"ShortcutInfo::getSafeId, ShortcutInfo::ShortcutInfo, ShortcutInfo::ShortcutInfo"
313,94cd71b3e35328c30778d02c07ee9a21d3ad6544,ShortcutManagerTest2.java,"@@ -53,6 +53,7 @@ import java.io.File;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.Writer;
+import java.util.Collections;
 import java.util.Locale;
 
 /**
@@ -223,6 +224,15 @@ public class ShortcutManagerTest2 extends BaseShortcutManagerTest {
                 });
     }
 
+    public void testShortcutIdTruncated() {
+        ShortcutInfo si = new ShortcutInfo.Builder(getTestContext(),
+                String.join("""", Collections.nCopies(Short.MAX_VALUE, ""s""))).build();
+
+        assertTrue(
+                ""id must be truncated to MAX_ID_LENGTH"",
+                si.getId().length() <= ShortcutInfo.MAX_ID_LENGTH);
+    }
+
     public void testShortcutInfoParcel() {
         setCaller(CALLING_PACKAGE_1, USER_10);
         ShortcutInfo si = parceled(new ShortcutInfo.Builder(mClientContext)
",10,0,ShortcutManagerTest2::testShortcutIdTruncated
314,b2dfeb065030eef7d5dd1307068c54896e688171,RemoteViews.java,"@@ -709,6 +709,12 @@ public class RemoteViews implements Parcelable, Filter {
                 mActions.get(i).visitUris(visitor);
             }
         }
+        if (mLandscape != null) {
+            mLandscape.visitUris(visitor);
+        }
+        if (mPortrait != null) {
+            mPortrait.visitUris(visitor);
+        }
     }
 
     private static void visitIconUri(Icon icon, @NonNull Consumer<Uri> visitor) {
",6,0,RemoteViews::visitUris
315,b2dfeb065030eef7d5dd1307068c54896e688171,RemoteViewsTest.java,"@@ -20,6 +20,10 @@ import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
+import static org.mockito.ArgumentMatchers.eq;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
 
 import android.app.ActivityOptions;
 import android.app.PendingIntent;
@@ -29,6 +33,8 @@ import android.content.Intent;
 import android.graphics.Bitmap;
 import android.graphics.drawable.BitmapDrawable;
 import android.graphics.drawable.Drawable;
+import android.graphics.drawable.Icon;
+import android.net.Uri;
 import android.os.AsyncTask;
 import android.os.Binder;
 import android.os.Parcel;
@@ -50,6 +56,7 @@ import org.junit.runner.RunWith;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.concurrent.CountDownLatch;
+import java.util.function.Consumer;
 
 /**
  * Tests for RemoteViews.
@@ -499,4 +506,61 @@ public class RemoteViewsTest {
             return null;
         }
     }
+
+    @Test
+    public void visitUris() {
+        RemoteViews views = new RemoteViews(mPackage, R.layout.remote_views_test);
+
+        final Uri imageUri = Uri.parse(""content://media/image"");
+        final Icon icon1 = Icon.createWithContentUri(""content://media/icon1"");
+        final Icon icon2 = Icon.createWithContentUri(""content://media/icon2"");
+        final Icon icon3 = Icon.createWithContentUri(""content://media/icon3"");
+        final Icon icon4 = Icon.createWithContentUri(""content://media/icon4"");
+        views.setImageViewUri(R.id.image, imageUri);
+        views.setTextViewCompoundDrawables(R.id.text, icon1, icon2, icon3, icon4);
+
+        Consumer<Uri> visitor = (Consumer<Uri>) spy(Consumer.class);
+        views.visitUris(visitor);
+        verify(visitor, times(1)).accept(eq(imageUri));
+        verify(visitor, times(1)).accept(eq(icon1.getUri()));
+        verify(visitor, times(1)).accept(eq(icon2.getUri()));
+        verify(visitor, times(1)).accept(eq(icon3.getUri()));
+        verify(visitor, times(1)).accept(eq(icon4.getUri()));
+    }
+
+    @Test
+    public void visitUris_separateOrientation() {
+        final RemoteViews landscape = new RemoteViews(mPackage, R.layout.remote_views_test);
+        final Uri imageUriL = Uri.parse(""content://landscape/image"");
+        final Icon icon1L = Icon.createWithContentUri(""content://landscape/icon1"");
+        final Icon icon2L = Icon.createWithContentUri(""content://landscape/icon2"");
+        final Icon icon3L = Icon.createWithContentUri(""content://landscape/icon3"");
+        final Icon icon4L = Icon.createWithContentUri(""content://landscape/icon4"");
+        landscape.setImageViewUri(R.id.image, imageUriL);
+        landscape.setTextViewCompoundDrawables(R.id.text, icon1L, icon2L, icon3L, icon4L);
+
+        final RemoteViews portrait = new RemoteViews(mPackage, 33);
+        final Uri imageUriP = Uri.parse(""content://portrait/image"");
+        final Icon icon1P = Icon.createWithContentUri(""content://portrait/icon1"");
+        final Icon icon2P = Icon.createWithContentUri(""content://portrait/icon2"");
+        final Icon icon3P = Icon.createWithContentUri(""content://portrait/icon3"");
+        final Icon icon4P = Icon.createWithContentUri(""content://portrait/icon4"");
+        portrait.setImageViewUri(R.id.image, imageUriP);
+        portrait.setTextViewCompoundDrawables(R.id.text, icon1P, icon2P, icon3P, icon4P);
+
+        RemoteViews views = new RemoteViews(landscape, portrait);
+
+        Consumer<Uri> visitor = (Consumer<Uri>) spy(Consumer.class);
+        views.visitUris(visitor);
+        verify(visitor, times(1)).accept(eq(imageUriL));
+        verify(visitor, times(1)).accept(eq(icon1L.getUri()));
+        verify(visitor, times(1)).accept(eq(icon2L.getUri()));
+        verify(visitor, times(1)).accept(eq(icon3L.getUri()));
+        verify(visitor, times(1)).accept(eq(icon4L.getUri()));
+        verify(visitor, times(1)).accept(eq(imageUriP));
+        verify(visitor, times(1)).accept(eq(icon1P.getUri()));
+        verify(visitor, times(1)).accept(eq(icon2P.getUri()));
+        verify(visitor, times(1)).accept(eq(icon3P.getUri()));
+        verify(visitor, times(1)).accept(eq(icon4P.getUri()));
+    }
 }
",64,0,"RemoteViewsTest::visitUris, RemoteViewsTest::visitUris_separateOrientation"
316,1db9575c599343530de8b6ff78f2179625f1c381,ActivityManager.java,"@@ -3666,6 +3666,9 @@ public class ActivityManager {
      * processes to reclaim memory; the system will take care of restarting
      * these processes in the future as needed.
      *
+     * <p class=""note"">Third party applications can only use this API to kill their own processes.
+     * </p>
+     *
      * @param packageName The name of the package whose processes are to
      * be killed.
      */
",3,0,
317,1db9575c599343530de8b6ff78f2179625f1c381,ActivityManagerService.java,"@@ -3618,8 +3618,20 @@ public class ActivityManagerService extends IActivityManager.Stub
             Slog.w(TAG, msg);
             throw new SecurityException(msg);
         }
+        final int callingUid = Binder.getCallingUid();
+        final int callingPid = Binder.getCallingPid();
+        final int callingAppId = UserHandle.getAppId(callingUid);
 
-        userId = mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(),
+        ProcessRecord proc;
+        synchronized (mPidsSelfLocked) {
+            proc = mPidsSelfLocked.get(callingPid);
+        }
+        final boolean hasKillAllPermission = PERMISSION_GRANTED == checkPermission(
+                android.Manifest.permission.FORCE_STOP_PACKAGES, callingPid, callingUid)
+                || UserHandle.isCore(callingUid)
+                || (proc != null && proc.info.isSystemApp());
+
+        userId = mUserController.handleIncomingUser(callingPid, callingUid,
                 userId, true, ALLOW_FULL_ONLY, ""killBackgroundProcesses"", null);
         final int[] userIds = mUserController.expandUserId(userId);
 
@@ -3634,7 +3646,7 @@ public class ActivityManagerService extends IActivityManager.Stub
                                     targetUserId));
                 } catch (RemoteException e) {
                 }
-                if (appId == -1) {
+                if (appId == -1 || (!hasKillAllPermission && appId != callingAppId)) {
                     Slog.w(TAG, ""Invalid packageName: "" + packageName);
                     return;
                 }
@@ -3702,6 +3714,22 @@ public class ActivityManagerService extends IActivityManager.Stub
             throw new SecurityException(msg);
         }
 
+        final int callingUid = Binder.getCallingUid();
+        final int callingPid = Binder.getCallingPid();
+
+        ProcessRecord proc;
+        synchronized (mPidsSelfLocked) {
+            proc = mPidsSelfLocked.get(callingPid);
+        }
+        if (callingUid >= FIRST_APPLICATION_UID
+                && (proc == null || !proc.info.isSystemApp())) {
+            final String msg = ""Permission Denial: killAllBackgroundProcesses() from pid=""
+                    + callingPid + "", uid="" + callingUid + "" is not allowed"";
+            Slog.w(TAG, msg);
+            // Silently return to avoid existing apps from crashing.
+            return;
+        }
+
         final long callingId = Binder.clearCallingIdentity();
         try {
             synchronized (this) {
",30,2,"ActivityManagerService::killAllBackgroundProcessesExcept, ActivityManagerService::killBackgroundProcesses"
318,6fc71babb098385e882e7cd491f44970499608ab,ActivityManagerService.java,"@@ -6313,7 +6313,7 @@ public class ActivityManagerService extends IActivityManager.Stub
         mActivityTaskManager.unhandledBack();
     }
 
-    // TODO: Move to ContentProviderHelper?
+    // TODO: Replace this method with one that returns a bound IContentProvider.
     public ParcelFileDescriptor openContentUri(String uriString) throws RemoteException {
         enforceNotIsolatedCaller(""openContentUri"");
         final int userId = UserHandle.getCallingUserId();
@@ -6342,6 +6342,16 @@ public class ActivityManagerService extends IActivityManager.Stub
                     Log.e(TAG, ""Cannot find package for uid: "" + uid);
                     return null;
                 }
+
+                final ApplicationInfo appInfo = mPackageManagerInt.getApplicationInfo(
+                        androidPackage.getPackageName(), /*flags*/0, Process.SYSTEM_UID,
+                        UserHandle.USER_SYSTEM);
+                if (!appInfo.isVendor() && !appInfo.isSystemApp() && !appInfo.isSystemExt()
+                        && !appInfo.isProduct()) {
+                    Log.e(TAG, ""openContentUri may only be used by vendor/system/product."");
+                    return null;
+                }
+
                 final AttributionSource attributionSource = new AttributionSource(
                         Binder.getCallingUid(), androidPackage.getPackageName(), null);
                 pfd = cph.provider.openFile(attributionSource, uri, ""r"", null);
",11,1,ActivityManagerService::openContentUri
319,64e1eb289bb272e03cf735733211a08dac802b8c,QuickAccessWalletTile.java,"@@ -16,6 +16,7 @@
 
 package com.android.systemui.qs.tiles;
 
+import static android.graphics.drawable.Icon.TYPE_URI;
 import static android.provider.Settings.Secure.NFC_PAYMENT_DEFAULT_COMPONENT;
 
 import static com.android.systemui.wallet.controller.QuickAccessWalletController.WalletChangeEvent.DEFAULT_PAYMENT_APP_CHANGE;
@@ -240,7 +241,12 @@ public class QuickAccessWalletTile extends QSTileImpl<QSTile.State> {
                 return;
             }
             mSelectedCard = cards.get(selectedIndex);
-            mCardViewDrawable = mSelectedCard.getCardImage().loadDrawable(mContext);
+            android.graphics.drawable.Icon cardImageIcon = mSelectedCard.getCardImage();
+            if (cardImageIcon.getType() == TYPE_URI) {
+                mCardViewDrawable = null;
+            } else {
+                mCardViewDrawable = mSelectedCard.getCardImage().loadDrawable(mContext);
+            }
             refreshState();
         }
 
",7,1,QuickAccessWalletTile::WalletCardRetriever::onWalletCardsRetrieved
320,64e1eb289bb272e03cf735733211a08dac802b8c,WalletScreenController.java,"@@ -318,7 +318,12 @@ public class WalletScreenController implements
          */
         QAWalletCardViewInfo(Context context, WalletCard walletCard) {
             mWalletCard = walletCard;
-            mCardDrawable = mWalletCard.getCardImage().loadDrawable(context);
+            Icon cardImageIcon = mWalletCard.getCardImage();
+            if (cardImageIcon.getType() == Icon.TYPE_URI) {
+                mCardDrawable = null;
+            } else {
+                mCardDrawable = mWalletCard.getCardImage().loadDrawable(context);
+            }
             Icon icon = mWalletCard.getCardIcon();
             mIconDrawable = icon == null ? null : icon.loadDrawable(context);
         }
",6,1,WalletScreenController::QAWalletCardViewInfo::QAWalletCardViewInfo
321,64e1eb289bb272e03cf735733211a08dac802b8c,QuickAccessWalletTileTest.java,"@@ -91,8 +91,11 @@ public class QuickAccessWalletTileTest extends SysuiTestCase {
 
     private static final String CARD_ID = ""card_id"";
     private static final String LABEL = ""QAW"";
+    private static final String CARD_DESCRIPTION = ""•••• 1234"";
     private static final Icon CARD_IMAGE =
             Icon.createWithBitmap(Bitmap.createBitmap(70, 50, Bitmap.Config.ARGB_8888));
+    private static final int PRIMARY_USER_ID = 0;
+    private static final int SECONDARY_USER_ID = 10;
 
     private final Drawable mTileIcon = mContext.getDrawable(R.drawable.ic_qs_wallet);
     private final Intent mWalletIntent = new Intent(QuickAccessWalletService.ACTION_VIEW_WALLET)
@@ -119,6 +122,8 @@ public class QuickAccessWalletTileTest extends SysuiTestCase {
     private SecureSettings mSecureSettings;
     @Mock
     private QuickAccessWalletController mController;
+    @Mock
+    private Icon mCardImage;
     @Captor
     ArgumentCaptor<Intent> mIntentCaptor;
     @Captor
@@ -144,6 +149,8 @@ public class QuickAccessWalletTileTest extends SysuiTestCase {
         when(mQuickAccessWalletClient.isWalletServiceAvailable()).thenReturn(true);
         when(mQuickAccessWalletClient.isWalletFeatureAvailableWhenDeviceLocked()).thenReturn(true);
         when(mController.getWalletClient()).thenReturn(mQuickAccessWalletClient);
+        when(mCardImage.getType()).thenReturn(Icon.TYPE_URI);
+        when(mCardImage.loadDrawableAsUser(any(), eq(SECONDARY_USER_ID))).thenReturn(null);
 
         mTile = new QuickAccessWalletTile(
                 mHost,
@@ -418,6 +425,28 @@ public class QuickAccessWalletTileTest extends SysuiTestCase {
         assertNotNull(mTile.getState().sideViewCustomDrawable);
     }
 
+    @Test
+    public void testQueryCards_notCurrentUser_hasCards_noSideViewDrawable() {
+        when(mKeyguardStateController.isUnlocked()).thenReturn(true);
+
+        PendingIntent pendingIntent =
+                PendingIntent.getActivity(mContext, 0, mWalletIntent, PendingIntent.FLAG_IMMUTABLE);
+        WalletCard walletCard =
+                new WalletCard.Builder(
+                    CARD_ID, mCardImage, CARD_DESCRIPTION, pendingIntent).build();
+        GetWalletCardsResponse response =
+                new GetWalletCardsResponse(Collections.singletonList(walletCard), 0);
+
+        mTile.handleSetListening(true);
+
+        verify(mController).queryWalletCards(mCallbackCaptor.capture());
+
+        mCallbackCaptor.getValue().onWalletCardsRetrieved(response);
+        mTestableLooper.processAllMessages();
+
+        assertNull(mTile.getState().sideViewCustomDrawable);
+    }
+
     @Test
     public void testQueryCards_noCards_notUpdateSideViewDrawable() {
         setUpWalletCard(/* hasCard= */ false);
@@ -465,6 +494,6 @@ public class QuickAccessWalletTileTest extends SysuiTestCase {
     private WalletCard createWalletCard(Context context) {
         PendingIntent pendingIntent =
                 PendingIntent.getActivity(context, 0, mWalletIntent, PendingIntent.FLAG_IMMUTABLE);
-        return new WalletCard.Builder(CARD_ID, CARD_IMAGE, ""•••• 1234"", pendingIntent).build();
+        return new WalletCard.Builder(CARD_ID, CARD_IMAGE, CARD_DESCRIPTION, pendingIntent).build();
     }
 }
",30,1,"QuickAccessWalletTileTest::createWalletCard, QuickAccessWalletTileTest::testQueryCards_notCurrentUser_hasCards_noSideViewDrawable, QuickAccessWalletTileTest::setUp"
322,ee234c797474f17f1206dbe9bfaa11c39e4e175e,Notification.java,"@@ -2846,6 +2846,8 @@ public class Notification implements Parcelable
                     }
                 }
             }
+
+            visitIconUri(visitor, extras.getParcelable(EXTRA_CONVERSATION_ICON));
         }
 
         if (isStyle(CallStyle.class) & extras != null) {
",2,0,Notification::visitUris
323,ee234c797474f17f1206dbe9bfaa11c39e4e175e,NotificationManagerServiceTest.java,"@@ -4447,6 +4447,8 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {
     public void testVisitUris() throws Exception {
         final Uri audioContents = Uri.parse(""content://com.example/audio"");
         final Uri backgroundImage = Uri.parse(""content://com.example/background"");
+        final Icon smallIcon = Icon.createWithContentUri(""content://media/small/icon"");
+        final Icon largeIcon = Icon.createWithContentUri(""content://media/large/icon"");
         final Icon personIcon1 = Icon.createWithContentUri(""content://media/person1"");
         final Icon personIcon2 = Icon.createWithContentUri(""content://media/person2"");
         final Icon personIcon3 = Icon.createWithContentUri(""content://media/person3"");
@@ -4480,7 +4482,8 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {
 
         Notification n = new Notification.Builder(mContext, ""a"")
                 .setContentTitle(""notification with uris"")
-                .setSmallIcon(android.R.drawable.sym_def_app_icon)
+                .setSmallIcon(smallIcon)
+                .setLargeIcon(largeIcon)
                 .addExtras(extras)
                 .build();
 
@@ -4488,6 +4491,8 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {
         n.visitUris(visitor);
         verify(visitor, times(1)).accept(eq(audioContents));
         verify(visitor, times(1)).accept(eq(backgroundImage));
+        verify(visitor, times(1)).accept(eq(smallIcon.getUri()));
+        verify(visitor, times(1)).accept(eq(largeIcon.getUri()));
         verify(visitor, times(1)).accept(eq(personIcon1.getUri()));
         verify(visitor, times(1)).accept(eq(personIcon2.getUri()));
         verify(visitor, times(1)).accept(eq(personIcon3.getUri()));
@@ -4495,6 +4500,68 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {
         verify(visitor, times(1)).accept(eq(historyUri2));
     }
 
+    @Test
+    public void testVisitUris_audioContentsString() throws Exception {
+        final Uri audioContents = Uri.parse(""content://com.example/audio"");
+
+        Bundle extras = new Bundle();
+        extras.putString(Notification.EXTRA_AUDIO_CONTENTS_URI, audioContents.toString());
+
+        Notification n = new Notification.Builder(mContext, ""a"")
+                .setContentTitle(""notification with uris"")
+                .setSmallIcon(android.R.drawable.sym_def_app_icon)
+                .addExtras(extras)
+                .build();
+
+        Consumer<Uri> visitor = (Consumer<Uri>) spy(Consumer.class);
+        n.visitUris(visitor);
+        verify(visitor, times(1)).accept(eq(audioContents));
+    }
+
+    @Test
+    public void testVisitUris_messagingStyle() {
+        final Icon personIcon1 = Icon.createWithContentUri(""content://media/person1"");
+        final Icon personIcon2 = Icon.createWithContentUri(""content://media/person2"");
+        final Icon personIcon3 = Icon.createWithContentUri(""content://media/person3"");
+        final Person person1 = new Person.Builder()
+                .setName(""Messaging Person 1"")
+                .setIcon(personIcon1)
+                .build();
+        final Person person2 = new Person.Builder()
+                .setName(""Messaging Person 2"")
+                .setIcon(personIcon2)
+                .build();
+        final Person person3 = new Person.Builder()
+                .setName(""Messaging Person 3"")
+                .setIcon(personIcon3)
+                .build();
+        Icon shortcutIcon = Icon.createWithContentUri(""content://media/shortcut"");
+
+        Notification.Builder builder = new Notification.Builder(mContext, ""a"")
+                .setCategory(Notification.CATEGORY_MESSAGE)
+                .setContentTitle(""new message!"")
+                .setContentText(""Conversation Notification"")
+                .setSmallIcon(android.R.drawable.sym_def_app_icon);
+        Notification.MessagingStyle.Message message1 = new Notification.MessagingStyle.Message(
+                ""Marco?"", System.currentTimeMillis(), person2);
+        Notification.MessagingStyle.Message message2 = new Notification.MessagingStyle.Message(
+                ""Polo!"", System.currentTimeMillis(), person3);
+        Notification.MessagingStyle style = new Notification.MessagingStyle(person1)
+                .addMessage(message1)
+                .addMessage(message2)
+                .setShortcutIcon(shortcutIcon);
+        builder.setStyle(style);
+        Notification n = builder.build();
+
+        Consumer<Uri> visitor = (Consumer<Uri>) spy(Consumer.class);
+        n.visitUris(visitor);
+
+        verify(visitor, times(1)).accept(eq(shortcutIcon.getUri()));
+        verify(visitor, times(1)).accept(eq(personIcon1.getUri()));
+        verify(visitor, times(1)).accept(eq(personIcon2.getUri()));
+        verify(visitor, times(1)).accept(eq(personIcon3.getUri()));
+    }
+
     @Test
     public void testVisitUris_callStyle() {
         Icon personIcon = Icon.createWithContentUri(""content://media/person"");
@@ -4518,24 +4585,6 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {
         verify(visitor, times(1)).accept(eq(verificationIcon.getUri()));
     }
 
-    @Test
-    public void testVisitUris_audioContentsString() throws Exception {
-        final Uri audioContents = Uri.parse(""content://com.example/audio"");
-
-        Bundle extras = new Bundle();
-        extras.putString(Notification.EXTRA_AUDIO_CONTENTS_URI, audioContents.toString());
-
-        Notification n = new Notification.Builder(mContext, ""a"")
-                .setContentTitle(""notification with uris"")
-                .setSmallIcon(android.R.drawable.sym_def_app_icon)
-                .addExtras(extras)
-                .build();
-
-        Consumer<Uri> visitor = (Consumer<Uri>) spy(Consumer.class);
-        n.visitUris(visitor);
-        verify(visitor, times(1)).accept(eq(audioContents));
-    }
-
     @Test
     public void testSetNotificationPolicy_preP_setOldFields() {
         ZenModeHelper mZenModeHelper = mock(ZenModeHelper.class);
",68,19,"NotificationManagerServiceTest::testVisitUris_audioContentsString, NotificationManagerServiceTest::testVisitUris, NotificationManagerServiceTest::testVisitUris_messagingStyle"
324,580ee2c3614140ff611acd1af2132a43a16bb88f,DevicePolicyManager.java,"@@ -11411,7 +11411,8 @@ public class DevicePolicyManager {
 
     /**
      * Called by a device admin to set the long support message. This will be displayed to the user
-     * in the device administators settings screen.
+     * in the device administrators settings screen. If the message is longer than 20000 characters
+     * it may be truncated.
      * <p>
      * If the long support message needs to be localized, it is the responsibility of the
      * {@link DeviceAdminReceiver} to listen to the {@link Intent#ACTION_LOCALE_CHANGED} broadcast
",2,1,
325,580ee2c3614140ff611acd1af2132a43a16bb88f,DevicePolicyManagerService.java,"@@ -361,6 +361,7 @@ import java.security.cert.CertificateFactory;
 import java.security.cert.X509Certificate;
 import java.text.DateFormat;
 import java.time.LocalDate;
+import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
@@ -372,6 +373,7 @@ import java.util.List;
 import java.util.Locale;
 import java.util.Map;
 import java.util.Objects;
+import java.util.Queue;
 import java.util.Set;
 import java.util.concurrent.TimeUnit;
 import java.util.function.Function;
@@ -400,6 +402,15 @@ public class DevicePolicyManagerService extends BaseIDevicePolicyManager {
 
     private static final int REQUEST_PROFILE_OFF_DEADLINE = 5572;
 
+    // Binary XML serializer doesn't support longer strings
+    private static final int MAX_POLICY_STRING_LENGTH = 65535;
+    // FrameworkParsingPackageUtils#MAX_FILE_NAME_SIZE, Android packages are used in dir names.
+    private static final int MAX_PACKAGE_NAME_LENGTH = 223;
+
+    private static final int MAX_LONG_SUPPORT_MESSAGE_LENGTH = 20000;
+    private static final int MAX_SHORT_SUPPORT_MESSAGE_LENGTH = 200;
+    private static final int MAX_ORG_NAME_LENGTH = 200;
+
     private static final long MS_PER_DAY = TimeUnit.DAYS.toMillis(1);
 
     private static final long EXPIRATION_GRACE_PERIOD_MS = 5 * MS_PER_DAY; // 5 days, in ms
@@ -9983,6 +9994,12 @@ public class DevicePolicyManagerService extends BaseIDevicePolicyManager {
         }
         Objects.requireNonNull(admin, ""admin is null"");
         Objects.requireNonNull(agent, ""agent is null"");
+        enforceMaxPackageNameLength(agent.getPackageName());
+        final String agentAsString = agent.flattenToString();
+        enforceMaxStringLength(agentAsString, ""agent name"");
+        if (args != null) {
+            enforceMaxStringLength(args, ""args"");
+        }
         final int userHandle = UserHandle.getCallingUserId();
         synchronized (getLockObject()) {
             ActiveAdmin ap = getActiveAdminForCallerLocked(admin,
@@ -10221,6 +10238,10 @@ public class DevicePolicyManagerService extends BaseIDevicePolicyManager {
         final CallerIdentity caller = getCallerIdentity(who);
 
         if (packageList != null) {
+            for (String pkg : (List<String>) packageList) {
+                enforceMaxPackageNameLength(pkg);
+            }
+
             int userId = caller.getUserId();
             final List<AccessibilityServiceInfo> enabledServices;
             long id = mInjector.binderClearCallingIdentity();
@@ -10387,6 +10408,10 @@ public class DevicePolicyManagerService extends BaseIDevicePolicyManager {
         }
 
         if (packageList != null) {
+            for (String pkg : (List<String>) packageList) {
+                enforceMaxPackageNameLength(pkg);
+            }
+
             List<InputMethodInfo> enabledImes = mInjector.binderWithCleanCallingIdentity(() ->
                     InputMethodManagerInternal.get().getEnabledInputMethodListAsUser(userId));
             if (enabledImes != null) {
@@ -11706,6 +11731,8 @@ public class DevicePolicyManagerService extends BaseIDevicePolicyManager {
             return;
         }
         Objects.requireNonNull(who, ""ComponentName is null"");
+        enforceMaxStringLength(accountType, ""account type"");
+
         final CallerIdentity caller = getCallerIdentity(who);
         synchronized (getLockObject()) {
             /*
@@ -12124,6 +12151,10 @@ public class DevicePolicyManagerService extends BaseIDevicePolicyManager {
             throws SecurityException {
         Objects.requireNonNull(who, ""ComponentName is null"");
         Objects.requireNonNull(packages, ""packages is null"");
+        for (String pkg : packages) {
+            enforceMaxPackageNameLength(pkg);
+        }
+
         final CallerIdentity caller = getCallerIdentity(who);
 
         synchronized (getLockObject()) {
@@ -14174,6 +14205,8 @@ public class DevicePolicyManagerService extends BaseIDevicePolicyManager {
             return;
         }
         Objects.requireNonNull(who, ""ComponentName is null"");
+        message = truncateIfLonger(message, MAX_SHORT_SUPPORT_MESSAGE_LENGTH);
+
         final CallerIdentity caller = getCallerIdentity(who);
         synchronized (getLockObject()) {
             ActiveAdmin admin = getActiveAdminForUidLocked(who, caller.getUid());
@@ -14206,6 +14239,9 @@ public class DevicePolicyManagerService extends BaseIDevicePolicyManager {
         if (!mHasFeature) {
             return;
         }
+
+        message = truncateIfLonger(message, MAX_LONG_SUPPORT_MESSAGE_LENGTH);
+
         Objects.requireNonNull(who, ""ComponentName is null"");
         final CallerIdentity caller = getCallerIdentity(who);
         synchronized (getLockObject()) {
@@ -14355,6 +14391,8 @@ public class DevicePolicyManagerService extends BaseIDevicePolicyManager {
         Objects.requireNonNull(who, ""ComponentName is null"");
         final CallerIdentity caller = getCallerIdentity(who);
 
+        text = truncateIfLonger(text, MAX_ORG_NAME_LENGTH);
+
         synchronized (getLockObject()) {
             ActiveAdmin admin = getProfileOwnerOrDeviceOwnerLocked(caller);
             if (!TextUtils.equals(admin.organizationName, text)) {
@@ -14604,9 +14642,8 @@ public class DevicePolicyManagerService extends BaseIDevicePolicyManager {
             throw new IllegalArgumentException(""ids must not be null"");
         }
         for (String id : ids) {
-            if (TextUtils.isEmpty(id)) {
-                throw new IllegalArgumentException(""ids must not contain empty string"");
-            }
+            Preconditions.checkArgument(!TextUtils.isEmpty(id), ""ids must not have empty string"");
+            enforceMaxStringLength(id, ""affiliation id"");
         }
 
         final Set<String> affiliationIds = new ArraySet<>(ids);
@@ -15889,6 +15926,9 @@ public class DevicePolicyManagerService extends BaseIDevicePolicyManager {
                 ""Provided administrator and target are the same object."");
         Preconditions.checkArgument(!admin.getPackageName().equals(target.getPackageName()),
                 ""Provided administrator and target have the same package name."");
+        if (bundle != null) {
+            enforceMaxStringLength(bundle, ""bundle"");
+        }
 
         final CallerIdentity caller = getCallerIdentity(admin);
         Preconditions.checkCallAuthorization(isDeviceOwner(caller) || isProfileOwner(caller));
@@ -17998,4 +18038,51 @@ public class DevicePolicyManagerService extends BaseIDevicePolicyManager {
                         && mInjector.getUsbManager().getUsbHalVersion() >= UsbManager.USB_HAL_V1_3
         );
     }
+
+    /**
+     * Truncates char sequence to maximum length, nulls are ignored.
+     */
+    private static CharSequence truncateIfLonger(CharSequence input, int maxLength) {
+        return input == null || input.length() <= maxLength
+                ? input
+                : input.subSequence(0, maxLength);
+    }
+
+    /**
+     * Throw if string argument is too long to be serialized.
+     */
+    private static void enforceMaxStringLength(String str, String argName) {
+        Preconditions.checkArgument(
+                str.length() <= MAX_POLICY_STRING_LENGTH, argName + "" loo long"");
+    }
+
+    private static void enforceMaxPackageNameLength(String pkg) {
+        Preconditions.checkArgument(
+                pkg.length() <= MAX_PACKAGE_NAME_LENGTH, ""Package name too long"");
+    }
+
+    /**
+     * Throw if persistable bundle contains any string that we can't serialize.
+     */
+    private static void enforceMaxStringLength(PersistableBundle bundle, String argName) {
+        // Persistable bundles can have other persistable bundles as values, traverse with a queue.
+        Queue<PersistableBundle> queue = new ArrayDeque<>();
+        queue.add(bundle);
+        while (!queue.isEmpty()) {
+            PersistableBundle current = queue.remove();
+            for (String key : current.keySet()) {
+                enforceMaxStringLength(key, ""key in "" + argName);
+                Object value = current.get(key);
+                if (value instanceof String) {
+                    enforceMaxStringLength((String) value, ""string value in "" + argName);
+                } else if (value instanceof String[]) {
+                    for (String str : (String[]) value) {
+                        enforceMaxStringLength(str, ""string value in "" + argName);
+                    }
+                } else if (value instanceof PersistableBundle) {
+                    queue.add((PersistableBundle) value);
+                }
+            }
+        }
+    }
 }
",90,3,"DevicePolicyManagerService::setPermittedAccessibilityServices, DevicePolicyManagerService::setAffiliationIds, DevicePolicyManagerService::enforceMaxStringLength, DevicePolicyManagerService::setTrustAgentConfiguration, DevicePolicyManagerService::setLockTaskPackages, DevicePolicyManagerService::transferOwnership, DevicePolicyManagerService::truncateIfLonger, DevicePolicyManagerService::enforceMaxPackageNameLength, DevicePolicyManagerService::setOrganizationName, DevicePolicyManagerService::setAccountManagementDisabled, DevicePolicyManagerService::setShortSupportMessage, DevicePolicyManagerService::setLongSupportMessage, DevicePolicyManagerService::setPermittedInputMethods, DevicePolicyManagerService::enforceMaxStringLength"
326,68d20cfadb029f339a80634271fd2a2da5557adb,KeyguardViewMediator.java,"@@ -677,6 +677,13 @@ public class KeyguardViewMediator extends SystemUI implements Dumpable,
                 }
             }
         }
+
+        @Override
+        public void onStrongAuthStateChanged(int userId) {
+            if (mLockPatternUtils.isUserInLockdown(KeyguardUpdateMonitor.getCurrentUser())) {
+                doKeyguardLocked(null);
+            }
+        }
     };
 
     ViewMediatorCallback mViewMediatorCallback = new ViewMediatorCallback() {
@@ -1535,7 +1542,8 @@ public class KeyguardViewMediator extends SystemUI implements Dumpable,
         }
 
         // if another app is disabling us, don't show
-        if (!mExternallyEnabled) {
+        if (!mExternallyEnabled
+            && !mLockPatternUtils.isUserInLockdown(KeyguardUpdateMonitor.getCurrentUser())) {
             if (DEBUG) Log.d(TAG, ""doKeyguard: not showing because externally disabled"");
 
             mNeedToReshowWhenReenabled = true;
",9,1,"KeyguardViewMediator::doKeyguardLocked, KeyguardViewMediator::KeyguardUpdateMonitorCallback"
327,a8ec22f965959cb1f8c76fa5ea9c0edf73ccc003,PermissionManagerService.java,"@@ -2882,29 +2882,55 @@ public class PermissionManagerService extends IPermissionManager.Stub {
                                 + pkg.getPackageName());
                     }
 
-                    if ((bp.isNormal() && shouldGrantNormalPermission)
-                            || (bp.isSignature()
-                                    && (!bp.isPrivileged() || CollectionUtils.contains(
-                                            isPrivilegedPermissionAllowlisted, permName))
-                                    && (CollectionUtils.contains(shouldGrantSignaturePermission,
-                                            permName)
-                                            || (((bp.isPrivileged() && CollectionUtils.contains(
-                                                    shouldGrantPrivilegedPermissionIfWasGranted,
-                                                    permName)) || bp.isDevelopment() || bp.isRole())
-                                                    && origState.isPermissionGranted(permName))))
-                            || (bp.isInternal()
-                                    && (!bp.isPrivileged() || CollectionUtils.contains(
-                                            isPrivilegedPermissionAllowlisted, permName))
-                                    && (CollectionUtils.contains(shouldGrantInternalPermission,
-                                            permName)
-                                            || (((bp.isPrivileged() && CollectionUtils.contains(
-                                                    shouldGrantPrivilegedPermissionIfWasGranted,
-                                                    permName)) || bp.isDevelopment() || bp.isRole())
-                                                    && origState.isPermissionGranted(permName))))) {
-                        // Grant an install permission.
-                        if (uidState.grantPermission(bp)) {
-                            changedInstallPermission = true;
+                    if (bp.isNormal() || bp.isSignature() || bp.isInternal()) {
+                        if ((bp.isNormal() && shouldGrantNormalPermission)
+                                || (bp.isSignature()
+                                        && (!bp.isPrivileged() || CollectionUtils.contains(
+                                                isPrivilegedPermissionAllowlisted, permName))
+                                        && (CollectionUtils.contains(shouldGrantSignaturePermission,
+                                                permName)
+                                                || (((bp.isPrivileged() && CollectionUtils.contains(
+                                                        shouldGrantPrivilegedPermissionIfWasGranted,
+                                                        permName)) || bp.isDevelopment()
+                                                                || bp.isRole())
+                                                        && origState.isPermissionGranted(
+                                                                permName))))
+                                || (bp.isInternal()
+                                        && (!bp.isPrivileged() || CollectionUtils.contains(
+                                                isPrivilegedPermissionAllowlisted, permName))
+                                        && (CollectionUtils.contains(shouldGrantInternalPermission,
+                                                permName)
+                                                || (((bp.isPrivileged() && CollectionUtils.contains(
+                                                        shouldGrantPrivilegedPermissionIfWasGranted,
+                                                        permName)) || bp.isDevelopment()
+                                                                || bp.isRole())
+                                                        && origState.isPermissionGranted(
+                                                                permName))))) {
+                            // Grant an install permission.
+                            if (uidState.grantPermission(bp)) {
+                                changedInstallPermission = true;
+                            }
+                        } else {
+                            if (DEBUG_PERMISSIONS) {
+                                boolean wasGranted = uidState.isPermissionGranted(bp.getName());
+                                if (wasGranted || bp.isAppOp()) {
+                                    Slog.i(TAG, (wasGranted ? ""Un-granting"" : ""Not granting"")
+                                            + "" permission "" + perm
+                                            + "" from package "" + friendlyName
+                                            + "" (protectionLevel="" + bp.getProtectionLevel()
+                                            + "" flags=0x""
+                                            + Integer.toHexString(PackageInfoUtils.appInfoFlags(pkg,
+                                            ps))
+                                            + "")"");
+                                }
+                            }
+                            if (uidState.revokePermission(bp)) {
+                                changedInstallPermission = true;
+                            }
                         }
+                        PermissionState origPermState = origState.getPermissionState(perm);
+                        int flags = origPermState != null ? origPermState.getFlags() : 0;
+                        uidState.updatePermissionFlags(bp, MASK_PERMISSION_FLAGS_ALL, flags);
                     } else if (bp.isRuntime()) {
                         boolean hardRestricted = bp.isHardRestricted();
                         boolean softRestricted = bp.isSoftRestricted();
@@ -3018,22 +3044,8 @@ public class PermissionManagerService extends IPermissionManager.Stub {
                         uidState.updatePermissionFlags(bp, MASK_PERMISSION_FLAGS_ALL,
                                 flags);
                     } else {
-                        if (DEBUG_PERMISSIONS) {
-                            boolean wasGranted = uidState.isPermissionGranted(bp.getName());
-                            if (wasGranted || bp.isAppOp()) {
-                                Slog.i(TAG, (wasGranted ? ""Un-granting"" : ""Not granting"")
-                                        + "" permission "" + perm
-                                        + "" from package "" + friendlyName
-                                        + "" (protectionLevel="" + bp.getProtectionLevel()
-                                        + "" flags=0x""
-                                        + Integer.toHexString(PackageInfoUtils.appInfoFlags(pkg,
-                                                ps))
-                                        + "")"");
-                            }
-                        }
-                        if (uidState.removePermissionState(bp.getName())) {
-                            changedInstallPermission = true;
-                        }
+                        Slog.wtf(LOG_TAG, ""Unknown permission protection "" + bp.getProtection()
+                                + "" for permission "" + bp.getName());
                     }
                 }
 
",50,38,PermissionManagerService::restorePermissionState
328,147730e4612628fa05de5d9099bb802a2ca29591,Notification.java,"@@ -2761,6 +2761,10 @@ public class Notification implements Parcelable
      * @hide
      */
     public void visitUris(@NonNull Consumer<Uri> visitor) {
+        if (publicVersion != null) {
+            publicVersion.visitUris(visitor);
+        }
+
         visitor.accept(sound);
 
         if (tickerView != null) tickerView.visitUris(visitor);
",4,0,Notification::visitUris
329,147730e4612628fa05de5d9099bb802a2ca29591,NotificationManagerServiceTest.java,"@@ -4500,6 +4500,26 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {
         verify(visitor, times(1)).accept(eq(historyUri2));
     }
 
+    @Test
+    public void testVisitUris_publicVersion() throws Exception {
+        final Icon smallIconPublic = Icon.createWithContentUri(""content://media/small/icon"");
+        final Icon largeIconPrivate = Icon.createWithContentUri(""content://media/large/icon"");
+
+        Notification publicVersion = new Notification.Builder(mContext, ""a"")
+                .setContentTitle(""notification with uris"")
+                .setSmallIcon(smallIconPublic)
+                .build();
+        Notification n = new Notification.Builder(mContext, ""a"")
+                .setLargeIcon(largeIconPrivate)
+                .setPublicVersion(publicVersion)
+                .build();
+
+        Consumer<Uri> visitor = (Consumer<Uri>) spy(Consumer.class);
+        n.visitUris(visitor);
+        verify(visitor, times(1)).accept(eq(smallIconPublic.getUri()));
+        verify(visitor, times(1)).accept(eq(largeIconPrivate.getUri()));
+    }
+
     @Test
     public void testVisitUris_audioContentsString() throws Exception {
         final Uri audioContents = Uri.parse(""content://com.example/audio"");
",20,0,NotificationManagerServiceTest::testVisitUris_publicVersion
330,2861dab20a619329f4c391cc0fac0d2ba24cd724,RemoteViews.java,"@@ -2560,6 +2560,11 @@ public class RemoteViews implements Parcelable, Filter {
         public int getActionTag() {
             return VIEW_GROUP_ACTION_ADD_TAG;
         }
+
+        @Override
+        public final void visitUris(@NonNull Consumer<Uri> visitor) {
+            mNestedViews.visitUris(visitor);
+        }
     }
 
     /**
",5,0,RemoteViews::ViewGroupActionAdd::visitUris
331,2861dab20a619329f4c391cc0fac0d2ba24cd724,RemoteViewsTest.java,"@@ -528,6 +528,30 @@ public class RemoteViewsTest {
         verify(visitor, times(1)).accept(eq(icon4.getUri()));
     }
 
+    @Test
+    public void visitUris_nestedViews() {
+        final RemoteViews outer = new RemoteViews(mPackage, R.layout.remote_views_test);
+
+        final RemoteViews inner = new RemoteViews(mPackage, 33);
+        final Uri imageUriI = Uri.parse(""content://inner/image"");
+        final Icon icon1 = Icon.createWithContentUri(""content://inner/icon1"");
+        final Icon icon2 = Icon.createWithContentUri(""content://inner/icon2"");
+        final Icon icon3 = Icon.createWithContentUri(""content://inner/icon3"");
+        final Icon icon4 = Icon.createWithContentUri(""content://inner/icon4"");
+        inner.setImageViewUri(R.id.image, imageUriI);
+        inner.setTextViewCompoundDrawables(R.id.text, icon1, icon2, icon3, icon4);
+
+        outer.addView(R.id.layout, inner);
+
+        Consumer<Uri> visitor = (Consumer<Uri>) spy(Consumer.class);
+        outer.visitUris(visitor);
+        verify(visitor, times(1)).accept(eq(imageUriI));
+        verify(visitor, times(1)).accept(eq(icon1.getUri()));
+        verify(visitor, times(1)).accept(eq(icon2.getUri()));
+        verify(visitor, times(1)).accept(eq(icon3.getUri()));
+        verify(visitor, times(1)).accept(eq(icon4.getUri()));
+    }
+
     @Test
     public void visitUris_separateOrientation() {
         final RemoteViews landscape = new RemoteViews(mPackage, R.layout.remote_views_test);
",24,0,RemoteViewsTest::visitUris_nestedViews
332,b48846957a0a716c7d5696ba389f728b2e874f11,MediaSession.java,"@@ -297,9 +297,11 @@ public final class MediaSession {
      * class that should receive media buttons. This allows restarting playback after the session
      * has been stopped. If your app is started in this way an {@link Intent#ACTION_MEDIA_BUTTON}
      * intent will be sent to the broadcast receiver.
-     * <p>
-     * Note: The given {@link android.content.BroadcastReceiver} should belong to the same package
-     * as the context that was given when creating {@link MediaSession}.
+     *
+     * <p>Note: The given {@link android.content.BroadcastReceiver} should belong to the same
+     * package as the context that was given when creating {@link MediaSession}.
+     *
+     * <p>Calls with invalid or non-existent receivers will be ignored.
      *
      * @param broadcastReceiver the component name of the BroadcastReceiver class
      */
",5,3,
333,b48846957a0a716c7d5696ba389f728b2e874f11,MediaSessionRecord.java,"@@ -16,12 +16,17 @@
 
 package com.android.server.media;
 
+import android.Manifest;
+import android.annotation.NonNull;
 import android.annotation.Nullable;
+import android.annotation.RequiresPermission;
 import android.app.PendingIntent;
 import android.content.ComponentName;
 import android.content.Context;
 import android.content.Intent;
+import android.content.pm.PackageManager;
 import android.content.pm.ParceledListSlice;
+import android.content.pm.ResolveInfo;
 import android.media.AudioAttributes;
 import android.media.AudioManager;
 import android.media.AudioSystem;
@@ -52,6 +57,7 @@ import android.os.Process;
 import android.os.RemoteException;
 import android.os.ResultReceiver;
 import android.os.SystemClock;
+import android.os.UserHandle;
 import android.text.TextUtils;
 import android.util.EventLog;
 import android.util.Log;
@@ -879,6 +885,22 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR
         }
     };
 
+    @RequiresPermission(Manifest.permission.INTERACT_ACROSS_USERS)
+    private static boolean componentNameExists(
+            @NonNull ComponentName componentName, @NonNull Context context, int userId) {
+        Intent mediaButtonIntent = new Intent(Intent.ACTION_MEDIA_BUTTON);
+        mediaButtonIntent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
+        mediaButtonIntent.setComponent(componentName);
+
+        UserHandle userHandle = UserHandle.of(userId);
+        PackageManager pm = context.getPackageManager();
+
+        List<ResolveInfo> resolveInfos =
+                pm.queryBroadcastReceiversAsUser(
+                        mediaButtonIntent, /* flags */ 0, userHandle);
+        return !resolveInfos.isEmpty();
+    }
+
     private final class SessionStub extends ISession.Stub {
         @Override
         public void destroySession() throws RemoteException {
@@ -949,6 +971,7 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR
         }
 
         @Override
+        @RequiresPermission(Manifest.permission.INTERACT_ACROSS_USERS)
         public void setMediaButtonBroadcastReceiver(ComponentName receiver) throws RemoteException {
             final long token = Binder.clearCallingIdentity();
             try {
@@ -964,6 +987,16 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR
                         != 0) {
                     return;
                 }
+
+                if (!componentNameExists(receiver, mContext, mUserId)) {
+                    Log.w(
+                            TAG,
+                            ""setMediaButtonBroadcastReceiver(): ""
+                                    + ""Ignoring invalid component name=""
+                                    + receiver);
+                    return;
+                }
+
                 mMediaButtonReceiverHolder = MediaButtonReceiverHolder.create(mUserId, receiver);
                 mService.onMediaButtonReceiverChanged(MediaSessionRecord.this);
             } finally {
",33,0,"MediaSessionRecord::SessionStub::setMediaButtonBroadcastReceiver, MediaSessionRecord::componentNameExists"
334,26c9cf7140ef6b8782a0b08fa331fbefe7ce6858,RemoteViews.java,"@@ -709,6 +709,11 @@ public class RemoteViews implements Parcelable, Filter {
                 mActions.get(i).visitUris(visitor);
             }
         }
+        if (mSizedRemoteViews != null) {
+            for (int i = 0; i < mSizedRemoteViews.size(); i++) {
+                mSizedRemoteViews.get(i).visitUris(visitor);
+            }
+        }
         if (mLandscape != null) {
             mLandscape.visitUris(visitor);
         }
",5,0,RemoteViews::visitUris
335,26c9cf7140ef6b8782a0b08fa331fbefe7ce6858,RemoteViewsTest.java,"@@ -38,6 +38,7 @@ import android.net.Uri;
 import android.os.AsyncTask;
 import android.os.Binder;
 import android.os.Parcel;
+import android.util.SizeF;
 import android.view.View;
 import android.view.ViewGroup;
 
@@ -55,6 +56,7 @@ import org.junit.runner.RunWith;
 
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.HashMap;
 import java.util.concurrent.CountDownLatch;
 import java.util.function.Consumer;
 
@@ -587,4 +589,43 @@ public class RemoteViewsTest {
         verify(visitor, times(1)).accept(eq(icon3P.getUri()));
         verify(visitor, times(1)).accept(eq(icon4P.getUri()));
     }
+
+    @Test
+    public void visitUris_sizedViews() {
+        final RemoteViews large = new RemoteViews(mPackage, R.layout.remote_views_test);
+        final Uri imageUriL = Uri.parse(""content://large/image"");
+        final Icon icon1L = Icon.createWithContentUri(""content://large/icon1"");
+        final Icon icon2L = Icon.createWithContentUri(""content://large/icon2"");
+        final Icon icon3L = Icon.createWithContentUri(""content://large/icon3"");
+        final Icon icon4L = Icon.createWithContentUri(""content://large/icon4"");
+        large.setImageViewUri(R.id.image, imageUriL);
+        large.setTextViewCompoundDrawables(R.id.text, icon1L, icon2L, icon3L, icon4L);
+
+        final RemoteViews small = new RemoteViews(mPackage, 33);
+        final Uri imageUriS = Uri.parse(""content://small/image"");
+        final Icon icon1S = Icon.createWithContentUri(""content://small/icon1"");
+        final Icon icon2S = Icon.createWithContentUri(""content://small/icon2"");
+        final Icon icon3S = Icon.createWithContentUri(""content://small/icon3"");
+        final Icon icon4S = Icon.createWithContentUri(""content://small/icon4"");
+        small.setImageViewUri(R.id.image, imageUriS);
+        small.setTextViewCompoundDrawables(R.id.text, icon1S, icon2S, icon3S, icon4S);
+
+        HashMap<SizeF, RemoteViews> sizedViews = new HashMap<>();
+        sizedViews.put(new SizeF(300, 300), large);
+        sizedViews.put(new SizeF(100, 100), small);
+        RemoteViews views = new RemoteViews(sizedViews);
+
+        Consumer<Uri> visitor = (Consumer<Uri>) spy(Consumer.class);
+        views.visitUris(visitor);
+        verify(visitor, times(1)).accept(eq(imageUriL));
+        verify(visitor, times(1)).accept(eq(icon1L.getUri()));
+        verify(visitor, times(1)).accept(eq(icon2L.getUri()));
+        verify(visitor, times(1)).accept(eq(icon3L.getUri()));
+        verify(visitor, times(1)).accept(eq(icon4L.getUri()));
+        verify(visitor, times(1)).accept(eq(imageUriS));
+        verify(visitor, times(1)).accept(eq(icon1S.getUri()));
+        verify(visitor, times(1)).accept(eq(icon2S.getUri()));
+        verify(visitor, times(1)).accept(eq(icon3S.getUri()));
+        verify(visitor, times(1)).accept(eq(icon4S.getUri()));
+    }
 }
",41,0,RemoteViewsTest::visitUris_sizedViews
336,2559e77cbb043c06e358444f526281cb9434b2d6,RemoteViews.java,"@@ -1808,7 +1808,7 @@ public class RemoteViews implements Parcelable, Filter {
         }
 
         @Override
-        public final void visitUris(@NonNull Consumer<Uri> visitor) {
+        public void visitUris(@NonNull Consumer<Uri> visitor) {
             switch (this.type) {
                 case URI:
                     final Uri uri = (Uri) getParameterValue(null);
@@ -2271,6 +2271,14 @@ public class RemoteViews implements Parcelable, Filter {
         public int getActionTag() {
             return NIGHT_MODE_REFLECTION_ACTION_TAG;
         }
+
+        @Override
+        public void visitUris(@NonNull Consumer<Uri> visitor) {
+            if (this.type == ICON) {
+                visitIconUri((Icon) mDarkValue, visitor);
+                visitIconUri((Icon) mLightValue, visitor);
+            }
+        }
     }
 
     /**
",9,1,"RemoteViews::BaseReflectionAction::visitUris, RemoteViews::NightModeReflectionAction::visitUris"
337,2559e77cbb043c06e358444f526281cb9434b2d6,RemoteViewsTest.java,"@@ -530,6 +530,19 @@ public class RemoteViewsTest {
         verify(visitor, times(1)).accept(eq(icon4.getUri()));
     }
 
+    @Test
+    public void visitUris_themedIcons() {
+        RemoteViews views = new RemoteViews(mPackage, R.layout.remote_views_test);
+        final Icon iconLight = Icon.createWithContentUri(""content://light/icon"");
+        final Icon iconDark = Icon.createWithContentUri(""content://dark/icon"");
+        views.setIcon(R.id.layout, ""setLargeIcon"", iconLight, iconDark);
+
+        Consumer<Uri> visitor = (Consumer<Uri>) spy(Consumer.class);
+        views.visitUris(visitor);
+        verify(visitor, times(1)).accept(eq(iconLight.getUri()));
+        verify(visitor, times(1)).accept(eq(iconDark.getUri()));
+    }
+
     @Test
     public void visitUris_nestedViews() {
         final RemoteViews outer = new RemoteViews(mPackage, R.layout.remote_views_test);
",13,0,RemoteViewsTest::visitUris_themedIcons
338,eee49f9cb80a37b3c2f70375cd1de64e32e2f86f,KeyguardViewMediator.java,"@@ -1145,9 +1145,9 @@ public class KeyguardViewMediator extends SystemUI implements Dumpable,
         final ContentResolver cr = mContext.getContentResolver();
 
         // From SecuritySettings
-        final long lockAfterTimeout = Settings.Secure.getInt(cr,
+        final long lockAfterTimeout = Settings.Secure.getIntForUser(cr,
                 Settings.Secure.LOCK_SCREEN_LOCK_AFTER_TIMEOUT,
-                KEYGUARD_LOCK_AFTER_DELAY_DEFAULT);
+                KEYGUARD_LOCK_AFTER_DELAY_DEFAULT, userId);
 
         // From DevicePolicyAdmin
         final long policyTimeout = mLockPatternUtils.getDevicePolicyManager()
@@ -1159,8 +1159,8 @@ public class KeyguardViewMediator extends SystemUI implements Dumpable,
             timeout = lockAfterTimeout;
         } else {
             // From DisplaySettings
-            long displayTimeout = Settings.System.getInt(cr, SCREEN_OFF_TIMEOUT,
-                    KEYGUARD_DISPLAY_TIMEOUT_DELAY_DEFAULT);
+            long displayTimeout = Settings.System.getIntForUser(cr, SCREEN_OFF_TIMEOUT,
+                    KEYGUARD_DISPLAY_TIMEOUT_DELAY_DEFAULT, userId);
 
             // policy in effect. Make sure we don't go beyond policy limit.
             displayTimeout = Math.max(displayTimeout, 0); // ignore negative values
@@ -2033,7 +2033,10 @@ public class KeyguardViewMediator extends SystemUI implements Dumpable,
     private void playSound(int soundId) {
         if (soundId == 0) return;
         final ContentResolver cr = mContext.getContentResolver();
-        if (Settings.System.getInt(cr, Settings.System.LOCKSCREEN_SOUNDS_ENABLED, 1) == 1) {
+        int lockscreenSoundsEnabled = Settings.System.getIntForUser(cr,
+                Settings.System.LOCKSCREEN_SOUNDS_ENABLED, 1,
+                KeyguardUpdateMonitor.getCurrentUser());
+        if (lockscreenSoundsEnabled == 1) {
 
             mLockSounds.stop(mLockSoundStreamId);
             // Init mAudioManager
",8,5,"KeyguardViewMediator::getLockTimeout, KeyguardViewMediator::playSound"
339,0e3a03142bcdade071c3997b1cb7be93678c1b42,MediaSessionRecord.java,"@@ -22,6 +22,8 @@ import android.annotation.Nullable;
 import android.annotation.RequiresPermission;
 import android.app.PendingIntent;
 import android.content.ComponentName;
+import android.content.ContentProvider;
+import android.content.ContentResolver;
 import android.content.Context;
 import android.content.Intent;
 import android.content.pm.PackageManager;
@@ -63,6 +65,9 @@ import android.util.EventLog;
 import android.util.Log;
 import android.view.KeyEvent;
 
+import com.android.server.LocalServices;
+import com.android.server.uri.UriGrantsManagerInternal;
+
 import java.io.PrintWriter;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -77,6 +82,10 @@ import java.util.concurrent.CopyOnWriteArrayList;
 // TODO(jaewan): Do not call service method directly -- introduce listener instead.
 public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionRecordImpl {
     private static final String TAG = ""MediaSessionRecord"";
+    private static final String[] ART_URIS = new String[] {
+            MediaMetadata.METADATA_KEY_ALBUM_ART_URI,
+            MediaMetadata.METADATA_KEY_ART_URI,
+            MediaMetadata.METADATA_KEY_DISPLAY_ICON_URI};
     private static final boolean DEBUG = Log.isLoggable(TAG, Log.DEBUG);
 
     /**
@@ -130,6 +139,7 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR
     private final SessionStub mSession;
     private final SessionCb mSessionCb;
     private final MediaSessionService mService;
+    private final UriGrantsManagerInternal mUgmInternal;
     private final Context mContext;
     private final boolean mVolumeAdjustmentForRemoteGroupSessions;
 
@@ -193,6 +203,7 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR
         mPolicies = policies;
         mVolumeAdjustmentForRemoteGroupSessions = mContext.getResources().getBoolean(
                 com.android.internal.R.bool.config_volumeAdjustmentForRemoteGroupSessions);
+        mUgmInternal = LocalServices.getService(UriGrantsManagerInternal.class);
 
         // May throw RemoteException if the session app is killed.
         mSessionCb.mCb.asBinder().linkToDeath(this, 0);
@@ -1013,21 +1024,45 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR
         public void setMetadata(MediaMetadata metadata, long duration, String metadataDescription)
                 throws RemoteException {
             synchronized (mLock) {
-                MediaMetadata temp = metadata == null ? null : new MediaMetadata.Builder(metadata)
-                        .build();
-                // This is to guarantee that the underlying bundle is unparceled
-                // before we set it to prevent concurrent reads from throwing an
-                // exception
-                if (temp != null) {
-                    temp.size();
-                }
-                mMetadata = temp;
                 mDuration = duration;
                 mMetadataDescription = metadataDescription;
+                mMetadata = sanitizeMediaMetadata(metadata);
             }
             mHandler.post(MessageHandler.MSG_UPDATE_METADATA);
         }
 
+        private MediaMetadata sanitizeMediaMetadata(MediaMetadata metadata) {
+            if (metadata == null) {
+                return null;
+            }
+            MediaMetadata.Builder metadataBuilder = new MediaMetadata.Builder(metadata);
+            for (String key: ART_URIS) {
+                String uriString = metadata.getString(key);
+                if (TextUtils.isEmpty(uriString)) {
+                    continue;
+                }
+                Uri uri = Uri.parse(uriString);
+                if (!ContentResolver.SCHEME_CONTENT.equals(uri.getScheme())) {
+                    continue;
+                }
+                try {
+                    mUgmInternal.checkGrantUriPermission(getUid(),
+                            getPackageName(),
+                            ContentProvider.getUriWithoutUserId(uri),
+                            Intent.FLAG_GRANT_READ_URI_PERMISSION,
+                            ContentProvider.getUserIdFromUri(uri, getUserId()));
+                } catch (SecurityException e) {
+                    metadataBuilder.putString(key, null);
+                }
+            }
+            MediaMetadata sanitizedMetadata = metadataBuilder.build();
+            // sanitizedMetadata.size() guarantees that the underlying bundle is unparceled
+            // before we set it to prevent concurrent reads from throwing an
+            // exception
+            sanitizedMetadata.size();
+            return sanitizedMetadata;
+        }
+
         @Override
         public void setPlaybackState(PlaybackState state) throws RemoteException {
             int oldState = mPlaybackState == null
",44,9,"MediaSessionRecord::MediaSessionRecord, MediaSessionRecord::SessionStub::sanitizeMediaMetadata, MediaSessionRecord::SessionStub::setMetadata"
340,0101ae8a47ff484d43af3dde506d19cde4590f65,ParcelableConference.java,"@@ -21,12 +21,12 @@ import android.os.Bundle;
 import android.os.Parcel;
 import android.os.Parcelable;
 
+import com.android.internal.telecom.IVideoProvider;
+
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 
-import com.android.internal.telecom.IVideoProvider;
-
 /**
  * A parcelable representation of a conference connection.
  * @hide
@@ -287,6 +287,14 @@ public final class ParcelableConference implements Parcelable {
         return mCallDirection;
     }
 
+    public String getCallerDisplayName() {
+        return mCallerDisplayName;
+    }
+
+    public int getCallerDisplayNamePresentation() {
+        return mCallerDisplayNamePresentation;
+    }
+
     public static final @android.annotation.NonNull Parcelable.Creator<ParcelableConference> CREATOR =
             new Parcelable.Creator<ParcelableConference> () {
         @Override
",10,2,"ParcelableConference::getCallerDisplayName, ParcelableConference::getCallerDisplayNamePresentation"
341,0101ae8a47ff484d43af3dde506d19cde4590f65,StatusHints.java,"@@ -16,14 +16,19 @@
 
 package android.telecom;
 
+import android.annotation.Nullable;
 import android.annotation.SystemApi;
 import android.content.ComponentName;
 import android.content.Context;
 import android.graphics.drawable.Drawable;
 import android.graphics.drawable.Icon;
+import android.os.Binder;
 import android.os.Bundle;
 import android.os.Parcel;
 import android.os.Parcelable;
+import android.os.UserHandle;
+
+import com.android.internal.annotations.VisibleForTesting;
 
 import java.util.Objects;
 
@@ -33,7 +38,7 @@ import java.util.Objects;
 public final class StatusHints implements Parcelable {
 
     private final CharSequence mLabel;
-    private final Icon mIcon;
+    private Icon mIcon;
     private final Bundle mExtras;
 
     /**
@@ -48,10 +53,30 @@ public final class StatusHints implements Parcelable {
 
     public StatusHints(CharSequence label, Icon icon, Bundle extras) {
         mLabel = label;
-        mIcon = icon;
+        mIcon = validateAccountIconUserBoundary(icon, Binder.getCallingUserHandle());
         mExtras = extras;
     }
 
+    /**
+     * @param icon
+     * @hide
+     */
+    @VisibleForTesting
+    public StatusHints(@Nullable Icon icon) {
+        mLabel = null;
+        mExtras = null;
+        mIcon = icon;
+    }
+
+    /**
+     *
+     * @param icon
+     * @hide
+     */
+    public void setIcon(@Nullable Icon icon) {
+        mIcon = icon;
+    }
+
     /**
      * @return A package used to load the icon.
      *
@@ -112,6 +137,30 @@ public final class StatusHints implements Parcelable {
         return 0;
     }
 
+    /**
+     * Validates the StatusHints image icon to see if it's not in the calling user space.
+     * Invalidates the icon if so, otherwise returns back the original icon.
+     *
+     * @param icon
+     * @return icon (validated)
+     * @hide
+     */
+    public static Icon validateAccountIconUserBoundary(Icon icon, UserHandle callingUserHandle) {
+        // Refer to Icon#getUriString for context. The URI string is invalid for icons of
+        // incompatible types.
+        if (icon != null && (icon.getType() == Icon.TYPE_URI
+                || icon.getType() == Icon.TYPE_URI_ADAPTIVE_BITMAP)) {
+            String encodedUser = icon.getUri().getEncodedUserInfo();
+            // If there is no encoded user, the URI is calling into the calling user space
+            if (encodedUser != null) {
+                int userId = Integer.parseInt(encodedUser);
+                // Do not try to save the icon if the user id isn't in the calling user space.
+                if (userId != callingUserHandle.getIdentifier()) return null;
+            }
+        }
+        return icon;
+    }
+
     @Override
     public void writeToParcel(Parcel out, int flags) {
         out.writeCharSequence(mLabel);
",51,2,"StatusHints::StatusHints, StatusHints::validateAccountIconUserBoundary, StatusHints::StatusHints, StatusHints::setIcon"
342,5a90c77327de244dee82de520ca602581d5341ed,Notification.java,"@@ -2811,17 +2811,6 @@ public class Notification implements Parcelable
             if (person != null) {
                 visitor.accept(person.getIconUri());
             }
-
-            final RemoteInputHistoryItem[] history = (RemoteInputHistoryItem[])
-                    extras.getParcelableArray(Notification.EXTRA_REMOTE_INPUT_HISTORY_ITEMS);
-            if (history != null) {
-                for (int i = 0; i < history.length; i++) {
-                    RemoteInputHistoryItem item = history[i];
-                    if (item.getUri() != null) {
-                        visitor.accept(item.getUri());
-                    }
-                }
-            }
         }
 
         if (isStyle(MessagingStyle.class) && extras != null) {
",0,11,Notification::visitUris
343,5a90c77327de244dee82de520ca602581d5341ed,NotificationManagerServiceTest.java,"@@ -115,7 +115,6 @@ import android.app.NotificationManager;
 import android.app.PendingIntent;
 import android.app.Person;
 import android.app.RemoteInput;
-import android.app.RemoteInputHistoryItem;
 import android.app.StatsManager;
 import android.app.admin.DevicePolicyManagerInternal;
 import android.app.usage.UsageStatsManagerInternal;
@@ -4464,12 +4463,6 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {
                 .setName(""People List Person 2"")
                 .setIcon(personIcon3)
                 .build();
-        final Uri historyUri1 = Uri.parse(""content://com.example/history1"");
-        final Uri historyUri2 = Uri.parse(""content://com.example/history2"");
-        final RemoteInputHistoryItem historyItem1 = new RemoteInputHistoryItem(null, historyUri1,
-                ""a"");
-        final RemoteInputHistoryItem historyItem2 = new RemoteInputHistoryItem(null, historyUri2,
-                ""b"");
 
         Bundle extras = new Bundle();
         extras.putParcelable(Notification.EXTRA_AUDIO_CONTENTS_URI, audioContents);
@@ -4477,8 +4470,6 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {
         extras.putParcelable(Notification.EXTRA_MESSAGING_PERSON, person1);
         extras.putParcelableArrayList(Notification.EXTRA_PEOPLE_LIST,
                 new ArrayList<>(Arrays.asList(person2, person3)));
-        extras.putParcelableArray(Notification.EXTRA_REMOTE_INPUT_HISTORY_ITEMS,
-                new RemoteInputHistoryItem[]{historyItem1, historyItem2});
 
         Notification n = new Notification.Builder(mContext, ""a"")
                 .setContentTitle(""notification with uris"")
@@ -4496,8 +4487,6 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {
         verify(visitor, times(1)).accept(eq(personIcon1.getUri()));
         verify(visitor, times(1)).accept(eq(personIcon2.getUri()));
         verify(visitor, times(1)).accept(eq(personIcon3.getUri()));
-        verify(visitor, times(1)).accept(eq(historyUri1));
-        verify(visitor, times(1)).accept(eq(historyUri2));
     }
 
     @Test
",0,11,NotificationManagerServiceTest::testVisitUris
344,7d92e02aa27e2f5aa236d568f341f960256071de,SubscriptionInfo.java,"@@ -18,6 +18,7 @@ package android.telephony;
 
 import static android.text.TextUtils.formatSimple;
 
+import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.annotation.SystemApi;
 import android.compat.annotation.UnsupportedAppUsage;
@@ -696,6 +697,15 @@ public class SubscriptionInfo implements Parcelable {
         return merged.isEmpty() ? null : merged;
     }
 
+    /**
+     * @hide
+     * @return mCarrierConfigAccessRules associated with this subscription.
+     */
+    public @NonNull List<UiccAccessRule> getCarrierConfigAccessRules() {
+        return mCarrierConfigAccessRules == null ? Collections.emptyList() :
+            Arrays.asList(mCarrierConfigAccessRules);
+    }
+
     /**
      * Returns the card string of the SIM card which contains the subscription.
      *
",10,0,SubscriptionInfo::getCarrierConfigAccessRules
345,c916dad1dfd40b0a4031fb954ada07989121f607,SaveImageInBackgroundTask.java,"@@ -89,7 +89,8 @@ class SaveImageInBackgroundTask extends AsyncTask<String, Void, Void> {
     SaveImageInBackgroundTask(Context context, ImageExporter exporter,
             ScreenshotSmartActions screenshotSmartActions,
             ScreenshotController.SaveImageInBackgroundData data,
-            Supplier<ActionTransition> sharedElementTransition) {
+            Supplier<ActionTransition> sharedElementTransition,
+            boolean smartActionsEnabled) {
         mContext = context;
         mScreenshotSmartActions = screenshotSmartActions;
         mImageData = new ScreenshotController.SavedImageData();
@@ -101,8 +102,7 @@ class SaveImageInBackgroundTask extends AsyncTask<String, Void, Void> {
         mParams = data;
 
         // Initialize screenshot notification smart actions provider.
-        mSmartActionsEnabled = DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_SYSTEMUI,
-                SystemUiDeviceConfigFlags.ENABLE_SCREENSHOT_NOTIFICATION_SMART_ACTIONS, true);
+        mSmartActionsEnabled = smartActionsEnabled;
         if (mSmartActionsEnabled) {
             mSmartActionsProvider =
                     SystemUIFactory.getInstance()
@@ -135,7 +135,12 @@ class SaveImageInBackgroundTask extends AsyncTask<String, Void, Void> {
                 // Since Quick Share target recommendation does not rely on image URL, it is
                 // queried and surfaced before image compress/export. Action intent would not be
                 // used, because it does not contain image URL.
-                queryQuickShareAction(image, user);
+                Notification.Action quickShare =
+                        queryQuickShareAction(mScreenshotId, image, user, null);
+                if (quickShare != null) {
+                    mQuickShareData.quickShareAction = quickShare;
+                    mParams.mQuickShareActionsReadyListener.onActionsReady(mQuickShareData);
+                }
             }
 
             // Call synchronously here since already on a background thread.
@@ -170,8 +175,9 @@ class SaveImageInBackgroundTask extends AsyncTask<String, Void, Void> {
             mImageData.shareTransition = createShareAction(mContext, mContext.getResources(), uri);
             mImageData.editTransition = createEditAction(mContext, mContext.getResources(), uri);
             mImageData.deleteAction = createDeleteAction(mContext, mContext.getResources(), uri);
-            mImageData.quickShareAction = createQuickShareAction(mContext,
-                    mQuickShareData.quickShareAction, uri);
+            mImageData.quickShareAction = createQuickShareAction(
+                    mQuickShareData.quickShareAction, mScreenshotId, uri, mImageTime, image,
+                    user);
 
             mParams.mActionsReadyListener.onActionsReady(mImageData);
             if (DEBUG_CALLBACK) {
@@ -454,60 +460,73 @@ class SaveImageInBackgroundTask extends AsyncTask<String, Void, Void> {
     }
 
     /**
-     * Populate image uri into intent of Quick Share action.
+     * Wrap the quickshare intent and populate the fillin intent with the URI
      */
     @VisibleForTesting
-    private Notification.Action createQuickShareAction(Context context, Notification.Action action,
-            Uri uri) {
-        if (action == null) {
+    Notification.Action createQuickShareAction(
+            Notification.Action quickShare, String screenshotId, Uri uri, long imageTime,
+            Bitmap image, UserHandle user) {
+        if (quickShare == null) {
             return null;
+        } else if (quickShare.actionIntent.isImmutable()) {
+            Notification.Action quickShareWithUri =
+                    queryQuickShareAction(screenshotId, image, user, uri);
+            if (quickShareWithUri == null
+                    || !quickShareWithUri.title.toString().contentEquals(quickShare.title)) {
+                return null;
+            }
+            quickShare = quickShareWithUri;
         }
-        // Populate image URI into Quick Share chip intent
-        Intent sharingIntent = action.actionIntent.getIntent();
-        sharingIntent.setType(""image/png"");
-        sharingIntent.putExtra(Intent.EXTRA_STREAM, uri);
-        String subjectDate = DateFormat.getDateTimeInstance().format(new Date(mImageTime));
+
+        Intent wrappedIntent = new Intent(mContext, SmartActionsReceiver.class)
+                .putExtra(ScreenshotController.EXTRA_ACTION_INTENT, quickShare.actionIntent)
+                .putExtra(ScreenshotController.EXTRA_ACTION_INTENT_FILLIN,
+                        createFillInIntent(uri, imageTime))
+                .addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
+        Bundle extras = quickShare.getExtras();
+        String actionType = extras.getString(
+                ScreenshotNotificationSmartActionsProvider.ACTION_TYPE,
+                ScreenshotNotificationSmartActionsProvider.DEFAULT_ACTION_TYPE);
+        addIntentExtras(screenshotId, wrappedIntent, actionType, mSmartActionsEnabled);
+        PendingIntent broadcastIntent =
+                PendingIntent.getBroadcast(mContext, mRandom.nextInt(), wrappedIntent,
+                        PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_IMMUTABLE);
+        return new Notification.Action.Builder(quickShare.getIcon(), quickShare.title,
+                broadcastIntent)
+                .setContextual(true)
+                .addExtras(extras)
+                .build();
+    }
+
+    private Intent createFillInIntent(Uri uri, long imageTime) {
+        Intent fillIn = new Intent();
+        fillIn.setType(""image/png"");
+        fillIn.putExtra(Intent.EXTRA_STREAM, uri);
+        String subjectDate = DateFormat.getDateTimeInstance().format(new Date(imageTime));
         String subject = String.format(SCREENSHOT_SHARE_SUBJECT_TEMPLATE, subjectDate);
-        sharingIntent.putExtra(Intent.EXTRA_SUBJECT, subject);
+        fillIn.putExtra(Intent.EXTRA_SUBJECT, subject);
         // Include URI in ClipData also, so that grantPermission picks it up.
         // We don't use setData here because some apps interpret this as ""to:"".
-        ClipData clipdata = new ClipData(new ClipDescription(""content"",
-                new String[]{""image/png""}),
+        ClipData clipData = new ClipData(
+                new ClipDescription(""content"", new String[]{""image/png""}),
                 new ClipData.Item(uri));
-        sharingIntent.setClipData(clipdata);
-        sharingIntent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
-        PendingIntent updatedPendingIntent = PendingIntent.getActivity(
-                context, 0, sharingIntent,
-                PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_IMMUTABLE);
-
-        // Proxy smart actions through {@link GlobalScreenshot.SmartActionsReceiver}
-        // for logging smart actions.
-        Bundle extras = action.getExtras();
-        String actionType = extras.getString(
-                ScreenshotNotificationSmartActionsProvider.ACTION_TYPE,
-                ScreenshotNotificationSmartActionsProvider.DEFAULT_ACTION_TYPE);
-        Intent intent = new Intent(context, SmartActionsReceiver.class)
-                .putExtra(ScreenshotController.EXTRA_ACTION_INTENT, updatedPendingIntent)
-                .addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
-        addIntentExtras(mScreenshotId, intent, actionType, mSmartActionsEnabled);
-        PendingIntent broadcastIntent = PendingIntent.getBroadcast(context,
-                mRandom.nextInt(),
-                intent,
-                PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_IMMUTABLE);
-        return new Notification.Action.Builder(action.getIcon(), action.title,
-                broadcastIntent).setContextual(true).addExtras(extras).build();
+        fillIn.setClipData(clipData);
+        fillIn.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
+        return fillIn;
     }
 
     /**
      * Query and surface Quick Share chip if it is available. Action intent would not be used,
      * because it does not contain image URL which would be populated in {@link
-     * #createQuickShareAction(Context, Notification.Action, Uri)}
+     * #createQuickShareAction(Notification.Action, String, Uri, long, Bitmap, UserHandle)}
      */
-    private void queryQuickShareAction(Bitmap image, UserHandle user) {
+
+    @VisibleForTesting
+    Notification.Action queryQuickShareAction(
+            String screenshotId, Bitmap image, UserHandle user, Uri uri) {
         CompletableFuture<List<Notification.Action>> quickShareActionsFuture =
                 mScreenshotSmartActions.getSmartActionsFuture(
-                        mScreenshotId, null, image, mSmartActionsProvider,
-                        QUICK_SHARE_ACTION,
+                        screenshotId, uri, image, mSmartActionsProvider, QUICK_SHARE_ACTION,
                         mSmartActionsEnabled, user);
         int timeoutMs = DeviceConfig.getInt(
                 DeviceConfig.NAMESPACE_SYSTEMUI,
@@ -515,11 +534,11 @@ class SaveImageInBackgroundTask extends AsyncTask<String, Void, Void> {
                 500);
         List<Notification.Action> quickShareActions =
                 mScreenshotSmartActions.getSmartActions(
-                        mScreenshotId, quickShareActionsFuture, timeoutMs,
+                        screenshotId, quickShareActionsFuture, timeoutMs,
                         mSmartActionsProvider, QUICK_SHARE_ACTION);
         if (!quickShareActions.isEmpty()) {
-            mQuickShareData.quickShareAction = quickShareActions.get(0);
-            mParams.mQuickShareActionsReadyListener.onActionsReady(mQuickShareData);
+            return quickShareActions.get(0);
         }
+        return null;
     }
 }
",66,47,"SaveImageInBackgroundTask::SaveImageInBackgroundTask, SaveImageInBackgroundTask::createQuickShareAction, SaveImageInBackgroundTask::queryQuickShareAction, SaveImageInBackgroundTask::doInBackground, SaveImageInBackgroundTask::queryQuickShareAction, SaveImageInBackgroundTask::createQuickShareAction, SaveImageInBackgroundTask::createFillInIntent, SaveImageInBackgroundTask::SaveImageInBackgroundTask"
346,c916dad1dfd40b0a4031fb954ada07989121f607,ScreenshotController.java,"@@ -62,6 +62,7 @@ import android.os.Message;
 import android.os.RemoteException;
 import android.os.VibrationEffect;
 import android.os.Vibrator;
+import android.provider.DeviceConfig;
 import android.provider.Settings;
 import android.util.DisplayMetrics;
 import android.util.Log;
@@ -88,6 +89,7 @@ import android.widget.Toast;
 import android.window.WindowContext;
 
 import com.android.internal.app.ChooserActivity;
+import com.android.internal.config.sysui.SystemUiDeviceConfigFlags;
 import com.android.internal.logging.UiEventLogger;
 import com.android.internal.policy.PhoneWindow;
 import com.android.internal.statusbar.IStatusBarService;
@@ -237,6 +239,7 @@ public class ScreenshotController {
     static final String EXTRA_SMART_ACTIONS_ENABLED = ""android:smart_actions_enabled"";
     static final String EXTRA_OVERRIDE_TRANSITION = ""android:screenshot_override_transition"";
     static final String EXTRA_ACTION_INTENT = ""android:screenshot_action_intent"";
+    static final String EXTRA_ACTION_INTENT_FILLIN = ""android:screenshot_action_intent_fillin"";
 
     static final String SCREENSHOT_URI_ID = ""android:screenshot_uri_id"";
     static final String EXTRA_CANCEL_NOTIFICATION = ""android:screenshot_cancel_notification"";
@@ -961,8 +964,11 @@ public class ScreenshotController {
             mSaveInBgTask.setActionsReadyListener(this::logSuccessOnActionsReady);
         }
 
+        boolean smartActionsEnabled = DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_SYSTEMUI,
+                SystemUiDeviceConfigFlags.ENABLE_SCREENSHOT_NOTIFICATION_SMART_ACTIONS, true);
+
         mSaveInBgTask = new SaveImageInBackgroundTask(mContext, mImageExporter,
-                mScreenshotSmartActions, data, getActionTransitionSupplier());
+                mScreenshotSmartActions, data, getActionTransitionSupplier(), smartActionsEnabled);
         mSaveInBgTask.execute(getForegroundAppLabel());
     }
 
",7,1,ScreenshotController::saveScreenshotInWorkerThread
347,c916dad1dfd40b0a4031fb954ada07989121f607,SmartActionsReceiver.java,"@@ -18,6 +18,7 @@ package com.android.systemui.screenshot;
 
 import static com.android.systemui.screenshot.LogConfig.DEBUG_ACTIONS;
 import static com.android.systemui.screenshot.ScreenshotController.EXTRA_ACTION_INTENT;
+import static com.android.systemui.screenshot.ScreenshotController.EXTRA_ACTION_INTENT_FILLIN;
 import static com.android.systemui.screenshot.ScreenshotController.EXTRA_ACTION_TYPE;
 import static com.android.systemui.screenshot.ScreenshotController.EXTRA_ID;
 
@@ -47,6 +48,7 @@ public class SmartActionsReceiver extends BroadcastReceiver {
     @Override
     public void onReceive(Context context, Intent intent) {
         PendingIntent pendingIntent = intent.getParcelableExtra(EXTRA_ACTION_INTENT);
+        Intent fillIn = intent.getParcelableExtra(EXTRA_ACTION_INTENT_FILLIN);
         String actionType = intent.getStringExtra(EXTRA_ACTION_TYPE);
         if (DEBUG_ACTIONS) {
             Log.d(TAG, ""Executing smart action ["" + actionType + ""]:"" + pendingIntent.getIntent());
@@ -54,7 +56,7 @@ public class SmartActionsReceiver extends BroadcastReceiver {
         ActivityOptions opts = ActivityOptions.makeBasic();
 
         try {
-            pendingIntent.send(context, 0, null, null, null, null, opts.toBundle());
+            pendingIntent.send(context, 0, fillIn, null, null, null, opts.toBundle());
         } catch (PendingIntent.CanceledException e) {
             Log.e(TAG, ""Pending intent canceled"", e);
         }
",3,1,SmartActionsReceiver::onReceive
348,c916dad1dfd40b0a4031fb954ada07989121f607,ScreenshotNotificationSmartActionsTest.java,"@@ -211,7 +211,7 @@ public class ScreenshotNotificationSmartActionsTest extends SysuiTestCase {
         data.mActionsReadyListener = null;
         SaveImageInBackgroundTask task =
                 new SaveImageInBackgroundTask(mContext, null, mScreenshotSmartActions, data,
-                        ActionTransition::new);
+                        ActionTransition::new, false);
 
         Notification.Action shareAction = task.createShareAction(mContext, mContext.getResources(),
                 Uri.parse(""Screenshot_123.png"")).get().action;
@@ -239,7 +239,7 @@ public class ScreenshotNotificationSmartActionsTest extends SysuiTestCase {
         data.mActionsReadyListener = null;
         SaveImageInBackgroundTask task =
                 new SaveImageInBackgroundTask(mContext, null, mScreenshotSmartActions, data,
-                        ActionTransition::new);
+                        ActionTransition::new, false);
 
         Notification.Action editAction = task.createEditAction(mContext, mContext.getResources(),
                 Uri.parse(""Screenshot_123.png"")).get().action;
@@ -267,7 +267,7 @@ public class ScreenshotNotificationSmartActionsTest extends SysuiTestCase {
         data.mActionsReadyListener = null;
         SaveImageInBackgroundTask task =
                 new SaveImageInBackgroundTask(mContext, null, mScreenshotSmartActions, data,
-                        ActionTransition::new);
+                        ActionTransition::new, false);
 
         Notification.Action deleteAction = task.createDeleteAction(mContext,
                 mContext.getResources(),
",3,3,"ScreenshotNotificationSmartActionsTest::testEditActionExtras, ScreenshotNotificationSmartActionsTest::testShareActionExtras, ScreenshotNotificationSmartActionsTest::testDeleteActionExtras"
349,f5fd00ab73631e1a840445cae87077517e83ffc4,WindowState.java,"@@ -3616,8 +3616,12 @@ class WindowState extends WindowContainer<WindowState> implements WindowManagerP
         // apps won't always be considered as foreground state.
         // Exclude private presentations as they can only be shown on private virtual displays and
         // shouldn't be the cause of an app be considered foreground.
-        if (mAttrs.type >= FIRST_SYSTEM_WINDOW && mAttrs.type != TYPE_TOAST
-                && mAttrs.type != TYPE_PRIVATE_PRESENTATION) {
+        // Exclude presentations on virtual displays as they are not actually visible.
+        if (mAttrs.type >= FIRST_SYSTEM_WINDOW
+                && mAttrs.type != TYPE_TOAST
+                && mAttrs.type != TYPE_PRIVATE_PRESENTATION
+                && !(mAttrs.type == TYPE_PRESENTATION && isOnVirtualDisplay())
+        ) {
             mWmService.mAtmService.mActiveUids.onNonAppSurfaceVisibilityChanged(mOwnerUid, shown);
         }
         if (mIsImWindow && mWmService.mAccessibilityController.hasCallbacks()) {
@@ -3625,6 +3629,10 @@ class WindowState extends WindowContainer<WindowState> implements WindowManagerP
         }
     }
 
+    private boolean isOnVirtualDisplay() {
+        return getDisplayContent().mDisplay.getType() == Display.TYPE_VIRTUAL;
+    }
+
     private void logExclusionRestrictions(int side) {
         if (!logsGestureExclusionRestrictions(this)
                 || SystemClock.uptimeMillis() < mLastExclusionLogUptimeMillis[side]
",10,2,"WindowState::onSurfaceShownChanged, WindowState::isOnVirtualDisplay"
350,83ee559375e3286e01ce4c66f0905fee007278ca,NotificationManager.java,"@@ -561,6 +561,12 @@ public class NotificationManager {
      */
     public static final int BUBBLE_PREFERENCE_SELECTED = 2;
 
+    /**
+     * Maximum length of the component name of a registered NotificationListenerService.
+     * @hide
+     */
+    public static int MAX_SERVICE_COMPONENT_NAME_LENGTH = 500;
+
     @UnsupportedAppUsage
     private static INotificationManager sService;
 
",6,0,
351,83ee559375e3286e01ce4c66f0905fee007278ca,NotificationManagerService.java,"@@ -5296,6 +5296,11 @@ public class NotificationManagerService extends SystemService {
                 boolean granted, boolean userSet) {
             Objects.requireNonNull(listener);
             checkNotificationListenerAccess();
+            if (granted && listener.flattenToString().length()
+                    > NotificationManager.MAX_SERVICE_COMPONENT_NAME_LENGTH) {
+                throw new IllegalArgumentException(
+                        ""Component name too long: "" + listener.flattenToString());
+            }
             if (!userSet && isNotificationListenerAccessUserSet(listener)) {
                 // Don't override user's choice
                 return;
",5,0,NotificationManagerService::Stub
352,83ee559375e3286e01ce4c66f0905fee007278ca,VrManagerService.java,"@@ -1049,7 +1049,11 @@ public class VrManagerService extends SystemService
 
         for (ComponentName c : possibleServices) {
             if (Objects.equals(c.getPackageName(), pkg)) {
-                nm.setNotificationListenerAccessGrantedForUser(c, userId, true);
+                try {
+                    nm.setNotificationListenerAccessGrantedForUser(c, userId, true);
+                } catch (Exception e) {
+                    Slog.w(TAG, ""Could not grant NLS access to package "" + pkg, e);
+                }
             }
         }
     }
",5,1,VrManagerService::grantNotificationListenerAccess
353,83ee559375e3286e01ce4c66f0905fee007278ca,NotificationManagerServiceTest.java,"@@ -74,6 +74,7 @@ import static junit.framework.Assert.assertNull;
 import static junit.framework.Assert.assertTrue;
 import static junit.framework.Assert.fail;
 
+import static org.junit.Assert.assertThrows;
 import static org.mockito.ArgumentMatchers.isNull;
 import static org.mockito.Matchers.anyBoolean;
 import static org.mockito.Matchers.anyLong;
@@ -3166,6 +3167,30 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {
                 any(), anyInt(), anyBoolean(), anyBoolean(), anyBoolean());
     }
 
+    @Test
+    public void testSetListenerAccessForUser_grantWithNameTooLong_throws() {
+        UserHandle user = UserHandle.of(mContext.getUserId() + 10);
+        ComponentName c = new ComponentName(""com.example.package"",
+                com.google.common.base.Strings.repeat(""Blah"", 150));
+
+        assertThrows(IllegalArgumentException.class,
+                () -> mBinderService.setNotificationListenerAccessGrantedForUser(
+                        c, user.getIdentifier(), /* enabled= */ true, true));
+    }
+
+    @Test
+    public void testSetListenerAccessForUser_revokeWithNameTooLong_okay() throws Exception {
+        UserHandle user = UserHandle.of(mContext.getUserId() + 10);
+        ComponentName c = new ComponentName(""com.example.package"",
+                com.google.common.base.Strings.repeat(""Blah"", 150));
+
+        mBinderService.setNotificationListenerAccessGrantedForUser(
+                c, user.getIdentifier(), /* enabled= */ false, true);
+
+        verify(mListeners).setPackageOrComponentEnabled(
+                c.flattenToString(), user.getIdentifier(), true, /* enabled= */ false, true);
+    }
+
     @Test
     public void testSetAssistantAccessForUser() throws Exception {
         UserInfo ui = new UserInfo();
",25,0,"NotificationManagerServiceTest::testSetListenerAccessForUser_grantWithNameTooLong_throws, NotificationManagerServiceTest::testSetListenerAccessForUser_revokeWithNameTooLong_okay"
354,dc790136f99780793fc2fe1c8d7c478d1b00c3e5,AccountManagerService.java,"@@ -4923,6 +4923,9 @@ public class AccountManagerService
             Bundle simulateBundle = p.readBundle();
             p.recycle();
             Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT);
+            if (intent != null && intent.getClass() != Intent.class) {
+                return false;
+            }
             Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT);
             if (intent == null) {
                 return (simulateIntent == null);
",3,0,AccountManagerService::Session::checkKeyIntentParceledCorrectly
355,492ce6e3bcffd9996657e37b36dea35c4bb84347,ResumeMediaBrowser.java,"@@ -17,6 +17,7 @@
 package com.android.systemui.media;
 
 import android.annotation.Nullable;
+import android.annotation.UserIdInt;
 import android.app.PendingIntent;
 import android.content.ComponentName;
 import android.content.Context;
@@ -50,6 +51,8 @@ public class ResumeMediaBrowser {
     private final Context mContext;
     @Nullable private final Callback mCallback;
     private MediaBrowserFactory mBrowserFactory;
+    @UserIdInt private final int mUserId;
+
     private MediaBrowser mMediaBrowser;
     private ComponentName mComponentName;
 
@@ -58,13 +61,19 @@ public class ResumeMediaBrowser {
      * @param context the context
      * @param callback used to report media items found
      * @param componentName Component name of the MediaBrowserService this browser will connect to
+     * @param userId ID of the current user
      */
-    public ResumeMediaBrowser(Context context, @Nullable Callback callback,
-            ComponentName componentName, MediaBrowserFactory browserFactory) {
+    public ResumeMediaBrowser(
+            Context context,
+            @Nullable Callback callback,
+            ComponentName componentName,
+            MediaBrowserFactory browserFactory,
+            @UserIdInt int userId) {
         mContext = context;
         mCallback = callback;
         mComponentName = componentName;
         mBrowserFactory = browserFactory;
+        mUserId = userId;
     }
 
     /**
@@ -259,6 +268,14 @@ public class ResumeMediaBrowser {
         return new MediaController(mContext, token);
     }
 
+    /**
+     * Get the ID of the user associated with this broswer
+     * @return the user ID
+     */
+    public @UserIdInt int getUserId() {
+        return mUserId;
+    }
+
     /**
      * Get the media session token
      * @return the token, or null if the MediaBrowser is null or disconnected
",19,2,"ResumeMediaBrowser::ResumeMediaBrowser, ResumeMediaBrowser::ResumeMediaBrowser, ResumeMediaBrowser::getUserId"
356,492ce6e3bcffd9996657e37b36dea35c4bb84347,ResumeMediaBrowserFactory.java,"@@ -16,6 +16,7 @@
 
 package com.android.systemui.media;
 
+import android.annotation.UserIdInt;
 import android.content.ComponentName;
 import android.content.Context;
 
@@ -39,10 +40,12 @@ public class ResumeMediaBrowserFactory {
      *
      * @param callback will be called on connection or error, and addTrack when media item found
      * @param componentName component to browse
+     * @param userId ID of the current user
      * @return
      */
     public ResumeMediaBrowser create(ResumeMediaBrowser.Callback callback,
-            ComponentName componentName) {
-        return new ResumeMediaBrowser(mContext, callback, componentName, mBrowserFactory);
+            ComponentName componentName, @UserIdInt int userId) {
+        return new ResumeMediaBrowser(mContext, callback, componentName, mBrowserFactory,
+            userId);
     }
 }
",5,2,"ResumeMediaBrowserFactory::create, ResumeMediaBrowserFactory::create"
357,71e3acf509833bb428b8d1efee42daea316d5a0d,RingtoneManager.java,"@@ -802,10 +802,10 @@ public class RingtoneManager {
 
         return ringtoneUri;
     }
-    
+
     /**
      * Sets the {@link Uri} of the default sound for a given sound type.
-     * 
+     *
      * @param context A context used for querying.
      * @param type The type whose default sound should be set. One of
      *            {@link #TYPE_RINGTONE}, {@link #TYPE_NOTIFICATION}, or
@@ -826,6 +826,21 @@ public class RingtoneManager {
         if(!isInternalRingtoneUri(ringtoneUri)) {
             ringtoneUri = ContentProvider.maybeAddUserId(ringtoneUri, context.getUserId());
         }
+
+        if (ringtoneUri != null) {
+            final String mimeType = resolver.getType(ringtoneUri);
+            if (mimeType == null) {
+                Log.e(TAG, ""setActualDefaultRingtoneUri for URI:"" + ringtoneUri
+                        + "" ignored: failure to find mimeType (no access from this context?)"");
+                return;
+            }
+            if (!(mimeType.startsWith(""audio/"") || mimeType.equals(""application/ogg""))) {
+                Log.e(TAG, ""setActualDefaultRingtoneUri for URI:"" + ringtoneUri
+                        + "" ignored: associated mimeType:"" + mimeType + "" is not an audio type"");
+                return;
+            }
+        }
+
         Settings.System.putStringForUser(resolver, setting,
                 ringtoneUri != null ? ringtoneUri.toString() : null, context.getUserId());
 
",17,2,RingtoneManager::setActualDefaultRingtoneUri
358,193a8234fe89f9ede2ade8972056fbecc1722cd7,Notification.java,"@@ -2811,6 +2811,17 @@ public class Notification implements Parcelable
             if (person != null) {
                 visitor.accept(person.getIconUri());
             }
+
+            final RemoteInputHistoryItem[] history = getParcelableArrayFromBundle(extras,
+                Notification.EXTRA_REMOTE_INPUT_HISTORY_ITEMS, RemoteInputHistoryItem.class);
+            if (history != null) {
+                for (int i = 0; i < history.length; i++) {
+                    RemoteInputHistoryItem item = history[i];
+                    if (item.getUri() != null) {
+                        visitor.accept(item.getUri());
+                    }
+                }
+            }
         }
 
         if (isStyle(MessagingStyle.class) && extras != null) {
",11,0,Notification::visitUris
359,193a8234fe89f9ede2ade8972056fbecc1722cd7,NotificationManagerServiceTest.java,"@@ -116,6 +116,7 @@ import android.app.NotificationManager;
 import android.app.PendingIntent;
 import android.app.Person;
 import android.app.RemoteInput;
+import android.app.RemoteInputHistoryItem;
 import android.app.StatsManager;
 import android.app.admin.DevicePolicyManagerInternal;
 import android.app.usage.UsageStatsManagerInternal;
@@ -4488,6 +4489,12 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {
                 .setName(""People List Person 2"")
                 .setIcon(personIcon3)
                 .build();
+        final Uri historyUri1 = Uri.parse(""content://com.example/history1"");
+        final Uri historyUri2 = Uri.parse(""content://com.example/history2"");
+        final RemoteInputHistoryItem historyItem1 = new RemoteInputHistoryItem(null, historyUri1,
+                ""a"");
+        final RemoteInputHistoryItem historyItem2 = new RemoteInputHistoryItem(null, historyUri2,
+                ""b"");
 
         Bundle extras = new Bundle();
         extras.putParcelable(Notification.EXTRA_AUDIO_CONTENTS_URI, audioContents);
@@ -4495,6 +4502,8 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {
         extras.putParcelable(Notification.EXTRA_MESSAGING_PERSON, person1);
         extras.putParcelableArrayList(Notification.EXTRA_PEOPLE_LIST,
                 new ArrayList<>(Arrays.asList(person2, person3)));
+        extras.putParcelableArray(Notification.EXTRA_REMOTE_INPUT_HISTORY_ITEMS,
+                new RemoteInputHistoryItem[]{historyItem1, historyItem2});
 
         Notification n = new Notification.Builder(mContext, ""a"")
                 .setContentTitle(""notification with uris"")
@@ -4503,6 +4512,13 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {
                 .addExtras(extras)
                 .build();
 
+        // Serialize and deserialize the notification to make sure nothing breaks in the process,
+        // since that's what will usually happen before we get to call visitUris.
+        Parcel parcel = Parcel.obtain();
+        n.writeToParcel(parcel, 0);
+        parcel.setDataPosition(0);
+        n = new Notification(parcel);
+
         Consumer<Uri> visitor = (Consumer<Uri>) spy(Consumer.class);
         n.visitUris(visitor);
         verify(visitor, times(1)).accept(eq(audioContents));
@@ -4512,6 +4528,8 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {
         verify(visitor, times(1)).accept(eq(personIcon1.getUri()));
         verify(visitor, times(1)).accept(eq(personIcon2.getUri()));
         verify(visitor, times(1)).accept(eq(personIcon3.getUri()));
+        verify(visitor, times(1)).accept(eq(historyUri1));
+        verify(visitor, times(1)).accept(eq(historyUri2));
     }
 
     @Test
",18,0,NotificationManagerServiceTest::testVisitUris
360,5b1e387eb079f165d3cbef4c263cc9b030791db9,Helper.java,"@@ -18,6 +18,8 @@ package com.android.server.autofill;
 
 import android.annotation.NonNull;
 import android.annotation.Nullable;
+import android.annotation.UserIdInt;
+import android.app.ActivityManager;
 import android.app.assist.AssistStructure;
 import android.app.assist.AssistStructure.ViewNode;
 import android.app.assist.AssistStructure.WindowNode;
@@ -34,6 +36,7 @@ import android.view.View;
 import android.view.WindowManager;
 import android.view.autofill.AutofillId;
 import android.view.autofill.AutofillValue;
+import android.widget.RemoteViews;
 
 import com.android.internal.logging.nano.MetricsProto.MetricsEvent;
 import com.android.internal.util.ArrayUtils;
@@ -42,6 +45,8 @@ import java.io.PrintWriter;
 import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.concurrent.atomic.AtomicBoolean;
+
 
 public final class Helper {
 
@@ -75,6 +80,44 @@ public final class Helper {
         throw new UnsupportedOperationException(""contains static members only"");
     }
 
+    private static boolean checkRemoteViewUriPermissions(
+            @UserIdInt int userId, @NonNull RemoteViews rView) {
+        final AtomicBoolean permissionsOk = new AtomicBoolean(true);
+
+        rView.visitUris(uri -> {
+            int uriOwnerId = android.content.ContentProvider.getUserIdFromUri(uri);
+            boolean allowed = uriOwnerId == userId;
+            permissionsOk.set(allowed && permissionsOk.get());
+        });
+
+        return permissionsOk.get();
+    }
+
+    /**
+     * Checks the URI permissions of the remote view,
+     * to see if the current userId is able to access it.
+     *
+     * Returns the RemoteView that is passed if user is able, null otherwise.
+     *
+     * TODO: instead of returning a null remoteview when
+     * the current userId cannot access an URI,
+     * return a new RemoteView with the URI removed.
+     */
+    public static @Nullable RemoteViews sanitizeRemoteView(RemoteViews rView) {
+        if (rView == null) return null;
+
+        int userId = ActivityManager.getCurrentUser();
+
+        boolean ok = checkRemoteViewUriPermissions(userId, rView);
+        if (!ok) {
+            Slog.w(TAG,
+                    ""sanitizeRemoteView() user: "" + userId
+                    + "" tried accessing resource that does not belong to them"");
+        }
+        return (ok ? rView : null);
+    }
+
+
     @Nullable
     static AutofillId[] toArray(@Nullable ArraySet<AutofillId> set) {
         if (set == null) return null;
",43,0,"Helper::sanitizeRemoteView, Helper::checkRemoteViewUriPermissions"
361,5b1e387eb079f165d3cbef4c263cc9b030791db9,FillUi.java,"@@ -141,8 +141,9 @@ final class FillUi {
 
         final LayoutInflater inflater = LayoutInflater.from(mContext);
 
-        final RemoteViews headerPresentation = response.getHeader();
-        final RemoteViews footerPresentation = response.getFooter();
+        final RemoteViews headerPresentation = Helper.sanitizeRemoteView(response.getHeader());
+        final RemoteViews footerPresentation = Helper.sanitizeRemoteView(response.getFooter());
+
         final ViewGroup decor;
         if (mFullScreen) {
             decor = (ViewGroup) inflater.inflate(R.layout.autofill_dataset_picker_fullscreen, null);
@@ -220,6 +221,9 @@ final class FillUi {
             ViewGroup container = decor.findViewById(R.id.autofill_dataset_picker);
             final View content;
             try {
+                if (Helper.sanitizeRemoteView(response.getPresentation()) == null) {
+                    throw new RuntimeException(""Permission error accessing RemoteView"");
+                }
                 content = response.getPresentation().applyWithTheme(
                         mContext, decor, interceptionHandler, mThemeId);
                 container.addView(content);
@@ -299,7 +303,8 @@ final class FillUi {
                 final Dataset dataset = response.getDatasets().get(i);
                 final int index = dataset.getFieldIds().indexOf(focusedViewId);
                 if (index >= 0) {
-                    final RemoteViews presentation = dataset.getFieldPresentation(index);
+                    final RemoteViews presentation = Helper.sanitizeRemoteView(
+                            dataset.getFieldPresentation(index));
                     if (presentation == null) {
                         Slog.w(TAG, ""not displaying UI on field "" + focusedViewId + "" because ""
                                 + ""service didn't provide a presentation for it on "" + dataset);
",8,3,FillUi::FillUi
362,5b1e387eb079f165d3cbef4c263cc9b030791db9,SaveUi.java,"@@ -368,8 +368,7 @@ final class SaveUi {
             return false;
         }
         writeLog(MetricsEvent.AUTOFILL_SAVE_CUSTOM_DESCRIPTION);
-
-        final RemoteViews template = customDescription.getPresentation();
+        final RemoteViews template = Helper.sanitizeRemoteView(customDescription.getPresentation());
         if (template == null) {
             Slog.w(TAG, ""No remote view on custom description"");
             return false;
",1,2,SaveUi::applyCustomDescription
363,bc240fffa8cf75caf9fb5a8b14ea125809b8b5f6,PipMenuView.java,"@@ -43,6 +43,7 @@ import android.content.Intent;
 import android.graphics.Color;
 import android.graphics.Rect;
 import android.graphics.drawable.Drawable;
+import android.graphics.drawable.Icon;
 import android.net.Uri;
 import android.os.Bundle;
 import android.os.Handler;
@@ -488,13 +489,19 @@ public class PipMenuView extends FrameLayout {
                     final PipMenuActionView actionView =
                             (PipMenuActionView) mActionsGroup.getChildAt(i);
 
-                    // TODO: Check if the action drawable has changed before we reload it
-                    action.getIcon().loadDrawableAsync(mContext, d -> {
-                        if (d != null) {
-                            d.setTint(Color.WHITE);
-                            actionView.setImageDrawable(d);
-                        }
-                    }, mMainHandler);
+                    final int iconType = action.getIcon().getType();
+                    if (iconType == Icon.TYPE_URI || iconType == Icon.TYPE_URI_ADAPTIVE_BITMAP) {
+                        // Disallow loading icon from content URI
+                        actionView.setImageDrawable(null);
+                    } else {
+                        // TODO: Check if the action drawable has changed before we reload it
+                        action.getIcon().loadDrawableAsync(mContext, d -> {
+                            if (d != null) {
+                                d.setTint(Color.WHITE);
+                                actionView.setImageDrawable(d);
+                            }
+                        }, mMainHandler);
+                    }
                     actionView.setContentDescription(action.getContentDescription());
                     if (action.isEnabled()) {
                         actionView.setOnClickListener(v -> {
",14,7,PipMenuView::updateActionViews
364,c28b8b46fbbf28633ecd7a78b7272a0abc3ac245,DatabaseUtils.java,"@@ -511,17 +511,31 @@ public class DatabaseUtils {
      */
     public static void appendEscapedSQLString(StringBuilder sb, String sqlString) {
         sb.append('\'');
-        if (sqlString.indexOf('\'') != -1) {
-            int length = sqlString.length();
-            for (int i = 0; i < length; i++) {
-                char c = sqlString.charAt(i);
-                if (c == '\'') {
-                    sb.append('\'');
+        int length = sqlString.length();
+        for (int i = 0; i < length; i++) {
+            char c = sqlString.charAt(i);
+            if (Character.isHighSurrogate(c)) {
+                if (i == length - 1) {
+                    continue;
+                }
+                if (Character.isLowSurrogate(sqlString.charAt(i + 1))) {
+                    // add them both
+                    sb.append(c);
+                    sb.append(sqlString.charAt(i + 1));
+                    continue;
+                } else {
+                    // this is a lone surrogate, skip it
+                    continue;
                 }
-                sb.append(c);
             }
-        } else
-            sb.append(sqlString);
+            if (Character.isLowSurrogate(c)) {
+                continue;
+            }
+            if (c == '\'') {
+                sb.append('\'');
+            }
+            sb.append(c);
+        }
         sb.append('\'');
     }
 
",23,9,DatabaseUtils::appendEscapedSQLString
365,65a7753ad199415c14a969289e8aea76320f8a78,SettingsProvider.java,"@@ -3075,6 +3075,15 @@ public class SettingsProvider extends ContentProvider {
             return settingsState.getSettingLocked(name);
         }
 
+        private boolean shouldExcludeSettingFromReset(Setting setting, String prefix) {
+            // If a prefix was specified, exclude settings whose names don't start with it.
+            if (prefix != null && !setting.getName().startsWith(prefix)) {
+                return true;
+            }
+            // Never reset SECURE_FRP_MODE, as it could be abused to bypass FRP via RescueParty.
+            return Secure.SECURE_FRP_MODE.equals(setting.getName());
+        }
+
         public void resetSettingsLocked(int type, int userId, String packageName, int mode,
                 String tag) {
             resetSettingsLocked(type, userId, packageName, mode, tag, /*prefix=*/
@@ -3097,7 +3106,7 @@ public class SettingsProvider extends ContentProvider {
                         Setting setting = settingsState.getSettingLocked(name);
                         if (packageName.equals(setting.getPackageName())) {
                             if ((tag != null && !tag.equals(setting.getTag()))
-                                    || (prefix != null && !setting.getName().startsWith(prefix))) {
+                                    || shouldExcludeSettingFromReset(setting, prefix)) {
                                 continue;
                             }
                             if (settingsState.resetSettingLocked(name)) {
@@ -3117,7 +3126,7 @@ public class SettingsProvider extends ContentProvider {
                         Setting setting = settingsState.getSettingLocked(name);
                         if (!SettingsState.isSystemPackage(getContext(),
                                 setting.getPackageName())) {
-                            if (prefix != null && !setting.getName().startsWith(prefix)) {
+                            if (shouldExcludeSettingFromReset(setting, prefix)) {
                                 continue;
                             }
                             if (settingsState.resetSettingLocked(name)) {
@@ -3137,7 +3146,7 @@ public class SettingsProvider extends ContentProvider {
                         Setting setting = settingsState.getSettingLocked(name);
                         if (!SettingsState.isSystemPackage(getContext(),
                                 setting.getPackageName())) {
-                            if (prefix != null && !setting.getName().startsWith(prefix)) {
+                            if (shouldExcludeSettingFromReset(setting, prefix)) {
                                 continue;
                             }
                             if (setting.isDefaultFromSystem()) {
@@ -3160,7 +3169,7 @@ public class SettingsProvider extends ContentProvider {
                     for (String name : settingsState.getSettingNamesLocked()) {
                         Setting setting = settingsState.getSettingLocked(name);
                         boolean someSettingChanged = false;
-                        if (prefix != null && !setting.getName().startsWith(prefix)) {
+                        if (shouldExcludeSettingFromReset(setting, prefix)) {
                             continue;
                         }
                         if (setting.isDefaultFromSystem()) {
",13,4,"SettingsProvider::SettingsRegistry::shouldExcludeSettingFromReset, SettingsProvider::SettingsRegistry::resetSettingsLocked"
366,65a7753ad199415c14a969289e8aea76320f8a78,SettingsProviderTest.java,"@@ -466,6 +466,31 @@ public class SettingsProviderTest extends BaseSettingsProviderTest {
         }
     }
 
+    // To prevent FRP bypasses, the SECURE_FRP_MODE setting should not be reset when all other
+    // settings are reset.  But it should still be possible to explicitly set its value.
+    @Test
+    public void testSecureFrpModeSettingCannotBeReset() throws Exception {
+        final String name = Settings.Secure.SECURE_FRP_MODE;
+        final String origValue = getSetting(SETTING_TYPE_GLOBAL, name);
+        setSettingViaShell(SETTING_TYPE_GLOBAL, name, ""1"", false);
+        try {
+            assertEquals(""1"", getSetting(SETTING_TYPE_GLOBAL, name));
+            for (int type : new int[] { SETTING_TYPE_GLOBAL, SETTING_TYPE_SECURE }) {
+                resetSettingsViaShell(type, Settings.RESET_MODE_UNTRUSTED_DEFAULTS);
+                resetSettingsViaShell(type, Settings.RESET_MODE_UNTRUSTED_CHANGES);
+                resetSettingsViaShell(type, Settings.RESET_MODE_TRUSTED_DEFAULTS);
+            }
+            // The value should still be ""1"".  It should not have been reset to null.
+            assertEquals(""1"", getSetting(SETTING_TYPE_GLOBAL, name));
+            // It should still be possible to explicitly set the value to ""0"".
+            setSettingViaShell(SETTING_TYPE_GLOBAL, name, ""0"", false);
+            assertEquals(""0"", getSetting(SETTING_TYPE_GLOBAL, name));
+        } finally {
+            setSettingViaShell(SETTING_TYPE_GLOBAL, name, origValue, false);
+            assertEquals(origValue, getSetting(SETTING_TYPE_GLOBAL, name));
+        }
+    }
+
     private void doTestQueryStringInBracketsViaProviderApiForType(int type) {
         // Make sure we have a clean slate.
         deleteStringViaProviderApi(type, FAKE_SETTING_NAME);
",25,0,SettingsProviderTest::testSecureFrpModeSettingCannotBeReset
367,e3723d5b82b41892f11dab9fa12fb45cab186d73,PipBoundsAlgorithm.java,"@@ -182,6 +182,21 @@ public class PipBoundsAlgorithm {
         return null;
     }
 
+    /**
+     * Returns the source hint rect if it is valid (if provided and is contained by the current
+     * task bounds and not too small).
+     */
+    public static Rect getValidSourceHintRect(PictureInPictureParams params, Rect sourceBounds,
+                @NonNull Rect destinationBounds) {
+        final Rect sourceHintRect = getValidSourceHintRect(params, sourceBounds);
+        if (sourceHintRect != null
+                && sourceHintRect.width() > destinationBounds.width()
+                && sourceHintRect.height() > destinationBounds.height()) {
+            return sourceHintRect;
+        }
+        return null;
+    }
+
     public float getDefaultAspectRatio() {
         return mDefaultAspectRatio;
     }
",15,0,PipBoundsAlgorithm::getValidSourceHintRect
368,e3723d5b82b41892f11dab9fa12fb45cab186d73,PipTaskOrganizer.java,"@@ -553,7 +553,7 @@ public class PipTaskOrganizer implements ShellTaskOrganizer.TaskListener,
         if (mOneShotAnimationType == ANIM_TYPE_BOUNDS) {
             mPipMenuController.attach(mLeash);
             final Rect sourceHintRect = PipBoundsAlgorithm.getValidSourceHintRect(
-                    info.pictureInPictureParams, currentBounds);
+                    info.pictureInPictureParams, currentBounds, destinationBounds);
             scheduleAnimateResizePip(currentBounds, destinationBounds, 0 /* startingAngle */,
                     sourceHintRect, TRANSITION_DIRECTION_TO_PIP, mEnterAnimationDuration,
                     null /* updateBoundsCallback */);
@@ -579,9 +579,9 @@ public class PipTaskOrganizer implements ShellTaskOrganizer.TaskListener,
             return;
         }
         final Rect currentBounds = mTaskInfo.configuration.windowConfiguration.getBounds();
-        final Rect sourceHintRect = PipBoundsAlgorithm.getValidSourceHintRect(
-                mPictureInPictureParams, currentBounds);
         final Rect destinationBounds = mPipBoundsAlgorithm.getEntryDestinationBounds();
+        final Rect sourceHintRect = PipBoundsAlgorithm.getValidSourceHintRect(
+                mPictureInPictureParams, currentBounds, destinationBounds);
         animateResizePip(currentBounds, destinationBounds, sourceHintRect,
                 TRANSITION_DIRECTION_TO_PIP, mEnterAnimationDuration, 0 /* startingAngle */);
         mPipTransitionState.setTransitionState(PipTransitionState.ENTERING_PIP);
",3,3,"PipTaskOrganizer::onTaskAppearedWithFixedRotation, PipTaskOrganizer::onTaskAppeared"
369,e3723d5b82b41892f11dab9fa12fb45cab186d73,PipTransition.java,"@@ -318,7 +318,7 @@ public class PipTransition extends PipTransitionController {
         if (mOneShotAnimationType == ANIM_TYPE_BOUNDS) {
             final Rect sourceHintRect =
                     PipBoundsAlgorithm.getValidSourceHintRect(
-                            taskInfo.pictureInPictureParams, currentBounds);
+                            taskInfo.pictureInPictureParams, currentBounds, destinationBounds);
             animator = mPipAnimationController.getAnimator(taskInfo, leash, currentBounds,
                     currentBounds, destinationBounds, sourceHintRect, TRANSITION_DIRECTION_TO_PIP,
                     0 /* startingAngle */, rotationDelta);
",1,1,PipTransition::startEnterAnimation
370,0b7e9f1dd833986faa7004f8fdbb9d65f213efa5,KeyguardSecurityContainerController.java,"@@ -426,7 +426,7 @@ public class KeyguardSecurityContainerController extends ViewController<Keyguard
                 case SimPuk:
                     // Shortcut for SIM PIN/PUK to go to directly to user's security screen or home
                     SecurityMode securityMode = mSecurityModel.getSecurityMode(targetUserId);
-                    if (securityMode == SecurityMode.None || mLockPatternUtils.isLockScreenDisabled(
+                    if (securityMode == SecurityMode.None && mLockPatternUtils.isLockScreenDisabled(
                             KeyguardUpdateMonitor.getCurrentUser())) {
                         finish = true;
                         eventSubtype = BOUNCER_DISMISS_SIM;
",1,1,KeyguardSecurityContainerController::showNextSecurityScreenOrFinish
371,19d66c209a5e505ec352e6c64421297dd7627c8a,Notification.java,"@@ -3357,8 +3357,11 @@ public class Notification implements Parcelable
      *
      * @hide
      */
-    public void setAllowlistToken(@Nullable IBinder token) {
-        mAllowlistToken = token;
+    public void clearAllowlistToken() {
+        mAllowlistToken = null;
+        if (publicVersion != null) {
+            publicVersion.clearAllowlistToken();
+        }
     }
 
     /**
",5,2,"Notification::setAllowlistToken, Notification::clearAllowlistToken"
372,19d66c209a5e505ec352e6c64421297dd7627c8a,NotificationManagerService.java,"@@ -4240,7 +4240,7 @@ public class NotificationManagerService extends SystemService {
                     // Remove background token before returning notification to untrusted app, this
                     // ensures the app isn't able to perform background operations that are
                     // associated with notification interactions.
-                    notification.setAllowlistToken(null);
+                    notification.clearAllowlistToken();
                     return new StatusBarNotification(
                             sbn.getPackageName(),
                             sbn.getOpPkg(),
",1,1,NotificationManagerService::Stub
373,1aa5689959c783e10574b5b0c13e4ed4d34bbaae,ActivityManagerService.java,"@@ -2807,6 +2807,22 @@ public class ActivityManagerService extends IActivityManager.Stub
         }
     }
 
+    /**
+     * Enforces that the uid of the caller matches the uid of the package.
+     *
+     * @param packageName the name of the package to match uid against.
+     * @param callingUid the uid of the caller.
+     * @throws SecurityException if the calling uid doesn't match uid of the package.
+     */
+    private void enforceCallingPackage(String packageName, int callingUid) {
+        final int userId = UserHandle.getUserId(callingUid);
+        final int packageUid = getPackageManagerInternal().getPackageUid(packageName,
+                /*flags=*/ 0, userId);
+        if (packageUid != callingUid) {
+            throw new SecurityException(packageName + "" does not belong to uid "" + callingUid);
+        }
+    }
+
     @Override
     public void setPackageScreenCompatMode(String packageName, int mode) {
         mActivityTaskManager.setPackageScreenCompatMode(packageName, mode);
@@ -12267,13 +12283,16 @@ public class ActivityManagerService extends IActivityManager.Stub
     // A backup agent has just come up
     @Override
     public void backupAgentCreated(String agentPackageName, IBinder agent, int userId) {
+        final int callingUid = Binder.getCallingUid();
+        enforceCallingPackage(agentPackageName, callingUid);
+
         // Resolve the target user id and enforce permissions.
-        userId = mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(),
+        userId = mUserController.handleIncomingUser(Binder.getCallingPid(), callingUid,
                 userId, /* allowAll */ false, ALLOW_FULL_ONLY, ""backupAgentCreated"", null);
         if (DEBUG_BACKUP) {
             Slog.v(TAG_BACKUP, ""backupAgentCreated: "" + agentPackageName + "" = "" + agent
                     + "" callingUserId = "" + UserHandle.getCallingUserId() + "" userId = "" + userId
-                    + "" callingUid = "" + Binder.getCallingUid() + "" uid = "" + Process.myUid());
+                    + "" callingUid = "" + callingUid + "" uid = "" + Process.myUid());
         }
 
         synchronized(this) {
",21,2,"ActivityManagerService::enforceCallingPackage, ActivityManagerService::backupAgentCreated"
374,9a7ef3dc845c229d21061548d0f5d9b0be978b72,UsbConfiguration.java,"@@ -172,7 +172,8 @@ public class UsbConfiguration implements Parcelable {
             String name = in.readString();
             int attributes = in.readInt();
             int maxPower = in.readInt();
-            Parcelable[] interfaces = in.readParcelableArray(UsbInterface.class.getClassLoader());
+            Parcelable[] interfaces = in.readParcelableArray(
+                    UsbInterface.class.getClassLoader(), UsbInterface.class);
             UsbConfiguration configuration = new UsbConfiguration(id, name, attributes, maxPower);
             configuration.setInterfaces(interfaces);
             return configuration;
",2,1,UsbConfiguration::Creator<UsbConfiguration>
375,c2a24edb3e383e4abd3044e64e25fb9d5c3eb251,SettingsProvider.java,"@@ -1906,6 +1906,9 @@ public class SettingsProvider extends ContentProvider {
             cacheName = Settings.System.ALARM_ALERT_CACHE;
         }
         if (cacheName != null) {
+            if (!isValidAudioUri(name, value)) {
+                return false;
+            }
             final File cacheFile = new File(
                     getRingtoneCacheDir(owningUserId), cacheName);
             cacheFile.delete();
@@ -1938,6 +1941,34 @@ public class SettingsProvider extends ContentProvider {
         }
     }
 
+    private boolean isValidAudioUri(String name, String uri) {
+        if (uri != null) {
+            Uri audioUri = Uri.parse(uri);
+            if (Settings.AUTHORITY.equals(
+                    ContentProvider.getAuthorityWithoutUserId(audioUri.getAuthority()))) {
+                // Don't accept setting the default uri to self-referential URIs like
+                // Settings.System.DEFAULT_RINGTONE_URI, which is an alias to the value of this
+                // setting.
+                return false;
+            }
+            final String mimeType = getContext().getContentResolver().getType(audioUri);
+            if (mimeType == null) {
+                Slog.e(LOG_TAG,
+                        ""mutateSystemSetting for setting: "" + name + "" URI: "" + audioUri
+                        + "" ignored: failure to find mimeType (no access from this context?)"");
+                return false;
+            }
+            if (!(mimeType.startsWith(""audio/"") || mimeType.equals(""application/ogg"")
+                    || mimeType.equals(""application/x-flac""))) {
+                Slog.e(LOG_TAG,
+                        ""mutateSystemSetting for setting: "" + name + "" URI: "" + audioUri
+                        + "" ignored: associated mimeType: "" + mimeType + "" is not an audio type"");
+                return false;
+            }
+        }
+        return true;
+    }
+
     private boolean hasWriteSecureSettingsPermission() {
         // Write secure settings is a more protected permission. If caller has it we are good.
         return getContext().checkCallingOrSelfPermission(Manifest.permission.WRITE_SECURE_SETTINGS)
",31,0,"SettingsProvider::isValidAudioUri, SettingsProvider::mutateSystemSetting"
376,a47eec4fba3344b724ae0ca2e0e37985307d0696,Notification.java,"@@ -2092,6 +2092,10 @@ public class Notification implements Parcelable
             }
         }
 
+        private void visitUris(@NonNull Consumer<Uri> visitor) {
+            visitIconUri(visitor, getIcon());
+        }
+
         @Override
         public Action clone() {
             return new Action(
@@ -2777,7 +2781,7 @@ public class Notification implements Parcelable
 
         if (actions != null) {
             for (Action action : actions) {
-                visitIconUri(visitor, action.getIcon());
+                action.visitUris(visitor);
             }
         }
 
@@ -2865,6 +2869,11 @@ public class Notification implements Parcelable
         if (mBubbleMetadata != null) {
             visitIconUri(visitor, mBubbleMetadata.getIcon());
         }
+
+        if (extras != null && extras.containsKey(WearableExtender.EXTRA_WEARABLE_EXTENSIONS)) {
+            WearableExtender extender = new WearableExtender(this);
+            extender.visitUris(visitor);
+        }
     }
 
     /**
@@ -11419,6 +11428,12 @@ public class Notification implements Parcelable
                 mFlags &= ~mask;
             }
         }
+
+        private void visitUris(@NonNull Consumer<Uri> visitor) {
+            for (Action action : mActions) {
+                action.visitUris(visitor);
+            }
+        }
     }
 
     /**
",16,1,"Notification::visitUris, Notification::WearableExtender::visitUris, Notification::Action::visitUris"
377,a47eec4fba3344b724ae0ca2e0e37985307d0696,NotificationManagerServiceTest.java,"@@ -4637,6 +4637,26 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {
         verify(visitor, times(1)).accept(eq(verificationIcon.getUri()));
     }
 
+    @Test
+    public void testVisitUris_wearableExtender() {
+        Icon actionIcon = Icon.createWithContentUri(""content://media/action"");
+        Icon wearActionIcon = Icon.createWithContentUri(""content://media/wearAction"");
+        PendingIntent intent = PendingIntent.getActivity(mContext, 0, new Intent(),
+                PendingIntent.FLAG_IMMUTABLE);
+        Notification n = new Notification.Builder(mContext, ""a"")
+                .setSmallIcon(android.R.drawable.sym_def_app_icon)
+                .addAction(new Notification.Action.Builder(actionIcon, ""Hey!"", intent).build())
+                .extend(new Notification.WearableExtender().addAction(
+                        new Notification.Action.Builder(wearActionIcon, ""Wear!"", intent).build()))
+                .build();
+
+        Consumer<Uri> visitor = (Consumer<Uri>) spy(Consumer.class);
+        n.visitUris(visitor);
+
+        verify(visitor).accept(eq(actionIcon.getUri()));
+        verify(visitor).accept(eq(wearActionIcon.getUri()));
+    }
+
     @Test
     public void testSetNotificationPolicy_preP_setOldFields() {
         ZenModeHelper mZenModeHelper = mock(ZenModeHelper.class);
",20,0,NotificationManagerServiceTest::testVisitUris_wearableExtender
378,a76d515c92b5a854536dc16768c47577c3bcc945,PendingIntentUtils.java,"@@ -34,6 +34,7 @@ public class PendingIntentUtils {
     public static Bundle createDontSendToRestrictedAppsBundle(@Nullable Bundle bundle) {
         final BroadcastOptions options = BroadcastOptions.makeBasic();
         options.setDontSendToRestrictedApps(true);
+        options.setPendingIntentBackgroundActivityLaunchAllowed(false);
         if (bundle == null) {
             return options.toBundle();
         }
",1,0,PendingIntentUtils::createDontSendToRestrictedAppsBundle
379,c17682ed92206abf2db40f6f27de1a3d8ab2a855,Notification.java,"@@ -2811,11 +2811,6 @@ public class Notification implements Parcelable
                 }
             }
 
-            final Person person = extras.getParcelable(EXTRA_MESSAGING_PERSON);
-            if (person != null) {
-                visitor.accept(person.getIconUri());
-            }
-
             final RemoteInputHistoryItem[] history = getParcelableArrayFromBundle(extras,
                 Notification.EXTRA_REMOTE_INPUT_HISTORY_ITEMS, RemoteInputHistoryItem.class);
             if (history != null) {
@@ -2826,9 +2821,14 @@ public class Notification implements Parcelable
                     }
                 }
             }
-        }
 
-        if (isStyle(MessagingStyle.class) && extras != null) {
+            // Extras for MessagingStyle. We visit them even if not isStyle(MessagingStyle), since
+            // Notification Listeners might use directly (without the isStyle check).
+            final Person person = extras.getParcelable(EXTRA_MESSAGING_PERSON);
+            if (person != null) {
+                visitor.accept(person.getIconUri());
+            }
+
             final Parcelable[] messages = extras.getParcelableArray(EXTRA_MESSAGES);
             if (!ArrayUtils.isEmpty(messages)) {
                 for (MessagingStyle.Message message : MessagingStyle.Message
@@ -2856,9 +2856,8 @@ public class Notification implements Parcelable
             }
 
             visitIconUri(visitor, extras.getParcelable(EXTRA_CONVERSATION_ICON));
-        }
 
-        if (isStyle(CallStyle.class) & extras != null) {
+            // Extras for CallStyle (same reason for visiting without checking isStyle).
             Person callPerson = extras.getParcelable(EXTRA_CALL_PERSON);
             if (callPerson != null) {
                 visitor.accept(callPerson.getIconUri());
",8,9,Notification::visitUris
380,c17682ed92206abf2db40f6f27de1a3d8ab2a855,NotificationManagerServiceTest.java,"@@ -4637,6 +4637,49 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {
         verify(visitor, times(1)).accept(eq(verificationIcon.getUri()));
     }
 
+    @Test
+    public void testVisitUris_styleExtrasWithoutStyle() {
+        Notification notification = new Notification.Builder(mContext, ""a"")
+                .setSmallIcon(android.R.drawable.sym_def_app_icon)
+                .build();
+
+        Notification.MessagingStyle messagingStyle = new Notification.MessagingStyle(
+                personWithIcon(""content://user""))
+                .addHistoricMessage(new Notification.MessagingStyle.Message(""Heyhey!"",
+                                System.currentTimeMillis(),
+                                personWithIcon(""content://historicalMessenger"")))
+                .addMessage(new Notification.MessagingStyle.Message(""Are you there"",
+                                System.currentTimeMillis(),
+                                personWithIcon(""content://messenger"")))
+                        .setShortcutIcon(
+                                Icon.createWithContentUri(""content://conversationShortcut""));
+        messagingStyle.addExtras(notification.extras); // Instead of Builder.setStyle(style).
+
+        Notification.CallStyle callStyle = Notification.CallStyle.forOngoingCall(
+                        personWithIcon(""content://caller""),
+                        PendingIntent.getActivity(mContext, 0, new Intent(),
+                                PendingIntent.FLAG_IMMUTABLE))
+                .setVerificationIcon(Icon.createWithContentUri(""content://callVerification""));
+        callStyle.addExtras(notification.extras); // Same.
+
+        Consumer<Uri> visitor = (Consumer<Uri>) spy(Consumer.class);
+        notification.visitUris(visitor);
+
+        verify(visitor).accept(eq(Uri.parse(""content://user"")));
+        verify(visitor).accept(eq(Uri.parse(""content://historicalMessenger"")));
+        verify(visitor).accept(eq(Uri.parse(""content://messenger"")));
+        verify(visitor).accept(eq(Uri.parse(""content://conversationShortcut"")));
+        verify(visitor).accept(eq(Uri.parse(""content://caller"")));
+        verify(visitor).accept(eq(Uri.parse(""content://callVerification"")));
+    }
+
+    private static Person personWithIcon(String iconUri) {
+        return new Person.Builder()
+                .setName(""Mr "" + iconUri)
+                .setIcon(Icon.createWithContentUri(iconUri))
+                .build();
+    }
+
     @Test
     public void testVisitUris_wearableExtender() {
         Icon actionIcon = Icon.createWithContentUri(""content://media/action"");
",43,0,"NotificationManagerServiceTest::personWithIcon, NotificationManagerServiceTest::testVisitUris_styleExtrasWithoutStyle"
381,547b1d1ba0eecc25c98ae61e3d55903d0fc8d5bb,PersistableBundle.java,"@@ -21,6 +21,7 @@ import static java.nio.charset.StandardCharsets.UTF_8;
 import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.util.ArrayMap;
+import android.util.Slog;
 import android.util.TypedXmlPullParser;
 import android.util.TypedXmlSerializer;
 import android.util.Xml;
@@ -46,6 +47,8 @@ import java.util.ArrayList;
  */
 public final class PersistableBundle extends BaseBundle implements Cloneable, Parcelable,
         XmlUtils.WriteMapCallback {
+    private static final String TAG = ""PersistableBundle"";
+
     private static final String TAG_PERSISTABLEMAP = ""pbundle_as_map"";
 
     /** An unmodifiable {@code PersistableBundle} that is always {@link #isEmpty() empty}. */
@@ -110,7 +113,11 @@ public final class PersistableBundle extends BaseBundle implements Cloneable, Pa
      * @hide
      */
     public PersistableBundle(Bundle b) {
-        this(b.getMap());
+        this(b, true);
+    }
+
+    private PersistableBundle(Bundle b, boolean throwException) {
+        this(b.getMap(), throwException);
     }
 
     /**
@@ -119,7 +126,7 @@ public final class PersistableBundle extends BaseBundle implements Cloneable, Pa
      * @param map a Map containing only those items that can be persisted.
      * @throws IllegalArgumentException if any element of #map cannot be persisted.
      */
-    private PersistableBundle(ArrayMap<String, Object> map) {
+    private PersistableBundle(ArrayMap<String, Object> map, boolean throwException) {
         super();
         mFlags = FLAG_DEFUSABLE;
 
@@ -128,16 +135,23 @@ public final class PersistableBundle extends BaseBundle implements Cloneable, Pa
 
         // Now verify each item throwing an exception if there is a violation.
         final int N = mMap.size();
-        for (int i=0; i<N; i++) {
+        for (int i = N - 1; i >= 0; --i) {
             Object value = mMap.valueAt(i);
             if (value instanceof ArrayMap) {
                 // Fix up any Maps by replacing them with PersistableBundles.
-                mMap.setValueAt(i, new PersistableBundle((ArrayMap<String, Object>) value));
+                mMap.setValueAt(i,
+                        new PersistableBundle((ArrayMap<String, Object>) value, throwException));
             } else if (value instanceof Bundle) {
-                mMap.setValueAt(i, new PersistableBundle(((Bundle) value)));
+                mMap.setValueAt(i, new PersistableBundle((Bundle) value, throwException));
             } else if (!isValidType(value)) {
-                throw new IllegalArgumentException(""Bad value in PersistableBundle key=""
-                        + mMap.keyAt(i) + "" value="" + value);
+                final String errorMsg = ""Bad value in PersistableBundle key=""
+                        + mMap.keyAt(i) + "" value="" + value;
+                if (throwException) {
+                    throw new IllegalArgumentException(errorMsg);
+                } else {
+                    Slog.wtfStack(TAG, errorMsg);
+                    mMap.removeAt(i);
+                }
             }
         }
     }
@@ -257,6 +271,15 @@ public final class PersistableBundle extends BaseBundle implements Cloneable, Pa
     /** @hide */
     public void saveToXml(TypedXmlSerializer out) throws IOException, XmlPullParserException {
         unparcel();
+        // Explicitly drop invalid types an attacker may have added before persisting.
+        for (int i = mMap.size() - 1; i >= 0; --i) {
+            final Object value = mMap.valueAt(i);
+            if (!isValidType(value)) {
+                Slog.e(TAG, ""Dropping bad data before persisting: ""
+                        + mMap.keyAt(i) + ""="" + value);
+                mMap.removeAt(i);
+            }
+        }
         XmlUtils.writeMapXml(mMap, out, this);
     }
 
@@ -311,9 +334,12 @@ public final class PersistableBundle extends BaseBundle implements Cloneable, Pa
         while (((event = in.next()) != XmlPullParser.END_DOCUMENT) &&
                 (event != XmlPullParser.END_TAG || in.getDepth() < outerDepth)) {
             if (event == XmlPullParser.START_TAG) {
+                // Don't throw an exception when restoring from XML since an attacker could try to
+                // input invalid data in the persisted file.
                 return new PersistableBundle((ArrayMap<String, Object>)
                         XmlUtils.readThisArrayMapXml(in, startTag, tagName,
-                        new MyReadMapCallback()));
+                        new MyReadMapCallback()),
+                        /* throwException */ false);
             }
         }
         return EMPTY;
",34,8,"PersistableBundle::PersistableBundle, PersistableBundle::saveToXml, PersistableBundle::PersistableBundle, PersistableBundle::PersistableBundle, PersistableBundle::PersistableBundle, PersistableBundle::restoreFromXml"
382,d8f3301840a28985d71438a7924bb884f36e8dbe,ShortcutService.java,"@@ -34,6 +34,7 @@ import android.app.usage.UsageStatsManagerInternal;
 import android.appwidget.AppWidgetProviderInfo;
 import android.content.BroadcastReceiver;
 import android.content.ComponentName;
+import android.content.ContentProvider;
 import android.content.Context;
 import android.content.Intent;
 import android.content.IntentFilter;
@@ -1900,11 +1901,32 @@ public class ShortcutService extends IShortcutService.Stub {
         }
         if (shortcut.getIcon() != null) {
             ShortcutInfo.validateIcon(shortcut.getIcon());
+            validateIconURI(shortcut);
         }
 
         shortcut.replaceFlags(shortcut.getFlags() & ShortcutInfo.FLAG_LONG_LIVED);
     }
 
+    // Validates the calling process has permission to access shortcut icon's image uri
+    private void validateIconURI(@NonNull final ShortcutInfo si) {
+        final int callingUid = injectBinderCallingUid();
+        final Icon icon = si.getIcon();
+        if (icon == null) {
+            // There's no icon in this shortcut, nothing to validate here.
+            return;
+        }
+        int iconType = icon.getType();
+        if (iconType != Icon.TYPE_URI && iconType != Icon.TYPE_URI_ADAPTIVE_BITMAP) {
+            // The icon is not URI-based, nothing to validate.
+            return;
+        }
+        final Uri uri = icon.getUri();
+        mUriGrantsManagerInternal.checkGrantUriPermission(callingUid, si.getPackage(),
+                ContentProvider.getUriWithoutUserId(uri),
+                Intent.FLAG_GRANT_READ_URI_PERMISSION,
+                ContentProvider.getUserIdFromUri(uri, UserHandle.getUserId(callingUid)));
+    }
+
     private void fixUpIncomingShortcutInfo(@NonNull ShortcutInfo shortcut, boolean forUpdate) {
         fixUpIncomingShortcutInfo(shortcut, forUpdate, /*forPinRequest=*/ false);
     }
",22,0,"ShortcutService::validateIconURI, ShortcutService::fixUpIncomingShortcutInfo"
383,9c0e09e708a704425e0acca6a75341f740c8fa70,NotificationsModule.java,"@@ -21,6 +21,7 @@ import android.content.Context;
 import android.content.pm.LauncherApps;
 import android.content.pm.ShortcutManager;
 import android.os.Handler;
+import android.os.UserManager;
 import android.view.accessibility.AccessibilityManager;
 
 import com.android.internal.logging.UiEventLogger;
@@ -144,6 +145,7 @@ public interface NotificationsModule {
             HighPriorityProvider highPriorityProvider,
             INotificationManager notificationManager,
             NotificationEntryManager notificationEntryManager,
+            UserManager userManager,
             PeopleSpaceWidgetManager peopleSpaceWidgetManager,
             LauncherApps launcherApps,
             ShortcutManager shortcutManager,
@@ -164,6 +166,7 @@ public interface NotificationsModule {
                 highPriorityProvider,
                 notificationManager,
                 notificationEntryManager,
+                userManager,
                 peopleSpaceWidgetManager,
                 launcherApps,
                 shortcutManager,
",3,0,provideNotificationGutsManager
384,9c0e09e708a704425e0acca6a75341f740c8fa70,NotificationConversationInfo.java,"@@ -48,6 +48,7 @@ import android.os.Bundle;
 import android.os.Handler;
 import android.os.RemoteException;
 import android.os.UserHandle;
+import android.os.UserManager;
 import android.service.notification.StatusBarNotification;
 import android.text.TextUtils;
 import android.transition.ChangeBounds;
@@ -118,6 +119,8 @@ public class NotificationConversationInfo extends LinearLayout implements
     private NotificationGuts mGutsContainer;
     private OnConversationSettingsClickListener mOnConversationSettingsClickListener;
 
+    private UserManager mUm;
+
     @VisibleForTesting
     boolean mSkipPost = false;
     private int mActualHeight;
@@ -152,10 +155,12 @@ public class NotificationConversationInfo extends LinearLayout implements
         mPressedApply = true;
 
         // If the user selected Priority and the previous selection was not priority, show a
-        // People Tile add request.
+        // People Tile add request if for same profile group.
         if (mSelectedAction == ACTION_FAVORITE && getPriority() != mSelectedAction) {
             mShadeController.animateCollapsePanels();
-            mPeopleSpaceWidgetManager.requestPinAppWidget(mShortcutInfo, new Bundle());
+            if (mUm.isSameProfileGroup(UserHandle.USER_SYSTEM, mSbn.getNormalizedUserId())) {
+                mPeopleSpaceWidgetManager.requestPinAppWidget(mShortcutInfo, new Bundle());
+            }
         }
         mGutsContainer.closeControls(v, true);
     };
@@ -189,6 +194,7 @@ public class NotificationConversationInfo extends LinearLayout implements
             @Action int selectedAction,
             ShortcutManager shortcutManager,
             PackageManager pm,
+            UserManager um,
             PeopleSpaceWidgetManager peopleSpaceWidgetManager,
             INotificationManager iNotificationManager,
             OnUserInteractionCallback onUserInteractionCallback,
@@ -214,6 +220,7 @@ public class NotificationConversationInfo extends LinearLayout implements
         mEntry = entry;
         mSbn = entry.getSbn();
         mPm = pm;
+        mUm = um;
         mAppName = mPackageName;
         mOnSettingsClickListener = onSettingsClick;
         mNotificationChannel = notificationChannel;
",9,2,"NotificationConversationInfo::if, NotificationConversationInfo::bindNotification"
385,9c0e09e708a704425e0acca6a75341f740c8fa70,NotificationGutsManager.java,"@@ -31,6 +31,7 @@ import android.net.Uri;
 import android.os.Bundle;
 import android.os.Handler;
 import android.os.UserHandle;
+import android.os.UserManager;
 import android.provider.Settings;
 import android.service.notification.StatusBarNotification;
 import android.util.ArraySet;
@@ -127,6 +128,9 @@ public class NotificationGutsManager implements Dumpable, NotificationLifetimeEx
     private Runnable mOpenRunnable;
     private final INotificationManager mNotificationManager;
     private final PeopleSpaceWidgetManager mPeopleSpaceWidgetManager;
+
+    private final UserManager mUserManager;
+
     private final LauncherApps mLauncherApps;
     private final ShortcutManager mShortcutManager;
     private final UserContextProvider mContextTracker;
@@ -146,6 +150,7 @@ public class NotificationGutsManager implements Dumpable, NotificationLifetimeEx
             HighPriorityProvider highPriorityProvider,
             INotificationManager notificationManager,
             NotificationEntryManager notificationEntryManager,
+            UserManager userManager,
             PeopleSpaceWidgetManager peopleSpaceWidgetManager,
             LauncherApps launcherApps,
             ShortcutManager shortcutManager,
@@ -164,6 +169,7 @@ public class NotificationGutsManager implements Dumpable, NotificationLifetimeEx
         mAccessibilityManager = accessibilityManager;
         mHighPriorityProvider = highPriorityProvider;
         mNotificationManager = notificationManager;
+        mUserManager = userManager;
         mPeopleSpaceWidgetManager = peopleSpaceWidgetManager;
         mLauncherApps = launcherApps;
         mShortcutManager = shortcutManager;
@@ -491,6 +497,7 @@ public class NotificationGutsManager implements Dumpable, NotificationLifetimeEx
                 notificationInfoView.getSelectedAction(),
                 mShortcutManager,
                 pmUser,
+                mUserManager,
                 mPeopleSpaceWidgetManager,
                 mNotificationManager,
                 mOnUserInteractionCallback,
",7,0,"NotificationGutsManager::initializeConversationNotificationInfo, NotificationGutsManager::NotificationGutsManager"
386,9c0e09e708a704425e0acca6a75341f740c8fa70,NotificationConversationInfoTest.java,"@@ -62,6 +62,7 @@ import android.graphics.drawable.Drawable;
 import android.graphics.drawable.Icon;
 import android.os.Handler;
 import android.os.UserHandle;
+import android.os.UserManager;
 import android.service.notification.StatusBarNotification;
 import android.test.suitebuilder.annotation.SmallTest;
 import android.testing.AndroidTestingRunner;
@@ -132,6 +133,8 @@ public class NotificationConversationInfoTest extends SysuiTestCase {
     @Mock
     private PackageManager mMockPackageManager;
     @Mock
+    private UserManager mUserManager;
+    @Mock
     private OnUserInteractionCallback mOnUserInteractionCallback;
     @Mock
     private BubblesManager mBubblesManager;
@@ -239,6 +242,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {
                 -1,
                 mShortcutManager,
                 mMockPackageManager,
+                mUserManager,
                 mPeopleSpaceWidgetManager,
                 mMockINotificationManager,
                 mOnUserInteractionCallback,
@@ -264,6 +268,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {
                 -1,
                 mShortcutManager,
                 mMockPackageManager,
+                mUserManager,
                 mPeopleSpaceWidgetManager,
                 mMockINotificationManager,
                 mOnUserInteractionCallback,
@@ -317,6 +322,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {
                 -1,
                 mShortcutManager,
                 mMockPackageManager,
+                mUserManager,
                 mPeopleSpaceWidgetManager,
                 mMockINotificationManager,
                 mOnUserInteractionCallback,
@@ -343,6 +349,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {
                 -1,
                 mShortcutManager,
                 mMockPackageManager,
+                mUserManager,
                 mPeopleSpaceWidgetManager,
                 mMockINotificationManager,
                 mOnUserInteractionCallback,
@@ -368,6 +375,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {
                 -1,
                 mShortcutManager,
                 mMockPackageManager,
+                mUserManager,
                 mPeopleSpaceWidgetManager,
                 mMockINotificationManager,
                 mOnUserInteractionCallback,
@@ -404,6 +412,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {
                 -1,
                 mShortcutManager,
                 mMockPackageManager,
+                mUserManager,
                 mPeopleSpaceWidgetManager,
                 mMockINotificationManager,
                 mOnUserInteractionCallback,
@@ -430,6 +439,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {
                 -1,
                 mShortcutManager,
                 mMockPackageManager,
+                mUserManager,
                 mPeopleSpaceWidgetManager,
                 mMockINotificationManager,
                 mOnUserInteractionCallback,
@@ -460,6 +470,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {
                 -1,
                 mShortcutManager,
                 mMockPackageManager,
+                mUserManager,
                 mPeopleSpaceWidgetManager,
                 mMockINotificationManager,
                 mOnUserInteractionCallback,
@@ -485,6 +496,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {
                 -1,
                 mShortcutManager,
                 mMockPackageManager,
+                mUserManager,
                 mPeopleSpaceWidgetManager,
                 mMockINotificationManager,
                 mOnUserInteractionCallback,
@@ -514,6 +526,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {
                 -1,
                 mShortcutManager,
                 mMockPackageManager,
+                mUserManager,
                 mPeopleSpaceWidgetManager,
                 mMockINotificationManager,
                 mOnUserInteractionCallback,
@@ -543,6 +556,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {
                 -1,
                 mShortcutManager,
                 mMockPackageManager,
+                mUserManager,
                 mPeopleSpaceWidgetManager,
                 mMockINotificationManager,
                 mOnUserInteractionCallback,
@@ -575,6 +589,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {
                 -1,
                 mShortcutManager,
                 mMockPackageManager,
+                mUserManager,
                 mPeopleSpaceWidgetManager,
                 mMockINotificationManager,
                 mOnUserInteractionCallback,
@@ -613,6 +628,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {
                 -1,
                 mShortcutManager,
                 mMockPackageManager,
+                mUserManager,
                 mPeopleSpaceWidgetManager,
                 mMockINotificationManager,
                 mOnUserInteractionCallback,
@@ -642,6 +658,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {
                 -1,
                 mShortcutManager,
                 mMockPackageManager,
+                mUserManager,
                 mPeopleSpaceWidgetManager,
                 mMockINotificationManager,
                 mOnUserInteractionCallback,
@@ -678,6 +695,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {
                 -1,
                 mShortcutManager,
                 mMockPackageManager,
+                mUserManager,
                 mPeopleSpaceWidgetManager,
                 mMockINotificationManager,
                 mOnUserInteractionCallback,
@@ -707,6 +725,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {
                 -1,
                 mShortcutManager,
                 mMockPackageManager,
+                mUserManager,
                 mPeopleSpaceWidgetManager,
                 mMockINotificationManager,
                 mOnUserInteractionCallback,
@@ -752,6 +771,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {
                 -1,
                 mShortcutManager,
                 mMockPackageManager,
+                mUserManager,
                 mPeopleSpaceWidgetManager,
                 mMockINotificationManager,
                 mOnUserInteractionCallback,
@@ -796,6 +816,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {
                 -1,
                 mShortcutManager,
                 mMockPackageManager,
+                mUserManager,
                 mPeopleSpaceWidgetManager,
                 mMockINotificationManager,
                 mOnUserInteractionCallback,
@@ -841,6 +862,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {
                 -1,
                 mShortcutManager,
                 mMockPackageManager,
+                mUserManager,
                 mPeopleSpaceWidgetManager,
                 mMockINotificationManager,
                 mOnUserInteractionCallback,
@@ -879,6 +901,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {
                 -1,
                 mShortcutManager,
                 mMockPackageManager,
+                mUserManager,
                 mPeopleSpaceWidgetManager,
                 mMockINotificationManager,
                 mOnUserInteractionCallback,
@@ -916,6 +939,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {
                 -1,
                 mShortcutManager,
                 mMockPackageManager,
+                mUserManager,
                 mPeopleSpaceWidgetManager,
                 mMockINotificationManager,
                 mOnUserInteractionCallback,
@@ -957,6 +981,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {
                 -1, // no action selected by default
                 mShortcutManager,
                 mMockPackageManager,
+                mUserManager,
                 mPeopleSpaceWidgetManager,
                 mMockINotificationManager,
                 mOnUserInteractionCallback,
@@ -988,6 +1013,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {
                 NotificationConversationInfo.ACTION_FAVORITE, // ""Favorite"" selected by default
                 mShortcutManager,
                 mMockPackageManager,
+                mUserManager,
                 mPeopleSpaceWidgetManager,
                 mMockINotificationManager,
                 mOnUserInteractionCallback,
@@ -1018,6 +1044,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {
                 -1,
                 mShortcutManager,
                 mMockPackageManager,
+                mUserManager,
                 mPeopleSpaceWidgetManager,
                 mMockINotificationManager,
                 mOnUserInteractionCallback,
@@ -1055,6 +1082,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {
                 -1,
                 mShortcutManager,
                 mMockPackageManager,
+                mUserManager,
                 mPeopleSpaceWidgetManager,
                 mMockINotificationManager,
                 mOnUserInteractionCallback,
@@ -1092,6 +1120,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {
                 -1,
                 mShortcutManager,
                 mMockPackageManager,
+                mUserManager,
                 mPeopleSpaceWidgetManager,
                 mMockINotificationManager,
                 mOnUserInteractionCallback,
@@ -1128,6 +1157,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {
                 -1,
                 mShortcutManager,
                 mMockPackageManager,
+                mUserManager,
                 mPeopleSpaceWidgetManager,
                 mMockINotificationManager,
                 mOnUserInteractionCallback,
@@ -1163,6 +1193,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {
                 -1,
                 mShortcutManager,
                 mMockPackageManager,
+                mUserManager,
                 mPeopleSpaceWidgetManager,
                 mMockINotificationManager,
                 mOnUserInteractionCallback,
@@ -1189,6 +1220,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {
                 -1,
                 mShortcutManager,
                 mMockPackageManager,
+                mUserManager,
                 mPeopleSpaceWidgetManager,
                 mMockINotificationManager,
                 mOnUserInteractionCallback,
@@ -1210,12 +1242,14 @@ public class NotificationConversationInfoTest extends SysuiTestCase {
 
     @Test
     public void testSelectPriorityRequestsPinPeopleTile() {
+        when(mUserManager.isSameProfileGroup(anyInt(), anyInt())).thenReturn(true);
         //WHEN channel is default importance
         mNotificationChannel.setImportantConversation(false);
         mNotificationInfo.bindNotification(
                 -1,
                 mShortcutManager,
                 mMockPackageManager,
+                mUserManager,
                 mPeopleSpaceWidgetManager,
                 mMockINotificationManager,
                 mOnUserInteractionCallback,
@@ -1241,12 +1275,48 @@ public class NotificationConversationInfoTest extends SysuiTestCase {
         verify(mPeopleSpaceWidgetManager, times(1)).requestPinAppWidget(any(), any());
     }
 
+    @Test
+    public void testSelectPriorityRequestsPinPeopleTile_noMultiuser() {
+        when(mUserManager.isSameProfileGroup(anyInt(), anyInt())).thenReturn(false);
+        //WHEN channel is default importance
+        mNotificationChannel.setImportantConversation(false);
+        mNotificationInfo.bindNotification(
+                -1,
+                mShortcutManager,
+                mMockPackageManager,
+                mUserManager,
+                mPeopleSpaceWidgetManager,
+                mMockINotificationManager,
+                mOnUserInteractionCallback,
+                TEST_PACKAGE_NAME,
+                mNotificationChannel,
+                mEntry,
+                mBubbleMetadata,
+                null,
+                mIconFactory,
+                mContext,
+                true,
+                mTestHandler,
+                mTestHandler, null, Optional.of(mBubblesManager),
+                mShadeController);
+
+        // WHEN user clicks ""priority""
+        mNotificationInfo.setSelectedAction(NotificationConversationInfo.ACTION_FAVORITE);
+
+        // and then done
+        mNotificationInfo.findViewById(R.id.done).performClick();
+
+        // No widget prompt; on a secondary user
+        verify(mPeopleSpaceWidgetManager, never()).requestPinAppWidget(any(), any());
+    }
+
     @Test
     public void testSelectDefaultDoesNotRequestPinPeopleTile() {
         mNotificationInfo.bindNotification(
                 -1,
                 mShortcutManager,
                 mMockPackageManager,
+                mUserManager,
                 mPeopleSpaceWidgetManager,
                 mMockINotificationManager,
                 mOnUserInteractionCallback,
@@ -1282,6 +1352,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {
                 -1,
                 mShortcutManager,
                 mMockPackageManager,
+                mUserManager,
                 mPeopleSpaceWidgetManager,
                 mMockINotificationManager,
                 mOnUserInteractionCallback,
",71,0,"NotificationConversationInfoTest::testBindNotification_priorityDndAndBubble, NotificationConversationInfoTest::testDefault_andSave, NotificationConversationInfoTest::testSelectPriorityRequestsPinPeopleTile_noMultiuser, NotificationConversationInfoTest::testBindNotification_SetsTextApplicationName, NotificationConversationInfoTest::testSilence_andSave, NotificationConversationInfoTest::testBindNotification_SetsTextGroupName, NotificationConversationInfoTest::testBindNotification_default_allCanBubble, NotificationConversationInfoTest::testSelectDefaultDoesNotRequestPinPeopleTile, NotificationConversationInfoTest::testBindNotification_doesNotCreateNewChannelIfExists, NotificationConversationInfoTest::testFavorite, NotificationConversationInfoTest::testBindNotification_SetsShortcutIcon, NotificationConversationInfoTest::testSilence, NotificationConversationInfoTest::testBindNotification_createsNewChannel, NotificationConversationInfoTest::testDefaultSelectedWhenChannelIsDefault, NotificationConversationInfoTest::testDefault_andSave_doesNotChangeNonImportantBubbling, NotificationConversationInfoTest::testBindNotification_SettingsButtonInvisibleWhenNoClickListener, NotificationConversationInfoTest::testBindNotification_priorityBaseline, NotificationConversationInfoTest::testBindNotification_priorityDnd, NotificationConversationInfoTest::testBindNotification_delegate, NotificationConversationInfoTest::testBindNotification_silentSelected_isFave_isSilent, NotificationConversationInfoTest::testFavoriteSelectedWhenChannelIsDefault, NotificationConversationInfoTest::testBindNotification_defaultSelected_notFave_notSilent, NotificationConversationInfoTest::testBindNotification_GroupNameHiddenIfNoGroup, NotificationConversationInfoTest::testDefault_andSave_doesNotDemoteImportance, NotificationConversationInfoTest::testSelectPriorityRequestsPinPeopleTile, NotificationConversationInfoTest::testBindNotification_noDelegate, NotificationConversationInfoTest::testFavorite_thenDefaultThenFavorite_andSave_nothingChanged, NotificationConversationInfoTest::testBindNotification_SetsOnClickListenerForSettings, NotificationConversationInfoTest::testSelectPriority_AlreadyPriority_DoesNotRequestPinPeopleTile, NotificationConversationInfoTest::testBindNotification_SettingsButtonInvisibleWhenDeviceUnprovisioned, NotificationConversationInfoTest::testFavorite_andSave, NotificationConversationInfoTest::testDefault, NotificationConversationInfoTest::testFavorite_andSave_doesNotLowerImportance"
387,9c0e09e708a704425e0acca6a75341f740c8fa70,NotificationGutsManagerTest.java,"@@ -54,6 +54,7 @@ import android.content.pm.ShortcutManager;
 import android.graphics.Color;
 import android.os.Binder;
 import android.os.Handler;
+import android.os.UserManager;
 import android.provider.Settings;
 import android.service.notification.StatusBarNotification;
 import android.testing.AndroidTestingRunner;
@@ -139,6 +140,8 @@ public class NotificationGutsManagerTest extends SysuiTestCase {
     @Mock private PeopleSpaceWidgetManager mPeopleSpaceWidgetManager;
     @Mock private AssistantFeedbackController mAssistantFeedbackController;
 
+    @Mock private UserManager mUserManager;
+
     @Before
     public void setUp() {
         mTestableLooper = TestableLooper.get(this);
@@ -156,7 +159,8 @@ public class NotificationGutsManagerTest extends SysuiTestCase {
 
         mGutsManager = new NotificationGutsManager(mContext,
                 () -> Optional.of(mStatusBar), mHandler, mHandler, mAccessibilityManager,
-                mHighPriorityProvider, mINotificationManager, mNotificationEntryManager,
+                mHighPriorityProvider, mINotificationManager, mUserManager,
+                mNotificationEntryManager,
                 mPeopleSpaceWidgetManager, mLauncherApps, mShortcutManager,
                 mChannelEditorDialogController, mContextTracker, mAssistantFeedbackController,
                 Optional.of(mBubblesManager), new UiEventLoggerFake(), mOnUserInteractionCallback,
",5,1,NotificationGutsManagerTest::setUp
388,969e47613b43d0a281aae08cb0766da7035921f9,ActivityTaskManagerService.java,"@@ -18,6 +18,7 @@ package com.android.server.wm;
 
 import static android.Manifest.permission.BIND_VOICE_INTERACTION;
 import static android.Manifest.permission.CHANGE_CONFIGURATION;
+import static android.Manifest.permission.CONTROL_KEYGUARD;
 import static android.Manifest.permission.CONTROL_REMOTE_APP_TRANSITION_ANIMATIONS;
 import static android.Manifest.permission.INTERACT_ACROSS_USERS;
 import static android.Manifest.permission.INTERACT_ACROSS_USERS_FULL;
@@ -3378,6 +3379,7 @@ public class ActivityTaskManagerService extends IActivityTaskManager.Stub {
 
     @Override
     public void keyguardGoingAway(int flags) {
+        mAmInternal.enforceCallingPermission(CONTROL_KEYGUARD, ""unlock keyguard"");
         enforceNotIsolatedCaller(""keyguardGoingAway"");
         final long token = Binder.clearCallingIdentity();
         try {
",2,0,ActivityTaskManagerService::keyguardGoingAway
389,aff1a9b475c4d8c1df92a600b809c55618b55ad1,ShortcutPackage.java,"@@ -359,6 +359,7 @@ class ShortcutPackage extends ShortcutPackageItem {
         // Extract Icon and update the icon res ID and the bitmap path.
         s.saveIconAndFixUpShortcutLocked(newShortcut);
         s.fixUpShortcutResourceNamesAndValues(newShortcut);
+        ensureShortcutCountBeforePush();
         saveShortcut(newShortcut);
     }
 
@@ -405,7 +406,6 @@ class ShortcutPackage extends ShortcutPackageItem {
             @NonNull List<ShortcutInfo> changedShortcuts) {
         Preconditions.checkArgument(newShortcut.isEnabled(),
                 ""pushDynamicShortcuts() cannot publish disabled shortcuts"");
-        ensureShortcutCountBeforePush();
 
         newShortcut.addFlags(ShortcutInfo.FLAG_DYNAMIC);
 
",1,1,"ShortcutPackage::pushDynamicShortcut, ShortcutPackage::forceReplaceShortcutInner"
390,7f725d0750df7184351c3553f7cf66de3c6ad050,ShortcutService.java,"@@ -1733,6 +1733,10 @@ public class ShortcutService extends IShortcutService.Stub {
             android.util.EventLog.writeEvent(0x534e4554, ""109824443"", -1, """");
             throw new SecurityException(""Shortcut package name mismatch"");
         }
+        final int callingUid = injectBinderCallingUid();
+        if (UserHandle.getUserId(callingUid) != si.getUserId()) {
+            throw new SecurityException(""User-ID in shortcut doesn't match the caller"");
+        }
     }
 
     private void verifyShortcutInfoPackages(
",4,0,ShortcutService::verifyShortcutInfoPackage
391,c3594639ce04fa5e84136a01cc1aa65eeb0b8705,KeyguardViewMediator.java,"@@ -677,13 +677,6 @@ public class KeyguardViewMediator extends SystemUI implements Dumpable,
                 }
             }
         }
-
-        @Override
-        public void onStrongAuthStateChanged(int userId) {
-            if (mLockPatternUtils.isUserInLockdown(KeyguardUpdateMonitor.getCurrentUser())) {
-                doKeyguardLocked(null);
-            }
-        }
     };
 
     ViewMediatorCallback mViewMediatorCallback = new ViewMediatorCallback() {
@@ -1542,8 +1535,7 @@ public class KeyguardViewMediator extends SystemUI implements Dumpable,
         }
 
         // if another app is disabling us, don't show
-        if (!mExternallyEnabled
-            && !mLockPatternUtils.isUserInLockdown(KeyguardUpdateMonitor.getCurrentUser())) {
+        if (!mExternallyEnabled) {
             if (DEBUG) Log.d(TAG, ""doKeyguard: not showing because externally disabled"");
 
             mNeedToReshowWhenReenabled = true;
",1,9,"KeyguardViewMediator::doKeyguardLocked, KeyguardViewMediator::KeyguardUpdateMonitorCallback"
392,5a1c2d06321754ec065bf15fbe4208e89a0a15db,ActivityManagerService.java,"@@ -8715,6 +8715,13 @@ public class ActivityManagerService extends IActivityManager.Stub
     public void onShellCommand(FileDescriptor in, FileDescriptor out,
             FileDescriptor err, String[] args, ShellCallback callback,
             ResultReceiver resultReceiver) {
+        final int callingUid = Binder.getCallingUid();
+        if (callingUid != ROOT_UID && callingUid != Process.SHELL_UID) {
+            if (resultReceiver != null) {
+                resultReceiver.send(-1, null);
+            }
+            throw new SecurityException(""Shell commands are only callable by root or shell"");
+        }
         (new ActivityManagerShellCommand(this, false)).exec(
                 this, in, out, err, args, callback, resultReceiver);
     }
",7,0,ActivityManagerService::onShellCommand
393,b452af38180ad07b3e8dd239a9a5193c8e87c40b,KeyguardViewMediator.java,"@@ -669,6 +669,13 @@ public class KeyguardViewMediator extends SystemUI implements Dumpable,
             }
         }
 
+        @Override
+        public void onStrongAuthStateChanged(int userId) {
+            if (mLockPatternUtils.isUserInLockdown(KeyguardUpdateMonitor.getCurrentUser())) {
+                doKeyguardLocked(null);
+            }
+        }
+
         @Override
         public void onTrustChanged(int userId) {
             if (userId == KeyguardUpdateMonitor.getCurrentUser()) {
@@ -1318,6 +1325,10 @@ public class KeyguardViewMediator extends SystemUI implements Dumpable,
             mExternallyEnabled = enabled;
 
             if (!enabled && mShowing) {
+                if (mLockPatternUtils.isUserInLockdown(KeyguardUpdateMonitor.getCurrentUser())) {
+                    Log.d(TAG, ""keyguardEnabled(false) overridden by user lockdown"");
+                    return;
+                }
                 if (mExitSecureCallback != null) {
                     if (DEBUG) Log.d(TAG, ""in process of verifyUnlock request, ignoring"");
                     // we're in the process of handling a request to verify the user
@@ -1534,8 +1545,9 @@ public class KeyguardViewMediator extends SystemUI implements Dumpable,
             return;
         }
 
-        // if another app is disabling us, don't show
-        if (!mExternallyEnabled) {
+        // if another app is disabling us, don't show unless we're in lockdown mode
+        if (!mExternallyEnabled
+                && !mLockPatternUtils.isUserInLockdown(KeyguardUpdateMonitor.getCurrentUser())) {
             if (DEBUG) Log.d(TAG, ""doKeyguard: not showing because externally disabled"");
 
             mNeedToReshowWhenReenabled = true;
",14,2,"KeyguardViewMediator::doKeyguardLocked, KeyguardViewMediator::KeyguardUpdateMonitorCallback, KeyguardViewMediator::setKeyguardEnabled"
394,29eaa0200523318863847f51deab2f71cde71884,UriGrantsManagerService.java,"@@ -41,6 +41,7 @@ import static org.xmlpull.v1.XmlPullParser.START_TAG;
 
 import android.annotation.NonNull;
 import android.annotation.Nullable;
+import android.annotation.RequiresPermission;
 import android.app.ActivityManager;
 import android.app.ActivityManagerInternal;
 import android.app.AppGlobals;
@@ -62,6 +63,7 @@ import android.os.Handler;
 import android.os.IBinder;
 import android.os.Looper;
 import android.os.Message;
+import android.os.Process;
 import android.os.RemoteException;
 import android.os.SystemClock;
 import android.os.UserHandle;
@@ -1302,6 +1304,46 @@ public class UriGrantsManagerService extends IUriGrantsManager.Stub {
         return false;
     }
 
+    /**
+     * Check if the targetPkg can be granted permission to access uri by
+     * the callingUid using the given modeFlags. See {@link #checkGrantUriPermissionUnlocked}.
+     *
+     * @param callingUid The uid of the grantor app that has permissions to the uri.
+     * @param targetPkg The package name of the granted app that needs permissions to the uri.
+     * @param uri The uri for which permissions should be granted.
+     * @param modeFlags The modes to grant. See {@link Intent#FLAG_GRANT_READ_URI_PERMISSION}, etc.
+     * @param userId The userId in which the uri is to be resolved.
+     * @return uid of the target or -1 if permission grant not required. Returns -1 if the caller
+     *  does not hold INTERACT_ACROSS_USERS_FULL
+     * @throws SecurityException if the grant is not allowed.
+     */
+    @Override
+    @RequiresPermission(android.Manifest.permission.INTERACT_ACROSS_USERS_FULL)
+    public int checkGrantUriPermission_ignoreNonSystem(int callingUid, String targetPkg, Uri uri,
+            int modeFlags, int userId) {
+        if (!isCallerIsSystemOrPrivileged()) {
+            return Process.INVALID_UID;
+        }
+        final long origId = Binder.clearCallingIdentity();
+        try {
+            return checkGrantUriPermissionUnlocked(callingUid, targetPkg, uri, modeFlags,
+                    userId);
+        } finally {
+            Binder.restoreCallingIdentity(origId);
+        }
+    }
+
+    private boolean isCallerIsSystemOrPrivileged() {
+        final int uid = Binder.getCallingUid();
+        if (uid == Process.SYSTEM_UID || uid == Process.ROOT_UID) {
+            return true;
+        }
+        return ActivityManager.checkComponentPermission(
+                android.Manifest.permission.INTERACT_ACROSS_USERS_FULL,
+                uid, /* owningUid = */-1, /* exported = */ true)
+                == PackageManager.PERMISSION_GRANTED;
+    }
+
     @GuardedBy(""mLock"")
     private void writeGrantedUriPermissionsLocked() {
         if (DEBUG) Slog.v(TAG, ""writeGrantedUriPermissions()"");
",42,0,"UriGrantsManagerService::checkGrantUriPermission_ignoreNonSystem, UriGrantsManagerService::isCallerIsSystemOrPrivileged"
395,1bc3a825d92aa35c46083d767d2d1cd29abf2252,KeyguardSecurityContainerController.java,"@@ -426,7 +426,7 @@ public class KeyguardSecurityContainerController extends ViewController<Keyguard
                 case SimPuk:
                     // Shortcut for SIM PIN/PUK to go to directly to user's security screen or home
                     SecurityMode securityMode = mSecurityModel.getSecurityMode(targetUserId);
-                    if (securityMode == SecurityMode.None && mLockPatternUtils.isLockScreenDisabled(
+                    if (securityMode == SecurityMode.None || mLockPatternUtils.isLockScreenDisabled(
                             KeyguardUpdateMonitor.getCurrentUser())) {
                         finish = true;
                         eventSubtype = BOUNCER_DISMISS_SIM;
",1,1,KeyguardSecurityContainerController::showNextSecurityScreenOrFinish
396,10e9c09cde3bbe154d88b7507c23fc79360c89b5,KeyguardSecurityContainerController.java,"@@ -54,6 +54,7 @@ import com.android.systemui.R;
 import com.android.systemui.classifier.FalsingCollector;
 import com.android.systemui.shared.system.SysUiStatsLog;
 import com.android.systemui.statusbar.policy.ConfigurationController;
+import com.android.systemui.statusbar.policy.DeviceProvisionedController;
 import com.android.systemui.statusbar.policy.KeyguardStateController;
 import com.android.systemui.util.ViewController;
 
@@ -221,6 +222,7 @@ public class KeyguardSecurityContainerController extends ViewController<Keyguard
                     mSecurityViewFlipperController.reloadColors();
                 }
             };
+    private final DeviceProvisionedController mDeviceProvisionedController;
 
     private KeyguardSecurityContainerController(KeyguardSecurityContainer view,
             AdminSecondaryLockScreenController.Factory adminSecondaryLockScreenControllerFactory,
@@ -233,6 +235,7 @@ public class KeyguardSecurityContainerController extends ViewController<Keyguard
             SecurityCallback securityCallback,
             KeyguardSecurityViewFlipperController securityViewFlipperController,
             ConfigurationController configurationController,
+            DeviceProvisionedController deviceProvisionedController,
             FalsingCollector falsingCollector) {
         super(view);
         mLockPatternUtils = lockPatternUtils;
@@ -247,6 +250,7 @@ public class KeyguardSecurityContainerController extends ViewController<Keyguard
                 mKeyguardSecurityCallback);
         mConfigurationController = configurationController;
         mLastOrientation = getResources().getConfiguration().orientation;
+        mDeviceProvisionedController = deviceProvisionedController;
         mFalsingCollector = falsingCollector;
     }
 
@@ -426,8 +430,11 @@ public class KeyguardSecurityContainerController extends ViewController<Keyguard
                 case SimPuk:
                     // Shortcut for SIM PIN/PUK to go to directly to user's security screen or home
                     SecurityMode securityMode = mSecurityModel.getSecurityMode(targetUserId);
-                    if (securityMode == SecurityMode.None || mLockPatternUtils.isLockScreenDisabled(
-                            KeyguardUpdateMonitor.getCurrentUser())) {
+                    boolean isLockscreenDisabled = mLockPatternUtils.isLockScreenDisabled(
+                            KeyguardUpdateMonitor.getCurrentUser())
+                            || !mDeviceProvisionedController.isUserSetup(targetUserId);
+
+                    if (securityMode == SecurityMode.None && isLockscreenDisabled) {
                         finish = true;
                         eventSubtype = BOUNCER_DISMISS_SIM;
                         uiEvent = BouncerUiEvent.BOUNCER_DISMISS_SIM;
@@ -625,6 +632,7 @@ public class KeyguardSecurityContainerController extends ViewController<Keyguard
         private final KeyguardStateController mKeyguardStateController;
         private final KeyguardSecurityViewFlipperController mSecurityViewFlipperController;
         private final ConfigurationController mConfigurationController;
+        private final DeviceProvisionedController mDeviceProvisionedController;
         private final FalsingCollector mFalsingCollector;
 
         @Inject
@@ -639,6 +647,7 @@ public class KeyguardSecurityContainerController extends ViewController<Keyguard
                 KeyguardStateController keyguardStateController,
                 KeyguardSecurityViewFlipperController securityViewFlipperController,
                 ConfigurationController configurationController,
+                DeviceProvisionedController deviceProvisionedController,
                 FalsingCollector falsingCollector) {
             mView = view;
             mAdminSecondaryLockScreenControllerFactory = adminSecondaryLockScreenControllerFactory;
@@ -650,6 +659,7 @@ public class KeyguardSecurityContainerController extends ViewController<Keyguard
             mKeyguardStateController = keyguardStateController;
             mSecurityViewFlipperController = securityViewFlipperController;
             mConfigurationController = configurationController;
+            mDeviceProvisionedController = deviceProvisionedController;
             mFalsingCollector = falsingCollector;
         }
 
@@ -659,7 +669,7 @@ public class KeyguardSecurityContainerController extends ViewController<Keyguard
                     mAdminSecondaryLockScreenControllerFactory, mLockPatternUtils,
                     mKeyguardUpdateMonitor, mKeyguardSecurityModel, mMetricsLogger, mUiEventLogger,
                     mKeyguardStateController, securityCallback, mSecurityViewFlipperController,
-                    mConfigurationController, mFalsingCollector);
+                    mConfigurationController, mDeviceProvisionedController, mFalsingCollector);
         }
 
     }
",13,3,"KeyguardSecurityContainerController::showNextSecurityScreenOrFinish, KeyguardSecurityContainerController::Factory::Factory, KeyguardSecurityContainerController::Factory::create, KeyguardSecurityContainerController::KeyguardSecurityContainerController"
397,10e9c09cde3bbe154d88b7507c23fc79360c89b5,KeyguardSecurityContainerControllerTest.java,"@@ -50,6 +50,7 @@ import com.android.systemui.R;
 import com.android.systemui.SysuiTestCase;
 import com.android.systemui.classifier.FalsingCollector;
 import com.android.systemui.statusbar.policy.ConfigurationController;
+import com.android.systemui.statusbar.policy.DeviceProvisionedController;
 import com.android.systemui.statusbar.policy.KeyguardStateController;
 
 import org.junit.Before;
@@ -143,7 +144,7 @@ public class KeyguardSecurityContainerControllerTest extends SysuiTestCase {
                 mView, mAdminSecondaryLockScreenControllerFactory, mLockPatternUtils,
                 mKeyguardUpdateMonitor, mKeyguardSecurityModel, mMetricsLogger, mUiEventLogger,
                 mKeyguardStateController, mKeyguardSecurityViewFlipperController,
-                mConfigurationController, mFalsingCollector)
+                mConfigurationController, mock(DeviceProvisionedController.class)), mFalsingCollector)
                 .create(mSecurityCallback);
     }
 
",2,1,KeyguardSecurityContainerControllerTest::setup
398,a7c40fadfd053fec2fd5e76137e3953d8b433352,UserManagerService.java,"@@ -248,6 +248,8 @@ public class UserManagerService extends IUserManager.Stub {
 
     private static final int USER_VERSION = 9;
 
+    private static final int MAX_USER_STRING_LENGTH = 500;
+
     private static final long EPOCH_PLUS_30_YEARS = 30L * 365 * 24 * 60 * 60 * 1000L; // ms
 
     static final int WRITE_USER_MSG = 1;
@@ -3157,15 +3159,17 @@ public class UserManagerService extends IUserManager.Stub {
         // Write seed data
         if (userData.persistSeedData) {
             if (userData.seedAccountName != null) {
-                serializer.attribute(null, ATTR_SEED_ACCOUNT_NAME, userData.seedAccountName);
+                serializer.attribute(null, ATTR_SEED_ACCOUNT_NAME,
+                        truncateString(userData.seedAccountName));
             }
             if (userData.seedAccountType != null) {
-                serializer.attribute(null, ATTR_SEED_ACCOUNT_TYPE, userData.seedAccountType);
+                serializer.attribute(null, ATTR_SEED_ACCOUNT_TYPE,
+                        truncateString(userData.seedAccountType));
             }
         }
         if (userInfo.name != null) {
             serializer.startTag(null, TAG_NAME);
-            serializer.text(userInfo.name);
+            serializer.text(truncateString(userInfo.name));
             serializer.endTag(null, TAG_NAME);
         }
         synchronized (mRestrictionsLock) {
@@ -3205,6 +3209,13 @@ public class UserManagerService extends IUserManager.Stub {
         serializer.endDocument();
     }
 
+    private String truncateString(String original) {
+        if (original == null || original.length() <= MAX_USER_STRING_LENGTH) {
+            return original;
+        }
+        return original.substring(0, MAX_USER_STRING_LENGTH);
+    }
+
     /*
      * Writes the user list file in this format:
      *
@@ -3565,6 +3576,7 @@ public class UserManagerService extends IUserManager.Stub {
             boolean preCreate, @Nullable String[] disallowedPackages,
             @NonNull TimingsTraceAndSlog t, @Nullable Object token)
                     throws UserManager.CheckedUserOperationException {
+        String truncatedName = truncateString(name);
         final UserTypeDetails userTypeDetails = mUserTypes.get(userType);
         if (userTypeDetails == null) {
             Slog.e(LOG_TAG, ""Cannot create user of invalid user type: "" + userType);
@@ -3590,8 +3602,9 @@ public class UserManagerService extends IUserManager.Stub {
 
         // Try to use a pre-created user (if available).
         if (!preCreate && parentId < 0 && isUserTypeEligibleForPreCreation(userTypeDetails)) {
-            final UserInfo preCreatedUser = convertPreCreatedUserIfPossible(userType, flags, name,
-                    token);
+
+            final UserInfo preCreatedUser = convertPreCreatedUserIfPossible(userType, flags,
+                    truncatedName, token);
             if (preCreatedUser != null) {
                 return preCreatedUser;
             }
@@ -3684,7 +3697,7 @@ public class UserManagerService extends IUserManager.Stub {
                         flags &= ~UserInfo.FLAG_EPHEMERAL;
                     }
 
-                    userInfo = new UserInfo(userId, name, null, flags, userType);
+                    userInfo = new UserInfo(userId, truncatedName, null, flags, userType);
                     userInfo.serialNumber = mNextSerialNumber++;
                     userInfo.creationTime = getCreationTime();
                     userInfo.partial = true;
@@ -4983,8 +4996,8 @@ public class UserManagerService extends IUserManager.Stub {
                     Slog.e(LOG_TAG, ""No such user for settings seed data u="" + userId);
                     return;
                 }
-                userData.seedAccountName = accountName;
-                userData.seedAccountType = accountType;
+                userData.seedAccountName = truncateString(accountName);
+                userData.seedAccountType = truncateString(accountType);
                 userData.seedAccountOptions = accountOptions;
                 userData.persistSeedData = persist;
             }
",21,8,"UserManagerService::truncateString, UserManagerService::createUserInternalUncheckedNoTracing, UserManagerService::writeUserLP, UserManagerService::setSeedAccountData"
399,e7326f9d5b85ebabcac3fd2c726c78b64f0fcb64,CompanionDeviceManagerService.java,"@@ -172,6 +172,7 @@ public class CompanionDeviceManagerService extends SystemService implements Bind
 
     private static final int ASSOCIATE_WITHOUT_PROMPT_MAX_PER_TIME_WINDOW = 5;
     private static final long ASSOCIATE_WITHOUT_PROMPT_WINDOW_MS = 60 * 60 * 1000; // 60 min;
+    private static final int MAX_CN_LENGTH = 500;
 
     private static final String XML_TAG_ASSOCIATIONS = ""associations"";
     private static final String XML_TAG_ASSOCIATION = ""association"";
@@ -555,6 +556,9 @@ public class CompanionDeviceManagerService extends SystemService implements Bind
             String callingPackage = component.getPackageName();
             checkCanCallNotificationApi(callingPackage);
             int userId = getCallingUserId();
+            if (component.flattenToString().length() > MAX_CN_LENGTH) {
+                throw new IllegalArgumentException(""Component name is too long."");
+            }
             final long identity = Binder.clearCallingIdentity();
             try {
                 return PendingIntent.getActivityAsUser(getContext(),
",4,0,CompanionDeviceManagerService::CompanionDeviceManagerImpl::requestNotificationAccess
400,1e5b9954ad00d7de02b7b39854b72991ed20659f,AppOpsControllerImpl.java,"@@ -52,6 +52,7 @@ import java.io.FileDescriptor;
 import java.io.PrintWriter;
 import java.util.ArrayList;
 import java.util.List;
+import java.util.Map;
 import java.util.Set;
 
 import javax.inject.Inject;
@@ -144,6 +145,10 @@ public class AppOpsControllerImpl extends BroadcastReceiver implements AppOpsCon
     protected void setListening(boolean listening) {
         mListening = listening;
         if (listening) {
+            // System UI could be restarted while ops are active, so fetch the currently active ops
+            // once System UI starts listening again.
+            fetchCurrentActiveOps();
+
             mAppOps.startWatchingActive(OPS, this);
             mAppOps.startWatchingNoted(OPS, this);
             mAudioManager.registerAudioRecordingCallback(mAudioRecordingCallback, mBGHandler);
@@ -176,6 +181,29 @@ public class AppOpsControllerImpl extends BroadcastReceiver implements AppOpsCon
         }
     }
 
+    private void fetchCurrentActiveOps() {
+        List<AppOpsManager.PackageOps> packageOps = mAppOps.getPackagesForOps(OPS);
+        for (AppOpsManager.PackageOps op : packageOps) {
+            for (AppOpsManager.OpEntry entry : op.getOps()) {
+                for (Map.Entry<String, AppOpsManager.AttributedOpEntry> attributedOpEntry :
+                        entry.getAttributedOpEntries().entrySet()) {
+                    if (attributedOpEntry.getValue().isRunning()) {
+                        onOpActiveChanged(
+                                entry.getOpStr(),
+                                op.getUid(),
+                                op.getPackageName(),
+                                /* attributionTag= */ attributedOpEntry.getKey(),
+                                /* active= */ true,
+                                // AppOpsManager doesn't have a way to fetch attribution flags or
+                                // chain ID given an op entry, so default them to none.
+                                AppOpsManager.ATTRIBUTION_FLAGS_NONE,
+                                AppOpsManager.ATTRIBUTION_CHAIN_ID_NONE);
+                    }
+                }
+            }
+        }
+    }
+
     /**
      * Adds a callback that will get notifified when an AppOp of the type the controller tracks
      * changes
",28,0,"AppOpsControllerImpl::fetchCurrentActiveOps, AppOpsControllerImpl::setListening"
401,1e5b9954ad00d7de02b7b39854b72991ed20659f,AppOpsControllerTest.java,"@@ -19,6 +19,8 @@ package com.android.systemui.appops;
 import static android.hardware.SensorPrivacyManager.Sensors.CAMERA;
 import static android.hardware.SensorPrivacyManager.Sensors.MICROPHONE;
 
+import static com.google.common.truth.Truth.assertThat;
+
 import static junit.framework.TestCase.assertFalse;
 
 import static org.junit.Assert.assertEquals;
@@ -66,6 +68,7 @@ import org.mockito.MockitoAnnotations;
 
 import java.util.Collections;
 import java.util.List;
+import java.util.Map;
 
 @SmallTest
 @RunWith(AndroidTestingRunner.class)
@@ -157,6 +160,204 @@ public class AppOpsControllerTest extends SysuiTestCase {
         verify(mSensorPrivacyController, times(1)).removeCallback(mController);
     }
 
+    @Test
+    public void startListening_fetchesCurrentActive_none() {
+        when(mAppOpsManager.getPackagesForOps(AppOpsControllerImpl.OPS))
+                .thenReturn(List.of());
+
+        mController.setListening(true);
+
+        assertThat(mController.getActiveAppOps()).isEmpty();
+    }
+
+    /** Regression test for b/294104969. */
+    @Test
+    public void startListening_fetchesCurrentActive_oneActive() {
+        AppOpsManager.PackageOps packageOps = createPackageOp(
+                ""package.test"",
+                /* packageUid= */ 2,
+                AppOpsManager.OPSTR_FINE_LOCATION,
+                /* isRunning= */ true);
+        when(mAppOpsManager.getPackagesForOps(AppOpsControllerImpl.OPS))
+                .thenReturn(List.of(packageOps));
+
+        // WHEN we start listening
+        mController.setListening(true);
+
+        // THEN the active list has the op
+        List<AppOpItem> list = mController.getActiveAppOps();
+        assertEquals(1, list.size());
+        AppOpItem first = list.get(0);
+        assertThat(first.getPackageName()).isEqualTo(""package.test"");
+        assertThat(first.getUid()).isEqualTo(2);
+        assertThat(first.getCode()).isEqualTo(AppOpsManager.OP_FINE_LOCATION);
+    }
+
+    @Test
+    public void startListening_fetchesCurrentActive_multiplePackages() {
+        AppOpsManager.PackageOps packageOps1 = createPackageOp(
+                ""package.one"",
+                /* packageUid= */ 1,
+                AppOpsManager.OPSTR_FINE_LOCATION,
+                /* isRunning= */ true);
+        AppOpsManager.PackageOps packageOps2 = createPackageOp(
+                ""package.two"",
+                /* packageUid= */ 2,
+                AppOpsManager.OPSTR_FINE_LOCATION,
+                /* isRunning= */ false);
+        AppOpsManager.PackageOps packageOps3 = createPackageOp(
+                ""package.three"",
+                /* packageUid= */ 3,
+                AppOpsManager.OPSTR_FINE_LOCATION,
+                /* isRunning= */ true);
+        when(mAppOpsManager.getPackagesForOps(AppOpsControllerImpl.OPS))
+                .thenReturn(List.of(packageOps1, packageOps2, packageOps3));
+
+        // WHEN we start listening
+        mController.setListening(true);
+
+        // THEN the active list has the ops
+        List<AppOpItem> list = mController.getActiveAppOps();
+        assertEquals(2, list.size());
+
+        AppOpItem item0 = list.get(0);
+        assertThat(item0.getPackageName()).isEqualTo(""package.one"");
+        assertThat(item0.getUid()).isEqualTo(1);
+        assertThat(item0.getCode()).isEqualTo(AppOpsManager.OP_FINE_LOCATION);
+
+        AppOpItem item1 = list.get(1);
+        assertThat(item1.getPackageName()).isEqualTo(""package.three"");
+        assertThat(item1.getUid()).isEqualTo(3);
+        assertThat(item1.getCode()).isEqualTo(AppOpsManager.OP_FINE_LOCATION);
+    }
+
+    @Test
+    public void startListening_fetchesCurrentActive_multipleEntries() {
+        AppOpsManager.PackageOps packageOps = mock(AppOpsManager.PackageOps.class);
+        when(packageOps.getUid()).thenReturn(1);
+        when(packageOps.getPackageName()).thenReturn(""package.one"");
+
+        // Entry 1
+        AppOpsManager.OpEntry entry1 = mock(AppOpsManager.OpEntry.class);
+        when(entry1.getOpStr()).thenReturn(AppOpsManager.OPSTR_PHONE_CALL_MICROPHONE);
+        AppOpsManager.AttributedOpEntry attributed1 = mock(AppOpsManager.AttributedOpEntry.class);
+        when(attributed1.isRunning()).thenReturn(true);
+        when(entry1.getAttributedOpEntries()).thenReturn(Map.of(""tag"", attributed1));
+        // Entry 2
+        AppOpsManager.OpEntry entry2 = mock(AppOpsManager.OpEntry.class);
+        when(entry2.getOpStr()).thenReturn(AppOpsManager.OPSTR_CAMERA);
+        AppOpsManager.AttributedOpEntry attributed2 = mock(AppOpsManager.AttributedOpEntry.class);
+        when(attributed2.isRunning()).thenReturn(true);
+        when(entry2.getAttributedOpEntries()).thenReturn(Map.of(""tag"", attributed2));
+        // Entry 3
+        AppOpsManager.OpEntry entry3 = mock(AppOpsManager.OpEntry.class);
+        when(entry3.getOpStr()).thenReturn(AppOpsManager.OPSTR_FINE_LOCATION);
+        AppOpsManager.AttributedOpEntry attributed3 = mock(AppOpsManager.AttributedOpEntry.class);
+        when(attributed3.isRunning()).thenReturn(false);
+        when(entry3.getAttributedOpEntries()).thenReturn(Map.of(""tag"", attributed3));
+
+        when(packageOps.getOps()).thenReturn(List.of(entry1, entry2, entry3));
+        when(mAppOpsManager.getPackagesForOps(AppOpsControllerImpl.OPS))
+                .thenReturn(List.of(packageOps));
+
+        // WHEN we start listening
+        mController.setListening(true);
+
+        // THEN the active list has the ops
+        List<AppOpItem> list = mController.getActiveAppOps();
+        assertEquals(2, list.size());
+
+        AppOpItem first = list.get(0);
+        assertThat(first.getPackageName()).isEqualTo(""package.one"");
+        assertThat(first.getUid()).isEqualTo(1);
+        assertThat(first.getCode()).isEqualTo(AppOpsManager.OP_PHONE_CALL_MICROPHONE);
+
+        AppOpItem second = list.get(1);
+        assertThat(second.getPackageName()).isEqualTo(""package.one"");
+        assertThat(second.getUid()).isEqualTo(1);
+        assertThat(second.getCode()).isEqualTo(AppOpsManager.OP_CAMERA);
+    }
+
+    @Test
+    public void startListening_fetchesCurrentActive_multipleAttributes() {
+        AppOpsManager.PackageOps packageOps = mock(AppOpsManager.PackageOps.class);
+        when(packageOps.getUid()).thenReturn(1);
+        when(packageOps.getPackageName()).thenReturn(""package.one"");
+        AppOpsManager.OpEntry entry = mock(AppOpsManager.OpEntry.class);
+        when(entry.getOpStr()).thenReturn(AppOpsManager.OPSTR_RECORD_AUDIO);
+
+        AppOpsManager.AttributedOpEntry attributed1 = mock(AppOpsManager.AttributedOpEntry.class);
+        when(attributed1.isRunning()).thenReturn(false);
+        AppOpsManager.AttributedOpEntry attributed2 = mock(AppOpsManager.AttributedOpEntry.class);
+        when(attributed2.isRunning()).thenReturn(true);
+        AppOpsManager.AttributedOpEntry attributed3 = mock(AppOpsManager.AttributedOpEntry.class);
+        when(attributed3.isRunning()).thenReturn(true);
+        when(entry.getAttributedOpEntries()).thenReturn(
+                Map.of(""attr1"", attributed1, ""attr2"", attributed2, ""attr3"", attributed3));
+
+        when(packageOps.getOps()).thenReturn(List.of(entry));
+        when(mAppOpsManager.getPackagesForOps(AppOpsControllerImpl.OPS))
+                .thenReturn(List.of(packageOps));
+
+        // WHEN we start listening
+        mController.setListening(true);
+
+        // THEN the active list has the ops
+        List<AppOpItem> list = mController.getActiveAppOps();
+        // Multiple attributes get merged into one entry in the active ops
+        assertEquals(1, list.size());
+
+        AppOpItem first = list.get(0);
+        assertThat(first.getPackageName()).isEqualTo(""package.one"");
+        assertThat(first.getUid()).isEqualTo(1);
+        assertThat(first.getCode()).isEqualTo(AppOpsManager.OP_RECORD_AUDIO);
+    }
+
+    /** Regression test for b/294104969. */
+    @Test
+    public void addCallback_existingCallbacksNotifiedOfCurrentActive() {
+        AppOpsManager.PackageOps packageOps1 = createPackageOp(
+                ""package.one"",
+                /* packageUid= */ 1,
+                AppOpsManager.OPSTR_FINE_LOCATION,
+                /* isRunning= */ true);
+        AppOpsManager.PackageOps packageOps2 = createPackageOp(
+                ""package.two"",
+                /* packageUid= */ 2,
+                AppOpsManager.OPSTR_RECORD_AUDIO,
+                /* isRunning= */ true);
+        AppOpsManager.PackageOps packageOps3 = createPackageOp(
+                ""package.three"",
+                /* packageUid= */ 3,
+                AppOpsManager.OPSTR_PHONE_CALL_MICROPHONE,
+                /* isRunning= */ true);
+        when(mAppOpsManager.getPackagesForOps(AppOpsControllerImpl.OPS))
+                .thenReturn(List.of(packageOps1, packageOps2, packageOps3));
+
+        // WHEN we start listening
+        mController.addCallback(
+                new int[]{AppOpsManager.OP_RECORD_AUDIO, AppOpsManager.OP_FINE_LOCATION},
+                mCallback);
+        mTestableLooper.processAllMessages();
+
+        // THEN the callback is notified of the current active ops it cares about
+        verify(mCallback).onActiveStateChanged(
+                AppOpsManager.OP_FINE_LOCATION,
+                /* uid= */ 1,
+                ""package.one"",
+                true);
+        verify(mCallback).onActiveStateChanged(
+                AppOpsManager.OP_RECORD_AUDIO,
+                /* uid= */ 2,
+                ""package.two"",
+                true);
+        verify(mCallback, never()).onActiveStateChanged(
+                AppOpsManager.OP_PHONE_CALL_MICROPHONE,
+                /* uid= */ 3,
+                ""package.three"",
+                true);
+    }
+
     @Test
     public void addCallback_includedCode() {
         mController.addCallback(
@@ -673,6 +874,22 @@ public class AppOpsControllerTest extends SysuiTestCase {
         assertEquals(AppOpsManager.OP_PHONE_CALL_CAMERA, list.get(cameraIdx).getCode());
     }
 
+    private AppOpsManager.PackageOps createPackageOp(
+            String packageName, int packageUid, String opStr, boolean isRunning) {
+        AppOpsManager.PackageOps packageOps = mock(AppOpsManager.PackageOps.class);
+        when(packageOps.getPackageName()).thenReturn(packageName);
+        when(packageOps.getUid()).thenReturn(packageUid);
+        AppOpsManager.OpEntry entry = mock(AppOpsManager.OpEntry.class);
+        when(entry.getOpStr()).thenReturn(opStr);
+        AppOpsManager.AttributedOpEntry attributed = mock(AppOpsManager.AttributedOpEntry.class);
+        when(attributed.isRunning()).thenReturn(isRunning);
+
+        when(packageOps.getOps()).thenReturn(Collections.singletonList(entry));
+        when(entry.getAttributedOpEntries()).thenReturn(Map.of(""tag"", attributed));
+
+        return packageOps;
+    }
+
     private class TestHandler extends AppOpsControllerImpl.H {
         TestHandler(Looper looper) {
             mController.super(looper);
",217,0,"AppOpsControllerTest::startListening_fetchesCurrentActive_multipleAttributes, AppOpsControllerTest::startListening_fetchesCurrentActive_multipleEntries, AppOpsControllerTest::startListening_fetchesCurrentActive_none, AppOpsControllerTest::startListening_fetchesCurrentActive_multiplePackages, AppOpsControllerTest::addCallback_existingCallbacksNotifiedOfCurrentActive, AppOpsControllerTest::startListening_fetchesCurrentActive_oneActive, AppOpsControllerTest::createPackageOp"
402,771669ad21217ad8a48ade48298e0f7276fd6bfb,ActivityManagerService.java,"@@ -5035,7 +5035,20 @@ public class ActivityManagerService extends IActivityManager.Stub
                 intent = new Intent(Intent.ACTION_MAIN);
             }
             try {
-                target.send(code, intent, resolvedType, allowlistToken, null,
+                if (allowlistToken != null) {
+                    final int callingUid = Binder.getCallingUid();
+                    final String packageName;
+                    final long token = Binder.clearCallingIdentity();
+                    try {
+                        packageName = AppGlobals.getPackageManager().getNameForUid(callingUid);
+                    } finally {
+                        Binder.restoreCallingIdentity(token);
+                    }
+                    Slog.wtf(TAG, ""Send a non-null allowlistToken to a non-PI target.""
+                            + "" Calling package: "" + packageName + ""; intent: "" + intent
+                            + ""; options: "" + options);
+                }
+                target.send(code, intent, resolvedType, null, null,
                         requiredPermission, options);
             } catch (RemoteException e) {
             }
",14,1,ActivityManagerService::sendIntentSender
403,3916fdc3cb4490fc828a633982c937da136fc791,DreamBackend.java,"@@ -351,7 +351,17 @@ public class DreamBackend {
         if (cn != null && cn.indexOf('/') < 0) {
             cn = resolveInfo.serviceInfo.packageName + ""/"" + cn;
         }
-        return cn == null ? null : ComponentName.unflattenFromString(cn);
+        // Ensure that the component is from the same package as the dream service. If not,
+        // treat the component as invalid and return null instead.
+        final ComponentName result = cn != null ? ComponentName.unflattenFromString(cn) : null;
+        if (result != null
+                && !result.getPackageName().equals(resolveInfo.serviceInfo.packageName)) {
+            Log.w(TAG,
+                    ""Inconsistent package name in component: "" + result.getPackageName()
+                            + "", should be: "" + resolveInfo.serviceInfo.packageName);
+            return null;
+        }
+        return result;
     }
 
     private static void logd(String msg, Object... args) {
",11,1,DreamBackend::getSettingsComponentName
404,a1e8ab5e0dbb34361cbd548abac2f8cf980faab9,ActivityManagerService.java,"@@ -3690,6 +3690,22 @@ public class ActivityManagerService extends IActivityManager.Stub
             throw new SecurityException(msg);
         }
 
+        final int callingUid = Binder.getCallingUid();
+        final int callingPid = Binder.getCallingPid();
+
+        ProcessRecord proc;
+        synchronized (mPidsSelfLocked) {
+            proc = mPidsSelfLocked.get(callingPid);
+        }
+        if (callingUid >= FIRST_APPLICATION_UID
+                && (proc == null || !proc.info.isSystemApp())) {
+            final String msg = ""Permission Denial: killAllBackgroundProcesses() from pid=""
+                    + callingPid + "", uid="" + callingUid + "" is not allowed"";
+            Slog.w(TAG, msg);
+            // Silently return to avoid existing apps from crashing.
+            return;
+        }
+
         final long callingId = Binder.clearCallingIdentity();
         try {
             synchronized (this) {
@@ -3730,22 +3746,6 @@ public class ActivityManagerService extends IActivityManager.Stub
             throw new SecurityException(msg);
         }
 
-        final int callingUid = Binder.getCallingUid();
-        final int callingPid = Binder.getCallingPid();
-
-        ProcessRecord proc;
-        synchronized (mPidsSelfLocked) {
-            proc = mPidsSelfLocked.get(callingPid);
-        }
-        if (callingUid >= FIRST_APPLICATION_UID
-                && (proc == null || !proc.info.isSystemApp())) {
-            final String msg = ""Permission Denial: killAllBackgroundProcesses() from pid=""
-                    + callingPid + "", uid="" + callingUid + "" is not allowed"";
-            Slog.w(TAG, msg);
-            // Silently return to avoid existing apps from crashing.
-            return;
-        }
-
         final long callingId = Binder.clearCallingIdentity();
         try {
             synchronized (this) {
",16,16,"ActivityManagerService::killAllBackgroundProcessesExcept, ActivityManagerService::killAllBackgroundProcesses"
