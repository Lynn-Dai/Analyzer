[
 {
  "hash": "23b641c5793bcbe559e56588016b9fb7555ae6ff",
  "commit": "Show the vibrate icon in the Status Bar by default\n\nChange-Id: I39d2f0ee7849403c404bdfa109e191102466c537",
  "files": [
   {
    "filename": "CollapsedStatusBarFragment.java",
    "diff": "@@ -231,7 +231,7 @@ public class CollapsedStatusBarFragment extends Fragment implements CommandQueue\n         mBlockedIcons.addAll(Arrays.asList(getResources().getStringArray(\n                 R.array.config_collapsed_statusbar_icon_blocklist)));\n \n-        if (mSecureSettings.getInt(Settings.Secure.STATUS_BAR_SHOW_VIBRATE_ICON, 0) == 0) {\n+        if (mSecureSettings.getInt(Settings.Secure.STATUS_BAR_SHOW_VIBRATE_ICON, 1) == 0) {\n             mBlockedIcons.add(getString(com.android.internal.R.string.status_bar_volume));\n         }\n \n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "CollapsedStatusBarFragment::updateBlockedIcons"
   }
  ]
 },
 {
  "hash": "ba528922c37f982e6533939b98852373848446a1",
  "commit": "SystemUI: Add HBM provider for UDFPS on Pixel devices\n\nThis implements high brightness mode (HBM) control for the under-display\nfingerprint sensor on Pixel devices. It enables and disables local HBM\nthrough the Pixel display HAL, similar to Google's implementation in the\nstock OS.\n\nBlocking IPC calls to the display HAL are done on a background thread to\navoid causing frame drops by blocking the main thread, but callbacks are\nalways run on the main thread as specified by the UdfpsHbmProvider docs.\nCare is taken to avoid enabling LHBM when it's already enabled and vice\nversa, as doing so causes the display HAL's request to time out and\nthrow an exception.\n\nFor simplicity, global HBM is not supported as it has never been used in\nproduction on Pixel devices.\n\nChange-Id: I8d301c7e1ce54ee8ffd987708b6f0e2bf115f7ef",
  "files": [
   {
    "filename": "Dependency.java",
    "diff": "@@ -40,6 +40,7 @@ import com.android.systemui.accessibility.AccessibilityButtonTargetsObserver;\n import com.android.systemui.accessibility.floatingmenu.AccessibilityFloatingMenuController;\n import com.android.systemui.appops.AppOpsController;\n import com.android.systemui.assist.AssistManager;\n+import com.android.systemui.biometrics.AuthController;\n import com.android.systemui.broadcast.BroadcastDispatcher;\n import com.android.systemui.colorextraction.SysuiColorExtractor;\n import com.android.systemui.dagger.SysUISingleton;\n@@ -370,6 +371,7 @@ public class Dependency {\n     @Inject Lazy<AmbientState> mAmbientStateLazy;\n     @Inject Lazy<GroupMembershipManager> mGroupMembershipManagerLazy;\n     @Inject Lazy<GroupExpansionManager> mGroupExpansionManagerLazy;\n+    @Inject Lazy<AuthController> mAuthController;\n \n     @Inject\n     public Dependency() {\n@@ -591,6 +593,8 @@ public class Dependency {\n         mProviders.put(GroupMembershipManager.class, mGroupMembershipManagerLazy::get);\n         mProviders.put(GroupExpansionManager.class, mGroupExpansionManagerLazy::get);\n \n+        mProviders.put(AuthController.class, mAuthController::get);\n+\n         Dependency.setInstance(this);\n     }\n \n",
    "added_lines": 4,
    "deleted_lines": 0,
    "changed_methods": "Dependency::start"
   }
  ]
 },
 {
  "hash": "1726a9eda3299ea04660d5109fea4b55375f0798",
  "commit": "fixup! Allow lineage resources package to be overlayed by RRO packages\n\nChange-Id: I7b1a53191ad613741159820bdd17bcb56d9872ef",
  "files": [
   {
    "filename": "OverlayManagerSettings.java",
    "diff": "@@ -235,8 +235,8 @@ final class OverlayManagerSettings {\n     }\n \n     private static boolean isImmutableFrameworkOverlay(@NonNull SettingsItem item) {\n-        return !item.isMutable() && \"android\".equals(item.getTargetPackageName())\n-               && \"lineageos.platform\".equals(item.getTargetPackageName());\n+        return !item.isMutable() && (\"android\".equals(item.getTargetPackageName())\n+               || \"lineageos.platform\".equals(item.getTargetPackageName()));\n     }\n \n     /**\n",
    "added_lines": 2,
    "deleted_lines": 2,
    "changed_methods": "OverlayManagerSettings::isImmutableFrameworkOverlay"
   }
  ]
 },
 {
  "hash": "9d31f5ad45805fd692ffd797dde13e6f16ed73e8",
  "commit": "SystemUI: Redraw display cutout on overlay changes\n\nFixes notch hide overlay on some devices\n\ncommit 5481d59996b34cda1cb6b680af7510fee7b53b42\nAuthor: daniml3 <danimoral1001@gmail.com>\nDate:   Tue Mar 9 08:11:13 2021 +0100\n\n    SystemUI: check if the cutout views array is null before using it\n\n    Signed-off-by: daniml3 <danimoral1001@gmail.com>\n    Change-Id: I1316c61280dadc30a86f2ae72559437a61dd4616\n\nCo-authored-by: daniml3 <danimoral1001@gmail.com>\nChange-Id: I5a049099ab375833f1e5ebbda49dc36c3c0b0a68",
  "files": [
   {
    "filename": "ScreenDecorations.java",
    "diff": "@@ -667,6 +667,13 @@ public class ScreenDecorations extends SystemUI implements Tunable {\n             updateRoundedCornerRadii();\n             if (DEBUG) Log.i(TAG, \"onConfigChanged from rot \" + oldRotation + \" to \" + mRotation);\n             setupDecorations();\n+            if (mCutoutViews != null) {\n+                for (DisplayCutoutView dcv : mCutoutViews) {\n+                    if (dcv != null) {\n+                        dcv.update();\n+                    }\n+                }\n+            }\n             if (mOverlays != null) {\n                 // Updating the layout params ensures that ViewRootImpl will call relayoutWindow(),\n                 // which ensures that the forced seamless rotation will end, even if we updated\n",
    "added_lines": 7,
    "deleted_lines": 0,
    "changed_methods": "ScreenDecorations::onConfigurationChanged"
   }
  ]
 },
 {
  "hash": "a5ca55c94e60a2036d1affb05072492a92b6b240",
  "commit": "SystemUI: MediaOutputController: Avoid NPE when created with empty packageName\n\nIf mPackageName is empty the mMediaController won't be set in start() which\nresults in a null object reference. Prior to commit d1f381a7dba1894b4c06029e305f12feb04483da\nit was possible to create MediaOutputController with an empty package name.\nIn this case the dialog did not contain information about currently played\nmedia but provided working options to change the output device. This commit\nreturns this behaviour.\n\nChange-Id: I94939467dcfe759f8e4aae88097579fb17c94a8e",
  "files": [
   {
    "filename": "MediaOutputController.java",
    "diff": "@@ -494,7 +494,7 @@ public class MediaOutputController implements LocalMediaManager.DeviceCallback {\n     }\n \n     private boolean isPlayBackInfoLocal() {\n-        return mMediaController.getPlaybackInfo() != null\n+        return mMediaController != null && mMediaController.getPlaybackInfo() != null\n                 && mMediaController.getPlaybackInfo().getPlaybackType()\n                         == MediaController.PlaybackInfo.PLAYBACK_TYPE_LOCAL;\n     }\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "MediaOutputController::isPlayBackInfoLocal"
   }
  ]
 },
 {
  "hash": "1ce45bc32ce80fbe3c6cc2fb14ccfabc566347f4",
  "commit": "SystemUI: screenshot: open long screenshot activity for partial screenshots\n\nThe partial screenshot UI is basically unusable. Replace it\nwith the long  screenshot UI which offers cropping, saving,\ncanceling, and sharing capabilities.\n\nChange-Id: I27f7a811838f7e3f2057f567c7a350255996a8cb",
  "files": [
   {
    "filename": "ScreenshotController.java",
    "diff": "@@ -445,15 +445,8 @@ public class ScreenshotController {\n      */\n     void takeScreenshotPartial(ComponentName topComponent,\n             final Consumer<Uri> finisher, RequestCallback requestCallback) {\n-        mScreenshotView.reset();\n-        mCurrentRequestCallback = requestCallback;\n-\n-        attachWindow();\n-        mWindow.setContentView(mScreenshotView);\n-        mScreenshotView.requestApplyInsets();\n-\n-        mScreenshotView.takePartialScreenshot(\n-                rect -> takeScreenshotInternal(topComponent, finisher, rect));\n+        startPartialScreenshotActivity();\n+        finisher.accept(null);\n     }\n \n     /**\n@@ -594,6 +587,13 @@ public class ScreenshotController {\n         return screenshot;\n     }\n \n+    private Bitmap captureScreenshot() {\n+        DisplayMetrics displayMetrics = new DisplayMetrics();\n+        getDefaultDisplay().getRealMetrics(displayMetrics);\n+        return captureScreenshot(\n+                new Rect(0, 0, displayMetrics.widthPixels, displayMetrics.heightPixels));\n+    }\n+\n     private void saveScreenshot(Bitmap screenshot, Consumer<Uri> finisher, Rect screenRect,\n             Insets screenInsets, ComponentName topComponent, boolean showFlash) {\n         if (mAccessibilityManager.isEnabled()) {\n@@ -702,6 +702,40 @@ public class ScreenshotController {\n                 onScrollCaptureResponseReady(mLastScrollCaptureRequest), mMainExecutor);\n     }\n \n+    public void startLongScreenshotActivity(ScrollCaptureController.LongScreenshot longScreenshot) {\n+        mLongScreenshotHolder.setLongScreenshot(longScreenshot);\n+        mLongScreenshotHolder.setTransitionDestinationCallback(\n+                (transitionDestination, onTransitionEnd) ->\n+                        mScreenshotView.startLongScreenshotTransition(\n+                                transitionDestination, onTransitionEnd,\n+                                longScreenshot));\n+        mLongScreenshotHolder.setForegroundAppName(getForegroundAppLabel());\n+\n+        final Intent intent = new Intent(mContext, LongScreenshotActivity.class);\n+        intent.setFlags(\n+                Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP);\n+\n+        mContext.startActivity(intent,\n+                ActivityOptions.makeCustomAnimation(mContext, 0, 0).toBundle());\n+        RemoteAnimationAdapter runner = new RemoteAnimationAdapter(\n+                SCREENSHOT_REMOTE_RUNNER, 0, 0);\n+        try {\n+            WindowManagerGlobal.getWindowManagerService()\n+                    .overridePendingAppTransitionRemote(runner, DEFAULT_DISPLAY);\n+        } catch (Exception e) {\n+            Log.e(TAG, \"Error overriding screenshot app transition\", e);\n+        }\n+    }\n+\n+    private void startPartialScreenshotActivity() {\n+        Bitmap newScreenshot = captureScreenshot();\n+\n+        ScrollCaptureController.BitmapScreenshot bitmapScreenshot =\n+            new ScrollCaptureController.BitmapScreenshot(mContext, newScreenshot);\n+\n+        startLongScreenshotActivity(bitmapScreenshot);\n+    }\n+\n     private void onScrollCaptureResponseReady(Future<ScrollCaptureResponse> responseFuture) {\n         try {\n             if (mLastScrollCaptureResponse != null) {\n@@ -751,28 +785,7 @@ public class ScreenshotController {\n                             return;\n                         }\n \n-                        mLongScreenshotHolder.setLongScreenshot(longScreenshot);\n-                        mLongScreenshotHolder.setTransitionDestinationCallback(\n-                                (transitionDestination, onTransitionEnd) ->\n-                                        mScreenshotView.startLongScreenshotTransition(\n-                                                transitionDestination, onTransitionEnd,\n-                                                longScreenshot));\n-                        mLongScreenshotHolder.setForegroundAppName(getForegroundAppLabel());\n-\n-                        final Intent intent = new Intent(mContext, LongScreenshotActivity.class);\n-                        intent.setFlags(\n-                                Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP);\n-\n-                        mContext.startActivity(intent,\n-                                ActivityOptions.makeCustomAnimation(mContext, 0, 0).toBundle());\n-                        RemoteAnimationAdapter runner = new RemoteAnimationAdapter(\n-                                SCREENSHOT_REMOTE_RUNNER, 0, 0);\n-                        try {\n-                            WindowManagerGlobal.getWindowManagerService()\n-                                    .overridePendingAppTransitionRemote(runner, DEFAULT_DISPLAY);\n-                        } catch (Exception e) {\n-                            Log.e(TAG, \"Error overriding screenshot app transition\", e);\n-                        }\n+                        startLongScreenshotActivity(longScreenshot);\n                     }, mMainExecutor);\n                 });\n             });\n",
    "added_lines": 44,
    "deleted_lines": 31,
    "changed_methods": "ScreenshotController::takeScreenshotPartial, ScreenshotController::startLongScreenshotActivity, ScreenshotController::startPartialScreenshotActivity, ScreenshotController::captureScreenshot, ScreenshotController::onScrollCaptureResponseReady"
   },
   {
    "filename": "ScrollCaptureController.java",
    "diff": "@@ -20,6 +20,7 @@ import android.content.Context;\n import android.graphics.Bitmap;\n import android.graphics.Rect;\n import android.graphics.drawable.Drawable;\n+import android.graphics.drawable.BitmapDrawable;\n import android.provider.Settings;\n import android.util.Log;\n import android.view.ScrollCaptureResponse;\n@@ -136,6 +137,73 @@ public class ScrollCaptureController {\n         }\n     }\n \n+    static class BitmapScreenshot extends LongScreenshot {\n+        private final BitmapDrawable mBitmapDrawable;\n+        private final Bitmap mBitmap;\n+\n+        BitmapScreenshot(Context context, Bitmap bitmap) {\n+            super(null, null);\n+\n+            mBitmap = bitmap;\n+            mBitmapDrawable = new BitmapDrawable(context.getResources(), bitmap);\n+        }\n+\n+        @Override\n+        public Bitmap toBitmap() {\n+            return mBitmap;\n+        }\n+\n+        @Override\n+        public Bitmap toBitmap(Rect bounds) {\n+            // Not used anywhere\n+            return mBitmap;\n+        }\n+\n+        @Override\n+        public void release() {\n+        }\n+\n+        @Override\n+        public int getLeft() {\n+            return 0;\n+        }\n+\n+        @Override\n+        public int getTop() {\n+            return 0;\n+        }\n+\n+        @Override\n+        public int getBottom() {\n+            return getHeight();\n+        }\n+\n+        @Override\n+        public int getWidth() {\n+            return mBitmap.getWidth();\n+        }\n+\n+        @Override\n+        public int getHeight() {\n+            return mBitmap.getHeight();\n+        }\n+\n+        @Override\n+        public int getPageHeight() {\n+            return getHeight();\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"BitmapScrenshot{w=\" + getWidth() + \", h=\" + getHeight() + \"}\";\n+        }\n+\n+        @Override\n+        public Drawable getDrawable() {\n+            return mBitmapDrawable;\n+        }\n+    }\n+\n     @Inject\n     ScrollCaptureController(Context context, @Background Executor bgExecutor,\n             ScrollCaptureClient client, ImageTileSet imageTileSet, UiEventLogger logger) {\n",
    "added_lines": 68,
    "deleted_lines": 0,
    "changed_methods": "ScrollCaptureController::BitmapScreenshot::BitmapScreenshot, ScrollCaptureController::BitmapScreenshot::getLeft, ScrollCaptureController::BitmapScreenshot::toBitmap, ScrollCaptureController::BitmapScreenshot::getWidth, ScrollCaptureController::BitmapScreenshot::getHeight, ScrollCaptureController::BitmapScreenshot::getPageHeight, ScrollCaptureController::BitmapScreenshot::getTop, ScrollCaptureController::BitmapScreenshot::getBottom, ScrollCaptureController::BitmapScreenshot::toString, ScrollCaptureController::BitmapScreenshot::getDrawable, ScrollCaptureController::BitmapScreenshot::release, ScrollCaptureController::BitmapScreenshot::toBitmap"
   }
  ]
 },
 {
  "hash": "1ce45bc32ce80fbe3c6cc2fb14ccfabc566347f4",
  "commit": "SystemUI: screenshot: open long screenshot activity for partial screenshots\n\nThe partial screenshot UI is basically unusable. Replace it\nwith the long  screenshot UI which offers cropping, saving,\ncanceling, and sharing capabilities.\n\nChange-Id: I27f7a811838f7e3f2057f567c7a350255996a8cb",
  "files": [
   {
    "filename": "ScreenshotController.java",
    "diff": "@@ -445,15 +445,8 @@ public class ScreenshotController {\n      */\n     void takeScreenshotPartial(ComponentName topComponent,\n             final Consumer<Uri> finisher, RequestCallback requestCallback) {\n-        mScreenshotView.reset();\n-        mCurrentRequestCallback = requestCallback;\n-\n-        attachWindow();\n-        mWindow.setContentView(mScreenshotView);\n-        mScreenshotView.requestApplyInsets();\n-\n-        mScreenshotView.takePartialScreenshot(\n-                rect -> takeScreenshotInternal(topComponent, finisher, rect));\n+        startPartialScreenshotActivity();\n+        finisher.accept(null);\n     }\n \n     /**\n@@ -594,6 +587,13 @@ public class ScreenshotController {\n         return screenshot;\n     }\n \n+    private Bitmap captureScreenshot() {\n+        DisplayMetrics displayMetrics = new DisplayMetrics();\n+        getDefaultDisplay().getRealMetrics(displayMetrics);\n+        return captureScreenshot(\n+                new Rect(0, 0, displayMetrics.widthPixels, displayMetrics.heightPixels));\n+    }\n+\n     private void saveScreenshot(Bitmap screenshot, Consumer<Uri> finisher, Rect screenRect,\n             Insets screenInsets, ComponentName topComponent, boolean showFlash) {\n         if (mAccessibilityManager.isEnabled()) {\n@@ -702,6 +702,40 @@ public class ScreenshotController {\n                 onScrollCaptureResponseReady(mLastScrollCaptureRequest), mMainExecutor);\n     }\n \n+    public void startLongScreenshotActivity(ScrollCaptureController.LongScreenshot longScreenshot) {\n+        mLongScreenshotHolder.setLongScreenshot(longScreenshot);\n+        mLongScreenshotHolder.setTransitionDestinationCallback(\n+                (transitionDestination, onTransitionEnd) ->\n+                        mScreenshotView.startLongScreenshotTransition(\n+                                transitionDestination, onTransitionEnd,\n+                                longScreenshot));\n+        mLongScreenshotHolder.setForegroundAppName(getForegroundAppLabel());\n+\n+        final Intent intent = new Intent(mContext, LongScreenshotActivity.class);\n+        intent.setFlags(\n+                Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP);\n+\n+        mContext.startActivity(intent,\n+                ActivityOptions.makeCustomAnimation(mContext, 0, 0).toBundle());\n+        RemoteAnimationAdapter runner = new RemoteAnimationAdapter(\n+                SCREENSHOT_REMOTE_RUNNER, 0, 0);\n+        try {\n+            WindowManagerGlobal.getWindowManagerService()\n+                    .overridePendingAppTransitionRemote(runner, DEFAULT_DISPLAY);\n+        } catch (Exception e) {\n+            Log.e(TAG, \"Error overriding screenshot app transition\", e);\n+        }\n+    }\n+\n+    private void startPartialScreenshotActivity() {\n+        Bitmap newScreenshot = captureScreenshot();\n+\n+        ScrollCaptureController.BitmapScreenshot bitmapScreenshot =\n+            new ScrollCaptureController.BitmapScreenshot(mContext, newScreenshot);\n+\n+        startLongScreenshotActivity(bitmapScreenshot);\n+    }\n+\n     private void onScrollCaptureResponseReady(Future<ScrollCaptureResponse> responseFuture) {\n         try {\n             if (mLastScrollCaptureResponse != null) {\n@@ -751,28 +785,7 @@ public class ScreenshotController {\n                             return;\n                         }\n \n-                        mLongScreenshotHolder.setLongScreenshot(longScreenshot);\n-                        mLongScreenshotHolder.setTransitionDestinationCallback(\n-                                (transitionDestination, onTransitionEnd) ->\n-                                        mScreenshotView.startLongScreenshotTransition(\n-                                                transitionDestination, onTransitionEnd,\n-                                                longScreenshot));\n-                        mLongScreenshotHolder.setForegroundAppName(getForegroundAppLabel());\n-\n-                        final Intent intent = new Intent(mContext, LongScreenshotActivity.class);\n-                        intent.setFlags(\n-                                Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP);\n-\n-                        mContext.startActivity(intent,\n-                                ActivityOptions.makeCustomAnimation(mContext, 0, 0).toBundle());\n-                        RemoteAnimationAdapter runner = new RemoteAnimationAdapter(\n-                                SCREENSHOT_REMOTE_RUNNER, 0, 0);\n-                        try {\n-                            WindowManagerGlobal.getWindowManagerService()\n-                                    .overridePendingAppTransitionRemote(runner, DEFAULT_DISPLAY);\n-                        } catch (Exception e) {\n-                            Log.e(TAG, \"Error overriding screenshot app transition\", e);\n-                        }\n+                        startLongScreenshotActivity(longScreenshot);\n                     }, mMainExecutor);\n                 });\n             });\n",
    "added_lines": 44,
    "deleted_lines": 31,
    "changed_methods": "ScreenshotController::takeScreenshotPartial, ScreenshotController::startLongScreenshotActivity, ScreenshotController::startPartialScreenshotActivity, ScreenshotController::captureScreenshot, ScreenshotController::onScrollCaptureResponseReady"
   },
   {
    "filename": "ScrollCaptureController.java",
    "diff": "@@ -20,6 +20,7 @@ import android.content.Context;\n import android.graphics.Bitmap;\n import android.graphics.Rect;\n import android.graphics.drawable.Drawable;\n+import android.graphics.drawable.BitmapDrawable;\n import android.provider.Settings;\n import android.util.Log;\n import android.view.ScrollCaptureResponse;\n@@ -136,6 +137,73 @@ public class ScrollCaptureController {\n         }\n     }\n \n+    static class BitmapScreenshot extends LongScreenshot {\n+        private final BitmapDrawable mBitmapDrawable;\n+        private final Bitmap mBitmap;\n+\n+        BitmapScreenshot(Context context, Bitmap bitmap) {\n+            super(null, null);\n+\n+            mBitmap = bitmap;\n+            mBitmapDrawable = new BitmapDrawable(context.getResources(), bitmap);\n+        }\n+\n+        @Override\n+        public Bitmap toBitmap() {\n+            return mBitmap;\n+        }\n+\n+        @Override\n+        public Bitmap toBitmap(Rect bounds) {\n+            // Not used anywhere\n+            return mBitmap;\n+        }\n+\n+        @Override\n+        public void release() {\n+        }\n+\n+        @Override\n+        public int getLeft() {\n+            return 0;\n+        }\n+\n+        @Override\n+        public int getTop() {\n+            return 0;\n+        }\n+\n+        @Override\n+        public int getBottom() {\n+            return getHeight();\n+        }\n+\n+        @Override\n+        public int getWidth() {\n+            return mBitmap.getWidth();\n+        }\n+\n+        @Override\n+        public int getHeight() {\n+            return mBitmap.getHeight();\n+        }\n+\n+        @Override\n+        public int getPageHeight() {\n+            return getHeight();\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"BitmapScrenshot{w=\" + getWidth() + \", h=\" + getHeight() + \"}\";\n+        }\n+\n+        @Override\n+        public Drawable getDrawable() {\n+            return mBitmapDrawable;\n+        }\n+    }\n+\n     @Inject\n     ScrollCaptureController(Context context, @Background Executor bgExecutor,\n             ScrollCaptureClient client, ImageTileSet imageTileSet, UiEventLogger logger) {\n",
    "added_lines": 68,
    "deleted_lines": 0,
    "changed_methods": "ScrollCaptureController::BitmapScreenshot::BitmapScreenshot, ScrollCaptureController::BitmapScreenshot::getLeft, ScrollCaptureController::BitmapScreenshot::toBitmap, ScrollCaptureController::BitmapScreenshot::getWidth, ScrollCaptureController::BitmapScreenshot::getHeight, ScrollCaptureController::BitmapScreenshot::getPageHeight, ScrollCaptureController::BitmapScreenshot::getTop, ScrollCaptureController::BitmapScreenshot::getBottom, ScrollCaptureController::BitmapScreenshot::toString, ScrollCaptureController::BitmapScreenshot::getDrawable, ScrollCaptureController::BitmapScreenshot::release, ScrollCaptureController::BitmapScreenshot::toBitmap"
   }
  ]
 },
 {
  "hash": "13429c61674c3b1cfbc71d5d22853cebbe7706a2",
  "commit": "SystemUI: screenshot: remove misplaced call to set crop view padding\n\nThis call to setExtraPadding() discards the previously set\npadding, making the screenshot crop view be able to select\nover the borders of the image. Remove it.\n\nChange-Id: I6cc28c79c2d9f4958215bb5957be6c9b2eab1002",
  "files": [
   {
    "filename": "LongScreenshotActivity.java",
    "diff": "@@ -442,7 +442,6 @@ public class LongScreenshotActivity extends Activity {\n             mCropView.setExtraPadding(extraPadding + mPreview.getPaddingTop(),\n                     extraPadding + mPreview.getPaddingBottom());\n             imageTop += (previewHeight - imageHeight) / 2;\n-            mCropView.setExtraPadding(extraPadding, extraPadding);\n             mCropView.setImageWidth(previewWidth);\n             scale = previewWidth / (float) mPreview.getDrawable().getIntrinsicWidth();\n         } else {\n",
    "added_lines": 0,
    "deleted_lines": 1,
    "changed_methods": "LongScreenshotActivity::updateImageDimensions"
   }
  ]
 },
 {
  "hash": "e110cba8fecf449207bca80f8696fe73af1d6e31",
  "commit": "SystemUI: screenshot: remove duplicate clamping on move action\n\nOn MotionEvent.ACTION_DOWN, a range of of motion is calculated and\nstored. On MotionEvent.ACTION_MOVE, the new position of the crop\nboundary is clamped by the original range of motion, and also\nclamped again by a new range of motion inside setBoundaryPosition().\n\nThe original range of motion is pointless and only used in this case,\nremove it.\n\nChange-Id: Ib4f35bf5317f5b5879606680beee3e077f829d10",
  "files": [
   {
    "filename": "CropView.java",
    "diff": "@@ -78,8 +78,6 @@ public class CropView extends View {\n     private float mMovementStartValue;\n     private float mStartingY;  // y coordinate of ACTION_DOWN\n     private float mStartingX;\n-    // The allowable values for the current boundary being dragged\n-    private Range<Float> mMotionRange;\n \n     // Value [0,1] indicating progress in animateEntrance()\n     private float mEntranceInterpolation = 1f;\n@@ -172,7 +170,6 @@ public class CropView extends View {\n                     mStartingX = event.getX();\n                     mMovementStartValue = getBoundaryPosition(mCurrentDraggingBoundary);\n                     updateListener(MotionEvent.ACTION_DOWN, event.getX());\n-                    mMotionRange = getAllowedValues(mCurrentDraggingBoundary);\n                 }\n                 return true;\n             case MotionEvent.ACTION_MOVE:\n@@ -185,8 +182,7 @@ public class CropView extends View {\n                                 : event.getX(pointerIndex) - mStartingX;\n                         float delta = pixelDistanceToFraction((int) deltaPx,\n                                 mCurrentDraggingBoundary);\n-                        setBoundaryPosition(mCurrentDraggingBoundary,\n-                                mMotionRange.clamp(mMovementStartValue + delta));\n+                        setBoundaryPosition(mCurrentDraggingBoundary, mMovementStartValue + delta);\n                         updateListener(MotionEvent.ACTION_MOVE, event.getX(pointerIndex));\n                         invalidate();\n                     }\n",
    "added_lines": 1,
    "deleted_lines": 5,
    "changed_methods": "CropView::onTouchEvent"
   }
  ]
 },
 {
  "hash": "834defa7e31a7d75de18de2fb148a7f845989830",
  "commit": "SystemUI: screenshot: add extra crop boundaries\n\nAdd corner boundaries that allow resizing in both vertical and\nhorizontal directions at the same time.\n\nTo handle corner boundaries, split every boundary into vertical\nand horizontal boundaries, and handle both vertical and horizontal\nchanges for all boundaries. If the boundary is a purely vertical\n(top, bottom) or purely horizontal (left, right) boundary, the\nopposite direction boundary will be none, and the selection won't\nbe changed on that selection.\n\nAlso, add a middle boundary that allows moving the current selection.\n\nTo achieve this, treat the middle boundary as composed of top and\nleft boundaries, and when trying to change either the top or the\nleft boundary while the currently dragged boundary is the middle\none, reposition the opposite boundary too.\n\nChange-Id: I6dd703733b3d161f5979d91a124350fb1a8d52ae",
  "files": [
   {
    "filename": "CropView.java",
    "diff": "@@ -57,7 +57,10 @@ public class CropView extends View {\n     private static final String TAG = \"CropView\";\n \n     public enum CropBoundary {\n-        NONE, TOP, BOTTOM, LEFT, RIGHT\n+        NONE, TOP, BOTTOM, LEFT, RIGHT,\n+        TOP_LEFT, TOP_RIGHT, BOTTOM_LEFT, BOTTOM_RIGHT,\n+        // Middle crop boundary is used for dragging\n+        MIDDLE,\n     }\n \n     private final float mCropTouchMargin;\n@@ -75,7 +78,8 @@ public class CropView extends View {\n     private CropBoundary mCurrentDraggingBoundary = CropBoundary.NONE;\n     private int mActivePointerId;\n     // The starting value of mCurrentDraggingBoundary's crop, used to compute touch deltas.\n-    private float mMovementStartValue;\n+    private float mMovementStartValueX;\n+    private float mMovementStartValueY;\n     private float mStartingY;  // y coordinate of ACTION_DOWN\n     private float mStartingX;\n \n@@ -168,7 +172,10 @@ public class CropView extends View {\n                     mActivePointerId = event.getPointerId(0);\n                     mStartingY = event.getY();\n                     mStartingX = event.getX();\n-                    mMovementStartValue = getBoundaryPosition(mCurrentDraggingBoundary);\n+                    CropBoundary hBoundary = getHorizontalBoundary(mCurrentDraggingBoundary);\n+                    CropBoundary vBoundary = getVerticalBoundary(mCurrentDraggingBoundary);\n+                    mMovementStartValueX = getBoundaryPosition(hBoundary);\n+                    mMovementStartValueY = getBoundaryPosition(vBoundary);\n                     updateListener(MotionEvent.ACTION_DOWN, event.getX());\n                 }\n                 return true;\n@@ -177,12 +184,14 @@ public class CropView extends View {\n                     int pointerIndex = event.findPointerIndex(mActivePointerId);\n                     if (pointerIndex >= 0) {\n                         // Original pointer still active, do the move.\n-                        float deltaPx = isVertical(mCurrentDraggingBoundary)\n-                                ? event.getY(pointerIndex) - mStartingY\n-                                : event.getX(pointerIndex) - mStartingX;\n-                        float delta = pixelDistanceToFraction((int) deltaPx,\n-                                mCurrentDraggingBoundary);\n-                        setBoundaryPosition(mCurrentDraggingBoundary, mMovementStartValue + delta);\n+                        CropBoundary hBoundary = getHorizontalBoundary(mCurrentDraggingBoundary);\n+                        CropBoundary vBoundary = getVerticalBoundary(mCurrentDraggingBoundary);\n+                        float deltaPxX = event.getX(pointerIndex) - mStartingX;\n+                        float deltaPxY = event.getY(pointerIndex) - mStartingY;\n+                        float deltaX = pixelDistanceToFraction((int) deltaPxX, hBoundary);\n+                        float deltaY = pixelDistanceToFraction((int) deltaPxY, vBoundary);\n+                        setBoundaryPosition(hBoundary, mMovementStartValueX + deltaX);\n+                        setBoundaryPosition(vBoundary, mMovementStartValueY + deltaY);\n                         updateListener(MotionEvent.ACTION_MOVE, event.getX(pointerIndex));\n                         invalidate();\n                     }\n@@ -238,15 +247,29 @@ public class CropView extends View {\n      * Set the given boundary to the given value without animation.\n      */\n     public void setBoundaryPosition(CropBoundary boundary, float position) {\n+        if (boundary == CropBoundary.NONE) {\n+            return;\n+        }\n+\n         position = (float) getAllowedValues(boundary).clamp(position);\n         switch (boundary) {\n             case TOP:\n+                if (mCurrentDraggingBoundary == CropBoundary.MIDDLE) {\n+                    // If the current dragging boundary is the middle, reposition the bottom side of\n+                    // the selection too, so that the selection appears to be moving.\n+                    mCrop.bottom = position + (mCrop.bottom - mCrop.top);\n+                }\n                 mCrop.top = position;\n                 break;\n             case BOTTOM:\n                 mCrop.bottom = position;\n                 break;\n             case LEFT:\n+                if (mCurrentDraggingBoundary == CropBoundary.MIDDLE) {\n+                    // If the current dragging boundary is the middle, reposition the right side of\n+                    // the selection too, so that the selection appears to be moving.\n+                    mCrop.right = position + (mCrop.right - mCrop.left);\n+                }\n                 mCrop.left = position;\n                 break;\n             case RIGHT:\n@@ -274,6 +297,38 @@ public class CropView extends View {\n         return 0;\n     }\n \n+    private CropBoundary getVerticalBoundary(CropBoundary boundary) {\n+        switch (boundary) {\n+            case TOP:\n+            case TOP_LEFT:\n+            case TOP_RIGHT:\n+            case MIDDLE:\n+                return CropBoundary.TOP;\n+            case BOTTOM:\n+            case BOTTOM_LEFT:\n+            case BOTTOM_RIGHT:\n+                return CropBoundary.BOTTOM;\n+            default:\n+                return CropBoundary.NONE;\n+        }\n+    }\n+\n+    private CropBoundary getHorizontalBoundary(CropBoundary boundary) {\n+        switch (boundary) {\n+            case LEFT:\n+            case TOP_LEFT:\n+            case BOTTOM_LEFT:\n+            case MIDDLE:\n+                return CropBoundary.LEFT;\n+            case RIGHT:\n+            case TOP_RIGHT:\n+            case BOTTOM_RIGHT:\n+                return CropBoundary.RIGHT;\n+            default:\n+                return CropBoundary.NONE;\n+        }\n+    }\n+\n     private static boolean isVertical(CropBoundary boundary) {\n         return boundary == CropBoundary.TOP || boundary == CropBoundary.BOTTOM;\n     }\n@@ -349,6 +404,11 @@ public class CropView extends View {\n     private Range getAllowedValues(CropBoundary boundary) {\n         switch (boundary) {\n             case TOP:\n+                if (mCurrentDraggingBoundary == CropBoundary.MIDDLE) {\n+                    // When the current dragging boundary is the middle, do not let the user move\n+                    // the selection past the bottom edge.\n+                    return new Range<>(0f, 1f - (mCrop.bottom - mCrop.top));\n+                }\n                 return new Range<>(0f,\n                         mCrop.bottom - pixelDistanceToFraction(mCropTouchMargin,\n                                 CropBoundary.BOTTOM));\n@@ -357,6 +417,11 @@ public class CropView extends View {\n                         mCrop.top + pixelDistanceToFraction(mCropTouchMargin,\n                                 CropBoundary.TOP), 1f);\n             case LEFT:\n+                if (mCurrentDraggingBoundary == CropBoundary.MIDDLE) {\n+                    // When the current dragging boundary is the middle, do not let the user move\n+                    // the selection past the right edge.\n+                    return new Range<>(0f, 1f - (mCrop.right - mCrop.left));\n+                }\n                 return new Range<>(0f,\n                         mCrop.right - pixelDistanceToFraction(mCropTouchMargin,\n                                 CropBoundary.RIGHT));\n@@ -373,16 +438,17 @@ public class CropView extends View {\n      * @param x coordinate of the relevant pointer.\n      */\n     private void updateListener(int action, float x) {\n-        if (mCropInteractionListener != null && isVertical(mCurrentDraggingBoundary)) {\n-            float boundaryPosition = getBoundaryPosition(mCurrentDraggingBoundary);\n+        CropBoundary boundary = getVerticalBoundary(mCurrentDraggingBoundary);\n+        if (mCropInteractionListener != null && boundary != CropBoundary.NONE) {\n+            float boundaryPosition = getBoundaryPosition(boundary);\n             switch (action) {\n                 case MotionEvent.ACTION_DOWN:\n-                    mCropInteractionListener.onCropDragStarted(mCurrentDraggingBoundary,\n+                    mCropInteractionListener.onCropDragStarted(boundary,\n                             boundaryPosition, fractionToVerticalPixels(boundaryPosition),\n                             (mCrop.left + mCrop.right) / 2, x);\n                     break;\n                 case MotionEvent.ACTION_MOVE:\n-                    mCropInteractionListener.onCropDragMoved(mCurrentDraggingBoundary,\n+                    mCropInteractionListener.onCropDragMoved(boundary,\n                             boundaryPosition, fractionToVerticalPixels(boundaryPosition),\n                             (mCrop.left + mCrop.right) / 2, x);\n                     break;\n@@ -462,10 +528,25 @@ public class CropView extends View {\n \n     private CropBoundary nearestBoundary(MotionEvent event, int topPx, int bottomPx, int leftPx,\n             int rightPx) {\n+        boolean isCloseToLeft = Math.abs(event.getX() - leftPx) < mCropTouchMargin;\n+        boolean isCloseToRight = Math.abs(event.getX() - rightPx) < mCropTouchMargin;\n+\n         if (Math.abs(event.getY() - topPx) < mCropTouchMargin) {\n+            if (isCloseToLeft) {\n+                return CropBoundary.TOP_LEFT;\n+            }\n+            if (isCloseToRight) {\n+                return CropBoundary.TOP_RIGHT;\n+            }\n             return CropBoundary.TOP;\n         }\n         if (Math.abs(event.getY() - bottomPx) < mCropTouchMargin) {\n+            if (isCloseToLeft) {\n+                return CropBoundary.BOTTOM_LEFT;\n+            }\n+            if (isCloseToRight) {\n+                return CropBoundary.BOTTOM_RIGHT;\n+            }\n             return CropBoundary.BOTTOM;\n         }\n         if (event.getY() > topPx || event.getY() < bottomPx) {\n@@ -476,6 +557,13 @@ public class CropView extends View {\n                 return CropBoundary.RIGHT;\n             }\n         }\n+\n+        float x = event.getX();\n+        float y = event.getY();\n+        if (x > leftPx && x < rightPx && y > topPx && y < bottomPx) {\n+            return CropBoundary.MIDDLE;\n+        }\n+\n         return CropBoundary.NONE;\n     }\n \n",
    "added_lines": 101,
    "deleted_lines": 13,
    "changed_methods": "CropView::getHorizontalBoundary, CropView::nearestBoundary, CropView::setBoundaryPosition, CropView::onTouchEvent, CropView::getAllowedValues, CropView::getVerticalBoundary, CropView::updateListener"
   }
  ]
 },
 {
  "hash": "92abcecfe2bd5a84a601a5eafd3ddf75c3968d38",
  "commit": "SystemUI: screenshot: disable magnification for partial screenshots\n\nPartial screenshots are screen-size and don't need a magnifying glass.\n\nChange-Id: I472103352411d1482423230a4ff08ddda45cc53d",
  "files": [
   {
    "filename": "LongScreenshotActivity.java",
    "diff": "@@ -181,6 +181,7 @@ public class LongScreenshotActivity extends Activity {\n             mCacheLoadFuture = null;\n         } else {\n             LongScreenshot longScreenshot = mLongScreenshotHolder.takeLongScreenshot();\n+            setMagnification(mLongScreenshotHolder.getNeedsMagnification());\n             if (longScreenshot != null) {\n                 onLongScreenshotReceived(longScreenshot);\n             } else {\n@@ -190,6 +191,14 @@ public class LongScreenshotActivity extends Activity {\n         }\n     }\n \n+    private void setMagnification(boolean status) {\n+        if (status) {\n+            mCropView.setCropInteractionListener(mMagnifierView);\n+        } else {\n+            mCropView.setCropInteractionListener(null);\n+        }\n+    }\n+\n     private void onLongScreenshotReceived(LongScreenshot longScreenshot) {\n         Log.i(TAG, \"Completed: \" + longScreenshot);\n         mLongScreenshot = longScreenshot;\n",
    "added_lines": 9,
    "deleted_lines": 0,
    "changed_methods": "LongScreenshotActivity::setMagnification, LongScreenshotActivity::onStart"
   },
   {
    "filename": "LongScreenshotData.java",
    "diff": "@@ -32,6 +32,7 @@ public class LongScreenshotData {\n     private final AtomicReference<ScreenshotController.TransitionDestination>\n             mTransitionDestinationCallback;\n     private String mForegroundAppName;\n+    private boolean mNeedsMagnification;\n \n     @Inject\n     public LongScreenshotData() {\n@@ -88,4 +89,12 @@ public class LongScreenshotData {\n     public String getForegroundAppName() {\n         return mForegroundAppName;\n     }\n+\n+    public void setNeedsMagnification(boolean status) {\n+        mNeedsMagnification = status;\n+    }\n+\n+    public boolean getNeedsMagnification() {\n+        return mNeedsMagnification;\n+    }\n }\n",
    "added_lines": 9,
    "deleted_lines": 0,
    "changed_methods": "LongScreenshotData::getNeedsMagnification, LongScreenshotData::setNeedsMagnification"
   },
   {
    "filename": "ScreenshotController.java",
    "diff": "@@ -733,6 +733,7 @@ public class ScreenshotController {\n         ScrollCaptureController.BitmapScreenshot bitmapScreenshot =\n             new ScrollCaptureController.BitmapScreenshot(mContext, newScreenshot);\n \n+        mLongScreenshotHolder.setNeedsMagnification(false);\n         startLongScreenshotActivity(bitmapScreenshot);\n     }\n \n@@ -785,6 +786,7 @@ public class ScreenshotController {\n                             return;\n                         }\n \n+                        mLongScreenshotHolder.setNeedsMagnification(true);\n                         startLongScreenshotActivity(longScreenshot);\n                     }, mMainExecutor);\n                 });\n",
    "added_lines": 2,
    "deleted_lines": 0,
    "changed_methods": "ScreenshotController::startPartialScreenshotActivity, ScreenshotController::onScrollCaptureResponseReady"
   }
  ]
 },
 {
  "hash": "92abcecfe2bd5a84a601a5eafd3ddf75c3968d38",
  "commit": "SystemUI: screenshot: disable magnification for partial screenshots\n\nPartial screenshots are screen-size and don't need a magnifying glass.\n\nChange-Id: I472103352411d1482423230a4ff08ddda45cc53d",
  "files": [
   {
    "filename": "LongScreenshotActivity.java",
    "diff": "@@ -181,6 +181,7 @@ public class LongScreenshotActivity extends Activity {\n             mCacheLoadFuture = null;\n         } else {\n             LongScreenshot longScreenshot = mLongScreenshotHolder.takeLongScreenshot();\n+            setMagnification(mLongScreenshotHolder.getNeedsMagnification());\n             if (longScreenshot != null) {\n                 onLongScreenshotReceived(longScreenshot);\n             } else {\n@@ -190,6 +191,14 @@ public class LongScreenshotActivity extends Activity {\n         }\n     }\n \n+    private void setMagnification(boolean status) {\n+        if (status) {\n+            mCropView.setCropInteractionListener(mMagnifierView);\n+        } else {\n+            mCropView.setCropInteractionListener(null);\n+        }\n+    }\n+\n     private void onLongScreenshotReceived(LongScreenshot longScreenshot) {\n         Log.i(TAG, \"Completed: \" + longScreenshot);\n         mLongScreenshot = longScreenshot;\n",
    "added_lines": 9,
    "deleted_lines": 0,
    "changed_methods": "LongScreenshotActivity::setMagnification, LongScreenshotActivity::onStart"
   },
   {
    "filename": "LongScreenshotData.java",
    "diff": "@@ -32,6 +32,7 @@ public class LongScreenshotData {\n     private final AtomicReference<ScreenshotController.TransitionDestination>\n             mTransitionDestinationCallback;\n     private String mForegroundAppName;\n+    private boolean mNeedsMagnification;\n \n     @Inject\n     public LongScreenshotData() {\n@@ -88,4 +89,12 @@ public class LongScreenshotData {\n     public String getForegroundAppName() {\n         return mForegroundAppName;\n     }\n+\n+    public void setNeedsMagnification(boolean status) {\n+        mNeedsMagnification = status;\n+    }\n+\n+    public boolean getNeedsMagnification() {\n+        return mNeedsMagnification;\n+    }\n }\n",
    "added_lines": 9,
    "deleted_lines": 0,
    "changed_methods": "LongScreenshotData::getNeedsMagnification, LongScreenshotData::setNeedsMagnification"
   },
   {
    "filename": "ScreenshotController.java",
    "diff": "@@ -733,6 +733,7 @@ public class ScreenshotController {\n         ScrollCaptureController.BitmapScreenshot bitmapScreenshot =\n             new ScrollCaptureController.BitmapScreenshot(mContext, newScreenshot);\n \n+        mLongScreenshotHolder.setNeedsMagnification(false);\n         startLongScreenshotActivity(bitmapScreenshot);\n     }\n \n@@ -785,6 +786,7 @@ public class ScreenshotController {\n                             return;\n                         }\n \n+                        mLongScreenshotHolder.setNeedsMagnification(true);\n                         startLongScreenshotActivity(longScreenshot);\n                     }, mMainExecutor);\n                 });\n",
    "added_lines": 2,
    "deleted_lines": 0,
    "changed_methods": "ScreenshotController::startPartialScreenshotActivity, ScreenshotController::onScrollCaptureResponseReady"
   }
  ]
 },
 {
  "hash": "92abcecfe2bd5a84a601a5eafd3ddf75c3968d38",
  "commit": "SystemUI: screenshot: disable magnification for partial screenshots\n\nPartial screenshots are screen-size and don't need a magnifying glass.\n\nChange-Id: I472103352411d1482423230a4ff08ddda45cc53d",
  "files": [
   {
    "filename": "LongScreenshotActivity.java",
    "diff": "@@ -181,6 +181,7 @@ public class LongScreenshotActivity extends Activity {\n             mCacheLoadFuture = null;\n         } else {\n             LongScreenshot longScreenshot = mLongScreenshotHolder.takeLongScreenshot();\n+            setMagnification(mLongScreenshotHolder.getNeedsMagnification());\n             if (longScreenshot != null) {\n                 onLongScreenshotReceived(longScreenshot);\n             } else {\n@@ -190,6 +191,14 @@ public class LongScreenshotActivity extends Activity {\n         }\n     }\n \n+    private void setMagnification(boolean status) {\n+        if (status) {\n+            mCropView.setCropInteractionListener(mMagnifierView);\n+        } else {\n+            mCropView.setCropInteractionListener(null);\n+        }\n+    }\n+\n     private void onLongScreenshotReceived(LongScreenshot longScreenshot) {\n         Log.i(TAG, \"Completed: \" + longScreenshot);\n         mLongScreenshot = longScreenshot;\n",
    "added_lines": 9,
    "deleted_lines": 0,
    "changed_methods": "LongScreenshotActivity::setMagnification, LongScreenshotActivity::onStart"
   },
   {
    "filename": "LongScreenshotData.java",
    "diff": "@@ -32,6 +32,7 @@ public class LongScreenshotData {\n     private final AtomicReference<ScreenshotController.TransitionDestination>\n             mTransitionDestinationCallback;\n     private String mForegroundAppName;\n+    private boolean mNeedsMagnification;\n \n     @Inject\n     public LongScreenshotData() {\n@@ -88,4 +89,12 @@ public class LongScreenshotData {\n     public String getForegroundAppName() {\n         return mForegroundAppName;\n     }\n+\n+    public void setNeedsMagnification(boolean status) {\n+        mNeedsMagnification = status;\n+    }\n+\n+    public boolean getNeedsMagnification() {\n+        return mNeedsMagnification;\n+    }\n }\n",
    "added_lines": 9,
    "deleted_lines": 0,
    "changed_methods": "LongScreenshotData::getNeedsMagnification, LongScreenshotData::setNeedsMagnification"
   },
   {
    "filename": "ScreenshotController.java",
    "diff": "@@ -733,6 +733,7 @@ public class ScreenshotController {\n         ScrollCaptureController.BitmapScreenshot bitmapScreenshot =\n             new ScrollCaptureController.BitmapScreenshot(mContext, newScreenshot);\n \n+        mLongScreenshotHolder.setNeedsMagnification(false);\n         startLongScreenshotActivity(bitmapScreenshot);\n     }\n \n@@ -785,6 +786,7 @@ public class ScreenshotController {\n                             return;\n                         }\n \n+                        mLongScreenshotHolder.setNeedsMagnification(true);\n                         startLongScreenshotActivity(longScreenshot);\n                     }, mMainExecutor);\n                 });\n",
    "added_lines": 2,
    "deleted_lines": 0,
    "changed_methods": "ScreenshotController::startPartialScreenshotActivity, ScreenshotController::onScrollCaptureResponseReady"
   }
  ]
 },
 {
  "hash": "45cefae04e40dc0de22e2dcdfcb1854431055edb",
  "commit": "SystemUI: screenshot: close QS after launching long screenshot activity\n\nChange-Id: Ief5510c037b27be714f8f6cc8661d81931f3babd",
  "files": [
   {
    "filename": "ScreenshotController.java",
    "diff": "@@ -90,6 +90,7 @@ import android.window.WindowContext;\n import com.android.internal.app.ChooserActivity;\n import com.android.internal.logging.UiEventLogger;\n import com.android.internal.policy.PhoneWindow;\n+import com.android.internal.statusbar.IStatusBarService;\n import com.android.settingslib.applications.InterestingConfigChanges;\n import com.android.systemui.R;\n import com.android.systemui.dagger.qualifiers.Main;\n@@ -263,6 +264,7 @@ public class ScreenshotController {\n     private final PhoneWindow mWindow;\n     private final DisplayManager mDisplayManager;\n     private final ScrollCaptureController mScrollCaptureController;\n+    private final IStatusBarService mStatusBarService;\n     private final LongScreenshotData mLongScreenshotHolder;\n     private final Vibrator mVibrator;\n     private final boolean mIsLowRamDevice;\n@@ -341,6 +343,7 @@ public class ScreenshotController {\n             ImageExporter imageExporter,\n             @Main Executor mainExecutor,\n             ScrollCaptureController scrollCaptureController,\n+            IStatusBarService statusBarService,\n             LongScreenshotData longScreenshotHolder,\n             ActivityManager activityManager) {\n         mScreenshotSmartActions = screenshotSmartActions;\n@@ -350,6 +353,7 @@ public class ScreenshotController {\n         mImageExporter = imageExporter;\n         mMainExecutor = mainExecutor;\n         mScrollCaptureController = scrollCaptureController;\n+        mStatusBarService = statusBarService;\n         mLongScreenshotHolder = longScreenshotHolder;\n         mIsLowRamDevice = activityManager.isLowRamDevice();\n         mBgExecutor = Executors.newSingleThreadExecutor();\n@@ -725,6 +729,12 @@ public class ScreenshotController {\n         } catch (Exception e) {\n             Log.e(TAG, \"Error overriding screenshot app transition\", e);\n         }\n+\n+        try {\n+            mStatusBarService.collapsePanels();\n+        } catch (RemoteException e) {\n+            Log.e(TAG, \"Error during collapsing panels\", e);\n+        }\n     }\n \n     private void startPartialScreenshotActivity() {\n",
    "added_lines": 10,
    "deleted_lines": 0,
    "changed_methods": "ScreenshotController::ScreenshotController, ScreenshotController::startLongScreenshotActivity"
   }
  ]
 },
 {
  "hash": "484c59b972c1772f75a4b1b9fce7512eee517dcb",
  "commit": "SystemUI: screenshot: add delay for long-press partial screenshot\n\n* Otherwise, we get power menu in screenshot.\n\nSigned-off-by: Pranav Vashi <neobuddy89@gmail.com>\nChange-Id: I018994c16eedfabffd6b7c291377668701c0e00d",
  "files": [
   {
    "filename": "GlobalActionsDialogLite.java",
    "diff": "@@ -1131,8 +1131,7 @@ public class GlobalActionsDialogLite implements DialogInterface.OnDismissListene\n             super(R.drawable.ic_screenshot, R.string.global_action_screenshot);\n         }\n \n-        @Override\n-        public void onPress() {\n+        private void takeScreenshot(int type) {\n             // Add a little delay before executing, to give the\n             // dialog a chance to go away before it takes a\n             // screenshot.\n@@ -1140,7 +1139,7 @@ public class GlobalActionsDialogLite implements DialogInterface.OnDismissListene\n             mHandler.postDelayed(new Runnable() {\n                 @Override\n                 public void run() {\n-                    mScreenshotHelper.takeScreenshot(TAKE_SCREENSHOT_FULLSCREEN, true, true,\n+                    mScreenshotHelper.takeScreenshot(type, true, true,\n                             SCREENSHOT_GLOBAL_ACTIONS, mHandler, null);\n                     mMetricsLogger.action(MetricsEvent.ACTION_SCREENSHOT_POWER_MENU);\n                     mUiEventLogger.log(GlobalActionsEvent.GA_SCREENSHOT_PRESS);\n@@ -1148,10 +1147,15 @@ public class GlobalActionsDialogLite implements DialogInterface.OnDismissListene\n             }, mDialogPressDelay);\n         }\n \n+        @Override\n+        public void onPress() {\n+            takeScreenshot(TAKE_SCREENSHOT_FULLSCREEN);\n+        }\n+\n         @Override\n         public boolean onLongPress() {\n-            mScreenshotHelper.takeScreenshot(TAKE_SCREENSHOT_SELECTED_REGION, true, true,\n-                    SCREENSHOT_GLOBAL_ACTIONS, mHandler, null);\n+            takeScreenshot(TAKE_SCREENSHOT_SELECTED_REGION);\n+\n             return true;\n         }\n \n",
    "added_lines": 9,
    "deleted_lines": 5,
    "changed_methods": "GlobalActionsDialogLite::ScreenshotAction::onLongPress, GlobalActionsDialogLite::ScreenshotAction::onPress, GlobalActionsDialogLite::ScreenshotAction::takeScreenshot"
   }
  ]
 },
 {
  "hash": "1b62ea8bfae85099b20f48509f97f37d70149b43",
  "commit": "Revert \"Do not re-inflate QS and SB when CONFIG_UI_MODE\"\n\nThis reverts commit 8a40ff855b86bc86e23367017002289920855a4e.\n\nThis is a prerequisite for making the QS panel follow the light system\nmode setting.\n\nChange-Id: Ibad399ece587505559cc73febdda2f2d8558e94d",
  "files": [
   {
    "filename": "FragmentHostManager.java",
    "diff": "@@ -53,7 +53,8 @@ public class FragmentHostManager {\n     private final View mRootView;\n     private final InterestingConfigChanges mConfigChanges = new InterestingConfigChanges(\n             ActivityInfo.CONFIG_FONT_SCALE | ActivityInfo.CONFIG_LOCALE\n-                | ActivityInfo.CONFIG_SCREEN_LAYOUT | ActivityInfo.CONFIG_ASSETS_PATHS);\n+                | ActivityInfo.CONFIG_SCREEN_LAYOUT | ActivityInfo.CONFIG_ASSETS_PATHS\n+                | ActivityInfo.CONFIG_UI_MODE);\n     private final FragmentService mManager;\n     private final ExtensionFragmentManager mPlugins = new ExtensionFragmentManager();\n \n",
    "added_lines": 2,
    "deleted_lines": 1,
    "changed_methods": ""
   }
  ]
 },
 {
  "hash": "3e99d1767968a27405a5656a47c6bc87c12d684c",
  "commit": "SystemUI: Follow light/dark theme in quick settings\n\nAndroid 12's dual-tone style where the quick settings panel is always\ndark makes the light theme look like a second-class citizen. Pure black\nalso looks out-of-place next to QS tiles and the notification panel\nbecause dynamic themes don't affect it at all.\n\nRevert to the ~Beta 1 style where quick settings used the same theme as\nthe notification shade.\n\n- colorAccentPrimary has been replaced with colorAccent for contrast in\n  light mode, because colorAccentPrimary is system_accent1_100 (dark\n  accent color)\n- Footer chips have been converted to surfaces (similar to QS tiles and\n  notifications), which makes more sense with the new style\n- The QS background is now the same as the notification shade background\n  in both light and dark modes\n\nDemo screenshots (with dual-tone commit):\nhttps://twitter.com/kdrag0n/status/1445922541218922496\n\n[kdrag0n: ported to 12L]\n\nChange-Id: I3d45b72f0f119e100505409d178ab8f698993881",
  "files": [
   {
    "filename": "ScrimController.java",
    "diff": "@@ -704,7 +704,7 @@ public class ScrimController implements ViewTreeObserver.OnPreDrawListener, Dump\n                 mNotificationsAlpha = behindAlpha;\n                 mNotificationsTint = behindTint;\n                 mBehindAlpha = 1;\n-                mBehindTint = Color.BLACK;\n+                mBehindTint = Color.TRANSPARENT;\n             } else {\n                 mBehindAlpha = behindAlpha;\n                 if (mState == ScrimState.SHADE_LOCKED) {\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "ScrimController::applyState"
   },
   {
    "filename": "ScrimState.java",
    "diff": "@@ -82,7 +82,7 @@ public enum ScrimState {\n             mBehindAlpha = mClipQsScrim ? 1 : mScrimBehindAlphaKeyguard;\n             mNotifAlpha = mClipQsScrim ? mScrimBehindAlphaKeyguard : 0;\n             if (mClipQsScrim) {\n-                updateScrimColor(mScrimBehind, 1f /* alpha */, Color.BLACK);\n+                updateScrimColor(mScrimBehind, 1f /* alpha */, Color.TRANSPARENT);\n             }\n         }\n     },\n@@ -119,7 +119,7 @@ public enum ScrimState {\n         @Override\n         public void prepare(ScrimState previousState) {\n             mBehindAlpha = mClipQsScrim ? 1 : mDefaultScrimAlpha;\n-            mBehindTint = mClipQsScrim ? Color.BLACK : Color.TRANSPARENT;\n+            mBehindTint = Color.TRANSPARENT;\n             mNotifAlpha = mClipQsScrim ? mDefaultScrimAlpha : 0;\n             mNotifTint = Color.TRANSPARENT;\n             mFrontAlpha = 0f;\n@@ -143,17 +143,17 @@ public enum ScrimState {\n             mBehindAlpha = mClipQsScrim ? 1 : mDefaultScrimAlpha;\n             mNotifAlpha = 1f;\n             mFrontAlpha = 0f;\n-            mBehindTint = Color.BLACK;\n+            mBehindTint = Color.TRANSPARENT;\n \n             if (mClipQsScrim) {\n-                updateScrimColor(mScrimBehind, 1f /* alpha */, Color.BLACK);\n+                updateScrimColor(mScrimBehind, 1f /* alpha */, Color.TRANSPARENT);\n             }\n         }\n \n         // to make sure correct color is returned before \"prepare\" is called\n         @Override\n         public int getBehindTint() {\n-            return Color.BLACK;\n+            return Color.TRANSPARENT;\n         }\n     },\n \n@@ -244,22 +244,22 @@ public enum ScrimState {\n             mAnimateChange = !mLaunchingAffordanceWithPreview && !fromAod;\n \n             mFrontTint = Color.TRANSPARENT;\n-            mBehindTint = Color.BLACK;\n+            mBehindTint = Color.TRANSPARENT;\n             mBlankScreen = false;\n \n             if (previousState == ScrimState.AOD) {\n                 // Set all scrims black, before they fade transparent.\n                 updateScrimColor(mScrimInFront, 1f /* alpha */, Color.BLACK /* tint */);\n-                updateScrimColor(mScrimBehind, 1f /* alpha */, Color.BLACK /* tint */);\n+                updateScrimColor(mScrimBehind, 1f /* alpha */, Color.TRANSPARENT /* tint */);\n \n                 // Scrims should still be black at the end of the transition.\n                 mFrontTint = Color.BLACK;\n-                mBehindTint = Color.BLACK;\n+                mBehindTint = Color.TRANSPARENT;\n                 mBlankScreen = true;\n             }\n \n             if (mClipQsScrim) {\n-                updateScrimColor(mScrimBehind, 1f /* alpha */, Color.BLACK);\n+                updateScrimColor(mScrimBehind, 1f /* alpha */, Color.TRANSPARENT);\n             }\n         }\n     };\n",
    "added_lines": 9,
    "deleted_lines": 9,
    "changed_methods": "prepare, getBehindTint"
   }
  ]
 },
 {
  "hash": "3e99d1767968a27405a5656a47c6bc87c12d684c",
  "commit": "SystemUI: Follow light/dark theme in quick settings\n\nAndroid 12's dual-tone style where the quick settings panel is always\ndark makes the light theme look like a second-class citizen. Pure black\nalso looks out-of-place next to QS tiles and the notification panel\nbecause dynamic themes don't affect it at all.\n\nRevert to the ~Beta 1 style where quick settings used the same theme as\nthe notification shade.\n\n- colorAccentPrimary has been replaced with colorAccent for contrast in\n  light mode, because colorAccentPrimary is system_accent1_100 (dark\n  accent color)\n- Footer chips have been converted to surfaces (similar to QS tiles and\n  notifications), which makes more sense with the new style\n- The QS background is now the same as the notification shade background\n  in both light and dark modes\n\nDemo screenshots (with dual-tone commit):\nhttps://twitter.com/kdrag0n/status/1445922541218922496\n\n[kdrag0n: ported to 12L]\n\nChange-Id: I3d45b72f0f119e100505409d178ab8f698993881",
  "files": [
   {
    "filename": "ScrimController.java",
    "diff": "@@ -704,7 +704,7 @@ public class ScrimController implements ViewTreeObserver.OnPreDrawListener, Dump\n                 mNotificationsAlpha = behindAlpha;\n                 mNotificationsTint = behindTint;\n                 mBehindAlpha = 1;\n-                mBehindTint = Color.BLACK;\n+                mBehindTint = Color.TRANSPARENT;\n             } else {\n                 mBehindAlpha = behindAlpha;\n                 if (mState == ScrimState.SHADE_LOCKED) {\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "ScrimController::applyState"
   },
   {
    "filename": "ScrimState.java",
    "diff": "@@ -82,7 +82,7 @@ public enum ScrimState {\n             mBehindAlpha = mClipQsScrim ? 1 : mScrimBehindAlphaKeyguard;\n             mNotifAlpha = mClipQsScrim ? mScrimBehindAlphaKeyguard : 0;\n             if (mClipQsScrim) {\n-                updateScrimColor(mScrimBehind, 1f /* alpha */, Color.BLACK);\n+                updateScrimColor(mScrimBehind, 1f /* alpha */, Color.TRANSPARENT);\n             }\n         }\n     },\n@@ -119,7 +119,7 @@ public enum ScrimState {\n         @Override\n         public void prepare(ScrimState previousState) {\n             mBehindAlpha = mClipQsScrim ? 1 : mDefaultScrimAlpha;\n-            mBehindTint = mClipQsScrim ? Color.BLACK : Color.TRANSPARENT;\n+            mBehindTint = Color.TRANSPARENT;\n             mNotifAlpha = mClipQsScrim ? mDefaultScrimAlpha : 0;\n             mNotifTint = Color.TRANSPARENT;\n             mFrontAlpha = 0f;\n@@ -143,17 +143,17 @@ public enum ScrimState {\n             mBehindAlpha = mClipQsScrim ? 1 : mDefaultScrimAlpha;\n             mNotifAlpha = 1f;\n             mFrontAlpha = 0f;\n-            mBehindTint = Color.BLACK;\n+            mBehindTint = Color.TRANSPARENT;\n \n             if (mClipQsScrim) {\n-                updateScrimColor(mScrimBehind, 1f /* alpha */, Color.BLACK);\n+                updateScrimColor(mScrimBehind, 1f /* alpha */, Color.TRANSPARENT);\n             }\n         }\n \n         // to make sure correct color is returned before \"prepare\" is called\n         @Override\n         public int getBehindTint() {\n-            return Color.BLACK;\n+            return Color.TRANSPARENT;\n         }\n     },\n \n@@ -244,22 +244,22 @@ public enum ScrimState {\n             mAnimateChange = !mLaunchingAffordanceWithPreview && !fromAod;\n \n             mFrontTint = Color.TRANSPARENT;\n-            mBehindTint = Color.BLACK;\n+            mBehindTint = Color.TRANSPARENT;\n             mBlankScreen = false;\n \n             if (previousState == ScrimState.AOD) {\n                 // Set all scrims black, before they fade transparent.\n                 updateScrimColor(mScrimInFront, 1f /* alpha */, Color.BLACK /* tint */);\n-                updateScrimColor(mScrimBehind, 1f /* alpha */, Color.BLACK /* tint */);\n+                updateScrimColor(mScrimBehind, 1f /* alpha */, Color.TRANSPARENT /* tint */);\n \n                 // Scrims should still be black at the end of the transition.\n                 mFrontTint = Color.BLACK;\n-                mBehindTint = Color.BLACK;\n+                mBehindTint = Color.TRANSPARENT;\n                 mBlankScreen = true;\n             }\n \n             if (mClipQsScrim) {\n-                updateScrimColor(mScrimBehind, 1f /* alpha */, Color.BLACK);\n+                updateScrimColor(mScrimBehind, 1f /* alpha */, Color.TRANSPARENT);\n             }\n         }\n     };\n",
    "added_lines": 9,
    "deleted_lines": 9,
    "changed_methods": "prepare, getBehindTint"
   }
  ]
 },
 {
  "hash": "13ddb603f5c0cfd8cd8999938b55fd06991c5133",
  "commit": "SystemUI: Initialize QS tiles in inactive state\n\nNow that the QS fragment is recreated when changing the UI mode (so that\nit follows light/dark themes), all tiles flash with active color briefly\nbecause the new views become visible before states are refreshed.\n\nInitializing tiles in the inactive state is much less disruptive, and\nthe effect is very hard to see as compared to the active color because\nthe background color is much less prominent.\n\nChange-Id: I048171d503f5533e91bab486b8805ac15c329f31",
  "files": [
   {
    "filename": "QSTile.java",
    "diff": "@@ -148,7 +148,7 @@ public interface QSTile {\n     @ProvidesInterface(version = State.VERSION)\n     public static class State {\n         public static final int VERSION = 1;\n-        public static final int DEFAULT_STATE = Tile.STATE_ACTIVE;\n+        public static final int DEFAULT_STATE = Tile.STATE_INACTIVE;\n \n         public Icon icon;\n         public Supplier<Icon> iconSupplier;\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": ""
   }
  ]
 },
 {
  "hash": "efdefe7d7daf1d403b11a1d5fcd391000e8d2047",
  "commit": "SystemUI: Add dual-tone light and dark themes for QS\n\nGoogle's dual-tone QS design where the notification panel has a\nsemantically higher elevation adds depth to the notification+QS shade,\nand we don't necessarily have to give it up just because our QS has\nlight and dark themes.\n\nTo preserve the dual-tone effect, use a darker background color for the\nQS section:\n\nLight:\n    Notifications: neutral1 20 (surface_light)\n    Notification panel: neutral1 50 (light BG)\n    QS background: neutral1 100 (darker light BG / surface_header_light)\n    Inactive QS tiles: neutral1 20 (surface_light)\n\nDark:\n    Notifications: neutral1 800 (surface_dark)\n    Notification panel: neutral1 900 (dark BG)\n    QS background: neutral1 950 (surface_header_dark_sysui modulated to L* 5)\n    Inactive QS tiles: neutral1 800 (surface_dark)\n\nThe dark QS background could be neutral1 0 (black) like it was before,\nbut I don't think it looks as good because it can't be tinted based on\nthe active wallpaper and thus stands out from other colors.\n\nUnfortunately, Google's current CAM16-based modulation causes hue shifts\nin extreme light and dark shades (e.g. L* = 98 / 5), but we'll fix this\nby generating and overlaying modulated surface colors in our\nThemeOverlayController implementation.\n\nDemo screenshots: https://twitter.com/kdrag0n/status/1445922541218922496\n\nChange-Id: Icdc4957ecb4e0201377351f1a3e1c6928d6b3955",
  "files": [
   {
    "filename": "ScrimController.java",
    "diff": "@@ -180,6 +180,7 @@ public class ScrimController implements ViewTreeObserver.OnPreDrawListener, Dump\n     private UnlockedScreenOffAnimationController mUnlockedScreenOffAnimationController;\n \n     private GradientColors mColors;\n+    private GradientColors mBehindColors;\n     private boolean mNeedsDrawableColorUpdate;\n \n     private float mScrimBehindAlphaKeyguard = KEYGUARD_SCRIM_ALPHA;\n@@ -276,6 +277,7 @@ public class ScrimController implements ViewTreeObserver.OnPreDrawListener, Dump\n         );\n \n         mColors = new GradientColors();\n+        mBehindColors = new GradientColors();\n     }\n \n     /**\n@@ -874,7 +876,7 @@ public class ScrimController implements ViewTreeObserver.OnPreDrawListener, Dump\n                     && !mBlankScreen;\n \n             mScrimInFront.setColors(mColors, animateScrimInFront);\n-            mScrimBehind.setColors(mColors, animateBehindScrim);\n+            mScrimBehind.setColors(mBehindColors, animateBehindScrim);\n             mNotificationsScrim.setColors(mColors, animateScrimNotifications);\n \n             dispatchBackScrimState(mScrimBehind.getViewAlpha());\n@@ -1214,11 +1216,19 @@ public class ScrimController implements ViewTreeObserver.OnPreDrawListener, Dump\n         if (mScrimBehind == null) return;\n         int background = Utils.getColorAttr(mScrimBehind.getContext(),\n                 android.R.attr.colorBackgroundFloating).getDefaultColor();\n+        int surfaceBackground = Utils.getColorAttr(mScrimBehind.getContext(),\n+                com.android.internal.R.attr.colorSurfaceHeader).getDefaultColor();\n         int accent = Utils.getColorAccent(mScrimBehind.getContext()).getDefaultColor();\n         mColors.setMainColor(background);\n         mColors.setSecondaryColor(accent);\n         mColors.setSupportsDarkText(\n                 ColorUtils.calculateContrast(mColors.getMainColor(), Color.WHITE) > 4.5);\n+\n+        mBehindColors.setMainColor(surfaceBackground);\n+        mBehindColors.setSecondaryColor(accent);\n+        mBehindColors.setSupportsDarkText(\n+                ColorUtils.calculateContrast(mBehindColors.getMainColor(), Color.WHITE) > 4.5);\n+\n         mNeedsDrawableColorUpdate = true;\n     }\n \n",
    "added_lines": 11,
    "deleted_lines": 1,
    "changed_methods": "ScrimController::ScrimController, ScrimController::updateScrims, ScrimController::updateThemeColors"
   }
  ]
 },
 {
  "hash": "643d46cefd3548dab0b55cadfb52c5d7247d601c",
  "commit": "SystemUI: Fix QS clock overlapping on UI mode change\n\nCalling updateAnimators() in a separate runnable seems to\ncause QSB header elements to overlap each other when switching\nbetween dark and light mode. This change was introduced in\nhttps://github.com/LineageOS/android_frameworks_base/commit/0558e1211604b3b6f465a394832bbf8fa06d1dfe and seems unnecessary so lets revert it.\n\nChange-Id: I14e60b608f2aac373e71fec0a6ab7d8e787d2457",
  "files": [
   {
    "filename": "QuickStatusBarHeader.java",
    "diff": "@@ -198,7 +198,7 @@ public class QuickStatusBarHeader extends FrameLayout implements TunerService.Tu\n         super.onMeasure(widthMeasureSpec, heightMeasureSpec);\n         if (mDatePrivacyView.getMeasuredHeight() != mTopViewMeasureHeight) {\n             mTopViewMeasureHeight = mDatePrivacyView.getMeasuredHeight();\n-            post(this::updateAnimators);\n+            updateAnimators();\n         }\n     }\n \n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "QuickStatusBarHeader::onMeasure"
   }
  ]
 },
 {
  "hash": "2f6486cc1099224384bebd611cea9e5291f08a6d",
  "commit": "SystemUI: Calculate paged QS tiles height properly\n\nWhen QS is re-inflated during UI mode change and we're on the\n3rd or higher QS page, the first QS page is misaligned and\nhence height returns 0, resulting in footer and media panel\nposition overlapping the QS panel. Return the maximum height\namong all present QS pages to fix this issue.\n\nChange-Id: I539babdb75c114cc44b4213ff114d4272be22ef6",
  "files": [
   {
    "filename": "PagedTileLayout.java",
    "diff": "@@ -111,12 +111,16 @@ public class PagedTileLayout extends ViewPager implements QSTileLayout {\n \n     @Override\n     public int getTilesHeight() {\n-        // Use the first page as that is the maximum height we need to show.\n-        TileLayout tileLayout = mPages.get(0);\n-        if (tileLayout == null) {\n-            return 0;\n+        // Find the maximum height among all pages.\n+        int height = 0;\n+        for (int i = 0; i < mPages.size(); i++) {\n+            TileLayout tileLayout = mPages.get(i);\n+            if (tileLayout != null) {\n+                height = Math.max(height, tileLayout.getTilesHeight());\n+            }\n         }\n-        return tileLayout.getTilesHeight();\n+        if (DEBUG) Log.d(TAG, \"getTilesHeight ret=\" + height);\n+        return height;\n     }\n \n     @Override\n",
    "added_lines": 9,
    "deleted_lines": 5,
    "changed_methods": "PagedTileLayout::getTilesHeight"
   }
  ]
 },
 {
  "hash": "22b7fd2e39b0e133437788f234a978144b06485d",
  "commit": "SystemUI: Follow light/dark theme in power menu\n\nNow that we've modified the power menu to refresh on UI mode changes,\nmake it follow the system light/dark theme for better integration in\nlight mode.\n\nSystemUI: Always refresh power menu on UI mode change\n\nThis is necessary for reliably theming the global actions dialog with\ndynamic colors and adapting it to light/dark themes.\n\nDemo screenshots (with color overlays applied):\nhttps://twitter.com/kdrag0n/status/1445960685427433473\n\n[kdrag0n: ported to 12L]\n\nChange-Id: If58fb4079a4cd11414ff928fad3576beecb14ff5\nSigned-off-by: althafvly <althafvly@gmail.com>",
  "files": [
   {
    "filename": "GlobalActionsDialogLite.java",
    "diff": "@@ -787,6 +787,15 @@ public class GlobalActionsDialogLite implements DialogInterface.OnDismissListene\n                 && (currentUser == null || currentUser.isPrimary());\n     }\n \n+    @Override\n+    public void onUiModeChanged() {\n+        // Colors may change, depending on UI mode\n+        mContext.getTheme().applyStyle(mContext.getThemeResId(), true);\n+        if (mDialog != null && mDialog.isShowing()) {\n+            mDialog.refreshDialog();\n+        }\n+    }\n+\n     @Override\n     public void onConfigChanged(Configuration newConfig) {\n         if (mDialog != null && mDialog.isShowing()\n",
    "added_lines": 9,
    "deleted_lines": 0,
    "changed_methods": "GlobalActionsDialogLite::onUiModeChanged"
   }
  ]
 },
 {
  "hash": "3367784f32d5faced63c893824bb996f39bfa9d3",
  "commit": "SystemUI: Re-evaluate system theme on UI mode change\n\n- Need for power menu to set accurate colors\n\nChange-Id: I05d41eaf8ea19ce3b6ce659d01da33cf55de3b7e",
  "files": [
   {
    "filename": "ThemeOverlayController.java",
    "diff": "@@ -66,6 +66,8 @@ import com.android.systemui.flags.FeatureFlags;\n import com.android.systemui.keyguard.WakefulnessLifecycle;\n import com.android.systemui.monet.ColorScheme;\n import com.android.systemui.settings.UserTracker;\n+import com.android.systemui.statusbar.policy.ConfigurationController;\n+import com.android.systemui.statusbar.policy.ConfigurationController.ConfigurationListener;\n import com.android.systemui.statusbar.policy.DeviceProvisionedController;\n import com.android.systemui.statusbar.policy.DeviceProvisionedController.DeviceProvisionedListener;\n import com.android.systemui.util.settings.SecureSettings;\n@@ -111,6 +113,7 @@ public class ThemeOverlayController extends SystemUI implements Dumpable {\n     private final Handler mBgHandler;\n     private final boolean mIsMonetEnabled;\n     private final UserTracker mUserTracker;\n+    private final ConfigurationController mConfigurationController;\n     private final DeviceProvisionedController mDeviceProvisionedController;\n     // Current wallpaper colors associated to a user.\n     private final SparseArray<WallpaperColors> mCurrentColors = new SparseArray<>();\n@@ -139,6 +142,15 @@ public class ThemeOverlayController extends SystemUI implements Dumpable {\n     // Determines if we should ignore THEME_CUSTOMIZATION_OVERLAY_PACKAGES setting changes.\n     private boolean mSkipSettingChange;\n \n+    private final ConfigurationListener mConfigurationListener =\n+            new ConfigurationListener() {\n+                @Override\n+                public void onUiModeChanged() {\n+                    Log.i(TAG, \"Re-applying theme on UI change\");\n+                    reevaluateSystemTheme(true /* forceReload */);\n+                }\n+            };\n+\n     private final DeviceProvisionedListener mDeviceProvisionedListener =\n             new DeviceProvisionedListener() {\n                 @Override\n@@ -342,10 +354,12 @@ public class ThemeOverlayController extends SystemUI implements Dumpable {\n             SecureSettings secureSettings, WallpaperManager wallpaperManager,\n             UserManager userManager, DeviceProvisionedController deviceProvisionedController,\n             UserTracker userTracker, DumpManager dumpManager, FeatureFlags featureFlags,\n-            WakefulnessLifecycle wakefulnessLifecycle) {\n+            WakefulnessLifecycle wakefulnessLifecycle, ConfigurationController\n+            configurationController) {\n         super(context);\n \n         mIsMonetEnabled = featureFlags.isMonetEnabled();\n+        mConfigurationController = configurationController;\n         mDeviceProvisionedController = deviceProvisionedController;\n         mBroadcastDispatcher = broadcastDispatcher;\n         mUserManager = userManager;\n@@ -400,6 +414,7 @@ public class ThemeOverlayController extends SystemUI implements Dumpable {\n \n         mUserTracker.addCallback(mUserTrackerCallback, mMainExecutor);\n \n+        mConfigurationController.addCallback(mConfigurationListener);\n         mDeviceProvisionedController.addCallback(mDeviceProvisionedListener);\n \n         // Upon boot, make sure we have the most up to date colors\n",
    "added_lines": 16,
    "deleted_lines": 1,
    "changed_methods": "ThemeOverlayController::ThemeOverlayController, ThemeOverlayController::ThemeOverlayController, ThemeOverlayController::start, ThemeOverlayController::ConfigurationListener"
   }
  ]
 },
 {
  "hash": "2efc6aaec9b71e0e0d1a050cedce746edc38a74e",
  "commit": "SystemUI: Make battery & clock clickable again in QuickStatusBarHeader\n\nChange-Id: I944b1122739754cc704f65039319fb260fcdbf1d",
  "files": [
   {
    "filename": "QuickStatusBarHeader.java",
    "diff": "@@ -18,10 +18,12 @@ import static android.app.StatusBarManager.DISABLE2_QUICK_SETTINGS;\n import static android.view.ViewGroup.LayoutParams.WRAP_CONTENT;\n \n import android.content.Context;\n+import android.content.Intent;\n import android.content.res.Configuration;\n import android.content.res.Resources;\n import android.graphics.Color;\n import android.graphics.Rect;\n+import android.provider.AlarmClock;\n import android.util.AttributeSet;\n import android.util.Pair;\n import android.view.DisplayCutout;\n@@ -39,6 +41,7 @@ import com.android.settingslib.Utils;\n import com.android.systemui.Dependency;\n import com.android.systemui.R;\n import com.android.systemui.battery.BatteryMeterView;\n+import com.android.systemui.plugins.ActivityStarter;\n import com.android.systemui.qs.QSDetail.Callback;\n import com.android.systemui.statusbar.phone.StatusBarContentInsetsProvider;\n import com.android.systemui.statusbar.phone.StatusBarIconController;\n@@ -64,6 +67,8 @@ public class QuickStatusBarHeader extends FrameLayout implements TunerService.Tu\n     private TouchAnimator mIconsAlphaAnimator;\n     private TouchAnimator mIconsAlphaAnimatorFixed;\n \n+    private final ActivityStarter mActivityStarter;\n+\n     protected QuickQSPanel mHeaderQsPanel;\n     private View mDatePrivacyView;\n     private View mDateView;\n@@ -110,6 +115,7 @@ public class QuickStatusBarHeader extends FrameLayout implements TunerService.Tu\n \n     public QuickStatusBarHeader(Context context, AttributeSet attrs) {\n         super(context, attrs);\n+        mActivityStarter = Dependency.get(ActivityStarter.class);\n     }\n \n     /**\n@@ -142,9 +148,15 @@ public class QuickStatusBarHeader extends FrameLayout implements TunerService.Tu\n \n         mClockContainer = findViewById(R.id.clock_container);\n         mClockView = findViewById(R.id.clock);\n+        mClockView.setOnClickListener(\n+                v -> mActivityStarter.postStartActivityDismissingKeyguard(\n+                        new Intent(AlarmClock.ACTION_SHOW_ALARMS), 0));\n         mDatePrivacySeparator = findViewById(R.id.space);\n         // Tint for the battery icons are handled in setupHost()\n         mBatteryRemainingIcon = findViewById(R.id.batteryRemainingIcon);\n+        mBatteryRemainingIcon.setOnClickListener(\n+                v -> mActivityStarter.postStartActivityDismissingKeyguard(\n+                        new Intent(Intent.ACTION_POWER_USAGE_SUMMARY), 0));\n \n         updateResources();\n         Configuration config = mContext.getResources().getConfiguration();\n",
    "added_lines": 12,
    "deleted_lines": 0,
    "changed_methods": "QuickStatusBarHeader::onFinishInflate, QuickStatusBarHeader::QuickStatusBarHeader"
   }
  ]
 },
 {
  "hash": "aa8742f84e8a269409d97b8385f0601d7df9e0b1",
  "commit": "SystemUI: Avoid NPE in volume dialog\n\nChange-Id: I1bc6d46de01ddd4db6b32555e5557611550d007e",
  "files": [
   {
    "filename": "VolumeDialogImpl.java",
    "diff": "@@ -1579,7 +1579,9 @@ public class VolumeDialogImpl implements VolumeDialog,\n                     mDialog.dismiss();\n                     tryToRemoveCaptionsTooltip();\n                     mExpanded = false;\n-                    mExpandRows.setExpanded(mExpanded);\n+                    if (mExpandRows != null) {\n+                        mExpandRows.setExpanded(mExpanded);\n+                    }\n                     mAnimatingRows = 0;\n                     mDefaultRow = null;\n                     mIsAnimatingDismiss = false;\n",
    "added_lines": 3,
    "deleted_lines": 1,
    "changed_methods": "VolumeDialogImpl::dismissH"
   }
  ]
 },
 {
  "hash": "83340a2f4915f90d76ec23d51bc1c7d8e8d26a3c",
  "commit": "SystemUI: Fix signal bar icon overlay issue\n\nIf the signal bar visible state is STATE_DOT, it should be shown\na dot instead of signal bar icons. But the signal bar icon will\nbe shown again if the mobile state changed, and then, the dot and\nsignal bar icon are both shown. So don't update signal bar\nvisibility if the state is not STATE_ICON\n\nBugs: 200915946\nTest: Manual\nChange-Id: I7fb04049790f112441511462d3f2963aed42c790",
  "files": [
   {
    "filename": "StatusBarMobileView.java",
    "diff": "@@ -186,7 +186,7 @@ public class StatusBarMobileView extends FrameLayout implements DarkReceiver,\n \n         setContentDescription(state.contentDescription);\n         int newVisibility = state.visible && !mForceHidden ? View.VISIBLE : View.GONE;\n-        if (newVisibility != mMobileGroup.getVisibility()) {\n+        if (newVisibility != mMobileGroup.getVisibility() && STATE_ICON == mVisibleState) {\n             mMobileGroup.setVisibility(newVisibility);\n             needsLayout = true;\n         }\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "StatusBarMobileView::updateState"
   }
  ]
 },
 {
  "hash": "faf136b1bdd0464352e654f58e751c0c19feaf96",
  "commit": "SystemUI: support black theme for dark mode [1/4]\n\nCo-authored-by: Jesse Chan <jc@lineageos.org>\nChange-Id: I57cd53de8f2c1e4d445441b514875b6af915b858",
  "files": [
   {
    "filename": "ThemeOverlayController.java",
    "diff": "@@ -71,6 +71,9 @@ import com.android.systemui.statusbar.policy.ConfigurationController.Configurati\n import com.android.systemui.statusbar.policy.DeviceProvisionedController;\n import com.android.systemui.statusbar.policy.DeviceProvisionedController.DeviceProvisionedListener;\n import com.android.systemui.util.settings.SecureSettings;\n+import com.android.systemui.util.settings.SystemSettings;\n+\n+import lineageos.providers.LineageSettings;\n \n import org.json.JSONException;\n import org.json.JSONObject;\n@@ -99,6 +102,8 @@ import javax.inject.Inject;\n @SysUISingleton\n public class ThemeOverlayController extends SystemUI implements Dumpable {\n     protected static final String TAG = \"ThemeOverlayController\";\n+    protected static final String OVERLAY_BERRY_BLACK_THEME =\n+            \"org.lineageos.overlay.customization.blacktheme\";\n     private static final boolean DEBUG = true;\n \n     protected static final int NEUTRAL = 0;\n@@ -109,6 +114,7 @@ public class ThemeOverlayController extends SystemUI implements Dumpable {\n     private final BroadcastDispatcher mBroadcastDispatcher;\n     private final Executor mBgExecutor;\n     private final SecureSettings mSecureSettings;\n+    private final SystemSettings mSystemSettings;\n     private final Executor mMainExecutor;\n     private final Handler mBgHandler;\n     private final boolean mIsMonetEnabled;\n@@ -245,6 +251,11 @@ public class ThemeOverlayController extends SystemUI implements Dumpable {\n         return false;\n     }\n \n+    private boolean isNightMode() {\n+        return (mContext.getResources().getConfiguration().uiMode\n+                & Configuration.UI_MODE_NIGHT_MASK) == Configuration.UI_MODE_NIGHT_YES;\n+    }\n+\n     private void handleWallpaperColors(WallpaperColors wallpaperColors, int flags, int userId) {\n         final int currentUser = mUserTracker.getUserId();\n         final boolean hadWallpaperColors = mCurrentColors.get(userId) != null;\n@@ -355,7 +366,7 @@ public class ThemeOverlayController extends SystemUI implements Dumpable {\n             UserManager userManager, DeviceProvisionedController deviceProvisionedController,\n             UserTracker userTracker, DumpManager dumpManager, FeatureFlags featureFlags,\n             WakefulnessLifecycle wakefulnessLifecycle, ConfigurationController\n-            configurationController) {\n+            configurationController, SystemSettings systemSettings) {\n         super(context);\n \n         mIsMonetEnabled = featureFlags.isMonetEnabled();\n@@ -368,6 +379,7 @@ public class ThemeOverlayController extends SystemUI implements Dumpable {\n         mBgHandler = bgHandler;\n         mThemeManager = themeOverlayApplier;\n         mSecureSettings = secureSettings;\n+        mSystemSettings = systemSettings;\n         mWallpaperManager = wallpaperManager;\n         mUserTracker = userTracker;\n         mWakefulnessLifecycle = wakefulnessLifecycle;\n@@ -408,6 +420,27 @@ public class ThemeOverlayController extends SystemUI implements Dumpable {\n                 },\n                 UserHandle.USER_ALL);\n \n+        mSystemSettings.registerContentObserverForUser(\n+                LineageSettings.System.getUriFor(LineageSettings.System.BERRY_BLACK_THEME),\n+                false,\n+                new ContentObserver(mBgHandler) {\n+                    @Override\n+                    public void onChange(boolean selfChange, Collection<Uri> collection, int flags,\n+                            int userId) {\n+                        if (DEBUG) Log.d(TAG, \"Overlay changed for user: \" + userId);\n+                        if (mUserTracker.getUserId() != userId) {\n+                            return;\n+                        }\n+                        if (!mDeviceProvisionedController.isUserSetup(userId)) {\n+                            Log.i(TAG, \"Theme application deferred when setting changed.\");\n+                            mDeferredThemeEvaluation = true;\n+                            return;\n+                        }\n+                        reevaluateSystemTheme(true /* forceReload */);\n+                    }\n+                },\n+                UserHandle.USER_ALL);\n+\n         if (!mIsMonetEnabled) {\n             return;\n         }\n@@ -507,10 +540,7 @@ public class ThemeOverlayController extends SystemUI implements Dumpable {\n      * Given a color candidate, return an overlay definition.\n      */\n     protected @Nullable FabricatedOverlay getOverlay(int color, int type) {\n-        boolean nightMode = (mContext.getResources().getConfiguration().uiMode\n-                & Configuration.UI_MODE_NIGHT_MASK) == Configuration.UI_MODE_NIGHT_YES;\n-\n-        mColorScheme = new ColorScheme(color, nightMode);\n+        mColorScheme = new ColorScheme(color, isNightMode());\n         List<Integer> colorShades = type == ACCENT\n                 ? mColorScheme.getAllAccentColors() : mColorScheme.getAllNeutralColors();\n         String name = type == ACCENT ? \"accent\" : \"neutral\";\n@@ -625,6 +655,14 @@ public class ThemeOverlayController extends SystemUI implements Dumpable {\n             categoryToPackage.put(OVERLAY_CATEGORY_ACCENT_COLOR, mSecondaryOverlay.getIdentifier());\n         }\n \n+        boolean isBlackMode = (LineageSettings.System.getIntForUser(\n+                mContext.getContentResolver(), LineageSettings.System.BERRY_BLACK_THEME,\n+                0, currentUser) == 1) && isNightMode();\n+        if (categoryToPackage.containsKey(OVERLAY_CATEGORY_SYSTEM_PALETTE) && isBlackMode) {\n+            OverlayIdentifier blackTheme = new OverlayIdentifier(OVERLAY_BERRY_BLACK_THEME);\n+            categoryToPackage.put(OVERLAY_CATEGORY_SYSTEM_PALETTE, blackTheme);\n+        }\n+\n         Set<UserHandle> managedProfiles = new HashSet<>();\n         for (UserInfo userInfo : mUserManager.getEnabledProfiles(currentUser)) {\n             if (userInfo.isManagedProfile()) {\n",
    "added_lines": 43,
    "deleted_lines": 5,
    "changed_methods": "ThemeOverlayController::start, ThemeOverlayController::getOverlay, ThemeOverlayController::isNightMode, ThemeOverlayController::ThemeOverlayController, ThemeOverlayController::ThemeOverlayController, ThemeOverlayController::updateThemeOverlays"
   }
  ]
 },
 {
  "hash": "100058582558ae6500303c8c4af54561da4e75c6",
  "commit": "Partially revert \"Assume sensors perform prox check\"\n\nThis commit partially reverts f40bd8fbb65c896c824fe3f1a5be857bbe8ae281\n(\"Assume sensors perform prox check\").\n\nSome devices do not have proximity gated sensors, and still require\ngating in software.\nPartially revert this commit to bring back the ability for sensors to\nbe proximity gated in software.\n\nChange-Id: Ic3d5c6e98d1767623ace4ee4eea1c52606fabd4a",
  "files": [
   {
    "filename": "DozeSensors.java",
    "diff": "@@ -492,6 +492,7 @@ public class DozeSensors {\n         private final boolean mSettingDefault;\n         private final boolean mRequiresTouchscreen;\n         private final boolean mRequiresProx;\n+        private final boolean mPerformsProxCheck;\n \n         protected boolean mRequested;\n         protected boolean mRegistered;\n@@ -506,6 +507,26 @@ public class DozeSensors {\n                 int pulseReason,\n                 boolean reportsTouchCoordinates,\n                 boolean requiresTouchscreen\n+        ) {\n+            this(\n+                sensor,\n+                setting,\n+                configured,\n+                pulseReason,\n+                reportsTouchCoordinates,\n+                requiresTouchscreen,\n+                true\n+            );\n+        }\n+\n+        TriggerSensor(\n+                Sensor sensor,\n+                String setting,\n+                boolean configured,\n+                int pulseReason,\n+                boolean reportsTouchCoordinates,\n+                boolean requiresTouchscreen,\n+                boolean performsProxCheck\n         ) {\n             this(\n                     sensor,\n@@ -516,7 +537,8 @@ public class DozeSensors {\n                     reportsTouchCoordinates,\n                     requiresTouchscreen,\n                     false /* ignoresSetting */,\n-                    false /* requiresProx */\n+                    false /* requiresProx */,\n+                    performsProxCheck\n             );\n         }\n \n@@ -530,6 +552,32 @@ public class DozeSensors {\n                 boolean requiresTouchscreen,\n                 boolean ignoresSetting,\n                 boolean requiresProx\n+        ) {\n+            this(\n+                    sensor,\n+                    setting,\n+                    settingDef,\n+                    configured,\n+                    pulseReason,\n+                    reportsTouchCoordinates,\n+                    requiresTouchscreen,\n+                    ignoresSetting,\n+                    requiresProx,\n+                    true\n+            );\n+        }\n+\n+        TriggerSensor(\n+                Sensor sensor,\n+                String setting,\n+                boolean settingDef,\n+                boolean configured,\n+                int pulseReason,\n+                boolean reportsTouchCoordinates,\n+                boolean requiresTouchscreen,\n+                boolean ignoresSetting,\n+                boolean requiresProx,\n+                boolean performsProxCheck\n         ) {\n             this(\n                     new Sensor[]{ sensor },\n@@ -541,6 +589,7 @@ public class DozeSensors {\n                     requiresTouchscreen,\n                     ignoresSetting,\n                     requiresProx,\n+                    performsProxCheck,\n                     DevicePostureController.DEVICE_POSTURE_UNKNOWN\n             );\n         }\n@@ -556,6 +605,34 @@ public class DozeSensors {\n                 boolean ignoresSetting,\n                 boolean requiresProx,\n                 @DevicePostureController.DevicePostureInt int posture\n+        ) {\n+            this(\n+                    sensors,\n+                    setting,\n+                    settingDef,\n+                    configured,\n+                    pulseReason,\n+                    reportsTouchCoordinates,\n+                    requiresTouchscreen,\n+                    ignoresSetting,\n+                    requiresProx,\n+                    true,\n+                    posture\n+            );\n+        }\n+\n+        TriggerSensor(\n+                @NonNull Sensor[] sensors,\n+                String setting,\n+                boolean settingDef,\n+                boolean configured,\n+                int pulseReason,\n+                boolean reportsTouchCoordinates,\n+                boolean requiresTouchscreen,\n+                boolean ignoresSetting,\n+                boolean requiresProx,\n+                boolean performsProxCheck,\n+                @DevicePostureController.DevicePostureInt int posture\n         ) {\n             mSensors = sensors;\n             mSetting = setting;\n@@ -566,6 +643,7 @@ public class DozeSensors {\n             mRequiresTouchscreen = requiresTouchscreen;\n             mIgnoresSetting = ignoresSetting;\n             mRequiresProx = requiresProx;\n+            mPerformsProxCheck = performsProxCheck;\n             mPosture = posture;\n         }\n \n@@ -701,13 +779,23 @@ public class DozeSensors {\n                     screenX = event.values[0];\n                     screenY = event.values[1];\n                 }\n-                mSensorCallback.onSensorPulse(mPulseReason, screenX, screenY, event.values);\n+                mSensorCallback.onSensorPulse(mPulseReason, mPerformsProxCheck,\n+                        screenX, screenY, event.values);\n                 if (!mRegistered) {\n                     updateListening();  // reregister, this sensor only fires once\n                 }\n             }));\n         }\n \n+        /**\n+         * If the sensor itself performs proximity checks, to avoid pocket dialing.\n+         * Gated sensors don't need to be stopped when the {@link DozeMachine} is\n+         * {@link DozeMachine.State#DOZE_AOD_PAUSED}.\n+         */\n+        public boolean performsProxCheck() {\n+            return mPerformsProxCheck;\n+        }\n+\n         public void registerSettingsObserver(ContentObserver settingsObserver) {\n             if (mConfigured && !TextUtils.isEmpty(mSetting)) {\n                 mSecureSettings.registerContentObserverForUser(\n@@ -802,7 +890,8 @@ public class DozeSensors {\n                     return;\n                 }\n                 if (DEBUG) Log.d(TAG, \"onSensorEvent: \" + triggerEventToString(event));\n-                mSensorCallback.onSensorPulse(mPulseReason, -1, -1, event.getValues());\n+                mSensorCallback.onSensorPulse(mPulseReason, true /* sensorPerformsProxCheck */,\n+                        -1, -1, event.getValues());\n             }));\n         }\n     }\n@@ -847,11 +936,13 @@ public class DozeSensors {\n         /**\n          * Called when a sensor requests a pulse\n          * @param pulseReason Requesting sensor, e.g. {@link DozeLog#REASON_SENSOR_PICKUP}\n+         * @param sensorPerformedProxCheck true if the sensor already checked for FAR proximity.\n          * @param screenX the location on the screen where the sensor fired or -1\n          *                if the sensor doesn't support reporting screen locations.\n          * @param screenY the location on the screen where the sensor fired or -1\n          * @param rawValues raw values array from the event.\n          */\n-        void onSensorPulse(int pulseReason, float screenX, float screenY, float[] rawValues);\n+        void onSensorPulse(int pulseReason, boolean sensorPerformedProxCheck,\n+                float screenX, float screenY, float[] rawValues);\n     }\n }\n",
    "added_lines": 95,
    "deleted_lines": 4,
    "changed_methods": "DozeSensors::TriggerSensor::onTrigger, DozeSensors::TriggerSensor::TriggerSensor, DozeSensors::TriggerSensor::TriggerSensor, DozeSensors::TriggerSensor::TriggerSensor, DozeSensors::TriggerSensor::performsProxCheck, DozeSensors::TriggerSensor::TriggerSensor, DozeSensors::PluginSensor::onSensorChanged, DozeSensors::TriggerSensor::TriggerSensor, DozeSensors::TriggerSensor::TriggerSensor"
   },
   {
    "filename": "DozeTriggers.java",
    "diff": "@@ -282,7 +282,8 @@ public class DozeTriggers implements DozeMachine.Part {\n     }\n \n     @VisibleForTesting\n-    void onSensor(int pulseReason, float screenX, float screenY, float[] rawValues) {\n+    void onSensor(int pulseReason, boolean sensorPerformedProxCheck,\n+            float screenX, float screenY, float[] rawValues) {\n         boolean isDoubleTap = pulseReason == DozeLog.REASON_SENSOR_DOUBLE_TAP;\n         boolean isTap = pulseReason == DozeLog.REASON_SENSOR_TAP;\n         boolean isPickup = pulseReason == DozeLog.REASON_SENSOR_PICKUP;\n@@ -299,11 +300,11 @@ public class DozeTriggers implements DozeMachine.Part {\n                     mMachine.isExecutingTransition() ? null : mMachine.getState(),\n                     pulseReason);\n         } else if (isLongPress) {\n-            requestPulse(pulseReason, true /* alreadyPerformedProxCheck */,\n+            requestPulse(pulseReason, sensorPerformedProxCheck /* alreadyPerformedProxCheck */,\n                     null /* onPulseSuppressedListener */);\n         } else if (isWakeOnReach || isQuickPickup) {\n             if (isWakeDisplayEvent) {\n-                requestPulse(pulseReason, true /* alreadyPerformedProxCheck */,\n+                requestPulse(pulseReason, sensorPerformedProxCheck /* alreadyPerformedProxCheck */,\n                         null /* onPulseSuppressedListener */);\n             }\n         } else {\n@@ -338,7 +339,7 @@ public class DozeTriggers implements DozeMachine.Part {\n                 } else {\n                     mDozeHost.extendPulse(pulseReason);\n                 }\n-            }, true /* alreadyPerformedProxCheck */, pulseReason);\n+            }, sensorPerformedProxCheck /* alreadyPerformedProxCheck */, pulseReason);\n         }\n \n         if (isPickup && !shouldDropPickupEvent()) {\n",
    "added_lines": 5,
    "deleted_lines": 4,
    "changed_methods": "DozeTriggers::onSensor, DozeTriggers::onSensor"
   }
  ]
 },
 {
  "hash": "100058582558ae6500303c8c4af54561da4e75c6",
  "commit": "Partially revert \"Assume sensors perform prox check\"\n\nThis commit partially reverts f40bd8fbb65c896c824fe3f1a5be857bbe8ae281\n(\"Assume sensors perform prox check\").\n\nSome devices do not have proximity gated sensors, and still require\ngating in software.\nPartially revert this commit to bring back the ability for sensors to\nbe proximity gated in software.\n\nChange-Id: Ic3d5c6e98d1767623ace4ee4eea1c52606fabd4a",
  "files": [
   {
    "filename": "DozeSensors.java",
    "diff": "@@ -492,6 +492,7 @@ public class DozeSensors {\n         private final boolean mSettingDefault;\n         private final boolean mRequiresTouchscreen;\n         private final boolean mRequiresProx;\n+        private final boolean mPerformsProxCheck;\n \n         protected boolean mRequested;\n         protected boolean mRegistered;\n@@ -506,6 +507,26 @@ public class DozeSensors {\n                 int pulseReason,\n                 boolean reportsTouchCoordinates,\n                 boolean requiresTouchscreen\n+        ) {\n+            this(\n+                sensor,\n+                setting,\n+                configured,\n+                pulseReason,\n+                reportsTouchCoordinates,\n+                requiresTouchscreen,\n+                true\n+            );\n+        }\n+\n+        TriggerSensor(\n+                Sensor sensor,\n+                String setting,\n+                boolean configured,\n+                int pulseReason,\n+                boolean reportsTouchCoordinates,\n+                boolean requiresTouchscreen,\n+                boolean performsProxCheck\n         ) {\n             this(\n                     sensor,\n@@ -516,7 +537,8 @@ public class DozeSensors {\n                     reportsTouchCoordinates,\n                     requiresTouchscreen,\n                     false /* ignoresSetting */,\n-                    false /* requiresProx */\n+                    false /* requiresProx */,\n+                    performsProxCheck\n             );\n         }\n \n@@ -530,6 +552,32 @@ public class DozeSensors {\n                 boolean requiresTouchscreen,\n                 boolean ignoresSetting,\n                 boolean requiresProx\n+        ) {\n+            this(\n+                    sensor,\n+                    setting,\n+                    settingDef,\n+                    configured,\n+                    pulseReason,\n+                    reportsTouchCoordinates,\n+                    requiresTouchscreen,\n+                    ignoresSetting,\n+                    requiresProx,\n+                    true\n+            );\n+        }\n+\n+        TriggerSensor(\n+                Sensor sensor,\n+                String setting,\n+                boolean settingDef,\n+                boolean configured,\n+                int pulseReason,\n+                boolean reportsTouchCoordinates,\n+                boolean requiresTouchscreen,\n+                boolean ignoresSetting,\n+                boolean requiresProx,\n+                boolean performsProxCheck\n         ) {\n             this(\n                     new Sensor[]{ sensor },\n@@ -541,6 +589,7 @@ public class DozeSensors {\n                     requiresTouchscreen,\n                     ignoresSetting,\n                     requiresProx,\n+                    performsProxCheck,\n                     DevicePostureController.DEVICE_POSTURE_UNKNOWN\n             );\n         }\n@@ -556,6 +605,34 @@ public class DozeSensors {\n                 boolean ignoresSetting,\n                 boolean requiresProx,\n                 @DevicePostureController.DevicePostureInt int posture\n+        ) {\n+            this(\n+                    sensors,\n+                    setting,\n+                    settingDef,\n+                    configured,\n+                    pulseReason,\n+                    reportsTouchCoordinates,\n+                    requiresTouchscreen,\n+                    ignoresSetting,\n+                    requiresProx,\n+                    true,\n+                    posture\n+            );\n+        }\n+\n+        TriggerSensor(\n+                @NonNull Sensor[] sensors,\n+                String setting,\n+                boolean settingDef,\n+                boolean configured,\n+                int pulseReason,\n+                boolean reportsTouchCoordinates,\n+                boolean requiresTouchscreen,\n+                boolean ignoresSetting,\n+                boolean requiresProx,\n+                boolean performsProxCheck,\n+                @DevicePostureController.DevicePostureInt int posture\n         ) {\n             mSensors = sensors;\n             mSetting = setting;\n@@ -566,6 +643,7 @@ public class DozeSensors {\n             mRequiresTouchscreen = requiresTouchscreen;\n             mIgnoresSetting = ignoresSetting;\n             mRequiresProx = requiresProx;\n+            mPerformsProxCheck = performsProxCheck;\n             mPosture = posture;\n         }\n \n@@ -701,13 +779,23 @@ public class DozeSensors {\n                     screenX = event.values[0];\n                     screenY = event.values[1];\n                 }\n-                mSensorCallback.onSensorPulse(mPulseReason, screenX, screenY, event.values);\n+                mSensorCallback.onSensorPulse(mPulseReason, mPerformsProxCheck,\n+                        screenX, screenY, event.values);\n                 if (!mRegistered) {\n                     updateListening();  // reregister, this sensor only fires once\n                 }\n             }));\n         }\n \n+        /**\n+         * If the sensor itself performs proximity checks, to avoid pocket dialing.\n+         * Gated sensors don't need to be stopped when the {@link DozeMachine} is\n+         * {@link DozeMachine.State#DOZE_AOD_PAUSED}.\n+         */\n+        public boolean performsProxCheck() {\n+            return mPerformsProxCheck;\n+        }\n+\n         public void registerSettingsObserver(ContentObserver settingsObserver) {\n             if (mConfigured && !TextUtils.isEmpty(mSetting)) {\n                 mSecureSettings.registerContentObserverForUser(\n@@ -802,7 +890,8 @@ public class DozeSensors {\n                     return;\n                 }\n                 if (DEBUG) Log.d(TAG, \"onSensorEvent: \" + triggerEventToString(event));\n-                mSensorCallback.onSensorPulse(mPulseReason, -1, -1, event.getValues());\n+                mSensorCallback.onSensorPulse(mPulseReason, true /* sensorPerformsProxCheck */,\n+                        -1, -1, event.getValues());\n             }));\n         }\n     }\n@@ -847,11 +936,13 @@ public class DozeSensors {\n         /**\n          * Called when a sensor requests a pulse\n          * @param pulseReason Requesting sensor, e.g. {@link DozeLog#REASON_SENSOR_PICKUP}\n+         * @param sensorPerformedProxCheck true if the sensor already checked for FAR proximity.\n          * @param screenX the location on the screen where the sensor fired or -1\n          *                if the sensor doesn't support reporting screen locations.\n          * @param screenY the location on the screen where the sensor fired or -1\n          * @param rawValues raw values array from the event.\n          */\n-        void onSensorPulse(int pulseReason, float screenX, float screenY, float[] rawValues);\n+        void onSensorPulse(int pulseReason, boolean sensorPerformedProxCheck,\n+                float screenX, float screenY, float[] rawValues);\n     }\n }\n",
    "added_lines": 95,
    "deleted_lines": 4,
    "changed_methods": "DozeSensors::TriggerSensor::onTrigger, DozeSensors::TriggerSensor::TriggerSensor, DozeSensors::TriggerSensor::TriggerSensor, DozeSensors::TriggerSensor::TriggerSensor, DozeSensors::TriggerSensor::performsProxCheck, DozeSensors::TriggerSensor::TriggerSensor, DozeSensors::PluginSensor::onSensorChanged, DozeSensors::TriggerSensor::TriggerSensor, DozeSensors::TriggerSensor::TriggerSensor"
   },
   {
    "filename": "DozeTriggers.java",
    "diff": "@@ -282,7 +282,8 @@ public class DozeTriggers implements DozeMachine.Part {\n     }\n \n     @VisibleForTesting\n-    void onSensor(int pulseReason, float screenX, float screenY, float[] rawValues) {\n+    void onSensor(int pulseReason, boolean sensorPerformedProxCheck,\n+            float screenX, float screenY, float[] rawValues) {\n         boolean isDoubleTap = pulseReason == DozeLog.REASON_SENSOR_DOUBLE_TAP;\n         boolean isTap = pulseReason == DozeLog.REASON_SENSOR_TAP;\n         boolean isPickup = pulseReason == DozeLog.REASON_SENSOR_PICKUP;\n@@ -299,11 +300,11 @@ public class DozeTriggers implements DozeMachine.Part {\n                     mMachine.isExecutingTransition() ? null : mMachine.getState(),\n                     pulseReason);\n         } else if (isLongPress) {\n-            requestPulse(pulseReason, true /* alreadyPerformedProxCheck */,\n+            requestPulse(pulseReason, sensorPerformedProxCheck /* alreadyPerformedProxCheck */,\n                     null /* onPulseSuppressedListener */);\n         } else if (isWakeOnReach || isQuickPickup) {\n             if (isWakeDisplayEvent) {\n-                requestPulse(pulseReason, true /* alreadyPerformedProxCheck */,\n+                requestPulse(pulseReason, sensorPerformedProxCheck /* alreadyPerformedProxCheck */,\n                         null /* onPulseSuppressedListener */);\n             }\n         } else {\n@@ -338,7 +339,7 @@ public class DozeTriggers implements DozeMachine.Part {\n                 } else {\n                     mDozeHost.extendPulse(pulseReason);\n                 }\n-            }, true /* alreadyPerformedProxCheck */, pulseReason);\n+            }, sensorPerformedProxCheck /* alreadyPerformedProxCheck */, pulseReason);\n         }\n \n         if (isPickup && !shouldDropPickupEvent()) {\n",
    "added_lines": 5,
    "deleted_lines": 4,
    "changed_methods": "DozeTriggers::onSensor, DozeTriggers::onSensor"
   }
  ]
 },
 {
  "hash": "a4b357c9dd7c372c08cbe782ea6e1b09380f88a1",
  "commit": "SystemUI: doze: add config for double tap sensors that need a proximity check\n\nChange-Id: Id7df987f0e9db4e5e2328534764ded397b6ac48d",
  "files": [
   {
    "filename": "DozeSensors.java",
    "diff": "@@ -200,7 +200,8 @@ public class DozeSensors {\n                         true /* configured */,\n                         DozeLog.REASON_SENSOR_DOUBLE_TAP,\n                         dozeParameters.doubleTapReportsTouchCoordinates(),\n-                        true /* touchscreen */),\n+                        true /* touchscreen */,\n+                        !dozeParameters.doubleTapNeedsProximityCheck() /* performsProxCheck */),\n                 new TriggerSensor(\n                         findSensors(config.tapSensorTypeMapping()),\n                         Settings.Secure.DOZE_TAP_SCREEN_GESTURE,\n",
    "added_lines": 2,
    "deleted_lines": 1,
    "changed_methods": "DozeSensors::DozeSensors"
   },
   {
    "filename": "DozeParameters.java",
    "diff": "@@ -298,6 +298,10 @@ public class DozeParameters implements\n         return 2 * getPulseVisibleDuration();\n     }\n \n+    public boolean doubleTapNeedsProximityCheck() {\n+        return mResources.getBoolean(R.bool.doze_double_tap_proximity_check);\n+    }\n+\n     public boolean doubleTapReportsTouchCoordinates() {\n         return mResources.getBoolean(R.bool.doze_double_tap_reports_touch_coordinates);\n     }\n",
    "added_lines": 4,
    "deleted_lines": 0,
    "changed_methods": "DozeParameters::doubleTapNeedsProximityCheck"
   }
  ]
 },
 {
  "hash": "a4b357c9dd7c372c08cbe782ea6e1b09380f88a1",
  "commit": "SystemUI: doze: add config for double tap sensors that need a proximity check\n\nChange-Id: Id7df987f0e9db4e5e2328534764ded397b6ac48d",
  "files": [
   {
    "filename": "DozeSensors.java",
    "diff": "@@ -200,7 +200,8 @@ public class DozeSensors {\n                         true /* configured */,\n                         DozeLog.REASON_SENSOR_DOUBLE_TAP,\n                         dozeParameters.doubleTapReportsTouchCoordinates(),\n-                        true /* touchscreen */),\n+                        true /* touchscreen */,\n+                        !dozeParameters.doubleTapNeedsProximityCheck() /* performsProxCheck */),\n                 new TriggerSensor(\n                         findSensors(config.tapSensorTypeMapping()),\n                         Settings.Secure.DOZE_TAP_SCREEN_GESTURE,\n",
    "added_lines": 2,
    "deleted_lines": 1,
    "changed_methods": "DozeSensors::DozeSensors"
   },
   {
    "filename": "DozeParameters.java",
    "diff": "@@ -298,6 +298,10 @@ public class DozeParameters implements\n         return 2 * getPulseVisibleDuration();\n     }\n \n+    public boolean doubleTapNeedsProximityCheck() {\n+        return mResources.getBoolean(R.bool.doze_double_tap_proximity_check);\n+    }\n+\n     public boolean doubleTapReportsTouchCoordinates() {\n         return mResources.getBoolean(R.bool.doze_double_tap_reports_touch_coordinates);\n     }\n",
    "added_lines": 4,
    "deleted_lines": 0,
    "changed_methods": "DozeParameters::doubleTapNeedsProximityCheck"
   }
  ]
 },
 {
  "hash": "3dd1c0ac07e72905c64cb43366edd571b2bdae9d",
  "commit": "SystemUI: doze: add config for long press sensors that need a proximity check\n\nChange-Id: I34d5a8313304e3ac8bd53282de66ab1d3d1653a8",
  "files": [
   {
    "filename": "DozeSensors.java",
    "diff": "@@ -222,7 +222,8 @@ public class DozeSensors {\n                         true /* reports touch coordinates */,\n                         true /* touchscreen */,\n                         false /* ignoresSetting */,\n-                        dozeParameters.longPressUsesProx() /* requiresProx */),\n+                        dozeParameters.longPressUsesProx() /* requiresProx */,\n+                        !dozeParameters.longPressNeedsProximityCheck() /* performsProxCheck */),\n                 new TriggerSensor(\n                         findSensor(config.udfpsLongPressSensorType()),\n                         \"doze_pulse_on_auth\",\n@@ -232,7 +233,8 @@ public class DozeSensors {\n                         true /* reports touch coordinates */,\n                         true /* touchscreen */,\n                         false /* ignoresSetting */,\n-                        dozeParameters.longPressUsesProx()),\n+                        dozeParameters.longPressUsesProx(),\n+                        !dozeParameters.longPressNeedsProximityCheck() /* performsProxCheck */),\n                 new PluginSensor(\n                         new SensorManagerPlugin.Sensor(TYPE_WAKE_DISPLAY),\n                         Settings.Secure.DOZE_WAKE_DISPLAY_GESTURE,\n",
    "added_lines": 4,
    "deleted_lines": 2,
    "changed_methods": "DozeSensors::DozeSensors"
   },
   {
    "filename": "DozeParameters.java",
    "diff": "@@ -324,6 +324,10 @@ public class DozeParameters implements\n         return mResources.getBoolean(R.bool.doze_single_tap_uses_prox);\n     }\n \n+    public boolean longPressNeedsProximityCheck() {\n+        return mResources.getBoolean(R.bool.doze_long_press_proximity_check);\n+    }\n+\n     /**\n      * Whether the long press sensor uses the proximity sensor.\n      */\n",
    "added_lines": 4,
    "deleted_lines": 0,
    "changed_methods": "DozeParameters::longPressNeedsProximityCheck"
   }
  ]
 },
 {
  "hash": "3dd1c0ac07e72905c64cb43366edd571b2bdae9d",
  "commit": "SystemUI: doze: add config for long press sensors that need a proximity check\n\nChange-Id: I34d5a8313304e3ac8bd53282de66ab1d3d1653a8",
  "files": [
   {
    "filename": "DozeSensors.java",
    "diff": "@@ -222,7 +222,8 @@ public class DozeSensors {\n                         true /* reports touch coordinates */,\n                         true /* touchscreen */,\n                         false /* ignoresSetting */,\n-                        dozeParameters.longPressUsesProx() /* requiresProx */),\n+                        dozeParameters.longPressUsesProx() /* requiresProx */,\n+                        !dozeParameters.longPressNeedsProximityCheck() /* performsProxCheck */),\n                 new TriggerSensor(\n                         findSensor(config.udfpsLongPressSensorType()),\n                         \"doze_pulse_on_auth\",\n@@ -232,7 +233,8 @@ public class DozeSensors {\n                         true /* reports touch coordinates */,\n                         true /* touchscreen */,\n                         false /* ignoresSetting */,\n-                        dozeParameters.longPressUsesProx()),\n+                        dozeParameters.longPressUsesProx(),\n+                        !dozeParameters.longPressNeedsProximityCheck() /* performsProxCheck */),\n                 new PluginSensor(\n                         new SensorManagerPlugin.Sensor(TYPE_WAKE_DISPLAY),\n                         Settings.Secure.DOZE_WAKE_DISPLAY_GESTURE,\n",
    "added_lines": 4,
    "deleted_lines": 2,
    "changed_methods": "DozeSensors::DozeSensors"
   },
   {
    "filename": "DozeParameters.java",
    "diff": "@@ -324,6 +324,10 @@ public class DozeParameters implements\n         return mResources.getBoolean(R.bool.doze_single_tap_uses_prox);\n     }\n \n+    public boolean longPressNeedsProximityCheck() {\n+        return mResources.getBoolean(R.bool.doze_long_press_proximity_check);\n+    }\n+\n     /**\n      * Whether the long press sensor uses the proximity sensor.\n      */\n",
    "added_lines": 4,
    "deleted_lines": 0,
    "changed_methods": "DozeParameters::longPressNeedsProximityCheck"
   }
  ]
 },
 {
  "hash": "d7f1a80214c2f4fa03f55ffd99e494e31f20c53b",
  "commit": "fixup! Add nvidia profile manager\n\nFixes:\nexternal/robolectric-shadows/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPackageParser.java:69: error: org.robolectric.shadows.ShadowPackageParser.Callback is not abstract and does not override abstract method getAppProfileService() in android.content.pm.PackageParser.Callback\n  private static class Callback implements PackageParser.Callback {\n                 ^\n1 error\n\nChange-Id: I4a2103361a80a920962d985d6358d9f8574f9454",
  "files": [
   {
    "filename": "PackageParser.java",
    "diff": "@@ -603,7 +603,9 @@ public class PackageParser {\n      * a package.\n      */\n     public interface Callback {\n-        NvAppProfileService getAppProfileService();\n+        default NvAppProfileService getAppProfileService() {\n+            return null;\n+        }\n         boolean hasFeature(String feature);\n     }\n \n",
    "added_lines": 3,
    "deleted_lines": 1,
    "changed_methods": "PackageParser::getAppProfileService"
   }
  ]
 },
 {
  "hash": "f606ff9c46f6e54b287c692e6b2eee9f7e8fc02c",
  "commit": "fixup! DeviceGroup: Framework changes for Group Device operations.\n\nfixup for change-Id: I0a8186e800e9d2701319db1adc97bdcf0441cc12\n\nSigned-off-by: Pranav Vashi <neobuddy89@gmail.com>\nChange-Id: Id67a9bc3e4a0e411b7377f111324465ca447b2a3",
  "files": [
   {
    "filename": "BluetoothAdapter.java",
    "diff": "@@ -3278,6 +3278,7 @@ public final class BluetoothAdapter {\n             case BluetoothProfile.LE_AUDIO:\n                 BluetoothLeAudio leAudio = (BluetoothLeAudio) proxy;\n                 leAudio.close();\n+                break;\n             case BluetoothProfile.GROUP_CLIENT:\n                 BluetoothDeviceGroup groupClient = (BluetoothDeviceGroup) proxy;\n                 groupClient.close();\n",
    "added_lines": 1,
    "deleted_lines": 0,
    "changed_methods": "BluetoothAdapter::closeProfileProxy"
   }
  ]
 },
 {
  "hash": "ad25de41b4b152426c9b72315f349b9e91ef773d",
  "commit": "base: ChooserActivity: Don't show image edit button on multiple targets\n\nIe52aaab90f678d32d9b67f95d81f86b82d1b9c7c introduced edit button but didn't\ntook into account that there can be multiple images being shared. This patch\nadds a check to ensure that this action is not shown in such cases.\n\nSigned-off-by: Aayush Gupta <aayushgupta219@gmail.com>\nChange-Id: I787cd9cfd873242542b330a522bed5df9deb62a4",
  "files": [
   {
    "filename": "ChooserActivity.java",
    "diff": "@@ -1394,13 +1394,16 @@ public class ChooserActivity extends ResolverActivity implements\n \n         final ViewGroup actionRow =\n                 (ViewGroup) contentPreviewLayout.findViewById(R.id.chooser_action_row);\n+        String action = targetIntent.getAction();\n+\n         //TODO: addActionButton(actionRow, createCopyButton());\n         addActionButton(actionRow, createNearbyButton(targetIntent));\n-        addActionButton(actionRow, createEditButton(targetIntent));\n+        if (!Intent.ACTION_SEND_MULTIPLE.equals(action)) {\n+            addActionButton(actionRow, createEditButton(targetIntent));\n+        }\n \n         mPreviewCoord = new ContentPreviewCoordinator(contentPreviewLayout, false);\n \n-        String action = targetIntent.getAction();\n         if (Intent.ACTION_SEND.equals(action)) {\n             Uri uri = targetIntent.getParcelableExtra(Intent.EXTRA_STREAM);\n             imagePreview.findViewById(R.id.content_preview_image_1_large)\n",
    "added_lines": 5,
    "deleted_lines": 2,
    "changed_methods": "ChooserActivity::displayImageContentPreview"
   }
  ]
 },
 {
  "hash": "01364b249e36ceba72fba3acc14197062a1fbbd6",
  "commit": "SystemUI: Fix QS mobile icon disappearing on theme switch\n\nWhen there is only single SIM, the signal icon disappears\nfrom expanded QS header on switching dark theme QS tile.\nEnsure that the signal icon is always shown on single SIM.\n\nChange-Id: I089731fe5815a0b2bcbbed1002ca65aa5d3301cd\nSigned-off-by: Adithya R <gh0strider.2k18.reborn@gmail.com>",
  "files": [
   {
    "filename": "QuickStatusBarHeader.java",
    "diff": "@@ -198,6 +198,9 @@ public class QuickStatusBarHeader extends FrameLayout implements TunerService.Tu\n \n     void setIsSingleCarrier(boolean isSingleCarrier) {\n         mIsSingleCarrier = isSingleCarrier;\n+        if (mIsSingleCarrier) {\n+            mIconContainer.removeIgnoredSlots(mRssiIgnoredSlots);\n+        }\n         updateAlphaAnimator();\n     }\n \n",
    "added_lines": 3,
    "deleted_lines": 0,
    "changed_methods": "QuickStatusBarHeader::setIsSingleCarrier"
   }
  ]
 },
 {
  "hash": "14cec8935c61ea3ce0db7a31bf8d00690ce8753a",
  "commit": "SystemUI: Redo circle battery style\n\n- Now shows up on QuickSettings panel.\n- Fixes issues with battery circle style on theme and\n  ui mode change and statusbar icon toggle.\n- Fixes wrong tint color with circle battery icon.\n- Re-evaluating system theme to avoid delay in circle\n  battery tint color change.\n\nChange-Id: Id90f85e47ce4b9811e9bb67b91169997020300d8",
  "files": [
   {
    "filename": "BatteryMeterView.java",
    "diff": "@@ -63,9 +63,6 @@ import java.text.NumberFormat;\n \n public class BatteryMeterView extends LinearLayout implements DarkReceiver {\n \n-    protected static final String STATUS_BAR_BATTERY_STYLE =\n-            \"lineagesystem:\" + LineageSettings.System.STATUS_BAR_BATTERY_STYLE;\n-\n     protected static final int BATTERY_STYLE_PORTRAIT = 0;\n     protected static final int BATTERY_STYLE_CIRCLE = 1;\n     protected static final int BATTERY_STYLE_TEXT = 2;\n@@ -93,8 +90,6 @@ public class BatteryMeterView extends LinearLayout implements DarkReceiver {\n     // Lazily-loaded since this is expected to be a rare-if-ever state\n     private Drawable mUnknownStateDrawable;\n \n-    private int mBatteryStyle = BATTERY_STYLE_PORTRAIT;\n-\n     private DualToneHandler mDualToneHandler;\n \n     private int mNonAdaptedSingleToneColor;\n@@ -125,9 +120,11 @@ public class BatteryMeterView extends LinearLayout implements DarkReceiver {\n         setupLayoutTransition();\n \n         mBatteryIconView = new ImageView(context);\n-        mBatteryIconView.setImageDrawable(mThemedDrawable);\n+        updateDrawable();\n         final MarginLayoutParams mlp = new MarginLayoutParams(\n-                getResources().getDimensionPixelSize(R.dimen.status_bar_battery_icon_width),\n+                getBatteryStyle() == BATTERY_STYLE_PORTRAIT ? getResources().getDimensionPixelSize(\n+                R.dimen.status_bar_battery_icon_width) : getResources().getDimensionPixelSize(\n+                R.dimen.status_bar_battery_icon_circle_width),\n                 getResources().getDimensionPixelSize(R.dimen.status_bar_battery_icon_height));\n         mlp.setMargins(0, 0, 0,\n                 getResources().getDimensionPixelOffset(R.dimen.battery_margin_bottom));\n@@ -157,11 +154,10 @@ public class BatteryMeterView extends LinearLayout implements DarkReceiver {\n         setLayoutTransition(transition);\n     }\n \n-    protected void setBatteryStyle(int batteryStyle) {\n-        if (batteryStyle == mBatteryStyle) return;\n-        mBatteryStyle = batteryStyle;\n-        updateBatteryStyle();\n-        updateShowPercent();\n+    protected void updateBatteryStyle() {\n+        updateDrawable();\n+        scaleBatteryMeterViews();\n+        updatePercentView();\n     }\n \n     public void setForceShowPercent(boolean show) {\n@@ -186,7 +182,7 @@ public class BatteryMeterView extends LinearLayout implements DarkReceiver {\n     @Override\n     protected void onConfigurationChanged(Configuration newConfig) {\n         super.onConfigurationChanged(newConfig);\n-        updatePercentView();\n+        updateBatteryStyle();\n     }\n \n     public void setColorsFromContext(Context context) {\n@@ -303,7 +299,7 @@ public class BatteryMeterView extends LinearLayout implements DarkReceiver {\n                 showBatteryPercent == 2;\n         boolean shouldShow =\n                 (drawPercentOnly && (!drawPercentInside || mCharging) ||\n-                mBatteryStyle == BATTERY_STYLE_TEXT);\n+                getBatteryStyle() == BATTERY_STYLE_TEXT);\n         shouldShow = shouldShow && !mBatteryStateUnknown;\n \n         if (shouldShow) {\n@@ -321,7 +317,7 @@ public class BatteryMeterView extends LinearLayout implements DarkReceiver {\n                                 LayoutParams.WRAP_CONTENT,\n                                 LayoutParams.MATCH_PARENT));\n             }\n-            if (mBatteryStyle == BATTERY_STYLE_TEXT) {\n+            if (getBatteryStyle() == BATTERY_STYLE_TEXT) {\n                 mBatteryPercentView.setPaddingRelative(0, 0, 0, 0);\n             } else {\n                 Resources res = getContext().getResources();\n@@ -358,7 +354,7 @@ public class BatteryMeterView extends LinearLayout implements DarkReceiver {\n         if (mBatteryStateUnknown) {\n             mBatteryIconView.setImageDrawable(getUnknownStateDrawable());\n         } else {\n-            updateBatteryStyle();\n+            updateDrawable();\n         }\n \n         updateShowPercent();\n@@ -375,7 +371,7 @@ public class BatteryMeterView extends LinearLayout implements DarkReceiver {\n         float iconScaleFactor = typedValue.getFloat();\n \n         int batteryHeight = res.getDimensionPixelSize(R.dimen.status_bar_battery_icon_height);\n-        int batteryWidth = mBatteryStyle == BATTERY_STYLE_CIRCLE ?\n+        int batteryWidth = getBatteryStyle() == BATTERY_STYLE_CIRCLE ?\n                 res.getDimensionPixelSize(R.dimen.status_bar_battery_icon_circle_width) :\n                 res.getDimensionPixelSize(R.dimen.status_bar_battery_icon_width);\n         int marginBottom = res.getDimensionPixelSize(R.dimen.battery_margin_bottom);\n@@ -387,17 +383,15 @@ public class BatteryMeterView extends LinearLayout implements DarkReceiver {\n         mBatteryIconView.setLayoutParams(scaledLayoutParams);\n     }\n \n-    private void updateBatteryStyle() {\n-        switch (mBatteryStyle) {\n+    private void updateDrawable() {\n+        switch (getBatteryStyle()) {\n             case BATTERY_STYLE_PORTRAIT:\n                 mBatteryIconView.setImageDrawable(mThemedDrawable);\n                 mBatteryIconView.setVisibility(View.VISIBLE);\n-                scaleBatteryMeterViews();\n                 break;\n             case BATTERY_STYLE_CIRCLE:\n                 mBatteryIconView.setImageDrawable(mCircleDrawable);\n                 mBatteryIconView.setVisibility(View.VISIBLE);\n-                scaleBatteryMeterViews();\n                 break;\n             case BATTERY_STYLE_TEXT:\n                 mBatteryIconView.setVisibility(View.GONE);\n@@ -406,6 +400,12 @@ public class BatteryMeterView extends LinearLayout implements DarkReceiver {\n         }\n     }\n \n+    private int getBatteryStyle() {\n+        return LineageSettings.System.getIntForUser(getContext().getContentResolver(),\n+                LineageSettings.System.STATUS_BAR_BATTERY_STYLE, BATTERY_STYLE_PORTRAIT,\n+                UserHandle.USER_CURRENT);\n+    }\n+\n     @Override\n     public void onDarkChanged(Rect area, float darkIntensity, int tint) {\n         float intensity = DarkIconDispatcher.isInArea(area, this) ? darkIntensity : 0;\n",
    "added_lines": 21,
    "deleted_lines": 21,
    "changed_methods": "BatteryMeterView::getBatteryStyle, BatteryMeterView::updateShowPercent, BatteryMeterView::BatteryMeterView, BatteryMeterView::onBatteryUnknownStateChanged, BatteryMeterView::onConfigurationChanged, BatteryMeterView::scaleBatteryMeterViews, BatteryMeterView::setBatteryStyle, BatteryMeterView::updateDrawable, BatteryMeterView::updateBatteryStyle"
   },
   {
    "filename": "BatteryMeterViewController.java",
    "diff": "@@ -15,6 +15,7 @@\n  */\n package com.android.systemui.battery;\n \n+import static lineageos.providers.LineageSettings.System.STATUS_BAR_BATTERY_STYLE;\n import static lineageos.providers.LineageSettings.System.STATUS_BAR_SHOW_BATTERY_PERCENT;\n \n import android.app.ActivityManager;\n@@ -67,10 +68,8 @@ public class BatteryMeterViewController extends ViewController<BatteryMeterView>\n                         getContext(), newValue);\n                 mBatteryHidden = icons.contains(mSlotBattery);\n                 mView.setVisibility(mBatteryHidden ? View.GONE : View.VISIBLE);\n-            } else if (BatteryMeterView.STATUS_BAR_BATTERY_STYLE.equals(key)) {\n                 if (!mBatteryHidden) {\n-                    mView.setBatteryStyle(TunerService.parseInteger(newValue,\n-                            BatteryMeterView.BATTERY_STYLE_PORTRAIT));\n+                    mView.updateBatteryStyle();\n                 }\n             }\n         }\n@@ -166,8 +165,7 @@ public class BatteryMeterViewController extends ViewController<BatteryMeterView>\n             return;\n         }\n \n-        mTunerService.addTunable(mTunable, StatusBarIconController.ICON_HIDE_LIST,\n-                BatteryMeterView.STATUS_BAR_BATTERY_STYLE);\n+        mTunerService.addTunable(mTunable, StatusBarIconController.ICON_HIDE_LIST);\n         mIsSubscribedForTunerUpdates = true;\n     }\n \n@@ -186,6 +184,11 @@ public class BatteryMeterViewController extends ViewController<BatteryMeterView>\n                 false,\n                 mSettingObserver,\n                 user);\n+        mContentResolver.registerContentObserver(\n+                LineageSettings.System.getUriFor(STATUS_BAR_BATTERY_STYLE),\n+                false,\n+                mSettingObserver,\n+                user);\n     }\n \n     private void registerGlobalBatteryUpdateObserver() {\n@@ -209,6 +212,9 @@ public class BatteryMeterViewController extends ViewController<BatteryMeterView>\n                 // update the text for sure if the estimate in the cache was updated\n                 mView.updatePercentText();\n             }\n+            if (TextUtils.equals(uri.getLastPathSegment(), STATUS_BAR_BATTERY_STYLE)) {\n+                mView.updateBatteryStyle();\n+            }\n         }\n     }\n }\n",
    "added_lines": 11,
    "deleted_lines": 5,
    "changed_methods": "BatteryMeterViewController::subscribeForTunerUpdates, BatteryMeterViewController::SettingObserver::onChange, BatteryMeterViewController::Tunable, BatteryMeterViewController::registerShowBatteryPercentObserver"
   },
   {
    "filename": "QuickStatusBarHeader.java",
    "diff": "@@ -23,6 +23,7 @@ import android.content.res.Configuration;\n import android.content.res.Resources;\n import android.graphics.Color;\n import android.graphics.Rect;\n+import android.os.UserHandle;\n import android.provider.AlarmClock;\n import android.util.AttributeSet;\n import android.util.Pair;\n@@ -51,6 +52,8 @@ import com.android.systemui.statusbar.policy.Clock;\n import com.android.systemui.statusbar.policy.VariableDateView;\n import com.android.systemui.tuner.TunerService;\n \n+import lineageos.providers.LineageSettings;\n+\n import java.util.List;\n \n /**\n@@ -291,7 +294,11 @@ public class QuickStatusBarHeader extends FrameLayout implements TunerService.Tu\n \n         int textColor = Utils.getColorAttrDefaultColor(mContext, android.R.attr.textColorPrimary);\n         if (textColor != mTextColorPrimary) {\n+            boolean isCircleBattery = LineageSettings.System.getIntForUser(\n+                    mContext.getContentResolver(), LineageSettings.System.STATUS_BAR_BATTERY_STYLE,\n+                    0, UserHandle.USER_CURRENT) == 1;\n             int textColorSecondary = Utils.getColorAttrDefaultColor(mContext,\n+                    isCircleBattery ? android.R.attr.textColorHint :\n                     android.R.attr.textColorSecondary);\n             mTextColorPrimary = textColor;\n             mClockView.setTextColor(textColor);\n",
    "added_lines": 7,
    "deleted_lines": 0,
    "changed_methods": "QuickStatusBarHeader::updateResources"
   },
   {
    "filename": "ThemeOverlayController.java",
    "diff": "@@ -441,6 +441,33 @@ public class ThemeOverlayController extends SystemUI implements Dumpable {\n                 },\n                 UserHandle.USER_ALL);\n \n+        mSystemSettings.registerContentObserverForUser(\n+                LineageSettings.System.getUriFor(LineageSettings.System.STATUS_BAR_BATTERY_STYLE),\n+                false,\n+                new ContentObserver(mBgHandler) {\n+                    @Override\n+                    public void onChange(boolean selfChange, Collection<Uri> collection, int flags,\n+                            int userId) {\n+                        if (DEBUG) Log.d(TAG, \"Overlay changed for user: \" + userId);\n+                        if (mUserTracker.getUserId() != userId) {\n+                            return;\n+                        }\n+                        if (!mDeviceProvisionedController.isUserSetup(userId)) {\n+                            Log.i(TAG, \"Theme application deferred when setting changed.\");\n+                            mDeferredThemeEvaluation = true;\n+                            return;\n+                        }\n+                        boolean isCircleBattery = LineageSettings.System.getIntForUser(\n+                                mContext.getContentResolver(),\n+                                LineageSettings.System.STATUS_BAR_BATTERY_STYLE,\n+                                0, UserHandle.USER_CURRENT) == 1;\n+                        if (isCircleBattery) {\n+                            reevaluateSystemTheme(true /* forceReload */);\n+                        }\n+                    }\n+                },\n+                UserHandle.USER_ALL);\n+\n         if (!mIsMonetEnabled) {\n             return;\n         }\n",
    "added_lines": 27,
    "deleted_lines": 0,
    "changed_methods": "ThemeOverlayController::start"
   }
  ]
 },
 {
  "hash": "14cec8935c61ea3ce0db7a31bf8d00690ce8753a",
  "commit": "SystemUI: Redo circle battery style\n\n- Now shows up on QuickSettings panel.\n- Fixes issues with battery circle style on theme and\n  ui mode change and statusbar icon toggle.\n- Fixes wrong tint color with circle battery icon.\n- Re-evaluating system theme to avoid delay in circle\n  battery tint color change.\n\nChange-Id: Id90f85e47ce4b9811e9bb67b91169997020300d8",
  "files": [
   {
    "filename": "BatteryMeterView.java",
    "diff": "@@ -63,9 +63,6 @@ import java.text.NumberFormat;\n \n public class BatteryMeterView extends LinearLayout implements DarkReceiver {\n \n-    protected static final String STATUS_BAR_BATTERY_STYLE =\n-            \"lineagesystem:\" + LineageSettings.System.STATUS_BAR_BATTERY_STYLE;\n-\n     protected static final int BATTERY_STYLE_PORTRAIT = 0;\n     protected static final int BATTERY_STYLE_CIRCLE = 1;\n     protected static final int BATTERY_STYLE_TEXT = 2;\n@@ -93,8 +90,6 @@ public class BatteryMeterView extends LinearLayout implements DarkReceiver {\n     // Lazily-loaded since this is expected to be a rare-if-ever state\n     private Drawable mUnknownStateDrawable;\n \n-    private int mBatteryStyle = BATTERY_STYLE_PORTRAIT;\n-\n     private DualToneHandler mDualToneHandler;\n \n     private int mNonAdaptedSingleToneColor;\n@@ -125,9 +120,11 @@ public class BatteryMeterView extends LinearLayout implements DarkReceiver {\n         setupLayoutTransition();\n \n         mBatteryIconView = new ImageView(context);\n-        mBatteryIconView.setImageDrawable(mThemedDrawable);\n+        updateDrawable();\n         final MarginLayoutParams mlp = new MarginLayoutParams(\n-                getResources().getDimensionPixelSize(R.dimen.status_bar_battery_icon_width),\n+                getBatteryStyle() == BATTERY_STYLE_PORTRAIT ? getResources().getDimensionPixelSize(\n+                R.dimen.status_bar_battery_icon_width) : getResources().getDimensionPixelSize(\n+                R.dimen.status_bar_battery_icon_circle_width),\n                 getResources().getDimensionPixelSize(R.dimen.status_bar_battery_icon_height));\n         mlp.setMargins(0, 0, 0,\n                 getResources().getDimensionPixelOffset(R.dimen.battery_margin_bottom));\n@@ -157,11 +154,10 @@ public class BatteryMeterView extends LinearLayout implements DarkReceiver {\n         setLayoutTransition(transition);\n     }\n \n-    protected void setBatteryStyle(int batteryStyle) {\n-        if (batteryStyle == mBatteryStyle) return;\n-        mBatteryStyle = batteryStyle;\n-        updateBatteryStyle();\n-        updateShowPercent();\n+    protected void updateBatteryStyle() {\n+        updateDrawable();\n+        scaleBatteryMeterViews();\n+        updatePercentView();\n     }\n \n     public void setForceShowPercent(boolean show) {\n@@ -186,7 +182,7 @@ public class BatteryMeterView extends LinearLayout implements DarkReceiver {\n     @Override\n     protected void onConfigurationChanged(Configuration newConfig) {\n         super.onConfigurationChanged(newConfig);\n-        updatePercentView();\n+        updateBatteryStyle();\n     }\n \n     public void setColorsFromContext(Context context) {\n@@ -303,7 +299,7 @@ public class BatteryMeterView extends LinearLayout implements DarkReceiver {\n                 showBatteryPercent == 2;\n         boolean shouldShow =\n                 (drawPercentOnly && (!drawPercentInside || mCharging) ||\n-                mBatteryStyle == BATTERY_STYLE_TEXT);\n+                getBatteryStyle() == BATTERY_STYLE_TEXT);\n         shouldShow = shouldShow && !mBatteryStateUnknown;\n \n         if (shouldShow) {\n@@ -321,7 +317,7 @@ public class BatteryMeterView extends LinearLayout implements DarkReceiver {\n                                 LayoutParams.WRAP_CONTENT,\n                                 LayoutParams.MATCH_PARENT));\n             }\n-            if (mBatteryStyle == BATTERY_STYLE_TEXT) {\n+            if (getBatteryStyle() == BATTERY_STYLE_TEXT) {\n                 mBatteryPercentView.setPaddingRelative(0, 0, 0, 0);\n             } else {\n                 Resources res = getContext().getResources();\n@@ -358,7 +354,7 @@ public class BatteryMeterView extends LinearLayout implements DarkReceiver {\n         if (mBatteryStateUnknown) {\n             mBatteryIconView.setImageDrawable(getUnknownStateDrawable());\n         } else {\n-            updateBatteryStyle();\n+            updateDrawable();\n         }\n \n         updateShowPercent();\n@@ -375,7 +371,7 @@ public class BatteryMeterView extends LinearLayout implements DarkReceiver {\n         float iconScaleFactor = typedValue.getFloat();\n \n         int batteryHeight = res.getDimensionPixelSize(R.dimen.status_bar_battery_icon_height);\n-        int batteryWidth = mBatteryStyle == BATTERY_STYLE_CIRCLE ?\n+        int batteryWidth = getBatteryStyle() == BATTERY_STYLE_CIRCLE ?\n                 res.getDimensionPixelSize(R.dimen.status_bar_battery_icon_circle_width) :\n                 res.getDimensionPixelSize(R.dimen.status_bar_battery_icon_width);\n         int marginBottom = res.getDimensionPixelSize(R.dimen.battery_margin_bottom);\n@@ -387,17 +383,15 @@ public class BatteryMeterView extends LinearLayout implements DarkReceiver {\n         mBatteryIconView.setLayoutParams(scaledLayoutParams);\n     }\n \n-    private void updateBatteryStyle() {\n-        switch (mBatteryStyle) {\n+    private void updateDrawable() {\n+        switch (getBatteryStyle()) {\n             case BATTERY_STYLE_PORTRAIT:\n                 mBatteryIconView.setImageDrawable(mThemedDrawable);\n                 mBatteryIconView.setVisibility(View.VISIBLE);\n-                scaleBatteryMeterViews();\n                 break;\n             case BATTERY_STYLE_CIRCLE:\n                 mBatteryIconView.setImageDrawable(mCircleDrawable);\n                 mBatteryIconView.setVisibility(View.VISIBLE);\n-                scaleBatteryMeterViews();\n                 break;\n             case BATTERY_STYLE_TEXT:\n                 mBatteryIconView.setVisibility(View.GONE);\n@@ -406,6 +400,12 @@ public class BatteryMeterView extends LinearLayout implements DarkReceiver {\n         }\n     }\n \n+    private int getBatteryStyle() {\n+        return LineageSettings.System.getIntForUser(getContext().getContentResolver(),\n+                LineageSettings.System.STATUS_BAR_BATTERY_STYLE, BATTERY_STYLE_PORTRAIT,\n+                UserHandle.USER_CURRENT);\n+    }\n+\n     @Override\n     public void onDarkChanged(Rect area, float darkIntensity, int tint) {\n         float intensity = DarkIconDispatcher.isInArea(area, this) ? darkIntensity : 0;\n",
    "added_lines": 21,
    "deleted_lines": 21,
    "changed_methods": "BatteryMeterView::getBatteryStyle, BatteryMeterView::updateShowPercent, BatteryMeterView::BatteryMeterView, BatteryMeterView::onBatteryUnknownStateChanged, BatteryMeterView::onConfigurationChanged, BatteryMeterView::scaleBatteryMeterViews, BatteryMeterView::setBatteryStyle, BatteryMeterView::updateDrawable, BatteryMeterView::updateBatteryStyle"
   },
   {
    "filename": "BatteryMeterViewController.java",
    "diff": "@@ -15,6 +15,7 @@\n  */\n package com.android.systemui.battery;\n \n+import static lineageos.providers.LineageSettings.System.STATUS_BAR_BATTERY_STYLE;\n import static lineageos.providers.LineageSettings.System.STATUS_BAR_SHOW_BATTERY_PERCENT;\n \n import android.app.ActivityManager;\n@@ -67,10 +68,8 @@ public class BatteryMeterViewController extends ViewController<BatteryMeterView>\n                         getContext(), newValue);\n                 mBatteryHidden = icons.contains(mSlotBattery);\n                 mView.setVisibility(mBatteryHidden ? View.GONE : View.VISIBLE);\n-            } else if (BatteryMeterView.STATUS_BAR_BATTERY_STYLE.equals(key)) {\n                 if (!mBatteryHidden) {\n-                    mView.setBatteryStyle(TunerService.parseInteger(newValue,\n-                            BatteryMeterView.BATTERY_STYLE_PORTRAIT));\n+                    mView.updateBatteryStyle();\n                 }\n             }\n         }\n@@ -166,8 +165,7 @@ public class BatteryMeterViewController extends ViewController<BatteryMeterView>\n             return;\n         }\n \n-        mTunerService.addTunable(mTunable, StatusBarIconController.ICON_HIDE_LIST,\n-                BatteryMeterView.STATUS_BAR_BATTERY_STYLE);\n+        mTunerService.addTunable(mTunable, StatusBarIconController.ICON_HIDE_LIST);\n         mIsSubscribedForTunerUpdates = true;\n     }\n \n@@ -186,6 +184,11 @@ public class BatteryMeterViewController extends ViewController<BatteryMeterView>\n                 false,\n                 mSettingObserver,\n                 user);\n+        mContentResolver.registerContentObserver(\n+                LineageSettings.System.getUriFor(STATUS_BAR_BATTERY_STYLE),\n+                false,\n+                mSettingObserver,\n+                user);\n     }\n \n     private void registerGlobalBatteryUpdateObserver() {\n@@ -209,6 +212,9 @@ public class BatteryMeterViewController extends ViewController<BatteryMeterView>\n                 // update the text for sure if the estimate in the cache was updated\n                 mView.updatePercentText();\n             }\n+            if (TextUtils.equals(uri.getLastPathSegment(), STATUS_BAR_BATTERY_STYLE)) {\n+                mView.updateBatteryStyle();\n+            }\n         }\n     }\n }\n",
    "added_lines": 11,
    "deleted_lines": 5,
    "changed_methods": "BatteryMeterViewController::subscribeForTunerUpdates, BatteryMeterViewController::SettingObserver::onChange, BatteryMeterViewController::Tunable, BatteryMeterViewController::registerShowBatteryPercentObserver"
   },
   {
    "filename": "QuickStatusBarHeader.java",
    "diff": "@@ -23,6 +23,7 @@ import android.content.res.Configuration;\n import android.content.res.Resources;\n import android.graphics.Color;\n import android.graphics.Rect;\n+import android.os.UserHandle;\n import android.provider.AlarmClock;\n import android.util.AttributeSet;\n import android.util.Pair;\n@@ -51,6 +52,8 @@ import com.android.systemui.statusbar.policy.Clock;\n import com.android.systemui.statusbar.policy.VariableDateView;\n import com.android.systemui.tuner.TunerService;\n \n+import lineageos.providers.LineageSettings;\n+\n import java.util.List;\n \n /**\n@@ -291,7 +294,11 @@ public class QuickStatusBarHeader extends FrameLayout implements TunerService.Tu\n \n         int textColor = Utils.getColorAttrDefaultColor(mContext, android.R.attr.textColorPrimary);\n         if (textColor != mTextColorPrimary) {\n+            boolean isCircleBattery = LineageSettings.System.getIntForUser(\n+                    mContext.getContentResolver(), LineageSettings.System.STATUS_BAR_BATTERY_STYLE,\n+                    0, UserHandle.USER_CURRENT) == 1;\n             int textColorSecondary = Utils.getColorAttrDefaultColor(mContext,\n+                    isCircleBattery ? android.R.attr.textColorHint :\n                     android.R.attr.textColorSecondary);\n             mTextColorPrimary = textColor;\n             mClockView.setTextColor(textColor);\n",
    "added_lines": 7,
    "deleted_lines": 0,
    "changed_methods": "QuickStatusBarHeader::updateResources"
   },
   {
    "filename": "ThemeOverlayController.java",
    "diff": "@@ -441,6 +441,33 @@ public class ThemeOverlayController extends SystemUI implements Dumpable {\n                 },\n                 UserHandle.USER_ALL);\n \n+        mSystemSettings.registerContentObserverForUser(\n+                LineageSettings.System.getUriFor(LineageSettings.System.STATUS_BAR_BATTERY_STYLE),\n+                false,\n+                new ContentObserver(mBgHandler) {\n+                    @Override\n+                    public void onChange(boolean selfChange, Collection<Uri> collection, int flags,\n+                            int userId) {\n+                        if (DEBUG) Log.d(TAG, \"Overlay changed for user: \" + userId);\n+                        if (mUserTracker.getUserId() != userId) {\n+                            return;\n+                        }\n+                        if (!mDeviceProvisionedController.isUserSetup(userId)) {\n+                            Log.i(TAG, \"Theme application deferred when setting changed.\");\n+                            mDeferredThemeEvaluation = true;\n+                            return;\n+                        }\n+                        boolean isCircleBattery = LineageSettings.System.getIntForUser(\n+                                mContext.getContentResolver(),\n+                                LineageSettings.System.STATUS_BAR_BATTERY_STYLE,\n+                                0, UserHandle.USER_CURRENT) == 1;\n+                        if (isCircleBattery) {\n+                            reevaluateSystemTheme(true /* forceReload */);\n+                        }\n+                    }\n+                },\n+                UserHandle.USER_ALL);\n+\n         if (!mIsMonetEnabled) {\n             return;\n         }\n",
    "added_lines": 27,
    "deleted_lines": 0,
    "changed_methods": "ThemeOverlayController::start"
   }
  ]
 },
 {
  "hash": "14cec8935c61ea3ce0db7a31bf8d00690ce8753a",
  "commit": "SystemUI: Redo circle battery style\n\n- Now shows up on QuickSettings panel.\n- Fixes issues with battery circle style on theme and\n  ui mode change and statusbar icon toggle.\n- Fixes wrong tint color with circle battery icon.\n- Re-evaluating system theme to avoid delay in circle\n  battery tint color change.\n\nChange-Id: Id90f85e47ce4b9811e9bb67b91169997020300d8",
  "files": [
   {
    "filename": "BatteryMeterView.java",
    "diff": "@@ -63,9 +63,6 @@ import java.text.NumberFormat;\n \n public class BatteryMeterView extends LinearLayout implements DarkReceiver {\n \n-    protected static final String STATUS_BAR_BATTERY_STYLE =\n-            \"lineagesystem:\" + LineageSettings.System.STATUS_BAR_BATTERY_STYLE;\n-\n     protected static final int BATTERY_STYLE_PORTRAIT = 0;\n     protected static final int BATTERY_STYLE_CIRCLE = 1;\n     protected static final int BATTERY_STYLE_TEXT = 2;\n@@ -93,8 +90,6 @@ public class BatteryMeterView extends LinearLayout implements DarkReceiver {\n     // Lazily-loaded since this is expected to be a rare-if-ever state\n     private Drawable mUnknownStateDrawable;\n \n-    private int mBatteryStyle = BATTERY_STYLE_PORTRAIT;\n-\n     private DualToneHandler mDualToneHandler;\n \n     private int mNonAdaptedSingleToneColor;\n@@ -125,9 +120,11 @@ public class BatteryMeterView extends LinearLayout implements DarkReceiver {\n         setupLayoutTransition();\n \n         mBatteryIconView = new ImageView(context);\n-        mBatteryIconView.setImageDrawable(mThemedDrawable);\n+        updateDrawable();\n         final MarginLayoutParams mlp = new MarginLayoutParams(\n-                getResources().getDimensionPixelSize(R.dimen.status_bar_battery_icon_width),\n+                getBatteryStyle() == BATTERY_STYLE_PORTRAIT ? getResources().getDimensionPixelSize(\n+                R.dimen.status_bar_battery_icon_width) : getResources().getDimensionPixelSize(\n+                R.dimen.status_bar_battery_icon_circle_width),\n                 getResources().getDimensionPixelSize(R.dimen.status_bar_battery_icon_height));\n         mlp.setMargins(0, 0, 0,\n                 getResources().getDimensionPixelOffset(R.dimen.battery_margin_bottom));\n@@ -157,11 +154,10 @@ public class BatteryMeterView extends LinearLayout implements DarkReceiver {\n         setLayoutTransition(transition);\n     }\n \n-    protected void setBatteryStyle(int batteryStyle) {\n-        if (batteryStyle == mBatteryStyle) return;\n-        mBatteryStyle = batteryStyle;\n-        updateBatteryStyle();\n-        updateShowPercent();\n+    protected void updateBatteryStyle() {\n+        updateDrawable();\n+        scaleBatteryMeterViews();\n+        updatePercentView();\n     }\n \n     public void setForceShowPercent(boolean show) {\n@@ -186,7 +182,7 @@ public class BatteryMeterView extends LinearLayout implements DarkReceiver {\n     @Override\n     protected void onConfigurationChanged(Configuration newConfig) {\n         super.onConfigurationChanged(newConfig);\n-        updatePercentView();\n+        updateBatteryStyle();\n     }\n \n     public void setColorsFromContext(Context context) {\n@@ -303,7 +299,7 @@ public class BatteryMeterView extends LinearLayout implements DarkReceiver {\n                 showBatteryPercent == 2;\n         boolean shouldShow =\n                 (drawPercentOnly && (!drawPercentInside || mCharging) ||\n-                mBatteryStyle == BATTERY_STYLE_TEXT);\n+                getBatteryStyle() == BATTERY_STYLE_TEXT);\n         shouldShow = shouldShow && !mBatteryStateUnknown;\n \n         if (shouldShow) {\n@@ -321,7 +317,7 @@ public class BatteryMeterView extends LinearLayout implements DarkReceiver {\n                                 LayoutParams.WRAP_CONTENT,\n                                 LayoutParams.MATCH_PARENT));\n             }\n-            if (mBatteryStyle == BATTERY_STYLE_TEXT) {\n+            if (getBatteryStyle() == BATTERY_STYLE_TEXT) {\n                 mBatteryPercentView.setPaddingRelative(0, 0, 0, 0);\n             } else {\n                 Resources res = getContext().getResources();\n@@ -358,7 +354,7 @@ public class BatteryMeterView extends LinearLayout implements DarkReceiver {\n         if (mBatteryStateUnknown) {\n             mBatteryIconView.setImageDrawable(getUnknownStateDrawable());\n         } else {\n-            updateBatteryStyle();\n+            updateDrawable();\n         }\n \n         updateShowPercent();\n@@ -375,7 +371,7 @@ public class BatteryMeterView extends LinearLayout implements DarkReceiver {\n         float iconScaleFactor = typedValue.getFloat();\n \n         int batteryHeight = res.getDimensionPixelSize(R.dimen.status_bar_battery_icon_height);\n-        int batteryWidth = mBatteryStyle == BATTERY_STYLE_CIRCLE ?\n+        int batteryWidth = getBatteryStyle() == BATTERY_STYLE_CIRCLE ?\n                 res.getDimensionPixelSize(R.dimen.status_bar_battery_icon_circle_width) :\n                 res.getDimensionPixelSize(R.dimen.status_bar_battery_icon_width);\n         int marginBottom = res.getDimensionPixelSize(R.dimen.battery_margin_bottom);\n@@ -387,17 +383,15 @@ public class BatteryMeterView extends LinearLayout implements DarkReceiver {\n         mBatteryIconView.setLayoutParams(scaledLayoutParams);\n     }\n \n-    private void updateBatteryStyle() {\n-        switch (mBatteryStyle) {\n+    private void updateDrawable() {\n+        switch (getBatteryStyle()) {\n             case BATTERY_STYLE_PORTRAIT:\n                 mBatteryIconView.setImageDrawable(mThemedDrawable);\n                 mBatteryIconView.setVisibility(View.VISIBLE);\n-                scaleBatteryMeterViews();\n                 break;\n             case BATTERY_STYLE_CIRCLE:\n                 mBatteryIconView.setImageDrawable(mCircleDrawable);\n                 mBatteryIconView.setVisibility(View.VISIBLE);\n-                scaleBatteryMeterViews();\n                 break;\n             case BATTERY_STYLE_TEXT:\n                 mBatteryIconView.setVisibility(View.GONE);\n@@ -406,6 +400,12 @@ public class BatteryMeterView extends LinearLayout implements DarkReceiver {\n         }\n     }\n \n+    private int getBatteryStyle() {\n+        return LineageSettings.System.getIntForUser(getContext().getContentResolver(),\n+                LineageSettings.System.STATUS_BAR_BATTERY_STYLE, BATTERY_STYLE_PORTRAIT,\n+                UserHandle.USER_CURRENT);\n+    }\n+\n     @Override\n     public void onDarkChanged(Rect area, float darkIntensity, int tint) {\n         float intensity = DarkIconDispatcher.isInArea(area, this) ? darkIntensity : 0;\n",
    "added_lines": 21,
    "deleted_lines": 21,
    "changed_methods": "BatteryMeterView::getBatteryStyle, BatteryMeterView::updateShowPercent, BatteryMeterView::BatteryMeterView, BatteryMeterView::onBatteryUnknownStateChanged, BatteryMeterView::onConfigurationChanged, BatteryMeterView::scaleBatteryMeterViews, BatteryMeterView::setBatteryStyle, BatteryMeterView::updateDrawable, BatteryMeterView::updateBatteryStyle"
   },
   {
    "filename": "BatteryMeterViewController.java",
    "diff": "@@ -15,6 +15,7 @@\n  */\n package com.android.systemui.battery;\n \n+import static lineageos.providers.LineageSettings.System.STATUS_BAR_BATTERY_STYLE;\n import static lineageos.providers.LineageSettings.System.STATUS_BAR_SHOW_BATTERY_PERCENT;\n \n import android.app.ActivityManager;\n@@ -67,10 +68,8 @@ public class BatteryMeterViewController extends ViewController<BatteryMeterView>\n                         getContext(), newValue);\n                 mBatteryHidden = icons.contains(mSlotBattery);\n                 mView.setVisibility(mBatteryHidden ? View.GONE : View.VISIBLE);\n-            } else if (BatteryMeterView.STATUS_BAR_BATTERY_STYLE.equals(key)) {\n                 if (!mBatteryHidden) {\n-                    mView.setBatteryStyle(TunerService.parseInteger(newValue,\n-                            BatteryMeterView.BATTERY_STYLE_PORTRAIT));\n+                    mView.updateBatteryStyle();\n                 }\n             }\n         }\n@@ -166,8 +165,7 @@ public class BatteryMeterViewController extends ViewController<BatteryMeterView>\n             return;\n         }\n \n-        mTunerService.addTunable(mTunable, StatusBarIconController.ICON_HIDE_LIST,\n-                BatteryMeterView.STATUS_BAR_BATTERY_STYLE);\n+        mTunerService.addTunable(mTunable, StatusBarIconController.ICON_HIDE_LIST);\n         mIsSubscribedForTunerUpdates = true;\n     }\n \n@@ -186,6 +184,11 @@ public class BatteryMeterViewController extends ViewController<BatteryMeterView>\n                 false,\n                 mSettingObserver,\n                 user);\n+        mContentResolver.registerContentObserver(\n+                LineageSettings.System.getUriFor(STATUS_BAR_BATTERY_STYLE),\n+                false,\n+                mSettingObserver,\n+                user);\n     }\n \n     private void registerGlobalBatteryUpdateObserver() {\n@@ -209,6 +212,9 @@ public class BatteryMeterViewController extends ViewController<BatteryMeterView>\n                 // update the text for sure if the estimate in the cache was updated\n                 mView.updatePercentText();\n             }\n+            if (TextUtils.equals(uri.getLastPathSegment(), STATUS_BAR_BATTERY_STYLE)) {\n+                mView.updateBatteryStyle();\n+            }\n         }\n     }\n }\n",
    "added_lines": 11,
    "deleted_lines": 5,
    "changed_methods": "BatteryMeterViewController::subscribeForTunerUpdates, BatteryMeterViewController::SettingObserver::onChange, BatteryMeterViewController::Tunable, BatteryMeterViewController::registerShowBatteryPercentObserver"
   },
   {
    "filename": "QuickStatusBarHeader.java",
    "diff": "@@ -23,6 +23,7 @@ import android.content.res.Configuration;\n import android.content.res.Resources;\n import android.graphics.Color;\n import android.graphics.Rect;\n+import android.os.UserHandle;\n import android.provider.AlarmClock;\n import android.util.AttributeSet;\n import android.util.Pair;\n@@ -51,6 +52,8 @@ import com.android.systemui.statusbar.policy.Clock;\n import com.android.systemui.statusbar.policy.VariableDateView;\n import com.android.systemui.tuner.TunerService;\n \n+import lineageos.providers.LineageSettings;\n+\n import java.util.List;\n \n /**\n@@ -291,7 +294,11 @@ public class QuickStatusBarHeader extends FrameLayout implements TunerService.Tu\n \n         int textColor = Utils.getColorAttrDefaultColor(mContext, android.R.attr.textColorPrimary);\n         if (textColor != mTextColorPrimary) {\n+            boolean isCircleBattery = LineageSettings.System.getIntForUser(\n+                    mContext.getContentResolver(), LineageSettings.System.STATUS_BAR_BATTERY_STYLE,\n+                    0, UserHandle.USER_CURRENT) == 1;\n             int textColorSecondary = Utils.getColorAttrDefaultColor(mContext,\n+                    isCircleBattery ? android.R.attr.textColorHint :\n                     android.R.attr.textColorSecondary);\n             mTextColorPrimary = textColor;\n             mClockView.setTextColor(textColor);\n",
    "added_lines": 7,
    "deleted_lines": 0,
    "changed_methods": "QuickStatusBarHeader::updateResources"
   },
   {
    "filename": "ThemeOverlayController.java",
    "diff": "@@ -441,6 +441,33 @@ public class ThemeOverlayController extends SystemUI implements Dumpable {\n                 },\n                 UserHandle.USER_ALL);\n \n+        mSystemSettings.registerContentObserverForUser(\n+                LineageSettings.System.getUriFor(LineageSettings.System.STATUS_BAR_BATTERY_STYLE),\n+                false,\n+                new ContentObserver(mBgHandler) {\n+                    @Override\n+                    public void onChange(boolean selfChange, Collection<Uri> collection, int flags,\n+                            int userId) {\n+                        if (DEBUG) Log.d(TAG, \"Overlay changed for user: \" + userId);\n+                        if (mUserTracker.getUserId() != userId) {\n+                            return;\n+                        }\n+                        if (!mDeviceProvisionedController.isUserSetup(userId)) {\n+                            Log.i(TAG, \"Theme application deferred when setting changed.\");\n+                            mDeferredThemeEvaluation = true;\n+                            return;\n+                        }\n+                        boolean isCircleBattery = LineageSettings.System.getIntForUser(\n+                                mContext.getContentResolver(),\n+                                LineageSettings.System.STATUS_BAR_BATTERY_STYLE,\n+                                0, UserHandle.USER_CURRENT) == 1;\n+                        if (isCircleBattery) {\n+                            reevaluateSystemTheme(true /* forceReload */);\n+                        }\n+                    }\n+                },\n+                UserHandle.USER_ALL);\n+\n         if (!mIsMonetEnabled) {\n             return;\n         }\n",
    "added_lines": 27,
    "deleted_lines": 0,
    "changed_methods": "ThemeOverlayController::start"
   }
  ]
 },
 {
  "hash": "14cec8935c61ea3ce0db7a31bf8d00690ce8753a",
  "commit": "SystemUI: Redo circle battery style\n\n- Now shows up on QuickSettings panel.\n- Fixes issues with battery circle style on theme and\n  ui mode change and statusbar icon toggle.\n- Fixes wrong tint color with circle battery icon.\n- Re-evaluating system theme to avoid delay in circle\n  battery tint color change.\n\nChange-Id: Id90f85e47ce4b9811e9bb67b91169997020300d8",
  "files": [
   {
    "filename": "BatteryMeterView.java",
    "diff": "@@ -63,9 +63,6 @@ import java.text.NumberFormat;\n \n public class BatteryMeterView extends LinearLayout implements DarkReceiver {\n \n-    protected static final String STATUS_BAR_BATTERY_STYLE =\n-            \"lineagesystem:\" + LineageSettings.System.STATUS_BAR_BATTERY_STYLE;\n-\n     protected static final int BATTERY_STYLE_PORTRAIT = 0;\n     protected static final int BATTERY_STYLE_CIRCLE = 1;\n     protected static final int BATTERY_STYLE_TEXT = 2;\n@@ -93,8 +90,6 @@ public class BatteryMeterView extends LinearLayout implements DarkReceiver {\n     // Lazily-loaded since this is expected to be a rare-if-ever state\n     private Drawable mUnknownStateDrawable;\n \n-    private int mBatteryStyle = BATTERY_STYLE_PORTRAIT;\n-\n     private DualToneHandler mDualToneHandler;\n \n     private int mNonAdaptedSingleToneColor;\n@@ -125,9 +120,11 @@ public class BatteryMeterView extends LinearLayout implements DarkReceiver {\n         setupLayoutTransition();\n \n         mBatteryIconView = new ImageView(context);\n-        mBatteryIconView.setImageDrawable(mThemedDrawable);\n+        updateDrawable();\n         final MarginLayoutParams mlp = new MarginLayoutParams(\n-                getResources().getDimensionPixelSize(R.dimen.status_bar_battery_icon_width),\n+                getBatteryStyle() == BATTERY_STYLE_PORTRAIT ? getResources().getDimensionPixelSize(\n+                R.dimen.status_bar_battery_icon_width) : getResources().getDimensionPixelSize(\n+                R.dimen.status_bar_battery_icon_circle_width),\n                 getResources().getDimensionPixelSize(R.dimen.status_bar_battery_icon_height));\n         mlp.setMargins(0, 0, 0,\n                 getResources().getDimensionPixelOffset(R.dimen.battery_margin_bottom));\n@@ -157,11 +154,10 @@ public class BatteryMeterView extends LinearLayout implements DarkReceiver {\n         setLayoutTransition(transition);\n     }\n \n-    protected void setBatteryStyle(int batteryStyle) {\n-        if (batteryStyle == mBatteryStyle) return;\n-        mBatteryStyle = batteryStyle;\n-        updateBatteryStyle();\n-        updateShowPercent();\n+    protected void updateBatteryStyle() {\n+        updateDrawable();\n+        scaleBatteryMeterViews();\n+        updatePercentView();\n     }\n \n     public void setForceShowPercent(boolean show) {\n@@ -186,7 +182,7 @@ public class BatteryMeterView extends LinearLayout implements DarkReceiver {\n     @Override\n     protected void onConfigurationChanged(Configuration newConfig) {\n         super.onConfigurationChanged(newConfig);\n-        updatePercentView();\n+        updateBatteryStyle();\n     }\n \n     public void setColorsFromContext(Context context) {\n@@ -303,7 +299,7 @@ public class BatteryMeterView extends LinearLayout implements DarkReceiver {\n                 showBatteryPercent == 2;\n         boolean shouldShow =\n                 (drawPercentOnly && (!drawPercentInside || mCharging) ||\n-                mBatteryStyle == BATTERY_STYLE_TEXT);\n+                getBatteryStyle() == BATTERY_STYLE_TEXT);\n         shouldShow = shouldShow && !mBatteryStateUnknown;\n \n         if (shouldShow) {\n@@ -321,7 +317,7 @@ public class BatteryMeterView extends LinearLayout implements DarkReceiver {\n                                 LayoutParams.WRAP_CONTENT,\n                                 LayoutParams.MATCH_PARENT));\n             }\n-            if (mBatteryStyle == BATTERY_STYLE_TEXT) {\n+            if (getBatteryStyle() == BATTERY_STYLE_TEXT) {\n                 mBatteryPercentView.setPaddingRelative(0, 0, 0, 0);\n             } else {\n                 Resources res = getContext().getResources();\n@@ -358,7 +354,7 @@ public class BatteryMeterView extends LinearLayout implements DarkReceiver {\n         if (mBatteryStateUnknown) {\n             mBatteryIconView.setImageDrawable(getUnknownStateDrawable());\n         } else {\n-            updateBatteryStyle();\n+            updateDrawable();\n         }\n \n         updateShowPercent();\n@@ -375,7 +371,7 @@ public class BatteryMeterView extends LinearLayout implements DarkReceiver {\n         float iconScaleFactor = typedValue.getFloat();\n \n         int batteryHeight = res.getDimensionPixelSize(R.dimen.status_bar_battery_icon_height);\n-        int batteryWidth = mBatteryStyle == BATTERY_STYLE_CIRCLE ?\n+        int batteryWidth = getBatteryStyle() == BATTERY_STYLE_CIRCLE ?\n                 res.getDimensionPixelSize(R.dimen.status_bar_battery_icon_circle_width) :\n                 res.getDimensionPixelSize(R.dimen.status_bar_battery_icon_width);\n         int marginBottom = res.getDimensionPixelSize(R.dimen.battery_margin_bottom);\n@@ -387,17 +383,15 @@ public class BatteryMeterView extends LinearLayout implements DarkReceiver {\n         mBatteryIconView.setLayoutParams(scaledLayoutParams);\n     }\n \n-    private void updateBatteryStyle() {\n-        switch (mBatteryStyle) {\n+    private void updateDrawable() {\n+        switch (getBatteryStyle()) {\n             case BATTERY_STYLE_PORTRAIT:\n                 mBatteryIconView.setImageDrawable(mThemedDrawable);\n                 mBatteryIconView.setVisibility(View.VISIBLE);\n-                scaleBatteryMeterViews();\n                 break;\n             case BATTERY_STYLE_CIRCLE:\n                 mBatteryIconView.setImageDrawable(mCircleDrawable);\n                 mBatteryIconView.setVisibility(View.VISIBLE);\n-                scaleBatteryMeterViews();\n                 break;\n             case BATTERY_STYLE_TEXT:\n                 mBatteryIconView.setVisibility(View.GONE);\n@@ -406,6 +400,12 @@ public class BatteryMeterView extends LinearLayout implements DarkReceiver {\n         }\n     }\n \n+    private int getBatteryStyle() {\n+        return LineageSettings.System.getIntForUser(getContext().getContentResolver(),\n+                LineageSettings.System.STATUS_BAR_BATTERY_STYLE, BATTERY_STYLE_PORTRAIT,\n+                UserHandle.USER_CURRENT);\n+    }\n+\n     @Override\n     public void onDarkChanged(Rect area, float darkIntensity, int tint) {\n         float intensity = DarkIconDispatcher.isInArea(area, this) ? darkIntensity : 0;\n",
    "added_lines": 21,
    "deleted_lines": 21,
    "changed_methods": "BatteryMeterView::getBatteryStyle, BatteryMeterView::updateShowPercent, BatteryMeterView::BatteryMeterView, BatteryMeterView::onBatteryUnknownStateChanged, BatteryMeterView::onConfigurationChanged, BatteryMeterView::scaleBatteryMeterViews, BatteryMeterView::setBatteryStyle, BatteryMeterView::updateDrawable, BatteryMeterView::updateBatteryStyle"
   },
   {
    "filename": "BatteryMeterViewController.java",
    "diff": "@@ -15,6 +15,7 @@\n  */\n package com.android.systemui.battery;\n \n+import static lineageos.providers.LineageSettings.System.STATUS_BAR_BATTERY_STYLE;\n import static lineageos.providers.LineageSettings.System.STATUS_BAR_SHOW_BATTERY_PERCENT;\n \n import android.app.ActivityManager;\n@@ -67,10 +68,8 @@ public class BatteryMeterViewController extends ViewController<BatteryMeterView>\n                         getContext(), newValue);\n                 mBatteryHidden = icons.contains(mSlotBattery);\n                 mView.setVisibility(mBatteryHidden ? View.GONE : View.VISIBLE);\n-            } else if (BatteryMeterView.STATUS_BAR_BATTERY_STYLE.equals(key)) {\n                 if (!mBatteryHidden) {\n-                    mView.setBatteryStyle(TunerService.parseInteger(newValue,\n-                            BatteryMeterView.BATTERY_STYLE_PORTRAIT));\n+                    mView.updateBatteryStyle();\n                 }\n             }\n         }\n@@ -166,8 +165,7 @@ public class BatteryMeterViewController extends ViewController<BatteryMeterView>\n             return;\n         }\n \n-        mTunerService.addTunable(mTunable, StatusBarIconController.ICON_HIDE_LIST,\n-                BatteryMeterView.STATUS_BAR_BATTERY_STYLE);\n+        mTunerService.addTunable(mTunable, StatusBarIconController.ICON_HIDE_LIST);\n         mIsSubscribedForTunerUpdates = true;\n     }\n \n@@ -186,6 +184,11 @@ public class BatteryMeterViewController extends ViewController<BatteryMeterView>\n                 false,\n                 mSettingObserver,\n                 user);\n+        mContentResolver.registerContentObserver(\n+                LineageSettings.System.getUriFor(STATUS_BAR_BATTERY_STYLE),\n+                false,\n+                mSettingObserver,\n+                user);\n     }\n \n     private void registerGlobalBatteryUpdateObserver() {\n@@ -209,6 +212,9 @@ public class BatteryMeterViewController extends ViewController<BatteryMeterView>\n                 // update the text for sure if the estimate in the cache was updated\n                 mView.updatePercentText();\n             }\n+            if (TextUtils.equals(uri.getLastPathSegment(), STATUS_BAR_BATTERY_STYLE)) {\n+                mView.updateBatteryStyle();\n+            }\n         }\n     }\n }\n",
    "added_lines": 11,
    "deleted_lines": 5,
    "changed_methods": "BatteryMeterViewController::subscribeForTunerUpdates, BatteryMeterViewController::SettingObserver::onChange, BatteryMeterViewController::Tunable, BatteryMeterViewController::registerShowBatteryPercentObserver"
   },
   {
    "filename": "QuickStatusBarHeader.java",
    "diff": "@@ -23,6 +23,7 @@ import android.content.res.Configuration;\n import android.content.res.Resources;\n import android.graphics.Color;\n import android.graphics.Rect;\n+import android.os.UserHandle;\n import android.provider.AlarmClock;\n import android.util.AttributeSet;\n import android.util.Pair;\n@@ -51,6 +52,8 @@ import com.android.systemui.statusbar.policy.Clock;\n import com.android.systemui.statusbar.policy.VariableDateView;\n import com.android.systemui.tuner.TunerService;\n \n+import lineageos.providers.LineageSettings;\n+\n import java.util.List;\n \n /**\n@@ -291,7 +294,11 @@ public class QuickStatusBarHeader extends FrameLayout implements TunerService.Tu\n \n         int textColor = Utils.getColorAttrDefaultColor(mContext, android.R.attr.textColorPrimary);\n         if (textColor != mTextColorPrimary) {\n+            boolean isCircleBattery = LineageSettings.System.getIntForUser(\n+                    mContext.getContentResolver(), LineageSettings.System.STATUS_BAR_BATTERY_STYLE,\n+                    0, UserHandle.USER_CURRENT) == 1;\n             int textColorSecondary = Utils.getColorAttrDefaultColor(mContext,\n+                    isCircleBattery ? android.R.attr.textColorHint :\n                     android.R.attr.textColorSecondary);\n             mTextColorPrimary = textColor;\n             mClockView.setTextColor(textColor);\n",
    "added_lines": 7,
    "deleted_lines": 0,
    "changed_methods": "QuickStatusBarHeader::updateResources"
   },
   {
    "filename": "ThemeOverlayController.java",
    "diff": "@@ -441,6 +441,33 @@ public class ThemeOverlayController extends SystemUI implements Dumpable {\n                 },\n                 UserHandle.USER_ALL);\n \n+        mSystemSettings.registerContentObserverForUser(\n+                LineageSettings.System.getUriFor(LineageSettings.System.STATUS_BAR_BATTERY_STYLE),\n+                false,\n+                new ContentObserver(mBgHandler) {\n+                    @Override\n+                    public void onChange(boolean selfChange, Collection<Uri> collection, int flags,\n+                            int userId) {\n+                        if (DEBUG) Log.d(TAG, \"Overlay changed for user: \" + userId);\n+                        if (mUserTracker.getUserId() != userId) {\n+                            return;\n+                        }\n+                        if (!mDeviceProvisionedController.isUserSetup(userId)) {\n+                            Log.i(TAG, \"Theme application deferred when setting changed.\");\n+                            mDeferredThemeEvaluation = true;\n+                            return;\n+                        }\n+                        boolean isCircleBattery = LineageSettings.System.getIntForUser(\n+                                mContext.getContentResolver(),\n+                                LineageSettings.System.STATUS_BAR_BATTERY_STYLE,\n+                                0, UserHandle.USER_CURRENT) == 1;\n+                        if (isCircleBattery) {\n+                            reevaluateSystemTheme(true /* forceReload */);\n+                        }\n+                    }\n+                },\n+                UserHandle.USER_ALL);\n+\n         if (!mIsMonetEnabled) {\n             return;\n         }\n",
    "added_lines": 27,
    "deleted_lines": 0,
    "changed_methods": "ThemeOverlayController::start"
   }
  ]
 },
 {
  "hash": "26066d9ee84bc90aa8f5f77cb6a2dfe5dc4be78c",
  "commit": "Keyguard: Allow user configurable fingerprint wake-and-unlock\n\nChange-Id: I471908cfa27a54e0075394eed348cb15386f62ce",
  "files": [
   {
    "filename": "KeyguardUpdateMonitor.java",
    "diff": "@@ -114,6 +114,8 @@ import com.android.systemui.util.RingerModeTracker;\n \n import com.google.android.collect.Lists;\n \n+import lineageos.providers.LineageSettings;\n+\n import java.io.FileDescriptor;\n import java.io.PrintWriter;\n import java.lang.ref.WeakReference;\n@@ -306,6 +308,7 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener, Dumpab\n             mCallbacks = Lists.newArrayList();\n     private ContentObserver mDeviceProvisionedObserver;\n     private ContentObserver mTimeFormatChangeObserver;\n+    private ContentObserver mSettingsChangeObserver;\n \n     private boolean mSwitchingUser;\n \n@@ -339,7 +342,7 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener, Dumpab\n     private SensorPrivacyManager mSensorPrivacyManager;\n     private int mFaceAuthUserId;\n \n-    private final boolean mFingerprintWakeAndUnlock;\n+    private boolean mFingerprintWakeAndUnlock;\n \n     /**\n      * Short delay before restarting fingerprint authentication after a successful try. This should\n@@ -1826,8 +1829,6 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener, Dumpab\n         mTelephonyListenerManager = telephonyListenerManager;\n         mDeviceProvisioned = isDeviceProvisionedInSettingsDb();\n         mStrongAuthTracker = new StrongAuthTracker(context, this::notifyStrongAuthStateChanged);\n-        mFingerprintWakeAndUnlock = mContext.getResources().getBoolean(\n-                com.android.systemui.R.bool.config_fingerprintWakeAndUnlock);\n         mBackgroundExecutor = backgroundExecutor;\n         mBroadcastDispatcher = broadcastDispatcher;\n         mInteractionJankMonitor = interactionJankMonitor;\n@@ -1841,6 +1842,8 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener, Dumpab\n         dumpManager.registerDumpable(getClass().getName(), this);\n         mSensorPrivacyManager = context.getSystemService(SensorPrivacyManager.class);\n \n+        updateFingerprintSettings();\n+\n         mHandler = new Handler(mainLooper) {\n             @Override\n             public void handleMessage(Message msg) {\n@@ -2113,6 +2116,32 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener, Dumpab\n         mContext.getContentResolver().registerContentObserver(\n                 Settings.System.getUriFor(Settings.System.TIME_12_24),\n                 false, mTimeFormatChangeObserver, UserHandle.USER_ALL);\n+\n+        mSettingsChangeObserver = new ContentObserver(mHandler) {\n+            @Override\n+            public void onChange(boolean selfChange) {\n+                updateFingerprintSettings();\n+            }\n+        };\n+        mContext.getContentResolver().registerContentObserver(\n+                LineageSettings.System.getUriFor(LineageSettings.System.FINGERPRINT_WAKE_UNLOCK),\n+                false, mSettingsChangeObserver, UserHandle.USER_ALL);\n+    }\n+\n+    private void updateFingerprintSettings() {\n+        boolean defFingerprintSettings = mContext.getResources().getBoolean(\n+                com.android.systemui.R.bool.config_fingerprintWakeAndUnlock);\n+        if (defFingerprintSettings) {\n+            mFingerprintWakeAndUnlock = LineageSettings.System.getIntForUser(\n+                    mContext.getContentResolver(), LineageSettings.System.FINGERPRINT_WAKE_UNLOCK,\n+                    1, UserHandle.USER_CURRENT) == 1;\n+        } else {\n+            mFingerprintWakeAndUnlock = defFingerprintSettings;\n+            // if its false, the device meant to be used like that, disable toggle with 2.\n+            LineageSettings.System.putIntForUser(mContext.getContentResolver(),\n+                    LineageSettings.System.FINGERPRINT_WAKE_UNLOCK,\n+                    2, UserHandle.USER_CURRENT);\n+        }\n     }\n \n     private void updateUdfpsEnrolled(int userId) {\n@@ -3462,6 +3491,10 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener, Dumpab\n             mContext.getContentResolver().unregisterContentObserver(mTimeFormatChangeObserver);\n         }\n \n+        if (mSettingsChangeObserver != null) {\n+            mContext.getContentResolver().unregisterContentObserver(mSettingsChangeObserver);\n+        }\n+\n         try {\n             ActivityManager.getService().unregisterUserSwitchObserver(mUserSwitchObserver);\n         } catch (RemoteException e) {\n",
    "added_lines": 36,
    "deleted_lines": 3,
    "changed_methods": "KeyguardUpdateMonitor::updateFingerprintSettings, KeyguardUpdateMonitor::destroy, KeyguardUpdateMonitor::KeyguardUpdateMonitor"
   }
  ]
 },
 {
  "hash": "92ebedf7b4cf1b3fe3f6bd0db1f8cecc2425f012",
  "commit": "SystemUI: screenshot: open the screenshot instead of edit\n\nOpen the taken screenshot in gallery application when clicking on the\npreview. There is a seperate edit button, so the preview imageview\nshould open gallery instead.\n\nTest: atest com.android.systemui.screenshot.ScreenshotNotificationSmartActionsTest\nChange-Id: I8f882ddd0da47ca50acc37d25ee0866ce5698e4f",
  "files": [
   {
    "filename": "ActionProxyReceiver.java",
    "diff": "@@ -20,6 +20,7 @@ import static android.view.Display.DEFAULT_DISPLAY;\n \n import static com.android.systemui.screenshot.ScreenshotController.ACTION_TYPE_EDIT;\n import static com.android.systemui.screenshot.ScreenshotController.ACTION_TYPE_SHARE;\n+import static com.android.systemui.screenshot.ScreenshotController.ACTION_TYPE_VIEW;\n import static com.android.systemui.screenshot.ScreenshotController.EXTRA_ACTION_INTENT;\n import static com.android.systemui.screenshot.ScreenshotController.EXTRA_DISALLOW_ENTER_PIP;\n import static com.android.systemui.screenshot.ScreenshotController.EXTRA_ID;\n@@ -98,9 +99,15 @@ public class ActionProxyReceiver extends BroadcastReceiver {\n         }\n \n         if (intent.getBooleanExtra(EXTRA_SMART_ACTIONS_ENABLED, false)) {\n-            String actionType = Intent.ACTION_EDIT.equals(intent.getAction())\n-                    ? ACTION_TYPE_EDIT\n-                    : ACTION_TYPE_SHARE;\n+            String action = intent.getAction();\n+            String actionType;\n+            if (Intent.ACTION_VIEW.equals(action)) {\n+                actionType = ACTION_TYPE_VIEW;\n+            } else if (Intent.ACTION_EDIT.equals(action)) {\n+                actionType = ACTION_TYPE_EDIT;\n+            } else {\n+                actionType = ACTION_TYPE_SHARE;\n+            }\n             mScreenshotSmartActions.notifyScreenshotAction(\n                     context, intent.getStringExtra(EXTRA_ID), actionType, false, null);\n         }\n",
    "added_lines": 10,
    "deleted_lines": 3,
    "changed_methods": "ActionProxyReceiver::onReceive"
   },
   {
    "filename": "SaveImageInBackgroundTask.java",
    "diff": "@@ -166,6 +166,7 @@ class SaveImageInBackgroundTask extends AsyncTask<String, Void, Void> {\n \n             mImageData.uri = uri;\n             mImageData.smartActions = smartActions;\n+            mImageData.viewTransition = createViewAction(mContext, mContext.getResources(), uri);\n             mImageData.shareTransition = createShareAction(mContext, mContext.getResources(), uri);\n             mImageData.editTransition = createEditAction(mContext, mContext.getResources(), uri);\n             mImageData.deleteAction = createDeleteAction(mContext, mContext.getResources(), uri);\n@@ -221,6 +222,51 @@ class SaveImageInBackgroundTask extends AsyncTask<String, Void, Void> {\n         mParams.clearImage();\n     }\n \n+    @VisibleForTesting\n+    Supplier<ActionTransition> createViewAction(Context context, Resources r, Uri uri) {\n+        return () -> {\n+            ActionTransition transition = mSharedElementTransition.get();\n+            // Note: the view, share and edit actions are proxied through ActionProxyReceiver in\n+            // order to do some common work like dismissing the keyguard and sending\n+            // closeSystemWindows\n+\n+            // Create an edit intent, if a specific package is provided as the editor, then\n+            // launch that directly\n+            Intent viewIntent = new Intent(Intent.ACTION_VIEW);\n+            viewIntent.setDataAndType(uri, \"image/png\");\n+            viewIntent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);\n+            viewIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);\n+\n+            PendingIntent pendingIntent = PendingIntent.getActivityAsUser(\n+                    context, 0, viewIntent, PendingIntent.FLAG_IMMUTABLE,\n+                    transition.bundle, UserHandle.CURRENT);\n+\n+            // Make sure pending intents for the system user are still unique across users\n+            // by setting the (otherwise unused) request code to the current user id.\n+            int requestCode = mContext.getUserId();\n+\n+            // Create a view action\n+            PendingIntent viewAction = PendingIntent.getBroadcastAsUser(context, requestCode,\n+                    new Intent(context, ActionProxyReceiver.class)\n+                            .putExtra(ScreenshotController.EXTRA_ACTION_INTENT, pendingIntent)\n+                            .putExtra(ScreenshotController.EXTRA_ID, mScreenshotId)\n+                            .putExtra(ScreenshotController.EXTRA_SMART_ACTIONS_ENABLED,\n+                                    mSmartActionsEnabled)\n+                            .putExtra(ScreenshotController.EXTRA_OVERRIDE_TRANSITION, true)\n+                            .setAction(Intent.ACTION_VIEW)\n+                            .addFlags(Intent.FLAG_RECEIVER_FOREGROUND),\n+                    PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_IMMUTABLE,\n+                    UserHandle.SYSTEM);\n+            Notification.Action.Builder editActionBuilder = new Notification.Action.Builder(\n+                    Icon.createWithResource(r, com.android.internal.R.drawable.ic_screenshot),\n+                    r.getString(com.android.internal.R.string.global_action_screenshot),\n+                    viewAction);\n+\n+            transition.action = editActionBuilder.build();\n+            return transition;\n+        };\n+    }\n+\n     /**\n      * Assumes that the action intent is sent immediately after being supplied.\n      */\n",
    "added_lines": 46,
    "deleted_lines": 0,
    "changed_methods": "SaveImageInBackgroundTask::createViewAction, SaveImageInBackgroundTask::doInBackground"
   },
   {
    "filename": "ScreenshotController.java",
    "diff": "@@ -166,6 +166,7 @@ public class ScreenshotController {\n      */\n     static class SavedImageData {\n         public Uri uri;\n+        public Supplier<ActionTransition> viewTransition;\n         public Supplier<ActionTransition> shareTransition;\n         public Supplier<ActionTransition> editTransition;\n         public Notification.Action deleteAction;\n@@ -229,6 +230,7 @@ public class ScreenshotController {\n     // ScreenshotNotificationSmartActionsProvider.\n     static final String EXTRA_ACTION_TYPE = \"android:screenshot_action_type\";\n     static final String EXTRA_ID = \"android:screenshot_id\";\n+    static final String ACTION_TYPE_VIEW = \"View\";\n     static final String ACTION_TYPE_DELETE = \"Delete\";\n     static final String ACTION_TYPE_SHARE = \"Share\";\n     static final String ACTION_TYPE_EDIT = \"Edit\";\n",
    "added_lines": 2,
    "deleted_lines": 0,
    "changed_methods": ""
   },
   {
    "filename": "ScreenshotView.java",
    "diff": "@@ -722,7 +722,7 @@ public class ScreenshotView extends FrameLayout implements\n         mScreenshotPreview.setOnClickListener(v -> {\n             mUiEventLogger.log(ScreenshotEvent.SCREENSHOT_PREVIEW_TAPPED, 0, mPackageName);\n             startSharedTransition(\n-                    imageData.editTransition.get());\n+                    imageData.viewTransition.get());\n         });\n         if (mQuickShareChip != null) {\n             mQuickShareChip.setPendingIntent(imageData.quickShareAction.actionIntent,\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "ScreenshotView::setChipIntents"
   },
   {
    "filename": "ScreenshotNotificationSmartActionsTest.java",
    "diff": "@@ -169,6 +169,34 @@ public class ScreenshotNotificationSmartActionsTest extends SysuiTestCase {\n         assertEquals(smartActions.size(), 0);\n     }\n \n+    // Tests for view action extras\n+    @Test\n+    public void testViewActionExtras() {\n+        if (Looper.myLooper() == null) {\n+            Looper.prepare();\n+        }\n+\n+        ScreenshotController.SaveImageInBackgroundData\n+                data = new ScreenshotController.SaveImageInBackgroundData();\n+        data.image = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);\n+        data.finisher = null;\n+        data.mActionsReadyListener = null;\n+        SaveImageInBackgroundTask task =\n+                new SaveImageInBackgroundTask(mContext, null, mScreenshotSmartActions, data,\n+                        ActionTransition::new);\n+\n+        Notification.Action viewAction = task.createViewAction(mContext, mContext.getResources(),\n+                Uri.parse(\"Screenshot_123.png\")).get().action;\n+\n+        Intent intent = viewAction.actionIntent.getIntent();\n+        assertNotNull(intent);\n+        Bundle bundle = intent.getExtras();\n+        assertTrue(bundle.containsKey(ScreenshotController.EXTRA_ID));\n+        assertTrue(bundle.containsKey(ScreenshotController.EXTRA_SMART_ACTIONS_ENABLED));\n+        assertEquals(ScreenshotController.ACTION_TYPE_VIEW, viewAction.title);\n+        assertEquals(Intent.ACTION_VIEW, intent.getAction());\n+    }\n+\n     // Tests for share action extras\n     @Test\n     public void testShareActionExtras() {\n",
    "added_lines": 28,
    "deleted_lines": 0,
    "changed_methods": "ScreenshotNotificationSmartActionsTest::testViewActionExtras"
   }
  ]
 },
 {
  "hash": "92ebedf7b4cf1b3fe3f6bd0db1f8cecc2425f012",
  "commit": "SystemUI: screenshot: open the screenshot instead of edit\n\nOpen the taken screenshot in gallery application when clicking on the\npreview. There is a seperate edit button, so the preview imageview\nshould open gallery instead.\n\nTest: atest com.android.systemui.screenshot.ScreenshotNotificationSmartActionsTest\nChange-Id: I8f882ddd0da47ca50acc37d25ee0866ce5698e4f",
  "files": [
   {
    "filename": "ActionProxyReceiver.java",
    "diff": "@@ -20,6 +20,7 @@ import static android.view.Display.DEFAULT_DISPLAY;\n \n import static com.android.systemui.screenshot.ScreenshotController.ACTION_TYPE_EDIT;\n import static com.android.systemui.screenshot.ScreenshotController.ACTION_TYPE_SHARE;\n+import static com.android.systemui.screenshot.ScreenshotController.ACTION_TYPE_VIEW;\n import static com.android.systemui.screenshot.ScreenshotController.EXTRA_ACTION_INTENT;\n import static com.android.systemui.screenshot.ScreenshotController.EXTRA_DISALLOW_ENTER_PIP;\n import static com.android.systemui.screenshot.ScreenshotController.EXTRA_ID;\n@@ -98,9 +99,15 @@ public class ActionProxyReceiver extends BroadcastReceiver {\n         }\n \n         if (intent.getBooleanExtra(EXTRA_SMART_ACTIONS_ENABLED, false)) {\n-            String actionType = Intent.ACTION_EDIT.equals(intent.getAction())\n-                    ? ACTION_TYPE_EDIT\n-                    : ACTION_TYPE_SHARE;\n+            String action = intent.getAction();\n+            String actionType;\n+            if (Intent.ACTION_VIEW.equals(action)) {\n+                actionType = ACTION_TYPE_VIEW;\n+            } else if (Intent.ACTION_EDIT.equals(action)) {\n+                actionType = ACTION_TYPE_EDIT;\n+            } else {\n+                actionType = ACTION_TYPE_SHARE;\n+            }\n             mScreenshotSmartActions.notifyScreenshotAction(\n                     context, intent.getStringExtra(EXTRA_ID), actionType, false, null);\n         }\n",
    "added_lines": 10,
    "deleted_lines": 3,
    "changed_methods": "ActionProxyReceiver::onReceive"
   },
   {
    "filename": "SaveImageInBackgroundTask.java",
    "diff": "@@ -166,6 +166,7 @@ class SaveImageInBackgroundTask extends AsyncTask<String, Void, Void> {\n \n             mImageData.uri = uri;\n             mImageData.smartActions = smartActions;\n+            mImageData.viewTransition = createViewAction(mContext, mContext.getResources(), uri);\n             mImageData.shareTransition = createShareAction(mContext, mContext.getResources(), uri);\n             mImageData.editTransition = createEditAction(mContext, mContext.getResources(), uri);\n             mImageData.deleteAction = createDeleteAction(mContext, mContext.getResources(), uri);\n@@ -221,6 +222,51 @@ class SaveImageInBackgroundTask extends AsyncTask<String, Void, Void> {\n         mParams.clearImage();\n     }\n \n+    @VisibleForTesting\n+    Supplier<ActionTransition> createViewAction(Context context, Resources r, Uri uri) {\n+        return () -> {\n+            ActionTransition transition = mSharedElementTransition.get();\n+            // Note: the view, share and edit actions are proxied through ActionProxyReceiver in\n+            // order to do some common work like dismissing the keyguard and sending\n+            // closeSystemWindows\n+\n+            // Create an edit intent, if a specific package is provided as the editor, then\n+            // launch that directly\n+            Intent viewIntent = new Intent(Intent.ACTION_VIEW);\n+            viewIntent.setDataAndType(uri, \"image/png\");\n+            viewIntent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);\n+            viewIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);\n+\n+            PendingIntent pendingIntent = PendingIntent.getActivityAsUser(\n+                    context, 0, viewIntent, PendingIntent.FLAG_IMMUTABLE,\n+                    transition.bundle, UserHandle.CURRENT);\n+\n+            // Make sure pending intents for the system user are still unique across users\n+            // by setting the (otherwise unused) request code to the current user id.\n+            int requestCode = mContext.getUserId();\n+\n+            // Create a view action\n+            PendingIntent viewAction = PendingIntent.getBroadcastAsUser(context, requestCode,\n+                    new Intent(context, ActionProxyReceiver.class)\n+                            .putExtra(ScreenshotController.EXTRA_ACTION_INTENT, pendingIntent)\n+                            .putExtra(ScreenshotController.EXTRA_ID, mScreenshotId)\n+                            .putExtra(ScreenshotController.EXTRA_SMART_ACTIONS_ENABLED,\n+                                    mSmartActionsEnabled)\n+                            .putExtra(ScreenshotController.EXTRA_OVERRIDE_TRANSITION, true)\n+                            .setAction(Intent.ACTION_VIEW)\n+                            .addFlags(Intent.FLAG_RECEIVER_FOREGROUND),\n+                    PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_IMMUTABLE,\n+                    UserHandle.SYSTEM);\n+            Notification.Action.Builder editActionBuilder = new Notification.Action.Builder(\n+                    Icon.createWithResource(r, com.android.internal.R.drawable.ic_screenshot),\n+                    r.getString(com.android.internal.R.string.global_action_screenshot),\n+                    viewAction);\n+\n+            transition.action = editActionBuilder.build();\n+            return transition;\n+        };\n+    }\n+\n     /**\n      * Assumes that the action intent is sent immediately after being supplied.\n      */\n",
    "added_lines": 46,
    "deleted_lines": 0,
    "changed_methods": "SaveImageInBackgroundTask::createViewAction, SaveImageInBackgroundTask::doInBackground"
   },
   {
    "filename": "ScreenshotController.java",
    "diff": "@@ -166,6 +166,7 @@ public class ScreenshotController {\n      */\n     static class SavedImageData {\n         public Uri uri;\n+        public Supplier<ActionTransition> viewTransition;\n         public Supplier<ActionTransition> shareTransition;\n         public Supplier<ActionTransition> editTransition;\n         public Notification.Action deleteAction;\n@@ -229,6 +230,7 @@ public class ScreenshotController {\n     // ScreenshotNotificationSmartActionsProvider.\n     static final String EXTRA_ACTION_TYPE = \"android:screenshot_action_type\";\n     static final String EXTRA_ID = \"android:screenshot_id\";\n+    static final String ACTION_TYPE_VIEW = \"View\";\n     static final String ACTION_TYPE_DELETE = \"Delete\";\n     static final String ACTION_TYPE_SHARE = \"Share\";\n     static final String ACTION_TYPE_EDIT = \"Edit\";\n",
    "added_lines": 2,
    "deleted_lines": 0,
    "changed_methods": ""
   },
   {
    "filename": "ScreenshotView.java",
    "diff": "@@ -722,7 +722,7 @@ public class ScreenshotView extends FrameLayout implements\n         mScreenshotPreview.setOnClickListener(v -> {\n             mUiEventLogger.log(ScreenshotEvent.SCREENSHOT_PREVIEW_TAPPED, 0, mPackageName);\n             startSharedTransition(\n-                    imageData.editTransition.get());\n+                    imageData.viewTransition.get());\n         });\n         if (mQuickShareChip != null) {\n             mQuickShareChip.setPendingIntent(imageData.quickShareAction.actionIntent,\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "ScreenshotView::setChipIntents"
   },
   {
    "filename": "ScreenshotNotificationSmartActionsTest.java",
    "diff": "@@ -169,6 +169,34 @@ public class ScreenshotNotificationSmartActionsTest extends SysuiTestCase {\n         assertEquals(smartActions.size(), 0);\n     }\n \n+    // Tests for view action extras\n+    @Test\n+    public void testViewActionExtras() {\n+        if (Looper.myLooper() == null) {\n+            Looper.prepare();\n+        }\n+\n+        ScreenshotController.SaveImageInBackgroundData\n+                data = new ScreenshotController.SaveImageInBackgroundData();\n+        data.image = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);\n+        data.finisher = null;\n+        data.mActionsReadyListener = null;\n+        SaveImageInBackgroundTask task =\n+                new SaveImageInBackgroundTask(mContext, null, mScreenshotSmartActions, data,\n+                        ActionTransition::new);\n+\n+        Notification.Action viewAction = task.createViewAction(mContext, mContext.getResources(),\n+                Uri.parse(\"Screenshot_123.png\")).get().action;\n+\n+        Intent intent = viewAction.actionIntent.getIntent();\n+        assertNotNull(intent);\n+        Bundle bundle = intent.getExtras();\n+        assertTrue(bundle.containsKey(ScreenshotController.EXTRA_ID));\n+        assertTrue(bundle.containsKey(ScreenshotController.EXTRA_SMART_ACTIONS_ENABLED));\n+        assertEquals(ScreenshotController.ACTION_TYPE_VIEW, viewAction.title);\n+        assertEquals(Intent.ACTION_VIEW, intent.getAction());\n+    }\n+\n     // Tests for share action extras\n     @Test\n     public void testShareActionExtras() {\n",
    "added_lines": 28,
    "deleted_lines": 0,
    "changed_methods": "ScreenshotNotificationSmartActionsTest::testViewActionExtras"
   }
  ]
 },
 {
  "hash": "92ebedf7b4cf1b3fe3f6bd0db1f8cecc2425f012",
  "commit": "SystemUI: screenshot: open the screenshot instead of edit\n\nOpen the taken screenshot in gallery application when clicking on the\npreview. There is a seperate edit button, so the preview imageview\nshould open gallery instead.\n\nTest: atest com.android.systemui.screenshot.ScreenshotNotificationSmartActionsTest\nChange-Id: I8f882ddd0da47ca50acc37d25ee0866ce5698e4f",
  "files": [
   {
    "filename": "ActionProxyReceiver.java",
    "diff": "@@ -20,6 +20,7 @@ import static android.view.Display.DEFAULT_DISPLAY;\n \n import static com.android.systemui.screenshot.ScreenshotController.ACTION_TYPE_EDIT;\n import static com.android.systemui.screenshot.ScreenshotController.ACTION_TYPE_SHARE;\n+import static com.android.systemui.screenshot.ScreenshotController.ACTION_TYPE_VIEW;\n import static com.android.systemui.screenshot.ScreenshotController.EXTRA_ACTION_INTENT;\n import static com.android.systemui.screenshot.ScreenshotController.EXTRA_DISALLOW_ENTER_PIP;\n import static com.android.systemui.screenshot.ScreenshotController.EXTRA_ID;\n@@ -98,9 +99,15 @@ public class ActionProxyReceiver extends BroadcastReceiver {\n         }\n \n         if (intent.getBooleanExtra(EXTRA_SMART_ACTIONS_ENABLED, false)) {\n-            String actionType = Intent.ACTION_EDIT.equals(intent.getAction())\n-                    ? ACTION_TYPE_EDIT\n-                    : ACTION_TYPE_SHARE;\n+            String action = intent.getAction();\n+            String actionType;\n+            if (Intent.ACTION_VIEW.equals(action)) {\n+                actionType = ACTION_TYPE_VIEW;\n+            } else if (Intent.ACTION_EDIT.equals(action)) {\n+                actionType = ACTION_TYPE_EDIT;\n+            } else {\n+                actionType = ACTION_TYPE_SHARE;\n+            }\n             mScreenshotSmartActions.notifyScreenshotAction(\n                     context, intent.getStringExtra(EXTRA_ID), actionType, false, null);\n         }\n",
    "added_lines": 10,
    "deleted_lines": 3,
    "changed_methods": "ActionProxyReceiver::onReceive"
   },
   {
    "filename": "SaveImageInBackgroundTask.java",
    "diff": "@@ -166,6 +166,7 @@ class SaveImageInBackgroundTask extends AsyncTask<String, Void, Void> {\n \n             mImageData.uri = uri;\n             mImageData.smartActions = smartActions;\n+            mImageData.viewTransition = createViewAction(mContext, mContext.getResources(), uri);\n             mImageData.shareTransition = createShareAction(mContext, mContext.getResources(), uri);\n             mImageData.editTransition = createEditAction(mContext, mContext.getResources(), uri);\n             mImageData.deleteAction = createDeleteAction(mContext, mContext.getResources(), uri);\n@@ -221,6 +222,51 @@ class SaveImageInBackgroundTask extends AsyncTask<String, Void, Void> {\n         mParams.clearImage();\n     }\n \n+    @VisibleForTesting\n+    Supplier<ActionTransition> createViewAction(Context context, Resources r, Uri uri) {\n+        return () -> {\n+            ActionTransition transition = mSharedElementTransition.get();\n+            // Note: the view, share and edit actions are proxied through ActionProxyReceiver in\n+            // order to do some common work like dismissing the keyguard and sending\n+            // closeSystemWindows\n+\n+            // Create an edit intent, if a specific package is provided as the editor, then\n+            // launch that directly\n+            Intent viewIntent = new Intent(Intent.ACTION_VIEW);\n+            viewIntent.setDataAndType(uri, \"image/png\");\n+            viewIntent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);\n+            viewIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);\n+\n+            PendingIntent pendingIntent = PendingIntent.getActivityAsUser(\n+                    context, 0, viewIntent, PendingIntent.FLAG_IMMUTABLE,\n+                    transition.bundle, UserHandle.CURRENT);\n+\n+            // Make sure pending intents for the system user are still unique across users\n+            // by setting the (otherwise unused) request code to the current user id.\n+            int requestCode = mContext.getUserId();\n+\n+            // Create a view action\n+            PendingIntent viewAction = PendingIntent.getBroadcastAsUser(context, requestCode,\n+                    new Intent(context, ActionProxyReceiver.class)\n+                            .putExtra(ScreenshotController.EXTRA_ACTION_INTENT, pendingIntent)\n+                            .putExtra(ScreenshotController.EXTRA_ID, mScreenshotId)\n+                            .putExtra(ScreenshotController.EXTRA_SMART_ACTIONS_ENABLED,\n+                                    mSmartActionsEnabled)\n+                            .putExtra(ScreenshotController.EXTRA_OVERRIDE_TRANSITION, true)\n+                            .setAction(Intent.ACTION_VIEW)\n+                            .addFlags(Intent.FLAG_RECEIVER_FOREGROUND),\n+                    PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_IMMUTABLE,\n+                    UserHandle.SYSTEM);\n+            Notification.Action.Builder editActionBuilder = new Notification.Action.Builder(\n+                    Icon.createWithResource(r, com.android.internal.R.drawable.ic_screenshot),\n+                    r.getString(com.android.internal.R.string.global_action_screenshot),\n+                    viewAction);\n+\n+            transition.action = editActionBuilder.build();\n+            return transition;\n+        };\n+    }\n+\n     /**\n      * Assumes that the action intent is sent immediately after being supplied.\n      */\n",
    "added_lines": 46,
    "deleted_lines": 0,
    "changed_methods": "SaveImageInBackgroundTask::createViewAction, SaveImageInBackgroundTask::doInBackground"
   },
   {
    "filename": "ScreenshotController.java",
    "diff": "@@ -166,6 +166,7 @@ public class ScreenshotController {\n      */\n     static class SavedImageData {\n         public Uri uri;\n+        public Supplier<ActionTransition> viewTransition;\n         public Supplier<ActionTransition> shareTransition;\n         public Supplier<ActionTransition> editTransition;\n         public Notification.Action deleteAction;\n@@ -229,6 +230,7 @@ public class ScreenshotController {\n     // ScreenshotNotificationSmartActionsProvider.\n     static final String EXTRA_ACTION_TYPE = \"android:screenshot_action_type\";\n     static final String EXTRA_ID = \"android:screenshot_id\";\n+    static final String ACTION_TYPE_VIEW = \"View\";\n     static final String ACTION_TYPE_DELETE = \"Delete\";\n     static final String ACTION_TYPE_SHARE = \"Share\";\n     static final String ACTION_TYPE_EDIT = \"Edit\";\n",
    "added_lines": 2,
    "deleted_lines": 0,
    "changed_methods": ""
   },
   {
    "filename": "ScreenshotView.java",
    "diff": "@@ -722,7 +722,7 @@ public class ScreenshotView extends FrameLayout implements\n         mScreenshotPreview.setOnClickListener(v -> {\n             mUiEventLogger.log(ScreenshotEvent.SCREENSHOT_PREVIEW_TAPPED, 0, mPackageName);\n             startSharedTransition(\n-                    imageData.editTransition.get());\n+                    imageData.viewTransition.get());\n         });\n         if (mQuickShareChip != null) {\n             mQuickShareChip.setPendingIntent(imageData.quickShareAction.actionIntent,\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "ScreenshotView::setChipIntents"
   },
   {
    "filename": "ScreenshotNotificationSmartActionsTest.java",
    "diff": "@@ -169,6 +169,34 @@ public class ScreenshotNotificationSmartActionsTest extends SysuiTestCase {\n         assertEquals(smartActions.size(), 0);\n     }\n \n+    // Tests for view action extras\n+    @Test\n+    public void testViewActionExtras() {\n+        if (Looper.myLooper() == null) {\n+            Looper.prepare();\n+        }\n+\n+        ScreenshotController.SaveImageInBackgroundData\n+                data = new ScreenshotController.SaveImageInBackgroundData();\n+        data.image = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);\n+        data.finisher = null;\n+        data.mActionsReadyListener = null;\n+        SaveImageInBackgroundTask task =\n+                new SaveImageInBackgroundTask(mContext, null, mScreenshotSmartActions, data,\n+                        ActionTransition::new);\n+\n+        Notification.Action viewAction = task.createViewAction(mContext, mContext.getResources(),\n+                Uri.parse(\"Screenshot_123.png\")).get().action;\n+\n+        Intent intent = viewAction.actionIntent.getIntent();\n+        assertNotNull(intent);\n+        Bundle bundle = intent.getExtras();\n+        assertTrue(bundle.containsKey(ScreenshotController.EXTRA_ID));\n+        assertTrue(bundle.containsKey(ScreenshotController.EXTRA_SMART_ACTIONS_ENABLED));\n+        assertEquals(ScreenshotController.ACTION_TYPE_VIEW, viewAction.title);\n+        assertEquals(Intent.ACTION_VIEW, intent.getAction());\n+    }\n+\n     // Tests for share action extras\n     @Test\n     public void testShareActionExtras() {\n",
    "added_lines": 28,
    "deleted_lines": 0,
    "changed_methods": "ScreenshotNotificationSmartActionsTest::testViewActionExtras"
   }
  ]
 },
 {
  "hash": "92ebedf7b4cf1b3fe3f6bd0db1f8cecc2425f012",
  "commit": "SystemUI: screenshot: open the screenshot instead of edit\n\nOpen the taken screenshot in gallery application when clicking on the\npreview. There is a seperate edit button, so the preview imageview\nshould open gallery instead.\n\nTest: atest com.android.systemui.screenshot.ScreenshotNotificationSmartActionsTest\nChange-Id: I8f882ddd0da47ca50acc37d25ee0866ce5698e4f",
  "files": [
   {
    "filename": "ActionProxyReceiver.java",
    "diff": "@@ -20,6 +20,7 @@ import static android.view.Display.DEFAULT_DISPLAY;\n \n import static com.android.systemui.screenshot.ScreenshotController.ACTION_TYPE_EDIT;\n import static com.android.systemui.screenshot.ScreenshotController.ACTION_TYPE_SHARE;\n+import static com.android.systemui.screenshot.ScreenshotController.ACTION_TYPE_VIEW;\n import static com.android.systemui.screenshot.ScreenshotController.EXTRA_ACTION_INTENT;\n import static com.android.systemui.screenshot.ScreenshotController.EXTRA_DISALLOW_ENTER_PIP;\n import static com.android.systemui.screenshot.ScreenshotController.EXTRA_ID;\n@@ -98,9 +99,15 @@ public class ActionProxyReceiver extends BroadcastReceiver {\n         }\n \n         if (intent.getBooleanExtra(EXTRA_SMART_ACTIONS_ENABLED, false)) {\n-            String actionType = Intent.ACTION_EDIT.equals(intent.getAction())\n-                    ? ACTION_TYPE_EDIT\n-                    : ACTION_TYPE_SHARE;\n+            String action = intent.getAction();\n+            String actionType;\n+            if (Intent.ACTION_VIEW.equals(action)) {\n+                actionType = ACTION_TYPE_VIEW;\n+            } else if (Intent.ACTION_EDIT.equals(action)) {\n+                actionType = ACTION_TYPE_EDIT;\n+            } else {\n+                actionType = ACTION_TYPE_SHARE;\n+            }\n             mScreenshotSmartActions.notifyScreenshotAction(\n                     context, intent.getStringExtra(EXTRA_ID), actionType, false, null);\n         }\n",
    "added_lines": 10,
    "deleted_lines": 3,
    "changed_methods": "ActionProxyReceiver::onReceive"
   },
   {
    "filename": "SaveImageInBackgroundTask.java",
    "diff": "@@ -166,6 +166,7 @@ class SaveImageInBackgroundTask extends AsyncTask<String, Void, Void> {\n \n             mImageData.uri = uri;\n             mImageData.smartActions = smartActions;\n+            mImageData.viewTransition = createViewAction(mContext, mContext.getResources(), uri);\n             mImageData.shareTransition = createShareAction(mContext, mContext.getResources(), uri);\n             mImageData.editTransition = createEditAction(mContext, mContext.getResources(), uri);\n             mImageData.deleteAction = createDeleteAction(mContext, mContext.getResources(), uri);\n@@ -221,6 +222,51 @@ class SaveImageInBackgroundTask extends AsyncTask<String, Void, Void> {\n         mParams.clearImage();\n     }\n \n+    @VisibleForTesting\n+    Supplier<ActionTransition> createViewAction(Context context, Resources r, Uri uri) {\n+        return () -> {\n+            ActionTransition transition = mSharedElementTransition.get();\n+            // Note: the view, share and edit actions are proxied through ActionProxyReceiver in\n+            // order to do some common work like dismissing the keyguard and sending\n+            // closeSystemWindows\n+\n+            // Create an edit intent, if a specific package is provided as the editor, then\n+            // launch that directly\n+            Intent viewIntent = new Intent(Intent.ACTION_VIEW);\n+            viewIntent.setDataAndType(uri, \"image/png\");\n+            viewIntent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);\n+            viewIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);\n+\n+            PendingIntent pendingIntent = PendingIntent.getActivityAsUser(\n+                    context, 0, viewIntent, PendingIntent.FLAG_IMMUTABLE,\n+                    transition.bundle, UserHandle.CURRENT);\n+\n+            // Make sure pending intents for the system user are still unique across users\n+            // by setting the (otherwise unused) request code to the current user id.\n+            int requestCode = mContext.getUserId();\n+\n+            // Create a view action\n+            PendingIntent viewAction = PendingIntent.getBroadcastAsUser(context, requestCode,\n+                    new Intent(context, ActionProxyReceiver.class)\n+                            .putExtra(ScreenshotController.EXTRA_ACTION_INTENT, pendingIntent)\n+                            .putExtra(ScreenshotController.EXTRA_ID, mScreenshotId)\n+                            .putExtra(ScreenshotController.EXTRA_SMART_ACTIONS_ENABLED,\n+                                    mSmartActionsEnabled)\n+                            .putExtra(ScreenshotController.EXTRA_OVERRIDE_TRANSITION, true)\n+                            .setAction(Intent.ACTION_VIEW)\n+                            .addFlags(Intent.FLAG_RECEIVER_FOREGROUND),\n+                    PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_IMMUTABLE,\n+                    UserHandle.SYSTEM);\n+            Notification.Action.Builder editActionBuilder = new Notification.Action.Builder(\n+                    Icon.createWithResource(r, com.android.internal.R.drawable.ic_screenshot),\n+                    r.getString(com.android.internal.R.string.global_action_screenshot),\n+                    viewAction);\n+\n+            transition.action = editActionBuilder.build();\n+            return transition;\n+        };\n+    }\n+\n     /**\n      * Assumes that the action intent is sent immediately after being supplied.\n      */\n",
    "added_lines": 46,
    "deleted_lines": 0,
    "changed_methods": "SaveImageInBackgroundTask::createViewAction, SaveImageInBackgroundTask::doInBackground"
   },
   {
    "filename": "ScreenshotController.java",
    "diff": "@@ -166,6 +166,7 @@ public class ScreenshotController {\n      */\n     static class SavedImageData {\n         public Uri uri;\n+        public Supplier<ActionTransition> viewTransition;\n         public Supplier<ActionTransition> shareTransition;\n         public Supplier<ActionTransition> editTransition;\n         public Notification.Action deleteAction;\n@@ -229,6 +230,7 @@ public class ScreenshotController {\n     // ScreenshotNotificationSmartActionsProvider.\n     static final String EXTRA_ACTION_TYPE = \"android:screenshot_action_type\";\n     static final String EXTRA_ID = \"android:screenshot_id\";\n+    static final String ACTION_TYPE_VIEW = \"View\";\n     static final String ACTION_TYPE_DELETE = \"Delete\";\n     static final String ACTION_TYPE_SHARE = \"Share\";\n     static final String ACTION_TYPE_EDIT = \"Edit\";\n",
    "added_lines": 2,
    "deleted_lines": 0,
    "changed_methods": ""
   },
   {
    "filename": "ScreenshotView.java",
    "diff": "@@ -722,7 +722,7 @@ public class ScreenshotView extends FrameLayout implements\n         mScreenshotPreview.setOnClickListener(v -> {\n             mUiEventLogger.log(ScreenshotEvent.SCREENSHOT_PREVIEW_TAPPED, 0, mPackageName);\n             startSharedTransition(\n-                    imageData.editTransition.get());\n+                    imageData.viewTransition.get());\n         });\n         if (mQuickShareChip != null) {\n             mQuickShareChip.setPendingIntent(imageData.quickShareAction.actionIntent,\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "ScreenshotView::setChipIntents"
   },
   {
    "filename": "ScreenshotNotificationSmartActionsTest.java",
    "diff": "@@ -169,6 +169,34 @@ public class ScreenshotNotificationSmartActionsTest extends SysuiTestCase {\n         assertEquals(smartActions.size(), 0);\n     }\n \n+    // Tests for view action extras\n+    @Test\n+    public void testViewActionExtras() {\n+        if (Looper.myLooper() == null) {\n+            Looper.prepare();\n+        }\n+\n+        ScreenshotController.SaveImageInBackgroundData\n+                data = new ScreenshotController.SaveImageInBackgroundData();\n+        data.image = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);\n+        data.finisher = null;\n+        data.mActionsReadyListener = null;\n+        SaveImageInBackgroundTask task =\n+                new SaveImageInBackgroundTask(mContext, null, mScreenshotSmartActions, data,\n+                        ActionTransition::new);\n+\n+        Notification.Action viewAction = task.createViewAction(mContext, mContext.getResources(),\n+                Uri.parse(\"Screenshot_123.png\")).get().action;\n+\n+        Intent intent = viewAction.actionIntent.getIntent();\n+        assertNotNull(intent);\n+        Bundle bundle = intent.getExtras();\n+        assertTrue(bundle.containsKey(ScreenshotController.EXTRA_ID));\n+        assertTrue(bundle.containsKey(ScreenshotController.EXTRA_SMART_ACTIONS_ENABLED));\n+        assertEquals(ScreenshotController.ACTION_TYPE_VIEW, viewAction.title);\n+        assertEquals(Intent.ACTION_VIEW, intent.getAction());\n+    }\n+\n     // Tests for share action extras\n     @Test\n     public void testShareActionExtras() {\n",
    "added_lines": 28,
    "deleted_lines": 0,
    "changed_methods": "ScreenshotNotificationSmartActionsTest::testViewActionExtras"
   }
  ]
 },
 {
  "hash": "92ebedf7b4cf1b3fe3f6bd0db1f8cecc2425f012",
  "commit": "SystemUI: screenshot: open the screenshot instead of edit\n\nOpen the taken screenshot in gallery application when clicking on the\npreview. There is a seperate edit button, so the preview imageview\nshould open gallery instead.\n\nTest: atest com.android.systemui.screenshot.ScreenshotNotificationSmartActionsTest\nChange-Id: I8f882ddd0da47ca50acc37d25ee0866ce5698e4f",
  "files": [
   {
    "filename": "ActionProxyReceiver.java",
    "diff": "@@ -20,6 +20,7 @@ import static android.view.Display.DEFAULT_DISPLAY;\n \n import static com.android.systemui.screenshot.ScreenshotController.ACTION_TYPE_EDIT;\n import static com.android.systemui.screenshot.ScreenshotController.ACTION_TYPE_SHARE;\n+import static com.android.systemui.screenshot.ScreenshotController.ACTION_TYPE_VIEW;\n import static com.android.systemui.screenshot.ScreenshotController.EXTRA_ACTION_INTENT;\n import static com.android.systemui.screenshot.ScreenshotController.EXTRA_DISALLOW_ENTER_PIP;\n import static com.android.systemui.screenshot.ScreenshotController.EXTRA_ID;\n@@ -98,9 +99,15 @@ public class ActionProxyReceiver extends BroadcastReceiver {\n         }\n \n         if (intent.getBooleanExtra(EXTRA_SMART_ACTIONS_ENABLED, false)) {\n-            String actionType = Intent.ACTION_EDIT.equals(intent.getAction())\n-                    ? ACTION_TYPE_EDIT\n-                    : ACTION_TYPE_SHARE;\n+            String action = intent.getAction();\n+            String actionType;\n+            if (Intent.ACTION_VIEW.equals(action)) {\n+                actionType = ACTION_TYPE_VIEW;\n+            } else if (Intent.ACTION_EDIT.equals(action)) {\n+                actionType = ACTION_TYPE_EDIT;\n+            } else {\n+                actionType = ACTION_TYPE_SHARE;\n+            }\n             mScreenshotSmartActions.notifyScreenshotAction(\n                     context, intent.getStringExtra(EXTRA_ID), actionType, false, null);\n         }\n",
    "added_lines": 10,
    "deleted_lines": 3,
    "changed_methods": "ActionProxyReceiver::onReceive"
   },
   {
    "filename": "SaveImageInBackgroundTask.java",
    "diff": "@@ -166,6 +166,7 @@ class SaveImageInBackgroundTask extends AsyncTask<String, Void, Void> {\n \n             mImageData.uri = uri;\n             mImageData.smartActions = smartActions;\n+            mImageData.viewTransition = createViewAction(mContext, mContext.getResources(), uri);\n             mImageData.shareTransition = createShareAction(mContext, mContext.getResources(), uri);\n             mImageData.editTransition = createEditAction(mContext, mContext.getResources(), uri);\n             mImageData.deleteAction = createDeleteAction(mContext, mContext.getResources(), uri);\n@@ -221,6 +222,51 @@ class SaveImageInBackgroundTask extends AsyncTask<String, Void, Void> {\n         mParams.clearImage();\n     }\n \n+    @VisibleForTesting\n+    Supplier<ActionTransition> createViewAction(Context context, Resources r, Uri uri) {\n+        return () -> {\n+            ActionTransition transition = mSharedElementTransition.get();\n+            // Note: the view, share and edit actions are proxied through ActionProxyReceiver in\n+            // order to do some common work like dismissing the keyguard and sending\n+            // closeSystemWindows\n+\n+            // Create an edit intent, if a specific package is provided as the editor, then\n+            // launch that directly\n+            Intent viewIntent = new Intent(Intent.ACTION_VIEW);\n+            viewIntent.setDataAndType(uri, \"image/png\");\n+            viewIntent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);\n+            viewIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);\n+\n+            PendingIntent pendingIntent = PendingIntent.getActivityAsUser(\n+                    context, 0, viewIntent, PendingIntent.FLAG_IMMUTABLE,\n+                    transition.bundle, UserHandle.CURRENT);\n+\n+            // Make sure pending intents for the system user are still unique across users\n+            // by setting the (otherwise unused) request code to the current user id.\n+            int requestCode = mContext.getUserId();\n+\n+            // Create a view action\n+            PendingIntent viewAction = PendingIntent.getBroadcastAsUser(context, requestCode,\n+                    new Intent(context, ActionProxyReceiver.class)\n+                            .putExtra(ScreenshotController.EXTRA_ACTION_INTENT, pendingIntent)\n+                            .putExtra(ScreenshotController.EXTRA_ID, mScreenshotId)\n+                            .putExtra(ScreenshotController.EXTRA_SMART_ACTIONS_ENABLED,\n+                                    mSmartActionsEnabled)\n+                            .putExtra(ScreenshotController.EXTRA_OVERRIDE_TRANSITION, true)\n+                            .setAction(Intent.ACTION_VIEW)\n+                            .addFlags(Intent.FLAG_RECEIVER_FOREGROUND),\n+                    PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_IMMUTABLE,\n+                    UserHandle.SYSTEM);\n+            Notification.Action.Builder editActionBuilder = new Notification.Action.Builder(\n+                    Icon.createWithResource(r, com.android.internal.R.drawable.ic_screenshot),\n+                    r.getString(com.android.internal.R.string.global_action_screenshot),\n+                    viewAction);\n+\n+            transition.action = editActionBuilder.build();\n+            return transition;\n+        };\n+    }\n+\n     /**\n      * Assumes that the action intent is sent immediately after being supplied.\n      */\n",
    "added_lines": 46,
    "deleted_lines": 0,
    "changed_methods": "SaveImageInBackgroundTask::createViewAction, SaveImageInBackgroundTask::doInBackground"
   },
   {
    "filename": "ScreenshotController.java",
    "diff": "@@ -166,6 +166,7 @@ public class ScreenshotController {\n      */\n     static class SavedImageData {\n         public Uri uri;\n+        public Supplier<ActionTransition> viewTransition;\n         public Supplier<ActionTransition> shareTransition;\n         public Supplier<ActionTransition> editTransition;\n         public Notification.Action deleteAction;\n@@ -229,6 +230,7 @@ public class ScreenshotController {\n     // ScreenshotNotificationSmartActionsProvider.\n     static final String EXTRA_ACTION_TYPE = \"android:screenshot_action_type\";\n     static final String EXTRA_ID = \"android:screenshot_id\";\n+    static final String ACTION_TYPE_VIEW = \"View\";\n     static final String ACTION_TYPE_DELETE = \"Delete\";\n     static final String ACTION_TYPE_SHARE = \"Share\";\n     static final String ACTION_TYPE_EDIT = \"Edit\";\n",
    "added_lines": 2,
    "deleted_lines": 0,
    "changed_methods": ""
   },
   {
    "filename": "ScreenshotView.java",
    "diff": "@@ -722,7 +722,7 @@ public class ScreenshotView extends FrameLayout implements\n         mScreenshotPreview.setOnClickListener(v -> {\n             mUiEventLogger.log(ScreenshotEvent.SCREENSHOT_PREVIEW_TAPPED, 0, mPackageName);\n             startSharedTransition(\n-                    imageData.editTransition.get());\n+                    imageData.viewTransition.get());\n         });\n         if (mQuickShareChip != null) {\n             mQuickShareChip.setPendingIntent(imageData.quickShareAction.actionIntent,\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "ScreenshotView::setChipIntents"
   },
   {
    "filename": "ScreenshotNotificationSmartActionsTest.java",
    "diff": "@@ -169,6 +169,34 @@ public class ScreenshotNotificationSmartActionsTest extends SysuiTestCase {\n         assertEquals(smartActions.size(), 0);\n     }\n \n+    // Tests for view action extras\n+    @Test\n+    public void testViewActionExtras() {\n+        if (Looper.myLooper() == null) {\n+            Looper.prepare();\n+        }\n+\n+        ScreenshotController.SaveImageInBackgroundData\n+                data = new ScreenshotController.SaveImageInBackgroundData();\n+        data.image = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);\n+        data.finisher = null;\n+        data.mActionsReadyListener = null;\n+        SaveImageInBackgroundTask task =\n+                new SaveImageInBackgroundTask(mContext, null, mScreenshotSmartActions, data,\n+                        ActionTransition::new);\n+\n+        Notification.Action viewAction = task.createViewAction(mContext, mContext.getResources(),\n+                Uri.parse(\"Screenshot_123.png\")).get().action;\n+\n+        Intent intent = viewAction.actionIntent.getIntent();\n+        assertNotNull(intent);\n+        Bundle bundle = intent.getExtras();\n+        assertTrue(bundle.containsKey(ScreenshotController.EXTRA_ID));\n+        assertTrue(bundle.containsKey(ScreenshotController.EXTRA_SMART_ACTIONS_ENABLED));\n+        assertEquals(ScreenshotController.ACTION_TYPE_VIEW, viewAction.title);\n+        assertEquals(Intent.ACTION_VIEW, intent.getAction());\n+    }\n+\n     // Tests for share action extras\n     @Test\n     public void testShareActionExtras() {\n",
    "added_lines": 28,
    "deleted_lines": 0,
    "changed_methods": "ScreenshotNotificationSmartActionsTest::testViewActionExtras"
   }
  ]
 },
 {
  "hash": "f85097863810e3bc65597c29689932eb707d65e8",
  "commit": "DO NOT MERGE Suppress notifications when device enter lockdown\n\nThis CL makes the following modifcations:\n1. Add LockPatternUtils.StrongAuthTracker to monitor\nthe lockdown mode status of the phone.\n2. Call mListeners.notifyRemovedLocked with all the\nnotifications in the mNotificationList when entering\nthe lockdown mode.\n3. Call mListeners.notifyPostedLocked with all the\nnotifications in the mNotificationList when exiting\nthe lockdown mode.\n4. Dismiss the function calls of notifyPostedLocked,\nnotifyRemovedLocked, and notifyRankingUpdateLocked\nduring the lockdown mode.\n\nThe CL also adds corresponding tests.\n\nBug: 173721373\nTest: atest NotificationManagerServiceTest\nTest: atest NotificationListenersTest\nTest: manually verify the paired device cannot receive\nnotifications when the host phone is in lockdown mode.\nIgnore-AOSP-First: pending fix for a security issue.\n\nChange-Id: I7e83544863eeadf8272b6ff8a9bb8136d6466203\nMerged-In: I7e83544863eeadf8272b6ff8a9bb8136d6466203\n(cherry picked from commit 3cb6842a053e236cc98d7616ba4433c31ffda3ac)\n(cherry picked from commit b1099290b8eb939fcb707c817989dd24d0e7a3b5)\nMerged-In: I7e83544863eeadf8272b6ff8a9bb8136d6466203",
  "files": [
   {
    "filename": "NotificationManagerService.java",
    "diff": "@@ -249,6 +249,7 @@ import android.util.Log;\n import android.util.Pair;\n import android.util.Slog;\n import android.util.SparseArray;\n+import android.util.SparseBooleanArray;\n import android.util.StatsEvent;\n import android.util.TypedXmlPullParser;\n import android.util.TypedXmlSerializer;\n@@ -280,6 +281,7 @@ import com.android.internal.util.DumpUtils;\n import com.android.internal.util.Preconditions;\n import com.android.internal.util.XmlUtils;\n import com.android.internal.util.function.TriPredicate;\n+import com.android.internal.widget.LockPatternUtils;\n import com.android.server.DeviceIdleInternal;\n import com.android.server.EventLogTags;\n import com.android.server.IoThread;\n@@ -1904,6 +1906,54 @@ public class NotificationManagerService extends SystemService {\n     private SettingsObserver mSettingsObserver;\n     protected ZenModeHelper mZenModeHelper;\n \n+    protected class StrongAuthTracker extends LockPatternUtils.StrongAuthTracker {\n+\n+        SparseBooleanArray mUserInLockDownMode = new SparseBooleanArray();\n+        boolean mIsInLockDownMode = false;\n+\n+        StrongAuthTracker(Context context) {\n+            super(context);\n+        }\n+\n+        private boolean containsFlag(int haystack, int needle) {\n+            return (haystack & needle) != 0;\n+        }\n+\n+        public boolean isInLockDownMode() {\n+            return mIsInLockDownMode;\n+        }\n+\n+        @Override\n+        public synchronized void onStrongAuthRequiredChanged(int userId) {\n+            boolean userInLockDownModeNext = containsFlag(getStrongAuthForUser(userId),\n+                    STRONG_AUTH_REQUIRED_AFTER_USER_LOCKDOWN);\n+            mUserInLockDownMode.put(userId, userInLockDownModeNext);\n+            boolean isInLockDownModeNext = mUserInLockDownMode.indexOfValue(true) != -1;\n+\n+            if (mIsInLockDownMode == isInLockDownModeNext) {\n+                return;\n+            }\n+\n+            if (isInLockDownModeNext) {\n+                cancelNotificationsWhenEnterLockDownMode();\n+            }\n+\n+            // When the mIsInLockDownMode is true, both notifyPostedLocked and\n+            // notifyRemovedLocked will be dismissed. So we shall call\n+            // cancelNotificationsWhenEnterLockDownMode before we set mIsInLockDownMode\n+            // as true and call postNotificationsWhenExitLockDownMode after we set\n+            // mIsInLockDownMode as false.\n+            mIsInLockDownMode = isInLockDownModeNext;\n+\n+            if (!isInLockDownModeNext) {\n+                postNotificationsWhenExitLockDownMode();\n+            }\n+        }\n+    }\n+\n+    private LockPatternUtils mLockPatternUtils;\n+    private StrongAuthTracker mStrongAuthTracker;\n+\n     public NotificationManagerService(Context context) {\n         this(context,\n                 new NotificationRecordLoggerImpl(),\n@@ -1926,6 +1976,11 @@ public class NotificationManagerService extends SystemService {\n         mAudioManager = audioMananger;\n     }\n \n+    @VisibleForTesting\n+    void setStrongAuthTracker(StrongAuthTracker strongAuthTracker) {\n+        mStrongAuthTracker = strongAuthTracker;\n+    }\n+\n     @VisibleForTesting\n     void setKeyguardManager(KeyguardManager keyguardManager) {\n         mKeyguardManager = keyguardManager;\n@@ -2113,6 +2168,8 @@ public class NotificationManagerService extends SystemService {\n                 ServiceManager.getService(Context.PLATFORM_COMPAT_SERVICE));\n \n         mUiHandler = new Handler(UiThread.get().getLooper());\n+        mLockPatternUtils = new LockPatternUtils(getContext());\n+        mStrongAuthTracker = new StrongAuthTracker(getContext());\n         String[] extractorNames;\n         try {\n             extractorNames = resources.getStringArray(R.array.config_notificationSignalExtractors);\n@@ -2597,6 +2654,7 @@ public class NotificationManagerService extends SystemService {\n                 bubbsExtractor.setShortcutHelper(mShortcutHelper);\n             }\n             registerNotificationPreferencesPullers();\n+            mLockPatternUtils.registerStrongAuthTracker(mStrongAuthTracker);\n         } else if (phase == SystemService.PHASE_THIRD_PARTY_APPS_CAN_START) {\n             // This observer will force an update when observe is called, causing us to\n             // bind to listener services.\n@@ -9210,6 +9268,29 @@ public class NotificationManagerService extends SystemService {\n         }\n     }\n \n+    private void cancelNotificationsWhenEnterLockDownMode() {\n+        synchronized (mNotificationLock) {\n+            int numNotifications = mNotificationList.size();\n+            for (int i = 0; i < numNotifications; i++) {\n+                NotificationRecord rec = mNotificationList.get(i);\n+                mListeners.notifyRemovedLocked(rec, REASON_CANCEL_ALL,\n+                        rec.getStats());\n+            }\n+\n+        }\n+    }\n+\n+    private void postNotificationsWhenExitLockDownMode() {\n+        synchronized (mNotificationLock) {\n+            int numNotifications = mNotificationList.size();\n+            for (int i = 0; i < numNotifications; i++) {\n+                NotificationRecord rec = mNotificationList.get(i);\n+                mListeners.notifyPostedLocked(rec, rec);\n+            }\n+\n+        }\n+    }\n+\n     private void updateNotificationPulse() {\n         synchronized (mNotificationLock) {\n             updateLightsLocked();\n@@ -9445,6 +9526,10 @@ public class NotificationManagerService extends SystemService {\n                 rankings.toArray(new NotificationListenerService.Ranking[0]));\n     }\n \n+    boolean isInLockDownMode() {\n+        return mStrongAuthTracker.isInLockDownMode();\n+    }\n+\n     boolean hasCompanionDevice(ManagedServiceInfo info) {\n         if (mCompanionManager == null) {\n             mCompanionManager = getCompanionManager();\n@@ -10496,8 +10581,12 @@ public class NotificationManagerService extends SystemService {\n          *                           targetting <= O_MR1\n          */\n         @GuardedBy(\"mNotificationLock\")\n-        private void notifyPostedLocked(NotificationRecord r, NotificationRecord old,\n+        void notifyPostedLocked(NotificationRecord r, NotificationRecord old,\n                 boolean notifyAllListeners) {\n+            if (isInLockDownMode()) {\n+                return;\n+            }\n+\n             try {\n                 // Lazily initialized snapshots of the notification.\n                 StatusBarNotification sbn = r.getSbn();\n@@ -10595,6 +10684,10 @@ public class NotificationManagerService extends SystemService {\n         @GuardedBy(\"mNotificationLock\")\n         public void notifyRemovedLocked(NotificationRecord r, int reason,\n                 NotificationStats notificationStats) {\n+            if (isInLockDownMode()) {\n+                return;\n+            }\n+\n             final StatusBarNotification sbn = r.getSbn();\n \n             // make a copy in case changes are made to the underlying Notification object\n@@ -10640,6 +10733,10 @@ public class NotificationManagerService extends SystemService {\n          */\n         @GuardedBy(\"mNotificationLock\")\n         public void notifyRankingUpdateLocked(List<NotificationRecord> changedHiddenNotifications) {\n+            if (isInLockDownMode()) {\n+                return;\n+            }\n+\n             boolean isHiddenRankingUpdate = changedHiddenNotifications != null\n                     && changedHiddenNotifications.size() > 0;\n             // TODO (b/73052211): if the ranking update changed the notification type,\n",
    "added_lines": 98,
    "deleted_lines": 1,
    "changed_methods": "NotificationManagerService::NotificationListeners::notifyRankingUpdateLocked, NotificationManagerService::init, NotificationManagerService::StrongAuthTracker::StrongAuthTracker, NotificationManagerService::StrongAuthTracker::containsFlag, NotificationManagerService::cancelNotificationsWhenEnterLockDownMode, NotificationManagerService::StrongAuthTracker::isInLockDownMode, NotificationManagerService::onBootPhase, NotificationManagerService::postNotificationsWhenExitLockDownMode, NotificationManagerService::StrongAuthTracker::onStrongAuthRequiredChanged, NotificationManagerService::setStrongAuthTracker, NotificationManagerService::isInLockDownMode, NotificationManagerService::NotificationListeners::notifyPostedLocked, NotificationManagerService::NotificationListeners::notifyRemovedLocked"
   },
   {
    "filename": "NotificationListenersTest.java",
    "diff": "@@ -27,12 +27,13 @@ import static com.google.common.truth.Truth.assertThat;\n import static junit.framework.Assert.assertFalse;\n import static junit.framework.Assert.assertTrue;\n \n-import static org.mockito.ArgumentMatchers.any;\n-import static org.mockito.ArgumentMatchers.anyInt;\n import static org.mockito.ArgumentMatchers.eq;\n import static org.mockito.ArgumentMatchers.nullable;\n+import static org.mockito.Mockito.atLeast;\n import static org.mockito.Mockito.doNothing;\n import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.reset;\n import static org.mockito.Mockito.spy;\n import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.when;\n@@ -47,10 +48,11 @@ import android.os.Bundle;\n import android.os.UserHandle;\n import android.service.notification.NotificationListenerFilter;\n import android.service.notification.NotificationListenerService;\n+import android.service.notification.NotificationStats;\n+import android.service.notification.StatusBarNotification;\n import android.testing.TestableContext;\n import android.util.ArraySet;\n import android.util.Pair;\n-import android.util.Slog;\n import android.util.TypedXmlPullParser;\n import android.util.TypedXmlSerializer;\n import android.util.Xml;\n@@ -61,11 +63,13 @@ import org.junit.Before;\n import org.junit.Test;\n import org.mockito.Mock;\n import org.mockito.MockitoAnnotations;\n+import org.mockito.internal.util.reflection.FieldSetter;\n \n import java.io.BufferedInputStream;\n import java.io.BufferedOutputStream;\n import java.io.ByteArrayInputStream;\n import java.io.ByteArrayOutputStream;\n+import java.util.List;\n \n public class NotificationListenersTest extends UiServiceTestCase {\n \n@@ -374,4 +378,66 @@ public class NotificationListenersTest extends UiServiceTestCase {\n         verify(mContext).sendBroadcastAsUser(\n                 any(), eq(UserHandle.of(userId)), nullable(String.class));\n     }\n+\n+    @Test\n+    public void testNotifyPostedLockedInLockdownMode() {\n+        NotificationRecord r = mock(NotificationRecord.class);\n+        NotificationRecord old = mock(NotificationRecord.class);\n+\n+        // before the lockdown mode\n+        when(mNm.isInLockDownMode()).thenReturn(false);\n+        mListeners.notifyPostedLocked(r, old, true);\n+        mListeners.notifyPostedLocked(r, old, false);\n+        verify(r, atLeast(2)).getSbn();\n+\n+        // in the lockdown mode\n+        reset(r);\n+        reset(old);\n+        when(mNm.isInLockDownMode()).thenReturn(true);\n+        mListeners.notifyPostedLocked(r, old, true);\n+        mListeners.notifyPostedLocked(r, old, false);\n+        verify(r, never()).getSbn();\n+    }\n+\n+    @Test\n+    public void testnotifyRankingUpdateLockedInLockdownMode() {\n+        List chn = mock(List.class);\n+\n+        // before the lockdown mode\n+        when(mNm.isInLockDownMode()).thenReturn(false);\n+        mListeners.notifyRankingUpdateLocked(chn);\n+        verify(chn, atLeast(1)).size();\n+\n+        // in the lockdown mode\n+        reset(chn);\n+        when(mNm.isInLockDownMode()).thenReturn(true);\n+        mListeners.notifyRankingUpdateLocked(chn);\n+        verify(chn, never()).size();\n+    }\n+\n+    @Test\n+    public void testNotifyRemovedLockedInLockdownMode() throws NoSuchFieldException {\n+        NotificationRecord r = mock(NotificationRecord.class);\n+        NotificationStats rs = mock(NotificationStats.class);\n+        StatusBarNotification sbn = mock(StatusBarNotification.class);\n+        FieldSetter.setField(mNm,\n+                NotificationManagerService.class.getDeclaredField(\"mHandler\"),\n+                mock(NotificationManagerService.WorkerHandler.class));\n+\n+        // before the lockdown mode\n+        when(mNm.isInLockDownMode()).thenReturn(false);\n+        when(r.getSbn()).thenReturn(sbn);\n+        mListeners.notifyRemovedLocked(r, 0, rs);\n+        mListeners.notifyRemovedLocked(r, 0, rs);\n+        verify(r, atLeast(2)).getSbn();\n+\n+        // in the lockdown mode\n+        reset(r);\n+        reset(rs);\n+        when(mNm.isInLockDownMode()).thenReturn(true);\n+        when(r.getSbn()).thenReturn(sbn);\n+        mListeners.notifyRemovedLocked(r, 0, rs);\n+        mListeners.notifyRemovedLocked(r, 0, rs);\n+        verify(r, never()).getSbn();\n+    }\n }\n",
    "added_lines": 69,
    "deleted_lines": 3,
    "changed_methods": "NotificationListenersTest::testnotifyRankingUpdateLockedInLockdownMode, NotificationListenersTest::testNotifyPostedLockedInLockdownMode, NotificationListenersTest::testNotifyRemovedLockedInLockdownMode"
   },
   {
    "filename": "NotificationManagerServiceTest.java",
    "diff": "@@ -58,10 +58,13 @@ import static android.service.notification.Adjustment.KEY_USER_SENTIMENT;\n import static android.service.notification.NotificationListenerService.FLAG_FILTER_TYPE_ALERTING;\n import static android.service.notification.NotificationListenerService.FLAG_FILTER_TYPE_CONVERSATIONS;\n import static android.service.notification.NotificationListenerService.FLAG_FILTER_TYPE_ONGOING;\n+import static android.service.notification.NotificationListenerService.REASON_CANCEL_ALL;\n import static android.service.notification.NotificationListenerService.Ranking.USER_SENTIMENT_NEGATIVE;\n import static android.service.notification.NotificationListenerService.Ranking.USER_SENTIMENT_NEUTRAL;\n import static android.view.WindowManager.LayoutParams.TYPE_TOAST;\n \n+import static com.android.internal.widget.LockPatternUtils.StrongAuthTracker.STRONG_AUTH_REQUIRED_AFTER_USER_LOCKDOWN;\n+\n import static com.google.common.truth.Truth.assertThat;\n \n import static junit.framework.Assert.assertEquals;\n@@ -223,7 +226,6 @@ import java.util.Arrays;\n import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n-import java.util.Set;\n import java.util.concurrent.CountDownLatch;\n import java.util.function.Consumer;\n \n@@ -409,8 +411,26 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n         interface NotificationAssistantAccessGrantedCallback {\n             void onGranted(ComponentName assistant, int userId, boolean granted, boolean userSet);\n         }\n+\n+        class StrongAuthTrackerFake extends NotificationManagerService.StrongAuthTracker {\n+            private int mGetStrongAuthForUserReturnValue = 0;\n+            StrongAuthTrackerFake(Context context) {\n+                super(context);\n+            }\n+\n+            public void setGetStrongAuthForUserReturnValue(int val) {\n+                mGetStrongAuthForUserReturnValue = val;\n+            }\n+\n+            @Override\n+            public int getStrongAuthForUser(int userId) {\n+                return mGetStrongAuthForUserReturnValue;\n+            }\n+        }\n     }\n \n+    TestableNotificationManagerService.StrongAuthTrackerFake mStrongAuthTracker;\n+\n     private class TestableToastCallback extends ITransientNotification.Stub {\n         @Override\n         public void show(IBinder windowToken) {\n@@ -530,6 +550,9 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n \n         mService.setAudioManager(mAudioManager);\n \n+        mStrongAuthTracker = mService.new StrongAuthTrackerFake(mContext);\n+        mService.setStrongAuthTracker(mStrongAuthTracker);\n+\n         mShortcutHelper = mService.getShortcutHelper();\n         mShortcutHelper.setLauncherApps(mLauncherApps);\n         mShortcutHelper.setShortcutServiceInternal(mShortcutServiceInternal);\n@@ -8354,4 +8377,44 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n             }\n         }\n     }\n+\n+    @Test\n+    public void testStrongAuthTracker_isInLockDownMode() {\n+        mStrongAuthTracker.setGetStrongAuthForUserReturnValue(\n+                STRONG_AUTH_REQUIRED_AFTER_USER_LOCKDOWN);\n+        mStrongAuthTracker.onStrongAuthRequiredChanged(mContext.getUserId());\n+        assertTrue(mStrongAuthTracker.isInLockDownMode());\n+        mStrongAuthTracker.setGetStrongAuthForUserReturnValue(0);\n+        mStrongAuthTracker.onStrongAuthRequiredChanged(mContext.getUserId());\n+        assertFalse(mStrongAuthTracker.isInLockDownMode());\n+    }\n+\n+    @Test\n+    public void testCancelAndPostNotificationsWhenEnterAndExitLockDownMode() {\n+        // post 2 notifications from 2 packages\n+        NotificationRecord pkgA = new NotificationRecord(mContext,\n+                generateSbn(\"a\", 1000, 9, 0), mTestNotificationChannel);\n+        mService.addNotification(pkgA);\n+        NotificationRecord pkgB = new NotificationRecord(mContext,\n+                generateSbn(\"b\", 1001, 9, 0), mTestNotificationChannel);\n+        mService.addNotification(pkgB);\n+\n+        // when entering the lockdown mode, cancel the 2 notifications.\n+        mStrongAuthTracker.setGetStrongAuthForUserReturnValue(\n+                STRONG_AUTH_REQUIRED_AFTER_USER_LOCKDOWN);\n+        mStrongAuthTracker.onStrongAuthRequiredChanged(mContext.getUserId());\n+        assertTrue(mStrongAuthTracker.isInLockDownMode());\n+\n+        // the notifyRemovedLocked function is called twice due to REASON_LOCKDOWN.\n+        ArgumentCaptor<Integer> captor = ArgumentCaptor.forClass(Integer.class);\n+        verify(mListeners, times(2)).notifyRemovedLocked(any(), captor.capture(), any());\n+        assertEquals(REASON_CANCEL_ALL, captor.getValue().intValue());\n+\n+        // exit lockdown mode.\n+        mStrongAuthTracker.setGetStrongAuthForUserReturnValue(0);\n+        mStrongAuthTracker.onStrongAuthRequiredChanged(mContext.getUserId());\n+\n+        // the notifyPostedLocked function is called twice.\n+        verify(mListeners, times(2)).notifyPostedLocked(any(), any());\n+    }\n }\n",
    "added_lines": 64,
    "deleted_lines": 1,
    "changed_methods": "NotificationManagerServiceTest::TestableNotificationManagerService::StrongAuthTrackerFake::StrongAuthTrackerFake, NotificationManagerServiceTest::testCancelAndPostNotificationsWhenEnterAndExitLockDownMode, NotificationManagerServiceTest::TestableNotificationManagerService::StrongAuthTrackerFake::setGetStrongAuthForUserReturnValue, NotificationManagerServiceTest::setUp, NotificationManagerServiceTest::testStrongAuthTracker_isInLockDownMode, NotificationManagerServiceTest::TestableNotificationManagerService::StrongAuthTrackerFake::getStrongAuthForUser"
   }
  ]
 },
 {
  "hash": "f85097863810e3bc65597c29689932eb707d65e8",
  "commit": "DO NOT MERGE Suppress notifications when device enter lockdown\n\nThis CL makes the following modifcations:\n1. Add LockPatternUtils.StrongAuthTracker to monitor\nthe lockdown mode status of the phone.\n2. Call mListeners.notifyRemovedLocked with all the\nnotifications in the mNotificationList when entering\nthe lockdown mode.\n3. Call mListeners.notifyPostedLocked with all the\nnotifications in the mNotificationList when exiting\nthe lockdown mode.\n4. Dismiss the function calls of notifyPostedLocked,\nnotifyRemovedLocked, and notifyRankingUpdateLocked\nduring the lockdown mode.\n\nThe CL also adds corresponding tests.\n\nBug: 173721373\nTest: atest NotificationManagerServiceTest\nTest: atest NotificationListenersTest\nTest: manually verify the paired device cannot receive\nnotifications when the host phone is in lockdown mode.\nIgnore-AOSP-First: pending fix for a security issue.\n\nChange-Id: I7e83544863eeadf8272b6ff8a9bb8136d6466203\nMerged-In: I7e83544863eeadf8272b6ff8a9bb8136d6466203\n(cherry picked from commit 3cb6842a053e236cc98d7616ba4433c31ffda3ac)\n(cherry picked from commit b1099290b8eb939fcb707c817989dd24d0e7a3b5)\nMerged-In: I7e83544863eeadf8272b6ff8a9bb8136d6466203",
  "files": [
   {
    "filename": "NotificationManagerService.java",
    "diff": "@@ -249,6 +249,7 @@ import android.util.Log;\n import android.util.Pair;\n import android.util.Slog;\n import android.util.SparseArray;\n+import android.util.SparseBooleanArray;\n import android.util.StatsEvent;\n import android.util.TypedXmlPullParser;\n import android.util.TypedXmlSerializer;\n@@ -280,6 +281,7 @@ import com.android.internal.util.DumpUtils;\n import com.android.internal.util.Preconditions;\n import com.android.internal.util.XmlUtils;\n import com.android.internal.util.function.TriPredicate;\n+import com.android.internal.widget.LockPatternUtils;\n import com.android.server.DeviceIdleInternal;\n import com.android.server.EventLogTags;\n import com.android.server.IoThread;\n@@ -1904,6 +1906,54 @@ public class NotificationManagerService extends SystemService {\n     private SettingsObserver mSettingsObserver;\n     protected ZenModeHelper mZenModeHelper;\n \n+    protected class StrongAuthTracker extends LockPatternUtils.StrongAuthTracker {\n+\n+        SparseBooleanArray mUserInLockDownMode = new SparseBooleanArray();\n+        boolean mIsInLockDownMode = false;\n+\n+        StrongAuthTracker(Context context) {\n+            super(context);\n+        }\n+\n+        private boolean containsFlag(int haystack, int needle) {\n+            return (haystack & needle) != 0;\n+        }\n+\n+        public boolean isInLockDownMode() {\n+            return mIsInLockDownMode;\n+        }\n+\n+        @Override\n+        public synchronized void onStrongAuthRequiredChanged(int userId) {\n+            boolean userInLockDownModeNext = containsFlag(getStrongAuthForUser(userId),\n+                    STRONG_AUTH_REQUIRED_AFTER_USER_LOCKDOWN);\n+            mUserInLockDownMode.put(userId, userInLockDownModeNext);\n+            boolean isInLockDownModeNext = mUserInLockDownMode.indexOfValue(true) != -1;\n+\n+            if (mIsInLockDownMode == isInLockDownModeNext) {\n+                return;\n+            }\n+\n+            if (isInLockDownModeNext) {\n+                cancelNotificationsWhenEnterLockDownMode();\n+            }\n+\n+            // When the mIsInLockDownMode is true, both notifyPostedLocked and\n+            // notifyRemovedLocked will be dismissed. So we shall call\n+            // cancelNotificationsWhenEnterLockDownMode before we set mIsInLockDownMode\n+            // as true and call postNotificationsWhenExitLockDownMode after we set\n+            // mIsInLockDownMode as false.\n+            mIsInLockDownMode = isInLockDownModeNext;\n+\n+            if (!isInLockDownModeNext) {\n+                postNotificationsWhenExitLockDownMode();\n+            }\n+        }\n+    }\n+\n+    private LockPatternUtils mLockPatternUtils;\n+    private StrongAuthTracker mStrongAuthTracker;\n+\n     public NotificationManagerService(Context context) {\n         this(context,\n                 new NotificationRecordLoggerImpl(),\n@@ -1926,6 +1976,11 @@ public class NotificationManagerService extends SystemService {\n         mAudioManager = audioMananger;\n     }\n \n+    @VisibleForTesting\n+    void setStrongAuthTracker(StrongAuthTracker strongAuthTracker) {\n+        mStrongAuthTracker = strongAuthTracker;\n+    }\n+\n     @VisibleForTesting\n     void setKeyguardManager(KeyguardManager keyguardManager) {\n         mKeyguardManager = keyguardManager;\n@@ -2113,6 +2168,8 @@ public class NotificationManagerService extends SystemService {\n                 ServiceManager.getService(Context.PLATFORM_COMPAT_SERVICE));\n \n         mUiHandler = new Handler(UiThread.get().getLooper());\n+        mLockPatternUtils = new LockPatternUtils(getContext());\n+        mStrongAuthTracker = new StrongAuthTracker(getContext());\n         String[] extractorNames;\n         try {\n             extractorNames = resources.getStringArray(R.array.config_notificationSignalExtractors);\n@@ -2597,6 +2654,7 @@ public class NotificationManagerService extends SystemService {\n                 bubbsExtractor.setShortcutHelper(mShortcutHelper);\n             }\n             registerNotificationPreferencesPullers();\n+            mLockPatternUtils.registerStrongAuthTracker(mStrongAuthTracker);\n         } else if (phase == SystemService.PHASE_THIRD_PARTY_APPS_CAN_START) {\n             // This observer will force an update when observe is called, causing us to\n             // bind to listener services.\n@@ -9210,6 +9268,29 @@ public class NotificationManagerService extends SystemService {\n         }\n     }\n \n+    private void cancelNotificationsWhenEnterLockDownMode() {\n+        synchronized (mNotificationLock) {\n+            int numNotifications = mNotificationList.size();\n+            for (int i = 0; i < numNotifications; i++) {\n+                NotificationRecord rec = mNotificationList.get(i);\n+                mListeners.notifyRemovedLocked(rec, REASON_CANCEL_ALL,\n+                        rec.getStats());\n+            }\n+\n+        }\n+    }\n+\n+    private void postNotificationsWhenExitLockDownMode() {\n+        synchronized (mNotificationLock) {\n+            int numNotifications = mNotificationList.size();\n+            for (int i = 0; i < numNotifications; i++) {\n+                NotificationRecord rec = mNotificationList.get(i);\n+                mListeners.notifyPostedLocked(rec, rec);\n+            }\n+\n+        }\n+    }\n+\n     private void updateNotificationPulse() {\n         synchronized (mNotificationLock) {\n             updateLightsLocked();\n@@ -9445,6 +9526,10 @@ public class NotificationManagerService extends SystemService {\n                 rankings.toArray(new NotificationListenerService.Ranking[0]));\n     }\n \n+    boolean isInLockDownMode() {\n+        return mStrongAuthTracker.isInLockDownMode();\n+    }\n+\n     boolean hasCompanionDevice(ManagedServiceInfo info) {\n         if (mCompanionManager == null) {\n             mCompanionManager = getCompanionManager();\n@@ -10496,8 +10581,12 @@ public class NotificationManagerService extends SystemService {\n          *                           targetting <= O_MR1\n          */\n         @GuardedBy(\"mNotificationLock\")\n-        private void notifyPostedLocked(NotificationRecord r, NotificationRecord old,\n+        void notifyPostedLocked(NotificationRecord r, NotificationRecord old,\n                 boolean notifyAllListeners) {\n+            if (isInLockDownMode()) {\n+                return;\n+            }\n+\n             try {\n                 // Lazily initialized snapshots of the notification.\n                 StatusBarNotification sbn = r.getSbn();\n@@ -10595,6 +10684,10 @@ public class NotificationManagerService extends SystemService {\n         @GuardedBy(\"mNotificationLock\")\n         public void notifyRemovedLocked(NotificationRecord r, int reason,\n                 NotificationStats notificationStats) {\n+            if (isInLockDownMode()) {\n+                return;\n+            }\n+\n             final StatusBarNotification sbn = r.getSbn();\n \n             // make a copy in case changes are made to the underlying Notification object\n@@ -10640,6 +10733,10 @@ public class NotificationManagerService extends SystemService {\n          */\n         @GuardedBy(\"mNotificationLock\")\n         public void notifyRankingUpdateLocked(List<NotificationRecord> changedHiddenNotifications) {\n+            if (isInLockDownMode()) {\n+                return;\n+            }\n+\n             boolean isHiddenRankingUpdate = changedHiddenNotifications != null\n                     && changedHiddenNotifications.size() > 0;\n             // TODO (b/73052211): if the ranking update changed the notification type,\n",
    "added_lines": 98,
    "deleted_lines": 1,
    "changed_methods": "NotificationManagerService::NotificationListeners::notifyRankingUpdateLocked, NotificationManagerService::init, NotificationManagerService::StrongAuthTracker::StrongAuthTracker, NotificationManagerService::StrongAuthTracker::containsFlag, NotificationManagerService::cancelNotificationsWhenEnterLockDownMode, NotificationManagerService::StrongAuthTracker::isInLockDownMode, NotificationManagerService::onBootPhase, NotificationManagerService::postNotificationsWhenExitLockDownMode, NotificationManagerService::StrongAuthTracker::onStrongAuthRequiredChanged, NotificationManagerService::setStrongAuthTracker, NotificationManagerService::isInLockDownMode, NotificationManagerService::NotificationListeners::notifyPostedLocked, NotificationManagerService::NotificationListeners::notifyRemovedLocked"
   },
   {
    "filename": "NotificationListenersTest.java",
    "diff": "@@ -27,12 +27,13 @@ import static com.google.common.truth.Truth.assertThat;\n import static junit.framework.Assert.assertFalse;\n import static junit.framework.Assert.assertTrue;\n \n-import static org.mockito.ArgumentMatchers.any;\n-import static org.mockito.ArgumentMatchers.anyInt;\n import static org.mockito.ArgumentMatchers.eq;\n import static org.mockito.ArgumentMatchers.nullable;\n+import static org.mockito.Mockito.atLeast;\n import static org.mockito.Mockito.doNothing;\n import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.reset;\n import static org.mockito.Mockito.spy;\n import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.when;\n@@ -47,10 +48,11 @@ import android.os.Bundle;\n import android.os.UserHandle;\n import android.service.notification.NotificationListenerFilter;\n import android.service.notification.NotificationListenerService;\n+import android.service.notification.NotificationStats;\n+import android.service.notification.StatusBarNotification;\n import android.testing.TestableContext;\n import android.util.ArraySet;\n import android.util.Pair;\n-import android.util.Slog;\n import android.util.TypedXmlPullParser;\n import android.util.TypedXmlSerializer;\n import android.util.Xml;\n@@ -61,11 +63,13 @@ import org.junit.Before;\n import org.junit.Test;\n import org.mockito.Mock;\n import org.mockito.MockitoAnnotations;\n+import org.mockito.internal.util.reflection.FieldSetter;\n \n import java.io.BufferedInputStream;\n import java.io.BufferedOutputStream;\n import java.io.ByteArrayInputStream;\n import java.io.ByteArrayOutputStream;\n+import java.util.List;\n \n public class NotificationListenersTest extends UiServiceTestCase {\n \n@@ -374,4 +378,66 @@ public class NotificationListenersTest extends UiServiceTestCase {\n         verify(mContext).sendBroadcastAsUser(\n                 any(), eq(UserHandle.of(userId)), nullable(String.class));\n     }\n+\n+    @Test\n+    public void testNotifyPostedLockedInLockdownMode() {\n+        NotificationRecord r = mock(NotificationRecord.class);\n+        NotificationRecord old = mock(NotificationRecord.class);\n+\n+        // before the lockdown mode\n+        when(mNm.isInLockDownMode()).thenReturn(false);\n+        mListeners.notifyPostedLocked(r, old, true);\n+        mListeners.notifyPostedLocked(r, old, false);\n+        verify(r, atLeast(2)).getSbn();\n+\n+        // in the lockdown mode\n+        reset(r);\n+        reset(old);\n+        when(mNm.isInLockDownMode()).thenReturn(true);\n+        mListeners.notifyPostedLocked(r, old, true);\n+        mListeners.notifyPostedLocked(r, old, false);\n+        verify(r, never()).getSbn();\n+    }\n+\n+    @Test\n+    public void testnotifyRankingUpdateLockedInLockdownMode() {\n+        List chn = mock(List.class);\n+\n+        // before the lockdown mode\n+        when(mNm.isInLockDownMode()).thenReturn(false);\n+        mListeners.notifyRankingUpdateLocked(chn);\n+        verify(chn, atLeast(1)).size();\n+\n+        // in the lockdown mode\n+        reset(chn);\n+        when(mNm.isInLockDownMode()).thenReturn(true);\n+        mListeners.notifyRankingUpdateLocked(chn);\n+        verify(chn, never()).size();\n+    }\n+\n+    @Test\n+    public void testNotifyRemovedLockedInLockdownMode() throws NoSuchFieldException {\n+        NotificationRecord r = mock(NotificationRecord.class);\n+        NotificationStats rs = mock(NotificationStats.class);\n+        StatusBarNotification sbn = mock(StatusBarNotification.class);\n+        FieldSetter.setField(mNm,\n+                NotificationManagerService.class.getDeclaredField(\"mHandler\"),\n+                mock(NotificationManagerService.WorkerHandler.class));\n+\n+        // before the lockdown mode\n+        when(mNm.isInLockDownMode()).thenReturn(false);\n+        when(r.getSbn()).thenReturn(sbn);\n+        mListeners.notifyRemovedLocked(r, 0, rs);\n+        mListeners.notifyRemovedLocked(r, 0, rs);\n+        verify(r, atLeast(2)).getSbn();\n+\n+        // in the lockdown mode\n+        reset(r);\n+        reset(rs);\n+        when(mNm.isInLockDownMode()).thenReturn(true);\n+        when(r.getSbn()).thenReturn(sbn);\n+        mListeners.notifyRemovedLocked(r, 0, rs);\n+        mListeners.notifyRemovedLocked(r, 0, rs);\n+        verify(r, never()).getSbn();\n+    }\n }\n",
    "added_lines": 69,
    "deleted_lines": 3,
    "changed_methods": "NotificationListenersTest::testnotifyRankingUpdateLockedInLockdownMode, NotificationListenersTest::testNotifyPostedLockedInLockdownMode, NotificationListenersTest::testNotifyRemovedLockedInLockdownMode"
   },
   {
    "filename": "NotificationManagerServiceTest.java",
    "diff": "@@ -58,10 +58,13 @@ import static android.service.notification.Adjustment.KEY_USER_SENTIMENT;\n import static android.service.notification.NotificationListenerService.FLAG_FILTER_TYPE_ALERTING;\n import static android.service.notification.NotificationListenerService.FLAG_FILTER_TYPE_CONVERSATIONS;\n import static android.service.notification.NotificationListenerService.FLAG_FILTER_TYPE_ONGOING;\n+import static android.service.notification.NotificationListenerService.REASON_CANCEL_ALL;\n import static android.service.notification.NotificationListenerService.Ranking.USER_SENTIMENT_NEGATIVE;\n import static android.service.notification.NotificationListenerService.Ranking.USER_SENTIMENT_NEUTRAL;\n import static android.view.WindowManager.LayoutParams.TYPE_TOAST;\n \n+import static com.android.internal.widget.LockPatternUtils.StrongAuthTracker.STRONG_AUTH_REQUIRED_AFTER_USER_LOCKDOWN;\n+\n import static com.google.common.truth.Truth.assertThat;\n \n import static junit.framework.Assert.assertEquals;\n@@ -223,7 +226,6 @@ import java.util.Arrays;\n import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n-import java.util.Set;\n import java.util.concurrent.CountDownLatch;\n import java.util.function.Consumer;\n \n@@ -409,8 +411,26 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n         interface NotificationAssistantAccessGrantedCallback {\n             void onGranted(ComponentName assistant, int userId, boolean granted, boolean userSet);\n         }\n+\n+        class StrongAuthTrackerFake extends NotificationManagerService.StrongAuthTracker {\n+            private int mGetStrongAuthForUserReturnValue = 0;\n+            StrongAuthTrackerFake(Context context) {\n+                super(context);\n+            }\n+\n+            public void setGetStrongAuthForUserReturnValue(int val) {\n+                mGetStrongAuthForUserReturnValue = val;\n+            }\n+\n+            @Override\n+            public int getStrongAuthForUser(int userId) {\n+                return mGetStrongAuthForUserReturnValue;\n+            }\n+        }\n     }\n \n+    TestableNotificationManagerService.StrongAuthTrackerFake mStrongAuthTracker;\n+\n     private class TestableToastCallback extends ITransientNotification.Stub {\n         @Override\n         public void show(IBinder windowToken) {\n@@ -530,6 +550,9 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n \n         mService.setAudioManager(mAudioManager);\n \n+        mStrongAuthTracker = mService.new StrongAuthTrackerFake(mContext);\n+        mService.setStrongAuthTracker(mStrongAuthTracker);\n+\n         mShortcutHelper = mService.getShortcutHelper();\n         mShortcutHelper.setLauncherApps(mLauncherApps);\n         mShortcutHelper.setShortcutServiceInternal(mShortcutServiceInternal);\n@@ -8354,4 +8377,44 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n             }\n         }\n     }\n+\n+    @Test\n+    public void testStrongAuthTracker_isInLockDownMode() {\n+        mStrongAuthTracker.setGetStrongAuthForUserReturnValue(\n+                STRONG_AUTH_REQUIRED_AFTER_USER_LOCKDOWN);\n+        mStrongAuthTracker.onStrongAuthRequiredChanged(mContext.getUserId());\n+        assertTrue(mStrongAuthTracker.isInLockDownMode());\n+        mStrongAuthTracker.setGetStrongAuthForUserReturnValue(0);\n+        mStrongAuthTracker.onStrongAuthRequiredChanged(mContext.getUserId());\n+        assertFalse(mStrongAuthTracker.isInLockDownMode());\n+    }\n+\n+    @Test\n+    public void testCancelAndPostNotificationsWhenEnterAndExitLockDownMode() {\n+        // post 2 notifications from 2 packages\n+        NotificationRecord pkgA = new NotificationRecord(mContext,\n+                generateSbn(\"a\", 1000, 9, 0), mTestNotificationChannel);\n+        mService.addNotification(pkgA);\n+        NotificationRecord pkgB = new NotificationRecord(mContext,\n+                generateSbn(\"b\", 1001, 9, 0), mTestNotificationChannel);\n+        mService.addNotification(pkgB);\n+\n+        // when entering the lockdown mode, cancel the 2 notifications.\n+        mStrongAuthTracker.setGetStrongAuthForUserReturnValue(\n+                STRONG_AUTH_REQUIRED_AFTER_USER_LOCKDOWN);\n+        mStrongAuthTracker.onStrongAuthRequiredChanged(mContext.getUserId());\n+        assertTrue(mStrongAuthTracker.isInLockDownMode());\n+\n+        // the notifyRemovedLocked function is called twice due to REASON_LOCKDOWN.\n+        ArgumentCaptor<Integer> captor = ArgumentCaptor.forClass(Integer.class);\n+        verify(mListeners, times(2)).notifyRemovedLocked(any(), captor.capture(), any());\n+        assertEquals(REASON_CANCEL_ALL, captor.getValue().intValue());\n+\n+        // exit lockdown mode.\n+        mStrongAuthTracker.setGetStrongAuthForUserReturnValue(0);\n+        mStrongAuthTracker.onStrongAuthRequiredChanged(mContext.getUserId());\n+\n+        // the notifyPostedLocked function is called twice.\n+        verify(mListeners, times(2)).notifyPostedLocked(any(), any());\n+    }\n }\n",
    "added_lines": 64,
    "deleted_lines": 1,
    "changed_methods": "NotificationManagerServiceTest::TestableNotificationManagerService::StrongAuthTrackerFake::StrongAuthTrackerFake, NotificationManagerServiceTest::testCancelAndPostNotificationsWhenEnterAndExitLockDownMode, NotificationManagerServiceTest::TestableNotificationManagerService::StrongAuthTrackerFake::setGetStrongAuthForUserReturnValue, NotificationManagerServiceTest::setUp, NotificationManagerServiceTest::testStrongAuthTracker_isInLockDownMode, NotificationManagerServiceTest::TestableNotificationManagerService::StrongAuthTrackerFake::getStrongAuthForUser"
   }
  ]
 },
 {
  "hash": "f85097863810e3bc65597c29689932eb707d65e8",
  "commit": "DO NOT MERGE Suppress notifications when device enter lockdown\n\nThis CL makes the following modifcations:\n1. Add LockPatternUtils.StrongAuthTracker to monitor\nthe lockdown mode status of the phone.\n2. Call mListeners.notifyRemovedLocked with all the\nnotifications in the mNotificationList when entering\nthe lockdown mode.\n3. Call mListeners.notifyPostedLocked with all the\nnotifications in the mNotificationList when exiting\nthe lockdown mode.\n4. Dismiss the function calls of notifyPostedLocked,\nnotifyRemovedLocked, and notifyRankingUpdateLocked\nduring the lockdown mode.\n\nThe CL also adds corresponding tests.\n\nBug: 173721373\nTest: atest NotificationManagerServiceTest\nTest: atest NotificationListenersTest\nTest: manually verify the paired device cannot receive\nnotifications when the host phone is in lockdown mode.\nIgnore-AOSP-First: pending fix for a security issue.\n\nChange-Id: I7e83544863eeadf8272b6ff8a9bb8136d6466203\nMerged-In: I7e83544863eeadf8272b6ff8a9bb8136d6466203\n(cherry picked from commit 3cb6842a053e236cc98d7616ba4433c31ffda3ac)\n(cherry picked from commit b1099290b8eb939fcb707c817989dd24d0e7a3b5)\nMerged-In: I7e83544863eeadf8272b6ff8a9bb8136d6466203",
  "files": [
   {
    "filename": "NotificationManagerService.java",
    "diff": "@@ -249,6 +249,7 @@ import android.util.Log;\n import android.util.Pair;\n import android.util.Slog;\n import android.util.SparseArray;\n+import android.util.SparseBooleanArray;\n import android.util.StatsEvent;\n import android.util.TypedXmlPullParser;\n import android.util.TypedXmlSerializer;\n@@ -280,6 +281,7 @@ import com.android.internal.util.DumpUtils;\n import com.android.internal.util.Preconditions;\n import com.android.internal.util.XmlUtils;\n import com.android.internal.util.function.TriPredicate;\n+import com.android.internal.widget.LockPatternUtils;\n import com.android.server.DeviceIdleInternal;\n import com.android.server.EventLogTags;\n import com.android.server.IoThread;\n@@ -1904,6 +1906,54 @@ public class NotificationManagerService extends SystemService {\n     private SettingsObserver mSettingsObserver;\n     protected ZenModeHelper mZenModeHelper;\n \n+    protected class StrongAuthTracker extends LockPatternUtils.StrongAuthTracker {\n+\n+        SparseBooleanArray mUserInLockDownMode = new SparseBooleanArray();\n+        boolean mIsInLockDownMode = false;\n+\n+        StrongAuthTracker(Context context) {\n+            super(context);\n+        }\n+\n+        private boolean containsFlag(int haystack, int needle) {\n+            return (haystack & needle) != 0;\n+        }\n+\n+        public boolean isInLockDownMode() {\n+            return mIsInLockDownMode;\n+        }\n+\n+        @Override\n+        public synchronized void onStrongAuthRequiredChanged(int userId) {\n+            boolean userInLockDownModeNext = containsFlag(getStrongAuthForUser(userId),\n+                    STRONG_AUTH_REQUIRED_AFTER_USER_LOCKDOWN);\n+            mUserInLockDownMode.put(userId, userInLockDownModeNext);\n+            boolean isInLockDownModeNext = mUserInLockDownMode.indexOfValue(true) != -1;\n+\n+            if (mIsInLockDownMode == isInLockDownModeNext) {\n+                return;\n+            }\n+\n+            if (isInLockDownModeNext) {\n+                cancelNotificationsWhenEnterLockDownMode();\n+            }\n+\n+            // When the mIsInLockDownMode is true, both notifyPostedLocked and\n+            // notifyRemovedLocked will be dismissed. So we shall call\n+            // cancelNotificationsWhenEnterLockDownMode before we set mIsInLockDownMode\n+            // as true and call postNotificationsWhenExitLockDownMode after we set\n+            // mIsInLockDownMode as false.\n+            mIsInLockDownMode = isInLockDownModeNext;\n+\n+            if (!isInLockDownModeNext) {\n+                postNotificationsWhenExitLockDownMode();\n+            }\n+        }\n+    }\n+\n+    private LockPatternUtils mLockPatternUtils;\n+    private StrongAuthTracker mStrongAuthTracker;\n+\n     public NotificationManagerService(Context context) {\n         this(context,\n                 new NotificationRecordLoggerImpl(),\n@@ -1926,6 +1976,11 @@ public class NotificationManagerService extends SystemService {\n         mAudioManager = audioMananger;\n     }\n \n+    @VisibleForTesting\n+    void setStrongAuthTracker(StrongAuthTracker strongAuthTracker) {\n+        mStrongAuthTracker = strongAuthTracker;\n+    }\n+\n     @VisibleForTesting\n     void setKeyguardManager(KeyguardManager keyguardManager) {\n         mKeyguardManager = keyguardManager;\n@@ -2113,6 +2168,8 @@ public class NotificationManagerService extends SystemService {\n                 ServiceManager.getService(Context.PLATFORM_COMPAT_SERVICE));\n \n         mUiHandler = new Handler(UiThread.get().getLooper());\n+        mLockPatternUtils = new LockPatternUtils(getContext());\n+        mStrongAuthTracker = new StrongAuthTracker(getContext());\n         String[] extractorNames;\n         try {\n             extractorNames = resources.getStringArray(R.array.config_notificationSignalExtractors);\n@@ -2597,6 +2654,7 @@ public class NotificationManagerService extends SystemService {\n                 bubbsExtractor.setShortcutHelper(mShortcutHelper);\n             }\n             registerNotificationPreferencesPullers();\n+            mLockPatternUtils.registerStrongAuthTracker(mStrongAuthTracker);\n         } else if (phase == SystemService.PHASE_THIRD_PARTY_APPS_CAN_START) {\n             // This observer will force an update when observe is called, causing us to\n             // bind to listener services.\n@@ -9210,6 +9268,29 @@ public class NotificationManagerService extends SystemService {\n         }\n     }\n \n+    private void cancelNotificationsWhenEnterLockDownMode() {\n+        synchronized (mNotificationLock) {\n+            int numNotifications = mNotificationList.size();\n+            for (int i = 0; i < numNotifications; i++) {\n+                NotificationRecord rec = mNotificationList.get(i);\n+                mListeners.notifyRemovedLocked(rec, REASON_CANCEL_ALL,\n+                        rec.getStats());\n+            }\n+\n+        }\n+    }\n+\n+    private void postNotificationsWhenExitLockDownMode() {\n+        synchronized (mNotificationLock) {\n+            int numNotifications = mNotificationList.size();\n+            for (int i = 0; i < numNotifications; i++) {\n+                NotificationRecord rec = mNotificationList.get(i);\n+                mListeners.notifyPostedLocked(rec, rec);\n+            }\n+\n+        }\n+    }\n+\n     private void updateNotificationPulse() {\n         synchronized (mNotificationLock) {\n             updateLightsLocked();\n@@ -9445,6 +9526,10 @@ public class NotificationManagerService extends SystemService {\n                 rankings.toArray(new NotificationListenerService.Ranking[0]));\n     }\n \n+    boolean isInLockDownMode() {\n+        return mStrongAuthTracker.isInLockDownMode();\n+    }\n+\n     boolean hasCompanionDevice(ManagedServiceInfo info) {\n         if (mCompanionManager == null) {\n             mCompanionManager = getCompanionManager();\n@@ -10496,8 +10581,12 @@ public class NotificationManagerService extends SystemService {\n          *                           targetting <= O_MR1\n          */\n         @GuardedBy(\"mNotificationLock\")\n-        private void notifyPostedLocked(NotificationRecord r, NotificationRecord old,\n+        void notifyPostedLocked(NotificationRecord r, NotificationRecord old,\n                 boolean notifyAllListeners) {\n+            if (isInLockDownMode()) {\n+                return;\n+            }\n+\n             try {\n                 // Lazily initialized snapshots of the notification.\n                 StatusBarNotification sbn = r.getSbn();\n@@ -10595,6 +10684,10 @@ public class NotificationManagerService extends SystemService {\n         @GuardedBy(\"mNotificationLock\")\n         public void notifyRemovedLocked(NotificationRecord r, int reason,\n                 NotificationStats notificationStats) {\n+            if (isInLockDownMode()) {\n+                return;\n+            }\n+\n             final StatusBarNotification sbn = r.getSbn();\n \n             // make a copy in case changes are made to the underlying Notification object\n@@ -10640,6 +10733,10 @@ public class NotificationManagerService extends SystemService {\n          */\n         @GuardedBy(\"mNotificationLock\")\n         public void notifyRankingUpdateLocked(List<NotificationRecord> changedHiddenNotifications) {\n+            if (isInLockDownMode()) {\n+                return;\n+            }\n+\n             boolean isHiddenRankingUpdate = changedHiddenNotifications != null\n                     && changedHiddenNotifications.size() > 0;\n             // TODO (b/73052211): if the ranking update changed the notification type,\n",
    "added_lines": 98,
    "deleted_lines": 1,
    "changed_methods": "NotificationManagerService::NotificationListeners::notifyRankingUpdateLocked, NotificationManagerService::init, NotificationManagerService::StrongAuthTracker::StrongAuthTracker, NotificationManagerService::StrongAuthTracker::containsFlag, NotificationManagerService::cancelNotificationsWhenEnterLockDownMode, NotificationManagerService::StrongAuthTracker::isInLockDownMode, NotificationManagerService::onBootPhase, NotificationManagerService::postNotificationsWhenExitLockDownMode, NotificationManagerService::StrongAuthTracker::onStrongAuthRequiredChanged, NotificationManagerService::setStrongAuthTracker, NotificationManagerService::isInLockDownMode, NotificationManagerService::NotificationListeners::notifyPostedLocked, NotificationManagerService::NotificationListeners::notifyRemovedLocked"
   },
   {
    "filename": "NotificationListenersTest.java",
    "diff": "@@ -27,12 +27,13 @@ import static com.google.common.truth.Truth.assertThat;\n import static junit.framework.Assert.assertFalse;\n import static junit.framework.Assert.assertTrue;\n \n-import static org.mockito.ArgumentMatchers.any;\n-import static org.mockito.ArgumentMatchers.anyInt;\n import static org.mockito.ArgumentMatchers.eq;\n import static org.mockito.ArgumentMatchers.nullable;\n+import static org.mockito.Mockito.atLeast;\n import static org.mockito.Mockito.doNothing;\n import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.reset;\n import static org.mockito.Mockito.spy;\n import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.when;\n@@ -47,10 +48,11 @@ import android.os.Bundle;\n import android.os.UserHandle;\n import android.service.notification.NotificationListenerFilter;\n import android.service.notification.NotificationListenerService;\n+import android.service.notification.NotificationStats;\n+import android.service.notification.StatusBarNotification;\n import android.testing.TestableContext;\n import android.util.ArraySet;\n import android.util.Pair;\n-import android.util.Slog;\n import android.util.TypedXmlPullParser;\n import android.util.TypedXmlSerializer;\n import android.util.Xml;\n@@ -61,11 +63,13 @@ import org.junit.Before;\n import org.junit.Test;\n import org.mockito.Mock;\n import org.mockito.MockitoAnnotations;\n+import org.mockito.internal.util.reflection.FieldSetter;\n \n import java.io.BufferedInputStream;\n import java.io.BufferedOutputStream;\n import java.io.ByteArrayInputStream;\n import java.io.ByteArrayOutputStream;\n+import java.util.List;\n \n public class NotificationListenersTest extends UiServiceTestCase {\n \n@@ -374,4 +378,66 @@ public class NotificationListenersTest extends UiServiceTestCase {\n         verify(mContext).sendBroadcastAsUser(\n                 any(), eq(UserHandle.of(userId)), nullable(String.class));\n     }\n+\n+    @Test\n+    public void testNotifyPostedLockedInLockdownMode() {\n+        NotificationRecord r = mock(NotificationRecord.class);\n+        NotificationRecord old = mock(NotificationRecord.class);\n+\n+        // before the lockdown mode\n+        when(mNm.isInLockDownMode()).thenReturn(false);\n+        mListeners.notifyPostedLocked(r, old, true);\n+        mListeners.notifyPostedLocked(r, old, false);\n+        verify(r, atLeast(2)).getSbn();\n+\n+        // in the lockdown mode\n+        reset(r);\n+        reset(old);\n+        when(mNm.isInLockDownMode()).thenReturn(true);\n+        mListeners.notifyPostedLocked(r, old, true);\n+        mListeners.notifyPostedLocked(r, old, false);\n+        verify(r, never()).getSbn();\n+    }\n+\n+    @Test\n+    public void testnotifyRankingUpdateLockedInLockdownMode() {\n+        List chn = mock(List.class);\n+\n+        // before the lockdown mode\n+        when(mNm.isInLockDownMode()).thenReturn(false);\n+        mListeners.notifyRankingUpdateLocked(chn);\n+        verify(chn, atLeast(1)).size();\n+\n+        // in the lockdown mode\n+        reset(chn);\n+        when(mNm.isInLockDownMode()).thenReturn(true);\n+        mListeners.notifyRankingUpdateLocked(chn);\n+        verify(chn, never()).size();\n+    }\n+\n+    @Test\n+    public void testNotifyRemovedLockedInLockdownMode() throws NoSuchFieldException {\n+        NotificationRecord r = mock(NotificationRecord.class);\n+        NotificationStats rs = mock(NotificationStats.class);\n+        StatusBarNotification sbn = mock(StatusBarNotification.class);\n+        FieldSetter.setField(mNm,\n+                NotificationManagerService.class.getDeclaredField(\"mHandler\"),\n+                mock(NotificationManagerService.WorkerHandler.class));\n+\n+        // before the lockdown mode\n+        when(mNm.isInLockDownMode()).thenReturn(false);\n+        when(r.getSbn()).thenReturn(sbn);\n+        mListeners.notifyRemovedLocked(r, 0, rs);\n+        mListeners.notifyRemovedLocked(r, 0, rs);\n+        verify(r, atLeast(2)).getSbn();\n+\n+        // in the lockdown mode\n+        reset(r);\n+        reset(rs);\n+        when(mNm.isInLockDownMode()).thenReturn(true);\n+        when(r.getSbn()).thenReturn(sbn);\n+        mListeners.notifyRemovedLocked(r, 0, rs);\n+        mListeners.notifyRemovedLocked(r, 0, rs);\n+        verify(r, never()).getSbn();\n+    }\n }\n",
    "added_lines": 69,
    "deleted_lines": 3,
    "changed_methods": "NotificationListenersTest::testnotifyRankingUpdateLockedInLockdownMode, NotificationListenersTest::testNotifyPostedLockedInLockdownMode, NotificationListenersTest::testNotifyRemovedLockedInLockdownMode"
   },
   {
    "filename": "NotificationManagerServiceTest.java",
    "diff": "@@ -58,10 +58,13 @@ import static android.service.notification.Adjustment.KEY_USER_SENTIMENT;\n import static android.service.notification.NotificationListenerService.FLAG_FILTER_TYPE_ALERTING;\n import static android.service.notification.NotificationListenerService.FLAG_FILTER_TYPE_CONVERSATIONS;\n import static android.service.notification.NotificationListenerService.FLAG_FILTER_TYPE_ONGOING;\n+import static android.service.notification.NotificationListenerService.REASON_CANCEL_ALL;\n import static android.service.notification.NotificationListenerService.Ranking.USER_SENTIMENT_NEGATIVE;\n import static android.service.notification.NotificationListenerService.Ranking.USER_SENTIMENT_NEUTRAL;\n import static android.view.WindowManager.LayoutParams.TYPE_TOAST;\n \n+import static com.android.internal.widget.LockPatternUtils.StrongAuthTracker.STRONG_AUTH_REQUIRED_AFTER_USER_LOCKDOWN;\n+\n import static com.google.common.truth.Truth.assertThat;\n \n import static junit.framework.Assert.assertEquals;\n@@ -223,7 +226,6 @@ import java.util.Arrays;\n import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n-import java.util.Set;\n import java.util.concurrent.CountDownLatch;\n import java.util.function.Consumer;\n \n@@ -409,8 +411,26 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n         interface NotificationAssistantAccessGrantedCallback {\n             void onGranted(ComponentName assistant, int userId, boolean granted, boolean userSet);\n         }\n+\n+        class StrongAuthTrackerFake extends NotificationManagerService.StrongAuthTracker {\n+            private int mGetStrongAuthForUserReturnValue = 0;\n+            StrongAuthTrackerFake(Context context) {\n+                super(context);\n+            }\n+\n+            public void setGetStrongAuthForUserReturnValue(int val) {\n+                mGetStrongAuthForUserReturnValue = val;\n+            }\n+\n+            @Override\n+            public int getStrongAuthForUser(int userId) {\n+                return mGetStrongAuthForUserReturnValue;\n+            }\n+        }\n     }\n \n+    TestableNotificationManagerService.StrongAuthTrackerFake mStrongAuthTracker;\n+\n     private class TestableToastCallback extends ITransientNotification.Stub {\n         @Override\n         public void show(IBinder windowToken) {\n@@ -530,6 +550,9 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n \n         mService.setAudioManager(mAudioManager);\n \n+        mStrongAuthTracker = mService.new StrongAuthTrackerFake(mContext);\n+        mService.setStrongAuthTracker(mStrongAuthTracker);\n+\n         mShortcutHelper = mService.getShortcutHelper();\n         mShortcutHelper.setLauncherApps(mLauncherApps);\n         mShortcutHelper.setShortcutServiceInternal(mShortcutServiceInternal);\n@@ -8354,4 +8377,44 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n             }\n         }\n     }\n+\n+    @Test\n+    public void testStrongAuthTracker_isInLockDownMode() {\n+        mStrongAuthTracker.setGetStrongAuthForUserReturnValue(\n+                STRONG_AUTH_REQUIRED_AFTER_USER_LOCKDOWN);\n+        mStrongAuthTracker.onStrongAuthRequiredChanged(mContext.getUserId());\n+        assertTrue(mStrongAuthTracker.isInLockDownMode());\n+        mStrongAuthTracker.setGetStrongAuthForUserReturnValue(0);\n+        mStrongAuthTracker.onStrongAuthRequiredChanged(mContext.getUserId());\n+        assertFalse(mStrongAuthTracker.isInLockDownMode());\n+    }\n+\n+    @Test\n+    public void testCancelAndPostNotificationsWhenEnterAndExitLockDownMode() {\n+        // post 2 notifications from 2 packages\n+        NotificationRecord pkgA = new NotificationRecord(mContext,\n+                generateSbn(\"a\", 1000, 9, 0), mTestNotificationChannel);\n+        mService.addNotification(pkgA);\n+        NotificationRecord pkgB = new NotificationRecord(mContext,\n+                generateSbn(\"b\", 1001, 9, 0), mTestNotificationChannel);\n+        mService.addNotification(pkgB);\n+\n+        // when entering the lockdown mode, cancel the 2 notifications.\n+        mStrongAuthTracker.setGetStrongAuthForUserReturnValue(\n+                STRONG_AUTH_REQUIRED_AFTER_USER_LOCKDOWN);\n+        mStrongAuthTracker.onStrongAuthRequiredChanged(mContext.getUserId());\n+        assertTrue(mStrongAuthTracker.isInLockDownMode());\n+\n+        // the notifyRemovedLocked function is called twice due to REASON_LOCKDOWN.\n+        ArgumentCaptor<Integer> captor = ArgumentCaptor.forClass(Integer.class);\n+        verify(mListeners, times(2)).notifyRemovedLocked(any(), captor.capture(), any());\n+        assertEquals(REASON_CANCEL_ALL, captor.getValue().intValue());\n+\n+        // exit lockdown mode.\n+        mStrongAuthTracker.setGetStrongAuthForUserReturnValue(0);\n+        mStrongAuthTracker.onStrongAuthRequiredChanged(mContext.getUserId());\n+\n+        // the notifyPostedLocked function is called twice.\n+        verify(mListeners, times(2)).notifyPostedLocked(any(), any());\n+    }\n }\n",
    "added_lines": 64,
    "deleted_lines": 1,
    "changed_methods": "NotificationManagerServiceTest::TestableNotificationManagerService::StrongAuthTrackerFake::StrongAuthTrackerFake, NotificationManagerServiceTest::testCancelAndPostNotificationsWhenEnterAndExitLockDownMode, NotificationManagerServiceTest::TestableNotificationManagerService::StrongAuthTrackerFake::setGetStrongAuthForUserReturnValue, NotificationManagerServiceTest::setUp, NotificationManagerServiceTest::testStrongAuthTracker_isInLockDownMode, NotificationManagerServiceTest::TestableNotificationManagerService::StrongAuthTrackerFake::getStrongAuthForUser"
   }
  ]
 },
 {
  "hash": "26a39ef345e111ca509a00f34d50c823461225aa",
  "commit": "Make sure callingPackage belongs to callingUid when checking BG-FGS restrictions.\n\nThis is to stop spoofed packageName to pretend to be allowListed\npackageName so it can bypass the BG-FGS restriction. This applies to\nboth BG-FGS while-in-use restriction and BG-FGS-start restriction\nsince these two restrictions are related.\n\nBug: 216695100\nBug: 215003903\nTest: atest cts/tests/app/src/android/app/cts/ActivityManagerFgsBgStartTest.java#testSpoofPackageName\nChange-Id: Ic14fc331a9b5fbdbcfe6e54a31c8b765513bfd89\nMerged-In: Ic14fc331a9b5fbdbcfe6e54a31c8b765513bfd89\n(cherry picked from commit eef20391ce4d15d4508dc295cb338954a7c69de7)\nMerged-In: Ic14fc331a9b5fbdbcfe6e54a31c8b765513bfd89",
  "files": [
   {
    "filename": "ActiveServices.java",
    "diff": "@@ -5999,10 +5999,16 @@ public final class ActiveServices {\n         }\n \n         if (ret == REASON_DENIED) {\n-            final boolean isAllowedPackage =\n-                    mAllowListWhileInUsePermissionInFgs.contains(callingPackage);\n-            if (isAllowedPackage) {\n-                ret = REASON_ALLOWLISTED_PACKAGE;\n+            if (verifyPackage(callingPackage, callingUid)) {\n+                final boolean isAllowedPackage =\n+                        mAllowListWhileInUsePermissionInFgs.contains(callingPackage);\n+                if (isAllowedPackage) {\n+                    ret = REASON_ALLOWLISTED_PACKAGE;\n+                }\n+            } else {\n+                EventLog.writeEvent(0x534e4554, \"215003903\", callingUid,\n+                        \"callingPackage:\" + callingPackage + \" does not belong to callingUid:\"\n+                                + callingUid);\n             }\n         }\n \n@@ -6385,4 +6391,21 @@ public final class ActiveServices {\n                 /* allowBackgroundActivityStarts */ false)\n                 != REASON_DENIED;\n     }\n+\n+    /**\n+     * Checks if a given packageName belongs to a given uid.\n+     * @param packageName the package of the caller\n+     * @param uid the uid of the caller\n+     * @return true or false\n+     */\n+    private boolean verifyPackage(String packageName, int uid) {\n+        if (uid == ROOT_UID || uid == SYSTEM_UID) {\n+            //System and Root are always allowed\n+            return true;\n+        }\n+        final int userId = UserHandle.getUserId(uid);\n+        final int packageUid = mAm.getPackageManagerInternal()\n+                .getPackageUid(packageName, PackageManager.MATCH_DEBUG_TRIAGED_MISSING, userId);\n+        return UserHandle.isSameApp(uid, packageUid);\n+    }\n }\n",
    "added_lines": 27,
    "deleted_lines": 4,
    "changed_methods": "ActiveServices::shouldAllowFgsWhileInUsePermissionLocked, ActiveServices::verifyPackage"
   }
  ]
 },
 {
  "hash": "66d3d4b687cac1c00ada8b66de974c4643b29691",
  "commit": "Clear mInterface before calling resetIkeState()\n\nClear mInterface before calling resetIkeState() in\nonDefaultNetworkChanged().\nresetIkeState() will trigger interfaceRemoved() to be called.\nIf mInterface is set, interfaceRemoved() will clear\nIkev2VpnRunner which makes VPN disconnect.\n\nThis issue can be reproduced when device establishes VPN\nconnection with mobile data first then connects to wifi.\nIn this case, onLost() for mobile data will not be called\nbecause there is a new network(wifi) can satisfy the request,\nso only onAvailable() for wifi will be called.\nWhich means onSessionLost() will not be called and only\nonDefaultNetworkChanged() will be called, which makes that\nmInterface is not cleared before interfaceRemoved() is called.\n\nBug: 219546241\nTest: Check if VPN is still there when establishing VPN with\n      mobile data first, then connect to wifi and disconnect\n      wifi.\nChange-Id: I7f9a1d9afd2a40762e9fac68edf1fb8ae75df8bc\n(cherry picked from commit 520cc2fde363dd038911b98b8b46259faf58a659)\nMerged-In: I7f9a1d9afd2a40762e9fac68edf1fb8ae75df8bc\n(cherry picked from commit 65d44b93bb99eae441ebf5bf1afb4efd00074758)\nMerged-In: I7f9a1d9afd2a40762e9fac68edf1fb8ae75df8bc",
  "files": [
   {
    "filename": "Vpn.java",
    "diff": "@@ -2627,6 +2627,9 @@ public class Vpn {\n                         return; // VPN has been shut down.\n                     }\n \n+                    // Clear mInterface to prevent Ikev2VpnRunner being cleared when\n+                    // interfaceRemoved() is called.\n+                    mInterface = null;\n                     // Without MOBIKE, we have no way to seamlessly migrate. Close on old\n                     // (non-default) network, and start the new one.\n                     resetIkeState();\n",
    "added_lines": 3,
    "deleted_lines": 0,
    "changed_methods": "Vpn::IkeV2VpnRunner::onDefaultNetworkChanged"
   }
  ]
 },
 {
  "hash": "b29568f8b9948aed6562b205fc569d7ba6a77f96",
  "commit": "DO NOT MERGE. Add a permissions check to LocationManagerService.\n\nPrevents apps from reading location requests of other users without INTERACT_ACROSS_USERS permission.\nBug: 222473855\nTest: Build\n\nChange-Id: Id591cd39ed7813c649b44d4a3210f0b1fb79b40d\n(cherry picked from commit 16560c093091b7ab390c16137618da6fd916d44e)\n(cherry picked from commit 5b376bc9fd51e1a39fd5e1bd6a698c7cb2b9b3d4)\nMerged-In: Id591cd39ed7813c649b44d4a3210f0b1fb79b40d",
  "files": [
   {
    "filename": "LocationManagerService.java",
    "diff": "@@ -17,6 +17,7 @@\n package com.android.server.location;\n \n import static android.Manifest.permission.ACCESS_FINE_LOCATION;\n+import static android.Manifest.permission.INTERACT_ACROSS_USERS;\n import static android.app.compat.CompatChanges.isChangeEnabled;\n import static android.content.pm.PackageManager.MATCH_DIRECT_BOOT_AWARE;\n import static android.content.pm.PackageManager.MATCH_SYSTEM_ONLY;\n@@ -39,6 +40,7 @@ import android.Manifest;\n import android.Manifest.permission;\n import android.annotation.NonNull;\n import android.annotation.Nullable;\n+import android.annotation.RequiresPermission;\n import android.app.ActivityManager;\n import android.app.AppOpsManager;\n import android.app.PendingIntent;\n@@ -1063,8 +1065,10 @@ public class LocationManagerService extends ILocationManager.Stub implements\n \n     @Override\n     public void addProviderRequestListener(IProviderRequestListener listener) {\n-        for (LocationProviderManager manager : mProviderManagers) {\n-            manager.addProviderRequestListener(listener);\n+        if (mContext.checkCallingOrSelfPermission(INTERACT_ACROSS_USERS) == PERMISSION_GRANTED) {\n+            for (LocationProviderManager manager : mProviderManagers) {\n+                manager.addProviderRequestListener(listener);\n+            }\n         }\n     }\n \n",
    "added_lines": 6,
    "deleted_lines": 2,
    "changed_methods": "LocationManagerService::addProviderRequestListener"
   }
  ]
 },
 {
  "hash": "475c5c8015d9437456c1741e77d54d465bc45fb0",
  "commit": "Disallow privileged apps to bypass location restriction\n\nThis bypass was originally allowed to let restricted users who can't use\nlocation to pair bluetooth devices. This isn't needed anymore with the\nbluetooth permissions.\n\nTest: Set up restricted profile and pair bluetooth\n      Verify com.android.phone gets rejected\nBug: 230861324\nBug: 231496105\nMerged-In: Ib34c0b56ef52f5ee2deceb84b02cd0ff73d8181d\nChange-Id: Ib34c0b56ef52f5ee2deceb84b02cd0ff73d8181d\n(cherry picked from commit 807f4cfc80728313d04f95343e5aea14691aceb0)\nMerged-In: Ib34c0b56ef52f5ee2deceb84b02cd0ff73d8181d",
  "files": [
   {
    "filename": "AppOpsManager.java",
    "diff": "@@ -2463,8 +2463,8 @@ public class AppOpsManager {\n      * restriction} for a certain app-op.\n      */\n     private static RestrictionBypass[] sOpAllowSystemRestrictionBypass = new RestrictionBypass[] {\n-            new RestrictionBypass(true, false), //COARSE_LOCATION\n-            new RestrictionBypass(true, false), //FINE_LOCATION\n+            null, //COARSE_LOCATION\n+            null, //FINE_LOCATION\n             null, //GPS\n             null, //VIBRATE\n             null, //READ_CONTACTS\n",
    "added_lines": 2,
    "deleted_lines": 2,
    "changed_methods": ""
   }
  ]
 },
 {
  "hash": "9642f85f5b777567389007f222d031e9b81dc3b7",
  "commit": "Allow system server uid to bypass location restriction\n\nBlocking system server from giving itself location restriction doesn't\nmake much sense.\n\nTest: Disable, reboot, observe bootloop, apply patch, build, flash,\n          observe successful boot\nBug: 230861324\nBug: 231496105\nMerged-In: Ic869da4847e4f39896861f3bf6e83f6f6c76ea62\nChange-Id: Ic869da4847e4f39896861f3bf6e83f6f6c76ea62\n(cherry picked from commit 1dddfe1f703cab6e159fafad45f51e8bad207dba)\nMerged-In: Ic869da4847e4f39896861f3bf6e83f6f6c76ea62",
  "files": [
   {
    "filename": "AppOpsManager.java",
    "diff": "@@ -2463,8 +2463,8 @@ public class AppOpsManager {\n      * restriction} for a certain app-op.\n      */\n     private static RestrictionBypass[] sOpAllowSystemRestrictionBypass = new RestrictionBypass[] {\n-            null, //COARSE_LOCATION\n-            null, //FINE_LOCATION\n+            new RestrictionBypass(true, false, false), //COARSE_LOCATION\n+            new RestrictionBypass(true, false, false), //FINE_LOCATION\n             null, //GPS\n             null, //VIBRATE\n             null, //READ_CONTACTS\n@@ -2473,7 +2473,7 @@ public class AppOpsManager {\n             null, //WRITE_CALL_LOG\n             null, //READ_CALENDAR\n             null, //WRITE_CALENDAR\n-            new RestrictionBypass(true, false), //WIFI_SCAN\n+            new RestrictionBypass(false, true, false), //WIFI_SCAN\n             null, //POST_NOTIFICATION\n             null, //NEIGHBORING_CELLS\n             null, //CALL_PHONE\n@@ -2487,10 +2487,10 @@ public class AppOpsManager {\n             null, //READ_ICC_SMS\n             null, //WRITE_ICC_SMS\n             null, //WRITE_SETTINGS\n-            new RestrictionBypass(true, false), //SYSTEM_ALERT_WINDOW\n+            new RestrictionBypass(false, true, false), //SYSTEM_ALERT_WINDOW\n             null, //ACCESS_NOTIFICATIONS\n             null, //CAMERA\n-            new RestrictionBypass(false, true), //RECORD_AUDIO\n+            new RestrictionBypass(false, false, true), //RECORD_AUDIO\n             null, //PLAY_AUDIO\n             null, //READ_CLIPBOARD\n             null, //WRITE_CLIPBOARD\n@@ -2508,7 +2508,7 @@ public class AppOpsManager {\n             null, //MONITOR_HIGH_POWER_LOCATION\n             null, //GET_USAGE_STATS\n             null, //MUTE_MICROPHONE\n-            new RestrictionBypass(true, false), //TOAST_WINDOW\n+            new RestrictionBypass(false, true, false), //TOAST_WINDOW\n             null, //PROJECT_MEDIA\n             null, //ACTIVATE_VPN\n             null, //WALLPAPER\n@@ -2540,7 +2540,7 @@ public class AppOpsManager {\n             null, // ACCEPT_HANDOVER\n             null, // MANAGE_IPSEC_HANDOVERS\n             null, // START_FOREGROUND\n-            new RestrictionBypass(true, false), // BLUETOOTH_SCAN\n+            new RestrictionBypass(false, true, false), // BLUETOOTH_SCAN\n             null, // USE_BIOMETRIC\n             null, // ACTIVITY_RECOGNITION\n             null, // SMS_FINANCIAL_TRANSACTIONS\n@@ -3105,6 +3105,9 @@ public class AppOpsManager {\n      * @hide\n      */\n     public static class RestrictionBypass {\n+        /** Does the app need to be system uid to bypass the restriction */\n+        public boolean isSystemUid;\n+\n         /** Does the app need to be privileged to bypass the restriction */\n         public boolean isPrivileged;\n \n@@ -3114,12 +3117,14 @@ public class AppOpsManager {\n          */\n         public boolean isRecordAudioRestrictionExcept;\n \n-        public RestrictionBypass(boolean isPrivileged, boolean isRecordAudioRestrictionExcept) {\n+        public RestrictionBypass(boolean isSystemUid, boolean isPrivileged,\n+                boolean isRecordAudioRestrictionExcept) {\n+            this.isSystemUid = isSystemUid;\n             this.isPrivileged = isPrivileged;\n             this.isRecordAudioRestrictionExcept = isRecordAudioRestrictionExcept;\n         }\n \n-        public static RestrictionBypass UNRESTRICTED = new RestrictionBypass(true, true);\n+        public static RestrictionBypass UNRESTRICTED = new RestrictionBypass(false, true, true);\n     }\n \n     /**\n",
    "added_lines": 14,
    "deleted_lines": 9,
    "changed_methods": "AppOpsManager::RestrictionBypass::RestrictionBypass, AppOpsManager::RestrictionBypass::RestrictionBypass"
   },
   {
    "filename": "AppOpsService.java",
    "diff": "@@ -4502,8 +4502,9 @@ public class AppOpsService extends IAppOpsService.Stub {\n      * @return The restriction matching the package\n      */\n     private RestrictionBypass getBypassforPackage(@NonNull AndroidPackage pkg) {\n-        return new RestrictionBypass(pkg.isPrivileged(), mContext.checkPermission(\n-                android.Manifest.permission.EXEMPT_FROM_AUDIO_RECORD_RESTRICTIONS, -1, pkg.getUid())\n+        return new RestrictionBypass(pkg.getUid() == Process.SYSTEM_UID, pkg.isPrivileged(),\n+                mContext.checkPermission(android.Manifest.permission\n+                        .EXEMPT_FROM_AUDIO_RECORD_RESTRICTIONS, -1, pkg.getUid())\n                 == PackageManager.PERMISSION_GRANTED);\n     }\n \n@@ -4785,6 +4786,9 @@ public class AppOpsService extends IAppOpsService.Stub {\n                 if (opBypass != null) {\n                     // If we are the system, bypass user restrictions for certain codes\n                     synchronized (this) {\n+                        if (opBypass.isSystemUid && appBypass != null && appBypass.isSystemUid) {\n+                            return false;\n+                        }\n                         if (opBypass.isPrivileged && appBypass != null && appBypass.isPrivileged) {\n                             return false;\n                         }\n",
    "added_lines": 6,
    "deleted_lines": 2,
    "changed_methods": "AppOpsService::isOpRestrictedLocked, AppOpsService::getBypassforPackage"
   }
  ]
 },
 {
  "hash": "9642f85f5b777567389007f222d031e9b81dc3b7",
  "commit": "Allow system server uid to bypass location restriction\n\nBlocking system server from giving itself location restriction doesn't\nmake much sense.\n\nTest: Disable, reboot, observe bootloop, apply patch, build, flash,\n          observe successful boot\nBug: 230861324\nBug: 231496105\nMerged-In: Ic869da4847e4f39896861f3bf6e83f6f6c76ea62\nChange-Id: Ic869da4847e4f39896861f3bf6e83f6f6c76ea62\n(cherry picked from commit 1dddfe1f703cab6e159fafad45f51e8bad207dba)\nMerged-In: Ic869da4847e4f39896861f3bf6e83f6f6c76ea62",
  "files": [
   {
    "filename": "AppOpsManager.java",
    "diff": "@@ -2463,8 +2463,8 @@ public class AppOpsManager {\n      * restriction} for a certain app-op.\n      */\n     private static RestrictionBypass[] sOpAllowSystemRestrictionBypass = new RestrictionBypass[] {\n-            null, //COARSE_LOCATION\n-            null, //FINE_LOCATION\n+            new RestrictionBypass(true, false, false), //COARSE_LOCATION\n+            new RestrictionBypass(true, false, false), //FINE_LOCATION\n             null, //GPS\n             null, //VIBRATE\n             null, //READ_CONTACTS\n@@ -2473,7 +2473,7 @@ public class AppOpsManager {\n             null, //WRITE_CALL_LOG\n             null, //READ_CALENDAR\n             null, //WRITE_CALENDAR\n-            new RestrictionBypass(true, false), //WIFI_SCAN\n+            new RestrictionBypass(false, true, false), //WIFI_SCAN\n             null, //POST_NOTIFICATION\n             null, //NEIGHBORING_CELLS\n             null, //CALL_PHONE\n@@ -2487,10 +2487,10 @@ public class AppOpsManager {\n             null, //READ_ICC_SMS\n             null, //WRITE_ICC_SMS\n             null, //WRITE_SETTINGS\n-            new RestrictionBypass(true, false), //SYSTEM_ALERT_WINDOW\n+            new RestrictionBypass(false, true, false), //SYSTEM_ALERT_WINDOW\n             null, //ACCESS_NOTIFICATIONS\n             null, //CAMERA\n-            new RestrictionBypass(false, true), //RECORD_AUDIO\n+            new RestrictionBypass(false, false, true), //RECORD_AUDIO\n             null, //PLAY_AUDIO\n             null, //READ_CLIPBOARD\n             null, //WRITE_CLIPBOARD\n@@ -2508,7 +2508,7 @@ public class AppOpsManager {\n             null, //MONITOR_HIGH_POWER_LOCATION\n             null, //GET_USAGE_STATS\n             null, //MUTE_MICROPHONE\n-            new RestrictionBypass(true, false), //TOAST_WINDOW\n+            new RestrictionBypass(false, true, false), //TOAST_WINDOW\n             null, //PROJECT_MEDIA\n             null, //ACTIVATE_VPN\n             null, //WALLPAPER\n@@ -2540,7 +2540,7 @@ public class AppOpsManager {\n             null, // ACCEPT_HANDOVER\n             null, // MANAGE_IPSEC_HANDOVERS\n             null, // START_FOREGROUND\n-            new RestrictionBypass(true, false), // BLUETOOTH_SCAN\n+            new RestrictionBypass(false, true, false), // BLUETOOTH_SCAN\n             null, // USE_BIOMETRIC\n             null, // ACTIVITY_RECOGNITION\n             null, // SMS_FINANCIAL_TRANSACTIONS\n@@ -3105,6 +3105,9 @@ public class AppOpsManager {\n      * @hide\n      */\n     public static class RestrictionBypass {\n+        /** Does the app need to be system uid to bypass the restriction */\n+        public boolean isSystemUid;\n+\n         /** Does the app need to be privileged to bypass the restriction */\n         public boolean isPrivileged;\n \n@@ -3114,12 +3117,14 @@ public class AppOpsManager {\n          */\n         public boolean isRecordAudioRestrictionExcept;\n \n-        public RestrictionBypass(boolean isPrivileged, boolean isRecordAudioRestrictionExcept) {\n+        public RestrictionBypass(boolean isSystemUid, boolean isPrivileged,\n+                boolean isRecordAudioRestrictionExcept) {\n+            this.isSystemUid = isSystemUid;\n             this.isPrivileged = isPrivileged;\n             this.isRecordAudioRestrictionExcept = isRecordAudioRestrictionExcept;\n         }\n \n-        public static RestrictionBypass UNRESTRICTED = new RestrictionBypass(true, true);\n+        public static RestrictionBypass UNRESTRICTED = new RestrictionBypass(false, true, true);\n     }\n \n     /**\n",
    "added_lines": 14,
    "deleted_lines": 9,
    "changed_methods": "AppOpsManager::RestrictionBypass::RestrictionBypass, AppOpsManager::RestrictionBypass::RestrictionBypass"
   },
   {
    "filename": "AppOpsService.java",
    "diff": "@@ -4502,8 +4502,9 @@ public class AppOpsService extends IAppOpsService.Stub {\n      * @return The restriction matching the package\n      */\n     private RestrictionBypass getBypassforPackage(@NonNull AndroidPackage pkg) {\n-        return new RestrictionBypass(pkg.isPrivileged(), mContext.checkPermission(\n-                android.Manifest.permission.EXEMPT_FROM_AUDIO_RECORD_RESTRICTIONS, -1, pkg.getUid())\n+        return new RestrictionBypass(pkg.getUid() == Process.SYSTEM_UID, pkg.isPrivileged(),\n+                mContext.checkPermission(android.Manifest.permission\n+                        .EXEMPT_FROM_AUDIO_RECORD_RESTRICTIONS, -1, pkg.getUid())\n                 == PackageManager.PERMISSION_GRANTED);\n     }\n \n@@ -4785,6 +4786,9 @@ public class AppOpsService extends IAppOpsService.Stub {\n                 if (opBypass != null) {\n                     // If we are the system, bypass user restrictions for certain codes\n                     synchronized (this) {\n+                        if (opBypass.isSystemUid && appBypass != null && appBypass.isSystemUid) {\n+                            return false;\n+                        }\n                         if (opBypass.isPrivileged && appBypass != null && appBypass.isPrivileged) {\n                             return false;\n                         }\n",
    "added_lines": 6,
    "deleted_lines": 2,
    "changed_methods": "AppOpsService::isOpRestrictedLocked, AppOpsService::getBypassforPackage"
   }
  ]
 },
 {
  "hash": "092156bc632dce1a6a3c56fcec8f45d6cce25afb",
  "commit": "Make CheckOp return allowed if any attr tag for a package is excluded\n\ncheckOp doesn't support checking against an attribution tag, this causes\nsome checkOps to fail when a noteOp is successful meaning that a\npreflight routine might fail before delivering data and doing the more\nprecise check. This only affects when a user restriction is applied and\nthere are excepted package+tag.\n\nTest: Checkop with test app\nBug: 232502990\nBug: 231496105\nMerged-In: Idcf5ac9a5401ad8089f5873da1f978fdf9258b5a\nChange-Id: Idcf5ac9a5401ad8089f5873da1f978fdf9258b5a\n(cherry picked from commit 61c2d0291bd5b9b39a1d7db7454b3d7c630e7de9)\n(cherry picked from commit 25f1b6a1ac5c71ebafe4b9235829aa3a79d1dd21)\nMerged-In: Idcf5ac9a5401ad8089f5873da1f978fdf9258b5a",
  "files": [
   {
    "filename": "AppOpsService.java",
    "diff": "@@ -3242,7 +3242,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n             return AppOpsManager.MODE_IGNORED;\n         }\n         synchronized (this) {\n-            if (isOpRestrictedLocked(uid, code, packageName, attributionTag, pvr.bypass)) {\n+            if (isOpRestrictedLocked(uid, code, packageName, attributionTag, pvr.bypass, true)) {\n                 return AppOpsManager.MODE_IGNORED;\n             }\n             code = AppOpsManager.opToSwitch(code);\n@@ -3459,7 +3459,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n \n             final int switchCode = AppOpsManager.opToSwitch(code);\n             final UidState uidState = ops.uidState;\n-            if (isOpRestrictedLocked(uid, code, packageName, attributionTag, pvr.bypass)) {\n+            if (isOpRestrictedLocked(uid, code, packageName, attributionTag, pvr.bypass, false)) {\n                 attributedOp.rejected(uidState.state, flags);\n                 scheduleOpNotedIfNeededLocked(code, uid, packageName, attributionTag, flags,\n                         AppOpsManager.MODE_IGNORED);\n@@ -3973,7 +3973,8 @@ public class AppOpsService extends IAppOpsService.Stub {\n             final Op op = getOpLocked(ops, code, uid, true);\n             final AttributedOp attributedOp = op.getOrCreateAttribution(op, attributionTag);\n             final UidState uidState = ops.uidState;\n-            isRestricted = isOpRestrictedLocked(uid, code, packageName, attributionTag, pvr.bypass);\n+            isRestricted = isOpRestrictedLocked(uid, code, packageName, attributionTag, pvr.bypass,\n+                    false);\n             final int switchCode = AppOpsManager.opToSwitch(code);\n             // If there is a non-default per UID policy (we set UID op mode only if\n             // non-default) it takes over, otherwise use the per package policy.\n@@ -4764,7 +4765,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n     }\n \n     private boolean isOpRestrictedLocked(int uid, int code, String packageName,\n-            String attributionTag, @Nullable RestrictionBypass appBypass) {\n+            String attributionTag, @Nullable RestrictionBypass appBypass, boolean isCheckOp) {\n         int restrictionSetCount = mOpGlobalRestrictions.size();\n \n         for (int i = 0; i < restrictionSetCount; i++) {\n@@ -4781,7 +4782,8 @@ public class AppOpsService extends IAppOpsService.Stub {\n             // For each client, check that the given op is not restricted, or that the given\n             // package is exempt from the restriction.\n             ClientUserRestrictionState restrictionState = mOpUserRestrictions.valueAt(i);\n-            if (restrictionState.hasRestriction(code, packageName, attributionTag, userHandle)) {\n+            if (restrictionState.hasRestriction(code, packageName, attributionTag, userHandle,\n+                    isCheckOp)) {\n                 RestrictionBypass opBypass = opAllowSystemBypassRestriction(code);\n                 if (opBypass != null) {\n                     // If we are the system, bypass user restrictions for certain codes\n@@ -7141,7 +7143,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n         }\n \n         public boolean hasRestriction(int restriction, String packageName, String attributionTag,\n-                int userId) {\n+                int userId, boolean isCheckOp) {\n             if (perUserRestrictions == null) {\n                 return false;\n             }\n@@ -7160,6 +7162,9 @@ public class AppOpsService extends IAppOpsService.Stub {\n                 return true;\n             }\n \n+            if (isCheckOp) {\n+                return !perUserExclusions.includes(packageName);\n+            }\n             return !perUserExclusions.contains(packageName, attributionTag);\n         }\n \n@@ -7326,7 +7331,8 @@ public class AppOpsService extends IAppOpsService.Stub {\n                 int numRestrictions = mOpUserRestrictions.size();\n                 for (int i = 0; i < numRestrictions; i++) {\n                     if (mOpUserRestrictions.valueAt(i)\n-                            .hasRestriction(code, pkg, attributionTag, user.getIdentifier())) {\n+                            .hasRestriction(code, pkg, attributionTag, user.getIdentifier(),\n+                                    false)) {\n                         number++;\n                     }\n                 }\n",
    "added_lines": 13,
    "deleted_lines": 7,
    "changed_methods": "AppOpsService::startOperationUnchecked, AppOpsService::ClientUserRestrictionState::hasRestriction, AppOpsService::isOpRestrictedLocked, AppOpsService::checkOperationUnchecked, AppOpsService::noteOperationUnchecked, AppOpsService::AppOpsManagerInternalImpl::getOpRestrictionCount, AppOpsService::isOpRestrictedLocked, AppOpsService::ClientUserRestrictionState::hasRestriction"
   }
  ]
 },
 {
  "hash": "e9e40c316783a0f9529ea5203096e8bceba6d26e",
  "commit": "Remove package title from notification access confirmation intent\n\nBug: 228178437\nTest: Manually confirmed on an application\nChange-Id: Idad6dc0c71d7b39de0bd9e4ad922b5e6020a6184\nMerged-In: Idad6dc0c71d7b39de0bd9e4ad922b5e6020a6184\n(cherry picked from commit e86cdf4ba16c68d3fe361eec24c99059aeef8536)\nMerged-In: Idad6dc0c71d7b39de0bd9e4ad922b5e6020a6184",
  "files": [
   {
    "filename": "NotificationAccessConfirmationActivityContract.java",
    "diff": "@@ -28,18 +28,15 @@ import com.android.internal.R;\n public final class NotificationAccessConfirmationActivityContract {\n     public static final String EXTRA_USER_ID = \"user_id\";\n     public static final String EXTRA_COMPONENT_NAME = \"component_name\";\n-    public static final String EXTRA_PACKAGE_TITLE = \"package_title\";\n \n     /**\n      * Creates a launcher intent for NotificationAccessConfirmationActivity.\n      */\n-    public static Intent launcherIntent(Context context, int userId, ComponentName component,\n-            String packageTitle) {\n+    public static Intent launcherIntent(Context context, int userId, ComponentName component) {\n         return new Intent()\n                 .setComponent(ComponentName.unflattenFromString(context.getString(\n                         R.string.config_notificationAccessConfirmationActivity)))\n                 .putExtra(EXTRA_USER_ID, userId)\n-                .putExtra(EXTRA_COMPONENT_NAME, component)\n-                .putExtra(EXTRA_PACKAGE_TITLE, packageTitle);\n+                .putExtra(EXTRA_COMPONENT_NAME, component);\n     }\n }\n",
    "added_lines": 2,
    "deleted_lines": 5,
    "changed_methods": "NotificationAccessConfirmationActivityContract::launcherIntent, NotificationAccessConfirmationActivityContract::launcherIntent"
   },
   {
    "filename": "CompanionDeviceManagerService.java",
    "diff": "@@ -74,7 +74,6 @@ import android.content.IntentFilter;\n import android.content.SharedPreferences;\n import android.content.pm.FeatureInfo;\n import android.content.pm.PackageInfo;\n-import android.content.pm.PackageItemInfo;\n import android.content.pm.PackageManager;\n import android.content.pm.PackageManagerInternal;\n import android.content.pm.ResolveInfo;\n@@ -556,20 +555,12 @@ public class CompanionDeviceManagerService extends SystemService implements Bind\n             String callingPackage = component.getPackageName();\n             checkCanCallNotificationApi(callingPackage);\n             int userId = getCallingUserId();\n-            String packageTitle = BidiFormatter.getInstance().unicodeWrap(\n-                    getPackageInfo(callingPackage, userId)\n-                            .applicationInfo\n-                            .loadSafeLabel(getContext().getPackageManager(),\n-                                    PackageItemInfo.DEFAULT_MAX_LABEL_SIZE_PX,\n-                                    PackageItemInfo.SAFE_LABEL_FLAG_TRIM\n-                                            | PackageItemInfo.SAFE_LABEL_FLAG_FIRST_LINE)\n-                            .toString());\n             final long identity = Binder.clearCallingIdentity();\n             try {\n                 return PendingIntent.getActivityAsUser(getContext(),\n                         0 /* request code */,\n                         NotificationAccessConfirmationActivityContract.launcherIntent(\n-                                getContext(), userId, component, packageTitle),\n+                                getContext(), userId, component),\n                         PendingIntent.FLAG_IMMUTABLE | PendingIntent.FLAG_ONE_SHOT\n                                 | PendingIntent.FLAG_CANCEL_CURRENT,\n                         null /* options */,\n",
    "added_lines": 1,
    "deleted_lines": 10,
    "changed_methods": "CompanionDeviceManagerService::CompanionDeviceManagerImpl::requestNotificationAccess"
   }
  ]
 },
 {
  "hash": "e9e40c316783a0f9529ea5203096e8bceba6d26e",
  "commit": "Remove package title from notification access confirmation intent\n\nBug: 228178437\nTest: Manually confirmed on an application\nChange-Id: Idad6dc0c71d7b39de0bd9e4ad922b5e6020a6184\nMerged-In: Idad6dc0c71d7b39de0bd9e4ad922b5e6020a6184\n(cherry picked from commit e86cdf4ba16c68d3fe361eec24c99059aeef8536)\nMerged-In: Idad6dc0c71d7b39de0bd9e4ad922b5e6020a6184",
  "files": [
   {
    "filename": "NotificationAccessConfirmationActivityContract.java",
    "diff": "@@ -28,18 +28,15 @@ import com.android.internal.R;\n public final class NotificationAccessConfirmationActivityContract {\n     public static final String EXTRA_USER_ID = \"user_id\";\n     public static final String EXTRA_COMPONENT_NAME = \"component_name\";\n-    public static final String EXTRA_PACKAGE_TITLE = \"package_title\";\n \n     /**\n      * Creates a launcher intent for NotificationAccessConfirmationActivity.\n      */\n-    public static Intent launcherIntent(Context context, int userId, ComponentName component,\n-            String packageTitle) {\n+    public static Intent launcherIntent(Context context, int userId, ComponentName component) {\n         return new Intent()\n                 .setComponent(ComponentName.unflattenFromString(context.getString(\n                         R.string.config_notificationAccessConfirmationActivity)))\n                 .putExtra(EXTRA_USER_ID, userId)\n-                .putExtra(EXTRA_COMPONENT_NAME, component)\n-                .putExtra(EXTRA_PACKAGE_TITLE, packageTitle);\n+                .putExtra(EXTRA_COMPONENT_NAME, component);\n     }\n }\n",
    "added_lines": 2,
    "deleted_lines": 5,
    "changed_methods": "NotificationAccessConfirmationActivityContract::launcherIntent, NotificationAccessConfirmationActivityContract::launcherIntent"
   },
   {
    "filename": "CompanionDeviceManagerService.java",
    "diff": "@@ -74,7 +74,6 @@ import android.content.IntentFilter;\n import android.content.SharedPreferences;\n import android.content.pm.FeatureInfo;\n import android.content.pm.PackageInfo;\n-import android.content.pm.PackageItemInfo;\n import android.content.pm.PackageManager;\n import android.content.pm.PackageManagerInternal;\n import android.content.pm.ResolveInfo;\n@@ -556,20 +555,12 @@ public class CompanionDeviceManagerService extends SystemService implements Bind\n             String callingPackage = component.getPackageName();\n             checkCanCallNotificationApi(callingPackage);\n             int userId = getCallingUserId();\n-            String packageTitle = BidiFormatter.getInstance().unicodeWrap(\n-                    getPackageInfo(callingPackage, userId)\n-                            .applicationInfo\n-                            .loadSafeLabel(getContext().getPackageManager(),\n-                                    PackageItemInfo.DEFAULT_MAX_LABEL_SIZE_PX,\n-                                    PackageItemInfo.SAFE_LABEL_FLAG_TRIM\n-                                            | PackageItemInfo.SAFE_LABEL_FLAG_FIRST_LINE)\n-                            .toString());\n             final long identity = Binder.clearCallingIdentity();\n             try {\n                 return PendingIntent.getActivityAsUser(getContext(),\n                         0 /* request code */,\n                         NotificationAccessConfirmationActivityContract.launcherIntent(\n-                                getContext(), userId, component, packageTitle),\n+                                getContext(), userId, component),\n                         PendingIntent.FLAG_IMMUTABLE | PendingIntent.FLAG_ONE_SHOT\n                                 | PendingIntent.FLAG_CANCEL_CURRENT,\n                         null /* options */,\n",
    "added_lines": 1,
    "deleted_lines": 10,
    "changed_methods": "CompanionDeviceManagerService::CompanionDeviceManagerImpl::requestNotificationAccess"
   }
  ]
 },
 {
  "hash": "b1f5b79a62453d38179ae1fca1b89797ac03bd1b",
  "commit": "Stop using invalid URL to prevent unexpected crash\n\nVerify the input PAC Uri before performing follow-up actions.\n\nCheck if the URL is a valid URL to filter some invalid URLs since\nthese invalid URLs could not fall into any subclass of existing\nURLConnections. When the PAC Uri is other invalid URL scheme, it\nwill cause an UnsupportedOperationException if there is no proper\nsubclass that implements the openConnection() method.\nA malformed URL may crash the system.\n\nEven it's a valid URL, some subclasses(e.g. JarURLConnection)\nmay not have openConnection() implemented. It will also hit the\nproblem, so convert the possbile exception from openConnection()\nto re-throw it to IOException which is handled in the existing\ncode.\n\nBug: 219498290\nTest: atest FrameworksNetTests CtsNetTestCases\nTest: Test with malformed URL\nChange-Id: I22903414380b62051f514e43b93af992f45740b4\n(cherry picked from commit 6390b37a3b32fc7583154d53fda3af8fbd95f59f)\nMerged-In: I22903414380b62051f514e43b93af992f45740b4\n(cherry picked from commit fe57c5bf892c54c495cacd23492532bfa9a63dd7)\nMerged-In: I22903414380b62051f514e43b93af992f45740b4",
  "files": [
   {
    "filename": "PacProxyService.java",
    "diff": "@@ -44,6 +44,7 @@ import android.os.SystemClock;\n import android.os.SystemProperties;\n import android.provider.Settings;\n import android.util.Log;\n+import android.webkit.URLUtil;\n \n import com.android.internal.annotations.GuardedBy;\n import com.android.internal.util.TrafficStatsConstants;\n@@ -232,8 +233,22 @@ public class PacProxyService extends IPacProxyManager.Stub {\n      * @throws IOException if the URL is malformed, or the PAC file is too big.\n      */\n     private static String get(Uri pacUri) throws IOException {\n-        URL url = new URL(pacUri.toString());\n-        URLConnection urlConnection = url.openConnection(java.net.Proxy.NO_PROXY);\n+        if (!URLUtil.isValidUrl(pacUri.toString()))  {\n+            throw new IOException(\"Malformed URL:\" + pacUri);\n+        }\n+\n+        final URL url = new URL(pacUri.toString());\n+        URLConnection urlConnection;\n+        try {\n+            urlConnection = url.openConnection(java.net.Proxy.NO_PROXY);\n+            // Catch the possible exceptions and rethrow as IOException to not to crash the system\n+            // for illegal input.\n+        } catch (IllegalArgumentException e) {\n+            throw new IOException(\"Incorrect proxy type for \" + pacUri);\n+        } catch (UnsupportedOperationException e) {\n+            throw new IOException(\"Unsupported URL connection type for \" + pacUri);\n+        }\n+\n         long contentLength = -1;\n         try {\n             contentLength = Long.parseLong(urlConnection.getHeaderField(\"Content-Length\"));\n",
    "added_lines": 17,
    "deleted_lines": 2,
    "changed_methods": "PacProxyService::get"
   }
  ]
 },
 {
  "hash": "7b5fce10d191dd819048edee9ed01433efea9e72",
  "commit": "Only allow the system server to connect to sync adapters\n\nBug: 203229608\nTest: Manual test with changing the check logic + debug log\nChange-Id: If18009f61360564d02dcda9b1e5fa15685e3250f\n(cherry picked from commit 58270527d11ac7e5f07d337a402d8edf046a63ee)\n(cherry picked from commit 7d1397a54475ed7fee632339ef7c60b432f0fbff)\nMerged-In: If18009f61360564d02dcda9b1e5fa15685e3250f",
  "files": [
   {
    "filename": "AbstractThreadedSyncAdapter.java",
    "diff": "@@ -21,6 +21,7 @@ import static com.android.internal.util.function.pooled.PooledLambda.obtainMessa\n import android.accounts.Account;\n import android.annotation.MainThread;\n import android.annotation.NonNull;\n+import android.os.Binder;\n import android.os.Build;\n import android.os.Bundle;\n import android.os.Handler;\n@@ -171,8 +172,20 @@ public abstract class AbstractThreadedSyncAdapter {\n     }\n \n     private class ISyncAdapterImpl extends ISyncAdapter.Stub {\n+        private boolean isCallerSystem() {\n+            final long callingUid = Binder.getCallingUid();\n+            if (callingUid != Process.SYSTEM_UID) {\n+                android.util.EventLog.writeEvent(0x534e4554, \"203229608\", -1, \"\");\n+                return false;\n+            }\n+            return true;\n+        }\n+\n         @Override\n         public void onUnsyncableAccount(ISyncAdapterUnsyncableAccountCallback cb) {\n+            if (!isCallerSystem()) {\n+                return;\n+            }\n             Handler.getMain().sendMessage(obtainMessage(\n                     AbstractThreadedSyncAdapter::handleOnUnsyncableAccount,\n                     AbstractThreadedSyncAdapter.this, cb));\n@@ -181,12 +194,16 @@ public abstract class AbstractThreadedSyncAdapter {\n         @Override\n         public void startSync(ISyncContext syncContext, String authority, Account account,\n                 Bundle extras) {\n+            if (!isCallerSystem()) {\n+                return;\n+            }\n             if (ENABLE_LOG) {\n                 if (extras != null) {\n                     extras.size(); // Unparcel so its toString() will show the contents.\n                 }\n                 Log.d(TAG, \"startSync() start \" + authority + \" \" + account + \" \" + extras);\n             }\n+\n             try {\n                 final SyncContext syncContextClient = new SyncContext(syncContext);\n \n@@ -242,6 +259,9 @@ public abstract class AbstractThreadedSyncAdapter {\n \n         @Override\n         public void cancelSync(ISyncContext syncContext) {\n+            if (!isCallerSystem()) {\n+                return;\n+            }\n             try {\n                 // synchronize to make sure that mSyncThreads doesn't change between when we\n                 // check it and when we use it\n",
    "added_lines": 20,
    "deleted_lines": 0,
    "changed_methods": "AbstractThreadedSyncAdapter::ISyncAdapterImpl::isCallerSystem, AbstractThreadedSyncAdapter::ISyncAdapterImpl::onUnsyncableAccount, AbstractThreadedSyncAdapter::ISyncAdapterImpl::cancelSync, AbstractThreadedSyncAdapter::ISyncAdapterImpl::startSync"
   }
  ]
 },
 {
  "hash": "57d3806348f9bf2c8d3b33e171869bdd46515bcd",
  "commit": "Allow apps receiving MediaSession callbacks to start FGS from BG.\n\nIf the app invoking the MediaSession callbacks is capable of\nstarting a FGS from background, then also allow the target app\nreceiving the callbacks to start FGS from background.\n\nBug: 221873343\nTest: manual\nChange-Id: I98de12b5410c3f0f70d7d2be12bef3e6d0e1bf73\nMerged-In: I98de12b5410c3f0f70d7d2be12bef3e6d0e1bf73\n(cherry picked from commit 6e2b1434733f1168067506c0967ced86772220de)",
  "files": [
   {
    "filename": "MediaSessionRecord.java",
    "diff": "@@ -1155,6 +1155,9 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR\n         public void sendCommand(String packageName, int pid, int uid, String command, Bundle args,\n                 ResultReceiver cb) {\n             try {\n+                final String reason = TAG + \":\" + command;\n+                mService.tempAllowlistTargetPkgIfPossible(getUid(), getPackageName(),\n+                        pid, uid, packageName, reason);\n                 mCb.onCommand(packageName, pid, uid, command, args, cb);\n             } catch (RemoteException e) {\n                 Log.e(TAG, \"Remote failure in sendCommand.\", e);\n@@ -1164,6 +1167,9 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR\n         public void sendCustomAction(String packageName, int pid, int uid, String action,\n                 Bundle args) {\n             try {\n+                final String reason = TAG + \":custom-\" + action;\n+                mService.tempAllowlistTargetPkgIfPossible(getUid(), getPackageName(),\n+                        pid, uid, packageName, reason);\n                 mCb.onCustomAction(packageName, pid, uid, action, args);\n             } catch (RemoteException e) {\n                 Log.e(TAG, \"Remote failure in sendCustomAction.\", e);\n@@ -1172,6 +1178,9 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR\n \n         public void prepare(String packageName, int pid, int uid) {\n             try {\n+                final String reason = TAG + \":prepare\";\n+                mService.tempAllowlistTargetPkgIfPossible(getUid(), getPackageName(),\n+                        pid, uid, packageName, reason);\n                 mCb.onPrepare(packageName, pid, uid);\n             } catch (RemoteException e) {\n                 Log.e(TAG, \"Remote failure in prepare.\", e);\n@@ -1181,6 +1190,9 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR\n         public void prepareFromMediaId(String packageName, int pid, int uid, String mediaId,\n                 Bundle extras) {\n             try {\n+                final String reason = TAG + \":prepareFromMediaId\";\n+                mService.tempAllowlistTargetPkgIfPossible(getUid(), getPackageName(),\n+                        pid, uid, packageName, reason);\n                 mCb.onPrepareFromMediaId(packageName, pid, uid, mediaId, extras);\n             } catch (RemoteException e) {\n                 Log.e(TAG, \"Remote failure in prepareFromMediaId.\", e);\n@@ -1190,6 +1202,9 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR\n         public void prepareFromSearch(String packageName, int pid, int uid, String query,\n                 Bundle extras) {\n             try {\n+                final String reason = TAG + \":prepareFromSearch\";\n+                mService.tempAllowlistTargetPkgIfPossible(getUid(), getPackageName(),\n+                        pid, uid, packageName, reason);\n                 mCb.onPrepareFromSearch(packageName, pid, uid, query, extras);\n             } catch (RemoteException e) {\n                 Log.e(TAG, \"Remote failure in prepareFromSearch.\", e);\n@@ -1198,6 +1213,9 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR\n \n         public void prepareFromUri(String packageName, int pid, int uid, Uri uri, Bundle extras) {\n             try {\n+                final String reason = TAG + \":prepareFromUri\";\n+                mService.tempAllowlistTargetPkgIfPossible(getUid(), getPackageName(),\n+                        pid, uid, packageName, reason);\n                 mCb.onPrepareFromUri(packageName, pid, uid, uri, extras);\n             } catch (RemoteException e) {\n                 Log.e(TAG, \"Remote failure in prepareFromUri.\", e);\n@@ -1206,6 +1224,9 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR\n \n         public void play(String packageName, int pid, int uid) {\n             try {\n+                final String reason = TAG + \":play\";\n+                mService.tempAllowlistTargetPkgIfPossible(getUid(), getPackageName(),\n+                        pid, uid, packageName, reason);\n                 mCb.onPlay(packageName, pid, uid);\n             } catch (RemoteException e) {\n                 Log.e(TAG, \"Remote failure in play.\", e);\n@@ -1215,6 +1236,9 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR\n         public void playFromMediaId(String packageName, int pid, int uid, String mediaId,\n                 Bundle extras) {\n             try {\n+                final String reason = TAG + \":playFromMediaId\";\n+                mService.tempAllowlistTargetPkgIfPossible(getUid(), getPackageName(),\n+                        pid, uid, packageName, reason);\n                 mCb.onPlayFromMediaId(packageName, pid, uid, mediaId, extras);\n             } catch (RemoteException e) {\n                 Log.e(TAG, \"Remote failure in playFromMediaId.\", e);\n@@ -1224,6 +1248,9 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR\n         public void playFromSearch(String packageName, int pid, int uid, String query,\n                 Bundle extras) {\n             try {\n+                final String reason = TAG + \":playFromSearch\";\n+                mService.tempAllowlistTargetPkgIfPossible(getUid(), getPackageName(),\n+                        pid, uid, packageName, reason);\n                 mCb.onPlayFromSearch(packageName, pid, uid, query, extras);\n             } catch (RemoteException e) {\n                 Log.e(TAG, \"Remote failure in playFromSearch.\", e);\n@@ -1232,6 +1259,9 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR\n \n         public void playFromUri(String packageName, int pid, int uid, Uri uri, Bundle extras) {\n             try {\n+                final String reason = TAG + \":playFromUri\";\n+                mService.tempAllowlistTargetPkgIfPossible(getUid(), getPackageName(),\n+                        pid, uid, packageName, reason);\n                 mCb.onPlayFromUri(packageName, pid, uid, uri, extras);\n             } catch (RemoteException e) {\n                 Log.e(TAG, \"Remote failure in playFromUri.\", e);\n@@ -1240,6 +1270,9 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR\n \n         public void skipToTrack(String packageName, int pid, int uid, long id) {\n             try {\n+                final String reason = TAG + \":skipToTrack\";\n+                mService.tempAllowlistTargetPkgIfPossible(getUid(), getPackageName(),\n+                        pid, uid, packageName, reason);\n                 mCb.onSkipToTrack(packageName, pid, uid, id);\n             } catch (RemoteException e) {\n                 Log.e(TAG, \"Remote failure in skipToTrack\", e);\n@@ -1248,6 +1281,9 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR\n \n         public void pause(String packageName, int pid, int uid) {\n             try {\n+                final String reason = TAG + \":pause\";\n+                mService.tempAllowlistTargetPkgIfPossible(getUid(), getPackageName(),\n+                        pid, uid, packageName, reason);\n                 mCb.onPause(packageName, pid, uid);\n             } catch (RemoteException e) {\n                 Log.e(TAG, \"Remote failure in pause.\", e);\n@@ -1256,6 +1292,9 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR\n \n         public void stop(String packageName, int pid, int uid) {\n             try {\n+                final String reason = TAG + \":stop\";\n+                mService.tempAllowlistTargetPkgIfPossible(getUid(), getPackageName(),\n+                        pid, uid, packageName, reason);\n                 mCb.onStop(packageName, pid, uid);\n             } catch (RemoteException e) {\n                 Log.e(TAG, \"Remote failure in stop.\", e);\n@@ -1264,6 +1303,9 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR\n \n         public void next(String packageName, int pid, int uid) {\n             try {\n+                final String reason = TAG + \":next\";\n+                mService.tempAllowlistTargetPkgIfPossible(getUid(), getPackageName(),\n+                        pid, uid, packageName, reason);\n                 mCb.onNext(packageName, pid, uid);\n             } catch (RemoteException e) {\n                 Log.e(TAG, \"Remote failure in next.\", e);\n@@ -1272,6 +1314,9 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR\n \n         public void previous(String packageName, int pid, int uid) {\n             try {\n+                final String reason = TAG + \":previous\";\n+                mService.tempAllowlistTargetPkgIfPossible(getUid(), getPackageName(),\n+                        pid, uid, packageName, reason);\n                 mCb.onPrevious(packageName, pid, uid);\n             } catch (RemoteException e) {\n                 Log.e(TAG, \"Remote failure in previous.\", e);\n@@ -1280,6 +1325,9 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR\n \n         public void fastForward(String packageName, int pid, int uid) {\n             try {\n+                final String reason = TAG + \":fastForward\";\n+                mService.tempAllowlistTargetPkgIfPossible(getUid(), getPackageName(),\n+                        pid, uid, packageName, reason);\n                 mCb.onFastForward(packageName, pid, uid);\n             } catch (RemoteException e) {\n                 Log.e(TAG, \"Remote failure in fastForward.\", e);\n@@ -1288,6 +1336,9 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR\n \n         public void rewind(String packageName, int pid, int uid) {\n             try {\n+                final String reason = TAG + \":rewind\";\n+                mService.tempAllowlistTargetPkgIfPossible(getUid(), getPackageName(),\n+                        pid, uid, packageName, reason);\n                 mCb.onRewind(packageName, pid, uid);\n             } catch (RemoteException e) {\n                 Log.e(TAG, \"Remote failure in rewind.\", e);\n@@ -1296,6 +1347,9 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR\n \n         public void seekTo(String packageName, int pid, int uid, long pos) {\n             try {\n+                final String reason = TAG + \":seekTo\";\n+                mService.tempAllowlistTargetPkgIfPossible(getUid(), getPackageName(),\n+                        pid, uid, packageName, reason);\n                 mCb.onSeekTo(packageName, pid, uid, pos);\n             } catch (RemoteException e) {\n                 Log.e(TAG, \"Remote failure in seekTo.\", e);\n@@ -1304,6 +1358,9 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR\n \n         public void rate(String packageName, int pid, int uid, Rating rating) {\n             try {\n+                final String reason = TAG + \":rate\";\n+                mService.tempAllowlistTargetPkgIfPossible(getUid(), getPackageName(),\n+                        pid, uid, packageName, reason);\n                 mCb.onRate(packageName, pid, uid, rating);\n             } catch (RemoteException e) {\n                 Log.e(TAG, \"Remote failure in rate.\", e);\n@@ -1312,6 +1369,9 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR\n \n         public void setPlaybackSpeed(String packageName, int pid, int uid, float speed) {\n             try {\n+                final String reason = TAG + \":setPlaybackSpeed\";\n+                mService.tempAllowlistTargetPkgIfPossible(getUid(), getPackageName(),\n+                        pid, uid, packageName, reason);\n                 mCb.onSetPlaybackSpeed(packageName, pid, uid, speed);\n             } catch (RemoteException e) {\n                 Log.e(TAG, \"Remote failure in setPlaybackSpeed.\", e);\n@@ -1321,6 +1381,9 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR\n         public void adjustVolume(String packageName, int pid, int uid, boolean asSystemService,\n                 int direction) {\n             try {\n+                final String reason = TAG + \":adjustVolume\";\n+                mService.tempAllowlistTargetPkgIfPossible(getUid(), getPackageName(),\n+                        pid, uid, packageName, reason);\n                 if (asSystemService) {\n                     mCb.onAdjustVolume(mContext.getPackageName(), Process.myPid(),\n                             Process.SYSTEM_UID, direction);\n@@ -1334,6 +1397,9 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR\n \n         public void setVolumeTo(String packageName, int pid, int uid, int value) {\n             try {\n+                final String reason = TAG + \":setVolumeTo\";\n+                mService.tempAllowlistTargetPkgIfPossible(getUid(), getPackageName(),\n+                        pid, uid, packageName, reason);\n                 mCb.onSetVolumeTo(packageName, pid, uid, value);\n             } catch (RemoteException e) {\n                 Log.e(TAG, \"Remote failure in setVolumeTo.\", e);\n",
    "added_lines": 66,
    "deleted_lines": 0,
    "changed_methods": "MediaSessionRecord::SessionCb::pause, MediaSessionRecord::SessionCb::rewind, MediaSessionRecord::SessionCb::playFromMediaId, MediaSessionRecord::SessionCb::stop, MediaSessionRecord::SessionCb::setVolumeTo, MediaSessionRecord::SessionCb::sendCommand, MediaSessionRecord::SessionCb::prepare, MediaSessionRecord::SessionCb::playFromSearch, MediaSessionRecord::SessionCb::next, MediaSessionRecord::SessionCb::prepareFromUri, MediaSessionRecord::SessionCb::fastForward, MediaSessionRecord::SessionCb::playFromUri, MediaSessionRecord::SessionCb::rate, MediaSessionRecord::SessionCb::play, MediaSessionRecord::SessionCb::adjustVolume, MediaSessionRecord::SessionCb::sendCustomAction, MediaSessionRecord::SessionCb::prepareFromSearch, MediaSessionRecord::SessionCb::skipToTrack, MediaSessionRecord::SessionCb::previous, MediaSessionRecord::SessionCb::setPlaybackSpeed, MediaSessionRecord::SessionCb::seekTo, MediaSessionRecord::SessionCb::prepareFromMediaId"
   }
  ]
 },
 {
  "hash": "f6d0f9e8ca43ab65ebaa9247ec388bd0af70c0f3",
  "commit": "Allow shell uid without checking the package name.\n\nBug: 230779051\nTest: manual\nChange-Id: I2867a15840a0987c948179e2f8069e652c4a0c1f\nMerged-In: I2867a15840a0987c948179e2f8069e652c4a0c1f\n(cherry picked from commit 6a61fb48f0a470fb39eb50602335e424945d064e)",
  "files": [
   {
    "filename": "MediaSessionService.java",
    "diff": "@@ -40,6 +40,7 @@ import android.content.Context;\n import android.content.Intent;\n import android.content.IntentFilter;\n import android.content.pm.PackageManager;\n+import android.content.pm.PackageManagerInternal;\n import android.media.AudioManager;\n import android.media.AudioPlaybackConfiguration;\n import android.media.AudioSystem;\n@@ -85,6 +86,7 @@ import android.view.ViewConfiguration;\n import com.android.internal.R;\n import com.android.internal.annotations.GuardedBy;\n import com.android.server.LocalManagerRegistry;\n+import com.android.server.LocalServices;\n import com.android.server.SystemService;\n import com.android.server.Watchdog;\n import com.android.server.Watchdog.Monitor;\n@@ -538,14 +540,19 @@ public class MediaSessionService extends SystemService implements Monitor {\n         if (TextUtils.isEmpty(packageName)) {\n             throw new IllegalArgumentException(\"packageName may not be empty\");\n         }\n-        String[] packages = mContext.getPackageManager().getPackagesForUid(uid);\n-        final int packageCount = packages.length;\n-        for (int i = 0; i < packageCount; i++) {\n-            if (packageName.equals(packages[i])) {\n-                return;\n-            }\n+        if (uid == Process.ROOT_UID || uid == Process.SHELL_UID) {\n+            // If the caller is shell, then trust the packageName given and allow it\n+            // to proceed.\n+            return;\n+        }\n+        final PackageManagerInternal packageManagerInternal =\n+                LocalServices.getService(PackageManagerInternal.class);\n+        final int actualUid = packageManagerInternal.getPackageUid(\n+                packageName, 0 /* flags */, UserHandle.getUserId(uid));\n+        if (!UserHandle.isSameApp(uid, actualUid)) {\n+            throw new IllegalArgumentException(\"packageName does not belong to the calling uid; \"\n+                    + \"pkg=\" + packageName + \", uid=\" + uid);\n         }\n-        throw new IllegalArgumentException(\"packageName is not owned by the calling process\");\n     }\n \n     void tempAllowlistTargetPkgIfPossible(int targetUid, String targetPackage,\n",
    "added_lines": 14,
    "deleted_lines": 7,
    "changed_methods": "MediaSessionService::enforcePackageName"
   }
  ]
 },
 {
  "hash": "bbcb4157d8acc45e3fbdf212bcdaa8d002eff446",
  "commit": "Extend splash screen exception list to SC-V2\n\nExtend the support of the exception list for SC-V2 and apps targeting\nS and SC-V2.\n\nTest: atest ActivityRecordTests\nTest: com.android.server.wm.SplashScreenExceptionListTest\nBug: 231708538\nMerged-In: I5412e81f70cbc9aac3861d13d85e199e949bedc7\nChange-Id: I70a2aa4684c1267fe98e0e2260c61042db9c2e36\n(cherry picked from commit e16beeffe35d16e482240666791ccfd6cf457604)",
  "files": [
   {
    "filename": "SplashScreenExceptionList.java",
    "diff": "@@ -81,7 +81,7 @@ class SplashScreenExceptionList {\n     @SuppressWarnings(\"AndroidFrameworkCompatChange\") // Target sdk check\n     public boolean isException(@NonNull String packageName, int targetSdk,\n             @Nullable Supplier<ApplicationInfo> infoSupplier) {\n-        if (targetSdk >= Build.VERSION_CODES.S) {\n+        if (targetSdk > Build.VERSION_CODES.S_V2) {\n             return false;\n         }\n \n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "SplashScreenExceptionList::isException"
   },
   {
    "filename": "ActivityRecordTests.java",
    "diff": "@@ -2528,7 +2528,9 @@ public class ActivityRecordTests extends WindowTestsBase {\n             DeviceConfig.setProperty(DeviceConfig.NAMESPACE_WINDOW_MANAGER,\n                     \"splash_screen_exception_list\", DEFAULT_COMPONENT_PACKAGE_NAME, false);\n             testLegacySplashScreen(Build.VERSION_CODES.R, TYPE_PARAMETER_LEGACY_SPLASH_SCREEN);\n-            testLegacySplashScreen(Build.VERSION_CODES.S, 0);\n+            testLegacySplashScreen(Build.VERSION_CODES.S, TYPE_PARAMETER_LEGACY_SPLASH_SCREEN);\n+            testLegacySplashScreen(Build.VERSION_CODES.S_V2, TYPE_PARAMETER_LEGACY_SPLASH_SCREEN);\n+            testLegacySplashScreen(Build.VERSION_CODES.S_V2 + 1, 0);\n         } finally {\n             try {\n                 DeviceConfig.setProperties(properties);\n",
    "added_lines": 3,
    "deleted_lines": 1,
    "changed_methods": "ActivityRecordTests::testCreateRemoveLegacySplashScreenWindow"
   },
   {
    "filename": "SplashScreenExceptionListTest.java",
    "diff": "@@ -80,13 +80,19 @@ public class SplashScreenExceptionListTest {\n     public void packageFromDeviceConfigIgnored() {\n         setExceptionListAndWaitForCallback(\"com.test.nosplashscreen1,com.test.nosplashscreen2\");\n \n-        assertIsException(\"com.test.nosplashscreen1\", null);\n-        assertIsException(\"com.test.nosplashscreen2\", null);\n-\n-        assertIsNotException(\"com.test.nosplashscreen1\", VERSION_CODES.S, null);\n-        assertIsNotException(\"com.test.nosplashscreen2\", VERSION_CODES.S, null);\n-        assertIsNotException(\"com.test.splashscreen\", VERSION_CODES.S, null);\n-        assertIsNotException(\"com.test.splashscreen\", VERSION_CODES.R, null);\n+        // In list, up to SC-V2 included\n+        assertIsException(\"com.test.nosplashscreen1\", VERSION_CODES.R);\n+        assertIsException(\"com.test.nosplashscreen1\", VERSION_CODES.S);\n+        assertIsException(\"com.test.nosplashscreen1\", VERSION_CODES.S_V2);\n+\n+        // In list, after SC-V2\n+        assertIsNotException(\"com.test.nosplashscreen2\", VERSION_CODES.S_V2 + 1);\n+        assertIsNotException(\"com.test.nosplashscreen2\", VERSION_CODES.CUR_DEVELOPMENT);\n+\n+        // Not in list, up to SC-V2 included\n+        assertIsNotException(\"com.test.splashscreen\", VERSION_CODES.R);\n+        assertIsNotException(\"com.test.splashscreen\", VERSION_CODES.S);\n+        assertIsNotException(\"com.test.splashscreen\", VERSION_CODES.S_V2);\n     }\n \n     private void setExceptionListAndWaitForCallback(String commaSeparatedList) {\n@@ -123,16 +129,26 @@ public class SplashScreenExceptionListTest {\n         metaData.putBoolean(\"android.splashscreen.exception_opt_out\", true);\n         assertIsNotException(packageName, VERSION_CODES.R, activityInfo);\n         assertIsNotException(packageName, VERSION_CODES.S, activityInfo);\n+        assertIsNotException(packageName, VERSION_CODES.S_V2, activityInfo);\n \n-        // Exception Pre S\n+        // Exception up to T\n         metaData.putBoolean(\"android.splashscreen.exception_opt_out\", false);\n-        assertIsException(packageName, activityInfo);\n-        assertIsNotException(packageName, VERSION_CODES.S, activityInfo);\n+        assertIsException(packageName, VERSION_CODES.R, activityInfo);\n+        assertIsException(packageName, VERSION_CODES.S, activityInfo);\n+        assertIsException(packageName, VERSION_CODES.S_V2, activityInfo);\n+\n+        // No Exception after T\n+        assertIsNotException(packageName, VERSION_CODES.S_V2 + 1, activityInfo);\n+        assertIsNotException(packageName, VERSION_CODES.CUR_DEVELOPMENT, activityInfo);\n \n         // Edge Cases\n         activityInfo.metaData = null;\n-        assertIsException(packageName, activityInfo);\n-        assertIsException(packageName, null);\n+        assertIsException(packageName, VERSION_CODES.R, activityInfo);\n+        assertIsException(packageName, VERSION_CODES.R);\n+    }\n+\n+    private void assertIsNotException(String packageName, int targetSdk) {\n+        assertIsNotException(packageName, targetSdk, null);\n     }\n \n     private void assertIsNotException(String packageName, int targetSdk,\n@@ -142,10 +158,14 @@ public class SplashScreenExceptionListTest {\n                 mList.isException(packageName, targetSdk, () -> activityInfo));\n     }\n \n-    private void assertIsException(String packageName,\n+    private void assertIsException(String packageName, int targetSdk) {\n+        assertIsException(packageName, targetSdk, null);\n+    }\n+\n+    private void assertIsException(String packageName, int targetSdk,\n             ApplicationInfo activityInfo) {\n         assertTrue(String.format(\"%s (sdk=%d) should have been considered as an exception\",\n-                packageName, VERSION_CODES.R),\n-                mList.isException(packageName, VERSION_CODES.R, () -> activityInfo));\n+                packageName, targetSdk),\n+                mList.isException(packageName, targetSdk, () -> activityInfo));\n     }\n }\n",
    "added_lines": 35,
    "deleted_lines": 15,
    "changed_methods": "SplashScreenExceptionListTest::metaDataOptOut, SplashScreenExceptionListTest::packageFromDeviceConfigIgnored, SplashScreenExceptionListTest::assertIsException, SplashScreenExceptionListTest::assertIsNotException, SplashScreenExceptionListTest::assertIsException, SplashScreenExceptionListTest::assertIsException"
   }
  ]
 },
 {
  "hash": "bbcb4157d8acc45e3fbdf212bcdaa8d002eff446",
  "commit": "Extend splash screen exception list to SC-V2\n\nExtend the support of the exception list for SC-V2 and apps targeting\nS and SC-V2.\n\nTest: atest ActivityRecordTests\nTest: com.android.server.wm.SplashScreenExceptionListTest\nBug: 231708538\nMerged-In: I5412e81f70cbc9aac3861d13d85e199e949bedc7\nChange-Id: I70a2aa4684c1267fe98e0e2260c61042db9c2e36\n(cherry picked from commit e16beeffe35d16e482240666791ccfd6cf457604)",
  "files": [
   {
    "filename": "SplashScreenExceptionList.java",
    "diff": "@@ -81,7 +81,7 @@ class SplashScreenExceptionList {\n     @SuppressWarnings(\"AndroidFrameworkCompatChange\") // Target sdk check\n     public boolean isException(@NonNull String packageName, int targetSdk,\n             @Nullable Supplier<ApplicationInfo> infoSupplier) {\n-        if (targetSdk >= Build.VERSION_CODES.S) {\n+        if (targetSdk > Build.VERSION_CODES.S_V2) {\n             return false;\n         }\n \n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "SplashScreenExceptionList::isException"
   },
   {
    "filename": "ActivityRecordTests.java",
    "diff": "@@ -2528,7 +2528,9 @@ public class ActivityRecordTests extends WindowTestsBase {\n             DeviceConfig.setProperty(DeviceConfig.NAMESPACE_WINDOW_MANAGER,\n                     \"splash_screen_exception_list\", DEFAULT_COMPONENT_PACKAGE_NAME, false);\n             testLegacySplashScreen(Build.VERSION_CODES.R, TYPE_PARAMETER_LEGACY_SPLASH_SCREEN);\n-            testLegacySplashScreen(Build.VERSION_CODES.S, 0);\n+            testLegacySplashScreen(Build.VERSION_CODES.S, TYPE_PARAMETER_LEGACY_SPLASH_SCREEN);\n+            testLegacySplashScreen(Build.VERSION_CODES.S_V2, TYPE_PARAMETER_LEGACY_SPLASH_SCREEN);\n+            testLegacySplashScreen(Build.VERSION_CODES.S_V2 + 1, 0);\n         } finally {\n             try {\n                 DeviceConfig.setProperties(properties);\n",
    "added_lines": 3,
    "deleted_lines": 1,
    "changed_methods": "ActivityRecordTests::testCreateRemoveLegacySplashScreenWindow"
   },
   {
    "filename": "SplashScreenExceptionListTest.java",
    "diff": "@@ -80,13 +80,19 @@ public class SplashScreenExceptionListTest {\n     public void packageFromDeviceConfigIgnored() {\n         setExceptionListAndWaitForCallback(\"com.test.nosplashscreen1,com.test.nosplashscreen2\");\n \n-        assertIsException(\"com.test.nosplashscreen1\", null);\n-        assertIsException(\"com.test.nosplashscreen2\", null);\n-\n-        assertIsNotException(\"com.test.nosplashscreen1\", VERSION_CODES.S, null);\n-        assertIsNotException(\"com.test.nosplashscreen2\", VERSION_CODES.S, null);\n-        assertIsNotException(\"com.test.splashscreen\", VERSION_CODES.S, null);\n-        assertIsNotException(\"com.test.splashscreen\", VERSION_CODES.R, null);\n+        // In list, up to SC-V2 included\n+        assertIsException(\"com.test.nosplashscreen1\", VERSION_CODES.R);\n+        assertIsException(\"com.test.nosplashscreen1\", VERSION_CODES.S);\n+        assertIsException(\"com.test.nosplashscreen1\", VERSION_CODES.S_V2);\n+\n+        // In list, after SC-V2\n+        assertIsNotException(\"com.test.nosplashscreen2\", VERSION_CODES.S_V2 + 1);\n+        assertIsNotException(\"com.test.nosplashscreen2\", VERSION_CODES.CUR_DEVELOPMENT);\n+\n+        // Not in list, up to SC-V2 included\n+        assertIsNotException(\"com.test.splashscreen\", VERSION_CODES.R);\n+        assertIsNotException(\"com.test.splashscreen\", VERSION_CODES.S);\n+        assertIsNotException(\"com.test.splashscreen\", VERSION_CODES.S_V2);\n     }\n \n     private void setExceptionListAndWaitForCallback(String commaSeparatedList) {\n@@ -123,16 +129,26 @@ public class SplashScreenExceptionListTest {\n         metaData.putBoolean(\"android.splashscreen.exception_opt_out\", true);\n         assertIsNotException(packageName, VERSION_CODES.R, activityInfo);\n         assertIsNotException(packageName, VERSION_CODES.S, activityInfo);\n+        assertIsNotException(packageName, VERSION_CODES.S_V2, activityInfo);\n \n-        // Exception Pre S\n+        // Exception up to T\n         metaData.putBoolean(\"android.splashscreen.exception_opt_out\", false);\n-        assertIsException(packageName, activityInfo);\n-        assertIsNotException(packageName, VERSION_CODES.S, activityInfo);\n+        assertIsException(packageName, VERSION_CODES.R, activityInfo);\n+        assertIsException(packageName, VERSION_CODES.S, activityInfo);\n+        assertIsException(packageName, VERSION_CODES.S_V2, activityInfo);\n+\n+        // No Exception after T\n+        assertIsNotException(packageName, VERSION_CODES.S_V2 + 1, activityInfo);\n+        assertIsNotException(packageName, VERSION_CODES.CUR_DEVELOPMENT, activityInfo);\n \n         // Edge Cases\n         activityInfo.metaData = null;\n-        assertIsException(packageName, activityInfo);\n-        assertIsException(packageName, null);\n+        assertIsException(packageName, VERSION_CODES.R, activityInfo);\n+        assertIsException(packageName, VERSION_CODES.R);\n+    }\n+\n+    private void assertIsNotException(String packageName, int targetSdk) {\n+        assertIsNotException(packageName, targetSdk, null);\n     }\n \n     private void assertIsNotException(String packageName, int targetSdk,\n@@ -142,10 +158,14 @@ public class SplashScreenExceptionListTest {\n                 mList.isException(packageName, targetSdk, () -> activityInfo));\n     }\n \n-    private void assertIsException(String packageName,\n+    private void assertIsException(String packageName, int targetSdk) {\n+        assertIsException(packageName, targetSdk, null);\n+    }\n+\n+    private void assertIsException(String packageName, int targetSdk,\n             ApplicationInfo activityInfo) {\n         assertTrue(String.format(\"%s (sdk=%d) should have been considered as an exception\",\n-                packageName, VERSION_CODES.R),\n-                mList.isException(packageName, VERSION_CODES.R, () -> activityInfo));\n+                packageName, targetSdk),\n+                mList.isException(packageName, targetSdk, () -> activityInfo));\n     }\n }\n",
    "added_lines": 35,
    "deleted_lines": 15,
    "changed_methods": "SplashScreenExceptionListTest::metaDataOptOut, SplashScreenExceptionListTest::packageFromDeviceConfigIgnored, SplashScreenExceptionListTest::assertIsException, SplashScreenExceptionListTest::assertIsNotException, SplashScreenExceptionListTest::assertIsException, SplashScreenExceptionListTest::assertIsException"
   }
  ]
 },
 {
  "hash": "bbcb4157d8acc45e3fbdf212bcdaa8d002eff446",
  "commit": "Extend splash screen exception list to SC-V2\n\nExtend the support of the exception list for SC-V2 and apps targeting\nS and SC-V2.\n\nTest: atest ActivityRecordTests\nTest: com.android.server.wm.SplashScreenExceptionListTest\nBug: 231708538\nMerged-In: I5412e81f70cbc9aac3861d13d85e199e949bedc7\nChange-Id: I70a2aa4684c1267fe98e0e2260c61042db9c2e36\n(cherry picked from commit e16beeffe35d16e482240666791ccfd6cf457604)",
  "files": [
   {
    "filename": "SplashScreenExceptionList.java",
    "diff": "@@ -81,7 +81,7 @@ class SplashScreenExceptionList {\n     @SuppressWarnings(\"AndroidFrameworkCompatChange\") // Target sdk check\n     public boolean isException(@NonNull String packageName, int targetSdk,\n             @Nullable Supplier<ApplicationInfo> infoSupplier) {\n-        if (targetSdk >= Build.VERSION_CODES.S) {\n+        if (targetSdk > Build.VERSION_CODES.S_V2) {\n             return false;\n         }\n \n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "SplashScreenExceptionList::isException"
   },
   {
    "filename": "ActivityRecordTests.java",
    "diff": "@@ -2528,7 +2528,9 @@ public class ActivityRecordTests extends WindowTestsBase {\n             DeviceConfig.setProperty(DeviceConfig.NAMESPACE_WINDOW_MANAGER,\n                     \"splash_screen_exception_list\", DEFAULT_COMPONENT_PACKAGE_NAME, false);\n             testLegacySplashScreen(Build.VERSION_CODES.R, TYPE_PARAMETER_LEGACY_SPLASH_SCREEN);\n-            testLegacySplashScreen(Build.VERSION_CODES.S, 0);\n+            testLegacySplashScreen(Build.VERSION_CODES.S, TYPE_PARAMETER_LEGACY_SPLASH_SCREEN);\n+            testLegacySplashScreen(Build.VERSION_CODES.S_V2, TYPE_PARAMETER_LEGACY_SPLASH_SCREEN);\n+            testLegacySplashScreen(Build.VERSION_CODES.S_V2 + 1, 0);\n         } finally {\n             try {\n                 DeviceConfig.setProperties(properties);\n",
    "added_lines": 3,
    "deleted_lines": 1,
    "changed_methods": "ActivityRecordTests::testCreateRemoveLegacySplashScreenWindow"
   },
   {
    "filename": "SplashScreenExceptionListTest.java",
    "diff": "@@ -80,13 +80,19 @@ public class SplashScreenExceptionListTest {\n     public void packageFromDeviceConfigIgnored() {\n         setExceptionListAndWaitForCallback(\"com.test.nosplashscreen1,com.test.nosplashscreen2\");\n \n-        assertIsException(\"com.test.nosplashscreen1\", null);\n-        assertIsException(\"com.test.nosplashscreen2\", null);\n-\n-        assertIsNotException(\"com.test.nosplashscreen1\", VERSION_CODES.S, null);\n-        assertIsNotException(\"com.test.nosplashscreen2\", VERSION_CODES.S, null);\n-        assertIsNotException(\"com.test.splashscreen\", VERSION_CODES.S, null);\n-        assertIsNotException(\"com.test.splashscreen\", VERSION_CODES.R, null);\n+        // In list, up to SC-V2 included\n+        assertIsException(\"com.test.nosplashscreen1\", VERSION_CODES.R);\n+        assertIsException(\"com.test.nosplashscreen1\", VERSION_CODES.S);\n+        assertIsException(\"com.test.nosplashscreen1\", VERSION_CODES.S_V2);\n+\n+        // In list, after SC-V2\n+        assertIsNotException(\"com.test.nosplashscreen2\", VERSION_CODES.S_V2 + 1);\n+        assertIsNotException(\"com.test.nosplashscreen2\", VERSION_CODES.CUR_DEVELOPMENT);\n+\n+        // Not in list, up to SC-V2 included\n+        assertIsNotException(\"com.test.splashscreen\", VERSION_CODES.R);\n+        assertIsNotException(\"com.test.splashscreen\", VERSION_CODES.S);\n+        assertIsNotException(\"com.test.splashscreen\", VERSION_CODES.S_V2);\n     }\n \n     private void setExceptionListAndWaitForCallback(String commaSeparatedList) {\n@@ -123,16 +129,26 @@ public class SplashScreenExceptionListTest {\n         metaData.putBoolean(\"android.splashscreen.exception_opt_out\", true);\n         assertIsNotException(packageName, VERSION_CODES.R, activityInfo);\n         assertIsNotException(packageName, VERSION_CODES.S, activityInfo);\n+        assertIsNotException(packageName, VERSION_CODES.S_V2, activityInfo);\n \n-        // Exception Pre S\n+        // Exception up to T\n         metaData.putBoolean(\"android.splashscreen.exception_opt_out\", false);\n-        assertIsException(packageName, activityInfo);\n-        assertIsNotException(packageName, VERSION_CODES.S, activityInfo);\n+        assertIsException(packageName, VERSION_CODES.R, activityInfo);\n+        assertIsException(packageName, VERSION_CODES.S, activityInfo);\n+        assertIsException(packageName, VERSION_CODES.S_V2, activityInfo);\n+\n+        // No Exception after T\n+        assertIsNotException(packageName, VERSION_CODES.S_V2 + 1, activityInfo);\n+        assertIsNotException(packageName, VERSION_CODES.CUR_DEVELOPMENT, activityInfo);\n \n         // Edge Cases\n         activityInfo.metaData = null;\n-        assertIsException(packageName, activityInfo);\n-        assertIsException(packageName, null);\n+        assertIsException(packageName, VERSION_CODES.R, activityInfo);\n+        assertIsException(packageName, VERSION_CODES.R);\n+    }\n+\n+    private void assertIsNotException(String packageName, int targetSdk) {\n+        assertIsNotException(packageName, targetSdk, null);\n     }\n \n     private void assertIsNotException(String packageName, int targetSdk,\n@@ -142,10 +158,14 @@ public class SplashScreenExceptionListTest {\n                 mList.isException(packageName, targetSdk, () -> activityInfo));\n     }\n \n-    private void assertIsException(String packageName,\n+    private void assertIsException(String packageName, int targetSdk) {\n+        assertIsException(packageName, targetSdk, null);\n+    }\n+\n+    private void assertIsException(String packageName, int targetSdk,\n             ApplicationInfo activityInfo) {\n         assertTrue(String.format(\"%s (sdk=%d) should have been considered as an exception\",\n-                packageName, VERSION_CODES.R),\n-                mList.isException(packageName, VERSION_CODES.R, () -> activityInfo));\n+                packageName, targetSdk),\n+                mList.isException(packageName, targetSdk, () -> activityInfo));\n     }\n }\n",
    "added_lines": 35,
    "deleted_lines": 15,
    "changed_methods": "SplashScreenExceptionListTest::metaDataOptOut, SplashScreenExceptionListTest::packageFromDeviceConfigIgnored, SplashScreenExceptionListTest::assertIsException, SplashScreenExceptionListTest::assertIsNotException, SplashScreenExceptionListTest::assertIsException, SplashScreenExceptionListTest::assertIsException"
   }
  ]
 },
 {
  "hash": "e2c024f96fe049e275d3af61170b0878135e9e9c",
  "commit": "SystemUI: VolumeDialogImpl: Show output button if there is an active stream\n\nThe media output dialog can be used to connect different devices.\nThis patch makes it show up if at least one of the following\nconditions is met:\n1: There is an active local media controller\n2: There is a bluetooth a2dp device connected\n\nChange-Id: Ie2a2a0f3125e1ffbf78bfc1f66868696f6389294",
  "files": [
   {
    "filename": "VolumeDialogImpl.java",
    "diff": "@@ -1240,22 +1240,25 @@ public class VolumeDialogImpl implements VolumeDialog,\n                 == BluetoothProfile.STATE_CONNECTED;\n     }\n \n+    private boolean isMediaControllerAvailable(MediaController mediaController) {\n+        return mediaController != null && !TextUtils.isEmpty(mediaController.getPackageName());\n+    }\n+\n     public void initSettingsH() {\n         if (mSettingsView != null) {\n             mSettingsView.setVisibility(mDeviceProvisionedController.isCurrentUserSetup()\n                     && mActivityManager.getLockTaskModeState() == LOCK_TASK_MODE_NONE\n-                    && isBluetoothA2dpConnected()\n+                    && (isMediaControllerAvailable(getActiveLocalMediaController())\n+                            || isBluetoothA2dpConnected())\n                     ? VISIBLE : GONE);\n         }\n         if (mSettingsIcon != null) {\n             mSettingsIcon.setOnClickListener(v -> {\n                 Events.writeEvent(Events.EVENT_SETTINGS_CLICK);\n                 final MediaController mediaController = getActiveLocalMediaController();\n-                String packageName =\n-                        mediaController != null\n-                                && !TextUtils.isEmpty(mediaController.getPackageName())\n-                                ? mediaController.getPackageName()\n-                                : \"\";\n+                String packageName = isMediaControllerAvailable(mediaController)\n+                        ? mediaController.getPackageName()\n+                        : \"\";\n                 mMediaOutputDialogFactory.create(packageName, false, mDialogView);\n                 dismissH(DISMISS_REASON_SETTINGS_CLICKED);\n             });\n",
    "added_lines": 9,
    "deleted_lines": 6,
    "changed_methods": "VolumeDialogImpl::isMediaControllerAvailable, VolumeDialogImpl::initSettingsH"
   }
  ]
 },
 {
  "hash": "e26a2ead9dc146ffffa63406963fc4e8a8687202",
  "commit": "SystemUI: VolumeDialogImpl: Move the MediaOutputDialog above status bar\n\nThe volume dialog is above the status bar too and can be used while\nthe statusbar is expanded. Opening the media output dialog then will\ncause the dialog to appear below the status bar which isn't visible\nuntil the status bar is collapsed. This change moves the media output\ndialog above the status bar.\n\nChange-Id: Ie906ee0a59d52dbb6b6f703e210fa43308d069f0",
  "files": [
   {
    "filename": "VolumeDialogImpl.java",
    "diff": "@@ -1259,7 +1259,7 @@ public class VolumeDialogImpl implements VolumeDialog,\n                 String packageName = isMediaControllerAvailable(mediaController)\n                         ? mediaController.getPackageName()\n                         : \"\";\n-                mMediaOutputDialogFactory.create(packageName, false, mDialogView);\n+                mMediaOutputDialogFactory.create(packageName, true, mDialogView);\n                 dismissH(DISMISS_REASON_SETTINGS_CLICKED);\n             });\n         }\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "VolumeDialogImpl::initSettingsH"
   }
  ]
 },
 {
  "hash": "33a0c1ca661a4bbd707442713a308be9f606a864",
  "commit": "SystemUI: VolumeDialogImpl: notifyVisible after the volume panel is fully hidden\n\nnotifyVisible(false) leads to reset of active stream. As a result,\nthe current active row will be untinted. Currently, this happens\nimmediately after the dismissal is requested, before the volume panel\nis fully hidden.\n\nUser can notice the row has been untinted before the panel is hidden.\n\nThis changes moves notifyVisible to the end of animation so the volume\npanel appearance will be consistent in between.\n\nChange-Id: Iacd83d48634a11bc248c9a2a45b68b53256fdcb2\nSigned-off-by: Jesse Chan <jc@lineageos.org>",
  "files": [
   {
    "filename": "VolumeDialogImpl.java",
    "diff": "@@ -1590,13 +1590,13 @@ public class VolumeDialogImpl implements VolumeDialog,\n                     mIsAnimatingDismiss = false;\n \n                     hideRingerDrawer();\n+                    mController.notifyVisible(false);\n                 }, 50));\n         if (!shouldSlideInVolumeTray()) {\n             animator.translationX(getTranslationForPanelLocation() * mDialogView.getWidth() / 2.0f);\n         }\n         animator.start();\n         checkODICaptionsTooltip(true);\n-        mController.notifyVisible(false);\n         synchronized (mSafetyWarningLock) {\n             if (mSafetyWarning != null) {\n                 if (D.BUG) Log.d(TAG, \"SafetyWarning dismissed\");\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "VolumeDialogImpl::dismissH"
   }
  ]
 },
 {
  "hash": "4b55896265e4283636c0297d7a37d14771ed6ff9",
  "commit": "fixup! Rewrite trust USB restriction handling\n\nFor our Trust preferences, if the `trust_restrict_usb` setting is\nmissing, we default to assuming a value of 0 (don't restrict USB\ndevices). However, here in fw/b, we're instead defaulting to assuming a\nvalue of 1 (restruct USB devices when device is locked). As such, this\ncan cause confusion because the user is expecting that we aren't\nrestricting USB connections by default.\n\nLet's update the fw/b side of things to also assume a value of 0 instead\nto clear up the confusion.\n\nChange-Id: Ifa45bfb05ad4e745266f3da11ee3f0f4a6a3384b",
  "files": [
   {
    "filename": "UsbDeviceManager.java",
    "diff": "@@ -1520,7 +1520,7 @@ public class UsbDeviceManager implements ActivityTaskManagerInternal.ScreenObser\n \n         public void setTrustRestrictUsb() {\n             final int restrictUsb = LineageSettings.Global.getInt(mContentResolver,\n-                    LineageSettings.Global.TRUST_RESTRICT_USB, 1);\n+                    LineageSettings.Global.TRUST_RESTRICT_USB, 0);\n             // Effective immediately, ejects any connected USB devices.\n             // If the restriction is set to \"only when locked\", only execute once USB is\n             // disconnected and keyguard is showing, to avoid ejecting connected devices\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "UsbDeviceManager::UsbHandler::setTrustRestrictUsb"
   }
  ]
 },
 {
  "hash": "16a2ea48ae337131c0825eb4c1d054f41d3bcb4a",
  "commit": "Don't pass non slider adj. as user interactions\n\nThis cl stops passing RBC on, RBC off and RBC intensity changes as\nslider interactions. Normal slider interactions will be passed as a user\ninteraction, regardless of whether RBC is on or not. Also, ensure the\nshort term model (STM) is correctly reset when necessary.\n\n                    | Old Scenario:     | New Scenario:\nRBC turned on       | user initiated    | non user\n                    | keep STM          | reset STM\n\nRBC turned off      | non user          | non user\n                    | reset STM         | reset STM\n\nChange of intensity | user initiated    | non user\n                    | reset STM         | reset STM\n\nSlider interaction  | user initiated    | user initiated\n whilst RBC is on   | keep STM          | keep STM\n\nBug: 204298104\nBug: 202262784\nTest: adb shell dumpsys display | grep -A50 mEvents\nTest: manual logs and check interactions\n\nChange-Id: I135623dc9ccca11817d5dd07d9b333b94aac30f1",
  "files": [
   {
    "filename": "DisplayPowerController.java",
    "diff": "@@ -433,14 +433,6 @@ final class DisplayPowerController implements AutomaticBrightnessController.Call\n     // PowerManager.BRIGHTNESS_INVALID_FLOAT when there's no temporary adjustment set.\n     private float mTemporaryAutoBrightnessAdjustment;\n \n-    // Whether reduce bright colors (rbc) has been turned on, or a change in strength has been\n-    // requested. We want to retain the current backlight level when rbc is toggled, since rbc\n-    // additionally makes the screen appear dimmer using screen colors rather than backlight levels,\n-    // and therefore we don't actually want to compensate for this by then in/decreasing the\n-    // backlight when toggling this feature.\n-    // This should be false during system start up.\n-    private boolean mPendingRbcOnOrChanged = false;\n-\n     // Whether auto brightness is applied one shot when screen is turned on\n     private boolean mAutoBrightnessOneShot;\n \n@@ -583,35 +575,29 @@ final class DisplayPowerController implements AutomaticBrightnessController.Call\n                 @Override\n                 public void onReduceBrightColorsActivationChanged(boolean activated,\n                         boolean userInitiated) {\n-                    applyReduceBrightColorsSplineAdjustment(\n-                            /* rbcStrengthChanged= */ false, activated);\n+                    applyReduceBrightColorsSplineAdjustment();\n \n                 }\n \n                 @Override\n                 public void onReduceBrightColorsStrengthChanged(int strength) {\n-                    applyReduceBrightColorsSplineAdjustment(\n-                            /* rbcStrengthChanged= */ true, /* justActivated= */ false);\n+                    applyReduceBrightColorsSplineAdjustment();\n                 }\n             });\n             if (active) {\n-                applyReduceBrightColorsSplineAdjustment(\n-                        /* rbcStrengthChanged= */ false,  /* justActivated= */ false);\n+                applyReduceBrightColorsSplineAdjustment();\n             }\n         } else {\n             mCdsi = null;\n         }\n     }\n \n-    private void applyReduceBrightColorsSplineAdjustment(\n-            boolean rbcStrengthChanged, boolean justActivated) {\n-        final int strengthChanged = rbcStrengthChanged ? 1 : 0;\n-        final int activated = justActivated ? 1 : 0;\n-        mHandler.obtainMessage(MSG_UPDATE_RBC, strengthChanged, activated).sendToTarget();\n+    private void applyReduceBrightColorsSplineAdjustment() {\n+        mHandler.obtainMessage(MSG_UPDATE_RBC).sendToTarget();\n         sendUpdatePowerState();\n     }\n \n-    private void handleRbcChanged(boolean strengthChanged, boolean justActivated) {\n+    private void handleRbcChanged() {\n         if (mBrightnessMapper == null) {\n             Log.w(TAG, \"No brightness mapping available to recalculate splines\");\n             return;\n@@ -623,12 +609,12 @@ final class DisplayPowerController implements AutomaticBrightnessController.Call\n         }\n         mBrightnessMapper.recalculateSplines(mCdsi.isReduceBrightColorsActivated(), adjustedNits);\n \n-        mPendingRbcOnOrChanged = strengthChanged || justActivated;\n \n-        // Reset model if strength changed OR rbc is turned off\n-        if ((strengthChanged || !justActivated) && mAutomaticBrightnessController != null) {\n-            mAutomaticBrightnessController.resetShortTermModel();\n-        }\n+        // If rbc is turned on, off or there is a change in strength, we want to reset the short\n+        // term model. Since the nits range at which brightness now operates has changed due to\n+        // RBC/strength change, any short term model based on the previous range should be\n+        // invalidated.\n+        mAutomaticBrightnessController.resetShortTermModel();\n     }\n \n     /**\n@@ -977,8 +963,7 @@ final class DisplayPowerController implements AutomaticBrightnessController.Call\n \n     private void reloadReduceBrightColours() {\n         if (mCdsi != null && mCdsi.isReduceBrightColorsActivated()) {\n-            applyReduceBrightColorsSplineAdjustment(\n-                    /* rbcStrengthChanged= */ false, /* justActivated= */ false);\n+            applyReduceBrightColorsSplineAdjustment();\n         }\n     }\n \n@@ -2155,23 +2140,17 @@ final class DisplayPowerController implements AutomaticBrightnessController.Call\n     }\n \n     // We want to return true if the user has set the screen brightness.\n-    // If they have just turned RBC on (and therefore added that interaction to the curve),\n-    // or changed the brightness another way, then we should return true.\n+    // RBC on, off, and intensity changes will return false.\n+    // Slider interactions whilst in RBC will return true, just as when in non-rbc.\n     private boolean updateUserSetScreenBrightness() {\n-        final boolean treatAsIfUserChanged = mPendingRbcOnOrChanged;\n-        if (treatAsIfUserChanged && !Float.isNaN(mCurrentScreenBrightnessSetting)) {\n-            mLastUserSetScreenBrightness = mCurrentScreenBrightnessSetting;\n-        }\n-        mPendingRbcOnOrChanged = false;\n-\n         if ((Float.isNaN(mPendingScreenBrightnessSetting)\n                 || mPendingScreenBrightnessSetting < 0.0f)) {\n-            return treatAsIfUserChanged;\n+            return false;\n         }\n         if (mCurrentScreenBrightnessSetting == mPendingScreenBrightnessSetting) {\n             mPendingScreenBrightnessSetting = PowerManager.BRIGHTNESS_INVALID_FLOAT;\n             mTemporaryScreenBrightness = PowerManager.BRIGHTNESS_INVALID_FLOAT;\n-            return treatAsIfUserChanged;\n+            return false;\n         }\n         setCurrentScreenBrightness(mPendingScreenBrightnessSetting);\n         mLastUserSetScreenBrightness = mPendingScreenBrightnessSetting;\n@@ -2515,9 +2494,7 @@ final class DisplayPowerController implements AutomaticBrightnessController.Call\n                     break;\n \n                 case MSG_UPDATE_RBC:\n-                    final int strengthChanged = msg.arg1;\n-                    final int justActivated = msg.arg2;\n-                    handleRbcChanged(strengthChanged == 1, justActivated == 1);\n+                    handleRbcChanged();\n                     break;\n             }\n         }\n",
    "added_lines": 17,
    "deleted_lines": 40,
    "changed_methods": "DisplayPowerController::handleRbcChanged, DisplayPowerController::reloadReduceBrightColours, DisplayPowerController::applyReduceBrightColorsSplineAdjustment, DisplayPowerController::DisplayPowerController, DisplayPowerController::handleRbcChanged, DisplayPowerController::updateUserSetScreenBrightness, DisplayPowerController::DisplayControllerHandler::handleMessage, DisplayPowerController::applyReduceBrightColorsSplineAdjustment"
   }
  ]
 },
 {
  "hash": "f27493ca32186a10cc091634bf3e7ee637dcb4b4",
  "commit": "Fix duplicate permission privilege escalation\n\nDuplicate permissions definition with different group allows\nprivilege permission escalation to a different permission group.\n\nAndroid studio and gradle plugin does not allow duplicate permissions\nwith different attributes, these tools only allow if duplicate\npermissions are exact copies.\n\nAlso platform stores permissions in map at multiple places with permission\nname as key. This suggests that we can disallow duplicate permissions\nduring package install/update\n\nBug: 213323615\nTest: AppSecurityTests\nChange-Id: I34120fff2ec2a158dfa55779d2afd4bbd49487ff\nMerged-In: I9bc839836786a0876e67fd73c05f8944bb532249\n(cherry picked from commit 548edbb850227e076735615f83f8e23352b0b82d)\nMerged-In: I34120fff2ec2a158dfa55779d2afd4bbd49487ff",
  "files": [
   {
    "filename": "ParsingPackageUtils.java",
    "diff": "@@ -20,6 +20,7 @@ import static android.content.pm.ActivityInfo.FLAG_SUPPORTS_PICTURE_IN_PICTURE;\n import static android.content.pm.ActivityInfo.RESIZE_MODE_UNRESIZEABLE;\n import static android.content.pm.PackageManager.INSTALL_PARSE_FAILED_BAD_MANIFEST;\n import static android.content.pm.PackageManager.INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES;\n+import static android.content.pm.PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;\n import static android.content.pm.PackageManager.INSTALL_PARSE_FAILED_ONLY_COREAPP_ALLOWED;\n import static android.content.pm.PackageManager.INSTALL_PARSE_FAILED_RESOURCES_ARSC_COMPRESSED;\n import static android.content.pm.PackageManager.INSTALL_PARSE_FAILED_UNEXPECTED_EXCEPTION;\n@@ -905,6 +906,13 @@ public class ParsingPackageUtils {\n             );\n         }\n \n+        if (ParsedPermissionUtils.declareDuplicatePermission(pkg)) {\n+            return input.error(\n+                    INSTALL_PARSE_FAILED_MANIFEST_MALFORMED,\n+                    \"Declare duplicate permissions with different protection levels or group.\"\n+            );\n+        }\n+\n         convertNewPermissions(pkg);\n \n         convertSplitPermissions(pkg);\n",
    "added_lines": 8,
    "deleted_lines": 0,
    "changed_methods": "ParsingPackageUtils::parseBaseApkTags"
   },
   {
    "filename": "ParsedPermissionUtils.java",
    "diff": "@@ -25,6 +25,8 @@ import android.content.pm.parsing.result.ParseResult;\n import android.content.res.Resources;\n import android.content.res.TypedArray;\n import android.content.res.XmlResourceParser;\n+import android.util.ArrayMap;\n+import android.util.EventLog;\n import android.util.Slog;\n \n import com.android.internal.R;\n@@ -32,6 +34,8 @@ import com.android.internal.R;\n import org.xmlpull.v1.XmlPullParserException;\n \n import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n \n /** @hide */\n public class ParsedPermissionUtils {\n@@ -233,4 +237,50 @@ public class ParsedPermissionUtils {\n         return ComponentParseUtils.parseAllMetaData(pkg, res, parser, tag, permissionGroup,\n                 input);\n     }\n+\n+    /**\n+     * Determines if a duplicate permission is malformed .i.e. defines different protection level\n+     * or group\n+     */\n+    private static boolean isMalformedDuplicate(ParsedPermission p1, ParsedPermission p2) {\n+        // Since a permission tree is also added as a permission with normal protection\n+        // level, we need to skip if the parsedPermission is a permission tree.\n+        if (p1 == null || p2 == null || p1.isTree() || p2.isTree()) {\n+            return false;\n+        }\n+\n+        if (p1.getProtectionLevel() != p2.getProtectionLevel()) {\n+            return true;\n+        }\n+        if (!Objects.equals(p1.getGroup(), p2.getGroup())) {\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+     * @return {@code true} if the package declares malformed duplicate permissions.\n+     *\n+     */\n+    public static boolean declareDuplicatePermission(@NonNull ParsingPackage pkg) {\n+        final List<ParsedPermission> permissions = pkg.getPermissions();\n+        final int size = permissions.size();\n+        if (size > 0) {\n+            final ArrayMap<String, ParsedPermission> checkDuplicatePerm = new ArrayMap<>(size);\n+            for (int i = 0; i < size; i++) {\n+                final ParsedPermission parsedPermission = permissions.get(i);\n+                final String name = parsedPermission.getName();\n+                final ParsedPermission perm = checkDuplicatePerm.get(name);\n+                if (isMalformedDuplicate(parsedPermission, perm)) {\n+                    // Fix for b/213323615\n+                    EventLog.writeEvent(0x534e4554, \"213323615\",\n+                            \"The package \" + pkg.getPackageName() + \" seems malicious\");\n+                    return true;\n+                }\n+                checkDuplicatePerm.put(name, parsedPermission);\n+            }\n+        }\n+        return false;\n+    }\n }\n",
    "added_lines": 50,
    "deleted_lines": 0,
    "changed_methods": "ParsedPermissionUtils::isMalformedDuplicate, ParsedPermissionUtils::declareDuplicatePermission"
   }
  ]
 },
 {
  "hash": "f27493ca32186a10cc091634bf3e7ee637dcb4b4",
  "commit": "Fix duplicate permission privilege escalation\n\nDuplicate permissions definition with different group allows\nprivilege permission escalation to a different permission group.\n\nAndroid studio and gradle plugin does not allow duplicate permissions\nwith different attributes, these tools only allow if duplicate\npermissions are exact copies.\n\nAlso platform stores permissions in map at multiple places with permission\nname as key. This suggests that we can disallow duplicate permissions\nduring package install/update\n\nBug: 213323615\nTest: AppSecurityTests\nChange-Id: I34120fff2ec2a158dfa55779d2afd4bbd49487ff\nMerged-In: I9bc839836786a0876e67fd73c05f8944bb532249\n(cherry picked from commit 548edbb850227e076735615f83f8e23352b0b82d)\nMerged-In: I34120fff2ec2a158dfa55779d2afd4bbd49487ff",
  "files": [
   {
    "filename": "ParsingPackageUtils.java",
    "diff": "@@ -20,6 +20,7 @@ import static android.content.pm.ActivityInfo.FLAG_SUPPORTS_PICTURE_IN_PICTURE;\n import static android.content.pm.ActivityInfo.RESIZE_MODE_UNRESIZEABLE;\n import static android.content.pm.PackageManager.INSTALL_PARSE_FAILED_BAD_MANIFEST;\n import static android.content.pm.PackageManager.INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES;\n+import static android.content.pm.PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;\n import static android.content.pm.PackageManager.INSTALL_PARSE_FAILED_ONLY_COREAPP_ALLOWED;\n import static android.content.pm.PackageManager.INSTALL_PARSE_FAILED_RESOURCES_ARSC_COMPRESSED;\n import static android.content.pm.PackageManager.INSTALL_PARSE_FAILED_UNEXPECTED_EXCEPTION;\n@@ -905,6 +906,13 @@ public class ParsingPackageUtils {\n             );\n         }\n \n+        if (ParsedPermissionUtils.declareDuplicatePermission(pkg)) {\n+            return input.error(\n+                    INSTALL_PARSE_FAILED_MANIFEST_MALFORMED,\n+                    \"Declare duplicate permissions with different protection levels or group.\"\n+            );\n+        }\n+\n         convertNewPermissions(pkg);\n \n         convertSplitPermissions(pkg);\n",
    "added_lines": 8,
    "deleted_lines": 0,
    "changed_methods": "ParsingPackageUtils::parseBaseApkTags"
   },
   {
    "filename": "ParsedPermissionUtils.java",
    "diff": "@@ -25,6 +25,8 @@ import android.content.pm.parsing.result.ParseResult;\n import android.content.res.Resources;\n import android.content.res.TypedArray;\n import android.content.res.XmlResourceParser;\n+import android.util.ArrayMap;\n+import android.util.EventLog;\n import android.util.Slog;\n \n import com.android.internal.R;\n@@ -32,6 +34,8 @@ import com.android.internal.R;\n import org.xmlpull.v1.XmlPullParserException;\n \n import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n \n /** @hide */\n public class ParsedPermissionUtils {\n@@ -233,4 +237,50 @@ public class ParsedPermissionUtils {\n         return ComponentParseUtils.parseAllMetaData(pkg, res, parser, tag, permissionGroup,\n                 input);\n     }\n+\n+    /**\n+     * Determines if a duplicate permission is malformed .i.e. defines different protection level\n+     * or group\n+     */\n+    private static boolean isMalformedDuplicate(ParsedPermission p1, ParsedPermission p2) {\n+        // Since a permission tree is also added as a permission with normal protection\n+        // level, we need to skip if the parsedPermission is a permission tree.\n+        if (p1 == null || p2 == null || p1.isTree() || p2.isTree()) {\n+            return false;\n+        }\n+\n+        if (p1.getProtectionLevel() != p2.getProtectionLevel()) {\n+            return true;\n+        }\n+        if (!Objects.equals(p1.getGroup(), p2.getGroup())) {\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+     * @return {@code true} if the package declares malformed duplicate permissions.\n+     *\n+     */\n+    public static boolean declareDuplicatePermission(@NonNull ParsingPackage pkg) {\n+        final List<ParsedPermission> permissions = pkg.getPermissions();\n+        final int size = permissions.size();\n+        if (size > 0) {\n+            final ArrayMap<String, ParsedPermission> checkDuplicatePerm = new ArrayMap<>(size);\n+            for (int i = 0; i < size; i++) {\n+                final ParsedPermission parsedPermission = permissions.get(i);\n+                final String name = parsedPermission.getName();\n+                final ParsedPermission perm = checkDuplicatePerm.get(name);\n+                if (isMalformedDuplicate(parsedPermission, perm)) {\n+                    // Fix for b/213323615\n+                    EventLog.writeEvent(0x534e4554, \"213323615\",\n+                            \"The package \" + pkg.getPackageName() + \" seems malicious\");\n+                    return true;\n+                }\n+                checkDuplicatePerm.put(name, parsedPermission);\n+            }\n+        }\n+        return false;\n+    }\n }\n",
    "added_lines": 50,
    "deleted_lines": 0,
    "changed_methods": "ParsedPermissionUtils::isMalformedDuplicate, ParsedPermissionUtils::declareDuplicatePermission"
   }
  ]
 },
 {
  "hash": "d42ec4c0e5ad85792f526cc90d8830b02febc1b0",
  "commit": "Remove package name from SafetyNet logs\n\nBug: 213323615\nTest: AppSecurityTests\nChange-Id: I8f823487ca16861a35135cfc3383fa2ce8258017\nMerged-In: I4b61d13256ce0bfb8fc9d21db52ee78ce2097f14\n(cherry picked from commit dfeea39dbc61ea9884e7e017335cbdf4942fa181)\nMerged-In: I8f823487ca16861a35135cfc3383fa2ce8258017",
  "files": [
   {
    "filename": "ParsedPermissionUtils.java",
    "diff": "@@ -274,8 +274,7 @@ public class ParsedPermissionUtils {\n                 final ParsedPermission perm = checkDuplicatePerm.get(name);\n                 if (isMalformedDuplicate(parsedPermission, perm)) {\n                     // Fix for b/213323615\n-                    EventLog.writeEvent(0x534e4554, \"213323615\",\n-                            \"The package \" + pkg.getPackageName() + \" seems malicious\");\n+                    EventLog.writeEvent(0x534e4554, \"213323615\");\n                     return true;\n                 }\n                 checkDuplicatePerm.put(name, parsedPermission);\n",
    "added_lines": 1,
    "deleted_lines": 2,
    "changed_methods": "ParsedPermissionUtils::declareDuplicatePermission"
   }
  ]
 },
 {
  "hash": "3792f09dcbd496d6c30558d7b26ceff2a6e742d2",
  "commit": "DozeSensors: only use proximity sensor if supported\n\nOn msm-4.14 devices, when the proximity sensor is in use,\nthe smp2p-sleepstate IRQ is fired multiple times a second,\nwith each one holding a 200ms wakelock.\nThis is probably a bug in the DSP firmware.\nTo fix this, avoid using the proximity sensor in doze mode,\nbecause sleep is preferred to turning off the screen.\n\nChange-Id: I57750afd77267abdc49780f70636626d20e666ad",
  "files": [
   {
    "filename": "DozeSensors.java",
    "diff": "@@ -47,6 +47,7 @@ import com.android.internal.logging.UiEvent;\n import com.android.internal.logging.UiEventLogger;\n import com.android.internal.logging.UiEventLoggerImpl;\n import com.android.keyguard.KeyguardUpdateMonitor;\n+import com.android.systemui.R;\n import com.android.systemui.biometrics.AuthController;\n import com.android.systemui.plugins.SensorManagerPlugin;\n import com.android.systemui.statusbar.phone.DozeParameters;\n@@ -262,13 +263,15 @@ public class DozeSensors {\n                         false /* ignoresSetting */,\n                         false /* requiresProx */),\n         };\n-        setProxListening(false);  // Don't immediately start listening when we register.\n-        mProximitySensor.register(\n-                proximityEvent -> {\n-                    if (proximityEvent != null) {\n-                        mProxCallback.accept(!proximityEvent.getBelow());\n-                    }\n-                });\n+        if (context.getResources().getBoolean(R.bool.doze_proximity_sensor_supported)) {\n+            setProxListening(false);  // Don't immediately start listening when we register.\n+            mProximitySensor.register(\n+                    proximityEvent -> {\n+                        if (proximityEvent != null) {\n+                            mProxCallback.accept(!proximityEvent.getBelow());\n+                        }\n+                    });\n+        }\n \n         mDevicePostureController.addCallback(mDevicePostureCallback);\n     }\n",
    "added_lines": 10,
    "deleted_lines": 7,
    "changed_methods": "DozeSensors::DozeSensors"
   }
  ]
 },
 {
  "hash": "263c70d638de51184f95e4e376c109908fd89dae",
  "commit": "hasRestrictedModeAccess: Clear calling identity when checking network capabilities\n\n* This code ends up being called from Datura, the firewall app,\n  which would fail with:\njava.lang.SecurityException: Package android does not belong to 10139\n   at android.net.NetworkPolicyManager.removeUidPolicy(NetworkPolicyManager.java:352)\n   at org.calyxos.datura.settings.SettingsManager.setAppRestriction(SettingsManager.java:108)\nCaused by: android.os.RemoteException: Remote stack trace:\n   at android.app.AppOpsManager.checkPackage(AppOpsManager.java:8552)\n   at com.android.server.ConnectivityService.getNetworkCapabilities(ConnectivityService.java:2042)\n   at android.net.ConnectivityManager.getNetworkCapabilities(ConnectivityManager.java:1563)\n   at com.android.server.net.NetworkPolicyManagerService.hasRestrictedModeAccess(NetworkPolicyManagerService.java:4133)\n   at com.android.server.net.NetworkPolicyManagerService.getNewRestrictedModeUidRule(NetworkPolicyManagerService.java:4116)\nPackage android does not belong to 10139\n  where 10139 is the uid of the firewall app\n* This should be safe since we're only checking the capabilities here,\n  and not actually returning anything anywhere - just a boolean\n\nChange-Id: Ia0b5790be19ad5aece0d30ae8e1a465f45f4fed6",
  "files": [
   {
    "filename": "NetworkPolicyManagerService.java",
    "diff": "@@ -4252,9 +4252,11 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {\n     }\n \n     private boolean hasRestrictedModeAccess(int uid) {\n+        final long token = Binder.clearCallingIdentity();\n         try {\n             NetworkCapabilities nc = mConnManager.getNetworkCapabilities(\n                     mConnManager.getActiveNetwork());\n+            Binder.restoreCallingIdentity(token);\n             int policy = getUidPolicy(uid);\n             if (nc != null\n                     && ((nc.hasTransport(TRANSPORT_VPN) && ((policy & POLICY_REJECT_VPN) != 0))\n@@ -4274,6 +4276,8 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {\n                     == PERMISSION_GRANTED;\n         } catch (RemoteException e) {\n             return false;\n+        } finally {\n+            Binder.restoreCallingIdentity(token);\n         }\n     }\n \n",
    "added_lines": 4,
    "deleted_lines": 0,
    "changed_methods": "NetworkPolicyManagerService::hasRestrictedModeAccess"
   }
  ]
 },
 {
  "hash": "8ba3b2ecf62593344757329e9934db6f2a574276",
  "commit": "fixup! fw/b: Add support for allowing/disallowing apps on cellular, vpn and wifi networks\n\n* Listen to changes in all networks\n* Limit backend calls during network capability changes to transport changes\n* Allow traffic over VPN networks if policy does not restrict it even if other transports are present\n\nChange-Id: I0d719bb7c7f04a493a4ddefa8e6154ef4159abd0",
  "files": [
   {
    "filename": "NetworkPolicyManagerService.java",
    "diff": "@@ -62,6 +62,7 @@ import static android.net.INetd.FIREWALL_RULE_ALLOW;\n import static android.net.INetd.FIREWALL_RULE_DENY;\n import static android.net.NetworkCapabilities.NET_CAPABILITY_NOT_METERED;\n import static android.net.NetworkCapabilities.NET_CAPABILITY_NOT_ROAMING;\n+import static android.net.NetworkCapabilities.NET_CAPABILITY_NOT_VPN;\n import static android.net.NetworkCapabilities.TRANSPORT_CELLULAR;\n import static android.net.NetworkCapabilities.TRANSPORT_VPN;\n import static android.net.NetworkCapabilities.TRANSPORT_WIFI;\n@@ -626,6 +627,9 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {\n     /** Map from network ID to last observed roaming state */\n     @GuardedBy(\"mNetworkPoliciesSecondLock\")\n     private final SparseBooleanArray mNetworkRoaming = new SparseBooleanArray();\n+    /** Map from network ID to last observed transports state */\n+    @GuardedBy(\"mNetworkPoliciesSecondLock\")\n+    private final SparseArray<int[]> mNetworkTransports = new SparseArray<>();\n \n     /** Map from netId to subId as of last update */\n     @GuardedBy(\"mNetworkPoliciesSecondLock\")\n@@ -1027,6 +1031,14 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {\n                     ACTION_CARRIER_CONFIG_CHANGED);\n             mContext.registerReceiver(mCarrierConfigReceiver, carrierConfigFilter, null, mHandler);\n \n+            for (UserInfo userInfo : mUserManager.getAliveUsers()) {\n+                mConnManager.registerDefaultNetworkCallbackForUid(\n+                        UserHandle.getUid(userInfo.id, Process.myUid()),\n+                        mDefaultNetworkCallback,\n+                        mUidEventHandler\n+                );\n+            }\n+\n             // listen for meteredness changes\n             mConnManager.registerNetworkCallback(\n                     new NetworkRequest.Builder().build(), mNetworkCallback);\n@@ -1207,6 +1219,11 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {\n                                 ConnectivitySettingsManager.getUidsAllowedOnRestrictedNetworks(\n                                         mContext);\n                         if (action == ACTION_USER_ADDED) {\n+                            mConnManager.registerDefaultNetworkCallbackForUid(\n+                                    UserHandle.getUid(userId, Process.myUid()),\n+                                    mDefaultNetworkCallback,\n+                                    mUidEventHandler\n+                            );\n                             // Add apps that are allowed by default.\n                             addDefaultRestrictBackgroundAllowlistUidsUL(userId);\n                             try {\n@@ -1311,6 +1328,35 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {\n         return changed;\n     }\n \n+    private static boolean updateTransportChange(SparseArray<int[]> lastValues, int[] newValue,\n+            Network network) {\n+        final int[] lastValue = lastValues.get(network.getNetId(), new int[]{});\n+        final boolean changed = (!Arrays.equals(lastValue, newValue))\n+                || lastValues.indexOfKey(network.getNetId()) < 0;\n+        if (changed) {\n+            lastValues.put(network.getNetId(), newValue);\n+        }\n+        return changed;\n+    }\n+\n+    private final NetworkCallback mDefaultNetworkCallback = new NetworkCallback() {\n+        @Override\n+        public void onAvailable(@NonNull Network network) {\n+            updateRestrictedModeAllowlistUL();\n+        }\n+\n+        @Override\n+        public void onCapabilitiesChanged(@NonNull Network network,\n+                @NonNull NetworkCapabilities networkCapabilities) {\n+            final int[] newTransports = networkCapabilities.getTransportTypes();\n+            final boolean transportsChanged = updateTransportChange(\n+                    mNetworkTransports, newTransports, network);\n+            if (transportsChanged) {\n+                updateRestrictedModeAllowlistUL();\n+            }\n+        }\n+    };\n+\n     private final NetworkCallback mNetworkCallback = new NetworkCallback() {\n         @Override\n         public void onCapabilitiesChanged(Network network,\n@@ -1332,7 +1378,6 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {\n                     mLogger.meterednessChanged(network.getNetId(), newMetered);\n                     updateNetworkRulesNL();\n                 }\n-                updateRestrictedModeAllowlistUL();\n             }\n         }\n     };\n@@ -4252,32 +4297,50 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {\n     }\n \n     private boolean hasRestrictedModeAccess(int uid) {\n-        final long token = Binder.clearCallingIdentity();\n         try {\n-            NetworkCapabilities nc = mConnManager.getNetworkCapabilities(\n-                    mConnManager.getActiveNetwork());\n-            Binder.restoreCallingIdentity(token);\n-            int policy = getUidPolicy(uid);\n-            if (nc != null\n-                    && ((nc.hasTransport(TRANSPORT_VPN) && ((policy & POLICY_REJECT_VPN) != 0))\n-                    || (nc.hasTransport(TRANSPORT_CELLULAR) && ((policy & POLICY_REJECT_CELLULAR)\n-                    != 0))\n-                    || (nc.hasTransport(TRANSPORT_WIFI) && ((policy & POLICY_REJECT_WIFI) != 0)))) {\n-                return false;\n-            }\n             // TODO: this needs to be kept in sync with\n             // PermissionMonitor#hasRestrictedNetworkPermission\n-            return ConnectivitySettingsManager.getUidsAllowedOnRestrictedNetworks(mContext)\n+            // Check for restricted-networking-mode status\n+            final boolean isUidAllowedOnRestrictedNetworks =\n+                    ConnectivitySettingsManager.getUidsAllowedOnRestrictedNetworks(mContext)\n                     .contains(uid)\n                     || mIPm.checkUidPermission(CONNECTIVITY_USE_RESTRICTED_NETWORKS, uid)\n                     == PERMISSION_GRANTED\n                     || mIPm.checkUidPermission(NETWORK_STACK, uid) == PERMISSION_GRANTED\n                     || mIPm.checkUidPermission(PERMISSION_MAINLINE_NETWORK_STACK, uid)\n                     == PERMISSION_GRANTED;\n+\n+            // Check for other policies (data-restrictions)\n+            final long token = Binder.clearCallingIdentity();\n+            NetworkCapabilities nc;\n+            try {\n+                nc = mConnManager.getNetworkCapabilities(mConnManager.getActiveNetwork());\n+            } finally {\n+                Binder.restoreCallingIdentity(token);\n+            }\n+            boolean isUidRestrictedByPolicy = false;\n+            if (isUidAllowedOnRestrictedNetworks && nc != null) {\n+                int policy = getUidPolicy(uid);\n+                final boolean isUidAllowedOnVpn = nc.hasTransport(TRANSPORT_VPN)\n+                        && ((policy & POLICY_REJECT_VPN) == 0);\n+                if (!isUidAllowedOnVpn) {\n+                    final boolean isUidRestrictedOnCell = nc.hasTransport(TRANSPORT_CELLULAR)\n+                            && ((policy & POLICY_REJECT_CELLULAR) != 0);\n+                    final boolean isUidRestrictedOnVpn = nc.hasTransport(TRANSPORT_VPN)\n+                            && ((policy & POLICY_REJECT_VPN) != 0);\n+                    final boolean isUidRestrictedOnWifi = nc.hasTransport(TRANSPORT_WIFI)\n+                            && ((policy & POLICY_REJECT_WIFI) != 0);\n+                    if (isUidRestrictedOnVpn || isUidRestrictedOnCell || isUidRestrictedOnWifi) {\n+                            isUidRestrictedByPolicy = true;\n+                    }\n+                }\n+            }\n+            // If app is restricted (aka not on the allowlist), it's not allowed to use the internet\n+            // If it is on the allowlist, then we also check its networking is not blocked\n+            // (aka active network is not null) and then other policies\n+            return isUidAllowedOnRestrictedNetworks && nc != null && !isUidRestrictedByPolicy;\n         } catch (RemoteException e) {\n             return false;\n-        } finally {\n-            Binder.restoreCallingIdentity(token);\n         }\n     }\n \n",
    "added_lines": 79,
    "deleted_lines": 16,
    "changed_methods": "NetworkPolicyManagerService::hasRestrictedModeAccess, NetworkPolicyManagerService::updateTransportChange, NetworkPolicyManagerService::initService, NetworkPolicyManagerService::BroadcastReceiver, NetworkPolicyManagerService::NetworkCallback"
   }
  ]
 },
 {
  "hash": "94af8f82a44c09f7cafabc7bffa06b2e52ca787b",
  "commit": "restricted-networking: Always log newly installed apps being added to the allowlist\n\n* This way we can try to track down rare issues noticed where\n  sometimes an app didn't get added to the allowlist, or it got\n  added when it shouldn't have.\n\nChange-Id: Ib95f80918feb5db95766837e5708ad070f2d1070",
  "files": [
   {
    "filename": "NetworkPolicyManagerService.java",
    "diff": "@@ -1158,10 +1158,10 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {\n             if (ACTION_PACKAGE_ADDED.equals(action)) {\n                 // update rules for UID, since it might be subject to\n                 // global background data policy\n-                if (LOGV) Slog.v(TAG, \"ACTION_PACKAGE_ADDED for uid=\" + uid);\n                 // Clear the cache for the app\n                 synchronized (mUidRulesFirstLock) {\n                     if (hasInternetPermissionUL(uid)) {\n+                        Slog.i(TAG, \"ACTION_PACKAGE_ADDED for uid=\" + uid);\n                         Set<Integer> uids =\n                                 ConnectivitySettingsManager.getUidsAllowedOnRestrictedNetworks(\n                                         context);\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "NetworkPolicyManagerService::BroadcastReceiver"
   }
  ]
 },
 {
  "hash": "cd997ae00ace81cd210ef028032de27462eb7ce4",
  "commit": "restricted-networking: Always log UID removal\n\n* Will help debug any issues that may or may not arise.\n\nChange-Id: I40f0937b921a83dfdee14891b791a067ae463b95",
  "files": [
   {
    "filename": "NetworkPolicyManagerService.java",
    "diff": "@@ -1185,7 +1185,7 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {\n             if (uid == -1) return;\n \n             // remove any policy and update rules to clean up\n-            if (LOGV) Slog.v(TAG, \"ACTION_UID_REMOVED for uid=\" + uid);\n+            Slog.i(TAG, \"ACTION_UID_REMOVED for uid=\" + uid);\n             synchronized (mUidRulesFirstLock) {\n                 onUidDeletedUL(uid);\n                 synchronized (mNetworkPoliciesSecondLock) {\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "NetworkPolicyManagerService::BroadcastReceiver"
   }
  ]
 },
 {
  "hash": "9d57437aaeaaafbf9de681afed1fbd406935a8d8",
  "commit": "restricted-networking: Only add newly installed apps to the allowlist, not upgrades\n\n* Upgrading apps still sends PACKAGE_ADDED, since it's sent for\n  \"new package installs\", which technically an upgrade still is.\n* Check EXTRA_REPLACING to see if it's a new app.\n* Avoids unconditionally turning on networking on app upgrade\n\nChange-Id: Ie7a4090101d47c7033b7f41792e943129dba0700",
  "files": [
   {
    "filename": "NetworkPolicyManagerService.java",
    "diff": "@@ -33,6 +33,7 @@ import static android.content.Intent.ACTION_PACKAGE_ADDED;\n import static android.content.Intent.ACTION_UID_REMOVED;\n import static android.content.Intent.ACTION_USER_ADDED;\n import static android.content.Intent.ACTION_USER_REMOVED;\n+import static android.content.Intent.EXTRA_REPLACING;\n import static android.content.Intent.EXTRA_UID;\n import static android.content.pm.PackageManager.MATCH_ANY_USER;\n import static android.content.pm.PackageManager.MATCH_DIRECT_BOOT_AWARE;\n@@ -1155,6 +1156,11 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {\n             final int uid = intent.getIntExtra(EXTRA_UID, -1);\n             if (uid == -1) return;\n \n+            if (intent.getBooleanExtra(EXTRA_REPLACING, false)) {\n+                if (LOGV) Slog.v(TAG, \"ACTION_PACKAGE_ADDED Not new app, skip it uid=\" + uid);\n+                return;\n+            }\n+\n             if (ACTION_PACKAGE_ADDED.equals(action)) {\n                 // update rules for UID, since it might be subject to\n                 // global background data policy\n",
    "added_lines": 6,
    "deleted_lines": 0,
    "changed_methods": "NetworkPolicyManagerService::BroadcastReceiver"
   }
  ]
 },
 {
  "hash": "759bccdedd80beb711ae950d38d5ddbbd88c7e30",
  "commit": "restricted-networking: Add a marker policy for network-isolation migration\n\n* We remove the pre-12 POLICY_REJECT_ALL (network-isolation) since it's\n  been replaced with restricted-networking-mode.\n* However, if the migration fails, there's no way of knowing, since\n  restricted-networking-mode is an allowlist\n* Add a new marker policy that is not used anywhere, just so that we\n  can debug migration problems easily with\n  `adb shell dumpsys netpolicy`\n* Can be easily removed later once we know for sure this works well (12L perhaps)\n\nChange-Id: I349eb146d4af935c8ce2d2329ab353d042a319f0",
  "files": [
   {
    "filename": "NetworkPolicyManager.java",
    "diff": "@@ -103,6 +103,10 @@ public class NetworkPolicyManager {\n      * @hide\n      */\n     public static final int POLICY_REJECT_ALL = 0x40000;\n+    /** Reject network usage on all networks, migration helper\n+     * @hide\n+     */\n+    public static final int POLICY_REJECT_ALL_MIGRATED = 0x80000;\n \n     /*\n      * Rules defining whether an uid has access to a network given its type (metered / non-metered).\n",
    "added_lines": 4,
    "deleted_lines": 0,
    "changed_methods": ""
   },
   {
    "filename": "NetworkPolicyManagerService.java",
    "diff": "@@ -89,6 +89,7 @@ import static android.net.NetworkPolicyManager.MASK_RESTRICTED_MODE_NETWORKS;\n import static android.net.NetworkPolicyManager.POLICY_ALLOW_METERED_BACKGROUND;\n import static android.net.NetworkPolicyManager.POLICY_NONE;\n import static android.net.NetworkPolicyManager.POLICY_REJECT_ALL;\n+import static android.net.NetworkPolicyManager.POLICY_REJECT_ALL_MIGRATED;\n import static android.net.NetworkPolicyManager.POLICY_REJECT_CELLULAR;\n import static android.net.NetworkPolicyManager.POLICY_REJECT_METERED_BACKGROUND;\n import static android.net.NetworkPolicyManager.POLICY_REJECT_VPN;\n@@ -2477,6 +2478,7 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {\n \n         // Clear policy to avoid future conflicts\n         for (int uid : uidsToDeny) {\n+            addUidPolicy(uid, POLICY_REJECT_ALL_MIGRATED);\n             removeUidPolicy(uid, POLICY_REJECT_ALL);\n         }\n     }\n",
    "added_lines": 2,
    "deleted_lines": 0,
    "changed_methods": "NetworkPolicyManagerService::migrateNetworkIsolation"
   }
  ]
 },
 {
  "hash": "759bccdedd80beb711ae950d38d5ddbbd88c7e30",
  "commit": "restricted-networking: Add a marker policy for network-isolation migration\n\n* We remove the pre-12 POLICY_REJECT_ALL (network-isolation) since it's\n  been replaced with restricted-networking-mode.\n* However, if the migration fails, there's no way of knowing, since\n  restricted-networking-mode is an allowlist\n* Add a new marker policy that is not used anywhere, just so that we\n  can debug migration problems easily with\n  `adb shell dumpsys netpolicy`\n* Can be easily removed later once we know for sure this works well (12L perhaps)\n\nChange-Id: I349eb146d4af935c8ce2d2329ab353d042a319f0",
  "files": [
   {
    "filename": "NetworkPolicyManager.java",
    "diff": "@@ -103,6 +103,10 @@ public class NetworkPolicyManager {\n      * @hide\n      */\n     public static final int POLICY_REJECT_ALL = 0x40000;\n+    /** Reject network usage on all networks, migration helper\n+     * @hide\n+     */\n+    public static final int POLICY_REJECT_ALL_MIGRATED = 0x80000;\n \n     /*\n      * Rules defining whether an uid has access to a network given its type (metered / non-metered).\n",
    "added_lines": 4,
    "deleted_lines": 0,
    "changed_methods": ""
   },
   {
    "filename": "NetworkPolicyManagerService.java",
    "diff": "@@ -89,6 +89,7 @@ import static android.net.NetworkPolicyManager.MASK_RESTRICTED_MODE_NETWORKS;\n import static android.net.NetworkPolicyManager.POLICY_ALLOW_METERED_BACKGROUND;\n import static android.net.NetworkPolicyManager.POLICY_NONE;\n import static android.net.NetworkPolicyManager.POLICY_REJECT_ALL;\n+import static android.net.NetworkPolicyManager.POLICY_REJECT_ALL_MIGRATED;\n import static android.net.NetworkPolicyManager.POLICY_REJECT_CELLULAR;\n import static android.net.NetworkPolicyManager.POLICY_REJECT_METERED_BACKGROUND;\n import static android.net.NetworkPolicyManager.POLICY_REJECT_VPN;\n@@ -2477,6 +2478,7 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {\n \n         // Clear policy to avoid future conflicts\n         for (int uid : uidsToDeny) {\n+            addUidPolicy(uid, POLICY_REJECT_ALL_MIGRATED);\n             removeUidPolicy(uid, POLICY_REJECT_ALL);\n         }\n     }\n",
    "added_lines": 2,
    "deleted_lines": 0,
    "changed_methods": "NetworkPolicyManagerService::migrateNetworkIsolation"
   }
  ]
 },
 {
  "hash": "f507e578bb9e8539493dce829307b28b865fdc2a",
  "commit": "fixup! Implement backup/restore for network policy\n\n* Add handling for secondary users\n\nChange-Id: I7d5806650f7f3a30638d9fac7848bd8d0bfda9a6",
  "files": [
   {
    "filename": "NetworkPolicyBackupHelper.java",
    "diff": "@@ -33,8 +33,11 @@ public class NetworkPolicyBackupHelper extends BlobBackupHelper {\n     // Key under which the payload blob is stored\n     static final String KEY_NETWORK_POLICY = \"network_policy\";\n \n-    public NetworkPolicyBackupHelper() {\n+    private final int mUserId;\n+\n+    public NetworkPolicyBackupHelper(int userId) {\n         super(BLOB_VERSION, KEY_NETWORK_POLICY);\n+        mUserId = userId;\n     }\n \n     @Override\n@@ -44,10 +47,10 @@ public class NetworkPolicyBackupHelper extends BlobBackupHelper {\n             try {\n                 INetworkPolicyManager npm = INetworkPolicyManager.Stub.asInterface(\n                         ServiceManager.getService(Context.NETWORK_POLICY_SERVICE));\n-                newPayload = npm.getBackupPayload();\n+                newPayload = npm.getBackupPayload(mUserId);\n             } catch (Exception e) {\n                 // Treat as no data\n-                Slog.e(TAG, \"Couldn't communicate with network policy manager\");\n+                Slog.e(TAG, \"Couldn't communicate with network policy manager\", e);\n                 newPayload = null;\n             }\n         }\n@@ -64,9 +67,9 @@ public class NetworkPolicyBackupHelper extends BlobBackupHelper {\n             try {\n                 INetworkPolicyManager.Stub.asInterface(\n                         ServiceManager.getService(Context.NETWORK_POLICY_SERVICE))\n-                        .applyRestore(payload);\n+                        .applyRestore(payload, mUserId);\n             } catch (Exception e) {\n-                Slog.e(TAG, \"Couldn't communicate with network policy manager\");\n+                Slog.e(TAG, \"Couldn't communicate with network policy manager\", e);\n             }\n         }\n     }\n",
    "added_lines": 8,
    "deleted_lines": 5,
    "changed_methods": "NetworkPolicyBackupHelper::applyRestoredPayload, NetworkPolicyBackupHelper::NetworkPolicyBackupHelper, NetworkPolicyBackupHelper::getBackupPayload, NetworkPolicyBackupHelper::NetworkPolicyBackupHelper"
   },
   {
    "filename": "SystemBackupAgent.java",
    "diff": "@@ -84,7 +84,7 @@ public class SystemBackupAgent extends BackupAgentHelper {\n     private static final String WALLPAPER_IMAGE_KEY = WallpaperBackupHelper.WALLPAPER_IMAGE_KEY;\n \n     private static final Set<String> sEligibleForMultiUser = Sets.newArraySet(\n-            PERMISSION_HELPER, NOTIFICATION_HELPER, SYNC_SETTINGS_HELPER);\n+            PERMISSION_HELPER, NOTIFICATION_HELPER, SYNC_SETTINGS_HELPER, NETWORK_POLICY_HELPER);\n \n     private int mUserId = UserHandle.USER_SYSTEM;\n \n@@ -103,7 +103,7 @@ public class SystemBackupAgent extends BackupAgentHelper {\n         addHelper(ACCOUNT_MANAGER_HELPER, new AccountManagerBackupHelper());\n         addHelper(SLICES_HELPER, new SliceBackupHelper(this));\n         addHelper(PEOPLE_HELPER, new PeopleBackupHelper(mUserId));\n-        addHelper(NETWORK_POLICY_HELPER, new NetworkPolicyBackupHelper());\n+        addHelper(NETWORK_POLICY_HELPER, new NetworkPolicyBackupHelper(mUserId));\n     }\n \n     @Override\n",
    "added_lines": 2,
    "deleted_lines": 2,
    "changed_methods": "SystemBackupAgent::onCreate"
   },
   {
    "filename": "NetworkPolicyManagerService.java",
    "diff": "@@ -426,7 +426,6 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {\n     private static final String ATTR_OWNER_PACKAGE = \"ownerPackage\";\n     private static final String ATTR_NETWORK_TYPES = \"networkTypes\";\n     private static final String ATTR_XML_UTILS_NAME = \"name\";\n-    private static final String ATTR_USER_ID = \"userId\";\n \n     private static final String ACTION_ALLOW_BACKGROUND =\n             \"com.android.server.net.action.ALLOW_BACKGROUND\";\n@@ -2496,7 +2495,7 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {\n         FileInputStream fis = null;\n         try {\n             fis = mPolicyFile.openRead();\n-            readPolicyXml(fis, false);\n+            readPolicyXml(fis, false, UserHandle.USER_ALL);\n         } catch (FileNotFoundException e) {\n             // missing policy is okay, probably first boot\n             upgradeDefaultBackgroundDataUL();\n@@ -2510,8 +2509,8 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {\n         migrateNetworkIsolation();\n     }\n \n-    private void readPolicyXml(InputStream inputStream, boolean forRestore) throws IOException,\n-            XmlPullParserException {\n+    private void readPolicyXml(InputStream inputStream, boolean forRestore, int userId)\n+            throws IOException, XmlPullParserException {\n         final TypedXmlPullParser in = Xml.resolvePullParser(inputStream);\n \n          // Must save the <restrict-background> tags and convert them to <uid-policy> later,\n@@ -2671,7 +2670,7 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {\n                             SubscriptionPlan.class, mSubscriptionPlans.get(subId), plan));\n                     mSubscriptionPlansOwner.put(subId, ownerPackage);\n                 } else if (TAG_UID_POLICY.equals(tag)) {\n-                    int uid = readUidAttribute(in, forRestore);\n+                    int uid = readUidAttribute(in, forRestore, userId);\n                     final int policy = readIntAttribute(in, ATTR_POLICY);\n \n                     if (UserHandle.isApp(uid)) {\n@@ -2694,10 +2693,10 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {\n                 } else if (TAG_WHITELIST.equals(tag)) {\n                     insideAllowlist = true;\n                 } else if (TAG_RESTRICT_BACKGROUND.equals(tag) && insideAllowlist) {\n-                    int uid = readUidAttribute(in, forRestore);\n+                    int uid = readUidAttribute(in, forRestore, userId);\n                     restrictBackgroundAllowedUids.append(uid, true);\n                 } else if (TAG_REVOKED_RESTRICT_BACKGROUND.equals(tag) && insideAllowlist) {\n-                    int uid = readUidAttribute(in, forRestore);\n+                    int uid = readUidAttribute(in, forRestore, userId);\n                     mRestrictBackgroundAllowlistRevokedUids.put(uid, true);\n                 }\n             } else if (type == END_TAG) {\n@@ -2801,7 +2800,7 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {\n         FileOutputStream fos = null;\n         try {\n             fos = mPolicyFile.startWrite();\n-            writePolicyXml(fos, false);\n+            writePolicyXml(fos, false, UserHandle.USER_ALL);\n             mPolicyFile.finishWrite(fos);\n         } catch (IOException e) {\n             if (fos != null) {\n@@ -2810,10 +2809,64 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {\n         }\n     }\n \n-    private void writePolicyXml(OutputStream outputStream, boolean forBackup) throws IOException {\n+    private void writePolicyXml(OutputStream outputStream, boolean forBackup, int userId)\n+            throws IOException {\n         TypedXmlSerializer out = Xml.resolveSerializer(outputStream);\n         out.startDocument(null, true);\n \n+        // only write UID-independent attributes during normal operation or system user backups\n+        if (!forBackup || userId == UserHandle.USER_SYSTEM) {\n+            writeUidIndependentAttributes(out);\n+        }\n+\n+        // write all known uid policies\n+        for (int i = 0; i < mUidPolicy.size(); i++) {\n+            final int uid = mUidPolicy.keyAt(i);\n+            final int policy = mUidPolicy.valueAt(i);\n+\n+            // skip writing policies belonging to other users\n+            if (forBackup && UserHandle.getUserId(uid) != userId) {\n+                continue;\n+            }\n+            // skip writing empty policies\n+            if (policy == POLICY_NONE) continue;\n+\n+            out.startTag(null, TAG_UID_POLICY);\n+            if (!forBackup) {\n+                writeIntAttribute(out, ATTR_UID, uid);\n+            } else {\n+                writeStringAttribute(out, ATTR_XML_UTILS_NAME, getPackageForUid(uid));\n+            }\n+            writeIntAttribute(out, ATTR_POLICY, policy);\n+            out.endTag(null, TAG_UID_POLICY);\n+        }\n+\n+        // write all allowlists\n+        out.startTag(null, TAG_WHITELIST);\n+\n+        // revoked restrict background allowlist\n+        int size = mRestrictBackgroundAllowlistRevokedUids.size();\n+        for (int i = 0; i < size; i++) {\n+            final int uid = mRestrictBackgroundAllowlistRevokedUids.keyAt(i);\n+            // skip writing policies belonging to other users\n+            if (forBackup && UserHandle.getUserId(uid) != userId) {\n+                continue;\n+            }\n+            out.startTag(null, TAG_REVOKED_RESTRICT_BACKGROUND);\n+            if (!forBackup) {\n+                writeIntAttribute(out, ATTR_UID, uid);\n+            } else {\n+                writeStringAttribute(out, ATTR_XML_UTILS_NAME, getPackageForUid(uid));\n+            }\n+            out.endTag(null, TAG_REVOKED_RESTRICT_BACKGROUND);\n+        }\n+\n+        out.endTag(null, TAG_WHITELIST);\n+\n+        out.endDocument();\n+    }\n+\n+    private void writeUidIndependentAttributes(TypedXmlSerializer out) throws IOException {\n         out.startTag(null, TAG_POLICY_LIST);\n         writeIntAttribute(out, ATTR_VERSION, VERSION_LATEST);\n         writeBooleanAttribute(out, ATTR_RESTRICT_BACKGROUND, mRestrictBackground);\n@@ -2880,89 +2933,43 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {\n                 writeLongAttribute(out, ATTR_USAGE_TIME, plan.getDataUsageTime());\n                 try {\n                     writeIntArrayXml(plan.getNetworkTypes(), ATTR_NETWORK_TYPES, out);\n-                } catch (XmlPullParserException ignored) { }\n+                } catch (XmlPullParserException ignored) {\n+                }\n                 out.endTag(null, TAG_SUBSCRIPTION_PLAN);\n             }\n         }\n-\n-        // write all known uid policies\n-        for (int i = 0; i < mUidPolicy.size(); i++) {\n-            final int uid = mUidPolicy.keyAt(i);\n-            final int policy = mUidPolicy.valueAt(i);\n-\n-            // skip writing empty policies\n-            if (policy == POLICY_NONE) continue;\n-\n-            out.startTag(null, TAG_UID_POLICY);\n-            if (!forBackup) {\n-                writeIntAttribute(out, ATTR_UID, uid);\n-            } else {\n-                writeStringAttribute(out, ATTR_XML_UTILS_NAME, getPackageForUid(uid));\n-                writeIntAttribute(out, ATTR_USER_ID, UserHandle.getUserId(uid));\n-            }\n-            writeIntAttribute(out, ATTR_POLICY, policy);\n-            out.endTag(null, TAG_UID_POLICY);\n-        }\n-\n         out.endTag(null, TAG_POLICY_LIST);\n-\n-        // write all allowlists\n-        out.startTag(null, TAG_WHITELIST);\n-\n-        // revoked restrict background allowlist\n-        int size = mRestrictBackgroundAllowlistRevokedUids.size();\n-        for (int i = 0; i < size; i++) {\n-            final int uid = mRestrictBackgroundAllowlistRevokedUids.keyAt(i);\n-            out.startTag(null, TAG_REVOKED_RESTRICT_BACKGROUND);\n-            if (!forBackup) {\n-                writeIntAttribute(out, ATTR_UID, uid);\n-            } else {\n-                writeStringAttribute(out, ATTR_XML_UTILS_NAME, getPackageForUid(uid));\n-                writeIntAttribute(out, ATTR_USER_ID, UserHandle.getUserId(uid));\n-            }\n-            out.endTag(null, TAG_REVOKED_RESTRICT_BACKGROUND);\n-        }\n-\n-        out.endTag(null, TAG_WHITELIST);\n-\n-        out.endDocument();\n     }\n \n     @Override\n-    public byte[] getBackupPayload() {\n+    public byte[] getBackupPayload(int user) {\n         enforceSystemCaller();\n-        if (LOGD) Slog.d(TAG, \"getBackupPayload\");\n+        if (LOGD) Slog.d(TAG, \"getBackupPayload u= \" + user);\n         final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n         try {\n-            writePolicyXml(baos, true);\n+            writePolicyXml(baos, true, user);\n             return baos.toByteArray();\n         } catch (IOException e) {\n-            Slog.w(TAG, \"getBackupPayload: error writing payload\", e);\n+            Slog.w(TAG, \"getBackupPayload: error writing payload for user \" + user, e);\n         }\n         return null;\n     }\n \n     @Override\n-    public void applyRestore(byte[] payload) {\n+    public void applyRestore(byte[] payload, int user) {\n         enforceSystemCaller();\n-        if (LOGD) Slog.d(TAG, \"applyRestore payload=\"\n+        if (LOGD) Slog.d(TAG, \"applyRestore u=\" + user + \" payload=\"\n                 + (payload != null ? new String(payload, StandardCharsets.UTF_8) : null));\n         if (payload == null) {\n-            Slog.w(TAG, \"applyRestore: no payload to restore\");\n+            Slog.w(TAG, \"applyRestore: no payload to restore for user \" + user);\n             return;\n         }\n \n-        // clear any existing policy and read from disk\n-        mNetworkPolicy.clear();\n-        mSubscriptionPlans.clear();\n-        mSubscriptionPlansOwner.clear();\n-        mUidPolicy.clear();\n-\n         final ByteArrayInputStream bais = new ByteArrayInputStream(payload);\n         try {\n-            readPolicyXml(bais, true);\n+            readPolicyXml(bais, true, user);\n         } catch (IOException | XmlPullParserException e) {\n-            Slog.w(TAG, \"applyRestore: error reading payload\", e);\n+            Slog.w(TAG, \"applyRestore: error reading payload for user \" + user, e);\n         }\n \n         // Migrate from pre-12 network-isolation to restricted-networking-mode\n@@ -6096,17 +6103,21 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {\n         }\n     }\n \n-    private int readUidAttribute(TypedXmlPullParser in, boolean forRestore) throws IOException {\n+    private int readUidAttribute(TypedXmlPullParser in, boolean forRestore, int userId)\n+            throws IOException {\n         if (!forRestore) {\n             return readIntAttribute(in, ATTR_UID);\n         } else {\n-            return getUidForPackage(readStringAttribute(in, ATTR_XML_UTILS_NAME),\n-                    readIntAttribute(in, ATTR_USER_ID));\n+            return getUidForPackage(readStringAttribute(in, ATTR_XML_UTILS_NAME), userId);\n         }\n     }\n \n     private String getPackageForUid(int uid) {\n-        return mContext.getPackageManager().getPackagesForUid(uid)[0];\n+        try {\n+            return mContext.getPackageManager().getPackagesForUid(uid)[0];\n+        } catch (Exception e) {\n+            return null;\n+        }\n     }\n \n     private int getUidForPackage(String packageName, int userId) {\n",
    "added_lines": 81,
    "deleted_lines": 70,
    "changed_methods": "NetworkPolicyManagerService::readPolicyAL, NetworkPolicyManagerService::applyRestore, NetworkPolicyManagerService::readUidAttribute, NetworkPolicyManagerService::applyRestore, NetworkPolicyManagerService::getBackupPayload, NetworkPolicyManagerService::writePolicyXml, NetworkPolicyManagerService::writePolicyXml, NetworkPolicyManagerService::getBackupPayload, NetworkPolicyManagerService::readUidAttribute, NetworkPolicyManagerService::getPackageForUid, NetworkPolicyManagerService::readPolicyXml, NetworkPolicyManagerService::writePolicyAL, NetworkPolicyManagerService::readPolicyXml, NetworkPolicyManagerService::writeUidIndependentAttributes"
   }
  ]
 },
 {
  "hash": "f507e578bb9e8539493dce829307b28b865fdc2a",
  "commit": "fixup! Implement backup/restore for network policy\n\n* Add handling for secondary users\n\nChange-Id: I7d5806650f7f3a30638d9fac7848bd8d0bfda9a6",
  "files": [
   {
    "filename": "NetworkPolicyBackupHelper.java",
    "diff": "@@ -33,8 +33,11 @@ public class NetworkPolicyBackupHelper extends BlobBackupHelper {\n     // Key under which the payload blob is stored\n     static final String KEY_NETWORK_POLICY = \"network_policy\";\n \n-    public NetworkPolicyBackupHelper() {\n+    private final int mUserId;\n+\n+    public NetworkPolicyBackupHelper(int userId) {\n         super(BLOB_VERSION, KEY_NETWORK_POLICY);\n+        mUserId = userId;\n     }\n \n     @Override\n@@ -44,10 +47,10 @@ public class NetworkPolicyBackupHelper extends BlobBackupHelper {\n             try {\n                 INetworkPolicyManager npm = INetworkPolicyManager.Stub.asInterface(\n                         ServiceManager.getService(Context.NETWORK_POLICY_SERVICE));\n-                newPayload = npm.getBackupPayload();\n+                newPayload = npm.getBackupPayload(mUserId);\n             } catch (Exception e) {\n                 // Treat as no data\n-                Slog.e(TAG, \"Couldn't communicate with network policy manager\");\n+                Slog.e(TAG, \"Couldn't communicate with network policy manager\", e);\n                 newPayload = null;\n             }\n         }\n@@ -64,9 +67,9 @@ public class NetworkPolicyBackupHelper extends BlobBackupHelper {\n             try {\n                 INetworkPolicyManager.Stub.asInterface(\n                         ServiceManager.getService(Context.NETWORK_POLICY_SERVICE))\n-                        .applyRestore(payload);\n+                        .applyRestore(payload, mUserId);\n             } catch (Exception e) {\n-                Slog.e(TAG, \"Couldn't communicate with network policy manager\");\n+                Slog.e(TAG, \"Couldn't communicate with network policy manager\", e);\n             }\n         }\n     }\n",
    "added_lines": 8,
    "deleted_lines": 5,
    "changed_methods": "NetworkPolicyBackupHelper::applyRestoredPayload, NetworkPolicyBackupHelper::NetworkPolicyBackupHelper, NetworkPolicyBackupHelper::getBackupPayload, NetworkPolicyBackupHelper::NetworkPolicyBackupHelper"
   },
   {
    "filename": "SystemBackupAgent.java",
    "diff": "@@ -84,7 +84,7 @@ public class SystemBackupAgent extends BackupAgentHelper {\n     private static final String WALLPAPER_IMAGE_KEY = WallpaperBackupHelper.WALLPAPER_IMAGE_KEY;\n \n     private static final Set<String> sEligibleForMultiUser = Sets.newArraySet(\n-            PERMISSION_HELPER, NOTIFICATION_HELPER, SYNC_SETTINGS_HELPER);\n+            PERMISSION_HELPER, NOTIFICATION_HELPER, SYNC_SETTINGS_HELPER, NETWORK_POLICY_HELPER);\n \n     private int mUserId = UserHandle.USER_SYSTEM;\n \n@@ -103,7 +103,7 @@ public class SystemBackupAgent extends BackupAgentHelper {\n         addHelper(ACCOUNT_MANAGER_HELPER, new AccountManagerBackupHelper());\n         addHelper(SLICES_HELPER, new SliceBackupHelper(this));\n         addHelper(PEOPLE_HELPER, new PeopleBackupHelper(mUserId));\n-        addHelper(NETWORK_POLICY_HELPER, new NetworkPolicyBackupHelper());\n+        addHelper(NETWORK_POLICY_HELPER, new NetworkPolicyBackupHelper(mUserId));\n     }\n \n     @Override\n",
    "added_lines": 2,
    "deleted_lines": 2,
    "changed_methods": "SystemBackupAgent::onCreate"
   },
   {
    "filename": "NetworkPolicyManagerService.java",
    "diff": "@@ -426,7 +426,6 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {\n     private static final String ATTR_OWNER_PACKAGE = \"ownerPackage\";\n     private static final String ATTR_NETWORK_TYPES = \"networkTypes\";\n     private static final String ATTR_XML_UTILS_NAME = \"name\";\n-    private static final String ATTR_USER_ID = \"userId\";\n \n     private static final String ACTION_ALLOW_BACKGROUND =\n             \"com.android.server.net.action.ALLOW_BACKGROUND\";\n@@ -2496,7 +2495,7 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {\n         FileInputStream fis = null;\n         try {\n             fis = mPolicyFile.openRead();\n-            readPolicyXml(fis, false);\n+            readPolicyXml(fis, false, UserHandle.USER_ALL);\n         } catch (FileNotFoundException e) {\n             // missing policy is okay, probably first boot\n             upgradeDefaultBackgroundDataUL();\n@@ -2510,8 +2509,8 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {\n         migrateNetworkIsolation();\n     }\n \n-    private void readPolicyXml(InputStream inputStream, boolean forRestore) throws IOException,\n-            XmlPullParserException {\n+    private void readPolicyXml(InputStream inputStream, boolean forRestore, int userId)\n+            throws IOException, XmlPullParserException {\n         final TypedXmlPullParser in = Xml.resolvePullParser(inputStream);\n \n          // Must save the <restrict-background> tags and convert them to <uid-policy> later,\n@@ -2671,7 +2670,7 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {\n                             SubscriptionPlan.class, mSubscriptionPlans.get(subId), plan));\n                     mSubscriptionPlansOwner.put(subId, ownerPackage);\n                 } else if (TAG_UID_POLICY.equals(tag)) {\n-                    int uid = readUidAttribute(in, forRestore);\n+                    int uid = readUidAttribute(in, forRestore, userId);\n                     final int policy = readIntAttribute(in, ATTR_POLICY);\n \n                     if (UserHandle.isApp(uid)) {\n@@ -2694,10 +2693,10 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {\n                 } else if (TAG_WHITELIST.equals(tag)) {\n                     insideAllowlist = true;\n                 } else if (TAG_RESTRICT_BACKGROUND.equals(tag) && insideAllowlist) {\n-                    int uid = readUidAttribute(in, forRestore);\n+                    int uid = readUidAttribute(in, forRestore, userId);\n                     restrictBackgroundAllowedUids.append(uid, true);\n                 } else if (TAG_REVOKED_RESTRICT_BACKGROUND.equals(tag) && insideAllowlist) {\n-                    int uid = readUidAttribute(in, forRestore);\n+                    int uid = readUidAttribute(in, forRestore, userId);\n                     mRestrictBackgroundAllowlistRevokedUids.put(uid, true);\n                 }\n             } else if (type == END_TAG) {\n@@ -2801,7 +2800,7 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {\n         FileOutputStream fos = null;\n         try {\n             fos = mPolicyFile.startWrite();\n-            writePolicyXml(fos, false);\n+            writePolicyXml(fos, false, UserHandle.USER_ALL);\n             mPolicyFile.finishWrite(fos);\n         } catch (IOException e) {\n             if (fos != null) {\n@@ -2810,10 +2809,64 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {\n         }\n     }\n \n-    private void writePolicyXml(OutputStream outputStream, boolean forBackup) throws IOException {\n+    private void writePolicyXml(OutputStream outputStream, boolean forBackup, int userId)\n+            throws IOException {\n         TypedXmlSerializer out = Xml.resolveSerializer(outputStream);\n         out.startDocument(null, true);\n \n+        // only write UID-independent attributes during normal operation or system user backups\n+        if (!forBackup || userId == UserHandle.USER_SYSTEM) {\n+            writeUidIndependentAttributes(out);\n+        }\n+\n+        // write all known uid policies\n+        for (int i = 0; i < mUidPolicy.size(); i++) {\n+            final int uid = mUidPolicy.keyAt(i);\n+            final int policy = mUidPolicy.valueAt(i);\n+\n+            // skip writing policies belonging to other users\n+            if (forBackup && UserHandle.getUserId(uid) != userId) {\n+                continue;\n+            }\n+            // skip writing empty policies\n+            if (policy == POLICY_NONE) continue;\n+\n+            out.startTag(null, TAG_UID_POLICY);\n+            if (!forBackup) {\n+                writeIntAttribute(out, ATTR_UID, uid);\n+            } else {\n+                writeStringAttribute(out, ATTR_XML_UTILS_NAME, getPackageForUid(uid));\n+            }\n+            writeIntAttribute(out, ATTR_POLICY, policy);\n+            out.endTag(null, TAG_UID_POLICY);\n+        }\n+\n+        // write all allowlists\n+        out.startTag(null, TAG_WHITELIST);\n+\n+        // revoked restrict background allowlist\n+        int size = mRestrictBackgroundAllowlistRevokedUids.size();\n+        for (int i = 0; i < size; i++) {\n+            final int uid = mRestrictBackgroundAllowlistRevokedUids.keyAt(i);\n+            // skip writing policies belonging to other users\n+            if (forBackup && UserHandle.getUserId(uid) != userId) {\n+                continue;\n+            }\n+            out.startTag(null, TAG_REVOKED_RESTRICT_BACKGROUND);\n+            if (!forBackup) {\n+                writeIntAttribute(out, ATTR_UID, uid);\n+            } else {\n+                writeStringAttribute(out, ATTR_XML_UTILS_NAME, getPackageForUid(uid));\n+            }\n+            out.endTag(null, TAG_REVOKED_RESTRICT_BACKGROUND);\n+        }\n+\n+        out.endTag(null, TAG_WHITELIST);\n+\n+        out.endDocument();\n+    }\n+\n+    private void writeUidIndependentAttributes(TypedXmlSerializer out) throws IOException {\n         out.startTag(null, TAG_POLICY_LIST);\n         writeIntAttribute(out, ATTR_VERSION, VERSION_LATEST);\n         writeBooleanAttribute(out, ATTR_RESTRICT_BACKGROUND, mRestrictBackground);\n@@ -2880,89 +2933,43 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {\n                 writeLongAttribute(out, ATTR_USAGE_TIME, plan.getDataUsageTime());\n                 try {\n                     writeIntArrayXml(plan.getNetworkTypes(), ATTR_NETWORK_TYPES, out);\n-                } catch (XmlPullParserException ignored) { }\n+                } catch (XmlPullParserException ignored) {\n+                }\n                 out.endTag(null, TAG_SUBSCRIPTION_PLAN);\n             }\n         }\n-\n-        // write all known uid policies\n-        for (int i = 0; i < mUidPolicy.size(); i++) {\n-            final int uid = mUidPolicy.keyAt(i);\n-            final int policy = mUidPolicy.valueAt(i);\n-\n-            // skip writing empty policies\n-            if (policy == POLICY_NONE) continue;\n-\n-            out.startTag(null, TAG_UID_POLICY);\n-            if (!forBackup) {\n-                writeIntAttribute(out, ATTR_UID, uid);\n-            } else {\n-                writeStringAttribute(out, ATTR_XML_UTILS_NAME, getPackageForUid(uid));\n-                writeIntAttribute(out, ATTR_USER_ID, UserHandle.getUserId(uid));\n-            }\n-            writeIntAttribute(out, ATTR_POLICY, policy);\n-            out.endTag(null, TAG_UID_POLICY);\n-        }\n-\n         out.endTag(null, TAG_POLICY_LIST);\n-\n-        // write all allowlists\n-        out.startTag(null, TAG_WHITELIST);\n-\n-        // revoked restrict background allowlist\n-        int size = mRestrictBackgroundAllowlistRevokedUids.size();\n-        for (int i = 0; i < size; i++) {\n-            final int uid = mRestrictBackgroundAllowlistRevokedUids.keyAt(i);\n-            out.startTag(null, TAG_REVOKED_RESTRICT_BACKGROUND);\n-            if (!forBackup) {\n-                writeIntAttribute(out, ATTR_UID, uid);\n-            } else {\n-                writeStringAttribute(out, ATTR_XML_UTILS_NAME, getPackageForUid(uid));\n-                writeIntAttribute(out, ATTR_USER_ID, UserHandle.getUserId(uid));\n-            }\n-            out.endTag(null, TAG_REVOKED_RESTRICT_BACKGROUND);\n-        }\n-\n-        out.endTag(null, TAG_WHITELIST);\n-\n-        out.endDocument();\n     }\n \n     @Override\n-    public byte[] getBackupPayload() {\n+    public byte[] getBackupPayload(int user) {\n         enforceSystemCaller();\n-        if (LOGD) Slog.d(TAG, \"getBackupPayload\");\n+        if (LOGD) Slog.d(TAG, \"getBackupPayload u= \" + user);\n         final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n         try {\n-            writePolicyXml(baos, true);\n+            writePolicyXml(baos, true, user);\n             return baos.toByteArray();\n         } catch (IOException e) {\n-            Slog.w(TAG, \"getBackupPayload: error writing payload\", e);\n+            Slog.w(TAG, \"getBackupPayload: error writing payload for user \" + user, e);\n         }\n         return null;\n     }\n \n     @Override\n-    public void applyRestore(byte[] payload) {\n+    public void applyRestore(byte[] payload, int user) {\n         enforceSystemCaller();\n-        if (LOGD) Slog.d(TAG, \"applyRestore payload=\"\n+        if (LOGD) Slog.d(TAG, \"applyRestore u=\" + user + \" payload=\"\n                 + (payload != null ? new String(payload, StandardCharsets.UTF_8) : null));\n         if (payload == null) {\n-            Slog.w(TAG, \"applyRestore: no payload to restore\");\n+            Slog.w(TAG, \"applyRestore: no payload to restore for user \" + user);\n             return;\n         }\n \n-        // clear any existing policy and read from disk\n-        mNetworkPolicy.clear();\n-        mSubscriptionPlans.clear();\n-        mSubscriptionPlansOwner.clear();\n-        mUidPolicy.clear();\n-\n         final ByteArrayInputStream bais = new ByteArrayInputStream(payload);\n         try {\n-            readPolicyXml(bais, true);\n+            readPolicyXml(bais, true, user);\n         } catch (IOException | XmlPullParserException e) {\n-            Slog.w(TAG, \"applyRestore: error reading payload\", e);\n+            Slog.w(TAG, \"applyRestore: error reading payload for user \" + user, e);\n         }\n \n         // Migrate from pre-12 network-isolation to restricted-networking-mode\n@@ -6096,17 +6103,21 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {\n         }\n     }\n \n-    private int readUidAttribute(TypedXmlPullParser in, boolean forRestore) throws IOException {\n+    private int readUidAttribute(TypedXmlPullParser in, boolean forRestore, int userId)\n+            throws IOException {\n         if (!forRestore) {\n             return readIntAttribute(in, ATTR_UID);\n         } else {\n-            return getUidForPackage(readStringAttribute(in, ATTR_XML_UTILS_NAME),\n-                    readIntAttribute(in, ATTR_USER_ID));\n+            return getUidForPackage(readStringAttribute(in, ATTR_XML_UTILS_NAME), userId);\n         }\n     }\n \n     private String getPackageForUid(int uid) {\n-        return mContext.getPackageManager().getPackagesForUid(uid)[0];\n+        try {\n+            return mContext.getPackageManager().getPackagesForUid(uid)[0];\n+        } catch (Exception e) {\n+            return null;\n+        }\n     }\n \n     private int getUidForPackage(String packageName, int userId) {\n",
    "added_lines": 81,
    "deleted_lines": 70,
    "changed_methods": "NetworkPolicyManagerService::readPolicyAL, NetworkPolicyManagerService::applyRestore, NetworkPolicyManagerService::readUidAttribute, NetworkPolicyManagerService::applyRestore, NetworkPolicyManagerService::getBackupPayload, NetworkPolicyManagerService::writePolicyXml, NetworkPolicyManagerService::writePolicyXml, NetworkPolicyManagerService::getBackupPayload, NetworkPolicyManagerService::readUidAttribute, NetworkPolicyManagerService::getPackageForUid, NetworkPolicyManagerService::readPolicyXml, NetworkPolicyManagerService::writePolicyAL, NetworkPolicyManagerService::readPolicyXml, NetworkPolicyManagerService::writeUidIndependentAttributes"
   }
  ]
 },
 {
  "hash": "f507e578bb9e8539493dce829307b28b865fdc2a",
  "commit": "fixup! Implement backup/restore for network policy\n\n* Add handling for secondary users\n\nChange-Id: I7d5806650f7f3a30638d9fac7848bd8d0bfda9a6",
  "files": [
   {
    "filename": "NetworkPolicyBackupHelper.java",
    "diff": "@@ -33,8 +33,11 @@ public class NetworkPolicyBackupHelper extends BlobBackupHelper {\n     // Key under which the payload blob is stored\n     static final String KEY_NETWORK_POLICY = \"network_policy\";\n \n-    public NetworkPolicyBackupHelper() {\n+    private final int mUserId;\n+\n+    public NetworkPolicyBackupHelper(int userId) {\n         super(BLOB_VERSION, KEY_NETWORK_POLICY);\n+        mUserId = userId;\n     }\n \n     @Override\n@@ -44,10 +47,10 @@ public class NetworkPolicyBackupHelper extends BlobBackupHelper {\n             try {\n                 INetworkPolicyManager npm = INetworkPolicyManager.Stub.asInterface(\n                         ServiceManager.getService(Context.NETWORK_POLICY_SERVICE));\n-                newPayload = npm.getBackupPayload();\n+                newPayload = npm.getBackupPayload(mUserId);\n             } catch (Exception e) {\n                 // Treat as no data\n-                Slog.e(TAG, \"Couldn't communicate with network policy manager\");\n+                Slog.e(TAG, \"Couldn't communicate with network policy manager\", e);\n                 newPayload = null;\n             }\n         }\n@@ -64,9 +67,9 @@ public class NetworkPolicyBackupHelper extends BlobBackupHelper {\n             try {\n                 INetworkPolicyManager.Stub.asInterface(\n                         ServiceManager.getService(Context.NETWORK_POLICY_SERVICE))\n-                        .applyRestore(payload);\n+                        .applyRestore(payload, mUserId);\n             } catch (Exception e) {\n-                Slog.e(TAG, \"Couldn't communicate with network policy manager\");\n+                Slog.e(TAG, \"Couldn't communicate with network policy manager\", e);\n             }\n         }\n     }\n",
    "added_lines": 8,
    "deleted_lines": 5,
    "changed_methods": "NetworkPolicyBackupHelper::applyRestoredPayload, NetworkPolicyBackupHelper::NetworkPolicyBackupHelper, NetworkPolicyBackupHelper::getBackupPayload, NetworkPolicyBackupHelper::NetworkPolicyBackupHelper"
   },
   {
    "filename": "SystemBackupAgent.java",
    "diff": "@@ -84,7 +84,7 @@ public class SystemBackupAgent extends BackupAgentHelper {\n     private static final String WALLPAPER_IMAGE_KEY = WallpaperBackupHelper.WALLPAPER_IMAGE_KEY;\n \n     private static final Set<String> sEligibleForMultiUser = Sets.newArraySet(\n-            PERMISSION_HELPER, NOTIFICATION_HELPER, SYNC_SETTINGS_HELPER);\n+            PERMISSION_HELPER, NOTIFICATION_HELPER, SYNC_SETTINGS_HELPER, NETWORK_POLICY_HELPER);\n \n     private int mUserId = UserHandle.USER_SYSTEM;\n \n@@ -103,7 +103,7 @@ public class SystemBackupAgent extends BackupAgentHelper {\n         addHelper(ACCOUNT_MANAGER_HELPER, new AccountManagerBackupHelper());\n         addHelper(SLICES_HELPER, new SliceBackupHelper(this));\n         addHelper(PEOPLE_HELPER, new PeopleBackupHelper(mUserId));\n-        addHelper(NETWORK_POLICY_HELPER, new NetworkPolicyBackupHelper());\n+        addHelper(NETWORK_POLICY_HELPER, new NetworkPolicyBackupHelper(mUserId));\n     }\n \n     @Override\n",
    "added_lines": 2,
    "deleted_lines": 2,
    "changed_methods": "SystemBackupAgent::onCreate"
   },
   {
    "filename": "NetworkPolicyManagerService.java",
    "diff": "@@ -426,7 +426,6 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {\n     private static final String ATTR_OWNER_PACKAGE = \"ownerPackage\";\n     private static final String ATTR_NETWORK_TYPES = \"networkTypes\";\n     private static final String ATTR_XML_UTILS_NAME = \"name\";\n-    private static final String ATTR_USER_ID = \"userId\";\n \n     private static final String ACTION_ALLOW_BACKGROUND =\n             \"com.android.server.net.action.ALLOW_BACKGROUND\";\n@@ -2496,7 +2495,7 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {\n         FileInputStream fis = null;\n         try {\n             fis = mPolicyFile.openRead();\n-            readPolicyXml(fis, false);\n+            readPolicyXml(fis, false, UserHandle.USER_ALL);\n         } catch (FileNotFoundException e) {\n             // missing policy is okay, probably first boot\n             upgradeDefaultBackgroundDataUL();\n@@ -2510,8 +2509,8 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {\n         migrateNetworkIsolation();\n     }\n \n-    private void readPolicyXml(InputStream inputStream, boolean forRestore) throws IOException,\n-            XmlPullParserException {\n+    private void readPolicyXml(InputStream inputStream, boolean forRestore, int userId)\n+            throws IOException, XmlPullParserException {\n         final TypedXmlPullParser in = Xml.resolvePullParser(inputStream);\n \n          // Must save the <restrict-background> tags and convert them to <uid-policy> later,\n@@ -2671,7 +2670,7 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {\n                             SubscriptionPlan.class, mSubscriptionPlans.get(subId), plan));\n                     mSubscriptionPlansOwner.put(subId, ownerPackage);\n                 } else if (TAG_UID_POLICY.equals(tag)) {\n-                    int uid = readUidAttribute(in, forRestore);\n+                    int uid = readUidAttribute(in, forRestore, userId);\n                     final int policy = readIntAttribute(in, ATTR_POLICY);\n \n                     if (UserHandle.isApp(uid)) {\n@@ -2694,10 +2693,10 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {\n                 } else if (TAG_WHITELIST.equals(tag)) {\n                     insideAllowlist = true;\n                 } else if (TAG_RESTRICT_BACKGROUND.equals(tag) && insideAllowlist) {\n-                    int uid = readUidAttribute(in, forRestore);\n+                    int uid = readUidAttribute(in, forRestore, userId);\n                     restrictBackgroundAllowedUids.append(uid, true);\n                 } else if (TAG_REVOKED_RESTRICT_BACKGROUND.equals(tag) && insideAllowlist) {\n-                    int uid = readUidAttribute(in, forRestore);\n+                    int uid = readUidAttribute(in, forRestore, userId);\n                     mRestrictBackgroundAllowlistRevokedUids.put(uid, true);\n                 }\n             } else if (type == END_TAG) {\n@@ -2801,7 +2800,7 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {\n         FileOutputStream fos = null;\n         try {\n             fos = mPolicyFile.startWrite();\n-            writePolicyXml(fos, false);\n+            writePolicyXml(fos, false, UserHandle.USER_ALL);\n             mPolicyFile.finishWrite(fos);\n         } catch (IOException e) {\n             if (fos != null) {\n@@ -2810,10 +2809,64 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {\n         }\n     }\n \n-    private void writePolicyXml(OutputStream outputStream, boolean forBackup) throws IOException {\n+    private void writePolicyXml(OutputStream outputStream, boolean forBackup, int userId)\n+            throws IOException {\n         TypedXmlSerializer out = Xml.resolveSerializer(outputStream);\n         out.startDocument(null, true);\n \n+        // only write UID-independent attributes during normal operation or system user backups\n+        if (!forBackup || userId == UserHandle.USER_SYSTEM) {\n+            writeUidIndependentAttributes(out);\n+        }\n+\n+        // write all known uid policies\n+        for (int i = 0; i < mUidPolicy.size(); i++) {\n+            final int uid = mUidPolicy.keyAt(i);\n+            final int policy = mUidPolicy.valueAt(i);\n+\n+            // skip writing policies belonging to other users\n+            if (forBackup && UserHandle.getUserId(uid) != userId) {\n+                continue;\n+            }\n+            // skip writing empty policies\n+            if (policy == POLICY_NONE) continue;\n+\n+            out.startTag(null, TAG_UID_POLICY);\n+            if (!forBackup) {\n+                writeIntAttribute(out, ATTR_UID, uid);\n+            } else {\n+                writeStringAttribute(out, ATTR_XML_UTILS_NAME, getPackageForUid(uid));\n+            }\n+            writeIntAttribute(out, ATTR_POLICY, policy);\n+            out.endTag(null, TAG_UID_POLICY);\n+        }\n+\n+        // write all allowlists\n+        out.startTag(null, TAG_WHITELIST);\n+\n+        // revoked restrict background allowlist\n+        int size = mRestrictBackgroundAllowlistRevokedUids.size();\n+        for (int i = 0; i < size; i++) {\n+            final int uid = mRestrictBackgroundAllowlistRevokedUids.keyAt(i);\n+            // skip writing policies belonging to other users\n+            if (forBackup && UserHandle.getUserId(uid) != userId) {\n+                continue;\n+            }\n+            out.startTag(null, TAG_REVOKED_RESTRICT_BACKGROUND);\n+            if (!forBackup) {\n+                writeIntAttribute(out, ATTR_UID, uid);\n+            } else {\n+                writeStringAttribute(out, ATTR_XML_UTILS_NAME, getPackageForUid(uid));\n+            }\n+            out.endTag(null, TAG_REVOKED_RESTRICT_BACKGROUND);\n+        }\n+\n+        out.endTag(null, TAG_WHITELIST);\n+\n+        out.endDocument();\n+    }\n+\n+    private void writeUidIndependentAttributes(TypedXmlSerializer out) throws IOException {\n         out.startTag(null, TAG_POLICY_LIST);\n         writeIntAttribute(out, ATTR_VERSION, VERSION_LATEST);\n         writeBooleanAttribute(out, ATTR_RESTRICT_BACKGROUND, mRestrictBackground);\n@@ -2880,89 +2933,43 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {\n                 writeLongAttribute(out, ATTR_USAGE_TIME, plan.getDataUsageTime());\n                 try {\n                     writeIntArrayXml(plan.getNetworkTypes(), ATTR_NETWORK_TYPES, out);\n-                } catch (XmlPullParserException ignored) { }\n+                } catch (XmlPullParserException ignored) {\n+                }\n                 out.endTag(null, TAG_SUBSCRIPTION_PLAN);\n             }\n         }\n-\n-        // write all known uid policies\n-        for (int i = 0; i < mUidPolicy.size(); i++) {\n-            final int uid = mUidPolicy.keyAt(i);\n-            final int policy = mUidPolicy.valueAt(i);\n-\n-            // skip writing empty policies\n-            if (policy == POLICY_NONE) continue;\n-\n-            out.startTag(null, TAG_UID_POLICY);\n-            if (!forBackup) {\n-                writeIntAttribute(out, ATTR_UID, uid);\n-            } else {\n-                writeStringAttribute(out, ATTR_XML_UTILS_NAME, getPackageForUid(uid));\n-                writeIntAttribute(out, ATTR_USER_ID, UserHandle.getUserId(uid));\n-            }\n-            writeIntAttribute(out, ATTR_POLICY, policy);\n-            out.endTag(null, TAG_UID_POLICY);\n-        }\n-\n         out.endTag(null, TAG_POLICY_LIST);\n-\n-        // write all allowlists\n-        out.startTag(null, TAG_WHITELIST);\n-\n-        // revoked restrict background allowlist\n-        int size = mRestrictBackgroundAllowlistRevokedUids.size();\n-        for (int i = 0; i < size; i++) {\n-            final int uid = mRestrictBackgroundAllowlistRevokedUids.keyAt(i);\n-            out.startTag(null, TAG_REVOKED_RESTRICT_BACKGROUND);\n-            if (!forBackup) {\n-                writeIntAttribute(out, ATTR_UID, uid);\n-            } else {\n-                writeStringAttribute(out, ATTR_XML_UTILS_NAME, getPackageForUid(uid));\n-                writeIntAttribute(out, ATTR_USER_ID, UserHandle.getUserId(uid));\n-            }\n-            out.endTag(null, TAG_REVOKED_RESTRICT_BACKGROUND);\n-        }\n-\n-        out.endTag(null, TAG_WHITELIST);\n-\n-        out.endDocument();\n     }\n \n     @Override\n-    public byte[] getBackupPayload() {\n+    public byte[] getBackupPayload(int user) {\n         enforceSystemCaller();\n-        if (LOGD) Slog.d(TAG, \"getBackupPayload\");\n+        if (LOGD) Slog.d(TAG, \"getBackupPayload u= \" + user);\n         final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n         try {\n-            writePolicyXml(baos, true);\n+            writePolicyXml(baos, true, user);\n             return baos.toByteArray();\n         } catch (IOException e) {\n-            Slog.w(TAG, \"getBackupPayload: error writing payload\", e);\n+            Slog.w(TAG, \"getBackupPayload: error writing payload for user \" + user, e);\n         }\n         return null;\n     }\n \n     @Override\n-    public void applyRestore(byte[] payload) {\n+    public void applyRestore(byte[] payload, int user) {\n         enforceSystemCaller();\n-        if (LOGD) Slog.d(TAG, \"applyRestore payload=\"\n+        if (LOGD) Slog.d(TAG, \"applyRestore u=\" + user + \" payload=\"\n                 + (payload != null ? new String(payload, StandardCharsets.UTF_8) : null));\n         if (payload == null) {\n-            Slog.w(TAG, \"applyRestore: no payload to restore\");\n+            Slog.w(TAG, \"applyRestore: no payload to restore for user \" + user);\n             return;\n         }\n \n-        // clear any existing policy and read from disk\n-        mNetworkPolicy.clear();\n-        mSubscriptionPlans.clear();\n-        mSubscriptionPlansOwner.clear();\n-        mUidPolicy.clear();\n-\n         final ByteArrayInputStream bais = new ByteArrayInputStream(payload);\n         try {\n-            readPolicyXml(bais, true);\n+            readPolicyXml(bais, true, user);\n         } catch (IOException | XmlPullParserException e) {\n-            Slog.w(TAG, \"applyRestore: error reading payload\", e);\n+            Slog.w(TAG, \"applyRestore: error reading payload for user \" + user, e);\n         }\n \n         // Migrate from pre-12 network-isolation to restricted-networking-mode\n@@ -6096,17 +6103,21 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {\n         }\n     }\n \n-    private int readUidAttribute(TypedXmlPullParser in, boolean forRestore) throws IOException {\n+    private int readUidAttribute(TypedXmlPullParser in, boolean forRestore, int userId)\n+            throws IOException {\n         if (!forRestore) {\n             return readIntAttribute(in, ATTR_UID);\n         } else {\n-            return getUidForPackage(readStringAttribute(in, ATTR_XML_UTILS_NAME),\n-                    readIntAttribute(in, ATTR_USER_ID));\n+            return getUidForPackage(readStringAttribute(in, ATTR_XML_UTILS_NAME), userId);\n         }\n     }\n \n     private String getPackageForUid(int uid) {\n-        return mContext.getPackageManager().getPackagesForUid(uid)[0];\n+        try {\n+            return mContext.getPackageManager().getPackagesForUid(uid)[0];\n+        } catch (Exception e) {\n+            return null;\n+        }\n     }\n \n     private int getUidForPackage(String packageName, int userId) {\n",
    "added_lines": 81,
    "deleted_lines": 70,
    "changed_methods": "NetworkPolicyManagerService::readPolicyAL, NetworkPolicyManagerService::applyRestore, NetworkPolicyManagerService::readUidAttribute, NetworkPolicyManagerService::applyRestore, NetworkPolicyManagerService::getBackupPayload, NetworkPolicyManagerService::writePolicyXml, NetworkPolicyManagerService::writePolicyXml, NetworkPolicyManagerService::getBackupPayload, NetworkPolicyManagerService::readUidAttribute, NetworkPolicyManagerService::getPackageForUid, NetworkPolicyManagerService::readPolicyXml, NetworkPolicyManagerService::writePolicyAL, NetworkPolicyManagerService::readPolicyXml, NetworkPolicyManagerService::writeUidIndependentAttributes"
   }
  ]
 },
 {
  "hash": "7d859aa90a381d80da2580e9b384c72c1e668859",
  "commit": "Add custom handling for backup/restore of UIDS_ALLOWED_ON_RESTRICTED_NETWORKS\n\nChange-Id: I8a4086692c385e9d6166a9bcb11d0a16c9fc7422",
  "files": [
   {
    "filename": "NetworkPolicyManagerService.java",
    "diff": "@@ -2841,6 +2841,26 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {\n             out.endTag(null, TAG_UID_POLICY);\n         }\n \n+        if (forBackup) {\n+            try {\n+                List<PackageInfo> packages = mIPm.getPackagesHoldingPermissions(\n+                        new String[]{android.Manifest.permission.INTERNET}, 0, userId\n+                ).getList();\n+                List<Integer> uids = packages.stream().map(packageInfo ->\n+                        packageInfo.applicationInfo.uid).collect(Collectors.toList());\n+                uids.removeAll(\n+                        ConnectivitySettingsManager.getUidsAllowedOnRestrictedNetworks(mContext));\n+                for (int uid : uids) {\n+                    out.startTag(null, TAG_UID_POLICY);\n+                    writeStringAttribute(out, ATTR_XML_UTILS_NAME, getPackageForUid(uid));\n+                    writeIntAttribute(out, ATTR_POLICY, POLICY_REJECT_ALL);\n+                    out.endTag(null, TAG_UID_POLICY);\n+                }\n+            } catch (RemoteException ignored) {\n+\n+            }\n+        }\n+\n         // write all allowlists\n         out.startTag(null, TAG_WHITELIST);\n \n",
    "added_lines": 20,
    "deleted_lines": 0,
    "changed_methods": "NetworkPolicyManagerService::writePolicyXml"
   }
  ]
 },
 {
  "hash": "e1f5dc7e844cf7171c89766800cce8e55462461e",
  "commit": "SystemUI: Fix QS header clock color\n\nNow that we're flipping QS colors by theme (dark/light), we can no longer\nrely on wallpaper colors for QS clock. Instead, we now can rely on clock color\nbeing updated correctly on QS re-inflation (via\nQuickStatusBarHeader.updateResources).\n\nChange-Id: Icdf2484793cb63b7c0ab6ab87e94185e6bdc9ca4",
  "files": [
   {
    "filename": "QuickStatusBarHeaderController.java",
    "diff": "@@ -18,10 +18,8 @@ package com.android.systemui.qs;\n \n import android.os.Bundle;\n \n-import com.android.internal.colorextraction.ColorExtractor;\n import com.android.systemui.R;\n import com.android.systemui.battery.BatteryMeterViewController;\n-import com.android.systemui.colorextraction.SysuiColorExtractor;\n import com.android.systemui.demomode.DemoMode;\n import com.android.systemui.demomode.DemoModeController;\n import com.android.systemui.flags.FeatureFlags;\n@@ -64,9 +62,6 @@ class QuickStatusBarHeaderController extends ViewController<QuickStatusBarHeader\n \n     private boolean mListening;\n \n-    private SysuiColorExtractor mColorExtractor;\n-    private ColorExtractor.OnColorsChangedListener mOnColorsChangedListener;\n-\n     @Inject\n     QuickStatusBarHeaderController(QuickStatusBarHeader view,\n             HeaderPrivacyIconsController headerPrivacyIconsController,\n@@ -74,7 +69,6 @@ class QuickStatusBarHeaderController extends ViewController<QuickStatusBarHeader\n             DemoModeController demoModeController,\n             QuickQSPanelController quickQSPanelController,\n             QSCarrierGroupController.Builder qsCarrierGroupControllerBuilder,\n-            SysuiColorExtractor colorExtractor,\n             QSExpansionPathInterpolator qsExpansionPathInterpolator,\n             BatteryMeterViewController batteryMeterViewController,\n             FeatureFlags featureFlags,\n@@ -104,12 +98,6 @@ class QuickStatusBarHeaderController extends ViewController<QuickStatusBarHeader\n \n         mIconManager = new StatusBarIconController.TintedIconManager(mIconContainer, featureFlags);\n         mDemoModeReceiver = new ClockDemoModeReceiver(mClockView);\n-        mColorExtractor = colorExtractor;\n-        mOnColorsChangedListener = (extractor, which) -> {\n-            final boolean lightTheme = mColorExtractor.getNeutralColors().supportsDarkText();\n-            mClockView.onColorsChanged(lightTheme);\n-        };\n-        mColorExtractor.addOnColorsChangedListener(mOnColorsChangedListener);\n \n         // Don't need to worry about tuner settings for this icon\n         mBatteryMeterViewController.ignoreTunerUpdates();\n@@ -157,7 +145,6 @@ class QuickStatusBarHeaderController extends ViewController<QuickStatusBarHeader\n \n     @Override\n     protected void onViewDetached() {\n-        mColorExtractor.removeOnColorsChangedListener(mOnColorsChangedListener);\n         mPrivacyIconsController.onParentInvisible();\n         mStatusBarIconController.removeIconGroup(mIconManager);\n         mQSCarrierGroupController.setOnSingleCarrierChangedListener(null);\n",
    "added_lines": 0,
    "deleted_lines": 13,
    "changed_methods": "QuickStatusBarHeaderController::QuickStatusBarHeaderController, QuickStatusBarHeaderController::onViewDetached"
   },
   {
    "filename": "Clock.java",
    "diff": "@@ -37,12 +37,10 @@ import android.text.format.DateFormat;\n import android.text.style.CharacterStyle;\n import android.text.style.RelativeSizeSpan;\n import android.util.AttributeSet;\n-import android.view.ContextThemeWrapper;\n import android.view.Display;\n import android.view.View;\n import android.widget.TextView;\n \n-import com.android.settingslib.Utils;\n import com.android.systemui.Dependency;\n import com.android.systemui.FontSizeUtils;\n import com.android.systemui.R;\n@@ -343,13 +341,6 @@ public class Clock extends TextView implements\n         setTextColor(mNonAdaptedColor);\n     }\n \n-    // Update text color based when shade scrim changes color.\n-    public void onColorsChanged(boolean lightTheme) {\n-        final Context context = new ContextThemeWrapper(mContext,\n-                lightTheme ? R.style.Theme_SystemUI_LightWallpaper : R.style.Theme_SystemUI);\n-        setTextColor(Utils.getColorAttrDefaultColor(context, R.attr.wallpaperTextColor));\n-    }\n-\n     @Override\n     public void onDensityOrFontScaleChanged() {\n         FontSizeUtils.updateFontSize(this, R.dimen.status_bar_clock_size);\n",
    "added_lines": 0,
    "deleted_lines": 9,
    "changed_methods": "Clock::onColorsChanged"
   }
  ]
 },
 {
  "hash": "e1f5dc7e844cf7171c89766800cce8e55462461e",
  "commit": "SystemUI: Fix QS header clock color\n\nNow that we're flipping QS colors by theme (dark/light), we can no longer\nrely on wallpaper colors for QS clock. Instead, we now can rely on clock color\nbeing updated correctly on QS re-inflation (via\nQuickStatusBarHeader.updateResources).\n\nChange-Id: Icdf2484793cb63b7c0ab6ab87e94185e6bdc9ca4",
  "files": [
   {
    "filename": "QuickStatusBarHeaderController.java",
    "diff": "@@ -18,10 +18,8 @@ package com.android.systemui.qs;\n \n import android.os.Bundle;\n \n-import com.android.internal.colorextraction.ColorExtractor;\n import com.android.systemui.R;\n import com.android.systemui.battery.BatteryMeterViewController;\n-import com.android.systemui.colorextraction.SysuiColorExtractor;\n import com.android.systemui.demomode.DemoMode;\n import com.android.systemui.demomode.DemoModeController;\n import com.android.systemui.flags.FeatureFlags;\n@@ -64,9 +62,6 @@ class QuickStatusBarHeaderController extends ViewController<QuickStatusBarHeader\n \n     private boolean mListening;\n \n-    private SysuiColorExtractor mColorExtractor;\n-    private ColorExtractor.OnColorsChangedListener mOnColorsChangedListener;\n-\n     @Inject\n     QuickStatusBarHeaderController(QuickStatusBarHeader view,\n             HeaderPrivacyIconsController headerPrivacyIconsController,\n@@ -74,7 +69,6 @@ class QuickStatusBarHeaderController extends ViewController<QuickStatusBarHeader\n             DemoModeController demoModeController,\n             QuickQSPanelController quickQSPanelController,\n             QSCarrierGroupController.Builder qsCarrierGroupControllerBuilder,\n-            SysuiColorExtractor colorExtractor,\n             QSExpansionPathInterpolator qsExpansionPathInterpolator,\n             BatteryMeterViewController batteryMeterViewController,\n             FeatureFlags featureFlags,\n@@ -104,12 +98,6 @@ class QuickStatusBarHeaderController extends ViewController<QuickStatusBarHeader\n \n         mIconManager = new StatusBarIconController.TintedIconManager(mIconContainer, featureFlags);\n         mDemoModeReceiver = new ClockDemoModeReceiver(mClockView);\n-        mColorExtractor = colorExtractor;\n-        mOnColorsChangedListener = (extractor, which) -> {\n-            final boolean lightTheme = mColorExtractor.getNeutralColors().supportsDarkText();\n-            mClockView.onColorsChanged(lightTheme);\n-        };\n-        mColorExtractor.addOnColorsChangedListener(mOnColorsChangedListener);\n \n         // Don't need to worry about tuner settings for this icon\n         mBatteryMeterViewController.ignoreTunerUpdates();\n@@ -157,7 +145,6 @@ class QuickStatusBarHeaderController extends ViewController<QuickStatusBarHeader\n \n     @Override\n     protected void onViewDetached() {\n-        mColorExtractor.removeOnColorsChangedListener(mOnColorsChangedListener);\n         mPrivacyIconsController.onParentInvisible();\n         mStatusBarIconController.removeIconGroup(mIconManager);\n         mQSCarrierGroupController.setOnSingleCarrierChangedListener(null);\n",
    "added_lines": 0,
    "deleted_lines": 13,
    "changed_methods": "QuickStatusBarHeaderController::QuickStatusBarHeaderController, QuickStatusBarHeaderController::onViewDetached"
   },
   {
    "filename": "Clock.java",
    "diff": "@@ -37,12 +37,10 @@ import android.text.format.DateFormat;\n import android.text.style.CharacterStyle;\n import android.text.style.RelativeSizeSpan;\n import android.util.AttributeSet;\n-import android.view.ContextThemeWrapper;\n import android.view.Display;\n import android.view.View;\n import android.widget.TextView;\n \n-import com.android.settingslib.Utils;\n import com.android.systemui.Dependency;\n import com.android.systemui.FontSizeUtils;\n import com.android.systemui.R;\n@@ -343,13 +341,6 @@ public class Clock extends TextView implements\n         setTextColor(mNonAdaptedColor);\n     }\n \n-    // Update text color based when shade scrim changes color.\n-    public void onColorsChanged(boolean lightTheme) {\n-        final Context context = new ContextThemeWrapper(mContext,\n-                lightTheme ? R.style.Theme_SystemUI_LightWallpaper : R.style.Theme_SystemUI);\n-        setTextColor(Utils.getColorAttrDefaultColor(context, R.attr.wallpaperTextColor));\n-    }\n-\n     @Override\n     public void onDensityOrFontScaleChanged() {\n         FontSizeUtils.updateFontSize(this, R.dimen.status_bar_clock_size);\n",
    "added_lines": 0,
    "deleted_lines": 9,
    "changed_methods": "Clock::onColorsChanged"
   }
  ]
 },
 {
  "hash": "a66abdde6d19431ac16ed009e492e2c7aa63a4fc",
  "commit": "SystemUI: QSCustomizer: Fix QS tile reset text color\n\n- Fixes https://gitlab.com/LineageOS/issues/android/-/issues/4873\n\nChange-Id: I49a599f10f68c0c576ec863b919936a3b171f2c6",
  "files": [
   {
    "filename": "QSCustomizer.java",
    "diff": "@@ -20,6 +20,9 @@ import android.animation.Animator.AnimatorListener;\n import android.animation.AnimatorListenerAdapter;\n import android.content.Context;\n import android.content.res.Configuration;\n+import android.graphics.Color;\n+import android.text.SpannableString;\n+import android.text.style.ForegroundColorSpan;\n import android.util.AttributeSet;\n import android.util.TypedValue;\n import android.view.LayoutInflater;\n@@ -73,8 +76,11 @@ public class QSCustomizer extends LinearLayout {\n         toolbar.setNavigationIcon(\n                 getResources().getDrawable(value.resourceId, mContext.getTheme()));\n \n-        toolbar.getMenu().add(Menu.NONE, MENU_RESET, 0,\n+        SpannableString resetText = new SpannableString(\n                 mContext.getString(com.android.internal.R.string.reset));\n+        resetText.setSpan(new ForegroundColorSpan(isNightMode() ?\n+                Color.WHITE : Color.BLACK), 0, resetText.length(), 0);\n+        toolbar.getMenu().add(Menu.NONE, MENU_RESET, 0, resetText);\n         toolbar.setTitle(R.string.qs_edit);\n         mRecyclerView = findViewById(android.R.id.list);\n         mTransparentView = findViewById(R.id.customizer_transparent_view);\n@@ -83,6 +89,11 @@ public class QSCustomizer extends LinearLayout {\n         mRecyclerView.setItemAnimator(animator);\n     }\n \n+    private boolean isNightMode() {\n+        return (mContext.getResources().getConfiguration().uiMode\n+                & Configuration.UI_MODE_NIGHT_MASK) == Configuration.UI_MODE_NIGHT_YES;\n+    }\n+\n     void updateResources() {\n         LayoutParams lp = (LayoutParams) mTransparentView.getLayoutParams();\n         lp.height = Utils.getQsHeaderSystemIconsAreaHeight(mContext);\n",
    "added_lines": 12,
    "deleted_lines": 1,
    "changed_methods": "QSCustomizer::QSCustomizer, QSCustomizer::isNightMode"
   }
  ]
 },
 {
  "hash": "c8c129afe16f5b4c9da9bf4c07a0bbeba4e4f697",
  "commit": "Restrict getInputMethodWindowVisibleHeight\n\nMake sure only the app currently interacting with the IME can\nquery this, and restrict the API to apps targeting SDKs before T\n\nFixes: 204906124\nTest: atest 'InputMethodManagerTest#getInputMethodWindowVisibleHeight_returnsZeroIfNotFocused'\nChange-Id: If1da19a3dd8c29542afc970b4b201d87547c27a9\nMerged-In: If1da19a3dd8c29542afc970b4b201d87547c27a9\n(cherry picked from commit 753331b390dc4d7cf895087223a8d72952af4de4)\nMerged-In: If1da19a3dd8c29542afc970b4b201d87547c27a9",
  "files": [
   {
    "filename": "InputMethodManager.java",
    "diff": "@@ -2958,7 +2958,7 @@ public final class InputMethodManager {\n     @UnsupportedAppUsage\n     public int getInputMethodWindowVisibleHeight() {\n         try {\n-            return mService.getInputMethodWindowVisibleHeight();\n+            return mService.getInputMethodWindowVisibleHeight(mClient);\n         } catch (RemoteException e) {\n             throw e.rethrowFromSystemServer();\n         }\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "InputMethodManager::getInputMethodWindowVisibleHeight"
   },
   {
    "filename": "InputMethodManagerService.java",
    "diff": "@@ -124,6 +124,7 @@ import android.util.Pair;\n import android.util.PrintWriterPrinter;\n import android.util.Printer;\n import android.util.Slog;\n+import android.util.SparseBooleanArray;\n import android.util.imetracing.ImeTracing;\n import android.util.proto.ProtoOutputStream;\n import android.view.IWindowManager;\n@@ -303,6 +304,8 @@ public class InputMethodManagerService extends IInputMethodManager.Stub\n     final InputMethodSettings mSettings;\n     final SettingsObserver mSettingsObserver;\n     final IWindowManager mIWindowManager;\n+    private final SparseBooleanArray mLoggedDeniedGetInputMethodWindowVisibleHeightForUid =\n+            new SparseBooleanArray(0);\n     final WindowManagerInternal mWindowManagerInternal;\n     final PackageManagerInternal mPackageManagerInternal;\n     final InputManagerInternal mInputManagerInternal;\n@@ -1364,6 +1367,13 @@ public class InputMethodManagerService extends IInputMethodManager.Stub\n             clearPackageChangeState();\n         }\n \n+        @Override\n+        public void onUidRemoved(int uid) {\n+            synchronized (mMethodMap) {\n+                mLoggedDeniedGetInputMethodWindowVisibleHeightForUid.delete(uid);\n+            }\n+        }\n+\n         private void clearPackageChangeState() {\n             // No need to lock them because we access these fields only on getRegisteredHandler().\n             mChangedPackages.clear();\n@@ -3127,21 +3137,8 @@ public class InputMethodManagerService extends IInputMethodManager.Stub\n             }\n             final long ident = Binder.clearCallingIdentity();\n             try {\n-                if (mCurClient == null || client == null\n-                        || mCurClient.client.asBinder() != client.asBinder()) {\n-                    // We need to check if this is the current client with\n-                    // focus in the window manager, to allow this call to\n-                    // be made before input is started in it.\n-                    final ClientState cs = mClients.get(client.asBinder());\n-                    if (cs == null) {\n-                        throw new IllegalArgumentException(\n-                                \"unknown client \" + client.asBinder());\n-                    }\n-                    if (!mWindowManagerInternal.isInputMethodClientFocus(cs.uid, cs.pid,\n-                            cs.selfReportedDisplayId)) {\n-                        Slog.w(TAG, \"Ignoring showSoftInput of uid \" + uid + \": \" + client);\n-                        return false;\n-                    }\n+                if (!canInteractWithImeLocked(uid, client, \"showSoftInput\")) {\n+                    return false;\n                 }\n                 if (DEBUG) Slog.v(TAG, \"Client requesting input be shown\");\n                 return showCurrentInputLocked(windowToken, flags, resultReceiver, reason);\n@@ -3966,9 +3963,46 @@ public class InputMethodManagerService extends IInputMethodManager.Stub\n      * @return {@link WindowManagerInternal#getInputMethodWindowVisibleHeight(int)}\n      */\n     @Override\n-    public int getInputMethodWindowVisibleHeight() {\n-        // TODO(yukawa): Should we verify the display ID?\n-        return mWindowManagerInternal.getInputMethodWindowVisibleHeight(mCurTokenDisplayId);\n+    @Deprecated\n+    public int getInputMethodWindowVisibleHeight(@NonNull IInputMethodClient client) {\n+        int callingUid = Binder.getCallingUid();\n+        return Binder.withCleanCallingIdentity(() -> {\n+            final int curTokenDisplayId;\n+            synchronized (mMethodMap) {\n+                if (!canInteractWithImeLocked(callingUid, client,\n+                        \"getInputMethodWindowVisibleHeight\")) {\n+                    if (!mLoggedDeniedGetInputMethodWindowVisibleHeightForUid.get(callingUid)) {\n+                        EventLog.writeEvent(0x534e4554, \"204906124\", callingUid, \"\");\n+                        mLoggedDeniedGetInputMethodWindowVisibleHeightForUid.put(callingUid, true);\n+                    }\n+                    return 0;\n+                }\n+                // This should probably use the caller's display id, but because this is unsupported\n+                // and maintained only for compatibility, there's no point in fixing it.\n+                curTokenDisplayId = mCurTokenDisplayId;\n+            }\n+            return mWindowManagerInternal.getInputMethodWindowVisibleHeight(curTokenDisplayId);\n+        });\n+    }\n+\n+    private boolean canInteractWithImeLocked(int callingUid, IInputMethodClient client,\n+            String method) {\n+        if (mCurClient == null || client == null\n+                || mCurClient.client.asBinder() != client.asBinder()) {\n+            // We need to check if this is the current client with\n+            // focus in the window manager, to allow this call to\n+            // be made before input is started in it.\n+            final ClientState cs = mClients.get(client.asBinder());\n+            if (cs == null) {\n+                throw new IllegalArgumentException(\"unknown client \" + client.asBinder());\n+            }\n+            if (!mWindowManagerInternal.isInputMethodClientFocus(cs.uid, cs.pid,\n+                    cs.selfReportedDisplayId)) {\n+                Slog.w(TAG, \"Ignoring \" + method + \" of uid \" + callingUid + \": \" + client);\n+                return false;\n+            }\n+        }\n+        return true;\n     }\n \n     @Override\n",
    "added_lines": 52,
    "deleted_lines": 18,
    "changed_methods": "InputMethodManagerService::MyPackageMonitor::onUidRemoved, InputMethodManagerService::showSoftInput, InputMethodManagerService::getInputMethodWindowVisibleHeight, InputMethodManagerService::canInteractWithImeLocked, InputMethodManagerService::getInputMethodWindowVisibleHeight"
   },
   {
    "filename": "MultiClientInputMethodManagerService.java",
    "diff": "@@ -1803,7 +1803,7 @@ public final class MultiClientInputMethodManagerService {\n \n         @BinderThread\n         @Override\n-        public int getInputMethodWindowVisibleHeight() {\n+        public int getInputMethodWindowVisibleHeight(IInputMethodClient client) {\n             reportNotSupported();\n             return 0;\n         }\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "MultiClientInputMethodManagerService::ApiCallbacks::getInputMethodWindowVisibleHeight, MultiClientInputMethodManagerService::ApiCallbacks::getInputMethodWindowVisibleHeight"
   }
  ]
 },
 {
  "hash": "c8c129afe16f5b4c9da9bf4c07a0bbeba4e4f697",
  "commit": "Restrict getInputMethodWindowVisibleHeight\n\nMake sure only the app currently interacting with the IME can\nquery this, and restrict the API to apps targeting SDKs before T\n\nFixes: 204906124\nTest: atest 'InputMethodManagerTest#getInputMethodWindowVisibleHeight_returnsZeroIfNotFocused'\nChange-Id: If1da19a3dd8c29542afc970b4b201d87547c27a9\nMerged-In: If1da19a3dd8c29542afc970b4b201d87547c27a9\n(cherry picked from commit 753331b390dc4d7cf895087223a8d72952af4de4)\nMerged-In: If1da19a3dd8c29542afc970b4b201d87547c27a9",
  "files": [
   {
    "filename": "InputMethodManager.java",
    "diff": "@@ -2958,7 +2958,7 @@ public final class InputMethodManager {\n     @UnsupportedAppUsage\n     public int getInputMethodWindowVisibleHeight() {\n         try {\n-            return mService.getInputMethodWindowVisibleHeight();\n+            return mService.getInputMethodWindowVisibleHeight(mClient);\n         } catch (RemoteException e) {\n             throw e.rethrowFromSystemServer();\n         }\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "InputMethodManager::getInputMethodWindowVisibleHeight"
   },
   {
    "filename": "InputMethodManagerService.java",
    "diff": "@@ -124,6 +124,7 @@ import android.util.Pair;\n import android.util.PrintWriterPrinter;\n import android.util.Printer;\n import android.util.Slog;\n+import android.util.SparseBooleanArray;\n import android.util.imetracing.ImeTracing;\n import android.util.proto.ProtoOutputStream;\n import android.view.IWindowManager;\n@@ -303,6 +304,8 @@ public class InputMethodManagerService extends IInputMethodManager.Stub\n     final InputMethodSettings mSettings;\n     final SettingsObserver mSettingsObserver;\n     final IWindowManager mIWindowManager;\n+    private final SparseBooleanArray mLoggedDeniedGetInputMethodWindowVisibleHeightForUid =\n+            new SparseBooleanArray(0);\n     final WindowManagerInternal mWindowManagerInternal;\n     final PackageManagerInternal mPackageManagerInternal;\n     final InputManagerInternal mInputManagerInternal;\n@@ -1364,6 +1367,13 @@ public class InputMethodManagerService extends IInputMethodManager.Stub\n             clearPackageChangeState();\n         }\n \n+        @Override\n+        public void onUidRemoved(int uid) {\n+            synchronized (mMethodMap) {\n+                mLoggedDeniedGetInputMethodWindowVisibleHeightForUid.delete(uid);\n+            }\n+        }\n+\n         private void clearPackageChangeState() {\n             // No need to lock them because we access these fields only on getRegisteredHandler().\n             mChangedPackages.clear();\n@@ -3127,21 +3137,8 @@ public class InputMethodManagerService extends IInputMethodManager.Stub\n             }\n             final long ident = Binder.clearCallingIdentity();\n             try {\n-                if (mCurClient == null || client == null\n-                        || mCurClient.client.asBinder() != client.asBinder()) {\n-                    // We need to check if this is the current client with\n-                    // focus in the window manager, to allow this call to\n-                    // be made before input is started in it.\n-                    final ClientState cs = mClients.get(client.asBinder());\n-                    if (cs == null) {\n-                        throw new IllegalArgumentException(\n-                                \"unknown client \" + client.asBinder());\n-                    }\n-                    if (!mWindowManagerInternal.isInputMethodClientFocus(cs.uid, cs.pid,\n-                            cs.selfReportedDisplayId)) {\n-                        Slog.w(TAG, \"Ignoring showSoftInput of uid \" + uid + \": \" + client);\n-                        return false;\n-                    }\n+                if (!canInteractWithImeLocked(uid, client, \"showSoftInput\")) {\n+                    return false;\n                 }\n                 if (DEBUG) Slog.v(TAG, \"Client requesting input be shown\");\n                 return showCurrentInputLocked(windowToken, flags, resultReceiver, reason);\n@@ -3966,9 +3963,46 @@ public class InputMethodManagerService extends IInputMethodManager.Stub\n      * @return {@link WindowManagerInternal#getInputMethodWindowVisibleHeight(int)}\n      */\n     @Override\n-    public int getInputMethodWindowVisibleHeight() {\n-        // TODO(yukawa): Should we verify the display ID?\n-        return mWindowManagerInternal.getInputMethodWindowVisibleHeight(mCurTokenDisplayId);\n+    @Deprecated\n+    public int getInputMethodWindowVisibleHeight(@NonNull IInputMethodClient client) {\n+        int callingUid = Binder.getCallingUid();\n+        return Binder.withCleanCallingIdentity(() -> {\n+            final int curTokenDisplayId;\n+            synchronized (mMethodMap) {\n+                if (!canInteractWithImeLocked(callingUid, client,\n+                        \"getInputMethodWindowVisibleHeight\")) {\n+                    if (!mLoggedDeniedGetInputMethodWindowVisibleHeightForUid.get(callingUid)) {\n+                        EventLog.writeEvent(0x534e4554, \"204906124\", callingUid, \"\");\n+                        mLoggedDeniedGetInputMethodWindowVisibleHeightForUid.put(callingUid, true);\n+                    }\n+                    return 0;\n+                }\n+                // This should probably use the caller's display id, but because this is unsupported\n+                // and maintained only for compatibility, there's no point in fixing it.\n+                curTokenDisplayId = mCurTokenDisplayId;\n+            }\n+            return mWindowManagerInternal.getInputMethodWindowVisibleHeight(curTokenDisplayId);\n+        });\n+    }\n+\n+    private boolean canInteractWithImeLocked(int callingUid, IInputMethodClient client,\n+            String method) {\n+        if (mCurClient == null || client == null\n+                || mCurClient.client.asBinder() != client.asBinder()) {\n+            // We need to check if this is the current client with\n+            // focus in the window manager, to allow this call to\n+            // be made before input is started in it.\n+            final ClientState cs = mClients.get(client.asBinder());\n+            if (cs == null) {\n+                throw new IllegalArgumentException(\"unknown client \" + client.asBinder());\n+            }\n+            if (!mWindowManagerInternal.isInputMethodClientFocus(cs.uid, cs.pid,\n+                    cs.selfReportedDisplayId)) {\n+                Slog.w(TAG, \"Ignoring \" + method + \" of uid \" + callingUid + \": \" + client);\n+                return false;\n+            }\n+        }\n+        return true;\n     }\n \n     @Override\n",
    "added_lines": 52,
    "deleted_lines": 18,
    "changed_methods": "InputMethodManagerService::MyPackageMonitor::onUidRemoved, InputMethodManagerService::showSoftInput, InputMethodManagerService::getInputMethodWindowVisibleHeight, InputMethodManagerService::canInteractWithImeLocked, InputMethodManagerService::getInputMethodWindowVisibleHeight"
   },
   {
    "filename": "MultiClientInputMethodManagerService.java",
    "diff": "@@ -1803,7 +1803,7 @@ public final class MultiClientInputMethodManagerService {\n \n         @BinderThread\n         @Override\n-        public int getInputMethodWindowVisibleHeight() {\n+        public int getInputMethodWindowVisibleHeight(IInputMethodClient client) {\n             reportNotSupported();\n             return 0;\n         }\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "MultiClientInputMethodManagerService::ApiCallbacks::getInputMethodWindowVisibleHeight, MultiClientInputMethodManagerService::ApiCallbacks::getInputMethodWindowVisibleHeight"
   }
  ]
 },
 {
  "hash": "c8c129afe16f5b4c9da9bf4c07a0bbeba4e4f697",
  "commit": "Restrict getInputMethodWindowVisibleHeight\n\nMake sure only the app currently interacting with the IME can\nquery this, and restrict the API to apps targeting SDKs before T\n\nFixes: 204906124\nTest: atest 'InputMethodManagerTest#getInputMethodWindowVisibleHeight_returnsZeroIfNotFocused'\nChange-Id: If1da19a3dd8c29542afc970b4b201d87547c27a9\nMerged-In: If1da19a3dd8c29542afc970b4b201d87547c27a9\n(cherry picked from commit 753331b390dc4d7cf895087223a8d72952af4de4)\nMerged-In: If1da19a3dd8c29542afc970b4b201d87547c27a9",
  "files": [
   {
    "filename": "InputMethodManager.java",
    "diff": "@@ -2958,7 +2958,7 @@ public final class InputMethodManager {\n     @UnsupportedAppUsage\n     public int getInputMethodWindowVisibleHeight() {\n         try {\n-            return mService.getInputMethodWindowVisibleHeight();\n+            return mService.getInputMethodWindowVisibleHeight(mClient);\n         } catch (RemoteException e) {\n             throw e.rethrowFromSystemServer();\n         }\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "InputMethodManager::getInputMethodWindowVisibleHeight"
   },
   {
    "filename": "InputMethodManagerService.java",
    "diff": "@@ -124,6 +124,7 @@ import android.util.Pair;\n import android.util.PrintWriterPrinter;\n import android.util.Printer;\n import android.util.Slog;\n+import android.util.SparseBooleanArray;\n import android.util.imetracing.ImeTracing;\n import android.util.proto.ProtoOutputStream;\n import android.view.IWindowManager;\n@@ -303,6 +304,8 @@ public class InputMethodManagerService extends IInputMethodManager.Stub\n     final InputMethodSettings mSettings;\n     final SettingsObserver mSettingsObserver;\n     final IWindowManager mIWindowManager;\n+    private final SparseBooleanArray mLoggedDeniedGetInputMethodWindowVisibleHeightForUid =\n+            new SparseBooleanArray(0);\n     final WindowManagerInternal mWindowManagerInternal;\n     final PackageManagerInternal mPackageManagerInternal;\n     final InputManagerInternal mInputManagerInternal;\n@@ -1364,6 +1367,13 @@ public class InputMethodManagerService extends IInputMethodManager.Stub\n             clearPackageChangeState();\n         }\n \n+        @Override\n+        public void onUidRemoved(int uid) {\n+            synchronized (mMethodMap) {\n+                mLoggedDeniedGetInputMethodWindowVisibleHeightForUid.delete(uid);\n+            }\n+        }\n+\n         private void clearPackageChangeState() {\n             // No need to lock them because we access these fields only on getRegisteredHandler().\n             mChangedPackages.clear();\n@@ -3127,21 +3137,8 @@ public class InputMethodManagerService extends IInputMethodManager.Stub\n             }\n             final long ident = Binder.clearCallingIdentity();\n             try {\n-                if (mCurClient == null || client == null\n-                        || mCurClient.client.asBinder() != client.asBinder()) {\n-                    // We need to check if this is the current client with\n-                    // focus in the window manager, to allow this call to\n-                    // be made before input is started in it.\n-                    final ClientState cs = mClients.get(client.asBinder());\n-                    if (cs == null) {\n-                        throw new IllegalArgumentException(\n-                                \"unknown client \" + client.asBinder());\n-                    }\n-                    if (!mWindowManagerInternal.isInputMethodClientFocus(cs.uid, cs.pid,\n-                            cs.selfReportedDisplayId)) {\n-                        Slog.w(TAG, \"Ignoring showSoftInput of uid \" + uid + \": \" + client);\n-                        return false;\n-                    }\n+                if (!canInteractWithImeLocked(uid, client, \"showSoftInput\")) {\n+                    return false;\n                 }\n                 if (DEBUG) Slog.v(TAG, \"Client requesting input be shown\");\n                 return showCurrentInputLocked(windowToken, flags, resultReceiver, reason);\n@@ -3966,9 +3963,46 @@ public class InputMethodManagerService extends IInputMethodManager.Stub\n      * @return {@link WindowManagerInternal#getInputMethodWindowVisibleHeight(int)}\n      */\n     @Override\n-    public int getInputMethodWindowVisibleHeight() {\n-        // TODO(yukawa): Should we verify the display ID?\n-        return mWindowManagerInternal.getInputMethodWindowVisibleHeight(mCurTokenDisplayId);\n+    @Deprecated\n+    public int getInputMethodWindowVisibleHeight(@NonNull IInputMethodClient client) {\n+        int callingUid = Binder.getCallingUid();\n+        return Binder.withCleanCallingIdentity(() -> {\n+            final int curTokenDisplayId;\n+            synchronized (mMethodMap) {\n+                if (!canInteractWithImeLocked(callingUid, client,\n+                        \"getInputMethodWindowVisibleHeight\")) {\n+                    if (!mLoggedDeniedGetInputMethodWindowVisibleHeightForUid.get(callingUid)) {\n+                        EventLog.writeEvent(0x534e4554, \"204906124\", callingUid, \"\");\n+                        mLoggedDeniedGetInputMethodWindowVisibleHeightForUid.put(callingUid, true);\n+                    }\n+                    return 0;\n+                }\n+                // This should probably use the caller's display id, but because this is unsupported\n+                // and maintained only for compatibility, there's no point in fixing it.\n+                curTokenDisplayId = mCurTokenDisplayId;\n+            }\n+            return mWindowManagerInternal.getInputMethodWindowVisibleHeight(curTokenDisplayId);\n+        });\n+    }\n+\n+    private boolean canInteractWithImeLocked(int callingUid, IInputMethodClient client,\n+            String method) {\n+        if (mCurClient == null || client == null\n+                || mCurClient.client.asBinder() != client.asBinder()) {\n+            // We need to check if this is the current client with\n+            // focus in the window manager, to allow this call to\n+            // be made before input is started in it.\n+            final ClientState cs = mClients.get(client.asBinder());\n+            if (cs == null) {\n+                throw new IllegalArgumentException(\"unknown client \" + client.asBinder());\n+            }\n+            if (!mWindowManagerInternal.isInputMethodClientFocus(cs.uid, cs.pid,\n+                    cs.selfReportedDisplayId)) {\n+                Slog.w(TAG, \"Ignoring \" + method + \" of uid \" + callingUid + \": \" + client);\n+                return false;\n+            }\n+        }\n+        return true;\n     }\n \n     @Override\n",
    "added_lines": 52,
    "deleted_lines": 18,
    "changed_methods": "InputMethodManagerService::MyPackageMonitor::onUidRemoved, InputMethodManagerService::showSoftInput, InputMethodManagerService::getInputMethodWindowVisibleHeight, InputMethodManagerService::canInteractWithImeLocked, InputMethodManagerService::getInputMethodWindowVisibleHeight"
   },
   {
    "filename": "MultiClientInputMethodManagerService.java",
    "diff": "@@ -1803,7 +1803,7 @@ public final class MultiClientInputMethodManagerService {\n \n         @BinderThread\n         @Override\n-        public int getInputMethodWindowVisibleHeight() {\n+        public int getInputMethodWindowVisibleHeight(IInputMethodClient client) {\n             reportNotSupported();\n             return 0;\n         }\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "MultiClientInputMethodManagerService::ApiCallbacks::getInputMethodWindowVisibleHeight, MultiClientInputMethodManagerService::ApiCallbacks::getInputMethodWindowVisibleHeight"
   }
  ]
 },
 {
  "hash": "7a455b258ba1b47318aa6c17b7ac20c6e7bb3453",
  "commit": "Stop crashing the system on hitting the alarm limit\n\nExempting the system as a runtime restart is not clearly\nbetter than extreme memory and computation pressure that can result from\nthe originating spam.\nCallers in the system should guard against any spammy requests that lead\nthem to create a lot of alarms.\n\nTest: Builds, boots and existing tests should pass.\n\natest CtsAlarmManagerTestCases:UidCapTests\natest FrameworksMockingServicesTests:AlarmManagerServiceTest\n\nBug: 234441463\nChange-Id: Id5e94d44ac9ab24870a8213ec7583da0f592a5ff\n(cherry picked from commit 3b9f3f4a0f5a661be65e287996cae8a4481a1453)\nMerged-In: Id5e94d44ac9ab24870a8213ec7583da0f592a5ff\n(cherry picked from commit 87fd506129631225581de641c4dd9956a15aa0ab)\nMerged-In: Id5e94d44ac9ab24870a8213ec7583da0f592a5ff",
  "files": [
   {
    "filename": "AlarmManagerService.java",
    "diff": "@@ -104,6 +104,7 @@ import android.text.TextUtils;\n import android.text.format.DateFormat;\n import android.util.ArrayMap;\n import android.util.ArraySet;\n+import android.util.EventLog;\n import android.util.IndentingPrintWriter;\n import android.util.Log;\n import android.util.LongArrayQueue;\n@@ -2031,7 +2032,11 @@ public class AlarmManagerService extends SystemService {\n                                 + \" reached for uid: \" + UserHandle.formatUid(callingUid)\n                                 + \", callingPackage: \" + callingPackage;\n                 Slog.w(TAG, errorMsg);\n-                throw new IllegalStateException(errorMsg);\n+                if (callingUid != Process.SYSTEM_UID) {\n+                    throw new IllegalStateException(errorMsg);\n+                } else {\n+                    EventLog.writeEvent(0x534e4554, \"234441463\", -1, errorMsg);\n+                }\n             }\n             setImplLocked(type, triggerAtTime, triggerElapsed, windowLength, interval, operation,\n                     directReceiver, listenerTag, flags, workSource, alarmClock, callingUid,\n",
    "added_lines": 6,
    "deleted_lines": 1,
    "changed_methods": "AlarmManagerService::setImpl"
   }
  ]
 },
 {
  "hash": "f35e379e1a6a8bfaff6e947d3bfbd0c095879af0",
  "commit": "Block FullScreenIntent while device is in use if notification has a silencing GroupAlertBehavior.\n\nBug: 231322873\nTest: atest NotificationInterruptStateProviderImplTest\nMerged-In: Id82d20c9f1f2001400871b5381f52b40fbdf81c5\nChange-Id: Id82d20c9f1f2001400871b5381f52b40fbdf81c5\n(cherry picked from commit 09761a98b5bbbefa331c49a96b50b4e08dc3f8df)\nMerged-In: Id82d20c9f1f2001400871b5381f52b40fbdf81c5",
  "files": [
   {
    "filename": "NotificationInterruptStateProviderImpl.java",
    "diff": "@@ -176,9 +176,86 @@ public class NotificationInterruptStateProviderImpl implements NotificationInter\n      */\n     @Override\n     public boolean shouldLaunchFullScreenIntentWhenAdded(NotificationEntry entry) {\n-        return entry.getSbn().getNotification().fullScreenIntent != null\n-                && (!shouldHeadsUp(entry)\n-                || mStatusBarStateController.getState() == StatusBarState.KEYGUARD);\n+        if (entry.getSbn().getNotification().fullScreenIntent == null) {\n+            return false;\n+        }\n+\n+        // Never show FSI when suppressed by DND\n+        if (entry.shouldSuppressFullScreenIntent()) {\n+            if (DEBUG) {\n+                Log.d(TAG, \"No FullScreenIntent: Suppressed by DND: \" + entry.getKey());\n+            }\n+            return false;\n+        }\n+\n+        // Never show FSI if importance is not HIGH\n+        if (entry.getImportance() < NotificationManager.IMPORTANCE_HIGH) {\n+            if (DEBUG) {\n+                Log.d(TAG, \"No FullScreenIntent: Not important enough: \" + entry.getKey());\n+            }\n+            return false;\n+        }\n+\n+        // If the notification has suppressive GroupAlertBehavior, block FSI and warn.\n+        StatusBarNotification sbn = entry.getSbn();\n+        if (sbn.isGroup() && sbn.getNotification().suppressAlertingDueToGrouping()) {\n+            // b/231322873: Detect and report an event when a notification has both an FSI and a\n+            // suppressive groupAlertBehavior, and now correctly block the FSI from firing.\n+            final int uid = entry.getSbn().getUid();\n+            android.util.EventLog.writeEvent(0x534e4554, \"231322873\", uid, \"groupAlertBehavior\");\n+            if (DEBUG) {\n+                Log.w(TAG, \"No FullScreenIntent: WARNING: GroupAlertBehavior will prevent HUN: \"\n+                        + entry.getKey());\n+            }\n+            return false;\n+        }\n+\n+        // If the screen is off, then launch the FullScreenIntent\n+        if (!mPowerManager.isInteractive()) {\n+            if (DEBUG) {\n+                Log.d(TAG, \"FullScreenIntent: Device is not interactive: \" + entry.getKey());\n+            }\n+            return true;\n+        }\n+\n+        // If the device is currently dreaming, then launch the FullScreenIntent\n+        if (isDreaming()) {\n+            if (DEBUG) {\n+                Log.d(TAG, \"FullScreenIntent: Device is dreaming: \" + entry.getKey());\n+            }\n+            return true;\n+        }\n+\n+        // If the keyguard is showing, then launch the FullScreenIntent\n+        if (mStatusBarStateController.getState() == StatusBarState.KEYGUARD) {\n+            if (DEBUG) {\n+                Log.d(TAG, \"FullScreenIntent: Keyguard is showing: \" + entry.getKey());\n+            }\n+            return true;\n+        }\n+\n+        // If the notification should HUN, then we don't need FSI\n+        if (shouldHeadsUp(entry)) {\n+            if (DEBUG) {\n+                Log.d(TAG, \"No FullScreenIntent: Expected to HUN: \" + entry.getKey());\n+            }\n+            return false;\n+        }\n+\n+        // If the notification won't HUN for some other reason (DND/snooze/etc), launch FSI.\n+        if (DEBUG) {\n+            Log.d(TAG, \"FullScreenIntent: Expected not to HUN: \" + entry.getKey());\n+        }\n+        return true;\n+    }\n+\n+    private boolean isDreaming() {\n+        try {\n+            return mDreamManager.isDreaming();\n+        } catch (RemoteException e) {\n+            Log.e(TAG, \"Failed to query dream manager.\", e);\n+            return false;\n+        }\n     }\n \n     private boolean shouldHeadsUpWhenAwake(NotificationEntry entry) {\n@@ -229,13 +306,7 @@ public class NotificationInterruptStateProviderImpl implements NotificationInter\n             return false;\n         }\n \n-        boolean isDreaming = false;\n-        try {\n-            isDreaming = mDreamManager.isDreaming();\n-        } catch (RemoteException e) {\n-            Log.e(TAG, \"Failed to query dream manager.\", e);\n-        }\n-        boolean inUse = mPowerManager.isScreenOn() && !isDreaming;\n+        boolean inUse = mPowerManager.isScreenOn() && !isDreaming();\n \n         if (!inUse) {\n             if (DEBUG_HEADS_UP) {\n",
    "added_lines": 81,
    "deleted_lines": 10,
    "changed_methods": "NotificationInterruptStateProviderImpl::shouldHeadsUpWhenAwake, NotificationInterruptStateProviderImpl::isDreaming, NotificationInterruptStateProviderImpl::shouldLaunchFullScreenIntentWhenAdded"
   },
   {
    "filename": "NotificationInterruptStateProviderImplTest.java",
    "diff": "@@ -24,6 +24,7 @@ import static android.app.NotificationManager.Policy.SUPPRESSED_EFFECT_AMBIENT;\n import static android.app.NotificationManager.Policy.SUPPRESSED_EFFECT_PEEK;\n \n import static com.android.systemui.statusbar.NotificationEntryHelper.modifyRanking;\n+import static com.android.systemui.statusbar.StatusBarState.KEYGUARD;\n import static com.android.systemui.statusbar.StatusBarState.SHADE;\n \n import static com.google.common.truth.Truth.assertThat;\n@@ -84,6 +85,8 @@ public class NotificationInterruptStateProviderImplTest extends SysuiTestCase {\n     BatteryController mBatteryController;\n     @Mock\n     Handler mMockHandler;\n+    @Mock\n+    PendingIntent mPendingIntent;\n \n     private NotificationInterruptStateProviderImpl mNotifInterruptionStateProvider;\n \n@@ -399,6 +402,97 @@ public class NotificationInterruptStateProviderImplTest extends SysuiTestCase {\n         assertThat(mNotifInterruptionStateProvider.shouldHeadsUp(entry)).isFalse();\n     }\n \n+    @Test\n+    public void testShouldNotFullScreen_notPendingIntent() throws RemoteException {\n+        NotificationEntry entry = createNotification(IMPORTANCE_HIGH);\n+        when(mPowerManager.isInteractive()).thenReturn(true);\n+        when(mDreamManager.isDreaming()).thenReturn(false);\n+        when(mStatusBarStateController.getState()).thenReturn(SHADE);\n+\n+        assertThat(mNotifInterruptionStateProvider.shouldLaunchFullScreenIntentWhenAdded(entry))\n+                .isFalse();\n+    }\n+\n+    @Test\n+    public void testShouldNotFullScreen_notHighImportance() throws RemoteException {\n+        NotificationEntry entry = createFsiNotification(IMPORTANCE_DEFAULT, /* silenced */ false);\n+        when(mPowerManager.isInteractive()).thenReturn(true);\n+        when(mDreamManager.isDreaming()).thenReturn(false);\n+        when(mStatusBarStateController.getState()).thenReturn(SHADE);\n+\n+        assertThat(mNotifInterruptionStateProvider.shouldLaunchFullScreenIntentWhenAdded(entry))\n+                .isFalse();\n+    }\n+\n+    @Test\n+    public void testShouldNotFullScreen_isGroupAlertSilenced() throws RemoteException {\n+        NotificationEntry entry = createFsiNotification(IMPORTANCE_HIGH, /* silenced */ true);\n+        when(mPowerManager.isInteractive()).thenReturn(false);\n+        when(mDreamManager.isDreaming()).thenReturn(true);\n+        when(mStatusBarStateController.getState()).thenReturn(KEYGUARD);\n+\n+        assertThat(mNotifInterruptionStateProvider.shouldLaunchFullScreenIntentWhenAdded(entry))\n+                .isFalse();\n+    }\n+\n+    @Test\n+    public void testShouldFullScreen_notInteractive() throws RemoteException {\n+        NotificationEntry entry = createFsiNotification(IMPORTANCE_HIGH, /* silenced */ false);\n+        when(mPowerManager.isInteractive()).thenReturn(false);\n+        when(mDreamManager.isDreaming()).thenReturn(false);\n+        when(mStatusBarStateController.getState()).thenReturn(SHADE);\n+\n+        assertThat(mNotifInterruptionStateProvider.shouldLaunchFullScreenIntentWhenAdded(entry))\n+                .isTrue();\n+    }\n+\n+    @Test\n+    public void testShouldFullScreen_isDreaming() throws RemoteException {\n+        NotificationEntry entry = createFsiNotification(IMPORTANCE_HIGH, /* silenced */ false);\n+        when(mPowerManager.isInteractive()).thenReturn(true);\n+        when(mDreamManager.isDreaming()).thenReturn(true);\n+        when(mStatusBarStateController.getState()).thenReturn(SHADE);\n+\n+        assertThat(mNotifInterruptionStateProvider.shouldLaunchFullScreenIntentWhenAdded(entry))\n+                .isTrue();\n+    }\n+\n+    @Test\n+    public void testShouldFullScreen_onKeyguard() throws RemoteException {\n+        NotificationEntry entry = createFsiNotification(IMPORTANCE_HIGH, /* silenced */ false);\n+        when(mPowerManager.isInteractive()).thenReturn(true);\n+        when(mDreamManager.isDreaming()).thenReturn(false);\n+        when(mStatusBarStateController.getState()).thenReturn(KEYGUARD);\n+\n+        assertThat(mNotifInterruptionStateProvider.shouldLaunchFullScreenIntentWhenAdded(entry))\n+                .isTrue();\n+    }\n+\n+    @Test\n+    public void testShouldNotFullScreen_willHun() throws RemoteException {\n+        NotificationEntry entry = createFsiNotification(IMPORTANCE_HIGH, /* silenced */ false);\n+        when(mPowerManager.isInteractive()).thenReturn(true);\n+        when(mPowerManager.isScreenOn()).thenReturn(true);\n+        when(mDreamManager.isDreaming()).thenReturn(false);\n+        when(mStatusBarStateController.getState()).thenReturn(SHADE);\n+\n+        assertThat(mNotifInterruptionStateProvider.shouldLaunchFullScreenIntentWhenAdded(entry))\n+                .isFalse();\n+    }\n+\n+    @Test\n+    public void testShouldFullScreen_packageSnoozed() throws RemoteException {\n+        NotificationEntry entry = createFsiNotification(IMPORTANCE_HIGH, /* silenced */ false);\n+        when(mPowerManager.isInteractive()).thenReturn(true);\n+        when(mPowerManager.isScreenOn()).thenReturn(true);\n+        when(mDreamManager.isDreaming()).thenReturn(false);\n+        when(mStatusBarStateController.getState()).thenReturn(SHADE);\n+        when(mHeadsUpManager.isSnoozed(\"a\")).thenReturn(true);\n+\n+        assertThat(mNotifInterruptionStateProvider.shouldLaunchFullScreenIntentWhenAdded(entry))\n+                .isTrue();\n+    }\n+\n     /**\n      * Bubbles can happen.\n      */\n@@ -503,6 +597,10 @@ public class NotificationInterruptStateProviderImplTest extends SysuiTestCase {\n                 .setContentText(\"content text\")\n                 .build();\n \n+        return createNotification(importance, n);\n+    }\n+\n+    private NotificationEntry createNotification(int importance, Notification n) {\n         return new NotificationEntryBuilder()\n                 .setPkg(\"a\")\n                 .setOpPkg(\"a\")\n@@ -512,6 +610,20 @@ public class NotificationInterruptStateProviderImplTest extends SysuiTestCase {\n                 .build();\n     }\n \n+    private NotificationEntry createFsiNotification(int importance, boolean silent) {\n+        Notification n = new Notification.Builder(getContext(), \"a\")\n+                .setContentTitle(\"title\")\n+                .setContentText(\"content text\")\n+                .setFullScreenIntent(mPendingIntent, true)\n+                .setGroup(\"fsi\")\n+                .setGroupAlertBehavior(silent\n+                        ? Notification.GROUP_ALERT_SUMMARY\n+                        : Notification.GROUP_ALERT_ALL)\n+                .build();\n+\n+        return createNotification(importance, n);\n+    }\n+\n     private final NotificationInterruptSuppressor\n             mSuppressAwakeHeadsUp =\n             new NotificationInterruptSuppressor() {\n",
    "added_lines": 112,
    "deleted_lines": 0,
    "changed_methods": "NotificationInterruptStateProviderImplTest::createNotification, NotificationInterruptStateProviderImplTest::createFsiNotification, NotificationInterruptStateProviderImplTest::testShouldNotFullScreen_notPendingIntent, NotificationInterruptStateProviderImplTest::testShouldFullScreen_notInteractive, NotificationInterruptStateProviderImplTest::testShouldFullScreen_onKeyguard, NotificationInterruptStateProviderImplTest::testShouldNotFullScreen_willHun, NotificationInterruptStateProviderImplTest::testShouldFullScreen_isDreaming, NotificationInterruptStateProviderImplTest::testShouldNotFullScreen_isGroupAlertSilenced, NotificationInterruptStateProviderImplTest::testShouldFullScreen_packageSnoozed, NotificationInterruptStateProviderImplTest::createNotification, NotificationInterruptStateProviderImplTest::testShouldNotFullScreen_notHighImportance"
   }
  ]
 },
 {
  "hash": "f35e379e1a6a8bfaff6e947d3bfbd0c095879af0",
  "commit": "Block FullScreenIntent while device is in use if notification has a silencing GroupAlertBehavior.\n\nBug: 231322873\nTest: atest NotificationInterruptStateProviderImplTest\nMerged-In: Id82d20c9f1f2001400871b5381f52b40fbdf81c5\nChange-Id: Id82d20c9f1f2001400871b5381f52b40fbdf81c5\n(cherry picked from commit 09761a98b5bbbefa331c49a96b50b4e08dc3f8df)\nMerged-In: Id82d20c9f1f2001400871b5381f52b40fbdf81c5",
  "files": [
   {
    "filename": "NotificationInterruptStateProviderImpl.java",
    "diff": "@@ -176,9 +176,86 @@ public class NotificationInterruptStateProviderImpl implements NotificationInter\n      */\n     @Override\n     public boolean shouldLaunchFullScreenIntentWhenAdded(NotificationEntry entry) {\n-        return entry.getSbn().getNotification().fullScreenIntent != null\n-                && (!shouldHeadsUp(entry)\n-                || mStatusBarStateController.getState() == StatusBarState.KEYGUARD);\n+        if (entry.getSbn().getNotification().fullScreenIntent == null) {\n+            return false;\n+        }\n+\n+        // Never show FSI when suppressed by DND\n+        if (entry.shouldSuppressFullScreenIntent()) {\n+            if (DEBUG) {\n+                Log.d(TAG, \"No FullScreenIntent: Suppressed by DND: \" + entry.getKey());\n+            }\n+            return false;\n+        }\n+\n+        // Never show FSI if importance is not HIGH\n+        if (entry.getImportance() < NotificationManager.IMPORTANCE_HIGH) {\n+            if (DEBUG) {\n+                Log.d(TAG, \"No FullScreenIntent: Not important enough: \" + entry.getKey());\n+            }\n+            return false;\n+        }\n+\n+        // If the notification has suppressive GroupAlertBehavior, block FSI and warn.\n+        StatusBarNotification sbn = entry.getSbn();\n+        if (sbn.isGroup() && sbn.getNotification().suppressAlertingDueToGrouping()) {\n+            // b/231322873: Detect and report an event when a notification has both an FSI and a\n+            // suppressive groupAlertBehavior, and now correctly block the FSI from firing.\n+            final int uid = entry.getSbn().getUid();\n+            android.util.EventLog.writeEvent(0x534e4554, \"231322873\", uid, \"groupAlertBehavior\");\n+            if (DEBUG) {\n+                Log.w(TAG, \"No FullScreenIntent: WARNING: GroupAlertBehavior will prevent HUN: \"\n+                        + entry.getKey());\n+            }\n+            return false;\n+        }\n+\n+        // If the screen is off, then launch the FullScreenIntent\n+        if (!mPowerManager.isInteractive()) {\n+            if (DEBUG) {\n+                Log.d(TAG, \"FullScreenIntent: Device is not interactive: \" + entry.getKey());\n+            }\n+            return true;\n+        }\n+\n+        // If the device is currently dreaming, then launch the FullScreenIntent\n+        if (isDreaming()) {\n+            if (DEBUG) {\n+                Log.d(TAG, \"FullScreenIntent: Device is dreaming: \" + entry.getKey());\n+            }\n+            return true;\n+        }\n+\n+        // If the keyguard is showing, then launch the FullScreenIntent\n+        if (mStatusBarStateController.getState() == StatusBarState.KEYGUARD) {\n+            if (DEBUG) {\n+                Log.d(TAG, \"FullScreenIntent: Keyguard is showing: \" + entry.getKey());\n+            }\n+            return true;\n+        }\n+\n+        // If the notification should HUN, then we don't need FSI\n+        if (shouldHeadsUp(entry)) {\n+            if (DEBUG) {\n+                Log.d(TAG, \"No FullScreenIntent: Expected to HUN: \" + entry.getKey());\n+            }\n+            return false;\n+        }\n+\n+        // If the notification won't HUN for some other reason (DND/snooze/etc), launch FSI.\n+        if (DEBUG) {\n+            Log.d(TAG, \"FullScreenIntent: Expected not to HUN: \" + entry.getKey());\n+        }\n+        return true;\n+    }\n+\n+    private boolean isDreaming() {\n+        try {\n+            return mDreamManager.isDreaming();\n+        } catch (RemoteException e) {\n+            Log.e(TAG, \"Failed to query dream manager.\", e);\n+            return false;\n+        }\n     }\n \n     private boolean shouldHeadsUpWhenAwake(NotificationEntry entry) {\n@@ -229,13 +306,7 @@ public class NotificationInterruptStateProviderImpl implements NotificationInter\n             return false;\n         }\n \n-        boolean isDreaming = false;\n-        try {\n-            isDreaming = mDreamManager.isDreaming();\n-        } catch (RemoteException e) {\n-            Log.e(TAG, \"Failed to query dream manager.\", e);\n-        }\n-        boolean inUse = mPowerManager.isScreenOn() && !isDreaming;\n+        boolean inUse = mPowerManager.isScreenOn() && !isDreaming();\n \n         if (!inUse) {\n             if (DEBUG_HEADS_UP) {\n",
    "added_lines": 81,
    "deleted_lines": 10,
    "changed_methods": "NotificationInterruptStateProviderImpl::shouldHeadsUpWhenAwake, NotificationInterruptStateProviderImpl::isDreaming, NotificationInterruptStateProviderImpl::shouldLaunchFullScreenIntentWhenAdded"
   },
   {
    "filename": "NotificationInterruptStateProviderImplTest.java",
    "diff": "@@ -24,6 +24,7 @@ import static android.app.NotificationManager.Policy.SUPPRESSED_EFFECT_AMBIENT;\n import static android.app.NotificationManager.Policy.SUPPRESSED_EFFECT_PEEK;\n \n import static com.android.systemui.statusbar.NotificationEntryHelper.modifyRanking;\n+import static com.android.systemui.statusbar.StatusBarState.KEYGUARD;\n import static com.android.systemui.statusbar.StatusBarState.SHADE;\n \n import static com.google.common.truth.Truth.assertThat;\n@@ -84,6 +85,8 @@ public class NotificationInterruptStateProviderImplTest extends SysuiTestCase {\n     BatteryController mBatteryController;\n     @Mock\n     Handler mMockHandler;\n+    @Mock\n+    PendingIntent mPendingIntent;\n \n     private NotificationInterruptStateProviderImpl mNotifInterruptionStateProvider;\n \n@@ -399,6 +402,97 @@ public class NotificationInterruptStateProviderImplTest extends SysuiTestCase {\n         assertThat(mNotifInterruptionStateProvider.shouldHeadsUp(entry)).isFalse();\n     }\n \n+    @Test\n+    public void testShouldNotFullScreen_notPendingIntent() throws RemoteException {\n+        NotificationEntry entry = createNotification(IMPORTANCE_HIGH);\n+        when(mPowerManager.isInteractive()).thenReturn(true);\n+        when(mDreamManager.isDreaming()).thenReturn(false);\n+        when(mStatusBarStateController.getState()).thenReturn(SHADE);\n+\n+        assertThat(mNotifInterruptionStateProvider.shouldLaunchFullScreenIntentWhenAdded(entry))\n+                .isFalse();\n+    }\n+\n+    @Test\n+    public void testShouldNotFullScreen_notHighImportance() throws RemoteException {\n+        NotificationEntry entry = createFsiNotification(IMPORTANCE_DEFAULT, /* silenced */ false);\n+        when(mPowerManager.isInteractive()).thenReturn(true);\n+        when(mDreamManager.isDreaming()).thenReturn(false);\n+        when(mStatusBarStateController.getState()).thenReturn(SHADE);\n+\n+        assertThat(mNotifInterruptionStateProvider.shouldLaunchFullScreenIntentWhenAdded(entry))\n+                .isFalse();\n+    }\n+\n+    @Test\n+    public void testShouldNotFullScreen_isGroupAlertSilenced() throws RemoteException {\n+        NotificationEntry entry = createFsiNotification(IMPORTANCE_HIGH, /* silenced */ true);\n+        when(mPowerManager.isInteractive()).thenReturn(false);\n+        when(mDreamManager.isDreaming()).thenReturn(true);\n+        when(mStatusBarStateController.getState()).thenReturn(KEYGUARD);\n+\n+        assertThat(mNotifInterruptionStateProvider.shouldLaunchFullScreenIntentWhenAdded(entry))\n+                .isFalse();\n+    }\n+\n+    @Test\n+    public void testShouldFullScreen_notInteractive() throws RemoteException {\n+        NotificationEntry entry = createFsiNotification(IMPORTANCE_HIGH, /* silenced */ false);\n+        when(mPowerManager.isInteractive()).thenReturn(false);\n+        when(mDreamManager.isDreaming()).thenReturn(false);\n+        when(mStatusBarStateController.getState()).thenReturn(SHADE);\n+\n+        assertThat(mNotifInterruptionStateProvider.shouldLaunchFullScreenIntentWhenAdded(entry))\n+                .isTrue();\n+    }\n+\n+    @Test\n+    public void testShouldFullScreen_isDreaming() throws RemoteException {\n+        NotificationEntry entry = createFsiNotification(IMPORTANCE_HIGH, /* silenced */ false);\n+        when(mPowerManager.isInteractive()).thenReturn(true);\n+        when(mDreamManager.isDreaming()).thenReturn(true);\n+        when(mStatusBarStateController.getState()).thenReturn(SHADE);\n+\n+        assertThat(mNotifInterruptionStateProvider.shouldLaunchFullScreenIntentWhenAdded(entry))\n+                .isTrue();\n+    }\n+\n+    @Test\n+    public void testShouldFullScreen_onKeyguard() throws RemoteException {\n+        NotificationEntry entry = createFsiNotification(IMPORTANCE_HIGH, /* silenced */ false);\n+        when(mPowerManager.isInteractive()).thenReturn(true);\n+        when(mDreamManager.isDreaming()).thenReturn(false);\n+        when(mStatusBarStateController.getState()).thenReturn(KEYGUARD);\n+\n+        assertThat(mNotifInterruptionStateProvider.shouldLaunchFullScreenIntentWhenAdded(entry))\n+                .isTrue();\n+    }\n+\n+    @Test\n+    public void testShouldNotFullScreen_willHun() throws RemoteException {\n+        NotificationEntry entry = createFsiNotification(IMPORTANCE_HIGH, /* silenced */ false);\n+        when(mPowerManager.isInteractive()).thenReturn(true);\n+        when(mPowerManager.isScreenOn()).thenReturn(true);\n+        when(mDreamManager.isDreaming()).thenReturn(false);\n+        when(mStatusBarStateController.getState()).thenReturn(SHADE);\n+\n+        assertThat(mNotifInterruptionStateProvider.shouldLaunchFullScreenIntentWhenAdded(entry))\n+                .isFalse();\n+    }\n+\n+    @Test\n+    public void testShouldFullScreen_packageSnoozed() throws RemoteException {\n+        NotificationEntry entry = createFsiNotification(IMPORTANCE_HIGH, /* silenced */ false);\n+        when(mPowerManager.isInteractive()).thenReturn(true);\n+        when(mPowerManager.isScreenOn()).thenReturn(true);\n+        when(mDreamManager.isDreaming()).thenReturn(false);\n+        when(mStatusBarStateController.getState()).thenReturn(SHADE);\n+        when(mHeadsUpManager.isSnoozed(\"a\")).thenReturn(true);\n+\n+        assertThat(mNotifInterruptionStateProvider.shouldLaunchFullScreenIntentWhenAdded(entry))\n+                .isTrue();\n+    }\n+\n     /**\n      * Bubbles can happen.\n      */\n@@ -503,6 +597,10 @@ public class NotificationInterruptStateProviderImplTest extends SysuiTestCase {\n                 .setContentText(\"content text\")\n                 .build();\n \n+        return createNotification(importance, n);\n+    }\n+\n+    private NotificationEntry createNotification(int importance, Notification n) {\n         return new NotificationEntryBuilder()\n                 .setPkg(\"a\")\n                 .setOpPkg(\"a\")\n@@ -512,6 +610,20 @@ public class NotificationInterruptStateProviderImplTest extends SysuiTestCase {\n                 .build();\n     }\n \n+    private NotificationEntry createFsiNotification(int importance, boolean silent) {\n+        Notification n = new Notification.Builder(getContext(), \"a\")\n+                .setContentTitle(\"title\")\n+                .setContentText(\"content text\")\n+                .setFullScreenIntent(mPendingIntent, true)\n+                .setGroup(\"fsi\")\n+                .setGroupAlertBehavior(silent\n+                        ? Notification.GROUP_ALERT_SUMMARY\n+                        : Notification.GROUP_ALERT_ALL)\n+                .build();\n+\n+        return createNotification(importance, n);\n+    }\n+\n     private final NotificationInterruptSuppressor\n             mSuppressAwakeHeadsUp =\n             new NotificationInterruptSuppressor() {\n",
    "added_lines": 112,
    "deleted_lines": 0,
    "changed_methods": "NotificationInterruptStateProviderImplTest::createNotification, NotificationInterruptStateProviderImplTest::createFsiNotification, NotificationInterruptStateProviderImplTest::testShouldNotFullScreen_notPendingIntent, NotificationInterruptStateProviderImplTest::testShouldFullScreen_notInteractive, NotificationInterruptStateProviderImplTest::testShouldFullScreen_onKeyguard, NotificationInterruptStateProviderImplTest::testShouldNotFullScreen_willHun, NotificationInterruptStateProviderImplTest::testShouldFullScreen_isDreaming, NotificationInterruptStateProviderImplTest::testShouldNotFullScreen_isGroupAlertSilenced, NotificationInterruptStateProviderImplTest::testShouldFullScreen_packageSnoozed, NotificationInterruptStateProviderImplTest::createNotification, NotificationInterruptStateProviderImplTest::testShouldNotFullScreen_notHighImportance"
   }
  ]
 },
 {
  "hash": "7d466d7b00888dba5270d8064dccd711d1496a1f",
  "commit": "Fix Notification redaction when power cycling a non-dozing device while occluded.\n\nThis issue was originally raised in the S timeline, but had already been fixed by the refactor to use UnlockedScreenOffAnimationController, which called updateIsKeyguard(/*force*/ true) from onFinishedWakingUp().  This solved the problem of re-triggering the redaction, but it also intriduced a new bug where the keyguard could end up briefly showing on top of the occluding activity when AOD was supported but off.  As a result, they limited the call to when the AOD was on (and animations were controlling, etc).  This CL uses the opposite check to make sure we recalcualte redaction (and only redaction, not the whole keyguard) when waking up while occluded.\n\nWe also needed to make sure that we rerun the notification pipeline when updating public information so that any necessary public views are sure to inflate.  That rerun has been limited in scope to conditions where the public mode information has detectably changed.\n\nBug: 189575031\nBug: 239828798\nTest: CTS Verifier NotificationPrivacyTest on emulator, AOD off, AOD on\nMerged-In: I95443ee6b77377aceb54b983d34131628027da9b\nChange-Id: I95443ee6b77377aceb54b983d34131628027da9b\n(cherry picked from commit 9d20909eaed9a8eae2ee73827bc15b1353e2dd8b)\nMerged-In: I95443ee6b77377aceb54b983d34131628027da9b",
  "files": [
   {
    "filename": "NotificationStackScrollLayoutController.java",
    "diff": "@@ -332,6 +332,13 @@ public class NotificationStackScrollLayoutController {\n         }\n     };\n \n+    /**\n+     * Recalculate sensitiveness without animation; called when waking up while keyguard occluded.\n+     */\n+    public void updateSensitivenessForOccludedWakeup() {\n+        mView.updateSensitiveness(false, mLockscreenUserManager.isAnyProfilePublicMode());\n+    }\n+\n     /**\n      * Set the overexpansion of the panel to be applied to the view.\n      */\n",
    "added_lines": 7,
    "deleted_lines": 0,
    "changed_methods": "NotificationStackScrollLayoutController::updateSensitivenessForOccludedWakeup"
   },
   {
    "filename": "StatusBar.java",
    "diff": "@@ -3779,6 +3779,17 @@ public class StatusBar extends SystemUI implements\n             mWakeUpCoordinator.setFullyAwake(true);\n             mBypassHeadsUpNotifier.setFullyAwake(true);\n             mWakeUpCoordinator.setWakingUp(false);\n+            if (isOccluded() && !mDozeParameters.canControlUnlockedScreenOff()) {\n+                // When the keyguard is occluded we don't use the KEYGUARD state which would\n+                // normally cause these redaction updates.  If AOD is on, the KEYGUARD state is used\n+                // to show the doze, AND UnlockedScreenOffAnimationController.onFinishedWakingUp()\n+                // would force a KEYGUARD state that would take care of recalculating redaction.\n+                // So if AOD is off or unsupported we need to trigger these updates at screen on\n+                // when the keyguard is occluded.\n+                mLockscreenUserManager.updatePublicMode();\n+                mNotificationPanelViewController.getNotificationStackScrollLayoutController()\n+                        .updateSensitivenessForOccludedWakeup();\n+            }\n             if (mLaunchCameraWhenFinishedWaking) {\n                 mNotificationPanelViewController.launchCamera(\n                         false /* animate */, mLastCameraLaunchSource);\n",
    "added_lines": 11,
    "deleted_lines": 0,
    "changed_methods": "StatusBar::Observer"
   }
  ]
 },
 {
  "hash": "7d466d7b00888dba5270d8064dccd711d1496a1f",
  "commit": "Fix Notification redaction when power cycling a non-dozing device while occluded.\n\nThis issue was originally raised in the S timeline, but had already been fixed by the refactor to use UnlockedScreenOffAnimationController, which called updateIsKeyguard(/*force*/ true) from onFinishedWakingUp().  This solved the problem of re-triggering the redaction, but it also intriduced a new bug where the keyguard could end up briefly showing on top of the occluding activity when AOD was supported but off.  As a result, they limited the call to when the AOD was on (and animations were controlling, etc).  This CL uses the opposite check to make sure we recalcualte redaction (and only redaction, not the whole keyguard) when waking up while occluded.\n\nWe also needed to make sure that we rerun the notification pipeline when updating public information so that any necessary public views are sure to inflate.  That rerun has been limited in scope to conditions where the public mode information has detectably changed.\n\nBug: 189575031\nBug: 239828798\nTest: CTS Verifier NotificationPrivacyTest on emulator, AOD off, AOD on\nMerged-In: I95443ee6b77377aceb54b983d34131628027da9b\nChange-Id: I95443ee6b77377aceb54b983d34131628027da9b\n(cherry picked from commit 9d20909eaed9a8eae2ee73827bc15b1353e2dd8b)\nMerged-In: I95443ee6b77377aceb54b983d34131628027da9b",
  "files": [
   {
    "filename": "NotificationStackScrollLayoutController.java",
    "diff": "@@ -332,6 +332,13 @@ public class NotificationStackScrollLayoutController {\n         }\n     };\n \n+    /**\n+     * Recalculate sensitiveness without animation; called when waking up while keyguard occluded.\n+     */\n+    public void updateSensitivenessForOccludedWakeup() {\n+        mView.updateSensitiveness(false, mLockscreenUserManager.isAnyProfilePublicMode());\n+    }\n+\n     /**\n      * Set the overexpansion of the panel to be applied to the view.\n      */\n",
    "added_lines": 7,
    "deleted_lines": 0,
    "changed_methods": "NotificationStackScrollLayoutController::updateSensitivenessForOccludedWakeup"
   },
   {
    "filename": "StatusBar.java",
    "diff": "@@ -3779,6 +3779,17 @@ public class StatusBar extends SystemUI implements\n             mWakeUpCoordinator.setFullyAwake(true);\n             mBypassHeadsUpNotifier.setFullyAwake(true);\n             mWakeUpCoordinator.setWakingUp(false);\n+            if (isOccluded() && !mDozeParameters.canControlUnlockedScreenOff()) {\n+                // When the keyguard is occluded we don't use the KEYGUARD state which would\n+                // normally cause these redaction updates.  If AOD is on, the KEYGUARD state is used\n+                // to show the doze, AND UnlockedScreenOffAnimationController.onFinishedWakingUp()\n+                // would force a KEYGUARD state that would take care of recalculating redaction.\n+                // So if AOD is off or unsupported we need to trigger these updates at screen on\n+                // when the keyguard is occluded.\n+                mLockscreenUserManager.updatePublicMode();\n+                mNotificationPanelViewController.getNotificationStackScrollLayoutController()\n+                        .updateSensitivenessForOccludedWakeup();\n+            }\n             if (mLaunchCameraWhenFinishedWaking) {\n                 mNotificationPanelViewController.launchCamera(\n                         false /* animate */, mLastCameraLaunchSource);\n",
    "added_lines": 11,
    "deleted_lines": 0,
    "changed_methods": "StatusBar::Observer"
   }
  ]
 },
 {
  "hash": "b0e48bda617e40866e9cde2cf8958bcc160fd6af",
  "commit": "Enforce zen rule limit on a package level.\n\nThis means that a single package with multiple different condition providers or configuration activities will correctly have all of their zen rules associated with the same package rather than each owner/activity having their rules counted separately.\n\nBug: 235823407\nTest: ZenModeHelperTest\nChange-Id: I35daf9a24f546ae25a78a2d841be39072cdc5641\nMerged-In: I35daf9a24f546ae25a78a2d841be39072cdc5641\n(cherry picked from commit f4e69394eee569ac3ec5748094b9ce88a91c278c)\n(cherry picked from commit 34f2ef779b368e9d57bfab09b61cab6d282e10e9)\nMerged-In: I35daf9a24f546ae25a78a2d841be39072cdc5641",
  "files": [
   {
    "filename": "ZenModeHelper.java",
    "diff": "@@ -326,7 +326,8 @@ public class ZenModeHelper {\n             int newRuleInstanceCount = getCurrentInstanceCount(automaticZenRule.getOwner())\n                     + getCurrentInstanceCount(automaticZenRule.getConfigurationActivity())\n                     + 1;\n-            if (newRuleInstanceCount > RULE_LIMIT_PER_PACKAGE\n+            int newPackageRuleCount = getPackageRuleCount(pkg) + 1;\n+            if (newPackageRuleCount > RULE_LIMIT_PER_PACKAGE\n                     || (ruleInstanceLimit > 0 && ruleInstanceLimit < newRuleInstanceCount)) {\n                 throw new IllegalArgumentException(\"Rule instance limit exceeded\");\n             }\n@@ -507,6 +508,23 @@ public class ZenModeHelper {\n         return count;\n     }\n \n+    // Equivalent method to getCurrentInstanceCount, but for all rules associated with a specific\n+    // package rather than a condition provider service or activity.\n+    private int getPackageRuleCount(String pkg) {\n+        if (pkg == null) {\n+            return 0;\n+        }\n+        int count = 0;\n+        synchronized (mConfig) {\n+            for (ZenRule rule : mConfig.automaticRules.values()) {\n+                if (pkg.equals(rule.getPkg())) {\n+                    count++;\n+                }\n+            }\n+        }\n+        return count;\n+    }\n+\n     public boolean canManageAutomaticZenRule(ZenRule rule) {\n         final int callingUid = Binder.getCallingUid();\n         if (callingUid == 0 || callingUid == Process.SYSTEM_UID) {\n",
    "added_lines": 19,
    "deleted_lines": 1,
    "changed_methods": "ZenModeHelper::addAutomaticZenRule, ZenModeHelper::getPackageRuleCount"
   },
   {
    "filename": "ZenModeHelperTest.java",
    "diff": "@@ -1618,7 +1618,9 @@ public class ZenModeHelperTest extends UiServiceTestCase {\n                     ZenModeConfig.toScheduleConditionId(si),\n                     new ZenPolicy.Builder().build(),\n                     NotificationManager.INTERRUPTION_FILTER_PRIORITY, true);\n-            String id = mZenModeHelperSpy.addAutomaticZenRule(\"android\", zenRule, \"test\");\n+            // We need the package name to be something that's not \"android\" so there aren't any\n+            // existing rules under that package.\n+            String id = mZenModeHelperSpy.addAutomaticZenRule(\"pkgname\", zenRule, \"test\");\n             assertNotNull(id);\n         }\n         try {\n@@ -1628,12 +1630,41 @@ public class ZenModeHelperTest extends UiServiceTestCase {\n                     ZenModeConfig.toScheduleConditionId(new ScheduleInfo()),\n                     new ZenPolicy.Builder().build(),\n                     NotificationManager.INTERRUPTION_FILTER_PRIORITY, true);\n-            String id = mZenModeHelperSpy.addAutomaticZenRule(\"android\", zenRule, \"test\");\n+            String id = mZenModeHelperSpy.addAutomaticZenRule(\"pkgname\", zenRule, \"test\");\n             fail(\"allowed too many rules to be created\");\n         } catch (IllegalArgumentException e) {\n             // yay\n         }\n+    }\n \n+    @Test\n+    public void testAddAutomaticZenRule_beyondSystemLimit_differentComponents() {\n+        // Make sure the system limit is enforced per-package even with different component provider\n+        // names.\n+        for (int i = 0; i < RULE_LIMIT_PER_PACKAGE; i++) {\n+            ScheduleInfo si = new ScheduleInfo();\n+            si.startHour = i;\n+            AutomaticZenRule zenRule = new AutomaticZenRule(\"name\" + i,\n+                    null,\n+                    new ComponentName(\"android\", \"ScheduleConditionProvider\" + i),\n+                    ZenModeConfig.toScheduleConditionId(si),\n+                    new ZenPolicy.Builder().build(),\n+                    NotificationManager.INTERRUPTION_FILTER_PRIORITY, true);\n+            String id = mZenModeHelperSpy.addAutomaticZenRule(\"pkgname\", zenRule, \"test\");\n+            assertNotNull(id);\n+        }\n+        try {\n+            AutomaticZenRule zenRule = new AutomaticZenRule(\"name\",\n+                    null,\n+                    new ComponentName(\"android\", \"ScheduleConditionProviderFinal\"),\n+                    ZenModeConfig.toScheduleConditionId(new ScheduleInfo()),\n+                    new ZenPolicy.Builder().build(),\n+                    NotificationManager.INTERRUPTION_FILTER_PRIORITY, true);\n+            String id = mZenModeHelperSpy.addAutomaticZenRule(\"pkgname\", zenRule, \"test\");\n+            fail(\"allowed too many rules to be created\");\n+        } catch (IllegalArgumentException e) {\n+            // yay\n+        }\n     }\n \n     @Test\n",
    "added_lines": 33,
    "deleted_lines": 2,
    "changed_methods": "ZenModeHelperTest::testAddAutomaticZenRule_beyondSystemLimit_differentComponents, ZenModeHelperTest::testAddAutomaticZenRule_beyondSystemLimit"
   }
  ]
 },
 {
  "hash": "b0e48bda617e40866e9cde2cf8958bcc160fd6af",
  "commit": "Enforce zen rule limit on a package level.\n\nThis means that a single package with multiple different condition providers or configuration activities will correctly have all of their zen rules associated with the same package rather than each owner/activity having their rules counted separately.\n\nBug: 235823407\nTest: ZenModeHelperTest\nChange-Id: I35daf9a24f546ae25a78a2d841be39072cdc5641\nMerged-In: I35daf9a24f546ae25a78a2d841be39072cdc5641\n(cherry picked from commit f4e69394eee569ac3ec5748094b9ce88a91c278c)\n(cherry picked from commit 34f2ef779b368e9d57bfab09b61cab6d282e10e9)\nMerged-In: I35daf9a24f546ae25a78a2d841be39072cdc5641",
  "files": [
   {
    "filename": "ZenModeHelper.java",
    "diff": "@@ -326,7 +326,8 @@ public class ZenModeHelper {\n             int newRuleInstanceCount = getCurrentInstanceCount(automaticZenRule.getOwner())\n                     + getCurrentInstanceCount(automaticZenRule.getConfigurationActivity())\n                     + 1;\n-            if (newRuleInstanceCount > RULE_LIMIT_PER_PACKAGE\n+            int newPackageRuleCount = getPackageRuleCount(pkg) + 1;\n+            if (newPackageRuleCount > RULE_LIMIT_PER_PACKAGE\n                     || (ruleInstanceLimit > 0 && ruleInstanceLimit < newRuleInstanceCount)) {\n                 throw new IllegalArgumentException(\"Rule instance limit exceeded\");\n             }\n@@ -507,6 +508,23 @@ public class ZenModeHelper {\n         return count;\n     }\n \n+    // Equivalent method to getCurrentInstanceCount, but for all rules associated with a specific\n+    // package rather than a condition provider service or activity.\n+    private int getPackageRuleCount(String pkg) {\n+        if (pkg == null) {\n+            return 0;\n+        }\n+        int count = 0;\n+        synchronized (mConfig) {\n+            for (ZenRule rule : mConfig.automaticRules.values()) {\n+                if (pkg.equals(rule.getPkg())) {\n+                    count++;\n+                }\n+            }\n+        }\n+        return count;\n+    }\n+\n     public boolean canManageAutomaticZenRule(ZenRule rule) {\n         final int callingUid = Binder.getCallingUid();\n         if (callingUid == 0 || callingUid == Process.SYSTEM_UID) {\n",
    "added_lines": 19,
    "deleted_lines": 1,
    "changed_methods": "ZenModeHelper::addAutomaticZenRule, ZenModeHelper::getPackageRuleCount"
   },
   {
    "filename": "ZenModeHelperTest.java",
    "diff": "@@ -1618,7 +1618,9 @@ public class ZenModeHelperTest extends UiServiceTestCase {\n                     ZenModeConfig.toScheduleConditionId(si),\n                     new ZenPolicy.Builder().build(),\n                     NotificationManager.INTERRUPTION_FILTER_PRIORITY, true);\n-            String id = mZenModeHelperSpy.addAutomaticZenRule(\"android\", zenRule, \"test\");\n+            // We need the package name to be something that's not \"android\" so there aren't any\n+            // existing rules under that package.\n+            String id = mZenModeHelperSpy.addAutomaticZenRule(\"pkgname\", zenRule, \"test\");\n             assertNotNull(id);\n         }\n         try {\n@@ -1628,12 +1630,41 @@ public class ZenModeHelperTest extends UiServiceTestCase {\n                     ZenModeConfig.toScheduleConditionId(new ScheduleInfo()),\n                     new ZenPolicy.Builder().build(),\n                     NotificationManager.INTERRUPTION_FILTER_PRIORITY, true);\n-            String id = mZenModeHelperSpy.addAutomaticZenRule(\"android\", zenRule, \"test\");\n+            String id = mZenModeHelperSpy.addAutomaticZenRule(\"pkgname\", zenRule, \"test\");\n             fail(\"allowed too many rules to be created\");\n         } catch (IllegalArgumentException e) {\n             // yay\n         }\n+    }\n \n+    @Test\n+    public void testAddAutomaticZenRule_beyondSystemLimit_differentComponents() {\n+        // Make sure the system limit is enforced per-package even with different component provider\n+        // names.\n+        for (int i = 0; i < RULE_LIMIT_PER_PACKAGE; i++) {\n+            ScheduleInfo si = new ScheduleInfo();\n+            si.startHour = i;\n+            AutomaticZenRule zenRule = new AutomaticZenRule(\"name\" + i,\n+                    null,\n+                    new ComponentName(\"android\", \"ScheduleConditionProvider\" + i),\n+                    ZenModeConfig.toScheduleConditionId(si),\n+                    new ZenPolicy.Builder().build(),\n+                    NotificationManager.INTERRUPTION_FILTER_PRIORITY, true);\n+            String id = mZenModeHelperSpy.addAutomaticZenRule(\"pkgname\", zenRule, \"test\");\n+            assertNotNull(id);\n+        }\n+        try {\n+            AutomaticZenRule zenRule = new AutomaticZenRule(\"name\",\n+                    null,\n+                    new ComponentName(\"android\", \"ScheduleConditionProviderFinal\"),\n+                    ZenModeConfig.toScheduleConditionId(new ScheduleInfo()),\n+                    new ZenPolicy.Builder().build(),\n+                    NotificationManager.INTERRUPTION_FILTER_PRIORITY, true);\n+            String id = mZenModeHelperSpy.addAutomaticZenRule(\"pkgname\", zenRule, \"test\");\n+            fail(\"allowed too many rules to be created\");\n+        } catch (IllegalArgumentException e) {\n+            // yay\n+        }\n     }\n \n     @Test\n",
    "added_lines": 33,
    "deleted_lines": 2,
    "changed_methods": "ZenModeHelperTest::testAddAutomaticZenRule_beyondSystemLimit_differentComponents, ZenModeHelperTest::testAddAutomaticZenRule_beyondSystemLimit"
   }
  ]
 },
 {
  "hash": "2f2dd97c1ee430c36d69e16b644641c03be46520",
  "commit": "Strip transition information from activityoptions when sent to app\n\nThe implementation of shared-element transitions takes the\nActivityOptions from the calling activity and sends them to\nanother activity. This means that any sensitive information\npassed into ActivityManager via ActivityOptions can make its\nway to an unrelated app. Recently a RemoteTransition object\nwas added which includes some sensitive information.\n\nThis CL strips the sensitive information from the activity\noptions before sending it to anonther app.\n\nBug: 237290578\nTest: atest ActivityManagerTest#testActivityManager_stripTransitionFromActivityOptions\nChange-Id: Ifa08fc195698f02bf70ca386178c67f6ba4a14ea\n(cherry picked from commit 0d03e6f1fc66fefb5409ac93ff49fa922f81664c)\nMerged-In: Ifa08fc195698f02bf70ca386178c67f6ba4a14ea",
  "files": [
   {
    "filename": "ActivityOptions.java",
    "diff": "@@ -1352,6 +1352,11 @@ public class ActivityOptions {\n         return mRemoteTransition;\n     }\n \n+    /** @hide */\n+    public void setRemoteTransition(@Nullable RemoteTransition remoteTransition) {\n+        mRemoteTransition = remoteTransition;\n+    }\n+\n     /** @hide */\n     public static ActivityOptions fromBundle(Bundle bOptions) {\n         return bOptions != null ? new ActivityOptions(bOptions) : null;\n",
    "added_lines": 5,
    "deleted_lines": 0,
    "changed_methods": "ActivityOptions::setRemoteTransition"
   },
   {
    "filename": "ActivityRecord.java",
    "diff": "@@ -4630,8 +4630,12 @@ final class ActivityRecord extends WindowToken implements WindowManagerService.A\n     ActivityOptions takeOptions() {\n         if (DEBUG_TRANSITION) Slog.i(TAG, \"Taking options for \" + this + \" callers=\"\n                 + Debug.getCallers(6));\n+        if (mPendingOptions == null) return null;\n         final ActivityOptions opts = mPendingOptions;\n         mPendingOptions = null;\n+        // Strip sensitive information from options before sending it to app.\n+        opts.setRemoteTransition(null);\n+        opts.setRemoteAnimationAdapter(null);\n         return opts;\n     }\n \n",
    "added_lines": 4,
    "deleted_lines": 0,
    "changed_methods": "ActivityRecord::takeOptions"
   }
  ]
 },
 {
  "hash": "2f2dd97c1ee430c36d69e16b644641c03be46520",
  "commit": "Strip transition information from activityoptions when sent to app\n\nThe implementation of shared-element transitions takes the\nActivityOptions from the calling activity and sends them to\nanother activity. This means that any sensitive information\npassed into ActivityManager via ActivityOptions can make its\nway to an unrelated app. Recently a RemoteTransition object\nwas added which includes some sensitive information.\n\nThis CL strips the sensitive information from the activity\noptions before sending it to anonther app.\n\nBug: 237290578\nTest: atest ActivityManagerTest#testActivityManager_stripTransitionFromActivityOptions\nChange-Id: Ifa08fc195698f02bf70ca386178c67f6ba4a14ea\n(cherry picked from commit 0d03e6f1fc66fefb5409ac93ff49fa922f81664c)\nMerged-In: Ifa08fc195698f02bf70ca386178c67f6ba4a14ea",
  "files": [
   {
    "filename": "ActivityOptions.java",
    "diff": "@@ -1352,6 +1352,11 @@ public class ActivityOptions {\n         return mRemoteTransition;\n     }\n \n+    /** @hide */\n+    public void setRemoteTransition(@Nullable RemoteTransition remoteTransition) {\n+        mRemoteTransition = remoteTransition;\n+    }\n+\n     /** @hide */\n     public static ActivityOptions fromBundle(Bundle bOptions) {\n         return bOptions != null ? new ActivityOptions(bOptions) : null;\n",
    "added_lines": 5,
    "deleted_lines": 0,
    "changed_methods": "ActivityOptions::setRemoteTransition"
   },
   {
    "filename": "ActivityRecord.java",
    "diff": "@@ -4630,8 +4630,12 @@ final class ActivityRecord extends WindowToken implements WindowManagerService.A\n     ActivityOptions takeOptions() {\n         if (DEBUG_TRANSITION) Slog.i(TAG, \"Taking options for \" + this + \" callers=\"\n                 + Debug.getCallers(6));\n+        if (mPendingOptions == null) return null;\n         final ActivityOptions opts = mPendingOptions;\n         mPendingOptions = null;\n+        // Strip sensitive information from options before sending it to app.\n+        opts.setRemoteTransition(null);\n+        opts.setRemoteAnimationAdapter(null);\n         return opts;\n     }\n \n",
    "added_lines": 4,
    "deleted_lines": 0,
    "changed_methods": "ActivityRecord::takeOptions"
   }
  ]
 },
 {
  "hash": "b24ae4fee23abb04a6f320ddfad0139a072df451",
  "commit": "Camera: Skip stream size check for whitelisted apps..\n\nIssue:\nFor quadracfa capture, Blob/YUV output streams need to be\nconfigured with custom dimensions which will not be\navailable in advertised stream configurations map.\n\nFix:\nSkip the stream size check for whitelisted apps to allow\nconfiguration of streams with custom dimensions.\n\nAlso, additionally, remove session id check so that\nbuffers from one session can be passed on to another\nsession for reprocess.\n\nSetprop to be used:\nadb shell setprop persist.vendor.camera.privapp.list <pack1,pack2>\n\nCRs-Fixed: 2075934\nChange-Id: Ie9c950fdc4e1675d19c38630d7063ac9d7c9d5b1",
  "files": [
   {
    "filename": "CameraCaptureSessionImpl.java",
    "diff": "@@ -222,7 +222,8 @@ public class CameraCaptureSessionImpl extends CameraCaptureSession\n         } else if (request.isReprocess() && !isReprocessable()) {\n             throw new IllegalArgumentException(\"this capture session cannot handle reprocess \" +\n                     \"requests\");\n-        } else if (request.isReprocess() && request.getReprocessableSessionId() != mId) {\n+        } else if (!mDeviceImpl.isPrivilegedApp() &&\n+                request.isReprocess() && request.getReprocessableSessionId() != mId) {\n             throw new IllegalArgumentException(\"capture request was created for another session\");\n         }\n     }\n",
    "added_lines": 2,
    "deleted_lines": 1,
    "changed_methods": "CameraCaptureSessionImpl::checkCaptureRequest"
   },
   {
    "filename": "CameraDeviceImpl.java",
    "diff": "@@ -22,6 +22,7 @@ import android.annotation.NonNull;\n import android.content.Context;\n import android.graphics.ImageFormat;\n import android.hardware.ICameraService;\n+import android.app.ActivityThread;\n import android.hardware.camera2.CameraAccessException;\n import android.hardware.camera2.CameraCaptureSession;\n import android.hardware.camera2.CameraCharacteristics;\n@@ -53,6 +54,8 @@ import android.os.Looper;\n import android.os.RemoteException;\n import android.os.ServiceSpecificException;\n import android.os.SystemClock;\n+import android.os.SystemProperties;\n+import android.text.TextUtils;\n import android.util.Log;\n import android.util.Range;\n import android.util.Size;\n@@ -151,6 +154,7 @@ public class CameraDeviceImpl extends CameraDevice\n     private int mNextSessionId = 0;\n \n     private final int mAppTargetSdkVersion;\n+    private boolean mIsPrivilegedApp = false;\n \n     private ExecutorService mOfflineSwitchService;\n     private CameraOfflineSessionImpl mOfflineSessionImpl;\n@@ -301,6 +305,7 @@ public class CameraDeviceImpl extends CameraDevice\n         } else {\n             mTotalPartialCount = partialCount;\n         }\n+        mIsPrivilegedApp = checkPrivilegedAppList();\n     }\n \n     public CameraDeviceCallbacks getCallbacks() {\n@@ -1503,6 +1508,27 @@ public class CameraDeviceImpl extends CameraDevice\n         return false;\n     }\n \n+    private boolean checkPrivilegedAppList() {\n+        String packageName = ActivityThread.currentOpPackageName();\n+        String packageList = SystemProperties.get(\"persist.vendor.camera.privapp.list\");\n+\n+        if (packageList.length() > 0) {\n+            TextUtils.StringSplitter splitter = new TextUtils.SimpleStringSplitter(',');\n+            splitter.setString(packageList);\n+            for (String str : splitter) {\n+                if (packageName.equals(str)) {\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+    public boolean isPrivilegedApp() {\n+        return mIsPrivilegedApp;\n+    }\n+\n     private void checkInputConfiguration(InputConfiguration inputConfig) {\n         if (inputConfig == null) {\n             return;\n@@ -1540,6 +1566,15 @@ public class CameraDeviceImpl extends CameraDevice\n                         inputConfig.getWidth() + \"x\" + inputConfig.getHeight() + \" is not valid\");\n             }\n         } else {\n+            /*\n+             * don't check input format and size,\n+             * if the package name is in the white list\n+             */\n+            if (isPrivilegedApp()) {\n+                Log.w(TAG, \"ignore input format/size check for white listed app\");\n+                return;\n+            }\n+\n             if (!checkInputConfigurationWithStreamConfigurations(inputConfig, /*maxRes*/false) &&\n                     !checkInputConfigurationWithStreamConfigurations(inputConfig, /*maxRes*/true)) {\n                 throw new IllegalArgumentException(\"Input config with format \" +\n",
    "added_lines": 35,
    "deleted_lines": 0,
    "changed_methods": "CameraDeviceImpl::checkPrivilegedAppList, CameraDeviceImpl::checkInputConfiguration, CameraDeviceImpl::isPrivilegedApp, CameraDeviceImpl::CameraDeviceImpl"
   }
  ]
 },
 {
  "hash": "b24ae4fee23abb04a6f320ddfad0139a072df451",
  "commit": "Camera: Skip stream size check for whitelisted apps..\n\nIssue:\nFor quadracfa capture, Blob/YUV output streams need to be\nconfigured with custom dimensions which will not be\navailable in advertised stream configurations map.\n\nFix:\nSkip the stream size check for whitelisted apps to allow\nconfiguration of streams with custom dimensions.\n\nAlso, additionally, remove session id check so that\nbuffers from one session can be passed on to another\nsession for reprocess.\n\nSetprop to be used:\nadb shell setprop persist.vendor.camera.privapp.list <pack1,pack2>\n\nCRs-Fixed: 2075934\nChange-Id: Ie9c950fdc4e1675d19c38630d7063ac9d7c9d5b1",
  "files": [
   {
    "filename": "CameraCaptureSessionImpl.java",
    "diff": "@@ -222,7 +222,8 @@ public class CameraCaptureSessionImpl extends CameraCaptureSession\n         } else if (request.isReprocess() && !isReprocessable()) {\n             throw new IllegalArgumentException(\"this capture session cannot handle reprocess \" +\n                     \"requests\");\n-        } else if (request.isReprocess() && request.getReprocessableSessionId() != mId) {\n+        } else if (!mDeviceImpl.isPrivilegedApp() &&\n+                request.isReprocess() && request.getReprocessableSessionId() != mId) {\n             throw new IllegalArgumentException(\"capture request was created for another session\");\n         }\n     }\n",
    "added_lines": 2,
    "deleted_lines": 1,
    "changed_methods": "CameraCaptureSessionImpl::checkCaptureRequest"
   },
   {
    "filename": "CameraDeviceImpl.java",
    "diff": "@@ -22,6 +22,7 @@ import android.annotation.NonNull;\n import android.content.Context;\n import android.graphics.ImageFormat;\n import android.hardware.ICameraService;\n+import android.app.ActivityThread;\n import android.hardware.camera2.CameraAccessException;\n import android.hardware.camera2.CameraCaptureSession;\n import android.hardware.camera2.CameraCharacteristics;\n@@ -53,6 +54,8 @@ import android.os.Looper;\n import android.os.RemoteException;\n import android.os.ServiceSpecificException;\n import android.os.SystemClock;\n+import android.os.SystemProperties;\n+import android.text.TextUtils;\n import android.util.Log;\n import android.util.Range;\n import android.util.Size;\n@@ -151,6 +154,7 @@ public class CameraDeviceImpl extends CameraDevice\n     private int mNextSessionId = 0;\n \n     private final int mAppTargetSdkVersion;\n+    private boolean mIsPrivilegedApp = false;\n \n     private ExecutorService mOfflineSwitchService;\n     private CameraOfflineSessionImpl mOfflineSessionImpl;\n@@ -301,6 +305,7 @@ public class CameraDeviceImpl extends CameraDevice\n         } else {\n             mTotalPartialCount = partialCount;\n         }\n+        mIsPrivilegedApp = checkPrivilegedAppList();\n     }\n \n     public CameraDeviceCallbacks getCallbacks() {\n@@ -1503,6 +1508,27 @@ public class CameraDeviceImpl extends CameraDevice\n         return false;\n     }\n \n+    private boolean checkPrivilegedAppList() {\n+        String packageName = ActivityThread.currentOpPackageName();\n+        String packageList = SystemProperties.get(\"persist.vendor.camera.privapp.list\");\n+\n+        if (packageList.length() > 0) {\n+            TextUtils.StringSplitter splitter = new TextUtils.SimpleStringSplitter(',');\n+            splitter.setString(packageList);\n+            for (String str : splitter) {\n+                if (packageName.equals(str)) {\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+    public boolean isPrivilegedApp() {\n+        return mIsPrivilegedApp;\n+    }\n+\n     private void checkInputConfiguration(InputConfiguration inputConfig) {\n         if (inputConfig == null) {\n             return;\n@@ -1540,6 +1566,15 @@ public class CameraDeviceImpl extends CameraDevice\n                         inputConfig.getWidth() + \"x\" + inputConfig.getHeight() + \" is not valid\");\n             }\n         } else {\n+            /*\n+             * don't check input format and size,\n+             * if the package name is in the white list\n+             */\n+            if (isPrivilegedApp()) {\n+                Log.w(TAG, \"ignore input format/size check for white listed app\");\n+                return;\n+            }\n+\n             if (!checkInputConfigurationWithStreamConfigurations(inputConfig, /*maxRes*/false) &&\n                     !checkInputConfigurationWithStreamConfigurations(inputConfig, /*maxRes*/true)) {\n                 throw new IllegalArgumentException(\"Input config with format \" +\n",
    "added_lines": 35,
    "deleted_lines": 0,
    "changed_methods": "CameraDeviceImpl::checkPrivilegedAppList, CameraDeviceImpl::checkInputConfiguration, CameraDeviceImpl::isPrivilegedApp, CameraDeviceImpl::CameraDeviceImpl"
   }
  ]
 },
 {
  "hash": "11b0c7005af679db65872bd45c1a3b5234aee04c",
  "commit": "SystemUI: Properly set onclick listener for battery\n\nChange-Id: I59acae19c382a2995777464ec545c608fcaa00c0",
  "files": [
   {
    "filename": "QuickStatusBarHeader.java",
    "diff": "@@ -157,9 +157,6 @@ public class QuickStatusBarHeader extends FrameLayout implements TunerService.Tu\n         mDatePrivacySeparator = findViewById(R.id.space);\n         // Tint for the battery icons are handled in setupHost()\n         mBatteryRemainingIcon = findViewById(R.id.batteryRemainingIcon);\n-        mBatteryRemainingIcon.setOnClickListener(\n-                v -> mActivityStarter.postStartActivityDismissingKeyguard(\n-                        new Intent(Intent.ACTION_POWER_USAGE_SUMMARY), 0));\n \n         updateResources();\n         Configuration config = mContext.getResources().getConfiguration();\n@@ -404,10 +401,12 @@ public class QuickStatusBarHeader extends FrameLayout implements TunerService.Tu\n             // Animates the icons and battery indicator from alpha 0 to 1, when the chip is visible\n             mIconsAlphaAnimator = mIconsAlphaAnimatorFixed;\n             mIconsAlphaAnimator.setPosition(mKeyguardExpansionFraction);\n+            setBatteryRemainingOnClick(false);\n         } else {\n             mIconsAlphaAnimator = null;\n             mIconContainer.setAlpha(1);\n             mBatteryRemainingIcon.setAlpha(1);\n+            setBatteryRemainingOnClick(true);\n         }\n \n     }\n@@ -568,6 +567,9 @@ public class QuickStatusBarHeader extends FrameLayout implements TunerService.Tu\n \n     public void updateEverything() {\n         post(() -> setClickable(!mExpanded));\n+        if (mExpanded) {\n+            setBatteryRemainingOnClick(true);\n+        }\n     }\n \n     public void setCallback(Callback qsPanelCallback) {\n@@ -596,4 +598,16 @@ public class QuickStatusBarHeader extends FrameLayout implements TunerService.Tu\n         mClockView.setClockVisibleByUser(!StatusBarIconController.getIconHideList(\n                 mContext, newValue).contains(\"clock\"));\n     }\n+\n+    private void setBatteryRemainingOnClick(boolean enable) {\n+        if (enable) {\n+            mBatteryRemainingIcon.setOnClickListener(\n+                    v -> mActivityStarter.postStartActivityDismissingKeyguard(\n+                            new Intent(Intent.ACTION_POWER_USAGE_SUMMARY), 0));\n+            mBatteryRemainingIcon.setClickable(true);\n+        } else {\n+            mBatteryRemainingIcon.setOnClickListener(null);\n+            mBatteryRemainingIcon.setClickable(false);\n+        }\n+    }\n }\n",
    "added_lines": 17,
    "deleted_lines": 3,
    "changed_methods": "QuickStatusBarHeader::onFinishInflate, QuickStatusBarHeader::updateEverything, QuickStatusBarHeader::setBatteryRemainingOnClick, QuickStatusBarHeader::setChipVisibility"
   }
  ]
 },
 {
  "hash": "b9f57cb67636f526f50e544f1462bce4640b2e4a",
  "commit": "DO NOT MERGE\nMove accountname and typeName length check from Account.java to AccountManagerService.\n\nBug: 169762606\nTest: atest AccountManagerServiceTest\nChange-Id: I80fabf3a64c55837db98ff316e7e5420129c001b\n(cherry picked from commit 0adcadb0b28310bac568def4da2cbaf16843bcea)\n(cherry picked from commit c48f5407d5ae5210b9ee486e362c43a90409faa0)\nMerged-In: I80fabf3a64c55837db98ff316e7e5420129c001b",
  "files": [
   {
    "filename": "Account.java",
    "diff": "@@ -31,7 +31,6 @@ import android.util.Log;\n \n import com.android.internal.annotations.GuardedBy;\n \n-import java.util.Objects;\n import java.util.Set;\n \n /**\n@@ -87,12 +86,6 @@ public class Account implements Parcelable {\n         if (TextUtils.isEmpty(type)) {\n             throw new IllegalArgumentException(\"the type must not be empty: \" + type);\n         }\n-        if (name.length() > 200) {\n-            throw new IllegalArgumentException(\"account name is longer than 200 characters\");\n-        }\n-        if (type.length() > 200) {\n-            throw new IllegalArgumentException(\"account type is longer than 200 characters\");\n-        }\n         this.name = name;\n         this.type = type;\n         this.accessId = accessId;\n",
    "added_lines": 0,
    "deleted_lines": 7,
    "changed_methods": "Account::Account"
   },
   {
    "filename": "AccountManagerService.java",
    "diff": "@@ -1819,6 +1819,14 @@ public class AccountManagerService\n         if (account == null) {\n             return false;\n         }\n+        if (account.name != null && account.name.length() > 200) {\n+            Log.w(TAG, \"Account cannot be added - Name longer than 200 chars\");\n+            return false;\n+        }\n+        if (account.type != null && account.type.length() > 200) {\n+            Log.w(TAG, \"Account cannot be added - Name longer than 200 chars\");\n+            return false;\n+        }\n         if (!isLocalUnlockedUser(accounts.userId)) {\n             Log.w(TAG, \"Account \" + account.toSafeString() + \" cannot be added - user \"\n                     + accounts.userId + \" is locked. callingUid=\" + callingUid);\n@@ -2064,6 +2072,10 @@ public class AccountManagerService\n                 + \", pid \" + Binder.getCallingPid());\n         }\n         if (accountToRename == null) throw new IllegalArgumentException(\"account is null\");\n+        if (newName != null && newName.length() > 200) {\n+            Log.e(TAG, \"renameAccount failed - account name longer than 200\");\n+            throw new IllegalArgumentException(\"account name longer than 200\");\n+        }\n         int userId = UserHandle.getCallingUserId();\n         if (!isAccountManagedByCaller(accountToRename.type, callingUid, userId)) {\n             String msg = String.format(\n",
    "added_lines": 12,
    "deleted_lines": 0,
    "changed_methods": "AccountManagerService::addAccountInternal, AccountManagerService::renameAccount"
   },
   {
    "filename": "AccountManagerServiceTest.java",
    "diff": "@@ -36,6 +36,7 @@ import android.accounts.CantAddAccountActivity;\n import android.accounts.IAccountManagerResponse;\n import android.app.AppOpsManager;\n import android.app.INotificationManager;\n+import android.app.PropertyInvalidatedCache;\n import android.app.admin.DevicePolicyManager;\n import android.app.admin.DevicePolicyManagerInternal;\n import android.content.BroadcastReceiver;\n@@ -132,6 +133,8 @@ public class AccountManagerServiceTest extends AndroidTestCase {\n     protected void setUp() throws Exception {\n         MockitoAnnotations.initMocks(this);\n \n+        PropertyInvalidatedCache.disableForTestMode();\n+\n         when(mMockPackageManager.checkSignatures(anyInt(), anyInt()))\n                     .thenReturn(PackageManager.SIGNATURE_MATCH);\n         final UserInfo ui = new UserInfo(UserHandle.USER_SYSTEM, \"user0\", 0);\n@@ -247,6 +250,27 @@ public class AccountManagerServiceTest extends AndroidTestCase {\n         assertEquals(a31, accounts[1]);\n     }\n \n+    @SmallTest\n+    public void testCheckAddAccountLongName() throws Exception {\n+        unlockSystemUser();\n+        //test comment\n+        String longString = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n+                + \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n+                + \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n+                + \"aaaaa\";\n+        Account a11 = new Account(longString, AccountManagerServiceTestFixtures.ACCOUNT_TYPE_1);\n+\n+        mAms.addAccountExplicitly(\n+                a11, /* password= */ \"p11\", /* extras= */ null, /* callerPackage= */ null);\n+\n+        String[] list = new String[]{AccountManagerServiceTestFixtures.CALLER_PACKAGE};\n+        when(mMockPackageManager.getPackagesForUid(anyInt())).thenReturn(list);\n+        Account[] accounts = mAms.getAccountsAsUser(null,\n+                UserHandle.getCallingUserId(), mContext.getOpPackageName());\n+        assertEquals(0, accounts.length);\n+    }\n+\n+\n     @SmallTest\n     public void testPasswords() throws Exception {\n         unlockSystemUser();\n",
    "added_lines": 24,
    "deleted_lines": 0,
    "changed_methods": "AccountManagerServiceTest::setUp, AccountManagerServiceTest::testCheckAddAccountLongName"
   }
  ]
 },
 {
  "hash": "b9f57cb67636f526f50e544f1462bce4640b2e4a",
  "commit": "DO NOT MERGE\nMove accountname and typeName length check from Account.java to AccountManagerService.\n\nBug: 169762606\nTest: atest AccountManagerServiceTest\nChange-Id: I80fabf3a64c55837db98ff316e7e5420129c001b\n(cherry picked from commit 0adcadb0b28310bac568def4da2cbaf16843bcea)\n(cherry picked from commit c48f5407d5ae5210b9ee486e362c43a90409faa0)\nMerged-In: I80fabf3a64c55837db98ff316e7e5420129c001b",
  "files": [
   {
    "filename": "Account.java",
    "diff": "@@ -31,7 +31,6 @@ import android.util.Log;\n \n import com.android.internal.annotations.GuardedBy;\n \n-import java.util.Objects;\n import java.util.Set;\n \n /**\n@@ -87,12 +86,6 @@ public class Account implements Parcelable {\n         if (TextUtils.isEmpty(type)) {\n             throw new IllegalArgumentException(\"the type must not be empty: \" + type);\n         }\n-        if (name.length() > 200) {\n-            throw new IllegalArgumentException(\"account name is longer than 200 characters\");\n-        }\n-        if (type.length() > 200) {\n-            throw new IllegalArgumentException(\"account type is longer than 200 characters\");\n-        }\n         this.name = name;\n         this.type = type;\n         this.accessId = accessId;\n",
    "added_lines": 0,
    "deleted_lines": 7,
    "changed_methods": "Account::Account"
   },
   {
    "filename": "AccountManagerService.java",
    "diff": "@@ -1819,6 +1819,14 @@ public class AccountManagerService\n         if (account == null) {\n             return false;\n         }\n+        if (account.name != null && account.name.length() > 200) {\n+            Log.w(TAG, \"Account cannot be added - Name longer than 200 chars\");\n+            return false;\n+        }\n+        if (account.type != null && account.type.length() > 200) {\n+            Log.w(TAG, \"Account cannot be added - Name longer than 200 chars\");\n+            return false;\n+        }\n         if (!isLocalUnlockedUser(accounts.userId)) {\n             Log.w(TAG, \"Account \" + account.toSafeString() + \" cannot be added - user \"\n                     + accounts.userId + \" is locked. callingUid=\" + callingUid);\n@@ -2064,6 +2072,10 @@ public class AccountManagerService\n                 + \", pid \" + Binder.getCallingPid());\n         }\n         if (accountToRename == null) throw new IllegalArgumentException(\"account is null\");\n+        if (newName != null && newName.length() > 200) {\n+            Log.e(TAG, \"renameAccount failed - account name longer than 200\");\n+            throw new IllegalArgumentException(\"account name longer than 200\");\n+        }\n         int userId = UserHandle.getCallingUserId();\n         if (!isAccountManagedByCaller(accountToRename.type, callingUid, userId)) {\n             String msg = String.format(\n",
    "added_lines": 12,
    "deleted_lines": 0,
    "changed_methods": "AccountManagerService::addAccountInternal, AccountManagerService::renameAccount"
   },
   {
    "filename": "AccountManagerServiceTest.java",
    "diff": "@@ -36,6 +36,7 @@ import android.accounts.CantAddAccountActivity;\n import android.accounts.IAccountManagerResponse;\n import android.app.AppOpsManager;\n import android.app.INotificationManager;\n+import android.app.PropertyInvalidatedCache;\n import android.app.admin.DevicePolicyManager;\n import android.app.admin.DevicePolicyManagerInternal;\n import android.content.BroadcastReceiver;\n@@ -132,6 +133,8 @@ public class AccountManagerServiceTest extends AndroidTestCase {\n     protected void setUp() throws Exception {\n         MockitoAnnotations.initMocks(this);\n \n+        PropertyInvalidatedCache.disableForTestMode();\n+\n         when(mMockPackageManager.checkSignatures(anyInt(), anyInt()))\n                     .thenReturn(PackageManager.SIGNATURE_MATCH);\n         final UserInfo ui = new UserInfo(UserHandle.USER_SYSTEM, \"user0\", 0);\n@@ -247,6 +250,27 @@ public class AccountManagerServiceTest extends AndroidTestCase {\n         assertEquals(a31, accounts[1]);\n     }\n \n+    @SmallTest\n+    public void testCheckAddAccountLongName() throws Exception {\n+        unlockSystemUser();\n+        //test comment\n+        String longString = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n+                + \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n+                + \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n+                + \"aaaaa\";\n+        Account a11 = new Account(longString, AccountManagerServiceTestFixtures.ACCOUNT_TYPE_1);\n+\n+        mAms.addAccountExplicitly(\n+                a11, /* password= */ \"p11\", /* extras= */ null, /* callerPackage= */ null);\n+\n+        String[] list = new String[]{AccountManagerServiceTestFixtures.CALLER_PACKAGE};\n+        when(mMockPackageManager.getPackagesForUid(anyInt())).thenReturn(list);\n+        Account[] accounts = mAms.getAccountsAsUser(null,\n+                UserHandle.getCallingUserId(), mContext.getOpPackageName());\n+        assertEquals(0, accounts.length);\n+    }\n+\n+\n     @SmallTest\n     public void testPasswords() throws Exception {\n         unlockSystemUser();\n",
    "added_lines": 24,
    "deleted_lines": 0,
    "changed_methods": "AccountManagerServiceTest::setUp, AccountManagerServiceTest::testCheckAddAccountLongName"
   }
  ]
 },
 {
  "hash": "b9f57cb67636f526f50e544f1462bce4640b2e4a",
  "commit": "DO NOT MERGE\nMove accountname and typeName length check from Account.java to AccountManagerService.\n\nBug: 169762606\nTest: atest AccountManagerServiceTest\nChange-Id: I80fabf3a64c55837db98ff316e7e5420129c001b\n(cherry picked from commit 0adcadb0b28310bac568def4da2cbaf16843bcea)\n(cherry picked from commit c48f5407d5ae5210b9ee486e362c43a90409faa0)\nMerged-In: I80fabf3a64c55837db98ff316e7e5420129c001b",
  "files": [
   {
    "filename": "Account.java",
    "diff": "@@ -31,7 +31,6 @@ import android.util.Log;\n \n import com.android.internal.annotations.GuardedBy;\n \n-import java.util.Objects;\n import java.util.Set;\n \n /**\n@@ -87,12 +86,6 @@ public class Account implements Parcelable {\n         if (TextUtils.isEmpty(type)) {\n             throw new IllegalArgumentException(\"the type must not be empty: \" + type);\n         }\n-        if (name.length() > 200) {\n-            throw new IllegalArgumentException(\"account name is longer than 200 characters\");\n-        }\n-        if (type.length() > 200) {\n-            throw new IllegalArgumentException(\"account type is longer than 200 characters\");\n-        }\n         this.name = name;\n         this.type = type;\n         this.accessId = accessId;\n",
    "added_lines": 0,
    "deleted_lines": 7,
    "changed_methods": "Account::Account"
   },
   {
    "filename": "AccountManagerService.java",
    "diff": "@@ -1819,6 +1819,14 @@ public class AccountManagerService\n         if (account == null) {\n             return false;\n         }\n+        if (account.name != null && account.name.length() > 200) {\n+            Log.w(TAG, \"Account cannot be added - Name longer than 200 chars\");\n+            return false;\n+        }\n+        if (account.type != null && account.type.length() > 200) {\n+            Log.w(TAG, \"Account cannot be added - Name longer than 200 chars\");\n+            return false;\n+        }\n         if (!isLocalUnlockedUser(accounts.userId)) {\n             Log.w(TAG, \"Account \" + account.toSafeString() + \" cannot be added - user \"\n                     + accounts.userId + \" is locked. callingUid=\" + callingUid);\n@@ -2064,6 +2072,10 @@ public class AccountManagerService\n                 + \", pid \" + Binder.getCallingPid());\n         }\n         if (accountToRename == null) throw new IllegalArgumentException(\"account is null\");\n+        if (newName != null && newName.length() > 200) {\n+            Log.e(TAG, \"renameAccount failed - account name longer than 200\");\n+            throw new IllegalArgumentException(\"account name longer than 200\");\n+        }\n         int userId = UserHandle.getCallingUserId();\n         if (!isAccountManagedByCaller(accountToRename.type, callingUid, userId)) {\n             String msg = String.format(\n",
    "added_lines": 12,
    "deleted_lines": 0,
    "changed_methods": "AccountManagerService::addAccountInternal, AccountManagerService::renameAccount"
   },
   {
    "filename": "AccountManagerServiceTest.java",
    "diff": "@@ -36,6 +36,7 @@ import android.accounts.CantAddAccountActivity;\n import android.accounts.IAccountManagerResponse;\n import android.app.AppOpsManager;\n import android.app.INotificationManager;\n+import android.app.PropertyInvalidatedCache;\n import android.app.admin.DevicePolicyManager;\n import android.app.admin.DevicePolicyManagerInternal;\n import android.content.BroadcastReceiver;\n@@ -132,6 +133,8 @@ public class AccountManagerServiceTest extends AndroidTestCase {\n     protected void setUp() throws Exception {\n         MockitoAnnotations.initMocks(this);\n \n+        PropertyInvalidatedCache.disableForTestMode();\n+\n         when(mMockPackageManager.checkSignatures(anyInt(), anyInt()))\n                     .thenReturn(PackageManager.SIGNATURE_MATCH);\n         final UserInfo ui = new UserInfo(UserHandle.USER_SYSTEM, \"user0\", 0);\n@@ -247,6 +250,27 @@ public class AccountManagerServiceTest extends AndroidTestCase {\n         assertEquals(a31, accounts[1]);\n     }\n \n+    @SmallTest\n+    public void testCheckAddAccountLongName() throws Exception {\n+        unlockSystemUser();\n+        //test comment\n+        String longString = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n+                + \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n+                + \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n+                + \"aaaaa\";\n+        Account a11 = new Account(longString, AccountManagerServiceTestFixtures.ACCOUNT_TYPE_1);\n+\n+        mAms.addAccountExplicitly(\n+                a11, /* password= */ \"p11\", /* extras= */ null, /* callerPackage= */ null);\n+\n+        String[] list = new String[]{AccountManagerServiceTestFixtures.CALLER_PACKAGE};\n+        when(mMockPackageManager.getPackagesForUid(anyInt())).thenReturn(list);\n+        Account[] accounts = mAms.getAccountsAsUser(null,\n+                UserHandle.getCallingUserId(), mContext.getOpPackageName());\n+        assertEquals(0, accounts.length);\n+    }\n+\n+\n     @SmallTest\n     public void testPasswords() throws Exception {\n         unlockSystemUser();\n",
    "added_lines": 24,
    "deleted_lines": 0,
    "changed_methods": "AccountManagerServiceTest::setUp, AccountManagerServiceTest::testCheckAddAccountLongName"
   }
  ]
 },
 {
  "hash": "5c68b1333bb3d3a2522bc6f2631c9fa91b8eff47",
  "commit": "switch TelecomManager List getters to ParceledListSlice\n\nIt was shown that given a large phoneAccountHandles that are\nover 1 mb, a TransactionTooLarge exception can be silently thrown\ncausing an empty list to be returned.\n\nIn order to prevent this behavior, all Lists that return a\nPhoneAccountHandle or PhoneAccount have been switched to\nParceledListSlice.\n\nbug: 236263294\nTest: atest android.telecom.cts.PhoneAccountRegistrarTest\n             #testRegisterPhoneAccountHandleWithFieldOverLimit\nChange-Id: I025245b2a6f8cfaca86f268851a9d8f0817e07dd\nMerged-In: I025245b2a6f8cfaca86f268851a9d8f0817e07dd\n(cherry picked from commit d54a48f42aca2ce06363a2c260cd3a8668e938d8)\nMerged-In: I025245b2a6f8cfaca86f268851a9d8f0817e07dd",
  "files": [
   {
    "filename": "TelecomManager.java",
    "diff": "@@ -1274,7 +1274,7 @@ public class TelecomManager {\n         if (service != null) {\n             try {\n                 return service.getPhoneAccountsSupportingScheme(uriScheme,\n-                        mContext.getOpPackageName());\n+                        mContext.getOpPackageName()).getList();\n             } catch (RemoteException e) {\n                 Log.e(TAG, \"Error calling ITelecomService#getPhoneAccountsSupportingScheme\", e);\n             }\n@@ -1316,7 +1316,7 @@ public class TelecomManager {\n         if (service != null) {\n             try {\n                 return service.getSelfManagedPhoneAccounts(mContext.getOpPackageName(),\n-                        mContext.getAttributionTag());\n+                        mContext.getAttributionTag()).getList();\n             } catch (RemoteException e) {\n                 Log.e(TAG, \"Error calling ITelecomService#getSelfManagedPhoneAccounts()\", e);\n             }\n@@ -1342,7 +1342,7 @@ public class TelecomManager {\n         if (service != null) {\n             try {\n                 return service.getCallCapablePhoneAccounts(includeDisabledAccounts,\n-                        mContext.getOpPackageName(), mContext.getAttributionTag());\n+                        mContext.getOpPackageName(), mContext.getAttributionTag()).getList();\n             } catch (RemoteException e) {\n                 Log.e(TAG, \"Error calling ITelecomService#getCallCapablePhoneAccounts(\"\n                         + includeDisabledAccounts + \")\", e);\n@@ -1366,7 +1366,7 @@ public class TelecomManager {\n         ITelecomService service = getTelecomService();\n         if (service != null) {\n             try {\n-                return service.getPhoneAccountsForPackage(mContext.getPackageName());\n+                return service.getPhoneAccountsForPackage(mContext.getPackageName()).getList();\n             } catch (RemoteException e) {\n                 Log.e(TAG, \"Error calling ITelecomService#getPhoneAccountsForPackage\", e);\n             }\n@@ -1426,7 +1426,7 @@ public class TelecomManager {\n         ITelecomService service = getTelecomService();\n         if (service != null) {\n             try {\n-                return service.getAllPhoneAccounts();\n+                return service.getAllPhoneAccounts().getList();\n             } catch (RemoteException e) {\n                 Log.e(TAG, \"Error calling ITelecomService#getAllPhoneAccounts\", e);\n             }\n@@ -1445,7 +1445,7 @@ public class TelecomManager {\n         ITelecomService service = getTelecomService();\n         if (service != null) {\n             try {\n-                return service.getAllPhoneAccountHandles();\n+                return service.getAllPhoneAccountHandles().getList();\n             } catch (RemoteException e) {\n                 Log.e(TAG, \"Error calling ITelecomService#getAllPhoneAccountHandles\", e);\n             }\n",
    "added_lines": 6,
    "deleted_lines": 6,
    "changed_methods": "TelecomManager::getSelfManagedPhoneAccounts, TelecomManager::getAllPhoneAccounts, TelecomManager::getPhoneAccountsSupportingScheme, TelecomManager::getPhoneAccountsForPackage, TelecomManager::getAllPhoneAccountHandles, TelecomManager::getCallCapablePhoneAccounts"
   }
  ]
 },
 {
  "hash": "8a2bb82716fc44049e5bff9fdbb2044c1ff59daa",
  "commit": "[RESTRICT AUTOMERGE] Do not send new Intent to non-exported activity when navigateUpTo\n\nThe new Intent was delivered to a non-exported activity while\n#navigateUpTo was called from an Activity of a different uid.\n\nBug: 238605611\nTest: atest StartActivityTests\nChange-Id: I854dd825bfd9a2c08851980d480d1f3a177af6cf\nMerged-In: I854dd825bfd9a2c08851980d480d1f3a177af6cf\n(cherry picked from commit 89ebc8c43f7d2aeaee4fdcf667f07aa98404981d)\nMerged-In: I854dd825bfd9a2c08851980d480d1f3a177af6cf",
  "files": [
   {
    "filename": "Task.java",
    "diff": "@@ -5475,7 +5475,23 @@ class Task extends TaskFragment {\n                     parentLaunchMode == ActivityInfo.LAUNCH_SINGLE_TASK ||\n                     parentLaunchMode == ActivityInfo.LAUNCH_SINGLE_TOP ||\n                     (destIntentFlags & Intent.FLAG_ACTIVITY_CLEAR_TOP) != 0) {\n-                parent.deliverNewIntentLocked(callingUid, destIntent, destGrants, srec.packageName);\n+                boolean abort;\n+                try {\n+                    abort = !mTaskSupervisor.checkStartAnyActivityPermission(destIntent,\n+                            parent.info, null /* resultWho */, -1 /* requestCode */, srec.getPid(),\n+                            callingUid, srec.info.packageName, null /* callingFeatureId */,\n+                            false /* ignoreTargetSecurity */, false /* launchingInTask */, srec.app,\n+                            null /* resultRecord */, null /* resultRootTask */);\n+                } catch (SecurityException e) {\n+                    abort = true;\n+                }\n+                if (abort) {\n+                    android.util.EventLog.writeEvent(0x534e4554, \"238605611\", callingUid, \"\");\n+                    foundParentInTask = false;\n+                } else {\n+                    parent.deliverNewIntentLocked(callingUid, destIntent, destGrants,\n+                            srec.packageName);\n+                }\n             } else {\n                 try {\n                     ActivityInfo aInfo = AppGlobals.getPackageManager().getActivityInfo(\n",
    "added_lines": 17,
    "deleted_lines": 1,
    "changed_methods": "Task::navigateUpTo"
   }
  ]
 },
 {
  "hash": "c9a0b9b3fa30d1a24537b8d68a8d3e9ad4e87ffe",
  "commit": "Do not send AccessibilityEvent if notification is for different user.\n\nBug: 237540408\nTest: BuzzBeepBlinkTest#testA11yCrossUserEventNotSent\nChange-Id: I62a875e26e214847ec72ce3c41b4f2fa8e597e07\n(cherry picked from commit a367c0a16a9070ed6bee3028ac5bbc967773ee8f)\nMerged-In: I62a875e26e214847ec72ce3c41b4f2fa8e597e07",
  "files": [
   {
    "filename": "NotificationManagerService.java",
    "diff": "@@ -7426,7 +7426,8 @@ public class NotificationManagerService extends SystemService {\n                 && (record.getSuppressedVisualEffects() & SUPPRESSED_EFFECT_STATUS_BAR) != 0;\n         if (!record.isUpdate\n                 && record.getImportance() > IMPORTANCE_MIN\n-                && !suppressedByDnd) {\n+                && !suppressedByDnd\n+                && isNotificationForCurrentUser(record)) {\n             sendAccessibilityEvent(record);\n             sentAccessibilityEvent = true;\n         }\n",
    "added_lines": 2,
    "deleted_lines": 1,
    "changed_methods": "NotificationManagerService::buzzBeepBlinkLocked"
   },
   {
    "filename": "BuzzBeepBlinkTest.java",
    "diff": "@@ -1299,6 +1299,21 @@ public class BuzzBeepBlinkTest extends UiServiceTestCase {\n         verify(mAccessibilityService, times(1)).sendAccessibilityEvent(any(), anyInt());\n     }\n \n+    @Test\n+    public void testA11yCrossUserEventNotSent() throws Exception {\n+        final Notification n = new Builder(getContext(), \"test\")\n+                .setSmallIcon(android.R.drawable.sym_def_app_icon).build();\n+        int userId = mUser.getIdentifier() + 1;\n+        StatusBarNotification sbn = new StatusBarNotification(mPkg, mPkg, 0, mTag, mUid,\n+                mPid, n, UserHandle.of(userId), null, System.currentTimeMillis());\n+        NotificationRecord r = new NotificationRecord(getContext(), sbn,\n+                new NotificationChannel(\"test\", \"test\", IMPORTANCE_HIGH));\n+\n+        mService.buzzBeepBlinkLocked(r);\n+\n+        verify(mAccessibilityService, never()).sendAccessibilityEvent(any(), anyInt());\n+    }\n+\n     @Test\n     public void testLightsScreenOn() {\n         mService.mScreenOn = true;\n",
    "added_lines": 15,
    "deleted_lines": 0,
    "changed_methods": "BuzzBeepBlinkTest::testA11yCrossUserEventNotSent"
   }
  ]
 },
 {
  "hash": "c9a0b9b3fa30d1a24537b8d68a8d3e9ad4e87ffe",
  "commit": "Do not send AccessibilityEvent if notification is for different user.\n\nBug: 237540408\nTest: BuzzBeepBlinkTest#testA11yCrossUserEventNotSent\nChange-Id: I62a875e26e214847ec72ce3c41b4f2fa8e597e07\n(cherry picked from commit a367c0a16a9070ed6bee3028ac5bbc967773ee8f)\nMerged-In: I62a875e26e214847ec72ce3c41b4f2fa8e597e07",
  "files": [
   {
    "filename": "NotificationManagerService.java",
    "diff": "@@ -7426,7 +7426,8 @@ public class NotificationManagerService extends SystemService {\n                 && (record.getSuppressedVisualEffects() & SUPPRESSED_EFFECT_STATUS_BAR) != 0;\n         if (!record.isUpdate\n                 && record.getImportance() > IMPORTANCE_MIN\n-                && !suppressedByDnd) {\n+                && !suppressedByDnd\n+                && isNotificationForCurrentUser(record)) {\n             sendAccessibilityEvent(record);\n             sentAccessibilityEvent = true;\n         }\n",
    "added_lines": 2,
    "deleted_lines": 1,
    "changed_methods": "NotificationManagerService::buzzBeepBlinkLocked"
   },
   {
    "filename": "BuzzBeepBlinkTest.java",
    "diff": "@@ -1299,6 +1299,21 @@ public class BuzzBeepBlinkTest extends UiServiceTestCase {\n         verify(mAccessibilityService, times(1)).sendAccessibilityEvent(any(), anyInt());\n     }\n \n+    @Test\n+    public void testA11yCrossUserEventNotSent() throws Exception {\n+        final Notification n = new Builder(getContext(), \"test\")\n+                .setSmallIcon(android.R.drawable.sym_def_app_icon).build();\n+        int userId = mUser.getIdentifier() + 1;\n+        StatusBarNotification sbn = new StatusBarNotification(mPkg, mPkg, 0, mTag, mUid,\n+                mPid, n, UserHandle.of(userId), null, System.currentTimeMillis());\n+        NotificationRecord r = new NotificationRecord(getContext(), sbn,\n+                new NotificationChannel(\"test\", \"test\", IMPORTANCE_HIGH));\n+\n+        mService.buzzBeepBlinkLocked(r);\n+\n+        verify(mAccessibilityService, never()).sendAccessibilityEvent(any(), anyInt());\n+    }\n+\n     @Test\n     public void testLightsScreenOn() {\n         mService.mScreenOn = true;\n",
    "added_lines": 15,
    "deleted_lines": 0,
    "changed_methods": "BuzzBeepBlinkTest::testA11yCrossUserEventNotSent"
   }
  ]
 },
 {
  "hash": "a1865c2b63ad8204cd29634820004bb729b50490",
  "commit": "DO NOT MERGE Fix auto-grant of AR runtime permission if device is upgrading from pre-Q\n\nTest: Manually install app apks targeting Q and verifying that AR permission is not auto-granted\nTest: atest ActivityRecognitionPermissionTest\nBug: 210065877\nChange-Id: I5b2f25218fcbb34a940dfa2ff722cc6595732cfa\n(cherry picked from commit 23aac9cb8eb4545a79bafef3c14864e0aa59e228)\nMerged-In: I5b2f25218fcbb34a940dfa2ff722cc6595732cfa",
  "files": [
   {
    "filename": "PermissionManagerService.java",
    "diff": "@@ -2764,7 +2764,6 @@ public class PermissionManagerService extends IPermissionManager.Stub {\n                     final Permission bp = mRegistry.getPermission(permName);\n                     final boolean appSupportsRuntimePermissions =\n                             pkg.getTargetSdkVersion() >= Build.VERSION_CODES.M;\n-                    String legacyActivityRecognitionPermission = null;\n \n                     if (DEBUG_INSTALL && bp != null) {\n                         Log.i(TAG, \"Package \" + friendlyName\n@@ -2788,47 +2787,12 @@ public class PermissionManagerService extends IPermissionManager.Stub {\n                     // Cache newImplicitPermissions before modifing permissionsState as for the\n                     // shared uids the original and new state are the same object\n                     if (!origState.hasPermissionState(permName)\n-                            && (pkg.getImplicitPermissions().contains(permName)\n-                            || (permName.equals(Manifest.permission.ACTIVITY_RECOGNITION)))) {\n-                        if (pkg.getImplicitPermissions().contains(permName)) {\n+                            && (pkg.getImplicitPermissions().contains(permName))) {\n                             // If permName is an implicit permission, try to auto-grant\n                             newImplicitPermissions.add(permName);\n-\n                             if (DEBUG_PERMISSIONS) {\n                                 Slog.i(TAG, permName + \" is newly added for \" + friendlyName);\n                             }\n-                        } else {\n-                            // Special case for Activity Recognition permission. Even if AR\n-                            // permission is not an implicit permission we want to add it to the\n-                            // list (try to auto-grant it) if the app was installed on a device\n-                            // before AR permission was split, regardless of if the app now requests\n-                            // the new AR permission or has updated its target SDK and AR is no\n-                            // longer implicit to it. This is a compatibility workaround for apps\n-                            // when AR permission was split in Q.\n-                            // TODO(zhanghai): This calls into SystemConfig, which generally\n-                            //  shouldn't  cause deadlock, but maybe we should keep a cache of the\n-                            //  split permission  list and just eliminate the possibility.\n-                            final List<PermissionManager.SplitPermissionInfo> permissionList =\n-                                    getSplitPermissionInfos();\n-                            int numSplitPerms = permissionList.size();\n-                            for (int splitPermNum = 0; splitPermNum < numSplitPerms;\n-                                    splitPermNum++) {\n-                                PermissionManager.SplitPermissionInfo sp = permissionList.get(\n-                                        splitPermNum);\n-                                String splitPermName = sp.getSplitPermission();\n-                                if (sp.getNewPermissions().contains(permName)\n-                                        && origState.isPermissionGranted(splitPermName)) {\n-                                    legacyActivityRecognitionPermission = splitPermName;\n-                                    newImplicitPermissions.add(permName);\n-\n-                                    if (DEBUG_PERMISSIONS) {\n-                                        Slog.i(TAG, permName + \" is newly added for \"\n-                                                + friendlyName);\n-                                    }\n-                                    break;\n-                                }\n-                            }\n-                        }\n                     }\n \n                     // TODO(b/140256621): The package instant app method has been removed\n@@ -2959,8 +2923,7 @@ public class PermissionManagerService extends IPermissionManager.Stub {\n                             // Hard restricted permissions cannot be held.\n                             } else if (!permissionPolicyInitialized\n                                     || (!hardRestricted || restrictionExempt)) {\n-                                if ((origPermState != null && origPermState.isGranted())\n-                                        || legacyActivityRecognitionPermission != null) {\n+                                if ((origPermState != null && origPermState.isGranted())) {\n                                     if (!uidState.grantPermission(bp)) {\n                                         wasChanged = true;\n                                     }\n",
    "added_lines": 2,
    "deleted_lines": 39,
    "changed_methods": "PermissionManagerService::restorePermissionState"
   }
  ]
 },
 {
  "hash": "e12b1a456b8736ecc10550562c413c33b5591f4b",
  "commit": "Check rule package name in ZenModeHelper.addAutomaticRule\n\ninstead of checking that of the configuration activity, which is potentially spoofable. The package name is verified to be the same app as the caller by NMS.\n\nThis change removes isSystemRule (called only once) in favor of checking the provided package name directly.\n\nBug: 242537431\nTest: ZenModeHelperTest, manual by verifying via provided exploit apk\nChange-Id: Ic7f350618c26a613df455a4128c9195f4b424a4d\n(cherry picked from commit 59732d6232d7d82d03897b25be0381c3c510db9b)\nMerged-In: Ic7f350618c26a613df455a4128c9195f4b424a4d",
  "files": [
   {
    "filename": "ZenModeHelper.java",
    "diff": "@@ -310,7 +310,7 @@ public class ZenModeHelper {\n \n     public String addAutomaticZenRule(String pkg, AutomaticZenRule automaticZenRule,\n             String reason) {\n-        if (!isSystemRule(automaticZenRule)) {\n+        if (!ZenModeConfig.SYSTEM_AUTHORITY.equals(pkg)) {\n             PackageItemInfo component = getServiceInfo(automaticZenRule.getOwner());\n             if (component == null) {\n                 component = getActivityInfo(automaticZenRule.getConfigurationActivity());\n@@ -566,11 +566,6 @@ public class ZenModeHelper {\n         }\n     }\n \n-    private boolean isSystemRule(AutomaticZenRule rule) {\n-        return rule.getOwner() != null\n-                && ZenModeConfig.SYSTEM_AUTHORITY.equals(rule.getOwner().getPackageName());\n-    }\n-\n     private ServiceInfo getServiceInfo(ComponentName owner) {\n         Intent queryIntent = new Intent();\n         queryIntent.setComponent(owner);\n",
    "added_lines": 1,
    "deleted_lines": 6,
    "changed_methods": "ZenModeHelper::isSystemRule, ZenModeHelper::addAutomaticZenRule"
   },
   {
    "filename": "ZenModeHelperTest.java",
    "diff": "@@ -1667,6 +1667,36 @@ public class ZenModeHelperTest extends UiServiceTestCase {\n         }\n     }\n \n+    @Test\n+    public void testAddAutomaticZenRule_claimedSystemOwner() {\n+        // Make sure anything that claims to have a \"system\" owner but not actually part of the\n+        // system package still gets limited on number of rules\n+        for (int i = 0; i < RULE_LIMIT_PER_PACKAGE; i++) {\n+            ScheduleInfo si = new ScheduleInfo();\n+            si.startHour = i;\n+            AutomaticZenRule zenRule = new AutomaticZenRule(\"name\" + i,\n+                    new ComponentName(\"android\", \"ScheduleConditionProvider\" + i),\n+                    null, // configuration activity\n+                    ZenModeConfig.toScheduleConditionId(si),\n+                    new ZenPolicy.Builder().build(),\n+                    NotificationManager.INTERRUPTION_FILTER_PRIORITY, true);\n+            String id = mZenModeHelperSpy.addAutomaticZenRule(\"pkgname\", zenRule, \"test\");\n+            assertNotNull(id);\n+        }\n+        try {\n+            AutomaticZenRule zenRule = new AutomaticZenRule(\"name\",\n+                    new ComponentName(\"android\", \"ScheduleConditionProviderFinal\"),\n+                    null, // configuration activity\n+                    ZenModeConfig.toScheduleConditionId(new ScheduleInfo()),\n+                    new ZenPolicy.Builder().build(),\n+                    NotificationManager.INTERRUPTION_FILTER_PRIORITY, true);\n+            String id = mZenModeHelperSpy.addAutomaticZenRule(\"pkgname\", zenRule, \"test\");\n+            fail(\"allowed too many rules to be created\");\n+        } catch (IllegalArgumentException e) {\n+            // yay\n+        }\n+    }\n+\n     @Test\n     public void testAddAutomaticZenRule_CA() {\n         AutomaticZenRule zenRule = new AutomaticZenRule(\"name\",\n",
    "added_lines": 30,
    "deleted_lines": 0,
    "changed_methods": "ZenModeHelperTest::testAddAutomaticZenRule_claimedSystemOwner"
   }
  ]
 },
 {
  "hash": "e12b1a456b8736ecc10550562c413c33b5591f4b",
  "commit": "Check rule package name in ZenModeHelper.addAutomaticRule\n\ninstead of checking that of the configuration activity, which is potentially spoofable. The package name is verified to be the same app as the caller by NMS.\n\nThis change removes isSystemRule (called only once) in favor of checking the provided package name directly.\n\nBug: 242537431\nTest: ZenModeHelperTest, manual by verifying via provided exploit apk\nChange-Id: Ic7f350618c26a613df455a4128c9195f4b424a4d\n(cherry picked from commit 59732d6232d7d82d03897b25be0381c3c510db9b)\nMerged-In: Ic7f350618c26a613df455a4128c9195f4b424a4d",
  "files": [
   {
    "filename": "ZenModeHelper.java",
    "diff": "@@ -310,7 +310,7 @@ public class ZenModeHelper {\n \n     public String addAutomaticZenRule(String pkg, AutomaticZenRule automaticZenRule,\n             String reason) {\n-        if (!isSystemRule(automaticZenRule)) {\n+        if (!ZenModeConfig.SYSTEM_AUTHORITY.equals(pkg)) {\n             PackageItemInfo component = getServiceInfo(automaticZenRule.getOwner());\n             if (component == null) {\n                 component = getActivityInfo(automaticZenRule.getConfigurationActivity());\n@@ -566,11 +566,6 @@ public class ZenModeHelper {\n         }\n     }\n \n-    private boolean isSystemRule(AutomaticZenRule rule) {\n-        return rule.getOwner() != null\n-                && ZenModeConfig.SYSTEM_AUTHORITY.equals(rule.getOwner().getPackageName());\n-    }\n-\n     private ServiceInfo getServiceInfo(ComponentName owner) {\n         Intent queryIntent = new Intent();\n         queryIntent.setComponent(owner);\n",
    "added_lines": 1,
    "deleted_lines": 6,
    "changed_methods": "ZenModeHelper::isSystemRule, ZenModeHelper::addAutomaticZenRule"
   },
   {
    "filename": "ZenModeHelperTest.java",
    "diff": "@@ -1667,6 +1667,36 @@ public class ZenModeHelperTest extends UiServiceTestCase {\n         }\n     }\n \n+    @Test\n+    public void testAddAutomaticZenRule_claimedSystemOwner() {\n+        // Make sure anything that claims to have a \"system\" owner but not actually part of the\n+        // system package still gets limited on number of rules\n+        for (int i = 0; i < RULE_LIMIT_PER_PACKAGE; i++) {\n+            ScheduleInfo si = new ScheduleInfo();\n+            si.startHour = i;\n+            AutomaticZenRule zenRule = new AutomaticZenRule(\"name\" + i,\n+                    new ComponentName(\"android\", \"ScheduleConditionProvider\" + i),\n+                    null, // configuration activity\n+                    ZenModeConfig.toScheduleConditionId(si),\n+                    new ZenPolicy.Builder().build(),\n+                    NotificationManager.INTERRUPTION_FILTER_PRIORITY, true);\n+            String id = mZenModeHelperSpy.addAutomaticZenRule(\"pkgname\", zenRule, \"test\");\n+            assertNotNull(id);\n+        }\n+        try {\n+            AutomaticZenRule zenRule = new AutomaticZenRule(\"name\",\n+                    new ComponentName(\"android\", \"ScheduleConditionProviderFinal\"),\n+                    null, // configuration activity\n+                    ZenModeConfig.toScheduleConditionId(new ScheduleInfo()),\n+                    new ZenPolicy.Builder().build(),\n+                    NotificationManager.INTERRUPTION_FILTER_PRIORITY, true);\n+            String id = mZenModeHelperSpy.addAutomaticZenRule(\"pkgname\", zenRule, \"test\");\n+            fail(\"allowed too many rules to be created\");\n+        } catch (IllegalArgumentException e) {\n+            // yay\n+        }\n+    }\n+\n     @Test\n     public void testAddAutomaticZenRule_CA() {\n         AutomaticZenRule zenRule = new AutomaticZenRule(\"name\",\n",
    "added_lines": 30,
    "deleted_lines": 0,
    "changed_methods": "ZenModeHelperTest::testAddAutomaticZenRule_claimedSystemOwner"
   }
  ]
 },
 {
  "hash": "6011fb5153c26340a71c28bd1f97270f46b25de2",
  "commit": "Trim any long string inputs that come in to AutomaticZenRule\n\nThis change both prevents any rules from being unable to be written to disk and also avoids risk of running out of memory while handling all the zen rules.\n\nBug: 242703460\nBug: 242703505\nBug: 242703780\nBug: 242704043\nBug: 243794204\nTest: cts AutomaticZenRuleTest; atest android.app.AutomaticZenRuleTest; manually confirmed each exploit example either saves the rule successfully with a truncated string (in the case of name & conditionId) or may fail to save the rule at all (if the owner/configactivity is invalid). Additionally ran the memory-exhausting PoC without device crashes.\n\nChange-Id: I110172a43f28528dd274b3b346eb29c3796ff2c6\nMerged-In: I110172a43f28528dd274b3b346eb29c3796ff2c6\n(cherry picked from commit de172ba0d434c940be9e2aad8685719731ab7da2)\n(cherry picked from commit 19bc2c3559620ed00e448117e65f6b44e6eb6d9b)\nMerged-In: I110172a43f28528dd274b3b346eb29c3796ff2c6",
  "files": [
   {
    "filename": "AutomaticZenRule.java",
    "diff": "@@ -47,6 +47,13 @@ public final class AutomaticZenRule implements Parcelable {\n     private boolean mModified = false;\n     private String mPkg;\n \n+    /**\n+     * The maximum string length for any string contained in this automatic zen rule. This pertains\n+     * both to fields in the rule itself (such as its name) and items with sub-fields.\n+     * @hide\n+     */\n+    public static final int MAX_STRING_LENGTH = 1000;\n+\n     /**\n      * Creates an automatic zen rule.\n      *\n@@ -93,10 +100,10 @@ public final class AutomaticZenRule implements Parcelable {\n     public AutomaticZenRule(@NonNull String name, @Nullable ComponentName owner,\n             @Nullable ComponentName configurationActivity, @NonNull Uri conditionId,\n             @Nullable ZenPolicy policy, int interruptionFilter, boolean enabled) {\n-        this.name = name;\n-        this.owner = owner;\n-        this.configurationActivity = configurationActivity;\n-        this.conditionId = conditionId;\n+        this.name = getTrimmedString(name);\n+        this.owner = getTrimmedComponentName(owner);\n+        this.configurationActivity = getTrimmedComponentName(configurationActivity);\n+        this.conditionId = getTrimmedUri(conditionId);\n         this.interruptionFilter = interruptionFilter;\n         this.enabled = enabled;\n         this.mZenPolicy = policy;\n@@ -115,12 +122,12 @@ public final class AutomaticZenRule implements Parcelable {\n     public AutomaticZenRule(Parcel source) {\n         enabled = source.readInt() == ENABLED;\n         if (source.readInt() == ENABLED) {\n-            name = source.readString();\n+            name = getTrimmedString(source.readString());\n         }\n         interruptionFilter = source.readInt();\n         conditionId = source.readParcelable(null);\n-        owner = source.readParcelable(null);\n-        configurationActivity = source.readParcelable(null);\n+        owner = getTrimmedComponentName(source.readParcelable(null));\n+        configurationActivity = getTrimmedComponentName(source.readParcelable(null));\n         creationTime = source.readLong();\n         mZenPolicy = source.readParcelable(null);\n         mModified = source.readInt() == ENABLED;\n@@ -196,7 +203,7 @@ public final class AutomaticZenRule implements Parcelable {\n      * Sets the representation of the state that causes this rule to become active.\n      */\n     public void setConditionId(Uri conditionId) {\n-        this.conditionId = conditionId;\n+        this.conditionId = getTrimmedUri(conditionId);\n     }\n \n     /**\n@@ -211,7 +218,7 @@ public final class AutomaticZenRule implements Parcelable {\n      * Sets the name of this rule.\n      */\n     public void setName(String name) {\n-        this.name = name;\n+        this.name = getTrimmedString(name);\n     }\n \n     /**\n@@ -243,7 +250,7 @@ public final class AutomaticZenRule implements Parcelable {\n      * that are not backed by {@link android.service.notification.ConditionProviderService}.\n      */\n     public void setConfigurationActivity(@Nullable ComponentName componentName) {\n-        this.configurationActivity = componentName;\n+        this.configurationActivity = getTrimmedComponentName(componentName);\n     }\n \n     /**\n@@ -333,4 +340,35 @@ public final class AutomaticZenRule implements Parcelable {\n             return new AutomaticZenRule[size];\n         }\n     };\n+\n+    /**\n+     * If the package or class name of the provided ComponentName are longer than MAX_STRING_LENGTH,\n+     * return a trimmed version that truncates each of the package and class name at the max length.\n+     */\n+    private static ComponentName getTrimmedComponentName(ComponentName cn) {\n+        if (cn == null) return null;\n+        return new ComponentName(getTrimmedString(cn.getPackageName()),\n+                getTrimmedString(cn.getClassName()));\n+    }\n+\n+    /**\n+     * Returns a truncated copy of the string if the string is longer than MAX_STRING_LENGTH.\n+     */\n+    private static String getTrimmedString(String input) {\n+        if (input != null && input.length() > MAX_STRING_LENGTH) {\n+            return input.substring(0, MAX_STRING_LENGTH);\n+        }\n+        return input;\n+    }\n+\n+    /**\n+     * Returns a truncated copy of the Uri by trimming the string representation to the maximum\n+     * string length.\n+     */\n+    private static Uri getTrimmedUri(Uri input) {\n+        if (input != null && input.toString().length() > MAX_STRING_LENGTH) {\n+            return Uri.parse(getTrimmedString(input.toString()));\n+        }\n+        return input;\n+    }\n }\n",
    "added_lines": 48,
    "deleted_lines": 10,
    "changed_methods": "AutomaticZenRule::getTrimmedComponentName, AutomaticZenRule::setConfigurationActivity, AutomaticZenRule::getTrimmedString, AutomaticZenRule::getTrimmedUri, AutomaticZenRule::setName, AutomaticZenRule::AutomaticZenRule, AutomaticZenRule::AutomaticZenRule, AutomaticZenRule::setConditionId"
   },
   {
    "filename": "AutomaticZenRuleTest.java",
    "diff": "@@ -0,0 +1,153 @@\n+/*\n+ * Copyright (C) 2022 The Android Open Source Project\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package android.app;\n+\n+import static junit.framework.Assert.assertEquals;\n+import static junit.framework.Assert.fail;\n+\n+import android.content.ComponentName;\n+import android.net.Uri;\n+import android.os.Parcel;\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4;\n+import androidx.test.filters.SmallTest;\n+\n+import com.google.common.base.Strings;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import java.lang.reflect.Field;\n+\n+@RunWith(AndroidJUnit4.class)\n+@SmallTest\n+public class AutomaticZenRuleTest {\n+    private static final String CLASS = \"android.app.AutomaticZenRule\";\n+\n+    @Test\n+    public void testLongFields_inConstructor() {\n+        String longString = Strings.repeat(\"A\", 65536);\n+        Uri longUri = Uri.parse(\"uri://\" + Strings.repeat(\"A\", 65530));\n+\n+        // test both variants where there's an owner, and where there's a configuration activity\n+        AutomaticZenRule rule1 = new AutomaticZenRule(\n+                longString, // name\n+                new ComponentName(\"pkg\", longString), // owner\n+                null,  // configuration activity\n+                longUri, // conditionId\n+                null, // zen policy\n+                0, // interruption filter\n+                true); // enabled\n+\n+        assertEquals(AutomaticZenRule.MAX_STRING_LENGTH, rule1.getName().length());\n+        assertEquals(AutomaticZenRule.MAX_STRING_LENGTH,\n+                rule1.getConditionId().toString().length());\n+        assertEquals(AutomaticZenRule.MAX_STRING_LENGTH, rule1.getOwner().getClassName().length());\n+\n+        AutomaticZenRule rule2 = new AutomaticZenRule(\n+                longString, // name\n+                null, // owner\n+                new ComponentName(longString, \"SomeClassName\"), // configuration activity\n+                longUri, // conditionId\n+                null, // zen policy\n+                0, // interruption filter\n+                false); // enabled\n+\n+        assertEquals(AutomaticZenRule.MAX_STRING_LENGTH, rule2.getName().length());\n+        assertEquals(AutomaticZenRule.MAX_STRING_LENGTH,\n+                rule2.getConditionId().toString().length());\n+        assertEquals(AutomaticZenRule.MAX_STRING_LENGTH,\n+                rule2.getConfigurationActivity().getPackageName().length());\n+    }\n+\n+    @Test\n+    public void testLongFields_inSetters() {\n+        String longString = Strings.repeat(\"A\", 65536);\n+        Uri longUri = Uri.parse(\"uri://\" + Strings.repeat(\"A\", 65530));\n+\n+        AutomaticZenRule rule = new AutomaticZenRule(\n+                \"sensible name\",\n+                new ComponentName(\"pkg\", \"ShortClass\"),\n+                null,\n+                Uri.parse(\"uri://short\"),\n+                null, 0, true);\n+\n+        rule.setName(longString);\n+        rule.setConditionId(longUri);\n+        rule.setConfigurationActivity(new ComponentName(longString, longString));\n+\n+        assertEquals(AutomaticZenRule.MAX_STRING_LENGTH, rule.getName().length());\n+        assertEquals(AutomaticZenRule.MAX_STRING_LENGTH,\n+                rule.getConditionId().toString().length());\n+        assertEquals(AutomaticZenRule.MAX_STRING_LENGTH,\n+                rule.getConfigurationActivity().getPackageName().length());\n+        assertEquals(AutomaticZenRule.MAX_STRING_LENGTH,\n+                rule.getConfigurationActivity().getClassName().length());\n+    }\n+\n+    @Test\n+    public void testLongInputsFromParcel() {\n+        // Create a rule with long fields, set directly via reflection so that we can confirm that\n+        // a rule with too-long fields that comes in via a parcel has its fields truncated directly.\n+        AutomaticZenRule rule = new AutomaticZenRule(\n+                \"placeholder\",\n+                new ComponentName(\"place\", \"holder\"),\n+                null,\n+                Uri.parse(\"uri://placeholder\"),\n+                null, 0, true);\n+\n+        try {\n+            String longString = Strings.repeat(\"A\", 65536);\n+            Uri longUri = Uri.parse(\"uri://\" + Strings.repeat(\"A\", 65530));\n+            Field name = Class.forName(CLASS).getDeclaredField(\"name\");\n+            name.setAccessible(true);\n+            name.set(rule, longString);\n+            Field conditionId = Class.forName(CLASS).getDeclaredField(\"conditionId\");\n+            conditionId.setAccessible(true);\n+            conditionId.set(rule, longUri);\n+            Field owner = Class.forName(CLASS).getDeclaredField(\"owner\");\n+            owner.setAccessible(true);\n+            owner.set(rule, new ComponentName(longString, longString));\n+            Field configActivity = Class.forName(CLASS).getDeclaredField(\"configurationActivity\");\n+            configActivity.setAccessible(true);\n+            configActivity.set(rule, new ComponentName(longString, longString));\n+        } catch (NoSuchFieldException e) {\n+            fail(e.toString());\n+        } catch (ClassNotFoundException e) {\n+            fail(e.toString());\n+        } catch (IllegalAccessException e) {\n+            fail(e.toString());\n+        }\n+\n+        Parcel parcel = Parcel.obtain();\n+        rule.writeToParcel(parcel, 0);\n+        parcel.setDataPosition(0);\n+\n+        AutomaticZenRule fromParcel = new AutomaticZenRule(parcel);\n+        assertEquals(AutomaticZenRule.MAX_STRING_LENGTH, fromParcel.getName().length());\n+        assertEquals(AutomaticZenRule.MAX_STRING_LENGTH,\n+                fromParcel.getConditionId().toString().length());\n+        assertEquals(AutomaticZenRule.MAX_STRING_LENGTH,\n+                fromParcel.getConfigurationActivity().getPackageName().length());\n+        assertEquals(AutomaticZenRule.MAX_STRING_LENGTH,\n+                fromParcel.getConfigurationActivity().getClassName().length());\n+        assertEquals(AutomaticZenRule.MAX_STRING_LENGTH,\n+                fromParcel.getOwner().getPackageName().length());\n+        assertEquals(AutomaticZenRule.MAX_STRING_LENGTH,\n+                fromParcel.getOwner().getClassName().length());\n+    }\n+}\n",
    "added_lines": 153,
    "deleted_lines": 0,
    "changed_methods": "AutomaticZenRuleTest::testLongFields_inConstructor, AutomaticZenRuleTest::testLongInputsFromParcel, AutomaticZenRuleTest::testLongFields_inSetters"
   }
  ]
 },
 {
  "hash": "6011fb5153c26340a71c28bd1f97270f46b25de2",
  "commit": "Trim any long string inputs that come in to AutomaticZenRule\n\nThis change both prevents any rules from being unable to be written to disk and also avoids risk of running out of memory while handling all the zen rules.\n\nBug: 242703460\nBug: 242703505\nBug: 242703780\nBug: 242704043\nBug: 243794204\nTest: cts AutomaticZenRuleTest; atest android.app.AutomaticZenRuleTest; manually confirmed each exploit example either saves the rule successfully with a truncated string (in the case of name & conditionId) or may fail to save the rule at all (if the owner/configactivity is invalid). Additionally ran the memory-exhausting PoC without device crashes.\n\nChange-Id: I110172a43f28528dd274b3b346eb29c3796ff2c6\nMerged-In: I110172a43f28528dd274b3b346eb29c3796ff2c6\n(cherry picked from commit de172ba0d434c940be9e2aad8685719731ab7da2)\n(cherry picked from commit 19bc2c3559620ed00e448117e65f6b44e6eb6d9b)\nMerged-In: I110172a43f28528dd274b3b346eb29c3796ff2c6",
  "files": [
   {
    "filename": "AutomaticZenRule.java",
    "diff": "@@ -47,6 +47,13 @@ public final class AutomaticZenRule implements Parcelable {\n     private boolean mModified = false;\n     private String mPkg;\n \n+    /**\n+     * The maximum string length for any string contained in this automatic zen rule. This pertains\n+     * both to fields in the rule itself (such as its name) and items with sub-fields.\n+     * @hide\n+     */\n+    public static final int MAX_STRING_LENGTH = 1000;\n+\n     /**\n      * Creates an automatic zen rule.\n      *\n@@ -93,10 +100,10 @@ public final class AutomaticZenRule implements Parcelable {\n     public AutomaticZenRule(@NonNull String name, @Nullable ComponentName owner,\n             @Nullable ComponentName configurationActivity, @NonNull Uri conditionId,\n             @Nullable ZenPolicy policy, int interruptionFilter, boolean enabled) {\n-        this.name = name;\n-        this.owner = owner;\n-        this.configurationActivity = configurationActivity;\n-        this.conditionId = conditionId;\n+        this.name = getTrimmedString(name);\n+        this.owner = getTrimmedComponentName(owner);\n+        this.configurationActivity = getTrimmedComponentName(configurationActivity);\n+        this.conditionId = getTrimmedUri(conditionId);\n         this.interruptionFilter = interruptionFilter;\n         this.enabled = enabled;\n         this.mZenPolicy = policy;\n@@ -115,12 +122,12 @@ public final class AutomaticZenRule implements Parcelable {\n     public AutomaticZenRule(Parcel source) {\n         enabled = source.readInt() == ENABLED;\n         if (source.readInt() == ENABLED) {\n-            name = source.readString();\n+            name = getTrimmedString(source.readString());\n         }\n         interruptionFilter = source.readInt();\n         conditionId = source.readParcelable(null);\n-        owner = source.readParcelable(null);\n-        configurationActivity = source.readParcelable(null);\n+        owner = getTrimmedComponentName(source.readParcelable(null));\n+        configurationActivity = getTrimmedComponentName(source.readParcelable(null));\n         creationTime = source.readLong();\n         mZenPolicy = source.readParcelable(null);\n         mModified = source.readInt() == ENABLED;\n@@ -196,7 +203,7 @@ public final class AutomaticZenRule implements Parcelable {\n      * Sets the representation of the state that causes this rule to become active.\n      */\n     public void setConditionId(Uri conditionId) {\n-        this.conditionId = conditionId;\n+        this.conditionId = getTrimmedUri(conditionId);\n     }\n \n     /**\n@@ -211,7 +218,7 @@ public final class AutomaticZenRule implements Parcelable {\n      * Sets the name of this rule.\n      */\n     public void setName(String name) {\n-        this.name = name;\n+        this.name = getTrimmedString(name);\n     }\n \n     /**\n@@ -243,7 +250,7 @@ public final class AutomaticZenRule implements Parcelable {\n      * that are not backed by {@link android.service.notification.ConditionProviderService}.\n      */\n     public void setConfigurationActivity(@Nullable ComponentName componentName) {\n-        this.configurationActivity = componentName;\n+        this.configurationActivity = getTrimmedComponentName(componentName);\n     }\n \n     /**\n@@ -333,4 +340,35 @@ public final class AutomaticZenRule implements Parcelable {\n             return new AutomaticZenRule[size];\n         }\n     };\n+\n+    /**\n+     * If the package or class name of the provided ComponentName are longer than MAX_STRING_LENGTH,\n+     * return a trimmed version that truncates each of the package and class name at the max length.\n+     */\n+    private static ComponentName getTrimmedComponentName(ComponentName cn) {\n+        if (cn == null) return null;\n+        return new ComponentName(getTrimmedString(cn.getPackageName()),\n+                getTrimmedString(cn.getClassName()));\n+    }\n+\n+    /**\n+     * Returns a truncated copy of the string if the string is longer than MAX_STRING_LENGTH.\n+     */\n+    private static String getTrimmedString(String input) {\n+        if (input != null && input.length() > MAX_STRING_LENGTH) {\n+            return input.substring(0, MAX_STRING_LENGTH);\n+        }\n+        return input;\n+    }\n+\n+    /**\n+     * Returns a truncated copy of the Uri by trimming the string representation to the maximum\n+     * string length.\n+     */\n+    private static Uri getTrimmedUri(Uri input) {\n+        if (input != null && input.toString().length() > MAX_STRING_LENGTH) {\n+            return Uri.parse(getTrimmedString(input.toString()));\n+        }\n+        return input;\n+    }\n }\n",
    "added_lines": 48,
    "deleted_lines": 10,
    "changed_methods": "AutomaticZenRule::getTrimmedComponentName, AutomaticZenRule::setConfigurationActivity, AutomaticZenRule::getTrimmedString, AutomaticZenRule::getTrimmedUri, AutomaticZenRule::setName, AutomaticZenRule::AutomaticZenRule, AutomaticZenRule::AutomaticZenRule, AutomaticZenRule::setConditionId"
   },
   {
    "filename": "AutomaticZenRuleTest.java",
    "diff": "@@ -0,0 +1,153 @@\n+/*\n+ * Copyright (C) 2022 The Android Open Source Project\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package android.app;\n+\n+import static junit.framework.Assert.assertEquals;\n+import static junit.framework.Assert.fail;\n+\n+import android.content.ComponentName;\n+import android.net.Uri;\n+import android.os.Parcel;\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4;\n+import androidx.test.filters.SmallTest;\n+\n+import com.google.common.base.Strings;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import java.lang.reflect.Field;\n+\n+@RunWith(AndroidJUnit4.class)\n+@SmallTest\n+public class AutomaticZenRuleTest {\n+    private static final String CLASS = \"android.app.AutomaticZenRule\";\n+\n+    @Test\n+    public void testLongFields_inConstructor() {\n+        String longString = Strings.repeat(\"A\", 65536);\n+        Uri longUri = Uri.parse(\"uri://\" + Strings.repeat(\"A\", 65530));\n+\n+        // test both variants where there's an owner, and where there's a configuration activity\n+        AutomaticZenRule rule1 = new AutomaticZenRule(\n+                longString, // name\n+                new ComponentName(\"pkg\", longString), // owner\n+                null,  // configuration activity\n+                longUri, // conditionId\n+                null, // zen policy\n+                0, // interruption filter\n+                true); // enabled\n+\n+        assertEquals(AutomaticZenRule.MAX_STRING_LENGTH, rule1.getName().length());\n+        assertEquals(AutomaticZenRule.MAX_STRING_LENGTH,\n+                rule1.getConditionId().toString().length());\n+        assertEquals(AutomaticZenRule.MAX_STRING_LENGTH, rule1.getOwner().getClassName().length());\n+\n+        AutomaticZenRule rule2 = new AutomaticZenRule(\n+                longString, // name\n+                null, // owner\n+                new ComponentName(longString, \"SomeClassName\"), // configuration activity\n+                longUri, // conditionId\n+                null, // zen policy\n+                0, // interruption filter\n+                false); // enabled\n+\n+        assertEquals(AutomaticZenRule.MAX_STRING_LENGTH, rule2.getName().length());\n+        assertEquals(AutomaticZenRule.MAX_STRING_LENGTH,\n+                rule2.getConditionId().toString().length());\n+        assertEquals(AutomaticZenRule.MAX_STRING_LENGTH,\n+                rule2.getConfigurationActivity().getPackageName().length());\n+    }\n+\n+    @Test\n+    public void testLongFields_inSetters() {\n+        String longString = Strings.repeat(\"A\", 65536);\n+        Uri longUri = Uri.parse(\"uri://\" + Strings.repeat(\"A\", 65530));\n+\n+        AutomaticZenRule rule = new AutomaticZenRule(\n+                \"sensible name\",\n+                new ComponentName(\"pkg\", \"ShortClass\"),\n+                null,\n+                Uri.parse(\"uri://short\"),\n+                null, 0, true);\n+\n+        rule.setName(longString);\n+        rule.setConditionId(longUri);\n+        rule.setConfigurationActivity(new ComponentName(longString, longString));\n+\n+        assertEquals(AutomaticZenRule.MAX_STRING_LENGTH, rule.getName().length());\n+        assertEquals(AutomaticZenRule.MAX_STRING_LENGTH,\n+                rule.getConditionId().toString().length());\n+        assertEquals(AutomaticZenRule.MAX_STRING_LENGTH,\n+                rule.getConfigurationActivity().getPackageName().length());\n+        assertEquals(AutomaticZenRule.MAX_STRING_LENGTH,\n+                rule.getConfigurationActivity().getClassName().length());\n+    }\n+\n+    @Test\n+    public void testLongInputsFromParcel() {\n+        // Create a rule with long fields, set directly via reflection so that we can confirm that\n+        // a rule with too-long fields that comes in via a parcel has its fields truncated directly.\n+        AutomaticZenRule rule = new AutomaticZenRule(\n+                \"placeholder\",\n+                new ComponentName(\"place\", \"holder\"),\n+                null,\n+                Uri.parse(\"uri://placeholder\"),\n+                null, 0, true);\n+\n+        try {\n+            String longString = Strings.repeat(\"A\", 65536);\n+            Uri longUri = Uri.parse(\"uri://\" + Strings.repeat(\"A\", 65530));\n+            Field name = Class.forName(CLASS).getDeclaredField(\"name\");\n+            name.setAccessible(true);\n+            name.set(rule, longString);\n+            Field conditionId = Class.forName(CLASS).getDeclaredField(\"conditionId\");\n+            conditionId.setAccessible(true);\n+            conditionId.set(rule, longUri);\n+            Field owner = Class.forName(CLASS).getDeclaredField(\"owner\");\n+            owner.setAccessible(true);\n+            owner.set(rule, new ComponentName(longString, longString));\n+            Field configActivity = Class.forName(CLASS).getDeclaredField(\"configurationActivity\");\n+            configActivity.setAccessible(true);\n+            configActivity.set(rule, new ComponentName(longString, longString));\n+        } catch (NoSuchFieldException e) {\n+            fail(e.toString());\n+        } catch (ClassNotFoundException e) {\n+            fail(e.toString());\n+        } catch (IllegalAccessException e) {\n+            fail(e.toString());\n+        }\n+\n+        Parcel parcel = Parcel.obtain();\n+        rule.writeToParcel(parcel, 0);\n+        parcel.setDataPosition(0);\n+\n+        AutomaticZenRule fromParcel = new AutomaticZenRule(parcel);\n+        assertEquals(AutomaticZenRule.MAX_STRING_LENGTH, fromParcel.getName().length());\n+        assertEquals(AutomaticZenRule.MAX_STRING_LENGTH,\n+                fromParcel.getConditionId().toString().length());\n+        assertEquals(AutomaticZenRule.MAX_STRING_LENGTH,\n+                fromParcel.getConfigurationActivity().getPackageName().length());\n+        assertEquals(AutomaticZenRule.MAX_STRING_LENGTH,\n+                fromParcel.getConfigurationActivity().getClassName().length());\n+        assertEquals(AutomaticZenRule.MAX_STRING_LENGTH,\n+                fromParcel.getOwner().getPackageName().length());\n+        assertEquals(AutomaticZenRule.MAX_STRING_LENGTH,\n+                fromParcel.getOwner().getClassName().length());\n+    }\n+}\n",
    "added_lines": 153,
    "deleted_lines": 0,
    "changed_methods": "AutomaticZenRuleTest::testLongFields_inConstructor, AutomaticZenRuleTest::testLongInputsFromParcel, AutomaticZenRuleTest::testLongFields_inSetters"
   }
  ]
 },
 {
  "hash": "7fcd9a37fa797b2f0d6c5fabfb9d1b0e52009ab7",
  "commit": "Fix system zen rules by using owner package name if caller is system\n\nPreviously were unable to add new zen rules because rules added via the settings pages were getting registered under package \"com.android.settings\", which then were not considered \"system rules\". These rules should have package android, so when we can trust the caller (via checking that the caller is system) we should be taking the package name from the owner of the rule.\n\nBug: 245236706\nBug: 242537431\nTest: NMSTest; manual\n\nChange-Id: Id69b671592396ac3304862dadbe73de328a8e27a\nMerged-In: Id69b671592396ac3304862dadbe73de328a8e27a\n(cherry picked from commit 78245566a27882cce59c0d7cd4c60e1604392a3f)\nMerged-In: Id69b671592396ac3304862dadbe73de328a8e27a",
  "files": [
   {
    "filename": "NotificationManagerService.java",
    "diff": "@@ -4812,7 +4812,16 @@ public class NotificationManagerService extends SystemService {\n             }\n             enforcePolicyAccess(Binder.getCallingUid(), \"addAutomaticZenRule\");\n \n-            return mZenModeHelper.addAutomaticZenRule(pkg, automaticZenRule,\n+            // If the caller is system, take the package name from the rule's owner rather than\n+            // from the caller's package.\n+            String rulePkg = pkg;\n+            if (isCallingUidSystem()) {\n+                if (automaticZenRule.getOwner() != null) {\n+                    rulePkg = automaticZenRule.getOwner().getPackageName();\n+                }\n+            }\n+\n+            return mZenModeHelper.addAutomaticZenRule(rulePkg, automaticZenRule,\n                     \"addAutomaticZenRule\");\n         }\n \n",
    "added_lines": 10,
    "deleted_lines": 1,
    "changed_methods": "NotificationManagerService::Stub"
   },
   {
    "filename": "NotificationManagerServiceTest.java",
    "diff": "@@ -6683,6 +6683,43 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n         mBinderService.addAutomaticZenRule(rule, mContext.getPackageName());\n     }\n \n+    @Test\n+    public void testAddAutomaticZenRule_systemCallTakesPackageFromOwner() throws Exception {\n+        mService.isSystemUid = true;\n+        ZenModeHelper mockZenModeHelper = mock(ZenModeHelper.class);\n+        when(mConditionProviders.isPackageOrComponentAllowed(anyString(), anyInt()))\n+                .thenReturn(true);\n+        mService.setZenHelper(mockZenModeHelper);\n+        ComponentName owner = new ComponentName(\"android\", \"ProviderName\");\n+        ZenPolicy zenPolicy = new ZenPolicy.Builder().allowAlarms(true).build();\n+        boolean isEnabled = true;\n+        AutomaticZenRule rule = new AutomaticZenRule(\"test\", owner, owner, mock(Uri.class),\n+                zenPolicy, NotificationManager.INTERRUPTION_FILTER_PRIORITY, isEnabled);\n+        mBinderService.addAutomaticZenRule(rule, \"com.android.settings\");\n+\n+        // verify that zen mode helper gets passed in a package name of \"android\"\n+        verify(mockZenModeHelper).addAutomaticZenRule(eq(\"android\"), eq(rule), anyString());\n+    }\n+\n+    @Test\n+    public void testAddAutomaticZenRule_nonSystemCallTakesPackageFromArg() throws Exception {\n+        mService.isSystemUid = false;\n+        ZenModeHelper mockZenModeHelper = mock(ZenModeHelper.class);\n+        when(mConditionProviders.isPackageOrComponentAllowed(anyString(), anyInt()))\n+                .thenReturn(true);\n+        mService.setZenHelper(mockZenModeHelper);\n+        ComponentName owner = new ComponentName(\"android\", \"ProviderName\");\n+        ZenPolicy zenPolicy = new ZenPolicy.Builder().allowAlarms(true).build();\n+        boolean isEnabled = true;\n+        AutomaticZenRule rule = new AutomaticZenRule(\"test\", owner, owner, mock(Uri.class),\n+                zenPolicy, NotificationManager.INTERRUPTION_FILTER_PRIORITY, isEnabled);\n+        mBinderService.addAutomaticZenRule(rule, \"another.package\");\n+\n+        // verify that zen mode helper gets passed in the package name from the arg, not the owner\n+        verify(mockZenModeHelper).addAutomaticZenRule(\n+                eq(\"another.package\"), eq(rule), anyString());\n+    }\n+\n     @Test\n     public void testAreNotificationsEnabledForPackage_crossUser() throws Exception {\n         try {\n",
    "added_lines": 37,
    "deleted_lines": 0,
    "changed_methods": "NotificationManagerServiceTest::testAddAutomaticZenRule_nonSystemCallTakesPackageFromArg, NotificationManagerServiceTest::testAddAutomaticZenRule_systemCallTakesPackageFromOwner"
   }
  ]
 },
 {
  "hash": "7fcd9a37fa797b2f0d6c5fabfb9d1b0e52009ab7",
  "commit": "Fix system zen rules by using owner package name if caller is system\n\nPreviously were unable to add new zen rules because rules added via the settings pages were getting registered under package \"com.android.settings\", which then were not considered \"system rules\". These rules should have package android, so when we can trust the caller (via checking that the caller is system) we should be taking the package name from the owner of the rule.\n\nBug: 245236706\nBug: 242537431\nTest: NMSTest; manual\n\nChange-Id: Id69b671592396ac3304862dadbe73de328a8e27a\nMerged-In: Id69b671592396ac3304862dadbe73de328a8e27a\n(cherry picked from commit 78245566a27882cce59c0d7cd4c60e1604392a3f)\nMerged-In: Id69b671592396ac3304862dadbe73de328a8e27a",
  "files": [
   {
    "filename": "NotificationManagerService.java",
    "diff": "@@ -4812,7 +4812,16 @@ public class NotificationManagerService extends SystemService {\n             }\n             enforcePolicyAccess(Binder.getCallingUid(), \"addAutomaticZenRule\");\n \n-            return mZenModeHelper.addAutomaticZenRule(pkg, automaticZenRule,\n+            // If the caller is system, take the package name from the rule's owner rather than\n+            // from the caller's package.\n+            String rulePkg = pkg;\n+            if (isCallingUidSystem()) {\n+                if (automaticZenRule.getOwner() != null) {\n+                    rulePkg = automaticZenRule.getOwner().getPackageName();\n+                }\n+            }\n+\n+            return mZenModeHelper.addAutomaticZenRule(rulePkg, automaticZenRule,\n                     \"addAutomaticZenRule\");\n         }\n \n",
    "added_lines": 10,
    "deleted_lines": 1,
    "changed_methods": "NotificationManagerService::Stub"
   },
   {
    "filename": "NotificationManagerServiceTest.java",
    "diff": "@@ -6683,6 +6683,43 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n         mBinderService.addAutomaticZenRule(rule, mContext.getPackageName());\n     }\n \n+    @Test\n+    public void testAddAutomaticZenRule_systemCallTakesPackageFromOwner() throws Exception {\n+        mService.isSystemUid = true;\n+        ZenModeHelper mockZenModeHelper = mock(ZenModeHelper.class);\n+        when(mConditionProviders.isPackageOrComponentAllowed(anyString(), anyInt()))\n+                .thenReturn(true);\n+        mService.setZenHelper(mockZenModeHelper);\n+        ComponentName owner = new ComponentName(\"android\", \"ProviderName\");\n+        ZenPolicy zenPolicy = new ZenPolicy.Builder().allowAlarms(true).build();\n+        boolean isEnabled = true;\n+        AutomaticZenRule rule = new AutomaticZenRule(\"test\", owner, owner, mock(Uri.class),\n+                zenPolicy, NotificationManager.INTERRUPTION_FILTER_PRIORITY, isEnabled);\n+        mBinderService.addAutomaticZenRule(rule, \"com.android.settings\");\n+\n+        // verify that zen mode helper gets passed in a package name of \"android\"\n+        verify(mockZenModeHelper).addAutomaticZenRule(eq(\"android\"), eq(rule), anyString());\n+    }\n+\n+    @Test\n+    public void testAddAutomaticZenRule_nonSystemCallTakesPackageFromArg() throws Exception {\n+        mService.isSystemUid = false;\n+        ZenModeHelper mockZenModeHelper = mock(ZenModeHelper.class);\n+        when(mConditionProviders.isPackageOrComponentAllowed(anyString(), anyInt()))\n+                .thenReturn(true);\n+        mService.setZenHelper(mockZenModeHelper);\n+        ComponentName owner = new ComponentName(\"android\", \"ProviderName\");\n+        ZenPolicy zenPolicy = new ZenPolicy.Builder().allowAlarms(true).build();\n+        boolean isEnabled = true;\n+        AutomaticZenRule rule = new AutomaticZenRule(\"test\", owner, owner, mock(Uri.class),\n+                zenPolicy, NotificationManager.INTERRUPTION_FILTER_PRIORITY, isEnabled);\n+        mBinderService.addAutomaticZenRule(rule, \"another.package\");\n+\n+        // verify that zen mode helper gets passed in the package name from the arg, not the owner\n+        verify(mockZenModeHelper).addAutomaticZenRule(\n+                eq(\"another.package\"), eq(rule), anyString());\n+    }\n+\n     @Test\n     public void testAreNotificationsEnabledForPackage_crossUser() throws Exception {\n         try {\n",
    "added_lines": 37,
    "deleted_lines": 0,
    "changed_methods": "NotificationManagerServiceTest::testAddAutomaticZenRule_nonSystemCallTakesPackageFromArg, NotificationManagerServiceTest::testAddAutomaticZenRule_systemCallTakesPackageFromOwner"
   }
  ]
 },
 {
  "hash": "f3bb6da05eeb2280356c87c87fbf7a41601dd66b",
  "commit": "Make sure parallel broadcasts enforce excluded permissions\n\nBug: 211029161\nBug: 210118427\nTest: atest android.content.cts.ContextWrapperTest#testSendBroadcastRequireNoneOfPermissions_receiverHasExcludedPermissions\nMerged-In: Ib4fafe2423c7ded1daf1b763f8103601c0e2c852\nChange-Id: Ib4fafe2423c7ded1daf1b763f8103601c0e2c852\n(cherry picked from commit 0eee4fa476212a35cecee499cfbbfe2d35580bb2)\nMerged-In: Ib4fafe2423c7ded1daf1b763f8103601c0e2c852",
  "files": [
   {
    "filename": "BroadcastQueue.java",
    "diff": "@@ -768,6 +768,54 @@ public final class BroadcastQueue {\n             }\n         }\n \n+        // Check that the receiver does *not* have any excluded permissions\n+        if (!skip && r.excludedPermissions != null && r.excludedPermissions.length > 0) {\n+            for (int i = 0; i < r.excludedPermissions.length; i++) {\n+                String excludedPermission = r.excludedPermissions[i];\n+                final int perm = mService.checkComponentPermission(excludedPermission,\n+                        filter.receiverList.pid, filter.receiverList.uid, -1, true);\n+\n+                int appOp = AppOpsManager.permissionToOpCode(excludedPermission);\n+                if (appOp != AppOpsManager.OP_NONE) {\n+                    // When there is an app op associated with the permission,\n+                    // skip when both the permission and the app op are\n+                    // granted.\n+                    if ((perm == PackageManager.PERMISSION_GRANTED) && (\n+                            mService.getAppOpsManager().checkOpNoThrow(appOp,\n+                                    filter.receiverList.uid,\n+                                    filter.packageName)\n+                                    == AppOpsManager.MODE_ALLOWED)) {\n+                        Slog.w(TAG, \"Appop Denial: receiving \"\n+                                + r.intent.toString()\n+                                + \" to \" + filter.receiverList.app\n+                                + \" (pid=\" + filter.receiverList.pid\n+                                + \", uid=\" + filter.receiverList.uid + \")\"\n+                                + \" excludes appop \" + AppOpsManager.permissionToOp(\n+                                excludedPermission)\n+                                + \" due to sender \" + r.callerPackage\n+                                + \" (uid \" + r.callingUid + \")\");\n+                        skip = true;\n+                        break;\n+                    }\n+                } else {\n+                    // When there is no app op associated with the permission,\n+                    // skip when permission is granted.\n+                    if (perm == PackageManager.PERMISSION_GRANTED) {\n+                        Slog.w(TAG, \"Permission Denial: receiving \"\n+                                + r.intent.toString()\n+                                + \" to \" + filter.receiverList.app\n+                                + \" (pid=\" + filter.receiverList.pid\n+                                + \", uid=\" + filter.receiverList.uid + \")\"\n+                                + \" excludes \" + excludedPermission\n+                                + \" due to sender \" + r.callerPackage\n+                                + \" (uid \" + r.callingUid + \")\");\n+                        skip = true;\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+\n         // Check that the receiver does *not* belong to any of the excluded packages\n         if (!skip && r.excludedPackages != null && r.excludedPackages.length > 0) {\n             if (ArrayUtils.contains(r.excludedPackages, filter.packageName)) {\n",
    "added_lines": 48,
    "deleted_lines": 0,
    "changed_methods": "BroadcastQueue::deliverToRegisteredReceiverLocked"
   }
  ]
 },
 {
  "hash": "c0353314847735082aa8a51557361d2081f5cdbc",
  "commit": "[DO NOT MERGE] Do not dismiss keyguard after SIM PUK unlock\n\nAfter PUK unlock, multiple calls to\nKeyguardSecurityContainerController#dismiss() were being called from\nthe KeyguardSimPukViewController, which begins the transition to the\nnext security screen, if any. At the same time, other parts of the\nsystem, also listening to SIM events, recognize the PUK unlock and\ncall KeyguardSecurityContainer#showSecurityScreen, which updates which\nsecurity method comes next. After boot, this should be one of PIN,\nPassword, Pattern, assuming they have a security method. If one of the\nfirst dismiss() calls comes AFTER the security method changes, this is\nincorrectly recognized by the code as a successful\nPIN/pattern/password unlock. This causes the keyguard to be marked as\ndone, causing screen flickers and incorrect system state.\n\nThe solution: every call to dismiss() should include a new parameter\nfor the security method used. If there is a difference between this\nparameter and the current value in KeyguardSecurityContainerCallback,\nignore the request, as the system state has changed.\n\nFixes: 238804980\nBug: 218500036\nTest: atest KeyguardSecurityContainerTest\nAdminSecondaryLockScreenControllerTest KeyguardHostViewControllerTest\nKeyguardSecurityContainerControllerTest\n\nChange-Id: I7c8714a177bc85fbce92f6e8fe911f74ca2ac243\nMerged-In: I7c8714a177bc85fbce92f6e8fe911f74ca2ac243\n(cherry picked from commit 37aeb26b0ae28a48c1ed40f008d5808d8a84be23)\n(cherry picked from commit 1e7087f1136989b67c9b72c470617e5fb8c80501)\nMerged-In: I7c8714a177bc85fbce92f6e8fe911f74ca2ac243",
  "files": [
   {
    "filename": "AdminSecondaryLockScreenController.java",
    "diff": "@@ -33,6 +33,7 @@ import android.view.SurfaceView;\n import android.view.ViewGroup;\n \n import com.android.internal.annotations.VisibleForTesting;\n+import com.android.keyguard.KeyguardSecurityModel.SecurityMode;\n import com.android.keyguard.dagger.KeyguardBouncerScope;\n import com.android.systemui.dagger.qualifiers.Main;\n \n@@ -208,7 +209,7 @@ public class AdminSecondaryLockScreenController {\n             hide();\n             if (mKeyguardCallback != null) {\n                 mKeyguardCallback.dismiss(/* securityVerified= */ true, userId,\n-                        /* bypassSecondaryLockScreen= */true);\n+                        /* bypassSecondaryLockScreen= */true, SecurityMode.Invalid);\n             }\n         }\n     }\n",
    "added_lines": 2,
    "deleted_lines": 1,
    "changed_methods": "AdminSecondaryLockScreenController::dismiss"
   },
   {
    "filename": "KeyguardAbsKeyInputViewController.java",
    "diff": "@@ -174,7 +174,7 @@ public abstract class KeyguardAbsKeyInputViewController<T extends KeyguardAbsKey\n             if (dismissKeyguard) {\n                 mDismissing = true;\n                 mLatencyTracker.onActionStart(LatencyTracker.ACTION_LOCKSCREEN_UNLOCK);\n-                getKeyguardSecurityCallback().dismiss(true, userId);\n+                getKeyguardSecurityCallback().dismiss(true, userId, getSecurityMode());\n             }\n         } else {\n             if (isValidPassword) {\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "KeyguardAbsKeyInputViewController::onPasswordChecked"
   },
   {
    "filename": "KeyguardHostViewController.java",
    "diff": "@@ -93,7 +93,7 @@ public class KeyguardHostViewController extends ViewController<KeyguardHostView>\n                                 Log.i(TAG, \"TrustAgent dismissed Keyguard.\");\n                             }\n                             mSecurityCallback.dismiss(false /* authenticated */, userId,\n-                                    /* bypassSecondaryLockScreen */ false);\n+                                    /* bypassSecondaryLockScreen */ false, SecurityMode.Invalid);\n                         } else {\n                             mViewMediatorCallback.playTrustedSound();\n                         }\n@@ -105,9 +105,9 @@ public class KeyguardHostViewController extends ViewController<KeyguardHostView>\n \n         @Override\n         public boolean dismiss(boolean authenticated, int targetUserId,\n-                boolean bypassSecondaryLockScreen) {\n+                boolean bypassSecondaryLockScreen, SecurityMode expectedSecurityMode) {\n             return mKeyguardSecurityContainerController.showNextSecurityScreenOrFinish(\n-                    authenticated, targetUserId, bypassSecondaryLockScreen);\n+                    authenticated, targetUserId, bypassSecondaryLockScreen, expectedSecurityMode);\n         }\n \n         @Override\n@@ -215,7 +215,8 @@ public class KeyguardHostViewController extends ViewController<KeyguardHostView>\n      * @return True if the keyguard is done.\n      */\n     public boolean dismiss(int targetUserId) {\n-        return mSecurityCallback.dismiss(false, targetUserId, false);\n+        return mSecurityCallback.dismiss(false, targetUserId, false,\n+                getCurrentSecurityMode());\n     }\n \n     /**\n@@ -356,10 +357,10 @@ public class KeyguardHostViewController extends ViewController<KeyguardHostView>\n     }\n \n     public boolean handleBackKey() {\n-        if (mKeyguardSecurityContainerController.getCurrentSecurityMode()\n-                != SecurityMode.None) {\n+        SecurityMode securityMode = mKeyguardSecurityContainerController.getCurrentSecurityMode();\n+        if (securityMode != SecurityMode.None) {\n             mKeyguardSecurityContainerController.dismiss(\n-                    false, KeyguardUpdateMonitor.getCurrentUser());\n+                    false, KeyguardUpdateMonitor.getCurrentUser(), securityMode);\n             return true;\n         }\n         return false;\n",
    "added_lines": 8,
    "deleted_lines": 7,
    "changed_methods": "KeyguardHostViewController::SecurityCallback, KeyguardHostViewController::handleBackKey, KeyguardHostViewController::KeyguardUpdateMonitorCallback, KeyguardHostViewController::dismiss"
   },
   {
    "filename": "KeyguardInputViewController.java",
    "diff": "@@ -59,10 +59,11 @@ public abstract class KeyguardInputViewController<T extends KeyguardInputView>\n             return false;\n         }\n         @Override\n-        public void dismiss(boolean securityVerified, int targetUserId) { }\n+        public void dismiss(boolean securityVerified, int targetUserId,\n+                SecurityMode expectedSecurityMode) { }\n         @Override\n         public void dismiss(boolean authenticated, int targetId,\n-                boolean bypassSecondaryLockScreen) { }\n+                boolean bypassSecondaryLockScreen, SecurityMode expectedSecurityMode) { }\n         @Override\n         public void onUserInput() { }\n         @Override\n",
    "added_lines": 3,
    "deleted_lines": 2,
    "changed_methods": "KeyguardInputViewController::KeyguardSecurityCallback"
   },
   {
    "filename": "KeyguardPatternViewController.java",
    "diff": "@@ -170,7 +170,7 @@ public class KeyguardPatternViewController\n                 if (dismissKeyguard) {\n                     mLockPatternView.setDisplayMode(LockPatternView.DisplayMode.Correct);\n                     mLatencyTracker.onActionStart(LatencyTracker.ACTION_LOCKSCREEN_UNLOCK);\n-                    getKeyguardSecurityCallback().dismiss(true, userId);\n+                    getKeyguardSecurityCallback().dismiss(true, userId, SecurityMode.Pattern);\n                 }\n             } else {\n                 mLockPatternView.setDisplayMode(LockPatternView.DisplayMode.Wrong);\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "KeyguardPatternViewController::UnlockPatternListener::onPatternChecked"
   },
   {
    "filename": "KeyguardSecurityCallback.java",
    "diff": "@@ -15,14 +15,17 @@\n  */\n package com.android.keyguard;\n \n+import com.android.keyguard.KeyguardSecurityModel.SecurityMode;\n+\n public interface KeyguardSecurityCallback {\n \n     /**\n      * Dismiss the given security screen.\n      * @param securityVerified true if the user correctly entered credentials for the given screen.\n      * @param targetUserId a user that needs to be the foreground user at the dismissal completion.\n+     * @param expectedSecurityMode The security mode that is invoking this dismiss.\n      */\n-    void dismiss(boolean securityVerified, int targetUserId);\n+    void dismiss(boolean securityVerified, int targetUserId, SecurityMode expectedSecurityMode);\n \n     /**\n      * Dismiss the given security screen.\n@@ -30,8 +33,10 @@ public interface KeyguardSecurityCallback {\n      * @param targetUserId a user that needs to be the foreground user at the dismissal completion.\n      * @param bypassSecondaryLockScreen true if the user can bypass the secondary lock screen,\n      *                                  if any, during this dismissal.\n+     * @param expectedSecurityMode The security mode that is invoking this dismiss.\n      */\n-    void dismiss(boolean securityVerified, int targetUserId, boolean bypassSecondaryLockScreen);\n+    void dismiss(boolean securityVerified, int targetUserId, boolean bypassSecondaryLockScreen,\n+            SecurityMode expectedSecurityMode);\n \n     /**\n      * Manually report user activity to keep the device awake.\n",
    "added_lines": 7,
    "deleted_lines": 2,
    "changed_methods": ""
   },
   {
    "filename": "KeyguardSecurityContainer.java",
    "diff": "@@ -181,7 +181,12 @@ public class KeyguardSecurityContainer extends FrameLayout {\n \n     // Used to notify the container when something interesting happens.\n     public interface SecurityCallback {\n-        boolean dismiss(boolean authenticated, int targetUserId, boolean bypassSecondaryLockScreen);\n+        /**\n+         * Potentially dismiss the current security screen, after validating that all device\n+         * security has been unlocked. Otherwise show the next screen.\n+         */\n+        boolean dismiss(boolean authenticated, int targetUserId, boolean bypassSecondaryLockScreen,\n+                SecurityMode expectedSecurityMode);\n \n         void userActivity();\n \n",
    "added_lines": 6,
    "deleted_lines": 1,
    "changed_methods": ""
   },
   {
    "filename": "KeyguardSecurityContainerController.java",
    "diff": "@@ -136,14 +136,17 @@ public class KeyguardSecurityContainerController extends ViewController<Keyguard\n         }\n \n         @Override\n-        public void dismiss(boolean authenticated, int targetId) {\n-            dismiss(authenticated, targetId, /* bypassSecondaryLockScreen */ false);\n+        public void dismiss(boolean authenticated, int targetId,\n+                SecurityMode expectedSecurityMode) {\n+            dismiss(authenticated, targetId, /* bypassSecondaryLockScreen */ false,\n+                    expectedSecurityMode);\n         }\n \n         @Override\n         public void dismiss(boolean authenticated, int targetId,\n-                boolean bypassSecondaryLockScreen) {\n-            mSecurityCallback.dismiss(authenticated, targetId, bypassSecondaryLockScreen);\n+                boolean bypassSecondaryLockScreen, SecurityMode expectedSecurityMode) {\n+            mSecurityCallback.dismiss(authenticated, targetId, bypassSecondaryLockScreen,\n+                    expectedSecurityMode);\n         }\n \n         public boolean isVerifyUnlockOnly() {\n@@ -307,8 +310,13 @@ public class KeyguardSecurityContainerController extends ViewController<Keyguard\n         return mCurrentSecurityMode;\n     }\n \n-    public void dismiss(boolean authenticated, int targetUserId) {\n-        mKeyguardSecurityCallback.dismiss(authenticated, targetUserId);\n+    /**\n+     * Potentially dismiss the current security screen, after validating that all device\n+     * security has been unlocked. Otherwise show the next screen.\n+     */\n+    public void dismiss(boolean authenticated, int targetUserId,\n+            SecurityMode expectedSecurityMode) {\n+        mKeyguardSecurityCallback.dismiss(authenticated, targetUserId, expectedSecurityMode);\n     }\n \n     public void reset() {\n@@ -367,12 +375,21 @@ public class KeyguardSecurityContainerController extends ViewController<Keyguard\n      *     completion.\n      * @param bypassSecondaryLockScreen true if the user is allowed to bypass the secondary\n      *     secondary lock screen requirement, if any.\n+     * @param expectedSecurityMode SecurityMode that is invoking this request. SecurityMode.Invalid\n+     *      indicates that no check should be done\n      * @return true if keyguard is done\n      */\n     public boolean showNextSecurityScreenOrFinish(boolean authenticated, int targetUserId,\n-            boolean bypassSecondaryLockScreen) {\n+            boolean bypassSecondaryLockScreen, SecurityMode expectedSecurityMode) {\n \n         if (DEBUG) Log.d(TAG, \"showNextSecurityScreenOrFinish(\" + authenticated + \")\");\n+        if (expectedSecurityMode != SecurityMode.Invalid\n+                && expectedSecurityMode != getCurrentSecurityMode()) {\n+            Log.w(TAG, \"Attempted to invoke showNextSecurityScreenOrFinish with securityMode \"\n+                    + expectedSecurityMode + \", but current mode is \" + getCurrentSecurityMode());\n+            return false;\n+        }\n+\n         boolean finish = false;\n         boolean strongAuth = false;\n         int eventSubtype = -1;\n",
    "added_lines": 24,
    "deleted_lines": 7,
    "changed_methods": "KeyguardSecurityContainerController::showNextSecurityScreenOrFinish, KeyguardSecurityContainerController::showNextSecurityScreenOrFinish, KeyguardSecurityContainerController::dismiss, KeyguardSecurityContainerController::KeyguardSecurityCallback, KeyguardSecurityContainerController::dismiss"
   },
   {
    "filename": "KeyguardSimPinViewController.java",
    "diff": "@@ -162,7 +162,8 @@ public class KeyguardSimPinViewController\n                             mRemainingAttempts = -1;\n                             mShowDefaultMessage = true;\n                             getKeyguardSecurityCallback().dismiss(\n-                                    true, KeyguardUpdateMonitor.getCurrentUser());\n+                                    true, KeyguardUpdateMonitor.getCurrentUser(),\n+                                    SecurityMode.SimPin);\n                         } else {\n                             mShowDefaultMessage = false;\n                             if (result.getResult() == PinResult.PIN_RESULT_TYPE_INCORRECT) {\n",
    "added_lines": 2,
    "deleted_lines": 1,
    "changed_methods": "KeyguardSimPinViewController::verifyPasswordAndUnlock"
   },
   {
    "filename": "KeyguardSimPukViewController.java",
    "diff": "@@ -69,7 +69,8 @@ public class KeyguardSimPukViewController\n             if (simState == TelephonyManager.SIM_STATE_READY) {\n                 mRemainingAttempts = -1;\n                 mShowDefaultMessage = true;\n-                getKeyguardSecurityCallback().dismiss(true, KeyguardUpdateMonitor.getCurrentUser());\n+                getKeyguardSecurityCallback().dismiss(true, KeyguardUpdateMonitor.getCurrentUser(),\n+                        SecurityMode.SimPuk);\n             } else {\n                 resetState();\n             }\n@@ -274,7 +275,8 @@ public class KeyguardSimPukViewController\n                             mShowDefaultMessage = true;\n \n                             getKeyguardSecurityCallback().dismiss(\n-                                    true, KeyguardUpdateMonitor.getCurrentUser());\n+                                    true, KeyguardUpdateMonitor.getCurrentUser(),\n+                                    SecurityMode.SimPuk);\n                         } else {\n                             mShowDefaultMessage = false;\n                             if (result.getResult() == PinResult.PIN_RESULT_TYPE_INCORRECT) {\n",
    "added_lines": 4,
    "deleted_lines": 2,
    "changed_methods": "KeyguardSimPukViewController::KeyguardUpdateMonitorCallback, KeyguardSimPukViewController::updateSim"
   },
   {
    "filename": "AdminSecondaryLockScreenControllerTest.java",
    "diff": "@@ -44,6 +44,7 @@ import android.view.SurfaceView;\n \n import androidx.test.filters.SmallTest;\n \n+import com.android.keyguard.KeyguardSecurityModel.SecurityMode;\n import com.android.systemui.SysuiTestCase;\n \n import org.junit.After;\n@@ -190,7 +191,7 @@ public class AdminSecondaryLockScreenControllerTest extends SysuiTestCase {\n \n     private void verifyViewDismissed(SurfaceView v) throws Exception {\n         verify(mKeyguardSecurityContainer).removeView(v);\n-        verify(mKeyguardCallback).dismiss(true, TARGET_USER_ID, true);\n+        verify(mKeyguardCallback).dismiss(true, TARGET_USER_ID, true, SecurityMode.Invalid);\n         assertThat(mContext.isBound(mComponentName)).isFalse();\n     }\n }\n",
    "added_lines": 2,
    "deleted_lines": 1,
    "changed_methods": "AdminSecondaryLockScreenControllerTest::verifyViewDismissed"
   },
   {
    "filename": "KeyguardSecurityContainerControllerTest.java",
    "diff": "@@ -18,6 +18,8 @@ package com.android.keyguard;\n \n import static android.view.WindowInsets.Type.ime;\n \n+import static com.google.common.truth.Truth.assertThat;\n+\n import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.ArgumentMatchers.anyBoolean;\n import static org.mockito.ArgumentMatchers.anyInt;\n@@ -62,6 +64,7 @@ import org.mockito.junit.MockitoRule;\n @RunWith(AndroidTestingRunner.class)\n @TestableLooper.RunWithLooper()\n public class KeyguardSecurityContainerControllerTest extends SysuiTestCase {\n+    private static final int TARGET_USER_ID = 100;\n     private static final int VIEW_WIDTH = 1600;\n \n     @Rule\n@@ -330,4 +333,42 @@ public class KeyguardSecurityContainerControllerTest extends SysuiTestCase {\n                 R.bool.can_use_one_handed_bouncer))\n                 .thenReturn(sysuiResourceCanUseOneHandedKeyguard);\n     }\n+\n+    @Test\n+    public void showNextSecurityScreenOrFinish_setsSecurityScreenToPinAfterSimPinUnlock() {\n+        // GIVEN the current security method is SimPin\n+        when(mKeyguardUpdateMonitor.getUserHasTrust(anyInt())).thenReturn(false);\n+        when(mKeyguardUpdateMonitor.getUserUnlockedWithBiometric(TARGET_USER_ID)).thenReturn(false);\n+        mKeyguardSecurityContainerController.showSecurityScreen(SecurityMode.SimPin);\n+\n+        // WHEN a request is made from the SimPin screens to show the next security method\n+        when(mKeyguardSecurityModel.getSecurityMode(TARGET_USER_ID)).thenReturn(SecurityMode.PIN);\n+        mKeyguardSecurityContainerController.showNextSecurityScreenOrFinish(\n+                /* authenticated= */true,\n+                TARGET_USER_ID,\n+                /* bypassSecondaryLockScreen= */true,\n+                SecurityMode.SimPin);\n+\n+        // THEN the next security method of PIN is set, and the keyguard is not marked as done\n+        verify(mSecurityCallback, never()).finish(anyBoolean(), anyInt());\n+        assertThat(mKeyguardSecurityContainerController.getCurrentSecurityMode())\n+                .isEqualTo(SecurityMode.PIN);\n+    }\n+\n+    @Test\n+    public void showNextSecurityScreenOrFinish_ignoresCallWhenSecurityMethodHasChanged() {\n+        //GIVEN current security mode has been set to PIN\n+        mKeyguardSecurityContainerController.showSecurityScreen(SecurityMode.PIN);\n+\n+        //WHEN a request comes from SimPin to dismiss the security screens\n+        boolean keyguardDone = mKeyguardSecurityContainerController.showNextSecurityScreenOrFinish(\n+                /* authenticated= */true,\n+                TARGET_USER_ID,\n+                /* bypassSecondaryLockScreen= */true,\n+                SecurityMode.SimPin);\n+\n+        //THEN no action has happened, which will not dismiss the security screens\n+        assertThat(keyguardDone).isEqualTo(false);\n+        verify(mKeyguardUpdateMonitor, never()).getUserHasTrust(anyInt());\n+    }\n }\n",
    "added_lines": 41,
    "deleted_lines": 0,
    "changed_methods": "KeyguardSecurityContainerControllerTest::showNextSecurityScreenOrFinish_ignoresCallWhenSecurityMethodHasChanged, KeyguardSecurityContainerControllerTest::showNextSecurityScreenOrFinish_setsSecurityScreenToPinAfterSimPinUnlock"
   }
  ]
 },
 {
  "hash": "c0353314847735082aa8a51557361d2081f5cdbc",
  "commit": "[DO NOT MERGE] Do not dismiss keyguard after SIM PUK unlock\n\nAfter PUK unlock, multiple calls to\nKeyguardSecurityContainerController#dismiss() were being called from\nthe KeyguardSimPukViewController, which begins the transition to the\nnext security screen, if any. At the same time, other parts of the\nsystem, also listening to SIM events, recognize the PUK unlock and\ncall KeyguardSecurityContainer#showSecurityScreen, which updates which\nsecurity method comes next. After boot, this should be one of PIN,\nPassword, Pattern, assuming they have a security method. If one of the\nfirst dismiss() calls comes AFTER the security method changes, this is\nincorrectly recognized by the code as a successful\nPIN/pattern/password unlock. This causes the keyguard to be marked as\ndone, causing screen flickers and incorrect system state.\n\nThe solution: every call to dismiss() should include a new parameter\nfor the security method used. If there is a difference between this\nparameter and the current value in KeyguardSecurityContainerCallback,\nignore the request, as the system state has changed.\n\nFixes: 238804980\nBug: 218500036\nTest: atest KeyguardSecurityContainerTest\nAdminSecondaryLockScreenControllerTest KeyguardHostViewControllerTest\nKeyguardSecurityContainerControllerTest\n\nChange-Id: I7c8714a177bc85fbce92f6e8fe911f74ca2ac243\nMerged-In: I7c8714a177bc85fbce92f6e8fe911f74ca2ac243\n(cherry picked from commit 37aeb26b0ae28a48c1ed40f008d5808d8a84be23)\n(cherry picked from commit 1e7087f1136989b67c9b72c470617e5fb8c80501)\nMerged-In: I7c8714a177bc85fbce92f6e8fe911f74ca2ac243",
  "files": [
   {
    "filename": "AdminSecondaryLockScreenController.java",
    "diff": "@@ -33,6 +33,7 @@ import android.view.SurfaceView;\n import android.view.ViewGroup;\n \n import com.android.internal.annotations.VisibleForTesting;\n+import com.android.keyguard.KeyguardSecurityModel.SecurityMode;\n import com.android.keyguard.dagger.KeyguardBouncerScope;\n import com.android.systemui.dagger.qualifiers.Main;\n \n@@ -208,7 +209,7 @@ public class AdminSecondaryLockScreenController {\n             hide();\n             if (mKeyguardCallback != null) {\n                 mKeyguardCallback.dismiss(/* securityVerified= */ true, userId,\n-                        /* bypassSecondaryLockScreen= */true);\n+                        /* bypassSecondaryLockScreen= */true, SecurityMode.Invalid);\n             }\n         }\n     }\n",
    "added_lines": 2,
    "deleted_lines": 1,
    "changed_methods": "AdminSecondaryLockScreenController::dismiss"
   },
   {
    "filename": "KeyguardAbsKeyInputViewController.java",
    "diff": "@@ -174,7 +174,7 @@ public abstract class KeyguardAbsKeyInputViewController<T extends KeyguardAbsKey\n             if (dismissKeyguard) {\n                 mDismissing = true;\n                 mLatencyTracker.onActionStart(LatencyTracker.ACTION_LOCKSCREEN_UNLOCK);\n-                getKeyguardSecurityCallback().dismiss(true, userId);\n+                getKeyguardSecurityCallback().dismiss(true, userId, getSecurityMode());\n             }\n         } else {\n             if (isValidPassword) {\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "KeyguardAbsKeyInputViewController::onPasswordChecked"
   },
   {
    "filename": "KeyguardHostViewController.java",
    "diff": "@@ -93,7 +93,7 @@ public class KeyguardHostViewController extends ViewController<KeyguardHostView>\n                                 Log.i(TAG, \"TrustAgent dismissed Keyguard.\");\n                             }\n                             mSecurityCallback.dismiss(false /* authenticated */, userId,\n-                                    /* bypassSecondaryLockScreen */ false);\n+                                    /* bypassSecondaryLockScreen */ false, SecurityMode.Invalid);\n                         } else {\n                             mViewMediatorCallback.playTrustedSound();\n                         }\n@@ -105,9 +105,9 @@ public class KeyguardHostViewController extends ViewController<KeyguardHostView>\n \n         @Override\n         public boolean dismiss(boolean authenticated, int targetUserId,\n-                boolean bypassSecondaryLockScreen) {\n+                boolean bypassSecondaryLockScreen, SecurityMode expectedSecurityMode) {\n             return mKeyguardSecurityContainerController.showNextSecurityScreenOrFinish(\n-                    authenticated, targetUserId, bypassSecondaryLockScreen);\n+                    authenticated, targetUserId, bypassSecondaryLockScreen, expectedSecurityMode);\n         }\n \n         @Override\n@@ -215,7 +215,8 @@ public class KeyguardHostViewController extends ViewController<KeyguardHostView>\n      * @return True if the keyguard is done.\n      */\n     public boolean dismiss(int targetUserId) {\n-        return mSecurityCallback.dismiss(false, targetUserId, false);\n+        return mSecurityCallback.dismiss(false, targetUserId, false,\n+                getCurrentSecurityMode());\n     }\n \n     /**\n@@ -356,10 +357,10 @@ public class KeyguardHostViewController extends ViewController<KeyguardHostView>\n     }\n \n     public boolean handleBackKey() {\n-        if (mKeyguardSecurityContainerController.getCurrentSecurityMode()\n-                != SecurityMode.None) {\n+        SecurityMode securityMode = mKeyguardSecurityContainerController.getCurrentSecurityMode();\n+        if (securityMode != SecurityMode.None) {\n             mKeyguardSecurityContainerController.dismiss(\n-                    false, KeyguardUpdateMonitor.getCurrentUser());\n+                    false, KeyguardUpdateMonitor.getCurrentUser(), securityMode);\n             return true;\n         }\n         return false;\n",
    "added_lines": 8,
    "deleted_lines": 7,
    "changed_methods": "KeyguardHostViewController::SecurityCallback, KeyguardHostViewController::handleBackKey, KeyguardHostViewController::KeyguardUpdateMonitorCallback, KeyguardHostViewController::dismiss"
   },
   {
    "filename": "KeyguardInputViewController.java",
    "diff": "@@ -59,10 +59,11 @@ public abstract class KeyguardInputViewController<T extends KeyguardInputView>\n             return false;\n         }\n         @Override\n-        public void dismiss(boolean securityVerified, int targetUserId) { }\n+        public void dismiss(boolean securityVerified, int targetUserId,\n+                SecurityMode expectedSecurityMode) { }\n         @Override\n         public void dismiss(boolean authenticated, int targetId,\n-                boolean bypassSecondaryLockScreen) { }\n+                boolean bypassSecondaryLockScreen, SecurityMode expectedSecurityMode) { }\n         @Override\n         public void onUserInput() { }\n         @Override\n",
    "added_lines": 3,
    "deleted_lines": 2,
    "changed_methods": "KeyguardInputViewController::KeyguardSecurityCallback"
   },
   {
    "filename": "KeyguardPatternViewController.java",
    "diff": "@@ -170,7 +170,7 @@ public class KeyguardPatternViewController\n                 if (dismissKeyguard) {\n                     mLockPatternView.setDisplayMode(LockPatternView.DisplayMode.Correct);\n                     mLatencyTracker.onActionStart(LatencyTracker.ACTION_LOCKSCREEN_UNLOCK);\n-                    getKeyguardSecurityCallback().dismiss(true, userId);\n+                    getKeyguardSecurityCallback().dismiss(true, userId, SecurityMode.Pattern);\n                 }\n             } else {\n                 mLockPatternView.setDisplayMode(LockPatternView.DisplayMode.Wrong);\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "KeyguardPatternViewController::UnlockPatternListener::onPatternChecked"
   },
   {
    "filename": "KeyguardSecurityCallback.java",
    "diff": "@@ -15,14 +15,17 @@\n  */\n package com.android.keyguard;\n \n+import com.android.keyguard.KeyguardSecurityModel.SecurityMode;\n+\n public interface KeyguardSecurityCallback {\n \n     /**\n      * Dismiss the given security screen.\n      * @param securityVerified true if the user correctly entered credentials for the given screen.\n      * @param targetUserId a user that needs to be the foreground user at the dismissal completion.\n+     * @param expectedSecurityMode The security mode that is invoking this dismiss.\n      */\n-    void dismiss(boolean securityVerified, int targetUserId);\n+    void dismiss(boolean securityVerified, int targetUserId, SecurityMode expectedSecurityMode);\n \n     /**\n      * Dismiss the given security screen.\n@@ -30,8 +33,10 @@ public interface KeyguardSecurityCallback {\n      * @param targetUserId a user that needs to be the foreground user at the dismissal completion.\n      * @param bypassSecondaryLockScreen true if the user can bypass the secondary lock screen,\n      *                                  if any, during this dismissal.\n+     * @param expectedSecurityMode The security mode that is invoking this dismiss.\n      */\n-    void dismiss(boolean securityVerified, int targetUserId, boolean bypassSecondaryLockScreen);\n+    void dismiss(boolean securityVerified, int targetUserId, boolean bypassSecondaryLockScreen,\n+            SecurityMode expectedSecurityMode);\n \n     /**\n      * Manually report user activity to keep the device awake.\n",
    "added_lines": 7,
    "deleted_lines": 2,
    "changed_methods": ""
   },
   {
    "filename": "KeyguardSecurityContainer.java",
    "diff": "@@ -181,7 +181,12 @@ public class KeyguardSecurityContainer extends FrameLayout {\n \n     // Used to notify the container when something interesting happens.\n     public interface SecurityCallback {\n-        boolean dismiss(boolean authenticated, int targetUserId, boolean bypassSecondaryLockScreen);\n+        /**\n+         * Potentially dismiss the current security screen, after validating that all device\n+         * security has been unlocked. Otherwise show the next screen.\n+         */\n+        boolean dismiss(boolean authenticated, int targetUserId, boolean bypassSecondaryLockScreen,\n+                SecurityMode expectedSecurityMode);\n \n         void userActivity();\n \n",
    "added_lines": 6,
    "deleted_lines": 1,
    "changed_methods": ""
   },
   {
    "filename": "KeyguardSecurityContainerController.java",
    "diff": "@@ -136,14 +136,17 @@ public class KeyguardSecurityContainerController extends ViewController<Keyguard\n         }\n \n         @Override\n-        public void dismiss(boolean authenticated, int targetId) {\n-            dismiss(authenticated, targetId, /* bypassSecondaryLockScreen */ false);\n+        public void dismiss(boolean authenticated, int targetId,\n+                SecurityMode expectedSecurityMode) {\n+            dismiss(authenticated, targetId, /* bypassSecondaryLockScreen */ false,\n+                    expectedSecurityMode);\n         }\n \n         @Override\n         public void dismiss(boolean authenticated, int targetId,\n-                boolean bypassSecondaryLockScreen) {\n-            mSecurityCallback.dismiss(authenticated, targetId, bypassSecondaryLockScreen);\n+                boolean bypassSecondaryLockScreen, SecurityMode expectedSecurityMode) {\n+            mSecurityCallback.dismiss(authenticated, targetId, bypassSecondaryLockScreen,\n+                    expectedSecurityMode);\n         }\n \n         public boolean isVerifyUnlockOnly() {\n@@ -307,8 +310,13 @@ public class KeyguardSecurityContainerController extends ViewController<Keyguard\n         return mCurrentSecurityMode;\n     }\n \n-    public void dismiss(boolean authenticated, int targetUserId) {\n-        mKeyguardSecurityCallback.dismiss(authenticated, targetUserId);\n+    /**\n+     * Potentially dismiss the current security screen, after validating that all device\n+     * security has been unlocked. Otherwise show the next screen.\n+     */\n+    public void dismiss(boolean authenticated, int targetUserId,\n+            SecurityMode expectedSecurityMode) {\n+        mKeyguardSecurityCallback.dismiss(authenticated, targetUserId, expectedSecurityMode);\n     }\n \n     public void reset() {\n@@ -367,12 +375,21 @@ public class KeyguardSecurityContainerController extends ViewController<Keyguard\n      *     completion.\n      * @param bypassSecondaryLockScreen true if the user is allowed to bypass the secondary\n      *     secondary lock screen requirement, if any.\n+     * @param expectedSecurityMode SecurityMode that is invoking this request. SecurityMode.Invalid\n+     *      indicates that no check should be done\n      * @return true if keyguard is done\n      */\n     public boolean showNextSecurityScreenOrFinish(boolean authenticated, int targetUserId,\n-            boolean bypassSecondaryLockScreen) {\n+            boolean bypassSecondaryLockScreen, SecurityMode expectedSecurityMode) {\n \n         if (DEBUG) Log.d(TAG, \"showNextSecurityScreenOrFinish(\" + authenticated + \")\");\n+        if (expectedSecurityMode != SecurityMode.Invalid\n+                && expectedSecurityMode != getCurrentSecurityMode()) {\n+            Log.w(TAG, \"Attempted to invoke showNextSecurityScreenOrFinish with securityMode \"\n+                    + expectedSecurityMode + \", but current mode is \" + getCurrentSecurityMode());\n+            return false;\n+        }\n+\n         boolean finish = false;\n         boolean strongAuth = false;\n         int eventSubtype = -1;\n",
    "added_lines": 24,
    "deleted_lines": 7,
    "changed_methods": "KeyguardSecurityContainerController::showNextSecurityScreenOrFinish, KeyguardSecurityContainerController::showNextSecurityScreenOrFinish, KeyguardSecurityContainerController::dismiss, KeyguardSecurityContainerController::KeyguardSecurityCallback, KeyguardSecurityContainerController::dismiss"
   },
   {
    "filename": "KeyguardSimPinViewController.java",
    "diff": "@@ -162,7 +162,8 @@ public class KeyguardSimPinViewController\n                             mRemainingAttempts = -1;\n                             mShowDefaultMessage = true;\n                             getKeyguardSecurityCallback().dismiss(\n-                                    true, KeyguardUpdateMonitor.getCurrentUser());\n+                                    true, KeyguardUpdateMonitor.getCurrentUser(),\n+                                    SecurityMode.SimPin);\n                         } else {\n                             mShowDefaultMessage = false;\n                             if (result.getResult() == PinResult.PIN_RESULT_TYPE_INCORRECT) {\n",
    "added_lines": 2,
    "deleted_lines": 1,
    "changed_methods": "KeyguardSimPinViewController::verifyPasswordAndUnlock"
   },
   {
    "filename": "KeyguardSimPukViewController.java",
    "diff": "@@ -69,7 +69,8 @@ public class KeyguardSimPukViewController\n             if (simState == TelephonyManager.SIM_STATE_READY) {\n                 mRemainingAttempts = -1;\n                 mShowDefaultMessage = true;\n-                getKeyguardSecurityCallback().dismiss(true, KeyguardUpdateMonitor.getCurrentUser());\n+                getKeyguardSecurityCallback().dismiss(true, KeyguardUpdateMonitor.getCurrentUser(),\n+                        SecurityMode.SimPuk);\n             } else {\n                 resetState();\n             }\n@@ -274,7 +275,8 @@ public class KeyguardSimPukViewController\n                             mShowDefaultMessage = true;\n \n                             getKeyguardSecurityCallback().dismiss(\n-                                    true, KeyguardUpdateMonitor.getCurrentUser());\n+                                    true, KeyguardUpdateMonitor.getCurrentUser(),\n+                                    SecurityMode.SimPuk);\n                         } else {\n                             mShowDefaultMessage = false;\n                             if (result.getResult() == PinResult.PIN_RESULT_TYPE_INCORRECT) {\n",
    "added_lines": 4,
    "deleted_lines": 2,
    "changed_methods": "KeyguardSimPukViewController::KeyguardUpdateMonitorCallback, KeyguardSimPukViewController::updateSim"
   },
   {
    "filename": "AdminSecondaryLockScreenControllerTest.java",
    "diff": "@@ -44,6 +44,7 @@ import android.view.SurfaceView;\n \n import androidx.test.filters.SmallTest;\n \n+import com.android.keyguard.KeyguardSecurityModel.SecurityMode;\n import com.android.systemui.SysuiTestCase;\n \n import org.junit.After;\n@@ -190,7 +191,7 @@ public class AdminSecondaryLockScreenControllerTest extends SysuiTestCase {\n \n     private void verifyViewDismissed(SurfaceView v) throws Exception {\n         verify(mKeyguardSecurityContainer).removeView(v);\n-        verify(mKeyguardCallback).dismiss(true, TARGET_USER_ID, true);\n+        verify(mKeyguardCallback).dismiss(true, TARGET_USER_ID, true, SecurityMode.Invalid);\n         assertThat(mContext.isBound(mComponentName)).isFalse();\n     }\n }\n",
    "added_lines": 2,
    "deleted_lines": 1,
    "changed_methods": "AdminSecondaryLockScreenControllerTest::verifyViewDismissed"
   },
   {
    "filename": "KeyguardSecurityContainerControllerTest.java",
    "diff": "@@ -18,6 +18,8 @@ package com.android.keyguard;\n \n import static android.view.WindowInsets.Type.ime;\n \n+import static com.google.common.truth.Truth.assertThat;\n+\n import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.ArgumentMatchers.anyBoolean;\n import static org.mockito.ArgumentMatchers.anyInt;\n@@ -62,6 +64,7 @@ import org.mockito.junit.MockitoRule;\n @RunWith(AndroidTestingRunner.class)\n @TestableLooper.RunWithLooper()\n public class KeyguardSecurityContainerControllerTest extends SysuiTestCase {\n+    private static final int TARGET_USER_ID = 100;\n     private static final int VIEW_WIDTH = 1600;\n \n     @Rule\n@@ -330,4 +333,42 @@ public class KeyguardSecurityContainerControllerTest extends SysuiTestCase {\n                 R.bool.can_use_one_handed_bouncer))\n                 .thenReturn(sysuiResourceCanUseOneHandedKeyguard);\n     }\n+\n+    @Test\n+    public void showNextSecurityScreenOrFinish_setsSecurityScreenToPinAfterSimPinUnlock() {\n+        // GIVEN the current security method is SimPin\n+        when(mKeyguardUpdateMonitor.getUserHasTrust(anyInt())).thenReturn(false);\n+        when(mKeyguardUpdateMonitor.getUserUnlockedWithBiometric(TARGET_USER_ID)).thenReturn(false);\n+        mKeyguardSecurityContainerController.showSecurityScreen(SecurityMode.SimPin);\n+\n+        // WHEN a request is made from the SimPin screens to show the next security method\n+        when(mKeyguardSecurityModel.getSecurityMode(TARGET_USER_ID)).thenReturn(SecurityMode.PIN);\n+        mKeyguardSecurityContainerController.showNextSecurityScreenOrFinish(\n+                /* authenticated= */true,\n+                TARGET_USER_ID,\n+                /* bypassSecondaryLockScreen= */true,\n+                SecurityMode.SimPin);\n+\n+        // THEN the next security method of PIN is set, and the keyguard is not marked as done\n+        verify(mSecurityCallback, never()).finish(anyBoolean(), anyInt());\n+        assertThat(mKeyguardSecurityContainerController.getCurrentSecurityMode())\n+                .isEqualTo(SecurityMode.PIN);\n+    }\n+\n+    @Test\n+    public void showNextSecurityScreenOrFinish_ignoresCallWhenSecurityMethodHasChanged() {\n+        //GIVEN current security mode has been set to PIN\n+        mKeyguardSecurityContainerController.showSecurityScreen(SecurityMode.PIN);\n+\n+        //WHEN a request comes from SimPin to dismiss the security screens\n+        boolean keyguardDone = mKeyguardSecurityContainerController.showNextSecurityScreenOrFinish(\n+                /* authenticated= */true,\n+                TARGET_USER_ID,\n+                /* bypassSecondaryLockScreen= */true,\n+                SecurityMode.SimPin);\n+\n+        //THEN no action has happened, which will not dismiss the security screens\n+        assertThat(keyguardDone).isEqualTo(false);\n+        verify(mKeyguardUpdateMonitor, never()).getUserHasTrust(anyInt());\n+    }\n }\n",
    "added_lines": 41,
    "deleted_lines": 0,
    "changed_methods": "KeyguardSecurityContainerControllerTest::showNextSecurityScreenOrFinish_ignoresCallWhenSecurityMethodHasChanged, KeyguardSecurityContainerControllerTest::showNextSecurityScreenOrFinish_setsSecurityScreenToPinAfterSimPinUnlock"
   }
  ]
 },
 {
  "hash": "c0353314847735082aa8a51557361d2081f5cdbc",
  "commit": "[DO NOT MERGE] Do not dismiss keyguard after SIM PUK unlock\n\nAfter PUK unlock, multiple calls to\nKeyguardSecurityContainerController#dismiss() were being called from\nthe KeyguardSimPukViewController, which begins the transition to the\nnext security screen, if any. At the same time, other parts of the\nsystem, also listening to SIM events, recognize the PUK unlock and\ncall KeyguardSecurityContainer#showSecurityScreen, which updates which\nsecurity method comes next. After boot, this should be one of PIN,\nPassword, Pattern, assuming they have a security method. If one of the\nfirst dismiss() calls comes AFTER the security method changes, this is\nincorrectly recognized by the code as a successful\nPIN/pattern/password unlock. This causes the keyguard to be marked as\ndone, causing screen flickers and incorrect system state.\n\nThe solution: every call to dismiss() should include a new parameter\nfor the security method used. If there is a difference between this\nparameter and the current value in KeyguardSecurityContainerCallback,\nignore the request, as the system state has changed.\n\nFixes: 238804980\nBug: 218500036\nTest: atest KeyguardSecurityContainerTest\nAdminSecondaryLockScreenControllerTest KeyguardHostViewControllerTest\nKeyguardSecurityContainerControllerTest\n\nChange-Id: I7c8714a177bc85fbce92f6e8fe911f74ca2ac243\nMerged-In: I7c8714a177bc85fbce92f6e8fe911f74ca2ac243\n(cherry picked from commit 37aeb26b0ae28a48c1ed40f008d5808d8a84be23)\n(cherry picked from commit 1e7087f1136989b67c9b72c470617e5fb8c80501)\nMerged-In: I7c8714a177bc85fbce92f6e8fe911f74ca2ac243",
  "files": [
   {
    "filename": "AdminSecondaryLockScreenController.java",
    "diff": "@@ -33,6 +33,7 @@ import android.view.SurfaceView;\n import android.view.ViewGroup;\n \n import com.android.internal.annotations.VisibleForTesting;\n+import com.android.keyguard.KeyguardSecurityModel.SecurityMode;\n import com.android.keyguard.dagger.KeyguardBouncerScope;\n import com.android.systemui.dagger.qualifiers.Main;\n \n@@ -208,7 +209,7 @@ public class AdminSecondaryLockScreenController {\n             hide();\n             if (mKeyguardCallback != null) {\n                 mKeyguardCallback.dismiss(/* securityVerified= */ true, userId,\n-                        /* bypassSecondaryLockScreen= */true);\n+                        /* bypassSecondaryLockScreen= */true, SecurityMode.Invalid);\n             }\n         }\n     }\n",
    "added_lines": 2,
    "deleted_lines": 1,
    "changed_methods": "AdminSecondaryLockScreenController::dismiss"
   },
   {
    "filename": "KeyguardAbsKeyInputViewController.java",
    "diff": "@@ -174,7 +174,7 @@ public abstract class KeyguardAbsKeyInputViewController<T extends KeyguardAbsKey\n             if (dismissKeyguard) {\n                 mDismissing = true;\n                 mLatencyTracker.onActionStart(LatencyTracker.ACTION_LOCKSCREEN_UNLOCK);\n-                getKeyguardSecurityCallback().dismiss(true, userId);\n+                getKeyguardSecurityCallback().dismiss(true, userId, getSecurityMode());\n             }\n         } else {\n             if (isValidPassword) {\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "KeyguardAbsKeyInputViewController::onPasswordChecked"
   },
   {
    "filename": "KeyguardHostViewController.java",
    "diff": "@@ -93,7 +93,7 @@ public class KeyguardHostViewController extends ViewController<KeyguardHostView>\n                                 Log.i(TAG, \"TrustAgent dismissed Keyguard.\");\n                             }\n                             mSecurityCallback.dismiss(false /* authenticated */, userId,\n-                                    /* bypassSecondaryLockScreen */ false);\n+                                    /* bypassSecondaryLockScreen */ false, SecurityMode.Invalid);\n                         } else {\n                             mViewMediatorCallback.playTrustedSound();\n                         }\n@@ -105,9 +105,9 @@ public class KeyguardHostViewController extends ViewController<KeyguardHostView>\n \n         @Override\n         public boolean dismiss(boolean authenticated, int targetUserId,\n-                boolean bypassSecondaryLockScreen) {\n+                boolean bypassSecondaryLockScreen, SecurityMode expectedSecurityMode) {\n             return mKeyguardSecurityContainerController.showNextSecurityScreenOrFinish(\n-                    authenticated, targetUserId, bypassSecondaryLockScreen);\n+                    authenticated, targetUserId, bypassSecondaryLockScreen, expectedSecurityMode);\n         }\n \n         @Override\n@@ -215,7 +215,8 @@ public class KeyguardHostViewController extends ViewController<KeyguardHostView>\n      * @return True if the keyguard is done.\n      */\n     public boolean dismiss(int targetUserId) {\n-        return mSecurityCallback.dismiss(false, targetUserId, false);\n+        return mSecurityCallback.dismiss(false, targetUserId, false,\n+                getCurrentSecurityMode());\n     }\n \n     /**\n@@ -356,10 +357,10 @@ public class KeyguardHostViewController extends ViewController<KeyguardHostView>\n     }\n \n     public boolean handleBackKey() {\n-        if (mKeyguardSecurityContainerController.getCurrentSecurityMode()\n-                != SecurityMode.None) {\n+        SecurityMode securityMode = mKeyguardSecurityContainerController.getCurrentSecurityMode();\n+        if (securityMode != SecurityMode.None) {\n             mKeyguardSecurityContainerController.dismiss(\n-                    false, KeyguardUpdateMonitor.getCurrentUser());\n+                    false, KeyguardUpdateMonitor.getCurrentUser(), securityMode);\n             return true;\n         }\n         return false;\n",
    "added_lines": 8,
    "deleted_lines": 7,
    "changed_methods": "KeyguardHostViewController::SecurityCallback, KeyguardHostViewController::handleBackKey, KeyguardHostViewController::KeyguardUpdateMonitorCallback, KeyguardHostViewController::dismiss"
   },
   {
    "filename": "KeyguardInputViewController.java",
    "diff": "@@ -59,10 +59,11 @@ public abstract class KeyguardInputViewController<T extends KeyguardInputView>\n             return false;\n         }\n         @Override\n-        public void dismiss(boolean securityVerified, int targetUserId) { }\n+        public void dismiss(boolean securityVerified, int targetUserId,\n+                SecurityMode expectedSecurityMode) { }\n         @Override\n         public void dismiss(boolean authenticated, int targetId,\n-                boolean bypassSecondaryLockScreen) { }\n+                boolean bypassSecondaryLockScreen, SecurityMode expectedSecurityMode) { }\n         @Override\n         public void onUserInput() { }\n         @Override\n",
    "added_lines": 3,
    "deleted_lines": 2,
    "changed_methods": "KeyguardInputViewController::KeyguardSecurityCallback"
   },
   {
    "filename": "KeyguardPatternViewController.java",
    "diff": "@@ -170,7 +170,7 @@ public class KeyguardPatternViewController\n                 if (dismissKeyguard) {\n                     mLockPatternView.setDisplayMode(LockPatternView.DisplayMode.Correct);\n                     mLatencyTracker.onActionStart(LatencyTracker.ACTION_LOCKSCREEN_UNLOCK);\n-                    getKeyguardSecurityCallback().dismiss(true, userId);\n+                    getKeyguardSecurityCallback().dismiss(true, userId, SecurityMode.Pattern);\n                 }\n             } else {\n                 mLockPatternView.setDisplayMode(LockPatternView.DisplayMode.Wrong);\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "KeyguardPatternViewController::UnlockPatternListener::onPatternChecked"
   },
   {
    "filename": "KeyguardSecurityCallback.java",
    "diff": "@@ -15,14 +15,17 @@\n  */\n package com.android.keyguard;\n \n+import com.android.keyguard.KeyguardSecurityModel.SecurityMode;\n+\n public interface KeyguardSecurityCallback {\n \n     /**\n      * Dismiss the given security screen.\n      * @param securityVerified true if the user correctly entered credentials for the given screen.\n      * @param targetUserId a user that needs to be the foreground user at the dismissal completion.\n+     * @param expectedSecurityMode The security mode that is invoking this dismiss.\n      */\n-    void dismiss(boolean securityVerified, int targetUserId);\n+    void dismiss(boolean securityVerified, int targetUserId, SecurityMode expectedSecurityMode);\n \n     /**\n      * Dismiss the given security screen.\n@@ -30,8 +33,10 @@ public interface KeyguardSecurityCallback {\n      * @param targetUserId a user that needs to be the foreground user at the dismissal completion.\n      * @param bypassSecondaryLockScreen true if the user can bypass the secondary lock screen,\n      *                                  if any, during this dismissal.\n+     * @param expectedSecurityMode The security mode that is invoking this dismiss.\n      */\n-    void dismiss(boolean securityVerified, int targetUserId, boolean bypassSecondaryLockScreen);\n+    void dismiss(boolean securityVerified, int targetUserId, boolean bypassSecondaryLockScreen,\n+            SecurityMode expectedSecurityMode);\n \n     /**\n      * Manually report user activity to keep the device awake.\n",
    "added_lines": 7,
    "deleted_lines": 2,
    "changed_methods": ""
   },
   {
    "filename": "KeyguardSecurityContainer.java",
    "diff": "@@ -181,7 +181,12 @@ public class KeyguardSecurityContainer extends FrameLayout {\n \n     // Used to notify the container when something interesting happens.\n     public interface SecurityCallback {\n-        boolean dismiss(boolean authenticated, int targetUserId, boolean bypassSecondaryLockScreen);\n+        /**\n+         * Potentially dismiss the current security screen, after validating that all device\n+         * security has been unlocked. Otherwise show the next screen.\n+         */\n+        boolean dismiss(boolean authenticated, int targetUserId, boolean bypassSecondaryLockScreen,\n+                SecurityMode expectedSecurityMode);\n \n         void userActivity();\n \n",
    "added_lines": 6,
    "deleted_lines": 1,
    "changed_methods": ""
   },
   {
    "filename": "KeyguardSecurityContainerController.java",
    "diff": "@@ -136,14 +136,17 @@ public class KeyguardSecurityContainerController extends ViewController<Keyguard\n         }\n \n         @Override\n-        public void dismiss(boolean authenticated, int targetId) {\n-            dismiss(authenticated, targetId, /* bypassSecondaryLockScreen */ false);\n+        public void dismiss(boolean authenticated, int targetId,\n+                SecurityMode expectedSecurityMode) {\n+            dismiss(authenticated, targetId, /* bypassSecondaryLockScreen */ false,\n+                    expectedSecurityMode);\n         }\n \n         @Override\n         public void dismiss(boolean authenticated, int targetId,\n-                boolean bypassSecondaryLockScreen) {\n-            mSecurityCallback.dismiss(authenticated, targetId, bypassSecondaryLockScreen);\n+                boolean bypassSecondaryLockScreen, SecurityMode expectedSecurityMode) {\n+            mSecurityCallback.dismiss(authenticated, targetId, bypassSecondaryLockScreen,\n+                    expectedSecurityMode);\n         }\n \n         public boolean isVerifyUnlockOnly() {\n@@ -307,8 +310,13 @@ public class KeyguardSecurityContainerController extends ViewController<Keyguard\n         return mCurrentSecurityMode;\n     }\n \n-    public void dismiss(boolean authenticated, int targetUserId) {\n-        mKeyguardSecurityCallback.dismiss(authenticated, targetUserId);\n+    /**\n+     * Potentially dismiss the current security screen, after validating that all device\n+     * security has been unlocked. Otherwise show the next screen.\n+     */\n+    public void dismiss(boolean authenticated, int targetUserId,\n+            SecurityMode expectedSecurityMode) {\n+        mKeyguardSecurityCallback.dismiss(authenticated, targetUserId, expectedSecurityMode);\n     }\n \n     public void reset() {\n@@ -367,12 +375,21 @@ public class KeyguardSecurityContainerController extends ViewController<Keyguard\n      *     completion.\n      * @param bypassSecondaryLockScreen true if the user is allowed to bypass the secondary\n      *     secondary lock screen requirement, if any.\n+     * @param expectedSecurityMode SecurityMode that is invoking this request. SecurityMode.Invalid\n+     *      indicates that no check should be done\n      * @return true if keyguard is done\n      */\n     public boolean showNextSecurityScreenOrFinish(boolean authenticated, int targetUserId,\n-            boolean bypassSecondaryLockScreen) {\n+            boolean bypassSecondaryLockScreen, SecurityMode expectedSecurityMode) {\n \n         if (DEBUG) Log.d(TAG, \"showNextSecurityScreenOrFinish(\" + authenticated + \")\");\n+        if (expectedSecurityMode != SecurityMode.Invalid\n+                && expectedSecurityMode != getCurrentSecurityMode()) {\n+            Log.w(TAG, \"Attempted to invoke showNextSecurityScreenOrFinish with securityMode \"\n+                    + expectedSecurityMode + \", but current mode is \" + getCurrentSecurityMode());\n+            return false;\n+        }\n+\n         boolean finish = false;\n         boolean strongAuth = false;\n         int eventSubtype = -1;\n",
    "added_lines": 24,
    "deleted_lines": 7,
    "changed_methods": "KeyguardSecurityContainerController::showNextSecurityScreenOrFinish, KeyguardSecurityContainerController::showNextSecurityScreenOrFinish, KeyguardSecurityContainerController::dismiss, KeyguardSecurityContainerController::KeyguardSecurityCallback, KeyguardSecurityContainerController::dismiss"
   },
   {
    "filename": "KeyguardSimPinViewController.java",
    "diff": "@@ -162,7 +162,8 @@ public class KeyguardSimPinViewController\n                             mRemainingAttempts = -1;\n                             mShowDefaultMessage = true;\n                             getKeyguardSecurityCallback().dismiss(\n-                                    true, KeyguardUpdateMonitor.getCurrentUser());\n+                                    true, KeyguardUpdateMonitor.getCurrentUser(),\n+                                    SecurityMode.SimPin);\n                         } else {\n                             mShowDefaultMessage = false;\n                             if (result.getResult() == PinResult.PIN_RESULT_TYPE_INCORRECT) {\n",
    "added_lines": 2,
    "deleted_lines": 1,
    "changed_methods": "KeyguardSimPinViewController::verifyPasswordAndUnlock"
   },
   {
    "filename": "KeyguardSimPukViewController.java",
    "diff": "@@ -69,7 +69,8 @@ public class KeyguardSimPukViewController\n             if (simState == TelephonyManager.SIM_STATE_READY) {\n                 mRemainingAttempts = -1;\n                 mShowDefaultMessage = true;\n-                getKeyguardSecurityCallback().dismiss(true, KeyguardUpdateMonitor.getCurrentUser());\n+                getKeyguardSecurityCallback().dismiss(true, KeyguardUpdateMonitor.getCurrentUser(),\n+                        SecurityMode.SimPuk);\n             } else {\n                 resetState();\n             }\n@@ -274,7 +275,8 @@ public class KeyguardSimPukViewController\n                             mShowDefaultMessage = true;\n \n                             getKeyguardSecurityCallback().dismiss(\n-                                    true, KeyguardUpdateMonitor.getCurrentUser());\n+                                    true, KeyguardUpdateMonitor.getCurrentUser(),\n+                                    SecurityMode.SimPuk);\n                         } else {\n                             mShowDefaultMessage = false;\n                             if (result.getResult() == PinResult.PIN_RESULT_TYPE_INCORRECT) {\n",
    "added_lines": 4,
    "deleted_lines": 2,
    "changed_methods": "KeyguardSimPukViewController::KeyguardUpdateMonitorCallback, KeyguardSimPukViewController::updateSim"
   },
   {
    "filename": "AdminSecondaryLockScreenControllerTest.java",
    "diff": "@@ -44,6 +44,7 @@ import android.view.SurfaceView;\n \n import androidx.test.filters.SmallTest;\n \n+import com.android.keyguard.KeyguardSecurityModel.SecurityMode;\n import com.android.systemui.SysuiTestCase;\n \n import org.junit.After;\n@@ -190,7 +191,7 @@ public class AdminSecondaryLockScreenControllerTest extends SysuiTestCase {\n \n     private void verifyViewDismissed(SurfaceView v) throws Exception {\n         verify(mKeyguardSecurityContainer).removeView(v);\n-        verify(mKeyguardCallback).dismiss(true, TARGET_USER_ID, true);\n+        verify(mKeyguardCallback).dismiss(true, TARGET_USER_ID, true, SecurityMode.Invalid);\n         assertThat(mContext.isBound(mComponentName)).isFalse();\n     }\n }\n",
    "added_lines": 2,
    "deleted_lines": 1,
    "changed_methods": "AdminSecondaryLockScreenControllerTest::verifyViewDismissed"
   },
   {
    "filename": "KeyguardSecurityContainerControllerTest.java",
    "diff": "@@ -18,6 +18,8 @@ package com.android.keyguard;\n \n import static android.view.WindowInsets.Type.ime;\n \n+import static com.google.common.truth.Truth.assertThat;\n+\n import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.ArgumentMatchers.anyBoolean;\n import static org.mockito.ArgumentMatchers.anyInt;\n@@ -62,6 +64,7 @@ import org.mockito.junit.MockitoRule;\n @RunWith(AndroidTestingRunner.class)\n @TestableLooper.RunWithLooper()\n public class KeyguardSecurityContainerControllerTest extends SysuiTestCase {\n+    private static final int TARGET_USER_ID = 100;\n     private static final int VIEW_WIDTH = 1600;\n \n     @Rule\n@@ -330,4 +333,42 @@ public class KeyguardSecurityContainerControllerTest extends SysuiTestCase {\n                 R.bool.can_use_one_handed_bouncer))\n                 .thenReturn(sysuiResourceCanUseOneHandedKeyguard);\n     }\n+\n+    @Test\n+    public void showNextSecurityScreenOrFinish_setsSecurityScreenToPinAfterSimPinUnlock() {\n+        // GIVEN the current security method is SimPin\n+        when(mKeyguardUpdateMonitor.getUserHasTrust(anyInt())).thenReturn(false);\n+        when(mKeyguardUpdateMonitor.getUserUnlockedWithBiometric(TARGET_USER_ID)).thenReturn(false);\n+        mKeyguardSecurityContainerController.showSecurityScreen(SecurityMode.SimPin);\n+\n+        // WHEN a request is made from the SimPin screens to show the next security method\n+        when(mKeyguardSecurityModel.getSecurityMode(TARGET_USER_ID)).thenReturn(SecurityMode.PIN);\n+        mKeyguardSecurityContainerController.showNextSecurityScreenOrFinish(\n+                /* authenticated= */true,\n+                TARGET_USER_ID,\n+                /* bypassSecondaryLockScreen= */true,\n+                SecurityMode.SimPin);\n+\n+        // THEN the next security method of PIN is set, and the keyguard is not marked as done\n+        verify(mSecurityCallback, never()).finish(anyBoolean(), anyInt());\n+        assertThat(mKeyguardSecurityContainerController.getCurrentSecurityMode())\n+                .isEqualTo(SecurityMode.PIN);\n+    }\n+\n+    @Test\n+    public void showNextSecurityScreenOrFinish_ignoresCallWhenSecurityMethodHasChanged() {\n+        //GIVEN current security mode has been set to PIN\n+        mKeyguardSecurityContainerController.showSecurityScreen(SecurityMode.PIN);\n+\n+        //WHEN a request comes from SimPin to dismiss the security screens\n+        boolean keyguardDone = mKeyguardSecurityContainerController.showNextSecurityScreenOrFinish(\n+                /* authenticated= */true,\n+                TARGET_USER_ID,\n+                /* bypassSecondaryLockScreen= */true,\n+                SecurityMode.SimPin);\n+\n+        //THEN no action has happened, which will not dismiss the security screens\n+        assertThat(keyguardDone).isEqualTo(false);\n+        verify(mKeyguardUpdateMonitor, never()).getUserHasTrust(anyInt());\n+    }\n }\n",
    "added_lines": 41,
    "deleted_lines": 0,
    "changed_methods": "KeyguardSecurityContainerControllerTest::showNextSecurityScreenOrFinish_ignoresCallWhenSecurityMethodHasChanged, KeyguardSecurityContainerControllerTest::showNextSecurityScreenOrFinish_setsSecurityScreenToPinAfterSimPinUnlock"
   }
  ]
 },
 {
  "hash": "c0353314847735082aa8a51557361d2081f5cdbc",
  "commit": "[DO NOT MERGE] Do not dismiss keyguard after SIM PUK unlock\n\nAfter PUK unlock, multiple calls to\nKeyguardSecurityContainerController#dismiss() were being called from\nthe KeyguardSimPukViewController, which begins the transition to the\nnext security screen, if any. At the same time, other parts of the\nsystem, also listening to SIM events, recognize the PUK unlock and\ncall KeyguardSecurityContainer#showSecurityScreen, which updates which\nsecurity method comes next. After boot, this should be one of PIN,\nPassword, Pattern, assuming they have a security method. If one of the\nfirst dismiss() calls comes AFTER the security method changes, this is\nincorrectly recognized by the code as a successful\nPIN/pattern/password unlock. This causes the keyguard to be marked as\ndone, causing screen flickers and incorrect system state.\n\nThe solution: every call to dismiss() should include a new parameter\nfor the security method used. If there is a difference between this\nparameter and the current value in KeyguardSecurityContainerCallback,\nignore the request, as the system state has changed.\n\nFixes: 238804980\nBug: 218500036\nTest: atest KeyguardSecurityContainerTest\nAdminSecondaryLockScreenControllerTest KeyguardHostViewControllerTest\nKeyguardSecurityContainerControllerTest\n\nChange-Id: I7c8714a177bc85fbce92f6e8fe911f74ca2ac243\nMerged-In: I7c8714a177bc85fbce92f6e8fe911f74ca2ac243\n(cherry picked from commit 37aeb26b0ae28a48c1ed40f008d5808d8a84be23)\n(cherry picked from commit 1e7087f1136989b67c9b72c470617e5fb8c80501)\nMerged-In: I7c8714a177bc85fbce92f6e8fe911f74ca2ac243",
  "files": [
   {
    "filename": "AdminSecondaryLockScreenController.java",
    "diff": "@@ -33,6 +33,7 @@ import android.view.SurfaceView;\n import android.view.ViewGroup;\n \n import com.android.internal.annotations.VisibleForTesting;\n+import com.android.keyguard.KeyguardSecurityModel.SecurityMode;\n import com.android.keyguard.dagger.KeyguardBouncerScope;\n import com.android.systemui.dagger.qualifiers.Main;\n \n@@ -208,7 +209,7 @@ public class AdminSecondaryLockScreenController {\n             hide();\n             if (mKeyguardCallback != null) {\n                 mKeyguardCallback.dismiss(/* securityVerified= */ true, userId,\n-                        /* bypassSecondaryLockScreen= */true);\n+                        /* bypassSecondaryLockScreen= */true, SecurityMode.Invalid);\n             }\n         }\n     }\n",
    "added_lines": 2,
    "deleted_lines": 1,
    "changed_methods": "AdminSecondaryLockScreenController::dismiss"
   },
   {
    "filename": "KeyguardAbsKeyInputViewController.java",
    "diff": "@@ -174,7 +174,7 @@ public abstract class KeyguardAbsKeyInputViewController<T extends KeyguardAbsKey\n             if (dismissKeyguard) {\n                 mDismissing = true;\n                 mLatencyTracker.onActionStart(LatencyTracker.ACTION_LOCKSCREEN_UNLOCK);\n-                getKeyguardSecurityCallback().dismiss(true, userId);\n+                getKeyguardSecurityCallback().dismiss(true, userId, getSecurityMode());\n             }\n         } else {\n             if (isValidPassword) {\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "KeyguardAbsKeyInputViewController::onPasswordChecked"
   },
   {
    "filename": "KeyguardHostViewController.java",
    "diff": "@@ -93,7 +93,7 @@ public class KeyguardHostViewController extends ViewController<KeyguardHostView>\n                                 Log.i(TAG, \"TrustAgent dismissed Keyguard.\");\n                             }\n                             mSecurityCallback.dismiss(false /* authenticated */, userId,\n-                                    /* bypassSecondaryLockScreen */ false);\n+                                    /* bypassSecondaryLockScreen */ false, SecurityMode.Invalid);\n                         } else {\n                             mViewMediatorCallback.playTrustedSound();\n                         }\n@@ -105,9 +105,9 @@ public class KeyguardHostViewController extends ViewController<KeyguardHostView>\n \n         @Override\n         public boolean dismiss(boolean authenticated, int targetUserId,\n-                boolean bypassSecondaryLockScreen) {\n+                boolean bypassSecondaryLockScreen, SecurityMode expectedSecurityMode) {\n             return mKeyguardSecurityContainerController.showNextSecurityScreenOrFinish(\n-                    authenticated, targetUserId, bypassSecondaryLockScreen);\n+                    authenticated, targetUserId, bypassSecondaryLockScreen, expectedSecurityMode);\n         }\n \n         @Override\n@@ -215,7 +215,8 @@ public class KeyguardHostViewController extends ViewController<KeyguardHostView>\n      * @return True if the keyguard is done.\n      */\n     public boolean dismiss(int targetUserId) {\n-        return mSecurityCallback.dismiss(false, targetUserId, false);\n+        return mSecurityCallback.dismiss(false, targetUserId, false,\n+                getCurrentSecurityMode());\n     }\n \n     /**\n@@ -356,10 +357,10 @@ public class KeyguardHostViewController extends ViewController<KeyguardHostView>\n     }\n \n     public boolean handleBackKey() {\n-        if (mKeyguardSecurityContainerController.getCurrentSecurityMode()\n-                != SecurityMode.None) {\n+        SecurityMode securityMode = mKeyguardSecurityContainerController.getCurrentSecurityMode();\n+        if (securityMode != SecurityMode.None) {\n             mKeyguardSecurityContainerController.dismiss(\n-                    false, KeyguardUpdateMonitor.getCurrentUser());\n+                    false, KeyguardUpdateMonitor.getCurrentUser(), securityMode);\n             return true;\n         }\n         return false;\n",
    "added_lines": 8,
    "deleted_lines": 7,
    "changed_methods": "KeyguardHostViewController::SecurityCallback, KeyguardHostViewController::handleBackKey, KeyguardHostViewController::KeyguardUpdateMonitorCallback, KeyguardHostViewController::dismiss"
   },
   {
    "filename": "KeyguardInputViewController.java",
    "diff": "@@ -59,10 +59,11 @@ public abstract class KeyguardInputViewController<T extends KeyguardInputView>\n             return false;\n         }\n         @Override\n-        public void dismiss(boolean securityVerified, int targetUserId) { }\n+        public void dismiss(boolean securityVerified, int targetUserId,\n+                SecurityMode expectedSecurityMode) { }\n         @Override\n         public void dismiss(boolean authenticated, int targetId,\n-                boolean bypassSecondaryLockScreen) { }\n+                boolean bypassSecondaryLockScreen, SecurityMode expectedSecurityMode) { }\n         @Override\n         public void onUserInput() { }\n         @Override\n",
    "added_lines": 3,
    "deleted_lines": 2,
    "changed_methods": "KeyguardInputViewController::KeyguardSecurityCallback"
   },
   {
    "filename": "KeyguardPatternViewController.java",
    "diff": "@@ -170,7 +170,7 @@ public class KeyguardPatternViewController\n                 if (dismissKeyguard) {\n                     mLockPatternView.setDisplayMode(LockPatternView.DisplayMode.Correct);\n                     mLatencyTracker.onActionStart(LatencyTracker.ACTION_LOCKSCREEN_UNLOCK);\n-                    getKeyguardSecurityCallback().dismiss(true, userId);\n+                    getKeyguardSecurityCallback().dismiss(true, userId, SecurityMode.Pattern);\n                 }\n             } else {\n                 mLockPatternView.setDisplayMode(LockPatternView.DisplayMode.Wrong);\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "KeyguardPatternViewController::UnlockPatternListener::onPatternChecked"
   },
   {
    "filename": "KeyguardSecurityCallback.java",
    "diff": "@@ -15,14 +15,17 @@\n  */\n package com.android.keyguard;\n \n+import com.android.keyguard.KeyguardSecurityModel.SecurityMode;\n+\n public interface KeyguardSecurityCallback {\n \n     /**\n      * Dismiss the given security screen.\n      * @param securityVerified true if the user correctly entered credentials for the given screen.\n      * @param targetUserId a user that needs to be the foreground user at the dismissal completion.\n+     * @param expectedSecurityMode The security mode that is invoking this dismiss.\n      */\n-    void dismiss(boolean securityVerified, int targetUserId);\n+    void dismiss(boolean securityVerified, int targetUserId, SecurityMode expectedSecurityMode);\n \n     /**\n      * Dismiss the given security screen.\n@@ -30,8 +33,10 @@ public interface KeyguardSecurityCallback {\n      * @param targetUserId a user that needs to be the foreground user at the dismissal completion.\n      * @param bypassSecondaryLockScreen true if the user can bypass the secondary lock screen,\n      *                                  if any, during this dismissal.\n+     * @param expectedSecurityMode The security mode that is invoking this dismiss.\n      */\n-    void dismiss(boolean securityVerified, int targetUserId, boolean bypassSecondaryLockScreen);\n+    void dismiss(boolean securityVerified, int targetUserId, boolean bypassSecondaryLockScreen,\n+            SecurityMode expectedSecurityMode);\n \n     /**\n      * Manually report user activity to keep the device awake.\n",
    "added_lines": 7,
    "deleted_lines": 2,
    "changed_methods": ""
   },
   {
    "filename": "KeyguardSecurityContainer.java",
    "diff": "@@ -181,7 +181,12 @@ public class KeyguardSecurityContainer extends FrameLayout {\n \n     // Used to notify the container when something interesting happens.\n     public interface SecurityCallback {\n-        boolean dismiss(boolean authenticated, int targetUserId, boolean bypassSecondaryLockScreen);\n+        /**\n+         * Potentially dismiss the current security screen, after validating that all device\n+         * security has been unlocked. Otherwise show the next screen.\n+         */\n+        boolean dismiss(boolean authenticated, int targetUserId, boolean bypassSecondaryLockScreen,\n+                SecurityMode expectedSecurityMode);\n \n         void userActivity();\n \n",
    "added_lines": 6,
    "deleted_lines": 1,
    "changed_methods": ""
   },
   {
    "filename": "KeyguardSecurityContainerController.java",
    "diff": "@@ -136,14 +136,17 @@ public class KeyguardSecurityContainerController extends ViewController<Keyguard\n         }\n \n         @Override\n-        public void dismiss(boolean authenticated, int targetId) {\n-            dismiss(authenticated, targetId, /* bypassSecondaryLockScreen */ false);\n+        public void dismiss(boolean authenticated, int targetId,\n+                SecurityMode expectedSecurityMode) {\n+            dismiss(authenticated, targetId, /* bypassSecondaryLockScreen */ false,\n+                    expectedSecurityMode);\n         }\n \n         @Override\n         public void dismiss(boolean authenticated, int targetId,\n-                boolean bypassSecondaryLockScreen) {\n-            mSecurityCallback.dismiss(authenticated, targetId, bypassSecondaryLockScreen);\n+                boolean bypassSecondaryLockScreen, SecurityMode expectedSecurityMode) {\n+            mSecurityCallback.dismiss(authenticated, targetId, bypassSecondaryLockScreen,\n+                    expectedSecurityMode);\n         }\n \n         public boolean isVerifyUnlockOnly() {\n@@ -307,8 +310,13 @@ public class KeyguardSecurityContainerController extends ViewController<Keyguard\n         return mCurrentSecurityMode;\n     }\n \n-    public void dismiss(boolean authenticated, int targetUserId) {\n-        mKeyguardSecurityCallback.dismiss(authenticated, targetUserId);\n+    /**\n+     * Potentially dismiss the current security screen, after validating that all device\n+     * security has been unlocked. Otherwise show the next screen.\n+     */\n+    public void dismiss(boolean authenticated, int targetUserId,\n+            SecurityMode expectedSecurityMode) {\n+        mKeyguardSecurityCallback.dismiss(authenticated, targetUserId, expectedSecurityMode);\n     }\n \n     public void reset() {\n@@ -367,12 +375,21 @@ public class KeyguardSecurityContainerController extends ViewController<Keyguard\n      *     completion.\n      * @param bypassSecondaryLockScreen true if the user is allowed to bypass the secondary\n      *     secondary lock screen requirement, if any.\n+     * @param expectedSecurityMode SecurityMode that is invoking this request. SecurityMode.Invalid\n+     *      indicates that no check should be done\n      * @return true if keyguard is done\n      */\n     public boolean showNextSecurityScreenOrFinish(boolean authenticated, int targetUserId,\n-            boolean bypassSecondaryLockScreen) {\n+            boolean bypassSecondaryLockScreen, SecurityMode expectedSecurityMode) {\n \n         if (DEBUG) Log.d(TAG, \"showNextSecurityScreenOrFinish(\" + authenticated + \")\");\n+        if (expectedSecurityMode != SecurityMode.Invalid\n+                && expectedSecurityMode != getCurrentSecurityMode()) {\n+            Log.w(TAG, \"Attempted to invoke showNextSecurityScreenOrFinish with securityMode \"\n+                    + expectedSecurityMode + \", but current mode is \" + getCurrentSecurityMode());\n+            return false;\n+        }\n+\n         boolean finish = false;\n         boolean strongAuth = false;\n         int eventSubtype = -1;\n",
    "added_lines": 24,
    "deleted_lines": 7,
    "changed_methods": "KeyguardSecurityContainerController::showNextSecurityScreenOrFinish, KeyguardSecurityContainerController::showNextSecurityScreenOrFinish, KeyguardSecurityContainerController::dismiss, KeyguardSecurityContainerController::KeyguardSecurityCallback, KeyguardSecurityContainerController::dismiss"
   },
   {
    "filename": "KeyguardSimPinViewController.java",
    "diff": "@@ -162,7 +162,8 @@ public class KeyguardSimPinViewController\n                             mRemainingAttempts = -1;\n                             mShowDefaultMessage = true;\n                             getKeyguardSecurityCallback().dismiss(\n-                                    true, KeyguardUpdateMonitor.getCurrentUser());\n+                                    true, KeyguardUpdateMonitor.getCurrentUser(),\n+                                    SecurityMode.SimPin);\n                         } else {\n                             mShowDefaultMessage = false;\n                             if (result.getResult() == PinResult.PIN_RESULT_TYPE_INCORRECT) {\n",
    "added_lines": 2,
    "deleted_lines": 1,
    "changed_methods": "KeyguardSimPinViewController::verifyPasswordAndUnlock"
   },
   {
    "filename": "KeyguardSimPukViewController.java",
    "diff": "@@ -69,7 +69,8 @@ public class KeyguardSimPukViewController\n             if (simState == TelephonyManager.SIM_STATE_READY) {\n                 mRemainingAttempts = -1;\n                 mShowDefaultMessage = true;\n-                getKeyguardSecurityCallback().dismiss(true, KeyguardUpdateMonitor.getCurrentUser());\n+                getKeyguardSecurityCallback().dismiss(true, KeyguardUpdateMonitor.getCurrentUser(),\n+                        SecurityMode.SimPuk);\n             } else {\n                 resetState();\n             }\n@@ -274,7 +275,8 @@ public class KeyguardSimPukViewController\n                             mShowDefaultMessage = true;\n \n                             getKeyguardSecurityCallback().dismiss(\n-                                    true, KeyguardUpdateMonitor.getCurrentUser());\n+                                    true, KeyguardUpdateMonitor.getCurrentUser(),\n+                                    SecurityMode.SimPuk);\n                         } else {\n                             mShowDefaultMessage = false;\n                             if (result.getResult() == PinResult.PIN_RESULT_TYPE_INCORRECT) {\n",
    "added_lines": 4,
    "deleted_lines": 2,
    "changed_methods": "KeyguardSimPukViewController::KeyguardUpdateMonitorCallback, KeyguardSimPukViewController::updateSim"
   },
   {
    "filename": "AdminSecondaryLockScreenControllerTest.java",
    "diff": "@@ -44,6 +44,7 @@ import android.view.SurfaceView;\n \n import androidx.test.filters.SmallTest;\n \n+import com.android.keyguard.KeyguardSecurityModel.SecurityMode;\n import com.android.systemui.SysuiTestCase;\n \n import org.junit.After;\n@@ -190,7 +191,7 @@ public class AdminSecondaryLockScreenControllerTest extends SysuiTestCase {\n \n     private void verifyViewDismissed(SurfaceView v) throws Exception {\n         verify(mKeyguardSecurityContainer).removeView(v);\n-        verify(mKeyguardCallback).dismiss(true, TARGET_USER_ID, true);\n+        verify(mKeyguardCallback).dismiss(true, TARGET_USER_ID, true, SecurityMode.Invalid);\n         assertThat(mContext.isBound(mComponentName)).isFalse();\n     }\n }\n",
    "added_lines": 2,
    "deleted_lines": 1,
    "changed_methods": "AdminSecondaryLockScreenControllerTest::verifyViewDismissed"
   },
   {
    "filename": "KeyguardSecurityContainerControllerTest.java",
    "diff": "@@ -18,6 +18,8 @@ package com.android.keyguard;\n \n import static android.view.WindowInsets.Type.ime;\n \n+import static com.google.common.truth.Truth.assertThat;\n+\n import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.ArgumentMatchers.anyBoolean;\n import static org.mockito.ArgumentMatchers.anyInt;\n@@ -62,6 +64,7 @@ import org.mockito.junit.MockitoRule;\n @RunWith(AndroidTestingRunner.class)\n @TestableLooper.RunWithLooper()\n public class KeyguardSecurityContainerControllerTest extends SysuiTestCase {\n+    private static final int TARGET_USER_ID = 100;\n     private static final int VIEW_WIDTH = 1600;\n \n     @Rule\n@@ -330,4 +333,42 @@ public class KeyguardSecurityContainerControllerTest extends SysuiTestCase {\n                 R.bool.can_use_one_handed_bouncer))\n                 .thenReturn(sysuiResourceCanUseOneHandedKeyguard);\n     }\n+\n+    @Test\n+    public void showNextSecurityScreenOrFinish_setsSecurityScreenToPinAfterSimPinUnlock() {\n+        // GIVEN the current security method is SimPin\n+        when(mKeyguardUpdateMonitor.getUserHasTrust(anyInt())).thenReturn(false);\n+        when(mKeyguardUpdateMonitor.getUserUnlockedWithBiometric(TARGET_USER_ID)).thenReturn(false);\n+        mKeyguardSecurityContainerController.showSecurityScreen(SecurityMode.SimPin);\n+\n+        // WHEN a request is made from the SimPin screens to show the next security method\n+        when(mKeyguardSecurityModel.getSecurityMode(TARGET_USER_ID)).thenReturn(SecurityMode.PIN);\n+        mKeyguardSecurityContainerController.showNextSecurityScreenOrFinish(\n+                /* authenticated= */true,\n+                TARGET_USER_ID,\n+                /* bypassSecondaryLockScreen= */true,\n+                SecurityMode.SimPin);\n+\n+        // THEN the next security method of PIN is set, and the keyguard is not marked as done\n+        verify(mSecurityCallback, never()).finish(anyBoolean(), anyInt());\n+        assertThat(mKeyguardSecurityContainerController.getCurrentSecurityMode())\n+                .isEqualTo(SecurityMode.PIN);\n+    }\n+\n+    @Test\n+    public void showNextSecurityScreenOrFinish_ignoresCallWhenSecurityMethodHasChanged() {\n+        //GIVEN current security mode has been set to PIN\n+        mKeyguardSecurityContainerController.showSecurityScreen(SecurityMode.PIN);\n+\n+        //WHEN a request comes from SimPin to dismiss the security screens\n+        boolean keyguardDone = mKeyguardSecurityContainerController.showNextSecurityScreenOrFinish(\n+                /* authenticated= */true,\n+                TARGET_USER_ID,\n+                /* bypassSecondaryLockScreen= */true,\n+                SecurityMode.SimPin);\n+\n+        //THEN no action has happened, which will not dismiss the security screens\n+        assertThat(keyguardDone).isEqualTo(false);\n+        verify(mKeyguardUpdateMonitor, never()).getUserHasTrust(anyInt());\n+    }\n }\n",
    "added_lines": 41,
    "deleted_lines": 0,
    "changed_methods": "KeyguardSecurityContainerControllerTest::showNextSecurityScreenOrFinish_ignoresCallWhenSecurityMethodHasChanged, KeyguardSecurityContainerControllerTest::showNextSecurityScreenOrFinish_setsSecurityScreenToPinAfterSimPinUnlock"
   }
  ]
 },
 {
  "hash": "c0353314847735082aa8a51557361d2081f5cdbc",
  "commit": "[DO NOT MERGE] Do not dismiss keyguard after SIM PUK unlock\n\nAfter PUK unlock, multiple calls to\nKeyguardSecurityContainerController#dismiss() were being called from\nthe KeyguardSimPukViewController, which begins the transition to the\nnext security screen, if any. At the same time, other parts of the\nsystem, also listening to SIM events, recognize the PUK unlock and\ncall KeyguardSecurityContainer#showSecurityScreen, which updates which\nsecurity method comes next. After boot, this should be one of PIN,\nPassword, Pattern, assuming they have a security method. If one of the\nfirst dismiss() calls comes AFTER the security method changes, this is\nincorrectly recognized by the code as a successful\nPIN/pattern/password unlock. This causes the keyguard to be marked as\ndone, causing screen flickers and incorrect system state.\n\nThe solution: every call to dismiss() should include a new parameter\nfor the security method used. If there is a difference between this\nparameter and the current value in KeyguardSecurityContainerCallback,\nignore the request, as the system state has changed.\n\nFixes: 238804980\nBug: 218500036\nTest: atest KeyguardSecurityContainerTest\nAdminSecondaryLockScreenControllerTest KeyguardHostViewControllerTest\nKeyguardSecurityContainerControllerTest\n\nChange-Id: I7c8714a177bc85fbce92f6e8fe911f74ca2ac243\nMerged-In: I7c8714a177bc85fbce92f6e8fe911f74ca2ac243\n(cherry picked from commit 37aeb26b0ae28a48c1ed40f008d5808d8a84be23)\n(cherry picked from commit 1e7087f1136989b67c9b72c470617e5fb8c80501)\nMerged-In: I7c8714a177bc85fbce92f6e8fe911f74ca2ac243",
  "files": [
   {
    "filename": "AdminSecondaryLockScreenController.java",
    "diff": "@@ -33,6 +33,7 @@ import android.view.SurfaceView;\n import android.view.ViewGroup;\n \n import com.android.internal.annotations.VisibleForTesting;\n+import com.android.keyguard.KeyguardSecurityModel.SecurityMode;\n import com.android.keyguard.dagger.KeyguardBouncerScope;\n import com.android.systemui.dagger.qualifiers.Main;\n \n@@ -208,7 +209,7 @@ public class AdminSecondaryLockScreenController {\n             hide();\n             if (mKeyguardCallback != null) {\n                 mKeyguardCallback.dismiss(/* securityVerified= */ true, userId,\n-                        /* bypassSecondaryLockScreen= */true);\n+                        /* bypassSecondaryLockScreen= */true, SecurityMode.Invalid);\n             }\n         }\n     }\n",
    "added_lines": 2,
    "deleted_lines": 1,
    "changed_methods": "AdminSecondaryLockScreenController::dismiss"
   },
   {
    "filename": "KeyguardAbsKeyInputViewController.java",
    "diff": "@@ -174,7 +174,7 @@ public abstract class KeyguardAbsKeyInputViewController<T extends KeyguardAbsKey\n             if (dismissKeyguard) {\n                 mDismissing = true;\n                 mLatencyTracker.onActionStart(LatencyTracker.ACTION_LOCKSCREEN_UNLOCK);\n-                getKeyguardSecurityCallback().dismiss(true, userId);\n+                getKeyguardSecurityCallback().dismiss(true, userId, getSecurityMode());\n             }\n         } else {\n             if (isValidPassword) {\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "KeyguardAbsKeyInputViewController::onPasswordChecked"
   },
   {
    "filename": "KeyguardHostViewController.java",
    "diff": "@@ -93,7 +93,7 @@ public class KeyguardHostViewController extends ViewController<KeyguardHostView>\n                                 Log.i(TAG, \"TrustAgent dismissed Keyguard.\");\n                             }\n                             mSecurityCallback.dismiss(false /* authenticated */, userId,\n-                                    /* bypassSecondaryLockScreen */ false);\n+                                    /* bypassSecondaryLockScreen */ false, SecurityMode.Invalid);\n                         } else {\n                             mViewMediatorCallback.playTrustedSound();\n                         }\n@@ -105,9 +105,9 @@ public class KeyguardHostViewController extends ViewController<KeyguardHostView>\n \n         @Override\n         public boolean dismiss(boolean authenticated, int targetUserId,\n-                boolean bypassSecondaryLockScreen) {\n+                boolean bypassSecondaryLockScreen, SecurityMode expectedSecurityMode) {\n             return mKeyguardSecurityContainerController.showNextSecurityScreenOrFinish(\n-                    authenticated, targetUserId, bypassSecondaryLockScreen);\n+                    authenticated, targetUserId, bypassSecondaryLockScreen, expectedSecurityMode);\n         }\n \n         @Override\n@@ -215,7 +215,8 @@ public class KeyguardHostViewController extends ViewController<KeyguardHostView>\n      * @return True if the keyguard is done.\n      */\n     public boolean dismiss(int targetUserId) {\n-        return mSecurityCallback.dismiss(false, targetUserId, false);\n+        return mSecurityCallback.dismiss(false, targetUserId, false,\n+                getCurrentSecurityMode());\n     }\n \n     /**\n@@ -356,10 +357,10 @@ public class KeyguardHostViewController extends ViewController<KeyguardHostView>\n     }\n \n     public boolean handleBackKey() {\n-        if (mKeyguardSecurityContainerController.getCurrentSecurityMode()\n-                != SecurityMode.None) {\n+        SecurityMode securityMode = mKeyguardSecurityContainerController.getCurrentSecurityMode();\n+        if (securityMode != SecurityMode.None) {\n             mKeyguardSecurityContainerController.dismiss(\n-                    false, KeyguardUpdateMonitor.getCurrentUser());\n+                    false, KeyguardUpdateMonitor.getCurrentUser(), securityMode);\n             return true;\n         }\n         return false;\n",
    "added_lines": 8,
    "deleted_lines": 7,
    "changed_methods": "KeyguardHostViewController::SecurityCallback, KeyguardHostViewController::handleBackKey, KeyguardHostViewController::KeyguardUpdateMonitorCallback, KeyguardHostViewController::dismiss"
   },
   {
    "filename": "KeyguardInputViewController.java",
    "diff": "@@ -59,10 +59,11 @@ public abstract class KeyguardInputViewController<T extends KeyguardInputView>\n             return false;\n         }\n         @Override\n-        public void dismiss(boolean securityVerified, int targetUserId) { }\n+        public void dismiss(boolean securityVerified, int targetUserId,\n+                SecurityMode expectedSecurityMode) { }\n         @Override\n         public void dismiss(boolean authenticated, int targetId,\n-                boolean bypassSecondaryLockScreen) { }\n+                boolean bypassSecondaryLockScreen, SecurityMode expectedSecurityMode) { }\n         @Override\n         public void onUserInput() { }\n         @Override\n",
    "added_lines": 3,
    "deleted_lines": 2,
    "changed_methods": "KeyguardInputViewController::KeyguardSecurityCallback"
   },
   {
    "filename": "KeyguardPatternViewController.java",
    "diff": "@@ -170,7 +170,7 @@ public class KeyguardPatternViewController\n                 if (dismissKeyguard) {\n                     mLockPatternView.setDisplayMode(LockPatternView.DisplayMode.Correct);\n                     mLatencyTracker.onActionStart(LatencyTracker.ACTION_LOCKSCREEN_UNLOCK);\n-                    getKeyguardSecurityCallback().dismiss(true, userId);\n+                    getKeyguardSecurityCallback().dismiss(true, userId, SecurityMode.Pattern);\n                 }\n             } else {\n                 mLockPatternView.setDisplayMode(LockPatternView.DisplayMode.Wrong);\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "KeyguardPatternViewController::UnlockPatternListener::onPatternChecked"
   },
   {
    "filename": "KeyguardSecurityCallback.java",
    "diff": "@@ -15,14 +15,17 @@\n  */\n package com.android.keyguard;\n \n+import com.android.keyguard.KeyguardSecurityModel.SecurityMode;\n+\n public interface KeyguardSecurityCallback {\n \n     /**\n      * Dismiss the given security screen.\n      * @param securityVerified true if the user correctly entered credentials for the given screen.\n      * @param targetUserId a user that needs to be the foreground user at the dismissal completion.\n+     * @param expectedSecurityMode The security mode that is invoking this dismiss.\n      */\n-    void dismiss(boolean securityVerified, int targetUserId);\n+    void dismiss(boolean securityVerified, int targetUserId, SecurityMode expectedSecurityMode);\n \n     /**\n      * Dismiss the given security screen.\n@@ -30,8 +33,10 @@ public interface KeyguardSecurityCallback {\n      * @param targetUserId a user that needs to be the foreground user at the dismissal completion.\n      * @param bypassSecondaryLockScreen true if the user can bypass the secondary lock screen,\n      *                                  if any, during this dismissal.\n+     * @param expectedSecurityMode The security mode that is invoking this dismiss.\n      */\n-    void dismiss(boolean securityVerified, int targetUserId, boolean bypassSecondaryLockScreen);\n+    void dismiss(boolean securityVerified, int targetUserId, boolean bypassSecondaryLockScreen,\n+            SecurityMode expectedSecurityMode);\n \n     /**\n      * Manually report user activity to keep the device awake.\n",
    "added_lines": 7,
    "deleted_lines": 2,
    "changed_methods": ""
   },
   {
    "filename": "KeyguardSecurityContainer.java",
    "diff": "@@ -181,7 +181,12 @@ public class KeyguardSecurityContainer extends FrameLayout {\n \n     // Used to notify the container when something interesting happens.\n     public interface SecurityCallback {\n-        boolean dismiss(boolean authenticated, int targetUserId, boolean bypassSecondaryLockScreen);\n+        /**\n+         * Potentially dismiss the current security screen, after validating that all device\n+         * security has been unlocked. Otherwise show the next screen.\n+         */\n+        boolean dismiss(boolean authenticated, int targetUserId, boolean bypassSecondaryLockScreen,\n+                SecurityMode expectedSecurityMode);\n \n         void userActivity();\n \n",
    "added_lines": 6,
    "deleted_lines": 1,
    "changed_methods": ""
   },
   {
    "filename": "KeyguardSecurityContainerController.java",
    "diff": "@@ -136,14 +136,17 @@ public class KeyguardSecurityContainerController extends ViewController<Keyguard\n         }\n \n         @Override\n-        public void dismiss(boolean authenticated, int targetId) {\n-            dismiss(authenticated, targetId, /* bypassSecondaryLockScreen */ false);\n+        public void dismiss(boolean authenticated, int targetId,\n+                SecurityMode expectedSecurityMode) {\n+            dismiss(authenticated, targetId, /* bypassSecondaryLockScreen */ false,\n+                    expectedSecurityMode);\n         }\n \n         @Override\n         public void dismiss(boolean authenticated, int targetId,\n-                boolean bypassSecondaryLockScreen) {\n-            mSecurityCallback.dismiss(authenticated, targetId, bypassSecondaryLockScreen);\n+                boolean bypassSecondaryLockScreen, SecurityMode expectedSecurityMode) {\n+            mSecurityCallback.dismiss(authenticated, targetId, bypassSecondaryLockScreen,\n+                    expectedSecurityMode);\n         }\n \n         public boolean isVerifyUnlockOnly() {\n@@ -307,8 +310,13 @@ public class KeyguardSecurityContainerController extends ViewController<Keyguard\n         return mCurrentSecurityMode;\n     }\n \n-    public void dismiss(boolean authenticated, int targetUserId) {\n-        mKeyguardSecurityCallback.dismiss(authenticated, targetUserId);\n+    /**\n+     * Potentially dismiss the current security screen, after validating that all device\n+     * security has been unlocked. Otherwise show the next screen.\n+     */\n+    public void dismiss(boolean authenticated, int targetUserId,\n+            SecurityMode expectedSecurityMode) {\n+        mKeyguardSecurityCallback.dismiss(authenticated, targetUserId, expectedSecurityMode);\n     }\n \n     public void reset() {\n@@ -367,12 +375,21 @@ public class KeyguardSecurityContainerController extends ViewController<Keyguard\n      *     completion.\n      * @param bypassSecondaryLockScreen true if the user is allowed to bypass the secondary\n      *     secondary lock screen requirement, if any.\n+     * @param expectedSecurityMode SecurityMode that is invoking this request. SecurityMode.Invalid\n+     *      indicates that no check should be done\n      * @return true if keyguard is done\n      */\n     public boolean showNextSecurityScreenOrFinish(boolean authenticated, int targetUserId,\n-            boolean bypassSecondaryLockScreen) {\n+            boolean bypassSecondaryLockScreen, SecurityMode expectedSecurityMode) {\n \n         if (DEBUG) Log.d(TAG, \"showNextSecurityScreenOrFinish(\" + authenticated + \")\");\n+        if (expectedSecurityMode != SecurityMode.Invalid\n+                && expectedSecurityMode != getCurrentSecurityMode()) {\n+            Log.w(TAG, \"Attempted to invoke showNextSecurityScreenOrFinish with securityMode \"\n+                    + expectedSecurityMode + \", but current mode is \" + getCurrentSecurityMode());\n+            return false;\n+        }\n+\n         boolean finish = false;\n         boolean strongAuth = false;\n         int eventSubtype = -1;\n",
    "added_lines": 24,
    "deleted_lines": 7,
    "changed_methods": "KeyguardSecurityContainerController::showNextSecurityScreenOrFinish, KeyguardSecurityContainerController::showNextSecurityScreenOrFinish, KeyguardSecurityContainerController::dismiss, KeyguardSecurityContainerController::KeyguardSecurityCallback, KeyguardSecurityContainerController::dismiss"
   },
   {
    "filename": "KeyguardSimPinViewController.java",
    "diff": "@@ -162,7 +162,8 @@ public class KeyguardSimPinViewController\n                             mRemainingAttempts = -1;\n                             mShowDefaultMessage = true;\n                             getKeyguardSecurityCallback().dismiss(\n-                                    true, KeyguardUpdateMonitor.getCurrentUser());\n+                                    true, KeyguardUpdateMonitor.getCurrentUser(),\n+                                    SecurityMode.SimPin);\n                         } else {\n                             mShowDefaultMessage = false;\n                             if (result.getResult() == PinResult.PIN_RESULT_TYPE_INCORRECT) {\n",
    "added_lines": 2,
    "deleted_lines": 1,
    "changed_methods": "KeyguardSimPinViewController::verifyPasswordAndUnlock"
   },
   {
    "filename": "KeyguardSimPukViewController.java",
    "diff": "@@ -69,7 +69,8 @@ public class KeyguardSimPukViewController\n             if (simState == TelephonyManager.SIM_STATE_READY) {\n                 mRemainingAttempts = -1;\n                 mShowDefaultMessage = true;\n-                getKeyguardSecurityCallback().dismiss(true, KeyguardUpdateMonitor.getCurrentUser());\n+                getKeyguardSecurityCallback().dismiss(true, KeyguardUpdateMonitor.getCurrentUser(),\n+                        SecurityMode.SimPuk);\n             } else {\n                 resetState();\n             }\n@@ -274,7 +275,8 @@ public class KeyguardSimPukViewController\n                             mShowDefaultMessage = true;\n \n                             getKeyguardSecurityCallback().dismiss(\n-                                    true, KeyguardUpdateMonitor.getCurrentUser());\n+                                    true, KeyguardUpdateMonitor.getCurrentUser(),\n+                                    SecurityMode.SimPuk);\n                         } else {\n                             mShowDefaultMessage = false;\n                             if (result.getResult() == PinResult.PIN_RESULT_TYPE_INCORRECT) {\n",
    "added_lines": 4,
    "deleted_lines": 2,
    "changed_methods": "KeyguardSimPukViewController::KeyguardUpdateMonitorCallback, KeyguardSimPukViewController::updateSim"
   },
   {
    "filename": "AdminSecondaryLockScreenControllerTest.java",
    "diff": "@@ -44,6 +44,7 @@ import android.view.SurfaceView;\n \n import androidx.test.filters.SmallTest;\n \n+import com.android.keyguard.KeyguardSecurityModel.SecurityMode;\n import com.android.systemui.SysuiTestCase;\n \n import org.junit.After;\n@@ -190,7 +191,7 @@ public class AdminSecondaryLockScreenControllerTest extends SysuiTestCase {\n \n     private void verifyViewDismissed(SurfaceView v) throws Exception {\n         verify(mKeyguardSecurityContainer).removeView(v);\n-        verify(mKeyguardCallback).dismiss(true, TARGET_USER_ID, true);\n+        verify(mKeyguardCallback).dismiss(true, TARGET_USER_ID, true, SecurityMode.Invalid);\n         assertThat(mContext.isBound(mComponentName)).isFalse();\n     }\n }\n",
    "added_lines": 2,
    "deleted_lines": 1,
    "changed_methods": "AdminSecondaryLockScreenControllerTest::verifyViewDismissed"
   },
   {
    "filename": "KeyguardSecurityContainerControllerTest.java",
    "diff": "@@ -18,6 +18,8 @@ package com.android.keyguard;\n \n import static android.view.WindowInsets.Type.ime;\n \n+import static com.google.common.truth.Truth.assertThat;\n+\n import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.ArgumentMatchers.anyBoolean;\n import static org.mockito.ArgumentMatchers.anyInt;\n@@ -62,6 +64,7 @@ import org.mockito.junit.MockitoRule;\n @RunWith(AndroidTestingRunner.class)\n @TestableLooper.RunWithLooper()\n public class KeyguardSecurityContainerControllerTest extends SysuiTestCase {\n+    private static final int TARGET_USER_ID = 100;\n     private static final int VIEW_WIDTH = 1600;\n \n     @Rule\n@@ -330,4 +333,42 @@ public class KeyguardSecurityContainerControllerTest extends SysuiTestCase {\n                 R.bool.can_use_one_handed_bouncer))\n                 .thenReturn(sysuiResourceCanUseOneHandedKeyguard);\n     }\n+\n+    @Test\n+    public void showNextSecurityScreenOrFinish_setsSecurityScreenToPinAfterSimPinUnlock() {\n+        // GIVEN the current security method is SimPin\n+        when(mKeyguardUpdateMonitor.getUserHasTrust(anyInt())).thenReturn(false);\n+        when(mKeyguardUpdateMonitor.getUserUnlockedWithBiometric(TARGET_USER_ID)).thenReturn(false);\n+        mKeyguardSecurityContainerController.showSecurityScreen(SecurityMode.SimPin);\n+\n+        // WHEN a request is made from the SimPin screens to show the next security method\n+        when(mKeyguardSecurityModel.getSecurityMode(TARGET_USER_ID)).thenReturn(SecurityMode.PIN);\n+        mKeyguardSecurityContainerController.showNextSecurityScreenOrFinish(\n+                /* authenticated= */true,\n+                TARGET_USER_ID,\n+                /* bypassSecondaryLockScreen= */true,\n+                SecurityMode.SimPin);\n+\n+        // THEN the next security method of PIN is set, and the keyguard is not marked as done\n+        verify(mSecurityCallback, never()).finish(anyBoolean(), anyInt());\n+        assertThat(mKeyguardSecurityContainerController.getCurrentSecurityMode())\n+                .isEqualTo(SecurityMode.PIN);\n+    }\n+\n+    @Test\n+    public void showNextSecurityScreenOrFinish_ignoresCallWhenSecurityMethodHasChanged() {\n+        //GIVEN current security mode has been set to PIN\n+        mKeyguardSecurityContainerController.showSecurityScreen(SecurityMode.PIN);\n+\n+        //WHEN a request comes from SimPin to dismiss the security screens\n+        boolean keyguardDone = mKeyguardSecurityContainerController.showNextSecurityScreenOrFinish(\n+                /* authenticated= */true,\n+                TARGET_USER_ID,\n+                /* bypassSecondaryLockScreen= */true,\n+                SecurityMode.SimPin);\n+\n+        //THEN no action has happened, which will not dismiss the security screens\n+        assertThat(keyguardDone).isEqualTo(false);\n+        verify(mKeyguardUpdateMonitor, never()).getUserHasTrust(anyInt());\n+    }\n }\n",
    "added_lines": 41,
    "deleted_lines": 0,
    "changed_methods": "KeyguardSecurityContainerControllerTest::showNextSecurityScreenOrFinish_ignoresCallWhenSecurityMethodHasChanged, KeyguardSecurityContainerControllerTest::showNextSecurityScreenOrFinish_setsSecurityScreenToPinAfterSimPinUnlock"
   }
  ]
 },
 {
  "hash": "c0353314847735082aa8a51557361d2081f5cdbc",
  "commit": "[DO NOT MERGE] Do not dismiss keyguard after SIM PUK unlock\n\nAfter PUK unlock, multiple calls to\nKeyguardSecurityContainerController#dismiss() were being called from\nthe KeyguardSimPukViewController, which begins the transition to the\nnext security screen, if any. At the same time, other parts of the\nsystem, also listening to SIM events, recognize the PUK unlock and\ncall KeyguardSecurityContainer#showSecurityScreen, which updates which\nsecurity method comes next. After boot, this should be one of PIN,\nPassword, Pattern, assuming they have a security method. If one of the\nfirst dismiss() calls comes AFTER the security method changes, this is\nincorrectly recognized by the code as a successful\nPIN/pattern/password unlock. This causes the keyguard to be marked as\ndone, causing screen flickers and incorrect system state.\n\nThe solution: every call to dismiss() should include a new parameter\nfor the security method used. If there is a difference between this\nparameter and the current value in KeyguardSecurityContainerCallback,\nignore the request, as the system state has changed.\n\nFixes: 238804980\nBug: 218500036\nTest: atest KeyguardSecurityContainerTest\nAdminSecondaryLockScreenControllerTest KeyguardHostViewControllerTest\nKeyguardSecurityContainerControllerTest\n\nChange-Id: I7c8714a177bc85fbce92f6e8fe911f74ca2ac243\nMerged-In: I7c8714a177bc85fbce92f6e8fe911f74ca2ac243\n(cherry picked from commit 37aeb26b0ae28a48c1ed40f008d5808d8a84be23)\n(cherry picked from commit 1e7087f1136989b67c9b72c470617e5fb8c80501)\nMerged-In: I7c8714a177bc85fbce92f6e8fe911f74ca2ac243",
  "files": [
   {
    "filename": "AdminSecondaryLockScreenController.java",
    "diff": "@@ -33,6 +33,7 @@ import android.view.SurfaceView;\n import android.view.ViewGroup;\n \n import com.android.internal.annotations.VisibleForTesting;\n+import com.android.keyguard.KeyguardSecurityModel.SecurityMode;\n import com.android.keyguard.dagger.KeyguardBouncerScope;\n import com.android.systemui.dagger.qualifiers.Main;\n \n@@ -208,7 +209,7 @@ public class AdminSecondaryLockScreenController {\n             hide();\n             if (mKeyguardCallback != null) {\n                 mKeyguardCallback.dismiss(/* securityVerified= */ true, userId,\n-                        /* bypassSecondaryLockScreen= */true);\n+                        /* bypassSecondaryLockScreen= */true, SecurityMode.Invalid);\n             }\n         }\n     }\n",
    "added_lines": 2,
    "deleted_lines": 1,
    "changed_methods": "AdminSecondaryLockScreenController::dismiss"
   },
   {
    "filename": "KeyguardAbsKeyInputViewController.java",
    "diff": "@@ -174,7 +174,7 @@ public abstract class KeyguardAbsKeyInputViewController<T extends KeyguardAbsKey\n             if (dismissKeyguard) {\n                 mDismissing = true;\n                 mLatencyTracker.onActionStart(LatencyTracker.ACTION_LOCKSCREEN_UNLOCK);\n-                getKeyguardSecurityCallback().dismiss(true, userId);\n+                getKeyguardSecurityCallback().dismiss(true, userId, getSecurityMode());\n             }\n         } else {\n             if (isValidPassword) {\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "KeyguardAbsKeyInputViewController::onPasswordChecked"
   },
   {
    "filename": "KeyguardHostViewController.java",
    "diff": "@@ -93,7 +93,7 @@ public class KeyguardHostViewController extends ViewController<KeyguardHostView>\n                                 Log.i(TAG, \"TrustAgent dismissed Keyguard.\");\n                             }\n                             mSecurityCallback.dismiss(false /* authenticated */, userId,\n-                                    /* bypassSecondaryLockScreen */ false);\n+                                    /* bypassSecondaryLockScreen */ false, SecurityMode.Invalid);\n                         } else {\n                             mViewMediatorCallback.playTrustedSound();\n                         }\n@@ -105,9 +105,9 @@ public class KeyguardHostViewController extends ViewController<KeyguardHostView>\n \n         @Override\n         public boolean dismiss(boolean authenticated, int targetUserId,\n-                boolean bypassSecondaryLockScreen) {\n+                boolean bypassSecondaryLockScreen, SecurityMode expectedSecurityMode) {\n             return mKeyguardSecurityContainerController.showNextSecurityScreenOrFinish(\n-                    authenticated, targetUserId, bypassSecondaryLockScreen);\n+                    authenticated, targetUserId, bypassSecondaryLockScreen, expectedSecurityMode);\n         }\n \n         @Override\n@@ -215,7 +215,8 @@ public class KeyguardHostViewController extends ViewController<KeyguardHostView>\n      * @return True if the keyguard is done.\n      */\n     public boolean dismiss(int targetUserId) {\n-        return mSecurityCallback.dismiss(false, targetUserId, false);\n+        return mSecurityCallback.dismiss(false, targetUserId, false,\n+                getCurrentSecurityMode());\n     }\n \n     /**\n@@ -356,10 +357,10 @@ public class KeyguardHostViewController extends ViewController<KeyguardHostView>\n     }\n \n     public boolean handleBackKey() {\n-        if (mKeyguardSecurityContainerController.getCurrentSecurityMode()\n-                != SecurityMode.None) {\n+        SecurityMode securityMode = mKeyguardSecurityContainerController.getCurrentSecurityMode();\n+        if (securityMode != SecurityMode.None) {\n             mKeyguardSecurityContainerController.dismiss(\n-                    false, KeyguardUpdateMonitor.getCurrentUser());\n+                    false, KeyguardUpdateMonitor.getCurrentUser(), securityMode);\n             return true;\n         }\n         return false;\n",
    "added_lines": 8,
    "deleted_lines": 7,
    "changed_methods": "KeyguardHostViewController::SecurityCallback, KeyguardHostViewController::handleBackKey, KeyguardHostViewController::KeyguardUpdateMonitorCallback, KeyguardHostViewController::dismiss"
   },
   {
    "filename": "KeyguardInputViewController.java",
    "diff": "@@ -59,10 +59,11 @@ public abstract class KeyguardInputViewController<T extends KeyguardInputView>\n             return false;\n         }\n         @Override\n-        public void dismiss(boolean securityVerified, int targetUserId) { }\n+        public void dismiss(boolean securityVerified, int targetUserId,\n+                SecurityMode expectedSecurityMode) { }\n         @Override\n         public void dismiss(boolean authenticated, int targetId,\n-                boolean bypassSecondaryLockScreen) { }\n+                boolean bypassSecondaryLockScreen, SecurityMode expectedSecurityMode) { }\n         @Override\n         public void onUserInput() { }\n         @Override\n",
    "added_lines": 3,
    "deleted_lines": 2,
    "changed_methods": "KeyguardInputViewController::KeyguardSecurityCallback"
   },
   {
    "filename": "KeyguardPatternViewController.java",
    "diff": "@@ -170,7 +170,7 @@ public class KeyguardPatternViewController\n                 if (dismissKeyguard) {\n                     mLockPatternView.setDisplayMode(LockPatternView.DisplayMode.Correct);\n                     mLatencyTracker.onActionStart(LatencyTracker.ACTION_LOCKSCREEN_UNLOCK);\n-                    getKeyguardSecurityCallback().dismiss(true, userId);\n+                    getKeyguardSecurityCallback().dismiss(true, userId, SecurityMode.Pattern);\n                 }\n             } else {\n                 mLockPatternView.setDisplayMode(LockPatternView.DisplayMode.Wrong);\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "KeyguardPatternViewController::UnlockPatternListener::onPatternChecked"
   },
   {
    "filename": "KeyguardSecurityCallback.java",
    "diff": "@@ -15,14 +15,17 @@\n  */\n package com.android.keyguard;\n \n+import com.android.keyguard.KeyguardSecurityModel.SecurityMode;\n+\n public interface KeyguardSecurityCallback {\n \n     /**\n      * Dismiss the given security screen.\n      * @param securityVerified true if the user correctly entered credentials for the given screen.\n      * @param targetUserId a user that needs to be the foreground user at the dismissal completion.\n+     * @param expectedSecurityMode The security mode that is invoking this dismiss.\n      */\n-    void dismiss(boolean securityVerified, int targetUserId);\n+    void dismiss(boolean securityVerified, int targetUserId, SecurityMode expectedSecurityMode);\n \n     /**\n      * Dismiss the given security screen.\n@@ -30,8 +33,10 @@ public interface KeyguardSecurityCallback {\n      * @param targetUserId a user that needs to be the foreground user at the dismissal completion.\n      * @param bypassSecondaryLockScreen true if the user can bypass the secondary lock screen,\n      *                                  if any, during this dismissal.\n+     * @param expectedSecurityMode The security mode that is invoking this dismiss.\n      */\n-    void dismiss(boolean securityVerified, int targetUserId, boolean bypassSecondaryLockScreen);\n+    void dismiss(boolean securityVerified, int targetUserId, boolean bypassSecondaryLockScreen,\n+            SecurityMode expectedSecurityMode);\n \n     /**\n      * Manually report user activity to keep the device awake.\n",
    "added_lines": 7,
    "deleted_lines": 2,
    "changed_methods": ""
   },
   {
    "filename": "KeyguardSecurityContainer.java",
    "diff": "@@ -181,7 +181,12 @@ public class KeyguardSecurityContainer extends FrameLayout {\n \n     // Used to notify the container when something interesting happens.\n     public interface SecurityCallback {\n-        boolean dismiss(boolean authenticated, int targetUserId, boolean bypassSecondaryLockScreen);\n+        /**\n+         * Potentially dismiss the current security screen, after validating that all device\n+         * security has been unlocked. Otherwise show the next screen.\n+         */\n+        boolean dismiss(boolean authenticated, int targetUserId, boolean bypassSecondaryLockScreen,\n+                SecurityMode expectedSecurityMode);\n \n         void userActivity();\n \n",
    "added_lines": 6,
    "deleted_lines": 1,
    "changed_methods": ""
   },
   {
    "filename": "KeyguardSecurityContainerController.java",
    "diff": "@@ -136,14 +136,17 @@ public class KeyguardSecurityContainerController extends ViewController<Keyguard\n         }\n \n         @Override\n-        public void dismiss(boolean authenticated, int targetId) {\n-            dismiss(authenticated, targetId, /* bypassSecondaryLockScreen */ false);\n+        public void dismiss(boolean authenticated, int targetId,\n+                SecurityMode expectedSecurityMode) {\n+            dismiss(authenticated, targetId, /* bypassSecondaryLockScreen */ false,\n+                    expectedSecurityMode);\n         }\n \n         @Override\n         public void dismiss(boolean authenticated, int targetId,\n-                boolean bypassSecondaryLockScreen) {\n-            mSecurityCallback.dismiss(authenticated, targetId, bypassSecondaryLockScreen);\n+                boolean bypassSecondaryLockScreen, SecurityMode expectedSecurityMode) {\n+            mSecurityCallback.dismiss(authenticated, targetId, bypassSecondaryLockScreen,\n+                    expectedSecurityMode);\n         }\n \n         public boolean isVerifyUnlockOnly() {\n@@ -307,8 +310,13 @@ public class KeyguardSecurityContainerController extends ViewController<Keyguard\n         return mCurrentSecurityMode;\n     }\n \n-    public void dismiss(boolean authenticated, int targetUserId) {\n-        mKeyguardSecurityCallback.dismiss(authenticated, targetUserId);\n+    /**\n+     * Potentially dismiss the current security screen, after validating that all device\n+     * security has been unlocked. Otherwise show the next screen.\n+     */\n+    public void dismiss(boolean authenticated, int targetUserId,\n+            SecurityMode expectedSecurityMode) {\n+        mKeyguardSecurityCallback.dismiss(authenticated, targetUserId, expectedSecurityMode);\n     }\n \n     public void reset() {\n@@ -367,12 +375,21 @@ public class KeyguardSecurityContainerController extends ViewController<Keyguard\n      *     completion.\n      * @param bypassSecondaryLockScreen true if the user is allowed to bypass the secondary\n      *     secondary lock screen requirement, if any.\n+     * @param expectedSecurityMode SecurityMode that is invoking this request. SecurityMode.Invalid\n+     *      indicates that no check should be done\n      * @return true if keyguard is done\n      */\n     public boolean showNextSecurityScreenOrFinish(boolean authenticated, int targetUserId,\n-            boolean bypassSecondaryLockScreen) {\n+            boolean bypassSecondaryLockScreen, SecurityMode expectedSecurityMode) {\n \n         if (DEBUG) Log.d(TAG, \"showNextSecurityScreenOrFinish(\" + authenticated + \")\");\n+        if (expectedSecurityMode != SecurityMode.Invalid\n+                && expectedSecurityMode != getCurrentSecurityMode()) {\n+            Log.w(TAG, \"Attempted to invoke showNextSecurityScreenOrFinish with securityMode \"\n+                    + expectedSecurityMode + \", but current mode is \" + getCurrentSecurityMode());\n+            return false;\n+        }\n+\n         boolean finish = false;\n         boolean strongAuth = false;\n         int eventSubtype = -1;\n",
    "added_lines": 24,
    "deleted_lines": 7,
    "changed_methods": "KeyguardSecurityContainerController::showNextSecurityScreenOrFinish, KeyguardSecurityContainerController::showNextSecurityScreenOrFinish, KeyguardSecurityContainerController::dismiss, KeyguardSecurityContainerController::KeyguardSecurityCallback, KeyguardSecurityContainerController::dismiss"
   },
   {
    "filename": "KeyguardSimPinViewController.java",
    "diff": "@@ -162,7 +162,8 @@ public class KeyguardSimPinViewController\n                             mRemainingAttempts = -1;\n                             mShowDefaultMessage = true;\n                             getKeyguardSecurityCallback().dismiss(\n-                                    true, KeyguardUpdateMonitor.getCurrentUser());\n+                                    true, KeyguardUpdateMonitor.getCurrentUser(),\n+                                    SecurityMode.SimPin);\n                         } else {\n                             mShowDefaultMessage = false;\n                             if (result.getResult() == PinResult.PIN_RESULT_TYPE_INCORRECT) {\n",
    "added_lines": 2,
    "deleted_lines": 1,
    "changed_methods": "KeyguardSimPinViewController::verifyPasswordAndUnlock"
   },
   {
    "filename": "KeyguardSimPukViewController.java",
    "diff": "@@ -69,7 +69,8 @@ public class KeyguardSimPukViewController\n             if (simState == TelephonyManager.SIM_STATE_READY) {\n                 mRemainingAttempts = -1;\n                 mShowDefaultMessage = true;\n-                getKeyguardSecurityCallback().dismiss(true, KeyguardUpdateMonitor.getCurrentUser());\n+                getKeyguardSecurityCallback().dismiss(true, KeyguardUpdateMonitor.getCurrentUser(),\n+                        SecurityMode.SimPuk);\n             } else {\n                 resetState();\n             }\n@@ -274,7 +275,8 @@ public class KeyguardSimPukViewController\n                             mShowDefaultMessage = true;\n \n                             getKeyguardSecurityCallback().dismiss(\n-                                    true, KeyguardUpdateMonitor.getCurrentUser());\n+                                    true, KeyguardUpdateMonitor.getCurrentUser(),\n+                                    SecurityMode.SimPuk);\n                         } else {\n                             mShowDefaultMessage = false;\n                             if (result.getResult() == PinResult.PIN_RESULT_TYPE_INCORRECT) {\n",
    "added_lines": 4,
    "deleted_lines": 2,
    "changed_methods": "KeyguardSimPukViewController::KeyguardUpdateMonitorCallback, KeyguardSimPukViewController::updateSim"
   },
   {
    "filename": "AdminSecondaryLockScreenControllerTest.java",
    "diff": "@@ -44,6 +44,7 @@ import android.view.SurfaceView;\n \n import androidx.test.filters.SmallTest;\n \n+import com.android.keyguard.KeyguardSecurityModel.SecurityMode;\n import com.android.systemui.SysuiTestCase;\n \n import org.junit.After;\n@@ -190,7 +191,7 @@ public class AdminSecondaryLockScreenControllerTest extends SysuiTestCase {\n \n     private void verifyViewDismissed(SurfaceView v) throws Exception {\n         verify(mKeyguardSecurityContainer).removeView(v);\n-        verify(mKeyguardCallback).dismiss(true, TARGET_USER_ID, true);\n+        verify(mKeyguardCallback).dismiss(true, TARGET_USER_ID, true, SecurityMode.Invalid);\n         assertThat(mContext.isBound(mComponentName)).isFalse();\n     }\n }\n",
    "added_lines": 2,
    "deleted_lines": 1,
    "changed_methods": "AdminSecondaryLockScreenControllerTest::verifyViewDismissed"
   },
   {
    "filename": "KeyguardSecurityContainerControllerTest.java",
    "diff": "@@ -18,6 +18,8 @@ package com.android.keyguard;\n \n import static android.view.WindowInsets.Type.ime;\n \n+import static com.google.common.truth.Truth.assertThat;\n+\n import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.ArgumentMatchers.anyBoolean;\n import static org.mockito.ArgumentMatchers.anyInt;\n@@ -62,6 +64,7 @@ import org.mockito.junit.MockitoRule;\n @RunWith(AndroidTestingRunner.class)\n @TestableLooper.RunWithLooper()\n public class KeyguardSecurityContainerControllerTest extends SysuiTestCase {\n+    private static final int TARGET_USER_ID = 100;\n     private static final int VIEW_WIDTH = 1600;\n \n     @Rule\n@@ -330,4 +333,42 @@ public class KeyguardSecurityContainerControllerTest extends SysuiTestCase {\n                 R.bool.can_use_one_handed_bouncer))\n                 .thenReturn(sysuiResourceCanUseOneHandedKeyguard);\n     }\n+\n+    @Test\n+    public void showNextSecurityScreenOrFinish_setsSecurityScreenToPinAfterSimPinUnlock() {\n+        // GIVEN the current security method is SimPin\n+        when(mKeyguardUpdateMonitor.getUserHasTrust(anyInt())).thenReturn(false);\n+        when(mKeyguardUpdateMonitor.getUserUnlockedWithBiometric(TARGET_USER_ID)).thenReturn(false);\n+        mKeyguardSecurityContainerController.showSecurityScreen(SecurityMode.SimPin);\n+\n+        // WHEN a request is made from the SimPin screens to show the next security method\n+        when(mKeyguardSecurityModel.getSecurityMode(TARGET_USER_ID)).thenReturn(SecurityMode.PIN);\n+        mKeyguardSecurityContainerController.showNextSecurityScreenOrFinish(\n+                /* authenticated= */true,\n+                TARGET_USER_ID,\n+                /* bypassSecondaryLockScreen= */true,\n+                SecurityMode.SimPin);\n+\n+        // THEN the next security method of PIN is set, and the keyguard is not marked as done\n+        verify(mSecurityCallback, never()).finish(anyBoolean(), anyInt());\n+        assertThat(mKeyguardSecurityContainerController.getCurrentSecurityMode())\n+                .isEqualTo(SecurityMode.PIN);\n+    }\n+\n+    @Test\n+    public void showNextSecurityScreenOrFinish_ignoresCallWhenSecurityMethodHasChanged() {\n+        //GIVEN current security mode has been set to PIN\n+        mKeyguardSecurityContainerController.showSecurityScreen(SecurityMode.PIN);\n+\n+        //WHEN a request comes from SimPin to dismiss the security screens\n+        boolean keyguardDone = mKeyguardSecurityContainerController.showNextSecurityScreenOrFinish(\n+                /* authenticated= */true,\n+                TARGET_USER_ID,\n+                /* bypassSecondaryLockScreen= */true,\n+                SecurityMode.SimPin);\n+\n+        //THEN no action has happened, which will not dismiss the security screens\n+        assertThat(keyguardDone).isEqualTo(false);\n+        verify(mKeyguardUpdateMonitor, never()).getUserHasTrust(anyInt());\n+    }\n }\n",
    "added_lines": 41,
    "deleted_lines": 0,
    "changed_methods": "KeyguardSecurityContainerControllerTest::showNextSecurityScreenOrFinish_ignoresCallWhenSecurityMethodHasChanged, KeyguardSecurityContainerControllerTest::showNextSecurityScreenOrFinish_setsSecurityScreenToPinAfterSimPinUnlock"
   }
  ]
 },
 {
  "hash": "c0353314847735082aa8a51557361d2081f5cdbc",
  "commit": "[DO NOT MERGE] Do not dismiss keyguard after SIM PUK unlock\n\nAfter PUK unlock, multiple calls to\nKeyguardSecurityContainerController#dismiss() were being called from\nthe KeyguardSimPukViewController, which begins the transition to the\nnext security screen, if any. At the same time, other parts of the\nsystem, also listening to SIM events, recognize the PUK unlock and\ncall KeyguardSecurityContainer#showSecurityScreen, which updates which\nsecurity method comes next. After boot, this should be one of PIN,\nPassword, Pattern, assuming they have a security method. If one of the\nfirst dismiss() calls comes AFTER the security method changes, this is\nincorrectly recognized by the code as a successful\nPIN/pattern/password unlock. This causes the keyguard to be marked as\ndone, causing screen flickers and incorrect system state.\n\nThe solution: every call to dismiss() should include a new parameter\nfor the security method used. If there is a difference between this\nparameter and the current value in KeyguardSecurityContainerCallback,\nignore the request, as the system state has changed.\n\nFixes: 238804980\nBug: 218500036\nTest: atest KeyguardSecurityContainerTest\nAdminSecondaryLockScreenControllerTest KeyguardHostViewControllerTest\nKeyguardSecurityContainerControllerTest\n\nChange-Id: I7c8714a177bc85fbce92f6e8fe911f74ca2ac243\nMerged-In: I7c8714a177bc85fbce92f6e8fe911f74ca2ac243\n(cherry picked from commit 37aeb26b0ae28a48c1ed40f008d5808d8a84be23)\n(cherry picked from commit 1e7087f1136989b67c9b72c470617e5fb8c80501)\nMerged-In: I7c8714a177bc85fbce92f6e8fe911f74ca2ac243",
  "files": [
   {
    "filename": "AdminSecondaryLockScreenController.java",
    "diff": "@@ -33,6 +33,7 @@ import android.view.SurfaceView;\n import android.view.ViewGroup;\n \n import com.android.internal.annotations.VisibleForTesting;\n+import com.android.keyguard.KeyguardSecurityModel.SecurityMode;\n import com.android.keyguard.dagger.KeyguardBouncerScope;\n import com.android.systemui.dagger.qualifiers.Main;\n \n@@ -208,7 +209,7 @@ public class AdminSecondaryLockScreenController {\n             hide();\n             if (mKeyguardCallback != null) {\n                 mKeyguardCallback.dismiss(/* securityVerified= */ true, userId,\n-                        /* bypassSecondaryLockScreen= */true);\n+                        /* bypassSecondaryLockScreen= */true, SecurityMode.Invalid);\n             }\n         }\n     }\n",
    "added_lines": 2,
    "deleted_lines": 1,
    "changed_methods": "AdminSecondaryLockScreenController::dismiss"
   },
   {
    "filename": "KeyguardAbsKeyInputViewController.java",
    "diff": "@@ -174,7 +174,7 @@ public abstract class KeyguardAbsKeyInputViewController<T extends KeyguardAbsKey\n             if (dismissKeyguard) {\n                 mDismissing = true;\n                 mLatencyTracker.onActionStart(LatencyTracker.ACTION_LOCKSCREEN_UNLOCK);\n-                getKeyguardSecurityCallback().dismiss(true, userId);\n+                getKeyguardSecurityCallback().dismiss(true, userId, getSecurityMode());\n             }\n         } else {\n             if (isValidPassword) {\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "KeyguardAbsKeyInputViewController::onPasswordChecked"
   },
   {
    "filename": "KeyguardHostViewController.java",
    "diff": "@@ -93,7 +93,7 @@ public class KeyguardHostViewController extends ViewController<KeyguardHostView>\n                                 Log.i(TAG, \"TrustAgent dismissed Keyguard.\");\n                             }\n                             mSecurityCallback.dismiss(false /* authenticated */, userId,\n-                                    /* bypassSecondaryLockScreen */ false);\n+                                    /* bypassSecondaryLockScreen */ false, SecurityMode.Invalid);\n                         } else {\n                             mViewMediatorCallback.playTrustedSound();\n                         }\n@@ -105,9 +105,9 @@ public class KeyguardHostViewController extends ViewController<KeyguardHostView>\n \n         @Override\n         public boolean dismiss(boolean authenticated, int targetUserId,\n-                boolean bypassSecondaryLockScreen) {\n+                boolean bypassSecondaryLockScreen, SecurityMode expectedSecurityMode) {\n             return mKeyguardSecurityContainerController.showNextSecurityScreenOrFinish(\n-                    authenticated, targetUserId, bypassSecondaryLockScreen);\n+                    authenticated, targetUserId, bypassSecondaryLockScreen, expectedSecurityMode);\n         }\n \n         @Override\n@@ -215,7 +215,8 @@ public class KeyguardHostViewController extends ViewController<KeyguardHostView>\n      * @return True if the keyguard is done.\n      */\n     public boolean dismiss(int targetUserId) {\n-        return mSecurityCallback.dismiss(false, targetUserId, false);\n+        return mSecurityCallback.dismiss(false, targetUserId, false,\n+                getCurrentSecurityMode());\n     }\n \n     /**\n@@ -356,10 +357,10 @@ public class KeyguardHostViewController extends ViewController<KeyguardHostView>\n     }\n \n     public boolean handleBackKey() {\n-        if (mKeyguardSecurityContainerController.getCurrentSecurityMode()\n-                != SecurityMode.None) {\n+        SecurityMode securityMode = mKeyguardSecurityContainerController.getCurrentSecurityMode();\n+        if (securityMode != SecurityMode.None) {\n             mKeyguardSecurityContainerController.dismiss(\n-                    false, KeyguardUpdateMonitor.getCurrentUser());\n+                    false, KeyguardUpdateMonitor.getCurrentUser(), securityMode);\n             return true;\n         }\n         return false;\n",
    "added_lines": 8,
    "deleted_lines": 7,
    "changed_methods": "KeyguardHostViewController::SecurityCallback, KeyguardHostViewController::handleBackKey, KeyguardHostViewController::KeyguardUpdateMonitorCallback, KeyguardHostViewController::dismiss"
   },
   {
    "filename": "KeyguardInputViewController.java",
    "diff": "@@ -59,10 +59,11 @@ public abstract class KeyguardInputViewController<T extends KeyguardInputView>\n             return false;\n         }\n         @Override\n-        public void dismiss(boolean securityVerified, int targetUserId) { }\n+        public void dismiss(boolean securityVerified, int targetUserId,\n+                SecurityMode expectedSecurityMode) { }\n         @Override\n         public void dismiss(boolean authenticated, int targetId,\n-                boolean bypassSecondaryLockScreen) { }\n+                boolean bypassSecondaryLockScreen, SecurityMode expectedSecurityMode) { }\n         @Override\n         public void onUserInput() { }\n         @Override\n",
    "added_lines": 3,
    "deleted_lines": 2,
    "changed_methods": "KeyguardInputViewController::KeyguardSecurityCallback"
   },
   {
    "filename": "KeyguardPatternViewController.java",
    "diff": "@@ -170,7 +170,7 @@ public class KeyguardPatternViewController\n                 if (dismissKeyguard) {\n                     mLockPatternView.setDisplayMode(LockPatternView.DisplayMode.Correct);\n                     mLatencyTracker.onActionStart(LatencyTracker.ACTION_LOCKSCREEN_UNLOCK);\n-                    getKeyguardSecurityCallback().dismiss(true, userId);\n+                    getKeyguardSecurityCallback().dismiss(true, userId, SecurityMode.Pattern);\n                 }\n             } else {\n                 mLockPatternView.setDisplayMode(LockPatternView.DisplayMode.Wrong);\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "KeyguardPatternViewController::UnlockPatternListener::onPatternChecked"
   },
   {
    "filename": "KeyguardSecurityCallback.java",
    "diff": "@@ -15,14 +15,17 @@\n  */\n package com.android.keyguard;\n \n+import com.android.keyguard.KeyguardSecurityModel.SecurityMode;\n+\n public interface KeyguardSecurityCallback {\n \n     /**\n      * Dismiss the given security screen.\n      * @param securityVerified true if the user correctly entered credentials for the given screen.\n      * @param targetUserId a user that needs to be the foreground user at the dismissal completion.\n+     * @param expectedSecurityMode The security mode that is invoking this dismiss.\n      */\n-    void dismiss(boolean securityVerified, int targetUserId);\n+    void dismiss(boolean securityVerified, int targetUserId, SecurityMode expectedSecurityMode);\n \n     /**\n      * Dismiss the given security screen.\n@@ -30,8 +33,10 @@ public interface KeyguardSecurityCallback {\n      * @param targetUserId a user that needs to be the foreground user at the dismissal completion.\n      * @param bypassSecondaryLockScreen true if the user can bypass the secondary lock screen,\n      *                                  if any, during this dismissal.\n+     * @param expectedSecurityMode The security mode that is invoking this dismiss.\n      */\n-    void dismiss(boolean securityVerified, int targetUserId, boolean bypassSecondaryLockScreen);\n+    void dismiss(boolean securityVerified, int targetUserId, boolean bypassSecondaryLockScreen,\n+            SecurityMode expectedSecurityMode);\n \n     /**\n      * Manually report user activity to keep the device awake.\n",
    "added_lines": 7,
    "deleted_lines": 2,
    "changed_methods": ""
   },
   {
    "filename": "KeyguardSecurityContainer.java",
    "diff": "@@ -181,7 +181,12 @@ public class KeyguardSecurityContainer extends FrameLayout {\n \n     // Used to notify the container when something interesting happens.\n     public interface SecurityCallback {\n-        boolean dismiss(boolean authenticated, int targetUserId, boolean bypassSecondaryLockScreen);\n+        /**\n+         * Potentially dismiss the current security screen, after validating that all device\n+         * security has been unlocked. Otherwise show the next screen.\n+         */\n+        boolean dismiss(boolean authenticated, int targetUserId, boolean bypassSecondaryLockScreen,\n+                SecurityMode expectedSecurityMode);\n \n         void userActivity();\n \n",
    "added_lines": 6,
    "deleted_lines": 1,
    "changed_methods": ""
   },
   {
    "filename": "KeyguardSecurityContainerController.java",
    "diff": "@@ -136,14 +136,17 @@ public class KeyguardSecurityContainerController extends ViewController<Keyguard\n         }\n \n         @Override\n-        public void dismiss(boolean authenticated, int targetId) {\n-            dismiss(authenticated, targetId, /* bypassSecondaryLockScreen */ false);\n+        public void dismiss(boolean authenticated, int targetId,\n+                SecurityMode expectedSecurityMode) {\n+            dismiss(authenticated, targetId, /* bypassSecondaryLockScreen */ false,\n+                    expectedSecurityMode);\n         }\n \n         @Override\n         public void dismiss(boolean authenticated, int targetId,\n-                boolean bypassSecondaryLockScreen) {\n-            mSecurityCallback.dismiss(authenticated, targetId, bypassSecondaryLockScreen);\n+                boolean bypassSecondaryLockScreen, SecurityMode expectedSecurityMode) {\n+            mSecurityCallback.dismiss(authenticated, targetId, bypassSecondaryLockScreen,\n+                    expectedSecurityMode);\n         }\n \n         public boolean isVerifyUnlockOnly() {\n@@ -307,8 +310,13 @@ public class KeyguardSecurityContainerController extends ViewController<Keyguard\n         return mCurrentSecurityMode;\n     }\n \n-    public void dismiss(boolean authenticated, int targetUserId) {\n-        mKeyguardSecurityCallback.dismiss(authenticated, targetUserId);\n+    /**\n+     * Potentially dismiss the current security screen, after validating that all device\n+     * security has been unlocked. Otherwise show the next screen.\n+     */\n+    public void dismiss(boolean authenticated, int targetUserId,\n+            SecurityMode expectedSecurityMode) {\n+        mKeyguardSecurityCallback.dismiss(authenticated, targetUserId, expectedSecurityMode);\n     }\n \n     public void reset() {\n@@ -367,12 +375,21 @@ public class KeyguardSecurityContainerController extends ViewController<Keyguard\n      *     completion.\n      * @param bypassSecondaryLockScreen true if the user is allowed to bypass the secondary\n      *     secondary lock screen requirement, if any.\n+     * @param expectedSecurityMode SecurityMode that is invoking this request. SecurityMode.Invalid\n+     *      indicates that no check should be done\n      * @return true if keyguard is done\n      */\n     public boolean showNextSecurityScreenOrFinish(boolean authenticated, int targetUserId,\n-            boolean bypassSecondaryLockScreen) {\n+            boolean bypassSecondaryLockScreen, SecurityMode expectedSecurityMode) {\n \n         if (DEBUG) Log.d(TAG, \"showNextSecurityScreenOrFinish(\" + authenticated + \")\");\n+        if (expectedSecurityMode != SecurityMode.Invalid\n+                && expectedSecurityMode != getCurrentSecurityMode()) {\n+            Log.w(TAG, \"Attempted to invoke showNextSecurityScreenOrFinish with securityMode \"\n+                    + expectedSecurityMode + \", but current mode is \" + getCurrentSecurityMode());\n+            return false;\n+        }\n+\n         boolean finish = false;\n         boolean strongAuth = false;\n         int eventSubtype = -1;\n",
    "added_lines": 24,
    "deleted_lines": 7,
    "changed_methods": "KeyguardSecurityContainerController::showNextSecurityScreenOrFinish, KeyguardSecurityContainerController::showNextSecurityScreenOrFinish, KeyguardSecurityContainerController::dismiss, KeyguardSecurityContainerController::KeyguardSecurityCallback, KeyguardSecurityContainerController::dismiss"
   },
   {
    "filename": "KeyguardSimPinViewController.java",
    "diff": "@@ -162,7 +162,8 @@ public class KeyguardSimPinViewController\n                             mRemainingAttempts = -1;\n                             mShowDefaultMessage = true;\n                             getKeyguardSecurityCallback().dismiss(\n-                                    true, KeyguardUpdateMonitor.getCurrentUser());\n+                                    true, KeyguardUpdateMonitor.getCurrentUser(),\n+                                    SecurityMode.SimPin);\n                         } else {\n                             mShowDefaultMessage = false;\n                             if (result.getResult() == PinResult.PIN_RESULT_TYPE_INCORRECT) {\n",
    "added_lines": 2,
    "deleted_lines": 1,
    "changed_methods": "KeyguardSimPinViewController::verifyPasswordAndUnlock"
   },
   {
    "filename": "KeyguardSimPukViewController.java",
    "diff": "@@ -69,7 +69,8 @@ public class KeyguardSimPukViewController\n             if (simState == TelephonyManager.SIM_STATE_READY) {\n                 mRemainingAttempts = -1;\n                 mShowDefaultMessage = true;\n-                getKeyguardSecurityCallback().dismiss(true, KeyguardUpdateMonitor.getCurrentUser());\n+                getKeyguardSecurityCallback().dismiss(true, KeyguardUpdateMonitor.getCurrentUser(),\n+                        SecurityMode.SimPuk);\n             } else {\n                 resetState();\n             }\n@@ -274,7 +275,8 @@ public class KeyguardSimPukViewController\n                             mShowDefaultMessage = true;\n \n                             getKeyguardSecurityCallback().dismiss(\n-                                    true, KeyguardUpdateMonitor.getCurrentUser());\n+                                    true, KeyguardUpdateMonitor.getCurrentUser(),\n+                                    SecurityMode.SimPuk);\n                         } else {\n                             mShowDefaultMessage = false;\n                             if (result.getResult() == PinResult.PIN_RESULT_TYPE_INCORRECT) {\n",
    "added_lines": 4,
    "deleted_lines": 2,
    "changed_methods": "KeyguardSimPukViewController::KeyguardUpdateMonitorCallback, KeyguardSimPukViewController::updateSim"
   },
   {
    "filename": "AdminSecondaryLockScreenControllerTest.java",
    "diff": "@@ -44,6 +44,7 @@ import android.view.SurfaceView;\n \n import androidx.test.filters.SmallTest;\n \n+import com.android.keyguard.KeyguardSecurityModel.SecurityMode;\n import com.android.systemui.SysuiTestCase;\n \n import org.junit.After;\n@@ -190,7 +191,7 @@ public class AdminSecondaryLockScreenControllerTest extends SysuiTestCase {\n \n     private void verifyViewDismissed(SurfaceView v) throws Exception {\n         verify(mKeyguardSecurityContainer).removeView(v);\n-        verify(mKeyguardCallback).dismiss(true, TARGET_USER_ID, true);\n+        verify(mKeyguardCallback).dismiss(true, TARGET_USER_ID, true, SecurityMode.Invalid);\n         assertThat(mContext.isBound(mComponentName)).isFalse();\n     }\n }\n",
    "added_lines": 2,
    "deleted_lines": 1,
    "changed_methods": "AdminSecondaryLockScreenControllerTest::verifyViewDismissed"
   },
   {
    "filename": "KeyguardSecurityContainerControllerTest.java",
    "diff": "@@ -18,6 +18,8 @@ package com.android.keyguard;\n \n import static android.view.WindowInsets.Type.ime;\n \n+import static com.google.common.truth.Truth.assertThat;\n+\n import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.ArgumentMatchers.anyBoolean;\n import static org.mockito.ArgumentMatchers.anyInt;\n@@ -62,6 +64,7 @@ import org.mockito.junit.MockitoRule;\n @RunWith(AndroidTestingRunner.class)\n @TestableLooper.RunWithLooper()\n public class KeyguardSecurityContainerControllerTest extends SysuiTestCase {\n+    private static final int TARGET_USER_ID = 100;\n     private static final int VIEW_WIDTH = 1600;\n \n     @Rule\n@@ -330,4 +333,42 @@ public class KeyguardSecurityContainerControllerTest extends SysuiTestCase {\n                 R.bool.can_use_one_handed_bouncer))\n                 .thenReturn(sysuiResourceCanUseOneHandedKeyguard);\n     }\n+\n+    @Test\n+    public void showNextSecurityScreenOrFinish_setsSecurityScreenToPinAfterSimPinUnlock() {\n+        // GIVEN the current security method is SimPin\n+        when(mKeyguardUpdateMonitor.getUserHasTrust(anyInt())).thenReturn(false);\n+        when(mKeyguardUpdateMonitor.getUserUnlockedWithBiometric(TARGET_USER_ID)).thenReturn(false);\n+        mKeyguardSecurityContainerController.showSecurityScreen(SecurityMode.SimPin);\n+\n+        // WHEN a request is made from the SimPin screens to show the next security method\n+        when(mKeyguardSecurityModel.getSecurityMode(TARGET_USER_ID)).thenReturn(SecurityMode.PIN);\n+        mKeyguardSecurityContainerController.showNextSecurityScreenOrFinish(\n+                /* authenticated= */true,\n+                TARGET_USER_ID,\n+                /* bypassSecondaryLockScreen= */true,\n+                SecurityMode.SimPin);\n+\n+        // THEN the next security method of PIN is set, and the keyguard is not marked as done\n+        verify(mSecurityCallback, never()).finish(anyBoolean(), anyInt());\n+        assertThat(mKeyguardSecurityContainerController.getCurrentSecurityMode())\n+                .isEqualTo(SecurityMode.PIN);\n+    }\n+\n+    @Test\n+    public void showNextSecurityScreenOrFinish_ignoresCallWhenSecurityMethodHasChanged() {\n+        //GIVEN current security mode has been set to PIN\n+        mKeyguardSecurityContainerController.showSecurityScreen(SecurityMode.PIN);\n+\n+        //WHEN a request comes from SimPin to dismiss the security screens\n+        boolean keyguardDone = mKeyguardSecurityContainerController.showNextSecurityScreenOrFinish(\n+                /* authenticated= */true,\n+                TARGET_USER_ID,\n+                /* bypassSecondaryLockScreen= */true,\n+                SecurityMode.SimPin);\n+\n+        //THEN no action has happened, which will not dismiss the security screens\n+        assertThat(keyguardDone).isEqualTo(false);\n+        verify(mKeyguardUpdateMonitor, never()).getUserHasTrust(anyInt());\n+    }\n }\n",
    "added_lines": 41,
    "deleted_lines": 0,
    "changed_methods": "KeyguardSecurityContainerControllerTest::showNextSecurityScreenOrFinish_ignoresCallWhenSecurityMethodHasChanged, KeyguardSecurityContainerControllerTest::showNextSecurityScreenOrFinish_setsSecurityScreenToPinAfterSimPinUnlock"
   }
  ]
 },
 {
  "hash": "c0353314847735082aa8a51557361d2081f5cdbc",
  "commit": "[DO NOT MERGE] Do not dismiss keyguard after SIM PUK unlock\n\nAfter PUK unlock, multiple calls to\nKeyguardSecurityContainerController#dismiss() were being called from\nthe KeyguardSimPukViewController, which begins the transition to the\nnext security screen, if any. At the same time, other parts of the\nsystem, also listening to SIM events, recognize the PUK unlock and\ncall KeyguardSecurityContainer#showSecurityScreen, which updates which\nsecurity method comes next. After boot, this should be one of PIN,\nPassword, Pattern, assuming they have a security method. If one of the\nfirst dismiss() calls comes AFTER the security method changes, this is\nincorrectly recognized by the code as a successful\nPIN/pattern/password unlock. This causes the keyguard to be marked as\ndone, causing screen flickers and incorrect system state.\n\nThe solution: every call to dismiss() should include a new parameter\nfor the security method used. If there is a difference between this\nparameter and the current value in KeyguardSecurityContainerCallback,\nignore the request, as the system state has changed.\n\nFixes: 238804980\nBug: 218500036\nTest: atest KeyguardSecurityContainerTest\nAdminSecondaryLockScreenControllerTest KeyguardHostViewControllerTest\nKeyguardSecurityContainerControllerTest\n\nChange-Id: I7c8714a177bc85fbce92f6e8fe911f74ca2ac243\nMerged-In: I7c8714a177bc85fbce92f6e8fe911f74ca2ac243\n(cherry picked from commit 37aeb26b0ae28a48c1ed40f008d5808d8a84be23)\n(cherry picked from commit 1e7087f1136989b67c9b72c470617e5fb8c80501)\nMerged-In: I7c8714a177bc85fbce92f6e8fe911f74ca2ac243",
  "files": [
   {
    "filename": "AdminSecondaryLockScreenController.java",
    "diff": "@@ -33,6 +33,7 @@ import android.view.SurfaceView;\n import android.view.ViewGroup;\n \n import com.android.internal.annotations.VisibleForTesting;\n+import com.android.keyguard.KeyguardSecurityModel.SecurityMode;\n import com.android.keyguard.dagger.KeyguardBouncerScope;\n import com.android.systemui.dagger.qualifiers.Main;\n \n@@ -208,7 +209,7 @@ public class AdminSecondaryLockScreenController {\n             hide();\n             if (mKeyguardCallback != null) {\n                 mKeyguardCallback.dismiss(/* securityVerified= */ true, userId,\n-                        /* bypassSecondaryLockScreen= */true);\n+                        /* bypassSecondaryLockScreen= */true, SecurityMode.Invalid);\n             }\n         }\n     }\n",
    "added_lines": 2,
    "deleted_lines": 1,
    "changed_methods": "AdminSecondaryLockScreenController::dismiss"
   },
   {
    "filename": "KeyguardAbsKeyInputViewController.java",
    "diff": "@@ -174,7 +174,7 @@ public abstract class KeyguardAbsKeyInputViewController<T extends KeyguardAbsKey\n             if (dismissKeyguard) {\n                 mDismissing = true;\n                 mLatencyTracker.onActionStart(LatencyTracker.ACTION_LOCKSCREEN_UNLOCK);\n-                getKeyguardSecurityCallback().dismiss(true, userId);\n+                getKeyguardSecurityCallback().dismiss(true, userId, getSecurityMode());\n             }\n         } else {\n             if (isValidPassword) {\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "KeyguardAbsKeyInputViewController::onPasswordChecked"
   },
   {
    "filename": "KeyguardHostViewController.java",
    "diff": "@@ -93,7 +93,7 @@ public class KeyguardHostViewController extends ViewController<KeyguardHostView>\n                                 Log.i(TAG, \"TrustAgent dismissed Keyguard.\");\n                             }\n                             mSecurityCallback.dismiss(false /* authenticated */, userId,\n-                                    /* bypassSecondaryLockScreen */ false);\n+                                    /* bypassSecondaryLockScreen */ false, SecurityMode.Invalid);\n                         } else {\n                             mViewMediatorCallback.playTrustedSound();\n                         }\n@@ -105,9 +105,9 @@ public class KeyguardHostViewController extends ViewController<KeyguardHostView>\n \n         @Override\n         public boolean dismiss(boolean authenticated, int targetUserId,\n-                boolean bypassSecondaryLockScreen) {\n+                boolean bypassSecondaryLockScreen, SecurityMode expectedSecurityMode) {\n             return mKeyguardSecurityContainerController.showNextSecurityScreenOrFinish(\n-                    authenticated, targetUserId, bypassSecondaryLockScreen);\n+                    authenticated, targetUserId, bypassSecondaryLockScreen, expectedSecurityMode);\n         }\n \n         @Override\n@@ -215,7 +215,8 @@ public class KeyguardHostViewController extends ViewController<KeyguardHostView>\n      * @return True if the keyguard is done.\n      */\n     public boolean dismiss(int targetUserId) {\n-        return mSecurityCallback.dismiss(false, targetUserId, false);\n+        return mSecurityCallback.dismiss(false, targetUserId, false,\n+                getCurrentSecurityMode());\n     }\n \n     /**\n@@ -356,10 +357,10 @@ public class KeyguardHostViewController extends ViewController<KeyguardHostView>\n     }\n \n     public boolean handleBackKey() {\n-        if (mKeyguardSecurityContainerController.getCurrentSecurityMode()\n-                != SecurityMode.None) {\n+        SecurityMode securityMode = mKeyguardSecurityContainerController.getCurrentSecurityMode();\n+        if (securityMode != SecurityMode.None) {\n             mKeyguardSecurityContainerController.dismiss(\n-                    false, KeyguardUpdateMonitor.getCurrentUser());\n+                    false, KeyguardUpdateMonitor.getCurrentUser(), securityMode);\n             return true;\n         }\n         return false;\n",
    "added_lines": 8,
    "deleted_lines": 7,
    "changed_methods": "KeyguardHostViewController::SecurityCallback, KeyguardHostViewController::handleBackKey, KeyguardHostViewController::KeyguardUpdateMonitorCallback, KeyguardHostViewController::dismiss"
   },
   {
    "filename": "KeyguardInputViewController.java",
    "diff": "@@ -59,10 +59,11 @@ public abstract class KeyguardInputViewController<T extends KeyguardInputView>\n             return false;\n         }\n         @Override\n-        public void dismiss(boolean securityVerified, int targetUserId) { }\n+        public void dismiss(boolean securityVerified, int targetUserId,\n+                SecurityMode expectedSecurityMode) { }\n         @Override\n         public void dismiss(boolean authenticated, int targetId,\n-                boolean bypassSecondaryLockScreen) { }\n+                boolean bypassSecondaryLockScreen, SecurityMode expectedSecurityMode) { }\n         @Override\n         public void onUserInput() { }\n         @Override\n",
    "added_lines": 3,
    "deleted_lines": 2,
    "changed_methods": "KeyguardInputViewController::KeyguardSecurityCallback"
   },
   {
    "filename": "KeyguardPatternViewController.java",
    "diff": "@@ -170,7 +170,7 @@ public class KeyguardPatternViewController\n                 if (dismissKeyguard) {\n                     mLockPatternView.setDisplayMode(LockPatternView.DisplayMode.Correct);\n                     mLatencyTracker.onActionStart(LatencyTracker.ACTION_LOCKSCREEN_UNLOCK);\n-                    getKeyguardSecurityCallback().dismiss(true, userId);\n+                    getKeyguardSecurityCallback().dismiss(true, userId, SecurityMode.Pattern);\n                 }\n             } else {\n                 mLockPatternView.setDisplayMode(LockPatternView.DisplayMode.Wrong);\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "KeyguardPatternViewController::UnlockPatternListener::onPatternChecked"
   },
   {
    "filename": "KeyguardSecurityCallback.java",
    "diff": "@@ -15,14 +15,17 @@\n  */\n package com.android.keyguard;\n \n+import com.android.keyguard.KeyguardSecurityModel.SecurityMode;\n+\n public interface KeyguardSecurityCallback {\n \n     /**\n      * Dismiss the given security screen.\n      * @param securityVerified true if the user correctly entered credentials for the given screen.\n      * @param targetUserId a user that needs to be the foreground user at the dismissal completion.\n+     * @param expectedSecurityMode The security mode that is invoking this dismiss.\n      */\n-    void dismiss(boolean securityVerified, int targetUserId);\n+    void dismiss(boolean securityVerified, int targetUserId, SecurityMode expectedSecurityMode);\n \n     /**\n      * Dismiss the given security screen.\n@@ -30,8 +33,10 @@ public interface KeyguardSecurityCallback {\n      * @param targetUserId a user that needs to be the foreground user at the dismissal completion.\n      * @param bypassSecondaryLockScreen true if the user can bypass the secondary lock screen,\n      *                                  if any, during this dismissal.\n+     * @param expectedSecurityMode The security mode that is invoking this dismiss.\n      */\n-    void dismiss(boolean securityVerified, int targetUserId, boolean bypassSecondaryLockScreen);\n+    void dismiss(boolean securityVerified, int targetUserId, boolean bypassSecondaryLockScreen,\n+            SecurityMode expectedSecurityMode);\n \n     /**\n      * Manually report user activity to keep the device awake.\n",
    "added_lines": 7,
    "deleted_lines": 2,
    "changed_methods": ""
   },
   {
    "filename": "KeyguardSecurityContainer.java",
    "diff": "@@ -181,7 +181,12 @@ public class KeyguardSecurityContainer extends FrameLayout {\n \n     // Used to notify the container when something interesting happens.\n     public interface SecurityCallback {\n-        boolean dismiss(boolean authenticated, int targetUserId, boolean bypassSecondaryLockScreen);\n+        /**\n+         * Potentially dismiss the current security screen, after validating that all device\n+         * security has been unlocked. Otherwise show the next screen.\n+         */\n+        boolean dismiss(boolean authenticated, int targetUserId, boolean bypassSecondaryLockScreen,\n+                SecurityMode expectedSecurityMode);\n \n         void userActivity();\n \n",
    "added_lines": 6,
    "deleted_lines": 1,
    "changed_methods": ""
   },
   {
    "filename": "KeyguardSecurityContainerController.java",
    "diff": "@@ -136,14 +136,17 @@ public class KeyguardSecurityContainerController extends ViewController<Keyguard\n         }\n \n         @Override\n-        public void dismiss(boolean authenticated, int targetId) {\n-            dismiss(authenticated, targetId, /* bypassSecondaryLockScreen */ false);\n+        public void dismiss(boolean authenticated, int targetId,\n+                SecurityMode expectedSecurityMode) {\n+            dismiss(authenticated, targetId, /* bypassSecondaryLockScreen */ false,\n+                    expectedSecurityMode);\n         }\n \n         @Override\n         public void dismiss(boolean authenticated, int targetId,\n-                boolean bypassSecondaryLockScreen) {\n-            mSecurityCallback.dismiss(authenticated, targetId, bypassSecondaryLockScreen);\n+                boolean bypassSecondaryLockScreen, SecurityMode expectedSecurityMode) {\n+            mSecurityCallback.dismiss(authenticated, targetId, bypassSecondaryLockScreen,\n+                    expectedSecurityMode);\n         }\n \n         public boolean isVerifyUnlockOnly() {\n@@ -307,8 +310,13 @@ public class KeyguardSecurityContainerController extends ViewController<Keyguard\n         return mCurrentSecurityMode;\n     }\n \n-    public void dismiss(boolean authenticated, int targetUserId) {\n-        mKeyguardSecurityCallback.dismiss(authenticated, targetUserId);\n+    /**\n+     * Potentially dismiss the current security screen, after validating that all device\n+     * security has been unlocked. Otherwise show the next screen.\n+     */\n+    public void dismiss(boolean authenticated, int targetUserId,\n+            SecurityMode expectedSecurityMode) {\n+        mKeyguardSecurityCallback.dismiss(authenticated, targetUserId, expectedSecurityMode);\n     }\n \n     public void reset() {\n@@ -367,12 +375,21 @@ public class KeyguardSecurityContainerController extends ViewController<Keyguard\n      *     completion.\n      * @param bypassSecondaryLockScreen true if the user is allowed to bypass the secondary\n      *     secondary lock screen requirement, if any.\n+     * @param expectedSecurityMode SecurityMode that is invoking this request. SecurityMode.Invalid\n+     *      indicates that no check should be done\n      * @return true if keyguard is done\n      */\n     public boolean showNextSecurityScreenOrFinish(boolean authenticated, int targetUserId,\n-            boolean bypassSecondaryLockScreen) {\n+            boolean bypassSecondaryLockScreen, SecurityMode expectedSecurityMode) {\n \n         if (DEBUG) Log.d(TAG, \"showNextSecurityScreenOrFinish(\" + authenticated + \")\");\n+        if (expectedSecurityMode != SecurityMode.Invalid\n+                && expectedSecurityMode != getCurrentSecurityMode()) {\n+            Log.w(TAG, \"Attempted to invoke showNextSecurityScreenOrFinish with securityMode \"\n+                    + expectedSecurityMode + \", but current mode is \" + getCurrentSecurityMode());\n+            return false;\n+        }\n+\n         boolean finish = false;\n         boolean strongAuth = false;\n         int eventSubtype = -1;\n",
    "added_lines": 24,
    "deleted_lines": 7,
    "changed_methods": "KeyguardSecurityContainerController::showNextSecurityScreenOrFinish, KeyguardSecurityContainerController::showNextSecurityScreenOrFinish, KeyguardSecurityContainerController::dismiss, KeyguardSecurityContainerController::KeyguardSecurityCallback, KeyguardSecurityContainerController::dismiss"
   },
   {
    "filename": "KeyguardSimPinViewController.java",
    "diff": "@@ -162,7 +162,8 @@ public class KeyguardSimPinViewController\n                             mRemainingAttempts = -1;\n                             mShowDefaultMessage = true;\n                             getKeyguardSecurityCallback().dismiss(\n-                                    true, KeyguardUpdateMonitor.getCurrentUser());\n+                                    true, KeyguardUpdateMonitor.getCurrentUser(),\n+                                    SecurityMode.SimPin);\n                         } else {\n                             mShowDefaultMessage = false;\n                             if (result.getResult() == PinResult.PIN_RESULT_TYPE_INCORRECT) {\n",
    "added_lines": 2,
    "deleted_lines": 1,
    "changed_methods": "KeyguardSimPinViewController::verifyPasswordAndUnlock"
   },
   {
    "filename": "KeyguardSimPukViewController.java",
    "diff": "@@ -69,7 +69,8 @@ public class KeyguardSimPukViewController\n             if (simState == TelephonyManager.SIM_STATE_READY) {\n                 mRemainingAttempts = -1;\n                 mShowDefaultMessage = true;\n-                getKeyguardSecurityCallback().dismiss(true, KeyguardUpdateMonitor.getCurrentUser());\n+                getKeyguardSecurityCallback().dismiss(true, KeyguardUpdateMonitor.getCurrentUser(),\n+                        SecurityMode.SimPuk);\n             } else {\n                 resetState();\n             }\n@@ -274,7 +275,8 @@ public class KeyguardSimPukViewController\n                             mShowDefaultMessage = true;\n \n                             getKeyguardSecurityCallback().dismiss(\n-                                    true, KeyguardUpdateMonitor.getCurrentUser());\n+                                    true, KeyguardUpdateMonitor.getCurrentUser(),\n+                                    SecurityMode.SimPuk);\n                         } else {\n                             mShowDefaultMessage = false;\n                             if (result.getResult() == PinResult.PIN_RESULT_TYPE_INCORRECT) {\n",
    "added_lines": 4,
    "deleted_lines": 2,
    "changed_methods": "KeyguardSimPukViewController::KeyguardUpdateMonitorCallback, KeyguardSimPukViewController::updateSim"
   },
   {
    "filename": "AdminSecondaryLockScreenControllerTest.java",
    "diff": "@@ -44,6 +44,7 @@ import android.view.SurfaceView;\n \n import androidx.test.filters.SmallTest;\n \n+import com.android.keyguard.KeyguardSecurityModel.SecurityMode;\n import com.android.systemui.SysuiTestCase;\n \n import org.junit.After;\n@@ -190,7 +191,7 @@ public class AdminSecondaryLockScreenControllerTest extends SysuiTestCase {\n \n     private void verifyViewDismissed(SurfaceView v) throws Exception {\n         verify(mKeyguardSecurityContainer).removeView(v);\n-        verify(mKeyguardCallback).dismiss(true, TARGET_USER_ID, true);\n+        verify(mKeyguardCallback).dismiss(true, TARGET_USER_ID, true, SecurityMode.Invalid);\n         assertThat(mContext.isBound(mComponentName)).isFalse();\n     }\n }\n",
    "added_lines": 2,
    "deleted_lines": 1,
    "changed_methods": "AdminSecondaryLockScreenControllerTest::verifyViewDismissed"
   },
   {
    "filename": "KeyguardSecurityContainerControllerTest.java",
    "diff": "@@ -18,6 +18,8 @@ package com.android.keyguard;\n \n import static android.view.WindowInsets.Type.ime;\n \n+import static com.google.common.truth.Truth.assertThat;\n+\n import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.ArgumentMatchers.anyBoolean;\n import static org.mockito.ArgumentMatchers.anyInt;\n@@ -62,6 +64,7 @@ import org.mockito.junit.MockitoRule;\n @RunWith(AndroidTestingRunner.class)\n @TestableLooper.RunWithLooper()\n public class KeyguardSecurityContainerControllerTest extends SysuiTestCase {\n+    private static final int TARGET_USER_ID = 100;\n     private static final int VIEW_WIDTH = 1600;\n \n     @Rule\n@@ -330,4 +333,42 @@ public class KeyguardSecurityContainerControllerTest extends SysuiTestCase {\n                 R.bool.can_use_one_handed_bouncer))\n                 .thenReturn(sysuiResourceCanUseOneHandedKeyguard);\n     }\n+\n+    @Test\n+    public void showNextSecurityScreenOrFinish_setsSecurityScreenToPinAfterSimPinUnlock() {\n+        // GIVEN the current security method is SimPin\n+        when(mKeyguardUpdateMonitor.getUserHasTrust(anyInt())).thenReturn(false);\n+        when(mKeyguardUpdateMonitor.getUserUnlockedWithBiometric(TARGET_USER_ID)).thenReturn(false);\n+        mKeyguardSecurityContainerController.showSecurityScreen(SecurityMode.SimPin);\n+\n+        // WHEN a request is made from the SimPin screens to show the next security method\n+        when(mKeyguardSecurityModel.getSecurityMode(TARGET_USER_ID)).thenReturn(SecurityMode.PIN);\n+        mKeyguardSecurityContainerController.showNextSecurityScreenOrFinish(\n+                /* authenticated= */true,\n+                TARGET_USER_ID,\n+                /* bypassSecondaryLockScreen= */true,\n+                SecurityMode.SimPin);\n+\n+        // THEN the next security method of PIN is set, and the keyguard is not marked as done\n+        verify(mSecurityCallback, never()).finish(anyBoolean(), anyInt());\n+        assertThat(mKeyguardSecurityContainerController.getCurrentSecurityMode())\n+                .isEqualTo(SecurityMode.PIN);\n+    }\n+\n+    @Test\n+    public void showNextSecurityScreenOrFinish_ignoresCallWhenSecurityMethodHasChanged() {\n+        //GIVEN current security mode has been set to PIN\n+        mKeyguardSecurityContainerController.showSecurityScreen(SecurityMode.PIN);\n+\n+        //WHEN a request comes from SimPin to dismiss the security screens\n+        boolean keyguardDone = mKeyguardSecurityContainerController.showNextSecurityScreenOrFinish(\n+                /* authenticated= */true,\n+                TARGET_USER_ID,\n+                /* bypassSecondaryLockScreen= */true,\n+                SecurityMode.SimPin);\n+\n+        //THEN no action has happened, which will not dismiss the security screens\n+        assertThat(keyguardDone).isEqualTo(false);\n+        verify(mKeyguardUpdateMonitor, never()).getUserHasTrust(anyInt());\n+    }\n }\n",
    "added_lines": 41,
    "deleted_lines": 0,
    "changed_methods": "KeyguardSecurityContainerControllerTest::showNextSecurityScreenOrFinish_ignoresCallWhenSecurityMethodHasChanged, KeyguardSecurityContainerControllerTest::showNextSecurityScreenOrFinish_setsSecurityScreenToPinAfterSimPinUnlock"
   }
  ]
 },
 {
  "hash": "c0353314847735082aa8a51557361d2081f5cdbc",
  "commit": "[DO NOT MERGE] Do not dismiss keyguard after SIM PUK unlock\n\nAfter PUK unlock, multiple calls to\nKeyguardSecurityContainerController#dismiss() were being called from\nthe KeyguardSimPukViewController, which begins the transition to the\nnext security screen, if any. At the same time, other parts of the\nsystem, also listening to SIM events, recognize the PUK unlock and\ncall KeyguardSecurityContainer#showSecurityScreen, which updates which\nsecurity method comes next. After boot, this should be one of PIN,\nPassword, Pattern, assuming they have a security method. If one of the\nfirst dismiss() calls comes AFTER the security method changes, this is\nincorrectly recognized by the code as a successful\nPIN/pattern/password unlock. This causes the keyguard to be marked as\ndone, causing screen flickers and incorrect system state.\n\nThe solution: every call to dismiss() should include a new parameter\nfor the security method used. If there is a difference between this\nparameter and the current value in KeyguardSecurityContainerCallback,\nignore the request, as the system state has changed.\n\nFixes: 238804980\nBug: 218500036\nTest: atest KeyguardSecurityContainerTest\nAdminSecondaryLockScreenControllerTest KeyguardHostViewControllerTest\nKeyguardSecurityContainerControllerTest\n\nChange-Id: I7c8714a177bc85fbce92f6e8fe911f74ca2ac243\nMerged-In: I7c8714a177bc85fbce92f6e8fe911f74ca2ac243\n(cherry picked from commit 37aeb26b0ae28a48c1ed40f008d5808d8a84be23)\n(cherry picked from commit 1e7087f1136989b67c9b72c470617e5fb8c80501)\nMerged-In: I7c8714a177bc85fbce92f6e8fe911f74ca2ac243",
  "files": [
   {
    "filename": "AdminSecondaryLockScreenController.java",
    "diff": "@@ -33,6 +33,7 @@ import android.view.SurfaceView;\n import android.view.ViewGroup;\n \n import com.android.internal.annotations.VisibleForTesting;\n+import com.android.keyguard.KeyguardSecurityModel.SecurityMode;\n import com.android.keyguard.dagger.KeyguardBouncerScope;\n import com.android.systemui.dagger.qualifiers.Main;\n \n@@ -208,7 +209,7 @@ public class AdminSecondaryLockScreenController {\n             hide();\n             if (mKeyguardCallback != null) {\n                 mKeyguardCallback.dismiss(/* securityVerified= */ true, userId,\n-                        /* bypassSecondaryLockScreen= */true);\n+                        /* bypassSecondaryLockScreen= */true, SecurityMode.Invalid);\n             }\n         }\n     }\n",
    "added_lines": 2,
    "deleted_lines": 1,
    "changed_methods": "AdminSecondaryLockScreenController::dismiss"
   },
   {
    "filename": "KeyguardAbsKeyInputViewController.java",
    "diff": "@@ -174,7 +174,7 @@ public abstract class KeyguardAbsKeyInputViewController<T extends KeyguardAbsKey\n             if (dismissKeyguard) {\n                 mDismissing = true;\n                 mLatencyTracker.onActionStart(LatencyTracker.ACTION_LOCKSCREEN_UNLOCK);\n-                getKeyguardSecurityCallback().dismiss(true, userId);\n+                getKeyguardSecurityCallback().dismiss(true, userId, getSecurityMode());\n             }\n         } else {\n             if (isValidPassword) {\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "KeyguardAbsKeyInputViewController::onPasswordChecked"
   },
   {
    "filename": "KeyguardHostViewController.java",
    "diff": "@@ -93,7 +93,7 @@ public class KeyguardHostViewController extends ViewController<KeyguardHostView>\n                                 Log.i(TAG, \"TrustAgent dismissed Keyguard.\");\n                             }\n                             mSecurityCallback.dismiss(false /* authenticated */, userId,\n-                                    /* bypassSecondaryLockScreen */ false);\n+                                    /* bypassSecondaryLockScreen */ false, SecurityMode.Invalid);\n                         } else {\n                             mViewMediatorCallback.playTrustedSound();\n                         }\n@@ -105,9 +105,9 @@ public class KeyguardHostViewController extends ViewController<KeyguardHostView>\n \n         @Override\n         public boolean dismiss(boolean authenticated, int targetUserId,\n-                boolean bypassSecondaryLockScreen) {\n+                boolean bypassSecondaryLockScreen, SecurityMode expectedSecurityMode) {\n             return mKeyguardSecurityContainerController.showNextSecurityScreenOrFinish(\n-                    authenticated, targetUserId, bypassSecondaryLockScreen);\n+                    authenticated, targetUserId, bypassSecondaryLockScreen, expectedSecurityMode);\n         }\n \n         @Override\n@@ -215,7 +215,8 @@ public class KeyguardHostViewController extends ViewController<KeyguardHostView>\n      * @return True if the keyguard is done.\n      */\n     public boolean dismiss(int targetUserId) {\n-        return mSecurityCallback.dismiss(false, targetUserId, false);\n+        return mSecurityCallback.dismiss(false, targetUserId, false,\n+                getCurrentSecurityMode());\n     }\n \n     /**\n@@ -356,10 +357,10 @@ public class KeyguardHostViewController extends ViewController<KeyguardHostView>\n     }\n \n     public boolean handleBackKey() {\n-        if (mKeyguardSecurityContainerController.getCurrentSecurityMode()\n-                != SecurityMode.None) {\n+        SecurityMode securityMode = mKeyguardSecurityContainerController.getCurrentSecurityMode();\n+        if (securityMode != SecurityMode.None) {\n             mKeyguardSecurityContainerController.dismiss(\n-                    false, KeyguardUpdateMonitor.getCurrentUser());\n+                    false, KeyguardUpdateMonitor.getCurrentUser(), securityMode);\n             return true;\n         }\n         return false;\n",
    "added_lines": 8,
    "deleted_lines": 7,
    "changed_methods": "KeyguardHostViewController::SecurityCallback, KeyguardHostViewController::handleBackKey, KeyguardHostViewController::KeyguardUpdateMonitorCallback, KeyguardHostViewController::dismiss"
   },
   {
    "filename": "KeyguardInputViewController.java",
    "diff": "@@ -59,10 +59,11 @@ public abstract class KeyguardInputViewController<T extends KeyguardInputView>\n             return false;\n         }\n         @Override\n-        public void dismiss(boolean securityVerified, int targetUserId) { }\n+        public void dismiss(boolean securityVerified, int targetUserId,\n+                SecurityMode expectedSecurityMode) { }\n         @Override\n         public void dismiss(boolean authenticated, int targetId,\n-                boolean bypassSecondaryLockScreen) { }\n+                boolean bypassSecondaryLockScreen, SecurityMode expectedSecurityMode) { }\n         @Override\n         public void onUserInput() { }\n         @Override\n",
    "added_lines": 3,
    "deleted_lines": 2,
    "changed_methods": "KeyguardInputViewController::KeyguardSecurityCallback"
   },
   {
    "filename": "KeyguardPatternViewController.java",
    "diff": "@@ -170,7 +170,7 @@ public class KeyguardPatternViewController\n                 if (dismissKeyguard) {\n                     mLockPatternView.setDisplayMode(LockPatternView.DisplayMode.Correct);\n                     mLatencyTracker.onActionStart(LatencyTracker.ACTION_LOCKSCREEN_UNLOCK);\n-                    getKeyguardSecurityCallback().dismiss(true, userId);\n+                    getKeyguardSecurityCallback().dismiss(true, userId, SecurityMode.Pattern);\n                 }\n             } else {\n                 mLockPatternView.setDisplayMode(LockPatternView.DisplayMode.Wrong);\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "KeyguardPatternViewController::UnlockPatternListener::onPatternChecked"
   },
   {
    "filename": "KeyguardSecurityCallback.java",
    "diff": "@@ -15,14 +15,17 @@\n  */\n package com.android.keyguard;\n \n+import com.android.keyguard.KeyguardSecurityModel.SecurityMode;\n+\n public interface KeyguardSecurityCallback {\n \n     /**\n      * Dismiss the given security screen.\n      * @param securityVerified true if the user correctly entered credentials for the given screen.\n      * @param targetUserId a user that needs to be the foreground user at the dismissal completion.\n+     * @param expectedSecurityMode The security mode that is invoking this dismiss.\n      */\n-    void dismiss(boolean securityVerified, int targetUserId);\n+    void dismiss(boolean securityVerified, int targetUserId, SecurityMode expectedSecurityMode);\n \n     /**\n      * Dismiss the given security screen.\n@@ -30,8 +33,10 @@ public interface KeyguardSecurityCallback {\n      * @param targetUserId a user that needs to be the foreground user at the dismissal completion.\n      * @param bypassSecondaryLockScreen true if the user can bypass the secondary lock screen,\n      *                                  if any, during this dismissal.\n+     * @param expectedSecurityMode The security mode that is invoking this dismiss.\n      */\n-    void dismiss(boolean securityVerified, int targetUserId, boolean bypassSecondaryLockScreen);\n+    void dismiss(boolean securityVerified, int targetUserId, boolean bypassSecondaryLockScreen,\n+            SecurityMode expectedSecurityMode);\n \n     /**\n      * Manually report user activity to keep the device awake.\n",
    "added_lines": 7,
    "deleted_lines": 2,
    "changed_methods": ""
   },
   {
    "filename": "KeyguardSecurityContainer.java",
    "diff": "@@ -181,7 +181,12 @@ public class KeyguardSecurityContainer extends FrameLayout {\n \n     // Used to notify the container when something interesting happens.\n     public interface SecurityCallback {\n-        boolean dismiss(boolean authenticated, int targetUserId, boolean bypassSecondaryLockScreen);\n+        /**\n+         * Potentially dismiss the current security screen, after validating that all device\n+         * security has been unlocked. Otherwise show the next screen.\n+         */\n+        boolean dismiss(boolean authenticated, int targetUserId, boolean bypassSecondaryLockScreen,\n+                SecurityMode expectedSecurityMode);\n \n         void userActivity();\n \n",
    "added_lines": 6,
    "deleted_lines": 1,
    "changed_methods": ""
   },
   {
    "filename": "KeyguardSecurityContainerController.java",
    "diff": "@@ -136,14 +136,17 @@ public class KeyguardSecurityContainerController extends ViewController<Keyguard\n         }\n \n         @Override\n-        public void dismiss(boolean authenticated, int targetId) {\n-            dismiss(authenticated, targetId, /* bypassSecondaryLockScreen */ false);\n+        public void dismiss(boolean authenticated, int targetId,\n+                SecurityMode expectedSecurityMode) {\n+            dismiss(authenticated, targetId, /* bypassSecondaryLockScreen */ false,\n+                    expectedSecurityMode);\n         }\n \n         @Override\n         public void dismiss(boolean authenticated, int targetId,\n-                boolean bypassSecondaryLockScreen) {\n-            mSecurityCallback.dismiss(authenticated, targetId, bypassSecondaryLockScreen);\n+                boolean bypassSecondaryLockScreen, SecurityMode expectedSecurityMode) {\n+            mSecurityCallback.dismiss(authenticated, targetId, bypassSecondaryLockScreen,\n+                    expectedSecurityMode);\n         }\n \n         public boolean isVerifyUnlockOnly() {\n@@ -307,8 +310,13 @@ public class KeyguardSecurityContainerController extends ViewController<Keyguard\n         return mCurrentSecurityMode;\n     }\n \n-    public void dismiss(boolean authenticated, int targetUserId) {\n-        mKeyguardSecurityCallback.dismiss(authenticated, targetUserId);\n+    /**\n+     * Potentially dismiss the current security screen, after validating that all device\n+     * security has been unlocked. Otherwise show the next screen.\n+     */\n+    public void dismiss(boolean authenticated, int targetUserId,\n+            SecurityMode expectedSecurityMode) {\n+        mKeyguardSecurityCallback.dismiss(authenticated, targetUserId, expectedSecurityMode);\n     }\n \n     public void reset() {\n@@ -367,12 +375,21 @@ public class KeyguardSecurityContainerController extends ViewController<Keyguard\n      *     completion.\n      * @param bypassSecondaryLockScreen true if the user is allowed to bypass the secondary\n      *     secondary lock screen requirement, if any.\n+     * @param expectedSecurityMode SecurityMode that is invoking this request. SecurityMode.Invalid\n+     *      indicates that no check should be done\n      * @return true if keyguard is done\n      */\n     public boolean showNextSecurityScreenOrFinish(boolean authenticated, int targetUserId,\n-            boolean bypassSecondaryLockScreen) {\n+            boolean bypassSecondaryLockScreen, SecurityMode expectedSecurityMode) {\n \n         if (DEBUG) Log.d(TAG, \"showNextSecurityScreenOrFinish(\" + authenticated + \")\");\n+        if (expectedSecurityMode != SecurityMode.Invalid\n+                && expectedSecurityMode != getCurrentSecurityMode()) {\n+            Log.w(TAG, \"Attempted to invoke showNextSecurityScreenOrFinish with securityMode \"\n+                    + expectedSecurityMode + \", but current mode is \" + getCurrentSecurityMode());\n+            return false;\n+        }\n+\n         boolean finish = false;\n         boolean strongAuth = false;\n         int eventSubtype = -1;\n",
    "added_lines": 24,
    "deleted_lines": 7,
    "changed_methods": "KeyguardSecurityContainerController::showNextSecurityScreenOrFinish, KeyguardSecurityContainerController::showNextSecurityScreenOrFinish, KeyguardSecurityContainerController::dismiss, KeyguardSecurityContainerController::KeyguardSecurityCallback, KeyguardSecurityContainerController::dismiss"
   },
   {
    "filename": "KeyguardSimPinViewController.java",
    "diff": "@@ -162,7 +162,8 @@ public class KeyguardSimPinViewController\n                             mRemainingAttempts = -1;\n                             mShowDefaultMessage = true;\n                             getKeyguardSecurityCallback().dismiss(\n-                                    true, KeyguardUpdateMonitor.getCurrentUser());\n+                                    true, KeyguardUpdateMonitor.getCurrentUser(),\n+                                    SecurityMode.SimPin);\n                         } else {\n                             mShowDefaultMessage = false;\n                             if (result.getResult() == PinResult.PIN_RESULT_TYPE_INCORRECT) {\n",
    "added_lines": 2,
    "deleted_lines": 1,
    "changed_methods": "KeyguardSimPinViewController::verifyPasswordAndUnlock"
   },
   {
    "filename": "KeyguardSimPukViewController.java",
    "diff": "@@ -69,7 +69,8 @@ public class KeyguardSimPukViewController\n             if (simState == TelephonyManager.SIM_STATE_READY) {\n                 mRemainingAttempts = -1;\n                 mShowDefaultMessage = true;\n-                getKeyguardSecurityCallback().dismiss(true, KeyguardUpdateMonitor.getCurrentUser());\n+                getKeyguardSecurityCallback().dismiss(true, KeyguardUpdateMonitor.getCurrentUser(),\n+                        SecurityMode.SimPuk);\n             } else {\n                 resetState();\n             }\n@@ -274,7 +275,8 @@ public class KeyguardSimPukViewController\n                             mShowDefaultMessage = true;\n \n                             getKeyguardSecurityCallback().dismiss(\n-                                    true, KeyguardUpdateMonitor.getCurrentUser());\n+                                    true, KeyguardUpdateMonitor.getCurrentUser(),\n+                                    SecurityMode.SimPuk);\n                         } else {\n                             mShowDefaultMessage = false;\n                             if (result.getResult() == PinResult.PIN_RESULT_TYPE_INCORRECT) {\n",
    "added_lines": 4,
    "deleted_lines": 2,
    "changed_methods": "KeyguardSimPukViewController::KeyguardUpdateMonitorCallback, KeyguardSimPukViewController::updateSim"
   },
   {
    "filename": "AdminSecondaryLockScreenControllerTest.java",
    "diff": "@@ -44,6 +44,7 @@ import android.view.SurfaceView;\n \n import androidx.test.filters.SmallTest;\n \n+import com.android.keyguard.KeyguardSecurityModel.SecurityMode;\n import com.android.systemui.SysuiTestCase;\n \n import org.junit.After;\n@@ -190,7 +191,7 @@ public class AdminSecondaryLockScreenControllerTest extends SysuiTestCase {\n \n     private void verifyViewDismissed(SurfaceView v) throws Exception {\n         verify(mKeyguardSecurityContainer).removeView(v);\n-        verify(mKeyguardCallback).dismiss(true, TARGET_USER_ID, true);\n+        verify(mKeyguardCallback).dismiss(true, TARGET_USER_ID, true, SecurityMode.Invalid);\n         assertThat(mContext.isBound(mComponentName)).isFalse();\n     }\n }\n",
    "added_lines": 2,
    "deleted_lines": 1,
    "changed_methods": "AdminSecondaryLockScreenControllerTest::verifyViewDismissed"
   },
   {
    "filename": "KeyguardSecurityContainerControllerTest.java",
    "diff": "@@ -18,6 +18,8 @@ package com.android.keyguard;\n \n import static android.view.WindowInsets.Type.ime;\n \n+import static com.google.common.truth.Truth.assertThat;\n+\n import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.ArgumentMatchers.anyBoolean;\n import static org.mockito.ArgumentMatchers.anyInt;\n@@ -62,6 +64,7 @@ import org.mockito.junit.MockitoRule;\n @RunWith(AndroidTestingRunner.class)\n @TestableLooper.RunWithLooper()\n public class KeyguardSecurityContainerControllerTest extends SysuiTestCase {\n+    private static final int TARGET_USER_ID = 100;\n     private static final int VIEW_WIDTH = 1600;\n \n     @Rule\n@@ -330,4 +333,42 @@ public class KeyguardSecurityContainerControllerTest extends SysuiTestCase {\n                 R.bool.can_use_one_handed_bouncer))\n                 .thenReturn(sysuiResourceCanUseOneHandedKeyguard);\n     }\n+\n+    @Test\n+    public void showNextSecurityScreenOrFinish_setsSecurityScreenToPinAfterSimPinUnlock() {\n+        // GIVEN the current security method is SimPin\n+        when(mKeyguardUpdateMonitor.getUserHasTrust(anyInt())).thenReturn(false);\n+        when(mKeyguardUpdateMonitor.getUserUnlockedWithBiometric(TARGET_USER_ID)).thenReturn(false);\n+        mKeyguardSecurityContainerController.showSecurityScreen(SecurityMode.SimPin);\n+\n+        // WHEN a request is made from the SimPin screens to show the next security method\n+        when(mKeyguardSecurityModel.getSecurityMode(TARGET_USER_ID)).thenReturn(SecurityMode.PIN);\n+        mKeyguardSecurityContainerController.showNextSecurityScreenOrFinish(\n+                /* authenticated= */true,\n+                TARGET_USER_ID,\n+                /* bypassSecondaryLockScreen= */true,\n+                SecurityMode.SimPin);\n+\n+        // THEN the next security method of PIN is set, and the keyguard is not marked as done\n+        verify(mSecurityCallback, never()).finish(anyBoolean(), anyInt());\n+        assertThat(mKeyguardSecurityContainerController.getCurrentSecurityMode())\n+                .isEqualTo(SecurityMode.PIN);\n+    }\n+\n+    @Test\n+    public void showNextSecurityScreenOrFinish_ignoresCallWhenSecurityMethodHasChanged() {\n+        //GIVEN current security mode has been set to PIN\n+        mKeyguardSecurityContainerController.showSecurityScreen(SecurityMode.PIN);\n+\n+        //WHEN a request comes from SimPin to dismiss the security screens\n+        boolean keyguardDone = mKeyguardSecurityContainerController.showNextSecurityScreenOrFinish(\n+                /* authenticated= */true,\n+                TARGET_USER_ID,\n+                /* bypassSecondaryLockScreen= */true,\n+                SecurityMode.SimPin);\n+\n+        //THEN no action has happened, which will not dismiss the security screens\n+        assertThat(keyguardDone).isEqualTo(false);\n+        verify(mKeyguardUpdateMonitor, never()).getUserHasTrust(anyInt());\n+    }\n }\n",
    "added_lines": 41,
    "deleted_lines": 0,
    "changed_methods": "KeyguardSecurityContainerControllerTest::showNextSecurityScreenOrFinish_ignoresCallWhenSecurityMethodHasChanged, KeyguardSecurityContainerControllerTest::showNextSecurityScreenOrFinish_setsSecurityScreenToPinAfterSimPinUnlock"
   }
  ]
 },
 {
  "hash": "c0353314847735082aa8a51557361d2081f5cdbc",
  "commit": "[DO NOT MERGE] Do not dismiss keyguard after SIM PUK unlock\n\nAfter PUK unlock, multiple calls to\nKeyguardSecurityContainerController#dismiss() were being called from\nthe KeyguardSimPukViewController, which begins the transition to the\nnext security screen, if any. At the same time, other parts of the\nsystem, also listening to SIM events, recognize the PUK unlock and\ncall KeyguardSecurityContainer#showSecurityScreen, which updates which\nsecurity method comes next. After boot, this should be one of PIN,\nPassword, Pattern, assuming they have a security method. If one of the\nfirst dismiss() calls comes AFTER the security method changes, this is\nincorrectly recognized by the code as a successful\nPIN/pattern/password unlock. This causes the keyguard to be marked as\ndone, causing screen flickers and incorrect system state.\n\nThe solution: every call to dismiss() should include a new parameter\nfor the security method used. If there is a difference between this\nparameter and the current value in KeyguardSecurityContainerCallback,\nignore the request, as the system state has changed.\n\nFixes: 238804980\nBug: 218500036\nTest: atest KeyguardSecurityContainerTest\nAdminSecondaryLockScreenControllerTest KeyguardHostViewControllerTest\nKeyguardSecurityContainerControllerTest\n\nChange-Id: I7c8714a177bc85fbce92f6e8fe911f74ca2ac243\nMerged-In: I7c8714a177bc85fbce92f6e8fe911f74ca2ac243\n(cherry picked from commit 37aeb26b0ae28a48c1ed40f008d5808d8a84be23)\n(cherry picked from commit 1e7087f1136989b67c9b72c470617e5fb8c80501)\nMerged-In: I7c8714a177bc85fbce92f6e8fe911f74ca2ac243",
  "files": [
   {
    "filename": "AdminSecondaryLockScreenController.java",
    "diff": "@@ -33,6 +33,7 @@ import android.view.SurfaceView;\n import android.view.ViewGroup;\n \n import com.android.internal.annotations.VisibleForTesting;\n+import com.android.keyguard.KeyguardSecurityModel.SecurityMode;\n import com.android.keyguard.dagger.KeyguardBouncerScope;\n import com.android.systemui.dagger.qualifiers.Main;\n \n@@ -208,7 +209,7 @@ public class AdminSecondaryLockScreenController {\n             hide();\n             if (mKeyguardCallback != null) {\n                 mKeyguardCallback.dismiss(/* securityVerified= */ true, userId,\n-                        /* bypassSecondaryLockScreen= */true);\n+                        /* bypassSecondaryLockScreen= */true, SecurityMode.Invalid);\n             }\n         }\n     }\n",
    "added_lines": 2,
    "deleted_lines": 1,
    "changed_methods": "AdminSecondaryLockScreenController::dismiss"
   },
   {
    "filename": "KeyguardAbsKeyInputViewController.java",
    "diff": "@@ -174,7 +174,7 @@ public abstract class KeyguardAbsKeyInputViewController<T extends KeyguardAbsKey\n             if (dismissKeyguard) {\n                 mDismissing = true;\n                 mLatencyTracker.onActionStart(LatencyTracker.ACTION_LOCKSCREEN_UNLOCK);\n-                getKeyguardSecurityCallback().dismiss(true, userId);\n+                getKeyguardSecurityCallback().dismiss(true, userId, getSecurityMode());\n             }\n         } else {\n             if (isValidPassword) {\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "KeyguardAbsKeyInputViewController::onPasswordChecked"
   },
   {
    "filename": "KeyguardHostViewController.java",
    "diff": "@@ -93,7 +93,7 @@ public class KeyguardHostViewController extends ViewController<KeyguardHostView>\n                                 Log.i(TAG, \"TrustAgent dismissed Keyguard.\");\n                             }\n                             mSecurityCallback.dismiss(false /* authenticated */, userId,\n-                                    /* bypassSecondaryLockScreen */ false);\n+                                    /* bypassSecondaryLockScreen */ false, SecurityMode.Invalid);\n                         } else {\n                             mViewMediatorCallback.playTrustedSound();\n                         }\n@@ -105,9 +105,9 @@ public class KeyguardHostViewController extends ViewController<KeyguardHostView>\n \n         @Override\n         public boolean dismiss(boolean authenticated, int targetUserId,\n-                boolean bypassSecondaryLockScreen) {\n+                boolean bypassSecondaryLockScreen, SecurityMode expectedSecurityMode) {\n             return mKeyguardSecurityContainerController.showNextSecurityScreenOrFinish(\n-                    authenticated, targetUserId, bypassSecondaryLockScreen);\n+                    authenticated, targetUserId, bypassSecondaryLockScreen, expectedSecurityMode);\n         }\n \n         @Override\n@@ -215,7 +215,8 @@ public class KeyguardHostViewController extends ViewController<KeyguardHostView>\n      * @return True if the keyguard is done.\n      */\n     public boolean dismiss(int targetUserId) {\n-        return mSecurityCallback.dismiss(false, targetUserId, false);\n+        return mSecurityCallback.dismiss(false, targetUserId, false,\n+                getCurrentSecurityMode());\n     }\n \n     /**\n@@ -356,10 +357,10 @@ public class KeyguardHostViewController extends ViewController<KeyguardHostView>\n     }\n \n     public boolean handleBackKey() {\n-        if (mKeyguardSecurityContainerController.getCurrentSecurityMode()\n-                != SecurityMode.None) {\n+        SecurityMode securityMode = mKeyguardSecurityContainerController.getCurrentSecurityMode();\n+        if (securityMode != SecurityMode.None) {\n             mKeyguardSecurityContainerController.dismiss(\n-                    false, KeyguardUpdateMonitor.getCurrentUser());\n+                    false, KeyguardUpdateMonitor.getCurrentUser(), securityMode);\n             return true;\n         }\n         return false;\n",
    "added_lines": 8,
    "deleted_lines": 7,
    "changed_methods": "KeyguardHostViewController::SecurityCallback, KeyguardHostViewController::handleBackKey, KeyguardHostViewController::KeyguardUpdateMonitorCallback, KeyguardHostViewController::dismiss"
   },
   {
    "filename": "KeyguardInputViewController.java",
    "diff": "@@ -59,10 +59,11 @@ public abstract class KeyguardInputViewController<T extends KeyguardInputView>\n             return false;\n         }\n         @Override\n-        public void dismiss(boolean securityVerified, int targetUserId) { }\n+        public void dismiss(boolean securityVerified, int targetUserId,\n+                SecurityMode expectedSecurityMode) { }\n         @Override\n         public void dismiss(boolean authenticated, int targetId,\n-                boolean bypassSecondaryLockScreen) { }\n+                boolean bypassSecondaryLockScreen, SecurityMode expectedSecurityMode) { }\n         @Override\n         public void onUserInput() { }\n         @Override\n",
    "added_lines": 3,
    "deleted_lines": 2,
    "changed_methods": "KeyguardInputViewController::KeyguardSecurityCallback"
   },
   {
    "filename": "KeyguardPatternViewController.java",
    "diff": "@@ -170,7 +170,7 @@ public class KeyguardPatternViewController\n                 if (dismissKeyguard) {\n                     mLockPatternView.setDisplayMode(LockPatternView.DisplayMode.Correct);\n                     mLatencyTracker.onActionStart(LatencyTracker.ACTION_LOCKSCREEN_UNLOCK);\n-                    getKeyguardSecurityCallback().dismiss(true, userId);\n+                    getKeyguardSecurityCallback().dismiss(true, userId, SecurityMode.Pattern);\n                 }\n             } else {\n                 mLockPatternView.setDisplayMode(LockPatternView.DisplayMode.Wrong);\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "KeyguardPatternViewController::UnlockPatternListener::onPatternChecked"
   },
   {
    "filename": "KeyguardSecurityCallback.java",
    "diff": "@@ -15,14 +15,17 @@\n  */\n package com.android.keyguard;\n \n+import com.android.keyguard.KeyguardSecurityModel.SecurityMode;\n+\n public interface KeyguardSecurityCallback {\n \n     /**\n      * Dismiss the given security screen.\n      * @param securityVerified true if the user correctly entered credentials for the given screen.\n      * @param targetUserId a user that needs to be the foreground user at the dismissal completion.\n+     * @param expectedSecurityMode The security mode that is invoking this dismiss.\n      */\n-    void dismiss(boolean securityVerified, int targetUserId);\n+    void dismiss(boolean securityVerified, int targetUserId, SecurityMode expectedSecurityMode);\n \n     /**\n      * Dismiss the given security screen.\n@@ -30,8 +33,10 @@ public interface KeyguardSecurityCallback {\n      * @param targetUserId a user that needs to be the foreground user at the dismissal completion.\n      * @param bypassSecondaryLockScreen true if the user can bypass the secondary lock screen,\n      *                                  if any, during this dismissal.\n+     * @param expectedSecurityMode The security mode that is invoking this dismiss.\n      */\n-    void dismiss(boolean securityVerified, int targetUserId, boolean bypassSecondaryLockScreen);\n+    void dismiss(boolean securityVerified, int targetUserId, boolean bypassSecondaryLockScreen,\n+            SecurityMode expectedSecurityMode);\n \n     /**\n      * Manually report user activity to keep the device awake.\n",
    "added_lines": 7,
    "deleted_lines": 2,
    "changed_methods": ""
   },
   {
    "filename": "KeyguardSecurityContainer.java",
    "diff": "@@ -181,7 +181,12 @@ public class KeyguardSecurityContainer extends FrameLayout {\n \n     // Used to notify the container when something interesting happens.\n     public interface SecurityCallback {\n-        boolean dismiss(boolean authenticated, int targetUserId, boolean bypassSecondaryLockScreen);\n+        /**\n+         * Potentially dismiss the current security screen, after validating that all device\n+         * security has been unlocked. Otherwise show the next screen.\n+         */\n+        boolean dismiss(boolean authenticated, int targetUserId, boolean bypassSecondaryLockScreen,\n+                SecurityMode expectedSecurityMode);\n \n         void userActivity();\n \n",
    "added_lines": 6,
    "deleted_lines": 1,
    "changed_methods": ""
   },
   {
    "filename": "KeyguardSecurityContainerController.java",
    "diff": "@@ -136,14 +136,17 @@ public class KeyguardSecurityContainerController extends ViewController<Keyguard\n         }\n \n         @Override\n-        public void dismiss(boolean authenticated, int targetId) {\n-            dismiss(authenticated, targetId, /* bypassSecondaryLockScreen */ false);\n+        public void dismiss(boolean authenticated, int targetId,\n+                SecurityMode expectedSecurityMode) {\n+            dismiss(authenticated, targetId, /* bypassSecondaryLockScreen */ false,\n+                    expectedSecurityMode);\n         }\n \n         @Override\n         public void dismiss(boolean authenticated, int targetId,\n-                boolean bypassSecondaryLockScreen) {\n-            mSecurityCallback.dismiss(authenticated, targetId, bypassSecondaryLockScreen);\n+                boolean bypassSecondaryLockScreen, SecurityMode expectedSecurityMode) {\n+            mSecurityCallback.dismiss(authenticated, targetId, bypassSecondaryLockScreen,\n+                    expectedSecurityMode);\n         }\n \n         public boolean isVerifyUnlockOnly() {\n@@ -307,8 +310,13 @@ public class KeyguardSecurityContainerController extends ViewController<Keyguard\n         return mCurrentSecurityMode;\n     }\n \n-    public void dismiss(boolean authenticated, int targetUserId) {\n-        mKeyguardSecurityCallback.dismiss(authenticated, targetUserId);\n+    /**\n+     * Potentially dismiss the current security screen, after validating that all device\n+     * security has been unlocked. Otherwise show the next screen.\n+     */\n+    public void dismiss(boolean authenticated, int targetUserId,\n+            SecurityMode expectedSecurityMode) {\n+        mKeyguardSecurityCallback.dismiss(authenticated, targetUserId, expectedSecurityMode);\n     }\n \n     public void reset() {\n@@ -367,12 +375,21 @@ public class KeyguardSecurityContainerController extends ViewController<Keyguard\n      *     completion.\n      * @param bypassSecondaryLockScreen true if the user is allowed to bypass the secondary\n      *     secondary lock screen requirement, if any.\n+     * @param expectedSecurityMode SecurityMode that is invoking this request. SecurityMode.Invalid\n+     *      indicates that no check should be done\n      * @return true if keyguard is done\n      */\n     public boolean showNextSecurityScreenOrFinish(boolean authenticated, int targetUserId,\n-            boolean bypassSecondaryLockScreen) {\n+            boolean bypassSecondaryLockScreen, SecurityMode expectedSecurityMode) {\n \n         if (DEBUG) Log.d(TAG, \"showNextSecurityScreenOrFinish(\" + authenticated + \")\");\n+        if (expectedSecurityMode != SecurityMode.Invalid\n+                && expectedSecurityMode != getCurrentSecurityMode()) {\n+            Log.w(TAG, \"Attempted to invoke showNextSecurityScreenOrFinish with securityMode \"\n+                    + expectedSecurityMode + \", but current mode is \" + getCurrentSecurityMode());\n+            return false;\n+        }\n+\n         boolean finish = false;\n         boolean strongAuth = false;\n         int eventSubtype = -1;\n",
    "added_lines": 24,
    "deleted_lines": 7,
    "changed_methods": "KeyguardSecurityContainerController::showNextSecurityScreenOrFinish, KeyguardSecurityContainerController::showNextSecurityScreenOrFinish, KeyguardSecurityContainerController::dismiss, KeyguardSecurityContainerController::KeyguardSecurityCallback, KeyguardSecurityContainerController::dismiss"
   },
   {
    "filename": "KeyguardSimPinViewController.java",
    "diff": "@@ -162,7 +162,8 @@ public class KeyguardSimPinViewController\n                             mRemainingAttempts = -1;\n                             mShowDefaultMessage = true;\n                             getKeyguardSecurityCallback().dismiss(\n-                                    true, KeyguardUpdateMonitor.getCurrentUser());\n+                                    true, KeyguardUpdateMonitor.getCurrentUser(),\n+                                    SecurityMode.SimPin);\n                         } else {\n                             mShowDefaultMessage = false;\n                             if (result.getResult() == PinResult.PIN_RESULT_TYPE_INCORRECT) {\n",
    "added_lines": 2,
    "deleted_lines": 1,
    "changed_methods": "KeyguardSimPinViewController::verifyPasswordAndUnlock"
   },
   {
    "filename": "KeyguardSimPukViewController.java",
    "diff": "@@ -69,7 +69,8 @@ public class KeyguardSimPukViewController\n             if (simState == TelephonyManager.SIM_STATE_READY) {\n                 mRemainingAttempts = -1;\n                 mShowDefaultMessage = true;\n-                getKeyguardSecurityCallback().dismiss(true, KeyguardUpdateMonitor.getCurrentUser());\n+                getKeyguardSecurityCallback().dismiss(true, KeyguardUpdateMonitor.getCurrentUser(),\n+                        SecurityMode.SimPuk);\n             } else {\n                 resetState();\n             }\n@@ -274,7 +275,8 @@ public class KeyguardSimPukViewController\n                             mShowDefaultMessage = true;\n \n                             getKeyguardSecurityCallback().dismiss(\n-                                    true, KeyguardUpdateMonitor.getCurrentUser());\n+                                    true, KeyguardUpdateMonitor.getCurrentUser(),\n+                                    SecurityMode.SimPuk);\n                         } else {\n                             mShowDefaultMessage = false;\n                             if (result.getResult() == PinResult.PIN_RESULT_TYPE_INCORRECT) {\n",
    "added_lines": 4,
    "deleted_lines": 2,
    "changed_methods": "KeyguardSimPukViewController::KeyguardUpdateMonitorCallback, KeyguardSimPukViewController::updateSim"
   },
   {
    "filename": "AdminSecondaryLockScreenControllerTest.java",
    "diff": "@@ -44,6 +44,7 @@ import android.view.SurfaceView;\n \n import androidx.test.filters.SmallTest;\n \n+import com.android.keyguard.KeyguardSecurityModel.SecurityMode;\n import com.android.systemui.SysuiTestCase;\n \n import org.junit.After;\n@@ -190,7 +191,7 @@ public class AdminSecondaryLockScreenControllerTest extends SysuiTestCase {\n \n     private void verifyViewDismissed(SurfaceView v) throws Exception {\n         verify(mKeyguardSecurityContainer).removeView(v);\n-        verify(mKeyguardCallback).dismiss(true, TARGET_USER_ID, true);\n+        verify(mKeyguardCallback).dismiss(true, TARGET_USER_ID, true, SecurityMode.Invalid);\n         assertThat(mContext.isBound(mComponentName)).isFalse();\n     }\n }\n",
    "added_lines": 2,
    "deleted_lines": 1,
    "changed_methods": "AdminSecondaryLockScreenControllerTest::verifyViewDismissed"
   },
   {
    "filename": "KeyguardSecurityContainerControllerTest.java",
    "diff": "@@ -18,6 +18,8 @@ package com.android.keyguard;\n \n import static android.view.WindowInsets.Type.ime;\n \n+import static com.google.common.truth.Truth.assertThat;\n+\n import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.ArgumentMatchers.anyBoolean;\n import static org.mockito.ArgumentMatchers.anyInt;\n@@ -62,6 +64,7 @@ import org.mockito.junit.MockitoRule;\n @RunWith(AndroidTestingRunner.class)\n @TestableLooper.RunWithLooper()\n public class KeyguardSecurityContainerControllerTest extends SysuiTestCase {\n+    private static final int TARGET_USER_ID = 100;\n     private static final int VIEW_WIDTH = 1600;\n \n     @Rule\n@@ -330,4 +333,42 @@ public class KeyguardSecurityContainerControllerTest extends SysuiTestCase {\n                 R.bool.can_use_one_handed_bouncer))\n                 .thenReturn(sysuiResourceCanUseOneHandedKeyguard);\n     }\n+\n+    @Test\n+    public void showNextSecurityScreenOrFinish_setsSecurityScreenToPinAfterSimPinUnlock() {\n+        // GIVEN the current security method is SimPin\n+        when(mKeyguardUpdateMonitor.getUserHasTrust(anyInt())).thenReturn(false);\n+        when(mKeyguardUpdateMonitor.getUserUnlockedWithBiometric(TARGET_USER_ID)).thenReturn(false);\n+        mKeyguardSecurityContainerController.showSecurityScreen(SecurityMode.SimPin);\n+\n+        // WHEN a request is made from the SimPin screens to show the next security method\n+        when(mKeyguardSecurityModel.getSecurityMode(TARGET_USER_ID)).thenReturn(SecurityMode.PIN);\n+        mKeyguardSecurityContainerController.showNextSecurityScreenOrFinish(\n+                /* authenticated= */true,\n+                TARGET_USER_ID,\n+                /* bypassSecondaryLockScreen= */true,\n+                SecurityMode.SimPin);\n+\n+        // THEN the next security method of PIN is set, and the keyguard is not marked as done\n+        verify(mSecurityCallback, never()).finish(anyBoolean(), anyInt());\n+        assertThat(mKeyguardSecurityContainerController.getCurrentSecurityMode())\n+                .isEqualTo(SecurityMode.PIN);\n+    }\n+\n+    @Test\n+    public void showNextSecurityScreenOrFinish_ignoresCallWhenSecurityMethodHasChanged() {\n+        //GIVEN current security mode has been set to PIN\n+        mKeyguardSecurityContainerController.showSecurityScreen(SecurityMode.PIN);\n+\n+        //WHEN a request comes from SimPin to dismiss the security screens\n+        boolean keyguardDone = mKeyguardSecurityContainerController.showNextSecurityScreenOrFinish(\n+                /* authenticated= */true,\n+                TARGET_USER_ID,\n+                /* bypassSecondaryLockScreen= */true,\n+                SecurityMode.SimPin);\n+\n+        //THEN no action has happened, which will not dismiss the security screens\n+        assertThat(keyguardDone).isEqualTo(false);\n+        verify(mKeyguardUpdateMonitor, never()).getUserHasTrust(anyInt());\n+    }\n }\n",
    "added_lines": 41,
    "deleted_lines": 0,
    "changed_methods": "KeyguardSecurityContainerControllerTest::showNextSecurityScreenOrFinish_ignoresCallWhenSecurityMethodHasChanged, KeyguardSecurityContainerControllerTest::showNextSecurityScreenOrFinish_setsSecurityScreenToPinAfterSimPinUnlock"
   }
  ]
 },
 {
  "hash": "c0353314847735082aa8a51557361d2081f5cdbc",
  "commit": "[DO NOT MERGE] Do not dismiss keyguard after SIM PUK unlock\n\nAfter PUK unlock, multiple calls to\nKeyguardSecurityContainerController#dismiss() were being called from\nthe KeyguardSimPukViewController, which begins the transition to the\nnext security screen, if any. At the same time, other parts of the\nsystem, also listening to SIM events, recognize the PUK unlock and\ncall KeyguardSecurityContainer#showSecurityScreen, which updates which\nsecurity method comes next. After boot, this should be one of PIN,\nPassword, Pattern, assuming they have a security method. If one of the\nfirst dismiss() calls comes AFTER the security method changes, this is\nincorrectly recognized by the code as a successful\nPIN/pattern/password unlock. This causes the keyguard to be marked as\ndone, causing screen flickers and incorrect system state.\n\nThe solution: every call to dismiss() should include a new parameter\nfor the security method used. If there is a difference between this\nparameter and the current value in KeyguardSecurityContainerCallback,\nignore the request, as the system state has changed.\n\nFixes: 238804980\nBug: 218500036\nTest: atest KeyguardSecurityContainerTest\nAdminSecondaryLockScreenControllerTest KeyguardHostViewControllerTest\nKeyguardSecurityContainerControllerTest\n\nChange-Id: I7c8714a177bc85fbce92f6e8fe911f74ca2ac243\nMerged-In: I7c8714a177bc85fbce92f6e8fe911f74ca2ac243\n(cherry picked from commit 37aeb26b0ae28a48c1ed40f008d5808d8a84be23)\n(cherry picked from commit 1e7087f1136989b67c9b72c470617e5fb8c80501)\nMerged-In: I7c8714a177bc85fbce92f6e8fe911f74ca2ac243",
  "files": [
   {
    "filename": "AdminSecondaryLockScreenController.java",
    "diff": "@@ -33,6 +33,7 @@ import android.view.SurfaceView;\n import android.view.ViewGroup;\n \n import com.android.internal.annotations.VisibleForTesting;\n+import com.android.keyguard.KeyguardSecurityModel.SecurityMode;\n import com.android.keyguard.dagger.KeyguardBouncerScope;\n import com.android.systemui.dagger.qualifiers.Main;\n \n@@ -208,7 +209,7 @@ public class AdminSecondaryLockScreenController {\n             hide();\n             if (mKeyguardCallback != null) {\n                 mKeyguardCallback.dismiss(/* securityVerified= */ true, userId,\n-                        /* bypassSecondaryLockScreen= */true);\n+                        /* bypassSecondaryLockScreen= */true, SecurityMode.Invalid);\n             }\n         }\n     }\n",
    "added_lines": 2,
    "deleted_lines": 1,
    "changed_methods": "AdminSecondaryLockScreenController::dismiss"
   },
   {
    "filename": "KeyguardAbsKeyInputViewController.java",
    "diff": "@@ -174,7 +174,7 @@ public abstract class KeyguardAbsKeyInputViewController<T extends KeyguardAbsKey\n             if (dismissKeyguard) {\n                 mDismissing = true;\n                 mLatencyTracker.onActionStart(LatencyTracker.ACTION_LOCKSCREEN_UNLOCK);\n-                getKeyguardSecurityCallback().dismiss(true, userId);\n+                getKeyguardSecurityCallback().dismiss(true, userId, getSecurityMode());\n             }\n         } else {\n             if (isValidPassword) {\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "KeyguardAbsKeyInputViewController::onPasswordChecked"
   },
   {
    "filename": "KeyguardHostViewController.java",
    "diff": "@@ -93,7 +93,7 @@ public class KeyguardHostViewController extends ViewController<KeyguardHostView>\n                                 Log.i(TAG, \"TrustAgent dismissed Keyguard.\");\n                             }\n                             mSecurityCallback.dismiss(false /* authenticated */, userId,\n-                                    /* bypassSecondaryLockScreen */ false);\n+                                    /* bypassSecondaryLockScreen */ false, SecurityMode.Invalid);\n                         } else {\n                             mViewMediatorCallback.playTrustedSound();\n                         }\n@@ -105,9 +105,9 @@ public class KeyguardHostViewController extends ViewController<KeyguardHostView>\n \n         @Override\n         public boolean dismiss(boolean authenticated, int targetUserId,\n-                boolean bypassSecondaryLockScreen) {\n+                boolean bypassSecondaryLockScreen, SecurityMode expectedSecurityMode) {\n             return mKeyguardSecurityContainerController.showNextSecurityScreenOrFinish(\n-                    authenticated, targetUserId, bypassSecondaryLockScreen);\n+                    authenticated, targetUserId, bypassSecondaryLockScreen, expectedSecurityMode);\n         }\n \n         @Override\n@@ -215,7 +215,8 @@ public class KeyguardHostViewController extends ViewController<KeyguardHostView>\n      * @return True if the keyguard is done.\n      */\n     public boolean dismiss(int targetUserId) {\n-        return mSecurityCallback.dismiss(false, targetUserId, false);\n+        return mSecurityCallback.dismiss(false, targetUserId, false,\n+                getCurrentSecurityMode());\n     }\n \n     /**\n@@ -356,10 +357,10 @@ public class KeyguardHostViewController extends ViewController<KeyguardHostView>\n     }\n \n     public boolean handleBackKey() {\n-        if (mKeyguardSecurityContainerController.getCurrentSecurityMode()\n-                != SecurityMode.None) {\n+        SecurityMode securityMode = mKeyguardSecurityContainerController.getCurrentSecurityMode();\n+        if (securityMode != SecurityMode.None) {\n             mKeyguardSecurityContainerController.dismiss(\n-                    false, KeyguardUpdateMonitor.getCurrentUser());\n+                    false, KeyguardUpdateMonitor.getCurrentUser(), securityMode);\n             return true;\n         }\n         return false;\n",
    "added_lines": 8,
    "deleted_lines": 7,
    "changed_methods": "KeyguardHostViewController::SecurityCallback, KeyguardHostViewController::handleBackKey, KeyguardHostViewController::KeyguardUpdateMonitorCallback, KeyguardHostViewController::dismiss"
   },
   {
    "filename": "KeyguardInputViewController.java",
    "diff": "@@ -59,10 +59,11 @@ public abstract class KeyguardInputViewController<T extends KeyguardInputView>\n             return false;\n         }\n         @Override\n-        public void dismiss(boolean securityVerified, int targetUserId) { }\n+        public void dismiss(boolean securityVerified, int targetUserId,\n+                SecurityMode expectedSecurityMode) { }\n         @Override\n         public void dismiss(boolean authenticated, int targetId,\n-                boolean bypassSecondaryLockScreen) { }\n+                boolean bypassSecondaryLockScreen, SecurityMode expectedSecurityMode) { }\n         @Override\n         public void onUserInput() { }\n         @Override\n",
    "added_lines": 3,
    "deleted_lines": 2,
    "changed_methods": "KeyguardInputViewController::KeyguardSecurityCallback"
   },
   {
    "filename": "KeyguardPatternViewController.java",
    "diff": "@@ -170,7 +170,7 @@ public class KeyguardPatternViewController\n                 if (dismissKeyguard) {\n                     mLockPatternView.setDisplayMode(LockPatternView.DisplayMode.Correct);\n                     mLatencyTracker.onActionStart(LatencyTracker.ACTION_LOCKSCREEN_UNLOCK);\n-                    getKeyguardSecurityCallback().dismiss(true, userId);\n+                    getKeyguardSecurityCallback().dismiss(true, userId, SecurityMode.Pattern);\n                 }\n             } else {\n                 mLockPatternView.setDisplayMode(LockPatternView.DisplayMode.Wrong);\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "KeyguardPatternViewController::UnlockPatternListener::onPatternChecked"
   },
   {
    "filename": "KeyguardSecurityCallback.java",
    "diff": "@@ -15,14 +15,17 @@\n  */\n package com.android.keyguard;\n \n+import com.android.keyguard.KeyguardSecurityModel.SecurityMode;\n+\n public interface KeyguardSecurityCallback {\n \n     /**\n      * Dismiss the given security screen.\n      * @param securityVerified true if the user correctly entered credentials for the given screen.\n      * @param targetUserId a user that needs to be the foreground user at the dismissal completion.\n+     * @param expectedSecurityMode The security mode that is invoking this dismiss.\n      */\n-    void dismiss(boolean securityVerified, int targetUserId);\n+    void dismiss(boolean securityVerified, int targetUserId, SecurityMode expectedSecurityMode);\n \n     /**\n      * Dismiss the given security screen.\n@@ -30,8 +33,10 @@ public interface KeyguardSecurityCallback {\n      * @param targetUserId a user that needs to be the foreground user at the dismissal completion.\n      * @param bypassSecondaryLockScreen true if the user can bypass the secondary lock screen,\n      *                                  if any, during this dismissal.\n+     * @param expectedSecurityMode The security mode that is invoking this dismiss.\n      */\n-    void dismiss(boolean securityVerified, int targetUserId, boolean bypassSecondaryLockScreen);\n+    void dismiss(boolean securityVerified, int targetUserId, boolean bypassSecondaryLockScreen,\n+            SecurityMode expectedSecurityMode);\n \n     /**\n      * Manually report user activity to keep the device awake.\n",
    "added_lines": 7,
    "deleted_lines": 2,
    "changed_methods": ""
   },
   {
    "filename": "KeyguardSecurityContainer.java",
    "diff": "@@ -181,7 +181,12 @@ public class KeyguardSecurityContainer extends FrameLayout {\n \n     // Used to notify the container when something interesting happens.\n     public interface SecurityCallback {\n-        boolean dismiss(boolean authenticated, int targetUserId, boolean bypassSecondaryLockScreen);\n+        /**\n+         * Potentially dismiss the current security screen, after validating that all device\n+         * security has been unlocked. Otherwise show the next screen.\n+         */\n+        boolean dismiss(boolean authenticated, int targetUserId, boolean bypassSecondaryLockScreen,\n+                SecurityMode expectedSecurityMode);\n \n         void userActivity();\n \n",
    "added_lines": 6,
    "deleted_lines": 1,
    "changed_methods": ""
   },
   {
    "filename": "KeyguardSecurityContainerController.java",
    "diff": "@@ -136,14 +136,17 @@ public class KeyguardSecurityContainerController extends ViewController<Keyguard\n         }\n \n         @Override\n-        public void dismiss(boolean authenticated, int targetId) {\n-            dismiss(authenticated, targetId, /* bypassSecondaryLockScreen */ false);\n+        public void dismiss(boolean authenticated, int targetId,\n+                SecurityMode expectedSecurityMode) {\n+            dismiss(authenticated, targetId, /* bypassSecondaryLockScreen */ false,\n+                    expectedSecurityMode);\n         }\n \n         @Override\n         public void dismiss(boolean authenticated, int targetId,\n-                boolean bypassSecondaryLockScreen) {\n-            mSecurityCallback.dismiss(authenticated, targetId, bypassSecondaryLockScreen);\n+                boolean bypassSecondaryLockScreen, SecurityMode expectedSecurityMode) {\n+            mSecurityCallback.dismiss(authenticated, targetId, bypassSecondaryLockScreen,\n+                    expectedSecurityMode);\n         }\n \n         public boolean isVerifyUnlockOnly() {\n@@ -307,8 +310,13 @@ public class KeyguardSecurityContainerController extends ViewController<Keyguard\n         return mCurrentSecurityMode;\n     }\n \n-    public void dismiss(boolean authenticated, int targetUserId) {\n-        mKeyguardSecurityCallback.dismiss(authenticated, targetUserId);\n+    /**\n+     * Potentially dismiss the current security screen, after validating that all device\n+     * security has been unlocked. Otherwise show the next screen.\n+     */\n+    public void dismiss(boolean authenticated, int targetUserId,\n+            SecurityMode expectedSecurityMode) {\n+        mKeyguardSecurityCallback.dismiss(authenticated, targetUserId, expectedSecurityMode);\n     }\n \n     public void reset() {\n@@ -367,12 +375,21 @@ public class KeyguardSecurityContainerController extends ViewController<Keyguard\n      *     completion.\n      * @param bypassSecondaryLockScreen true if the user is allowed to bypass the secondary\n      *     secondary lock screen requirement, if any.\n+     * @param expectedSecurityMode SecurityMode that is invoking this request. SecurityMode.Invalid\n+     *      indicates that no check should be done\n      * @return true if keyguard is done\n      */\n     public boolean showNextSecurityScreenOrFinish(boolean authenticated, int targetUserId,\n-            boolean bypassSecondaryLockScreen) {\n+            boolean bypassSecondaryLockScreen, SecurityMode expectedSecurityMode) {\n \n         if (DEBUG) Log.d(TAG, \"showNextSecurityScreenOrFinish(\" + authenticated + \")\");\n+        if (expectedSecurityMode != SecurityMode.Invalid\n+                && expectedSecurityMode != getCurrentSecurityMode()) {\n+            Log.w(TAG, \"Attempted to invoke showNextSecurityScreenOrFinish with securityMode \"\n+                    + expectedSecurityMode + \", but current mode is \" + getCurrentSecurityMode());\n+            return false;\n+        }\n+\n         boolean finish = false;\n         boolean strongAuth = false;\n         int eventSubtype = -1;\n",
    "added_lines": 24,
    "deleted_lines": 7,
    "changed_methods": "KeyguardSecurityContainerController::showNextSecurityScreenOrFinish, KeyguardSecurityContainerController::showNextSecurityScreenOrFinish, KeyguardSecurityContainerController::dismiss, KeyguardSecurityContainerController::KeyguardSecurityCallback, KeyguardSecurityContainerController::dismiss"
   },
   {
    "filename": "KeyguardSimPinViewController.java",
    "diff": "@@ -162,7 +162,8 @@ public class KeyguardSimPinViewController\n                             mRemainingAttempts = -1;\n                             mShowDefaultMessage = true;\n                             getKeyguardSecurityCallback().dismiss(\n-                                    true, KeyguardUpdateMonitor.getCurrentUser());\n+                                    true, KeyguardUpdateMonitor.getCurrentUser(),\n+                                    SecurityMode.SimPin);\n                         } else {\n                             mShowDefaultMessage = false;\n                             if (result.getResult() == PinResult.PIN_RESULT_TYPE_INCORRECT) {\n",
    "added_lines": 2,
    "deleted_lines": 1,
    "changed_methods": "KeyguardSimPinViewController::verifyPasswordAndUnlock"
   },
   {
    "filename": "KeyguardSimPukViewController.java",
    "diff": "@@ -69,7 +69,8 @@ public class KeyguardSimPukViewController\n             if (simState == TelephonyManager.SIM_STATE_READY) {\n                 mRemainingAttempts = -1;\n                 mShowDefaultMessage = true;\n-                getKeyguardSecurityCallback().dismiss(true, KeyguardUpdateMonitor.getCurrentUser());\n+                getKeyguardSecurityCallback().dismiss(true, KeyguardUpdateMonitor.getCurrentUser(),\n+                        SecurityMode.SimPuk);\n             } else {\n                 resetState();\n             }\n@@ -274,7 +275,8 @@ public class KeyguardSimPukViewController\n                             mShowDefaultMessage = true;\n \n                             getKeyguardSecurityCallback().dismiss(\n-                                    true, KeyguardUpdateMonitor.getCurrentUser());\n+                                    true, KeyguardUpdateMonitor.getCurrentUser(),\n+                                    SecurityMode.SimPuk);\n                         } else {\n                             mShowDefaultMessage = false;\n                             if (result.getResult() == PinResult.PIN_RESULT_TYPE_INCORRECT) {\n",
    "added_lines": 4,
    "deleted_lines": 2,
    "changed_methods": "KeyguardSimPukViewController::KeyguardUpdateMonitorCallback, KeyguardSimPukViewController::updateSim"
   },
   {
    "filename": "AdminSecondaryLockScreenControllerTest.java",
    "diff": "@@ -44,6 +44,7 @@ import android.view.SurfaceView;\n \n import androidx.test.filters.SmallTest;\n \n+import com.android.keyguard.KeyguardSecurityModel.SecurityMode;\n import com.android.systemui.SysuiTestCase;\n \n import org.junit.After;\n@@ -190,7 +191,7 @@ public class AdminSecondaryLockScreenControllerTest extends SysuiTestCase {\n \n     private void verifyViewDismissed(SurfaceView v) throws Exception {\n         verify(mKeyguardSecurityContainer).removeView(v);\n-        verify(mKeyguardCallback).dismiss(true, TARGET_USER_ID, true);\n+        verify(mKeyguardCallback).dismiss(true, TARGET_USER_ID, true, SecurityMode.Invalid);\n         assertThat(mContext.isBound(mComponentName)).isFalse();\n     }\n }\n",
    "added_lines": 2,
    "deleted_lines": 1,
    "changed_methods": "AdminSecondaryLockScreenControllerTest::verifyViewDismissed"
   },
   {
    "filename": "KeyguardSecurityContainerControllerTest.java",
    "diff": "@@ -18,6 +18,8 @@ package com.android.keyguard;\n \n import static android.view.WindowInsets.Type.ime;\n \n+import static com.google.common.truth.Truth.assertThat;\n+\n import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.ArgumentMatchers.anyBoolean;\n import static org.mockito.ArgumentMatchers.anyInt;\n@@ -62,6 +64,7 @@ import org.mockito.junit.MockitoRule;\n @RunWith(AndroidTestingRunner.class)\n @TestableLooper.RunWithLooper()\n public class KeyguardSecurityContainerControllerTest extends SysuiTestCase {\n+    private static final int TARGET_USER_ID = 100;\n     private static final int VIEW_WIDTH = 1600;\n \n     @Rule\n@@ -330,4 +333,42 @@ public class KeyguardSecurityContainerControllerTest extends SysuiTestCase {\n                 R.bool.can_use_one_handed_bouncer))\n                 .thenReturn(sysuiResourceCanUseOneHandedKeyguard);\n     }\n+\n+    @Test\n+    public void showNextSecurityScreenOrFinish_setsSecurityScreenToPinAfterSimPinUnlock() {\n+        // GIVEN the current security method is SimPin\n+        when(mKeyguardUpdateMonitor.getUserHasTrust(anyInt())).thenReturn(false);\n+        when(mKeyguardUpdateMonitor.getUserUnlockedWithBiometric(TARGET_USER_ID)).thenReturn(false);\n+        mKeyguardSecurityContainerController.showSecurityScreen(SecurityMode.SimPin);\n+\n+        // WHEN a request is made from the SimPin screens to show the next security method\n+        when(mKeyguardSecurityModel.getSecurityMode(TARGET_USER_ID)).thenReturn(SecurityMode.PIN);\n+        mKeyguardSecurityContainerController.showNextSecurityScreenOrFinish(\n+                /* authenticated= */true,\n+                TARGET_USER_ID,\n+                /* bypassSecondaryLockScreen= */true,\n+                SecurityMode.SimPin);\n+\n+        // THEN the next security method of PIN is set, and the keyguard is not marked as done\n+        verify(mSecurityCallback, never()).finish(anyBoolean(), anyInt());\n+        assertThat(mKeyguardSecurityContainerController.getCurrentSecurityMode())\n+                .isEqualTo(SecurityMode.PIN);\n+    }\n+\n+    @Test\n+    public void showNextSecurityScreenOrFinish_ignoresCallWhenSecurityMethodHasChanged() {\n+        //GIVEN current security mode has been set to PIN\n+        mKeyguardSecurityContainerController.showSecurityScreen(SecurityMode.PIN);\n+\n+        //WHEN a request comes from SimPin to dismiss the security screens\n+        boolean keyguardDone = mKeyguardSecurityContainerController.showNextSecurityScreenOrFinish(\n+                /* authenticated= */true,\n+                TARGET_USER_ID,\n+                /* bypassSecondaryLockScreen= */true,\n+                SecurityMode.SimPin);\n+\n+        //THEN no action has happened, which will not dismiss the security screens\n+        assertThat(keyguardDone).isEqualTo(false);\n+        verify(mKeyguardUpdateMonitor, never()).getUserHasTrust(anyInt());\n+    }\n }\n",
    "added_lines": 41,
    "deleted_lines": 0,
    "changed_methods": "KeyguardSecurityContainerControllerTest::showNextSecurityScreenOrFinish_ignoresCallWhenSecurityMethodHasChanged, KeyguardSecurityContainerControllerTest::showNextSecurityScreenOrFinish_setsSecurityScreenToPinAfterSimPinUnlock"
   }
  ]
 },
 {
  "hash": "c0353314847735082aa8a51557361d2081f5cdbc",
  "commit": "[DO NOT MERGE] Do not dismiss keyguard after SIM PUK unlock\n\nAfter PUK unlock, multiple calls to\nKeyguardSecurityContainerController#dismiss() were being called from\nthe KeyguardSimPukViewController, which begins the transition to the\nnext security screen, if any. At the same time, other parts of the\nsystem, also listening to SIM events, recognize the PUK unlock and\ncall KeyguardSecurityContainer#showSecurityScreen, which updates which\nsecurity method comes next. After boot, this should be one of PIN,\nPassword, Pattern, assuming they have a security method. If one of the\nfirst dismiss() calls comes AFTER the security method changes, this is\nincorrectly recognized by the code as a successful\nPIN/pattern/password unlock. This causes the keyguard to be marked as\ndone, causing screen flickers and incorrect system state.\n\nThe solution: every call to dismiss() should include a new parameter\nfor the security method used. If there is a difference between this\nparameter and the current value in KeyguardSecurityContainerCallback,\nignore the request, as the system state has changed.\n\nFixes: 238804980\nBug: 218500036\nTest: atest KeyguardSecurityContainerTest\nAdminSecondaryLockScreenControllerTest KeyguardHostViewControllerTest\nKeyguardSecurityContainerControllerTest\n\nChange-Id: I7c8714a177bc85fbce92f6e8fe911f74ca2ac243\nMerged-In: I7c8714a177bc85fbce92f6e8fe911f74ca2ac243\n(cherry picked from commit 37aeb26b0ae28a48c1ed40f008d5808d8a84be23)\n(cherry picked from commit 1e7087f1136989b67c9b72c470617e5fb8c80501)\nMerged-In: I7c8714a177bc85fbce92f6e8fe911f74ca2ac243",
  "files": [
   {
    "filename": "AdminSecondaryLockScreenController.java",
    "diff": "@@ -33,6 +33,7 @@ import android.view.SurfaceView;\n import android.view.ViewGroup;\n \n import com.android.internal.annotations.VisibleForTesting;\n+import com.android.keyguard.KeyguardSecurityModel.SecurityMode;\n import com.android.keyguard.dagger.KeyguardBouncerScope;\n import com.android.systemui.dagger.qualifiers.Main;\n \n@@ -208,7 +209,7 @@ public class AdminSecondaryLockScreenController {\n             hide();\n             if (mKeyguardCallback != null) {\n                 mKeyguardCallback.dismiss(/* securityVerified= */ true, userId,\n-                        /* bypassSecondaryLockScreen= */true);\n+                        /* bypassSecondaryLockScreen= */true, SecurityMode.Invalid);\n             }\n         }\n     }\n",
    "added_lines": 2,
    "deleted_lines": 1,
    "changed_methods": "AdminSecondaryLockScreenController::dismiss"
   },
   {
    "filename": "KeyguardAbsKeyInputViewController.java",
    "diff": "@@ -174,7 +174,7 @@ public abstract class KeyguardAbsKeyInputViewController<T extends KeyguardAbsKey\n             if (dismissKeyguard) {\n                 mDismissing = true;\n                 mLatencyTracker.onActionStart(LatencyTracker.ACTION_LOCKSCREEN_UNLOCK);\n-                getKeyguardSecurityCallback().dismiss(true, userId);\n+                getKeyguardSecurityCallback().dismiss(true, userId, getSecurityMode());\n             }\n         } else {\n             if (isValidPassword) {\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "KeyguardAbsKeyInputViewController::onPasswordChecked"
   },
   {
    "filename": "KeyguardHostViewController.java",
    "diff": "@@ -93,7 +93,7 @@ public class KeyguardHostViewController extends ViewController<KeyguardHostView>\n                                 Log.i(TAG, \"TrustAgent dismissed Keyguard.\");\n                             }\n                             mSecurityCallback.dismiss(false /* authenticated */, userId,\n-                                    /* bypassSecondaryLockScreen */ false);\n+                                    /* bypassSecondaryLockScreen */ false, SecurityMode.Invalid);\n                         } else {\n                             mViewMediatorCallback.playTrustedSound();\n                         }\n@@ -105,9 +105,9 @@ public class KeyguardHostViewController extends ViewController<KeyguardHostView>\n \n         @Override\n         public boolean dismiss(boolean authenticated, int targetUserId,\n-                boolean bypassSecondaryLockScreen) {\n+                boolean bypassSecondaryLockScreen, SecurityMode expectedSecurityMode) {\n             return mKeyguardSecurityContainerController.showNextSecurityScreenOrFinish(\n-                    authenticated, targetUserId, bypassSecondaryLockScreen);\n+                    authenticated, targetUserId, bypassSecondaryLockScreen, expectedSecurityMode);\n         }\n \n         @Override\n@@ -215,7 +215,8 @@ public class KeyguardHostViewController extends ViewController<KeyguardHostView>\n      * @return True if the keyguard is done.\n      */\n     public boolean dismiss(int targetUserId) {\n-        return mSecurityCallback.dismiss(false, targetUserId, false);\n+        return mSecurityCallback.dismiss(false, targetUserId, false,\n+                getCurrentSecurityMode());\n     }\n \n     /**\n@@ -356,10 +357,10 @@ public class KeyguardHostViewController extends ViewController<KeyguardHostView>\n     }\n \n     public boolean handleBackKey() {\n-        if (mKeyguardSecurityContainerController.getCurrentSecurityMode()\n-                != SecurityMode.None) {\n+        SecurityMode securityMode = mKeyguardSecurityContainerController.getCurrentSecurityMode();\n+        if (securityMode != SecurityMode.None) {\n             mKeyguardSecurityContainerController.dismiss(\n-                    false, KeyguardUpdateMonitor.getCurrentUser());\n+                    false, KeyguardUpdateMonitor.getCurrentUser(), securityMode);\n             return true;\n         }\n         return false;\n",
    "added_lines": 8,
    "deleted_lines": 7,
    "changed_methods": "KeyguardHostViewController::SecurityCallback, KeyguardHostViewController::handleBackKey, KeyguardHostViewController::KeyguardUpdateMonitorCallback, KeyguardHostViewController::dismiss"
   },
   {
    "filename": "KeyguardInputViewController.java",
    "diff": "@@ -59,10 +59,11 @@ public abstract class KeyguardInputViewController<T extends KeyguardInputView>\n             return false;\n         }\n         @Override\n-        public void dismiss(boolean securityVerified, int targetUserId) { }\n+        public void dismiss(boolean securityVerified, int targetUserId,\n+                SecurityMode expectedSecurityMode) { }\n         @Override\n         public void dismiss(boolean authenticated, int targetId,\n-                boolean bypassSecondaryLockScreen) { }\n+                boolean bypassSecondaryLockScreen, SecurityMode expectedSecurityMode) { }\n         @Override\n         public void onUserInput() { }\n         @Override\n",
    "added_lines": 3,
    "deleted_lines": 2,
    "changed_methods": "KeyguardInputViewController::KeyguardSecurityCallback"
   },
   {
    "filename": "KeyguardPatternViewController.java",
    "diff": "@@ -170,7 +170,7 @@ public class KeyguardPatternViewController\n                 if (dismissKeyguard) {\n                     mLockPatternView.setDisplayMode(LockPatternView.DisplayMode.Correct);\n                     mLatencyTracker.onActionStart(LatencyTracker.ACTION_LOCKSCREEN_UNLOCK);\n-                    getKeyguardSecurityCallback().dismiss(true, userId);\n+                    getKeyguardSecurityCallback().dismiss(true, userId, SecurityMode.Pattern);\n                 }\n             } else {\n                 mLockPatternView.setDisplayMode(LockPatternView.DisplayMode.Wrong);\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "KeyguardPatternViewController::UnlockPatternListener::onPatternChecked"
   },
   {
    "filename": "KeyguardSecurityCallback.java",
    "diff": "@@ -15,14 +15,17 @@\n  */\n package com.android.keyguard;\n \n+import com.android.keyguard.KeyguardSecurityModel.SecurityMode;\n+\n public interface KeyguardSecurityCallback {\n \n     /**\n      * Dismiss the given security screen.\n      * @param securityVerified true if the user correctly entered credentials for the given screen.\n      * @param targetUserId a user that needs to be the foreground user at the dismissal completion.\n+     * @param expectedSecurityMode The security mode that is invoking this dismiss.\n      */\n-    void dismiss(boolean securityVerified, int targetUserId);\n+    void dismiss(boolean securityVerified, int targetUserId, SecurityMode expectedSecurityMode);\n \n     /**\n      * Dismiss the given security screen.\n@@ -30,8 +33,10 @@ public interface KeyguardSecurityCallback {\n      * @param targetUserId a user that needs to be the foreground user at the dismissal completion.\n      * @param bypassSecondaryLockScreen true if the user can bypass the secondary lock screen,\n      *                                  if any, during this dismissal.\n+     * @param expectedSecurityMode The security mode that is invoking this dismiss.\n      */\n-    void dismiss(boolean securityVerified, int targetUserId, boolean bypassSecondaryLockScreen);\n+    void dismiss(boolean securityVerified, int targetUserId, boolean bypassSecondaryLockScreen,\n+            SecurityMode expectedSecurityMode);\n \n     /**\n      * Manually report user activity to keep the device awake.\n",
    "added_lines": 7,
    "deleted_lines": 2,
    "changed_methods": ""
   },
   {
    "filename": "KeyguardSecurityContainer.java",
    "diff": "@@ -181,7 +181,12 @@ public class KeyguardSecurityContainer extends FrameLayout {\n \n     // Used to notify the container when something interesting happens.\n     public interface SecurityCallback {\n-        boolean dismiss(boolean authenticated, int targetUserId, boolean bypassSecondaryLockScreen);\n+        /**\n+         * Potentially dismiss the current security screen, after validating that all device\n+         * security has been unlocked. Otherwise show the next screen.\n+         */\n+        boolean dismiss(boolean authenticated, int targetUserId, boolean bypassSecondaryLockScreen,\n+                SecurityMode expectedSecurityMode);\n \n         void userActivity();\n \n",
    "added_lines": 6,
    "deleted_lines": 1,
    "changed_methods": ""
   },
   {
    "filename": "KeyguardSecurityContainerController.java",
    "diff": "@@ -136,14 +136,17 @@ public class KeyguardSecurityContainerController extends ViewController<Keyguard\n         }\n \n         @Override\n-        public void dismiss(boolean authenticated, int targetId) {\n-            dismiss(authenticated, targetId, /* bypassSecondaryLockScreen */ false);\n+        public void dismiss(boolean authenticated, int targetId,\n+                SecurityMode expectedSecurityMode) {\n+            dismiss(authenticated, targetId, /* bypassSecondaryLockScreen */ false,\n+                    expectedSecurityMode);\n         }\n \n         @Override\n         public void dismiss(boolean authenticated, int targetId,\n-                boolean bypassSecondaryLockScreen) {\n-            mSecurityCallback.dismiss(authenticated, targetId, bypassSecondaryLockScreen);\n+                boolean bypassSecondaryLockScreen, SecurityMode expectedSecurityMode) {\n+            mSecurityCallback.dismiss(authenticated, targetId, bypassSecondaryLockScreen,\n+                    expectedSecurityMode);\n         }\n \n         public boolean isVerifyUnlockOnly() {\n@@ -307,8 +310,13 @@ public class KeyguardSecurityContainerController extends ViewController<Keyguard\n         return mCurrentSecurityMode;\n     }\n \n-    public void dismiss(boolean authenticated, int targetUserId) {\n-        mKeyguardSecurityCallback.dismiss(authenticated, targetUserId);\n+    /**\n+     * Potentially dismiss the current security screen, after validating that all device\n+     * security has been unlocked. Otherwise show the next screen.\n+     */\n+    public void dismiss(boolean authenticated, int targetUserId,\n+            SecurityMode expectedSecurityMode) {\n+        mKeyguardSecurityCallback.dismiss(authenticated, targetUserId, expectedSecurityMode);\n     }\n \n     public void reset() {\n@@ -367,12 +375,21 @@ public class KeyguardSecurityContainerController extends ViewController<Keyguard\n      *     completion.\n      * @param bypassSecondaryLockScreen true if the user is allowed to bypass the secondary\n      *     secondary lock screen requirement, if any.\n+     * @param expectedSecurityMode SecurityMode that is invoking this request. SecurityMode.Invalid\n+     *      indicates that no check should be done\n      * @return true if keyguard is done\n      */\n     public boolean showNextSecurityScreenOrFinish(boolean authenticated, int targetUserId,\n-            boolean bypassSecondaryLockScreen) {\n+            boolean bypassSecondaryLockScreen, SecurityMode expectedSecurityMode) {\n \n         if (DEBUG) Log.d(TAG, \"showNextSecurityScreenOrFinish(\" + authenticated + \")\");\n+        if (expectedSecurityMode != SecurityMode.Invalid\n+                && expectedSecurityMode != getCurrentSecurityMode()) {\n+            Log.w(TAG, \"Attempted to invoke showNextSecurityScreenOrFinish with securityMode \"\n+                    + expectedSecurityMode + \", but current mode is \" + getCurrentSecurityMode());\n+            return false;\n+        }\n+\n         boolean finish = false;\n         boolean strongAuth = false;\n         int eventSubtype = -1;\n",
    "added_lines": 24,
    "deleted_lines": 7,
    "changed_methods": "KeyguardSecurityContainerController::showNextSecurityScreenOrFinish, KeyguardSecurityContainerController::showNextSecurityScreenOrFinish, KeyguardSecurityContainerController::dismiss, KeyguardSecurityContainerController::KeyguardSecurityCallback, KeyguardSecurityContainerController::dismiss"
   },
   {
    "filename": "KeyguardSimPinViewController.java",
    "diff": "@@ -162,7 +162,8 @@ public class KeyguardSimPinViewController\n                             mRemainingAttempts = -1;\n                             mShowDefaultMessage = true;\n                             getKeyguardSecurityCallback().dismiss(\n-                                    true, KeyguardUpdateMonitor.getCurrentUser());\n+                                    true, KeyguardUpdateMonitor.getCurrentUser(),\n+                                    SecurityMode.SimPin);\n                         } else {\n                             mShowDefaultMessage = false;\n                             if (result.getResult() == PinResult.PIN_RESULT_TYPE_INCORRECT) {\n",
    "added_lines": 2,
    "deleted_lines": 1,
    "changed_methods": "KeyguardSimPinViewController::verifyPasswordAndUnlock"
   },
   {
    "filename": "KeyguardSimPukViewController.java",
    "diff": "@@ -69,7 +69,8 @@ public class KeyguardSimPukViewController\n             if (simState == TelephonyManager.SIM_STATE_READY) {\n                 mRemainingAttempts = -1;\n                 mShowDefaultMessage = true;\n-                getKeyguardSecurityCallback().dismiss(true, KeyguardUpdateMonitor.getCurrentUser());\n+                getKeyguardSecurityCallback().dismiss(true, KeyguardUpdateMonitor.getCurrentUser(),\n+                        SecurityMode.SimPuk);\n             } else {\n                 resetState();\n             }\n@@ -274,7 +275,8 @@ public class KeyguardSimPukViewController\n                             mShowDefaultMessage = true;\n \n                             getKeyguardSecurityCallback().dismiss(\n-                                    true, KeyguardUpdateMonitor.getCurrentUser());\n+                                    true, KeyguardUpdateMonitor.getCurrentUser(),\n+                                    SecurityMode.SimPuk);\n                         } else {\n                             mShowDefaultMessage = false;\n                             if (result.getResult() == PinResult.PIN_RESULT_TYPE_INCORRECT) {\n",
    "added_lines": 4,
    "deleted_lines": 2,
    "changed_methods": "KeyguardSimPukViewController::KeyguardUpdateMonitorCallback, KeyguardSimPukViewController::updateSim"
   },
   {
    "filename": "AdminSecondaryLockScreenControllerTest.java",
    "diff": "@@ -44,6 +44,7 @@ import android.view.SurfaceView;\n \n import androidx.test.filters.SmallTest;\n \n+import com.android.keyguard.KeyguardSecurityModel.SecurityMode;\n import com.android.systemui.SysuiTestCase;\n \n import org.junit.After;\n@@ -190,7 +191,7 @@ public class AdminSecondaryLockScreenControllerTest extends SysuiTestCase {\n \n     private void verifyViewDismissed(SurfaceView v) throws Exception {\n         verify(mKeyguardSecurityContainer).removeView(v);\n-        verify(mKeyguardCallback).dismiss(true, TARGET_USER_ID, true);\n+        verify(mKeyguardCallback).dismiss(true, TARGET_USER_ID, true, SecurityMode.Invalid);\n         assertThat(mContext.isBound(mComponentName)).isFalse();\n     }\n }\n",
    "added_lines": 2,
    "deleted_lines": 1,
    "changed_methods": "AdminSecondaryLockScreenControllerTest::verifyViewDismissed"
   },
   {
    "filename": "KeyguardSecurityContainerControllerTest.java",
    "diff": "@@ -18,6 +18,8 @@ package com.android.keyguard;\n \n import static android.view.WindowInsets.Type.ime;\n \n+import static com.google.common.truth.Truth.assertThat;\n+\n import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.ArgumentMatchers.anyBoolean;\n import static org.mockito.ArgumentMatchers.anyInt;\n@@ -62,6 +64,7 @@ import org.mockito.junit.MockitoRule;\n @RunWith(AndroidTestingRunner.class)\n @TestableLooper.RunWithLooper()\n public class KeyguardSecurityContainerControllerTest extends SysuiTestCase {\n+    private static final int TARGET_USER_ID = 100;\n     private static final int VIEW_WIDTH = 1600;\n \n     @Rule\n@@ -330,4 +333,42 @@ public class KeyguardSecurityContainerControllerTest extends SysuiTestCase {\n                 R.bool.can_use_one_handed_bouncer))\n                 .thenReturn(sysuiResourceCanUseOneHandedKeyguard);\n     }\n+\n+    @Test\n+    public void showNextSecurityScreenOrFinish_setsSecurityScreenToPinAfterSimPinUnlock() {\n+        // GIVEN the current security method is SimPin\n+        when(mKeyguardUpdateMonitor.getUserHasTrust(anyInt())).thenReturn(false);\n+        when(mKeyguardUpdateMonitor.getUserUnlockedWithBiometric(TARGET_USER_ID)).thenReturn(false);\n+        mKeyguardSecurityContainerController.showSecurityScreen(SecurityMode.SimPin);\n+\n+        // WHEN a request is made from the SimPin screens to show the next security method\n+        when(mKeyguardSecurityModel.getSecurityMode(TARGET_USER_ID)).thenReturn(SecurityMode.PIN);\n+        mKeyguardSecurityContainerController.showNextSecurityScreenOrFinish(\n+                /* authenticated= */true,\n+                TARGET_USER_ID,\n+                /* bypassSecondaryLockScreen= */true,\n+                SecurityMode.SimPin);\n+\n+        // THEN the next security method of PIN is set, and the keyguard is not marked as done\n+        verify(mSecurityCallback, never()).finish(anyBoolean(), anyInt());\n+        assertThat(mKeyguardSecurityContainerController.getCurrentSecurityMode())\n+                .isEqualTo(SecurityMode.PIN);\n+    }\n+\n+    @Test\n+    public void showNextSecurityScreenOrFinish_ignoresCallWhenSecurityMethodHasChanged() {\n+        //GIVEN current security mode has been set to PIN\n+        mKeyguardSecurityContainerController.showSecurityScreen(SecurityMode.PIN);\n+\n+        //WHEN a request comes from SimPin to dismiss the security screens\n+        boolean keyguardDone = mKeyguardSecurityContainerController.showNextSecurityScreenOrFinish(\n+                /* authenticated= */true,\n+                TARGET_USER_ID,\n+                /* bypassSecondaryLockScreen= */true,\n+                SecurityMode.SimPin);\n+\n+        //THEN no action has happened, which will not dismiss the security screens\n+        assertThat(keyguardDone).isEqualTo(false);\n+        verify(mKeyguardUpdateMonitor, never()).getUserHasTrust(anyInt());\n+    }\n }\n",
    "added_lines": 41,
    "deleted_lines": 0,
    "changed_methods": "KeyguardSecurityContainerControllerTest::showNextSecurityScreenOrFinish_ignoresCallWhenSecurityMethodHasChanged, KeyguardSecurityContainerControllerTest::showNextSecurityScreenOrFinish_setsSecurityScreenToPinAfterSimPinUnlock"
   }
  ]
 },
 {
  "hash": "b6ce47054c0770ce028e44b165610a65417dfd33",
  "commit": "Limit the number of concurrently snoozed notifications\n\nTest: atest FrameworksUiServicesTests\nBug: 234441463\nChange-Id: I005b43979d1c708fd505c8b33ae0c8cb03ddbb35\nMerged-In: I005b43979d1c708fd505c8b33ae0c8cb03ddbb35\n(cherry picked from commit 7c38394ae9c69620499a87e629edae4fe0ac4edc)\n(cherry picked from commit bc808de2f8a88e76fde0b6d033b4a232aebff8cb)\nMerged-In: I005b43979d1c708fd505c8b33ae0c8cb03ddbb35",
  "files": [
   {
    "filename": "NotificationManagerService.java",
    "diff": "@@ -6751,6 +6751,7 @@ public class NotificationManagerService extends SystemService {\n \n         @GuardedBy(\"mNotificationLock\")\n         void snoozeLocked(NotificationRecord r) {\n+            final List<NotificationRecord> recordsToSnooze = new ArrayList<>();\n             if (r.getSbn().isGroup()) {\n                 final List<NotificationRecord> groupNotifications =\n                         findCurrentAndSnoozedGroupNotificationsLocked(\n@@ -6759,8 +6760,8 @@ public class NotificationManagerService extends SystemService {\n                 if (r.getNotification().isGroupSummary()) {\n                     // snooze all children\n                     for (int i = 0; i < groupNotifications.size(); i++) {\n-                        if (mKey != groupNotifications.get(i).getKey()) {\n-                            snoozeNotificationLocked(groupNotifications.get(i));\n+                        if (!mKey.equals(groupNotifications.get(i).getKey())) {\n+                            recordsToSnooze.add(groupNotifications.get(i));\n                         }\n                     }\n                 } else {\n@@ -6770,8 +6771,8 @@ public class NotificationManagerService extends SystemService {\n                         if (groupNotifications.size() == 2) {\n                             // snooze summary and the one child\n                             for (int i = 0; i < groupNotifications.size(); i++) {\n-                                if (mKey != groupNotifications.get(i).getKey()) {\n-                                    snoozeNotificationLocked(groupNotifications.get(i));\n+                                if (!mKey.equals(groupNotifications.get(i).getKey())) {\n+                                    recordsToSnooze.add(groupNotifications.get(i));\n                                 }\n                             }\n                         }\n@@ -6779,7 +6780,15 @@ public class NotificationManagerService extends SystemService {\n                 }\n             }\n             // snooze the notification\n-            snoozeNotificationLocked(r);\n+            recordsToSnooze.add(r);\n+\n+            if (mSnoozeHelper.canSnooze(recordsToSnooze.size())) {\n+                for (int i = 0; i < recordsToSnooze.size(); i++) {\n+                    snoozeNotificationLocked(recordsToSnooze.get(i));\n+                }\n+            } else {\n+                Log.w(TAG, \"Cannot snooze \" + r.getKey() + \": too many snoozed notifications\");\n+            }\n \n         }\n \n",
    "added_lines": 14,
    "deleted_lines": 5,
    "changed_methods": "NotificationManagerService::SnoozeNotificationRunnable::snoozeLocked"
   },
   {
    "filename": "SnoozeHelper.java",
    "diff": "@@ -62,6 +62,8 @@ import java.util.Set;\n public class SnoozeHelper {\n     public static final int XML_SNOOZED_NOTIFICATION_VERSION = 1;\n \n+    static final int CONCURRENT_SNOOZE_LIMIT = 500;\n+\n     protected static final String XML_TAG_NAME = \"snoozed-notifications\";\n \n     private static final String XML_SNOOZED_NOTIFICATION = \"notification\";\n@@ -134,6 +136,15 @@ public class SnoozeHelper {\n         }\n     }\n \n+    protected boolean canSnooze(int numberToSnooze) {\n+        synchronized (mLock) {\n+            if ((mPackages.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n     @NonNull\n     protected Long getSnoozeTimeForUnpostedNotification(int userId, String pkg, String key) {\n         Long time = null;\n",
    "added_lines": 11,
    "deleted_lines": 0,
    "changed_methods": "SnoozeHelper::canSnooze"
   },
   {
    "filename": "NotificationManagerServiceTest.java",
    "diff": "@@ -2798,20 +2798,81 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n                 any(NotificationManagerService.SnoozeNotificationRunnable.class));\n     }\n \n+    @Test\n+    public void testSnoozeRunnable_tooManySnoozed_singleNotification() {\n+        final NotificationRecord notification = generateNotificationRecord(\n+                mTestNotificationChannel, 1, null, true);\n+        mService.addNotification(notification);\n+\n+        when(mSnoozeHelper.canSnooze(anyInt())).thenReturn(true);\n+        when(mSnoozeHelper.canSnooze(1)).thenReturn(false);\n+\n+        NotificationManagerService.SnoozeNotificationRunnable snoozeNotificationRunnable =\n+                mService.new SnoozeNotificationRunnable(\n+                        notification.getKey(), 100, null);\n+        snoozeNotificationRunnable.run();\n+\n+        verify(mSnoozeHelper, never()).snooze(any(NotificationRecord.class), anyLong());\n+        assertEquals(1, mService.getNotificationRecordCount());\n+    }\n+\n+    @Test\n+    public void testSnoozeRunnable_tooManySnoozed_singleGroupChildNotification() {\n+        final NotificationRecord notification = generateNotificationRecord(\n+                mTestNotificationChannel, 1, \"group\", true);\n+        final NotificationRecord notificationChild = generateNotificationRecord(\n+                mTestNotificationChannel, 1, \"group\", false);\n+        mService.addNotification(notification);\n+        mService.addNotification(notificationChild);\n+\n+        when(mSnoozeHelper.canSnooze(anyInt())).thenReturn(true);\n+        when(mSnoozeHelper.canSnooze(2)).thenReturn(false);\n+\n+        NotificationManagerService.SnoozeNotificationRunnable snoozeNotificationRunnable =\n+                mService.new SnoozeNotificationRunnable(\n+                        notificationChild.getKey(), 100, null);\n+        snoozeNotificationRunnable.run();\n+\n+        verify(mSnoozeHelper, never()).snooze(any(NotificationRecord.class), anyLong());\n+        assertEquals(2, mService.getNotificationRecordCount());\n+    }\n+\n+    @Test\n+    public void testSnoozeRunnable_tooManySnoozed_summaryNotification() {\n+        final NotificationRecord notification = generateNotificationRecord(\n+                mTestNotificationChannel, 1, \"group\", true);\n+        final NotificationRecord notificationChild = generateNotificationRecord(\n+                mTestNotificationChannel, 12, \"group\", false);\n+        final NotificationRecord notificationChild2 = generateNotificationRecord(\n+                mTestNotificationChannel, 13, \"group\", false);\n+        mService.addNotification(notification);\n+        mService.addNotification(notificationChild);\n+        mService.addNotification(notificationChild2);\n+\n+        when(mSnoozeHelper.canSnooze(anyInt())).thenReturn(true);\n+        when(mSnoozeHelper.canSnooze(3)).thenReturn(false);\n+\n+        NotificationManagerService.SnoozeNotificationRunnable snoozeNotificationRunnable =\n+                mService.new SnoozeNotificationRunnable(\n+                        notification.getKey(), 100, null);\n+        snoozeNotificationRunnable.run();\n+\n+        verify(mSnoozeHelper, never()).snooze(any(NotificationRecord.class), anyLong());\n+        assertEquals(3, mService.getNotificationRecordCount());\n+    }\n+\n     @Test\n     public void testSnoozeRunnable_reSnoozeASingleSnoozedNotification() throws Exception {\n         final NotificationRecord notification = generateNotificationRecord(\n                 mTestNotificationChannel, 1, null, true);\n         mService.addNotification(notification);\n         when(mSnoozeHelper.getNotification(any())).thenReturn(notification);\n+        when(mSnoozeHelper.canSnooze(anyInt())).thenReturn(true);\n \n         NotificationManagerService.SnoozeNotificationRunnable snoozeNotificationRunnable =\n                 mService.new SnoozeNotificationRunnable(\n                 notification.getKey(), 100, null);\n         snoozeNotificationRunnable.run();\n-        NotificationManagerService.SnoozeNotificationRunnable snoozeNotificationRunnable2 =\n-                mService.new SnoozeNotificationRunnable(\n-                notification.getKey(), 100, null);\n         snoozeNotificationRunnable.run();\n \n         // snooze twice\n@@ -2819,19 +2880,17 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n     }\n \n     @Test\n-    public void testSnoozeRunnable_reSnoozeASnoozedNotificationWithGroupKey() throws Exception {\n+    public void testSnoozeRunnable_reSnoozeASnoozedNotificationWithGroupKey() {\n         final NotificationRecord notification = generateNotificationRecord(\n                 mTestNotificationChannel, 1, \"group\", true);\n         mService.addNotification(notification);\n         when(mSnoozeHelper.getNotification(any())).thenReturn(notification);\n+        when(mSnoozeHelper.canSnooze(anyInt())).thenReturn(true);\n \n         NotificationManagerService.SnoozeNotificationRunnable snoozeNotificationRunnable =\n                 mService.new SnoozeNotificationRunnable(\n                 notification.getKey(), 100, null);\n         snoozeNotificationRunnable.run();\n-        NotificationManagerService.SnoozeNotificationRunnable snoozeNotificationRunnable2 =\n-                mService.new SnoozeNotificationRunnable(\n-                notification.getKey(), 100, null);\n         snoozeNotificationRunnable.run();\n \n         // snooze twice\n@@ -2849,6 +2908,7 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n         when(mSnoozeHelper.getNotification(any())).thenReturn(notification);\n         when(mSnoozeHelper.getNotifications(\n                 anyString(), anyString(), anyInt())).thenReturn(new ArrayList<>());\n+        when(mSnoozeHelper.canSnooze(anyInt())).thenReturn(true);\n \n         NotificationManagerService.SnoozeNotificationRunnable snoozeNotificationRunnable =\n                 mService.new SnoozeNotificationRunnable(\n@@ -2858,8 +2918,8 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n                 .thenReturn(new ArrayList<>(Arrays.asList(notification, notification2)));\n         NotificationManagerService.SnoozeNotificationRunnable snoozeNotificationRunnable2 =\n                 mService.new SnoozeNotificationRunnable(\n-                        notification.getKey(), 100, null);\n-        snoozeNotificationRunnable.run();\n+                        notification2.getKey(), 100, null);\n+        snoozeNotificationRunnable2.run();\n \n         // snooze twice\n         verify(mSnoozeHelper, times(4)).snooze(any(NotificationRecord.class), anyLong());\n@@ -2873,6 +2933,7 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n                 mTestNotificationChannel, 2, \"group\", false);\n         mService.addNotification(grouped);\n         mService.addNotification(nonGrouped);\n+        when(mSnoozeHelper.canSnooze(anyInt())).thenReturn(true);\n \n         NotificationManagerService.SnoozeNotificationRunnable snoozeNotificationRunnable =\n                 mService.new SnoozeNotificationRunnable(\n@@ -2902,6 +2963,7 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n         mService.addNotification(parent);\n         mService.addNotification(child);\n         mService.addNotification(child2);\n+        when(mSnoozeHelper.canSnooze(anyInt())).thenReturn(true);\n \n         NotificationManagerService.SnoozeNotificationRunnable snoozeNotificationRunnable =\n                 mService.new SnoozeNotificationRunnable(\n@@ -2923,6 +2985,7 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n         mService.addNotification(parent);\n         mService.addNotification(child);\n         mService.addNotification(child2);\n+        when(mSnoozeHelper.canSnooze(anyInt())).thenReturn(true);\n \n         NotificationManagerService.SnoozeNotificationRunnable snoozeNotificationRunnable =\n                 mService.new SnoozeNotificationRunnable(\n@@ -2948,6 +3011,7 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n                 mTestNotificationChannel, 2, \"group\", false);\n         mService.addNotification(parent);\n         mService.addNotification(child);\n+        when(mSnoozeHelper.canSnooze(anyInt())).thenReturn(true);\n \n         NotificationManagerService.SnoozeNotificationRunnable snoozeNotificationRunnable =\n                 mService.new SnoozeNotificationRunnable(\n@@ -2975,6 +3039,7 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n         final NotificationRecord child = generateNotificationRecord(\n                 mTestNotificationChannel, 2, \"group\", false);\n         mService.addNotification(child);\n+        when(mSnoozeHelper.canSnooze(anyInt())).thenReturn(true);\n \n         NotificationManagerService.SnoozeNotificationRunnable snoozeNotificationRunnable =\n                 mService.new SnoozeNotificationRunnable(\n",
    "added_lines": 74,
    "deleted_lines": 9,
    "changed_methods": "NotificationManagerServiceTest::testSnoozeRunnable_reSnoozeASingleSnoozedNotification, NotificationManagerServiceTest::testSnoozeRunnable_snoozeSummary_withChildren, NotificationManagerServiceTest::testSnoozeRunnable_tooManySnoozed_singleNotification, NotificationManagerServiceTest::testSnoozeRunnable_tooManySnoozed_singleGroupChildNotification, NotificationManagerServiceTest::testSnoozeRunnable_reSnoozeASnoozedNotificationWithGroupKey, NotificationManagerServiceTest::testSnoozeRunnable_snoozeGroupChild_fellowChildren, NotificationManagerServiceTest::testSnoozeRunnable_reSnoozeMultipleNotificationsWithGroupKey, NotificationManagerServiceTest::testSnoozeRunnable_snoozeGroupChild_noOthersInGroup, NotificationManagerServiceTest::testSnoozeRunnable_tooManySnoozed_summaryNotification, NotificationManagerServiceTest::testSnoozeRunnable_snoozeNonGrouped, NotificationManagerServiceTest::testSnoozeRunnable_snoozeGroupChild_onlyChildOfSummary"
   },
   {
    "filename": "SnoozeHelperTest.java",
    "diff": "@@ -15,6 +15,7 @@\n  */\n package com.android.server.notification;\n \n+import static com.android.server.notification.SnoozeHelper.CONCURRENT_SNOOZE_LIMIT;\n import static com.android.server.notification.SnoozeHelper.EXTRA_KEY;\n \n import static junit.framework.Assert.assertEquals;\n@@ -280,6 +281,22 @@ public class SnoozeHelperTest extends UiServiceTestCase {\n                 UserHandle.USER_SYSTEM, r.getSbn().getPackageName(), r.getKey()));\n     }\n \n+    @Test\n+    public void testSnoozeLimit() {\n+        for (int i = 0; i < CONCURRENT_SNOOZE_LIMIT; i++ ) {\n+            NotificationRecord r = getNotificationRecord(\"pkg\", i, i+\"\", UserHandle.SYSTEM);\n+\n+            assertTrue(\"cannot snooze record \" + i, mSnoozeHelper.canSnooze(1));\n+\n+            if (i % 2 == 0) {\n+                mSnoozeHelper.snooze(r, null);\n+            } else {\n+                mSnoozeHelper.snooze(r, 9000);\n+            }\n+        }\n+        assertFalse(mSnoozeHelper.canSnooze(1));\n+    }\n+\n     @Test\n     public void testCancelByApp() throws Exception {\n         NotificationRecord r = getNotificationRecord(\"pkg\", 1, \"one\", UserHandle.SYSTEM);\n",
    "added_lines": 17,
    "deleted_lines": 0,
    "changed_methods": "SnoozeHelperTest::testSnoozeLimit"
   }
  ]
 },
 {
  "hash": "b6ce47054c0770ce028e44b165610a65417dfd33",
  "commit": "Limit the number of concurrently snoozed notifications\n\nTest: atest FrameworksUiServicesTests\nBug: 234441463\nChange-Id: I005b43979d1c708fd505c8b33ae0c8cb03ddbb35\nMerged-In: I005b43979d1c708fd505c8b33ae0c8cb03ddbb35\n(cherry picked from commit 7c38394ae9c69620499a87e629edae4fe0ac4edc)\n(cherry picked from commit bc808de2f8a88e76fde0b6d033b4a232aebff8cb)\nMerged-In: I005b43979d1c708fd505c8b33ae0c8cb03ddbb35",
  "files": [
   {
    "filename": "NotificationManagerService.java",
    "diff": "@@ -6751,6 +6751,7 @@ public class NotificationManagerService extends SystemService {\n \n         @GuardedBy(\"mNotificationLock\")\n         void snoozeLocked(NotificationRecord r) {\n+            final List<NotificationRecord> recordsToSnooze = new ArrayList<>();\n             if (r.getSbn().isGroup()) {\n                 final List<NotificationRecord> groupNotifications =\n                         findCurrentAndSnoozedGroupNotificationsLocked(\n@@ -6759,8 +6760,8 @@ public class NotificationManagerService extends SystemService {\n                 if (r.getNotification().isGroupSummary()) {\n                     // snooze all children\n                     for (int i = 0; i < groupNotifications.size(); i++) {\n-                        if (mKey != groupNotifications.get(i).getKey()) {\n-                            snoozeNotificationLocked(groupNotifications.get(i));\n+                        if (!mKey.equals(groupNotifications.get(i).getKey())) {\n+                            recordsToSnooze.add(groupNotifications.get(i));\n                         }\n                     }\n                 } else {\n@@ -6770,8 +6771,8 @@ public class NotificationManagerService extends SystemService {\n                         if (groupNotifications.size() == 2) {\n                             // snooze summary and the one child\n                             for (int i = 0; i < groupNotifications.size(); i++) {\n-                                if (mKey != groupNotifications.get(i).getKey()) {\n-                                    snoozeNotificationLocked(groupNotifications.get(i));\n+                                if (!mKey.equals(groupNotifications.get(i).getKey())) {\n+                                    recordsToSnooze.add(groupNotifications.get(i));\n                                 }\n                             }\n                         }\n@@ -6779,7 +6780,15 @@ public class NotificationManagerService extends SystemService {\n                 }\n             }\n             // snooze the notification\n-            snoozeNotificationLocked(r);\n+            recordsToSnooze.add(r);\n+\n+            if (mSnoozeHelper.canSnooze(recordsToSnooze.size())) {\n+                for (int i = 0; i < recordsToSnooze.size(); i++) {\n+                    snoozeNotificationLocked(recordsToSnooze.get(i));\n+                }\n+            } else {\n+                Log.w(TAG, \"Cannot snooze \" + r.getKey() + \": too many snoozed notifications\");\n+            }\n \n         }\n \n",
    "added_lines": 14,
    "deleted_lines": 5,
    "changed_methods": "NotificationManagerService::SnoozeNotificationRunnable::snoozeLocked"
   },
   {
    "filename": "SnoozeHelper.java",
    "diff": "@@ -62,6 +62,8 @@ import java.util.Set;\n public class SnoozeHelper {\n     public static final int XML_SNOOZED_NOTIFICATION_VERSION = 1;\n \n+    static final int CONCURRENT_SNOOZE_LIMIT = 500;\n+\n     protected static final String XML_TAG_NAME = \"snoozed-notifications\";\n \n     private static final String XML_SNOOZED_NOTIFICATION = \"notification\";\n@@ -134,6 +136,15 @@ public class SnoozeHelper {\n         }\n     }\n \n+    protected boolean canSnooze(int numberToSnooze) {\n+        synchronized (mLock) {\n+            if ((mPackages.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n     @NonNull\n     protected Long getSnoozeTimeForUnpostedNotification(int userId, String pkg, String key) {\n         Long time = null;\n",
    "added_lines": 11,
    "deleted_lines": 0,
    "changed_methods": "SnoozeHelper::canSnooze"
   },
   {
    "filename": "NotificationManagerServiceTest.java",
    "diff": "@@ -2798,20 +2798,81 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n                 any(NotificationManagerService.SnoozeNotificationRunnable.class));\n     }\n \n+    @Test\n+    public void testSnoozeRunnable_tooManySnoozed_singleNotification() {\n+        final NotificationRecord notification = generateNotificationRecord(\n+                mTestNotificationChannel, 1, null, true);\n+        mService.addNotification(notification);\n+\n+        when(mSnoozeHelper.canSnooze(anyInt())).thenReturn(true);\n+        when(mSnoozeHelper.canSnooze(1)).thenReturn(false);\n+\n+        NotificationManagerService.SnoozeNotificationRunnable snoozeNotificationRunnable =\n+                mService.new SnoozeNotificationRunnable(\n+                        notification.getKey(), 100, null);\n+        snoozeNotificationRunnable.run();\n+\n+        verify(mSnoozeHelper, never()).snooze(any(NotificationRecord.class), anyLong());\n+        assertEquals(1, mService.getNotificationRecordCount());\n+    }\n+\n+    @Test\n+    public void testSnoozeRunnable_tooManySnoozed_singleGroupChildNotification() {\n+        final NotificationRecord notification = generateNotificationRecord(\n+                mTestNotificationChannel, 1, \"group\", true);\n+        final NotificationRecord notificationChild = generateNotificationRecord(\n+                mTestNotificationChannel, 1, \"group\", false);\n+        mService.addNotification(notification);\n+        mService.addNotification(notificationChild);\n+\n+        when(mSnoozeHelper.canSnooze(anyInt())).thenReturn(true);\n+        when(mSnoozeHelper.canSnooze(2)).thenReturn(false);\n+\n+        NotificationManagerService.SnoozeNotificationRunnable snoozeNotificationRunnable =\n+                mService.new SnoozeNotificationRunnable(\n+                        notificationChild.getKey(), 100, null);\n+        snoozeNotificationRunnable.run();\n+\n+        verify(mSnoozeHelper, never()).snooze(any(NotificationRecord.class), anyLong());\n+        assertEquals(2, mService.getNotificationRecordCount());\n+    }\n+\n+    @Test\n+    public void testSnoozeRunnable_tooManySnoozed_summaryNotification() {\n+        final NotificationRecord notification = generateNotificationRecord(\n+                mTestNotificationChannel, 1, \"group\", true);\n+        final NotificationRecord notificationChild = generateNotificationRecord(\n+                mTestNotificationChannel, 12, \"group\", false);\n+        final NotificationRecord notificationChild2 = generateNotificationRecord(\n+                mTestNotificationChannel, 13, \"group\", false);\n+        mService.addNotification(notification);\n+        mService.addNotification(notificationChild);\n+        mService.addNotification(notificationChild2);\n+\n+        when(mSnoozeHelper.canSnooze(anyInt())).thenReturn(true);\n+        when(mSnoozeHelper.canSnooze(3)).thenReturn(false);\n+\n+        NotificationManagerService.SnoozeNotificationRunnable snoozeNotificationRunnable =\n+                mService.new SnoozeNotificationRunnable(\n+                        notification.getKey(), 100, null);\n+        snoozeNotificationRunnable.run();\n+\n+        verify(mSnoozeHelper, never()).snooze(any(NotificationRecord.class), anyLong());\n+        assertEquals(3, mService.getNotificationRecordCount());\n+    }\n+\n     @Test\n     public void testSnoozeRunnable_reSnoozeASingleSnoozedNotification() throws Exception {\n         final NotificationRecord notification = generateNotificationRecord(\n                 mTestNotificationChannel, 1, null, true);\n         mService.addNotification(notification);\n         when(mSnoozeHelper.getNotification(any())).thenReturn(notification);\n+        when(mSnoozeHelper.canSnooze(anyInt())).thenReturn(true);\n \n         NotificationManagerService.SnoozeNotificationRunnable snoozeNotificationRunnable =\n                 mService.new SnoozeNotificationRunnable(\n                 notification.getKey(), 100, null);\n         snoozeNotificationRunnable.run();\n-        NotificationManagerService.SnoozeNotificationRunnable snoozeNotificationRunnable2 =\n-                mService.new SnoozeNotificationRunnable(\n-                notification.getKey(), 100, null);\n         snoozeNotificationRunnable.run();\n \n         // snooze twice\n@@ -2819,19 +2880,17 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n     }\n \n     @Test\n-    public void testSnoozeRunnable_reSnoozeASnoozedNotificationWithGroupKey() throws Exception {\n+    public void testSnoozeRunnable_reSnoozeASnoozedNotificationWithGroupKey() {\n         final NotificationRecord notification = generateNotificationRecord(\n                 mTestNotificationChannel, 1, \"group\", true);\n         mService.addNotification(notification);\n         when(mSnoozeHelper.getNotification(any())).thenReturn(notification);\n+        when(mSnoozeHelper.canSnooze(anyInt())).thenReturn(true);\n \n         NotificationManagerService.SnoozeNotificationRunnable snoozeNotificationRunnable =\n                 mService.new SnoozeNotificationRunnable(\n                 notification.getKey(), 100, null);\n         snoozeNotificationRunnable.run();\n-        NotificationManagerService.SnoozeNotificationRunnable snoozeNotificationRunnable2 =\n-                mService.new SnoozeNotificationRunnable(\n-                notification.getKey(), 100, null);\n         snoozeNotificationRunnable.run();\n \n         // snooze twice\n@@ -2849,6 +2908,7 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n         when(mSnoozeHelper.getNotification(any())).thenReturn(notification);\n         when(mSnoozeHelper.getNotifications(\n                 anyString(), anyString(), anyInt())).thenReturn(new ArrayList<>());\n+        when(mSnoozeHelper.canSnooze(anyInt())).thenReturn(true);\n \n         NotificationManagerService.SnoozeNotificationRunnable snoozeNotificationRunnable =\n                 mService.new SnoozeNotificationRunnable(\n@@ -2858,8 +2918,8 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n                 .thenReturn(new ArrayList<>(Arrays.asList(notification, notification2)));\n         NotificationManagerService.SnoozeNotificationRunnable snoozeNotificationRunnable2 =\n                 mService.new SnoozeNotificationRunnable(\n-                        notification.getKey(), 100, null);\n-        snoozeNotificationRunnable.run();\n+                        notification2.getKey(), 100, null);\n+        snoozeNotificationRunnable2.run();\n \n         // snooze twice\n         verify(mSnoozeHelper, times(4)).snooze(any(NotificationRecord.class), anyLong());\n@@ -2873,6 +2933,7 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n                 mTestNotificationChannel, 2, \"group\", false);\n         mService.addNotification(grouped);\n         mService.addNotification(nonGrouped);\n+        when(mSnoozeHelper.canSnooze(anyInt())).thenReturn(true);\n \n         NotificationManagerService.SnoozeNotificationRunnable snoozeNotificationRunnable =\n                 mService.new SnoozeNotificationRunnable(\n@@ -2902,6 +2963,7 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n         mService.addNotification(parent);\n         mService.addNotification(child);\n         mService.addNotification(child2);\n+        when(mSnoozeHelper.canSnooze(anyInt())).thenReturn(true);\n \n         NotificationManagerService.SnoozeNotificationRunnable snoozeNotificationRunnable =\n                 mService.new SnoozeNotificationRunnable(\n@@ -2923,6 +2985,7 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n         mService.addNotification(parent);\n         mService.addNotification(child);\n         mService.addNotification(child2);\n+        when(mSnoozeHelper.canSnooze(anyInt())).thenReturn(true);\n \n         NotificationManagerService.SnoozeNotificationRunnable snoozeNotificationRunnable =\n                 mService.new SnoozeNotificationRunnable(\n@@ -2948,6 +3011,7 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n                 mTestNotificationChannel, 2, \"group\", false);\n         mService.addNotification(parent);\n         mService.addNotification(child);\n+        when(mSnoozeHelper.canSnooze(anyInt())).thenReturn(true);\n \n         NotificationManagerService.SnoozeNotificationRunnable snoozeNotificationRunnable =\n                 mService.new SnoozeNotificationRunnable(\n@@ -2975,6 +3039,7 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n         final NotificationRecord child = generateNotificationRecord(\n                 mTestNotificationChannel, 2, \"group\", false);\n         mService.addNotification(child);\n+        when(mSnoozeHelper.canSnooze(anyInt())).thenReturn(true);\n \n         NotificationManagerService.SnoozeNotificationRunnable snoozeNotificationRunnable =\n                 mService.new SnoozeNotificationRunnable(\n",
    "added_lines": 74,
    "deleted_lines": 9,
    "changed_methods": "NotificationManagerServiceTest::testSnoozeRunnable_reSnoozeASingleSnoozedNotification, NotificationManagerServiceTest::testSnoozeRunnable_snoozeSummary_withChildren, NotificationManagerServiceTest::testSnoozeRunnable_tooManySnoozed_singleNotification, NotificationManagerServiceTest::testSnoozeRunnable_tooManySnoozed_singleGroupChildNotification, NotificationManagerServiceTest::testSnoozeRunnable_reSnoozeASnoozedNotificationWithGroupKey, NotificationManagerServiceTest::testSnoozeRunnable_snoozeGroupChild_fellowChildren, NotificationManagerServiceTest::testSnoozeRunnable_reSnoozeMultipleNotificationsWithGroupKey, NotificationManagerServiceTest::testSnoozeRunnable_snoozeGroupChild_noOthersInGroup, NotificationManagerServiceTest::testSnoozeRunnable_tooManySnoozed_summaryNotification, NotificationManagerServiceTest::testSnoozeRunnable_snoozeNonGrouped, NotificationManagerServiceTest::testSnoozeRunnable_snoozeGroupChild_onlyChildOfSummary"
   },
   {
    "filename": "SnoozeHelperTest.java",
    "diff": "@@ -15,6 +15,7 @@\n  */\n package com.android.server.notification;\n \n+import static com.android.server.notification.SnoozeHelper.CONCURRENT_SNOOZE_LIMIT;\n import static com.android.server.notification.SnoozeHelper.EXTRA_KEY;\n \n import static junit.framework.Assert.assertEquals;\n@@ -280,6 +281,22 @@ public class SnoozeHelperTest extends UiServiceTestCase {\n                 UserHandle.USER_SYSTEM, r.getSbn().getPackageName(), r.getKey()));\n     }\n \n+    @Test\n+    public void testSnoozeLimit() {\n+        for (int i = 0; i < CONCURRENT_SNOOZE_LIMIT; i++ ) {\n+            NotificationRecord r = getNotificationRecord(\"pkg\", i, i+\"\", UserHandle.SYSTEM);\n+\n+            assertTrue(\"cannot snooze record \" + i, mSnoozeHelper.canSnooze(1));\n+\n+            if (i % 2 == 0) {\n+                mSnoozeHelper.snooze(r, null);\n+            } else {\n+                mSnoozeHelper.snooze(r, 9000);\n+            }\n+        }\n+        assertFalse(mSnoozeHelper.canSnooze(1));\n+    }\n+\n     @Test\n     public void testCancelByApp() throws Exception {\n         NotificationRecord r = getNotificationRecord(\"pkg\", 1, \"one\", UserHandle.SYSTEM);\n",
    "added_lines": 17,
    "deleted_lines": 0,
    "changed_methods": "SnoozeHelperTest::testSnoozeLimit"
   }
  ]
 },
 {
  "hash": "b6ce47054c0770ce028e44b165610a65417dfd33",
  "commit": "Limit the number of concurrently snoozed notifications\n\nTest: atest FrameworksUiServicesTests\nBug: 234441463\nChange-Id: I005b43979d1c708fd505c8b33ae0c8cb03ddbb35\nMerged-In: I005b43979d1c708fd505c8b33ae0c8cb03ddbb35\n(cherry picked from commit 7c38394ae9c69620499a87e629edae4fe0ac4edc)\n(cherry picked from commit bc808de2f8a88e76fde0b6d033b4a232aebff8cb)\nMerged-In: I005b43979d1c708fd505c8b33ae0c8cb03ddbb35",
  "files": [
   {
    "filename": "NotificationManagerService.java",
    "diff": "@@ -6751,6 +6751,7 @@ public class NotificationManagerService extends SystemService {\n \n         @GuardedBy(\"mNotificationLock\")\n         void snoozeLocked(NotificationRecord r) {\n+            final List<NotificationRecord> recordsToSnooze = new ArrayList<>();\n             if (r.getSbn().isGroup()) {\n                 final List<NotificationRecord> groupNotifications =\n                         findCurrentAndSnoozedGroupNotificationsLocked(\n@@ -6759,8 +6760,8 @@ public class NotificationManagerService extends SystemService {\n                 if (r.getNotification().isGroupSummary()) {\n                     // snooze all children\n                     for (int i = 0; i < groupNotifications.size(); i++) {\n-                        if (mKey != groupNotifications.get(i).getKey()) {\n-                            snoozeNotificationLocked(groupNotifications.get(i));\n+                        if (!mKey.equals(groupNotifications.get(i).getKey())) {\n+                            recordsToSnooze.add(groupNotifications.get(i));\n                         }\n                     }\n                 } else {\n@@ -6770,8 +6771,8 @@ public class NotificationManagerService extends SystemService {\n                         if (groupNotifications.size() == 2) {\n                             // snooze summary and the one child\n                             for (int i = 0; i < groupNotifications.size(); i++) {\n-                                if (mKey != groupNotifications.get(i).getKey()) {\n-                                    snoozeNotificationLocked(groupNotifications.get(i));\n+                                if (!mKey.equals(groupNotifications.get(i).getKey())) {\n+                                    recordsToSnooze.add(groupNotifications.get(i));\n                                 }\n                             }\n                         }\n@@ -6779,7 +6780,15 @@ public class NotificationManagerService extends SystemService {\n                 }\n             }\n             // snooze the notification\n-            snoozeNotificationLocked(r);\n+            recordsToSnooze.add(r);\n+\n+            if (mSnoozeHelper.canSnooze(recordsToSnooze.size())) {\n+                for (int i = 0; i < recordsToSnooze.size(); i++) {\n+                    snoozeNotificationLocked(recordsToSnooze.get(i));\n+                }\n+            } else {\n+                Log.w(TAG, \"Cannot snooze \" + r.getKey() + \": too many snoozed notifications\");\n+            }\n \n         }\n \n",
    "added_lines": 14,
    "deleted_lines": 5,
    "changed_methods": "NotificationManagerService::SnoozeNotificationRunnable::snoozeLocked"
   },
   {
    "filename": "SnoozeHelper.java",
    "diff": "@@ -62,6 +62,8 @@ import java.util.Set;\n public class SnoozeHelper {\n     public static final int XML_SNOOZED_NOTIFICATION_VERSION = 1;\n \n+    static final int CONCURRENT_SNOOZE_LIMIT = 500;\n+\n     protected static final String XML_TAG_NAME = \"snoozed-notifications\";\n \n     private static final String XML_SNOOZED_NOTIFICATION = \"notification\";\n@@ -134,6 +136,15 @@ public class SnoozeHelper {\n         }\n     }\n \n+    protected boolean canSnooze(int numberToSnooze) {\n+        synchronized (mLock) {\n+            if ((mPackages.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n     @NonNull\n     protected Long getSnoozeTimeForUnpostedNotification(int userId, String pkg, String key) {\n         Long time = null;\n",
    "added_lines": 11,
    "deleted_lines": 0,
    "changed_methods": "SnoozeHelper::canSnooze"
   },
   {
    "filename": "NotificationManagerServiceTest.java",
    "diff": "@@ -2798,20 +2798,81 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n                 any(NotificationManagerService.SnoozeNotificationRunnable.class));\n     }\n \n+    @Test\n+    public void testSnoozeRunnable_tooManySnoozed_singleNotification() {\n+        final NotificationRecord notification = generateNotificationRecord(\n+                mTestNotificationChannel, 1, null, true);\n+        mService.addNotification(notification);\n+\n+        when(mSnoozeHelper.canSnooze(anyInt())).thenReturn(true);\n+        when(mSnoozeHelper.canSnooze(1)).thenReturn(false);\n+\n+        NotificationManagerService.SnoozeNotificationRunnable snoozeNotificationRunnable =\n+                mService.new SnoozeNotificationRunnable(\n+                        notification.getKey(), 100, null);\n+        snoozeNotificationRunnable.run();\n+\n+        verify(mSnoozeHelper, never()).snooze(any(NotificationRecord.class), anyLong());\n+        assertEquals(1, mService.getNotificationRecordCount());\n+    }\n+\n+    @Test\n+    public void testSnoozeRunnable_tooManySnoozed_singleGroupChildNotification() {\n+        final NotificationRecord notification = generateNotificationRecord(\n+                mTestNotificationChannel, 1, \"group\", true);\n+        final NotificationRecord notificationChild = generateNotificationRecord(\n+                mTestNotificationChannel, 1, \"group\", false);\n+        mService.addNotification(notification);\n+        mService.addNotification(notificationChild);\n+\n+        when(mSnoozeHelper.canSnooze(anyInt())).thenReturn(true);\n+        when(mSnoozeHelper.canSnooze(2)).thenReturn(false);\n+\n+        NotificationManagerService.SnoozeNotificationRunnable snoozeNotificationRunnable =\n+                mService.new SnoozeNotificationRunnable(\n+                        notificationChild.getKey(), 100, null);\n+        snoozeNotificationRunnable.run();\n+\n+        verify(mSnoozeHelper, never()).snooze(any(NotificationRecord.class), anyLong());\n+        assertEquals(2, mService.getNotificationRecordCount());\n+    }\n+\n+    @Test\n+    public void testSnoozeRunnable_tooManySnoozed_summaryNotification() {\n+        final NotificationRecord notification = generateNotificationRecord(\n+                mTestNotificationChannel, 1, \"group\", true);\n+        final NotificationRecord notificationChild = generateNotificationRecord(\n+                mTestNotificationChannel, 12, \"group\", false);\n+        final NotificationRecord notificationChild2 = generateNotificationRecord(\n+                mTestNotificationChannel, 13, \"group\", false);\n+        mService.addNotification(notification);\n+        mService.addNotification(notificationChild);\n+        mService.addNotification(notificationChild2);\n+\n+        when(mSnoozeHelper.canSnooze(anyInt())).thenReturn(true);\n+        when(mSnoozeHelper.canSnooze(3)).thenReturn(false);\n+\n+        NotificationManagerService.SnoozeNotificationRunnable snoozeNotificationRunnable =\n+                mService.new SnoozeNotificationRunnable(\n+                        notification.getKey(), 100, null);\n+        snoozeNotificationRunnable.run();\n+\n+        verify(mSnoozeHelper, never()).snooze(any(NotificationRecord.class), anyLong());\n+        assertEquals(3, mService.getNotificationRecordCount());\n+    }\n+\n     @Test\n     public void testSnoozeRunnable_reSnoozeASingleSnoozedNotification() throws Exception {\n         final NotificationRecord notification = generateNotificationRecord(\n                 mTestNotificationChannel, 1, null, true);\n         mService.addNotification(notification);\n         when(mSnoozeHelper.getNotification(any())).thenReturn(notification);\n+        when(mSnoozeHelper.canSnooze(anyInt())).thenReturn(true);\n \n         NotificationManagerService.SnoozeNotificationRunnable snoozeNotificationRunnable =\n                 mService.new SnoozeNotificationRunnable(\n                 notification.getKey(), 100, null);\n         snoozeNotificationRunnable.run();\n-        NotificationManagerService.SnoozeNotificationRunnable snoozeNotificationRunnable2 =\n-                mService.new SnoozeNotificationRunnable(\n-                notification.getKey(), 100, null);\n         snoozeNotificationRunnable.run();\n \n         // snooze twice\n@@ -2819,19 +2880,17 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n     }\n \n     @Test\n-    public void testSnoozeRunnable_reSnoozeASnoozedNotificationWithGroupKey() throws Exception {\n+    public void testSnoozeRunnable_reSnoozeASnoozedNotificationWithGroupKey() {\n         final NotificationRecord notification = generateNotificationRecord(\n                 mTestNotificationChannel, 1, \"group\", true);\n         mService.addNotification(notification);\n         when(mSnoozeHelper.getNotification(any())).thenReturn(notification);\n+        when(mSnoozeHelper.canSnooze(anyInt())).thenReturn(true);\n \n         NotificationManagerService.SnoozeNotificationRunnable snoozeNotificationRunnable =\n                 mService.new SnoozeNotificationRunnable(\n                 notification.getKey(), 100, null);\n         snoozeNotificationRunnable.run();\n-        NotificationManagerService.SnoozeNotificationRunnable snoozeNotificationRunnable2 =\n-                mService.new SnoozeNotificationRunnable(\n-                notification.getKey(), 100, null);\n         snoozeNotificationRunnable.run();\n \n         // snooze twice\n@@ -2849,6 +2908,7 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n         when(mSnoozeHelper.getNotification(any())).thenReturn(notification);\n         when(mSnoozeHelper.getNotifications(\n                 anyString(), anyString(), anyInt())).thenReturn(new ArrayList<>());\n+        when(mSnoozeHelper.canSnooze(anyInt())).thenReturn(true);\n \n         NotificationManagerService.SnoozeNotificationRunnable snoozeNotificationRunnable =\n                 mService.new SnoozeNotificationRunnable(\n@@ -2858,8 +2918,8 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n                 .thenReturn(new ArrayList<>(Arrays.asList(notification, notification2)));\n         NotificationManagerService.SnoozeNotificationRunnable snoozeNotificationRunnable2 =\n                 mService.new SnoozeNotificationRunnable(\n-                        notification.getKey(), 100, null);\n-        snoozeNotificationRunnable.run();\n+                        notification2.getKey(), 100, null);\n+        snoozeNotificationRunnable2.run();\n \n         // snooze twice\n         verify(mSnoozeHelper, times(4)).snooze(any(NotificationRecord.class), anyLong());\n@@ -2873,6 +2933,7 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n                 mTestNotificationChannel, 2, \"group\", false);\n         mService.addNotification(grouped);\n         mService.addNotification(nonGrouped);\n+        when(mSnoozeHelper.canSnooze(anyInt())).thenReturn(true);\n \n         NotificationManagerService.SnoozeNotificationRunnable snoozeNotificationRunnable =\n                 mService.new SnoozeNotificationRunnable(\n@@ -2902,6 +2963,7 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n         mService.addNotification(parent);\n         mService.addNotification(child);\n         mService.addNotification(child2);\n+        when(mSnoozeHelper.canSnooze(anyInt())).thenReturn(true);\n \n         NotificationManagerService.SnoozeNotificationRunnable snoozeNotificationRunnable =\n                 mService.new SnoozeNotificationRunnable(\n@@ -2923,6 +2985,7 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n         mService.addNotification(parent);\n         mService.addNotification(child);\n         mService.addNotification(child2);\n+        when(mSnoozeHelper.canSnooze(anyInt())).thenReturn(true);\n \n         NotificationManagerService.SnoozeNotificationRunnable snoozeNotificationRunnable =\n                 mService.new SnoozeNotificationRunnable(\n@@ -2948,6 +3011,7 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n                 mTestNotificationChannel, 2, \"group\", false);\n         mService.addNotification(parent);\n         mService.addNotification(child);\n+        when(mSnoozeHelper.canSnooze(anyInt())).thenReturn(true);\n \n         NotificationManagerService.SnoozeNotificationRunnable snoozeNotificationRunnable =\n                 mService.new SnoozeNotificationRunnable(\n@@ -2975,6 +3039,7 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n         final NotificationRecord child = generateNotificationRecord(\n                 mTestNotificationChannel, 2, \"group\", false);\n         mService.addNotification(child);\n+        when(mSnoozeHelper.canSnooze(anyInt())).thenReturn(true);\n \n         NotificationManagerService.SnoozeNotificationRunnable snoozeNotificationRunnable =\n                 mService.new SnoozeNotificationRunnable(\n",
    "added_lines": 74,
    "deleted_lines": 9,
    "changed_methods": "NotificationManagerServiceTest::testSnoozeRunnable_reSnoozeASingleSnoozedNotification, NotificationManagerServiceTest::testSnoozeRunnable_snoozeSummary_withChildren, NotificationManagerServiceTest::testSnoozeRunnable_tooManySnoozed_singleNotification, NotificationManagerServiceTest::testSnoozeRunnable_tooManySnoozed_singleGroupChildNotification, NotificationManagerServiceTest::testSnoozeRunnable_reSnoozeASnoozedNotificationWithGroupKey, NotificationManagerServiceTest::testSnoozeRunnable_snoozeGroupChild_fellowChildren, NotificationManagerServiceTest::testSnoozeRunnable_reSnoozeMultipleNotificationsWithGroupKey, NotificationManagerServiceTest::testSnoozeRunnable_snoozeGroupChild_noOthersInGroup, NotificationManagerServiceTest::testSnoozeRunnable_tooManySnoozed_summaryNotification, NotificationManagerServiceTest::testSnoozeRunnable_snoozeNonGrouped, NotificationManagerServiceTest::testSnoozeRunnable_snoozeGroupChild_onlyChildOfSummary"
   },
   {
    "filename": "SnoozeHelperTest.java",
    "diff": "@@ -15,6 +15,7 @@\n  */\n package com.android.server.notification;\n \n+import static com.android.server.notification.SnoozeHelper.CONCURRENT_SNOOZE_LIMIT;\n import static com.android.server.notification.SnoozeHelper.EXTRA_KEY;\n \n import static junit.framework.Assert.assertEquals;\n@@ -280,6 +281,22 @@ public class SnoozeHelperTest extends UiServiceTestCase {\n                 UserHandle.USER_SYSTEM, r.getSbn().getPackageName(), r.getKey()));\n     }\n \n+    @Test\n+    public void testSnoozeLimit() {\n+        for (int i = 0; i < CONCURRENT_SNOOZE_LIMIT; i++ ) {\n+            NotificationRecord r = getNotificationRecord(\"pkg\", i, i+\"\", UserHandle.SYSTEM);\n+\n+            assertTrue(\"cannot snooze record \" + i, mSnoozeHelper.canSnooze(1));\n+\n+            if (i % 2 == 0) {\n+                mSnoozeHelper.snooze(r, null);\n+            } else {\n+                mSnoozeHelper.snooze(r, 9000);\n+            }\n+        }\n+        assertFalse(mSnoozeHelper.canSnooze(1));\n+    }\n+\n     @Test\n     public void testCancelByApp() throws Exception {\n         NotificationRecord r = getNotificationRecord(\"pkg\", 1, \"one\", UserHandle.SYSTEM);\n",
    "added_lines": 17,
    "deleted_lines": 0,
    "changed_methods": "SnoozeHelperTest::testSnoozeLimit"
   }
  ]
 },
 {
  "hash": "b6ce47054c0770ce028e44b165610a65417dfd33",
  "commit": "Limit the number of concurrently snoozed notifications\n\nTest: atest FrameworksUiServicesTests\nBug: 234441463\nChange-Id: I005b43979d1c708fd505c8b33ae0c8cb03ddbb35\nMerged-In: I005b43979d1c708fd505c8b33ae0c8cb03ddbb35\n(cherry picked from commit 7c38394ae9c69620499a87e629edae4fe0ac4edc)\n(cherry picked from commit bc808de2f8a88e76fde0b6d033b4a232aebff8cb)\nMerged-In: I005b43979d1c708fd505c8b33ae0c8cb03ddbb35",
  "files": [
   {
    "filename": "NotificationManagerService.java",
    "diff": "@@ -6751,6 +6751,7 @@ public class NotificationManagerService extends SystemService {\n \n         @GuardedBy(\"mNotificationLock\")\n         void snoozeLocked(NotificationRecord r) {\n+            final List<NotificationRecord> recordsToSnooze = new ArrayList<>();\n             if (r.getSbn().isGroup()) {\n                 final List<NotificationRecord> groupNotifications =\n                         findCurrentAndSnoozedGroupNotificationsLocked(\n@@ -6759,8 +6760,8 @@ public class NotificationManagerService extends SystemService {\n                 if (r.getNotification().isGroupSummary()) {\n                     // snooze all children\n                     for (int i = 0; i < groupNotifications.size(); i++) {\n-                        if (mKey != groupNotifications.get(i).getKey()) {\n-                            snoozeNotificationLocked(groupNotifications.get(i));\n+                        if (!mKey.equals(groupNotifications.get(i).getKey())) {\n+                            recordsToSnooze.add(groupNotifications.get(i));\n                         }\n                     }\n                 } else {\n@@ -6770,8 +6771,8 @@ public class NotificationManagerService extends SystemService {\n                         if (groupNotifications.size() == 2) {\n                             // snooze summary and the one child\n                             for (int i = 0; i < groupNotifications.size(); i++) {\n-                                if (mKey != groupNotifications.get(i).getKey()) {\n-                                    snoozeNotificationLocked(groupNotifications.get(i));\n+                                if (!mKey.equals(groupNotifications.get(i).getKey())) {\n+                                    recordsToSnooze.add(groupNotifications.get(i));\n                                 }\n                             }\n                         }\n@@ -6779,7 +6780,15 @@ public class NotificationManagerService extends SystemService {\n                 }\n             }\n             // snooze the notification\n-            snoozeNotificationLocked(r);\n+            recordsToSnooze.add(r);\n+\n+            if (mSnoozeHelper.canSnooze(recordsToSnooze.size())) {\n+                for (int i = 0; i < recordsToSnooze.size(); i++) {\n+                    snoozeNotificationLocked(recordsToSnooze.get(i));\n+                }\n+            } else {\n+                Log.w(TAG, \"Cannot snooze \" + r.getKey() + \": too many snoozed notifications\");\n+            }\n \n         }\n \n",
    "added_lines": 14,
    "deleted_lines": 5,
    "changed_methods": "NotificationManagerService::SnoozeNotificationRunnable::snoozeLocked"
   },
   {
    "filename": "SnoozeHelper.java",
    "diff": "@@ -62,6 +62,8 @@ import java.util.Set;\n public class SnoozeHelper {\n     public static final int XML_SNOOZED_NOTIFICATION_VERSION = 1;\n \n+    static final int CONCURRENT_SNOOZE_LIMIT = 500;\n+\n     protected static final String XML_TAG_NAME = \"snoozed-notifications\";\n \n     private static final String XML_SNOOZED_NOTIFICATION = \"notification\";\n@@ -134,6 +136,15 @@ public class SnoozeHelper {\n         }\n     }\n \n+    protected boolean canSnooze(int numberToSnooze) {\n+        synchronized (mLock) {\n+            if ((mPackages.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n     @NonNull\n     protected Long getSnoozeTimeForUnpostedNotification(int userId, String pkg, String key) {\n         Long time = null;\n",
    "added_lines": 11,
    "deleted_lines": 0,
    "changed_methods": "SnoozeHelper::canSnooze"
   },
   {
    "filename": "NotificationManagerServiceTest.java",
    "diff": "@@ -2798,20 +2798,81 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n                 any(NotificationManagerService.SnoozeNotificationRunnable.class));\n     }\n \n+    @Test\n+    public void testSnoozeRunnable_tooManySnoozed_singleNotification() {\n+        final NotificationRecord notification = generateNotificationRecord(\n+                mTestNotificationChannel, 1, null, true);\n+        mService.addNotification(notification);\n+\n+        when(mSnoozeHelper.canSnooze(anyInt())).thenReturn(true);\n+        when(mSnoozeHelper.canSnooze(1)).thenReturn(false);\n+\n+        NotificationManagerService.SnoozeNotificationRunnable snoozeNotificationRunnable =\n+                mService.new SnoozeNotificationRunnable(\n+                        notification.getKey(), 100, null);\n+        snoozeNotificationRunnable.run();\n+\n+        verify(mSnoozeHelper, never()).snooze(any(NotificationRecord.class), anyLong());\n+        assertEquals(1, mService.getNotificationRecordCount());\n+    }\n+\n+    @Test\n+    public void testSnoozeRunnable_tooManySnoozed_singleGroupChildNotification() {\n+        final NotificationRecord notification = generateNotificationRecord(\n+                mTestNotificationChannel, 1, \"group\", true);\n+        final NotificationRecord notificationChild = generateNotificationRecord(\n+                mTestNotificationChannel, 1, \"group\", false);\n+        mService.addNotification(notification);\n+        mService.addNotification(notificationChild);\n+\n+        when(mSnoozeHelper.canSnooze(anyInt())).thenReturn(true);\n+        when(mSnoozeHelper.canSnooze(2)).thenReturn(false);\n+\n+        NotificationManagerService.SnoozeNotificationRunnable snoozeNotificationRunnable =\n+                mService.new SnoozeNotificationRunnable(\n+                        notificationChild.getKey(), 100, null);\n+        snoozeNotificationRunnable.run();\n+\n+        verify(mSnoozeHelper, never()).snooze(any(NotificationRecord.class), anyLong());\n+        assertEquals(2, mService.getNotificationRecordCount());\n+    }\n+\n+    @Test\n+    public void testSnoozeRunnable_tooManySnoozed_summaryNotification() {\n+        final NotificationRecord notification = generateNotificationRecord(\n+                mTestNotificationChannel, 1, \"group\", true);\n+        final NotificationRecord notificationChild = generateNotificationRecord(\n+                mTestNotificationChannel, 12, \"group\", false);\n+        final NotificationRecord notificationChild2 = generateNotificationRecord(\n+                mTestNotificationChannel, 13, \"group\", false);\n+        mService.addNotification(notification);\n+        mService.addNotification(notificationChild);\n+        mService.addNotification(notificationChild2);\n+\n+        when(mSnoozeHelper.canSnooze(anyInt())).thenReturn(true);\n+        when(mSnoozeHelper.canSnooze(3)).thenReturn(false);\n+\n+        NotificationManagerService.SnoozeNotificationRunnable snoozeNotificationRunnable =\n+                mService.new SnoozeNotificationRunnable(\n+                        notification.getKey(), 100, null);\n+        snoozeNotificationRunnable.run();\n+\n+        verify(mSnoozeHelper, never()).snooze(any(NotificationRecord.class), anyLong());\n+        assertEquals(3, mService.getNotificationRecordCount());\n+    }\n+\n     @Test\n     public void testSnoozeRunnable_reSnoozeASingleSnoozedNotification() throws Exception {\n         final NotificationRecord notification = generateNotificationRecord(\n                 mTestNotificationChannel, 1, null, true);\n         mService.addNotification(notification);\n         when(mSnoozeHelper.getNotification(any())).thenReturn(notification);\n+        when(mSnoozeHelper.canSnooze(anyInt())).thenReturn(true);\n \n         NotificationManagerService.SnoozeNotificationRunnable snoozeNotificationRunnable =\n                 mService.new SnoozeNotificationRunnable(\n                 notification.getKey(), 100, null);\n         snoozeNotificationRunnable.run();\n-        NotificationManagerService.SnoozeNotificationRunnable snoozeNotificationRunnable2 =\n-                mService.new SnoozeNotificationRunnable(\n-                notification.getKey(), 100, null);\n         snoozeNotificationRunnable.run();\n \n         // snooze twice\n@@ -2819,19 +2880,17 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n     }\n \n     @Test\n-    public void testSnoozeRunnable_reSnoozeASnoozedNotificationWithGroupKey() throws Exception {\n+    public void testSnoozeRunnable_reSnoozeASnoozedNotificationWithGroupKey() {\n         final NotificationRecord notification = generateNotificationRecord(\n                 mTestNotificationChannel, 1, \"group\", true);\n         mService.addNotification(notification);\n         when(mSnoozeHelper.getNotification(any())).thenReturn(notification);\n+        when(mSnoozeHelper.canSnooze(anyInt())).thenReturn(true);\n \n         NotificationManagerService.SnoozeNotificationRunnable snoozeNotificationRunnable =\n                 mService.new SnoozeNotificationRunnable(\n                 notification.getKey(), 100, null);\n         snoozeNotificationRunnable.run();\n-        NotificationManagerService.SnoozeNotificationRunnable snoozeNotificationRunnable2 =\n-                mService.new SnoozeNotificationRunnable(\n-                notification.getKey(), 100, null);\n         snoozeNotificationRunnable.run();\n \n         // snooze twice\n@@ -2849,6 +2908,7 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n         when(mSnoozeHelper.getNotification(any())).thenReturn(notification);\n         when(mSnoozeHelper.getNotifications(\n                 anyString(), anyString(), anyInt())).thenReturn(new ArrayList<>());\n+        when(mSnoozeHelper.canSnooze(anyInt())).thenReturn(true);\n \n         NotificationManagerService.SnoozeNotificationRunnable snoozeNotificationRunnable =\n                 mService.new SnoozeNotificationRunnable(\n@@ -2858,8 +2918,8 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n                 .thenReturn(new ArrayList<>(Arrays.asList(notification, notification2)));\n         NotificationManagerService.SnoozeNotificationRunnable snoozeNotificationRunnable2 =\n                 mService.new SnoozeNotificationRunnable(\n-                        notification.getKey(), 100, null);\n-        snoozeNotificationRunnable.run();\n+                        notification2.getKey(), 100, null);\n+        snoozeNotificationRunnable2.run();\n \n         // snooze twice\n         verify(mSnoozeHelper, times(4)).snooze(any(NotificationRecord.class), anyLong());\n@@ -2873,6 +2933,7 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n                 mTestNotificationChannel, 2, \"group\", false);\n         mService.addNotification(grouped);\n         mService.addNotification(nonGrouped);\n+        when(mSnoozeHelper.canSnooze(anyInt())).thenReturn(true);\n \n         NotificationManagerService.SnoozeNotificationRunnable snoozeNotificationRunnable =\n                 mService.new SnoozeNotificationRunnable(\n@@ -2902,6 +2963,7 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n         mService.addNotification(parent);\n         mService.addNotification(child);\n         mService.addNotification(child2);\n+        when(mSnoozeHelper.canSnooze(anyInt())).thenReturn(true);\n \n         NotificationManagerService.SnoozeNotificationRunnable snoozeNotificationRunnable =\n                 mService.new SnoozeNotificationRunnable(\n@@ -2923,6 +2985,7 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n         mService.addNotification(parent);\n         mService.addNotification(child);\n         mService.addNotification(child2);\n+        when(mSnoozeHelper.canSnooze(anyInt())).thenReturn(true);\n \n         NotificationManagerService.SnoozeNotificationRunnable snoozeNotificationRunnable =\n                 mService.new SnoozeNotificationRunnable(\n@@ -2948,6 +3011,7 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n                 mTestNotificationChannel, 2, \"group\", false);\n         mService.addNotification(parent);\n         mService.addNotification(child);\n+        when(mSnoozeHelper.canSnooze(anyInt())).thenReturn(true);\n \n         NotificationManagerService.SnoozeNotificationRunnable snoozeNotificationRunnable =\n                 mService.new SnoozeNotificationRunnable(\n@@ -2975,6 +3039,7 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n         final NotificationRecord child = generateNotificationRecord(\n                 mTestNotificationChannel, 2, \"group\", false);\n         mService.addNotification(child);\n+        when(mSnoozeHelper.canSnooze(anyInt())).thenReturn(true);\n \n         NotificationManagerService.SnoozeNotificationRunnable snoozeNotificationRunnable =\n                 mService.new SnoozeNotificationRunnable(\n",
    "added_lines": 74,
    "deleted_lines": 9,
    "changed_methods": "NotificationManagerServiceTest::testSnoozeRunnable_reSnoozeASingleSnoozedNotification, NotificationManagerServiceTest::testSnoozeRunnable_snoozeSummary_withChildren, NotificationManagerServiceTest::testSnoozeRunnable_tooManySnoozed_singleNotification, NotificationManagerServiceTest::testSnoozeRunnable_tooManySnoozed_singleGroupChildNotification, NotificationManagerServiceTest::testSnoozeRunnable_reSnoozeASnoozedNotificationWithGroupKey, NotificationManagerServiceTest::testSnoozeRunnable_snoozeGroupChild_fellowChildren, NotificationManagerServiceTest::testSnoozeRunnable_reSnoozeMultipleNotificationsWithGroupKey, NotificationManagerServiceTest::testSnoozeRunnable_snoozeGroupChild_noOthersInGroup, NotificationManagerServiceTest::testSnoozeRunnable_tooManySnoozed_summaryNotification, NotificationManagerServiceTest::testSnoozeRunnable_snoozeNonGrouped, NotificationManagerServiceTest::testSnoozeRunnable_snoozeGroupChild_onlyChildOfSummary"
   },
   {
    "filename": "SnoozeHelperTest.java",
    "diff": "@@ -15,6 +15,7 @@\n  */\n package com.android.server.notification;\n \n+import static com.android.server.notification.SnoozeHelper.CONCURRENT_SNOOZE_LIMIT;\n import static com.android.server.notification.SnoozeHelper.EXTRA_KEY;\n \n import static junit.framework.Assert.assertEquals;\n@@ -280,6 +281,22 @@ public class SnoozeHelperTest extends UiServiceTestCase {\n                 UserHandle.USER_SYSTEM, r.getSbn().getPackageName(), r.getKey()));\n     }\n \n+    @Test\n+    public void testSnoozeLimit() {\n+        for (int i = 0; i < CONCURRENT_SNOOZE_LIMIT; i++ ) {\n+            NotificationRecord r = getNotificationRecord(\"pkg\", i, i+\"\", UserHandle.SYSTEM);\n+\n+            assertTrue(\"cannot snooze record \" + i, mSnoozeHelper.canSnooze(1));\n+\n+            if (i % 2 == 0) {\n+                mSnoozeHelper.snooze(r, null);\n+            } else {\n+                mSnoozeHelper.snooze(r, 9000);\n+            }\n+        }\n+        assertFalse(mSnoozeHelper.canSnooze(1));\n+    }\n+\n     @Test\n     public void testCancelByApp() throws Exception {\n         NotificationRecord r = getNotificationRecord(\"pkg\", 1, \"one\", UserHandle.SYSTEM);\n",
    "added_lines": 17,
    "deleted_lines": 0,
    "changed_methods": "SnoozeHelperTest::testSnoozeLimit"
   }
  ]
 },
 {
  "hash": "ea88f4dacab25b56ef333ec24362200e9b8dfd47",
  "commit": "camera: Skip HFR checks for privileged apps\n\nIssue: HAL3 supports HFR only if its greater than or equal\n       to 120fps.\n\nFix: Skip the checks to allow HFR 60 and 90 fps in HAL3 for\n     specific apps.\n     The following property need to be set to allow these\n     HFR configurations :\n     adb shell setprop persist.camera.privapp.list <pack1,pack2,etc>\n\nChange-Id: I5f3bc94bea60dbe03284de39cd4280f67df8b015\nCRs-Fixed: 2258892",
  "files": [
   {
    "filename": "SurfaceUtils.java",
    "diff": "@@ -20,11 +20,14 @@ import static android.system.OsConstants.EINVAL;\n \n import static com.android.internal.util.Preconditions.checkNotNull;\n \n+import android.app.ActivityThread;\n import android.compat.annotation.UnsupportedAppUsage;\n import android.graphics.ImageFormat;\n import android.graphics.PixelFormat;\n import android.hardware.HardwareBuffer;\n import android.hardware.camera2.params.StreamConfigurationMap;\n+import android.os.SystemProperties;\n+import android.text.TextUtils;\n import android.util.Range;\n import android.util.Size;\n import android.view.Surface;\n@@ -241,6 +244,11 @@ public class SurfaceUtils {\n                     + \" the size must be 1 or 2\");\n         }\n \n+        if (isPrivilegedApp()) {\n+            //skip checks for privileged apps\n+            return;\n+        }\n+\n         List<Size> highSpeedSizes = null;\n         if (fpsRange == null) {\n             highSpeedSizes = Arrays.asList(config.getHighSpeedVideoSizes());\n@@ -303,4 +311,21 @@ public class SurfaceUtils {\n             /*out*/int[/*2*/] dimens);\n \n     private static native long nativeGetSurfaceId(Surface surface);\n+\n+    private static boolean isPrivilegedApp() {\n+        String packageName = ActivityThread.currentOpPackageName();\n+        String packageList = SystemProperties.get(\"persist.vendor.camera.privapp.list\");\n+\n+        if (packageList.length() > 0) {\n+            TextUtils.StringSplitter splitter = new TextUtils.SimpleStringSplitter(',');\n+            splitter.setString(packageList);\n+            for (String str : splitter) {\n+                if (packageName.equals(str)) {\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        return false;\n+    }\n }\n",
    "added_lines": 25,
    "deleted_lines": 0,
    "changed_methods": "SurfaceUtils::isPrivilegedApp, SurfaceUtils::checkConstrainedHighSpeedSurfaces"
   }
  ]
 },
 {
  "hash": "0c648fbdfd607a586fd411c7036cbf7cac0efba3",
  "commit": "fixup! SystemUI: Add visualizer feature\n\nVisualizer doesn't show if we occlude it on playback.\n\nChange-Id: If3c62e9c7dd51731ae8bf764f5137a729d251792",
  "files": [
   {
    "filename": "NotificationMediaManager.java",
    "diff": "@@ -166,7 +166,7 @@ public class NotificationMediaManager implements Dumpable, TunerService.Tunable\n                 }\n                 findAndUpdateMediaNotifications();\n                 mStatusBarOptionalLazy.get().map(StatusBar::getVisualizerView).ifPresent(\n-                        v -> v.setOccluded(state.getState() == PlaybackState.STATE_PLAYING));\n+                        v -> v.setPlaying(state.getState() == PlaybackState.STATE_PLAYING));\n             }\n         }\n \n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "NotificationMediaManager::Callback"
   }
  ]
 },
 {
  "hash": "17f77d49d8f311f2b6e159847799500b329e7bb1",
  "commit": "Revert \"Prevent non-admin users from deleting system apps.\"\n\nThis reverts commit 6c870e157994519094e9e50ddf93e57a26779e22.\n\nReason for revert: Regression, DELETE_SYSTEM_APP flag no longer works\n\nChange-Id: Id3eb9e08a5404e88c39235d0d47337ed41bc6139\nMerged-In: I4e959e296cca9bbdfc8fccc5e5e0e654ca524165\n(cherry picked from commit d9089fbe06e77f5ea1773f5d69b641a81e0b5832)\nMerged-In: Id3eb9e08a5404e88c39235d0d47337ed41bc6139",
  "files": [
   {
    "filename": "PackageManagerService.java",
    "diff": "@@ -21739,16 +21739,6 @@ public class PackageManagerService extends IPackageManager.Stub\n                 return PackageManager.DELETE_FAILED_INTERNAL_ERROR;\n             }\n \n-            if (isSystemApp(uninstalledPs)) {\n-                UserInfo userInfo = mUserManager.getUserInfo(userId);\n-                if (userInfo == null || !userInfo.isAdmin()) {\n-                    Slog.w(TAG, \"Not removing package \" + packageName\n-                            + \" as only admin user may downgrade system apps\");\n-                    EventLog.writeEvent(0x534e4554, \"170646036\", -1, packageName);\n-                    return PackageManager.DELETE_FAILED_USER_RESTRICTED;\n-                }\n-            }\n-\n             disabledSystemPs = mSettings.getDisabledSystemPkgLPr(packageName);\n             // Static shared libs can be declared by any package, so let us not\n             // allow removing a package if it provides a lib others depend on.\n",
    "added_lines": 0,
    "deleted_lines": 10,
    "changed_methods": "PackageManagerService::deletePackageX"
   }
  ]
 },
 {
  "hash": "1064ad0a0ec5eafc1fd7c14d42d546b3fc480245",
  "commit": "Revert \"Prevent exfiltration of system files via user image settings.\"\n\nThis reverts commit bfb1cd5fd27c8d854336163540bb5b014ad504d1.\n\nReason for revert: regression if multiple crop system crop handlers are present\n\nChange-Id: I570c736ffbd55891bcb2e08110ee4111c5e88d59\nMerged-In: Idf1ab60878d619ee30505d71e8afe31d8b0c0ebe\n(cherry picked from commit 3cfba99d24bc04bc15edd49d1442bee8adb6c171)\nMerged-In: I570c736ffbd55891bcb2e08110ee4111c5e88d59",
  "files": [
   {
    "filename": "EditUserPhotoController.java",
    "diff": "@@ -21,8 +21,6 @@ import android.content.ClipData;\n import android.content.ContentResolver;\n import android.content.Context;\n import android.content.Intent;\n-import android.content.pm.ActivityInfo;\n-import android.content.pm.PackageManager;\n import android.database.Cursor;\n import android.graphics.Bitmap;\n import android.graphics.Bitmap.Config;\n@@ -85,7 +83,6 @@ public class EditUserPhotoController {\n     private static final int DEFAULT_PHOTO_SIZE = 500;\n \n     private static final String IMAGES_DIR = \"multi_user\";\n-    private static final String PRE_CROP_PICTURE_FILE_NAME = \"PreCropEditUserPhoto.jpg\";\n     private static final String CROP_PICTURE_FILE_NAME = \"CropEditUserPhoto.jpg\";\n     private static final String TAKE_PICTURE_FILE_NAME = \"TakeEditUserPhoto.jpg\";\n     private static final String NEW_USER_PHOTO_FILE_NAME = \"NewUserPhoto.png\";\n@@ -98,7 +95,6 @@ public class EditUserPhotoController {\n     private final String mFileAuthority;\n \n     private final File mImagesDir;\n-    private final Uri mPreCropPictureUri;\n     private final Uri mCropPictureUri;\n     private final Uri mTakePictureUri;\n \n@@ -114,7 +110,6 @@ public class EditUserPhotoController {\n \n         mImagesDir = new File(activity.getCacheDir(), IMAGES_DIR);\n         mImagesDir.mkdir();\n-        mPreCropPictureUri = createTempImageUri(activity, PRE_CROP_PICTURE_FILE_NAME, !waiting);\n         mCropPictureUri = createTempImageUri(activity, CROP_PICTURE_FILE_NAME, !waiting);\n         mTakePictureUri = createTempImageUri(activity, TAKE_PICTURE_FILE_NAME, !waiting);\n         mPhotoSize = getPhotoSize(activity);\n@@ -148,7 +143,7 @@ public class EditUserPhotoController {\n             case REQUEST_CODE_CHOOSE_PHOTO:\n                 if (mTakePictureUri.equals(pictureUri)) {\n                     if (PhotoCapabilityUtils.canCropPhoto(mActivity)) {\n-                        cropPhoto(pictureUri);\n+                        cropPhoto();\n                     } else {\n                         onPhotoNotCropped(pictureUri);\n                     }\n@@ -229,7 +224,7 @@ public class EditUserPhotoController {\n             protected Void doInBackground(Void... params) {\n                 final ContentResolver cr = mActivity.getContentResolver();\n                 try (InputStream in = cr.openInputStream(pictureUri);\n-                        OutputStream out = cr.openOutputStream(mPreCropPictureUri)) {\n+                     OutputStream out = cr.openOutputStream(mTakePictureUri)) {\n                     Streams.copy(in, out);\n                 } catch (IOException e) {\n                     Log.w(TAG, \"Failed to copy photo\", e);\n@@ -240,41 +235,28 @@ public class EditUserPhotoController {\n             @Override\n             protected void onPostExecute(Void result) {\n                 if (!mActivity.isFinishing() && !mActivity.isDestroyed()) {\n-                    cropPhoto(mPreCropPictureUri);\n+                    cropPhoto();\n                 }\n             }\n         }.execute();\n     }\n \n-    private void cropPhoto(final Uri pictureUri) {\n+    private void cropPhoto() {\n         // TODO: Use a public intent, when there is one.\n         Intent intent = new Intent(\"com.android.camera.action.CROP\");\n-        intent.setDataAndType(pictureUri, \"image/*\");\n+        intent.setDataAndType(mTakePictureUri, \"image/*\");\n         appendOutputExtra(intent, mCropPictureUri);\n         appendCropExtras(intent);\n-        try {\n-            StrictMode.disableDeathOnFileUriExposure();\n-            if (startSystemActivityForResult(intent, REQUEST_CODE_CROP_PHOTO)) {\n-                return;\n+        if (intent.resolveActivity(mActivity.getPackageManager()) != null) {\n+            try {\n+                StrictMode.disableDeathOnFileUriExposure();\n+                mActivityStarter.startActivityForResult(intent, REQUEST_CODE_CROP_PHOTO);\n+            } finally {\n+                StrictMode.enableDeathOnFileUriExposure();\n             }\n-        } finally {\n-            StrictMode.enableDeathOnFileUriExposure();\n-        }\n-\n-        onPhotoNotCropped(mTakePictureUri);\n-\n-    }\n-\n-    private boolean startSystemActivityForResult(Intent intent, int code) {\n-        ActivityInfo info = intent.resolveActivityInfo(mActivity.getPackageManager(),\n-                PackageManager.MATCH_SYSTEM_ONLY);\n-        if (info == null) {\n-            Log.w(TAG, \"No system package activity could be found for code \" + code);\n-            return false;\n+        } else {\n+            onPhotoNotCropped(mTakePictureUri);\n         }\n-        intent.setPackage(info.packageName);\n-        mActivityStarter.startActivityForResult(intent, code);\n-        return true;\n     }\n \n     private void appendOutputExtra(Intent intent, Uri pictureUri) {\n",
    "added_lines": 13,
    "deleted_lines": 31,
    "changed_methods": "EditUserPhotoController::EditUserPhotoController, EditUserPhotoController::copyAndCropPhoto, EditUserPhotoController::onActivityResult, EditUserPhotoController::cropPhoto, EditUserPhotoController::startSystemActivityForResult, EditUserPhotoController::cropPhoto"
   }
  ]
 },
 {
  "hash": "40d09c7983dc8f5053123f0045ba5b4fa4494a10",
  "commit": "Prevent non-admin users from deleting system apps.\n\nThis addresses a security issue where the guest user can remove updates\nfor system apps.\n\nWith this CL, attempts to uninstall/downgrade system apps will fail if\nattempted by a non-admin user, unless the DELETE_SYSTEM_APP flag is\nspecified.\n\nThis is a fixed version of ag/17408864, to address b/236578018.\n\nBug: 170646036\nTest: manual, try uninstalling system app update as guest\nMerged-In: I4e959e296cca9bbdfc8fccc5e5e0e654ca524165\nChange-Id: I6ecfef50294c9000a6ce539bdec6f372c872a40b\n(cherry picked from commit fbfa268d47c7915b7a87d3fef22a5b8f3bbabeb7)\nMerged-In: I6ecfef50294c9000a6ce539bdec6f372c872a40b",
  "files": [
   {
    "filename": "PackageManagerService.java",
    "diff": "@@ -21739,6 +21739,17 @@ public class PackageManagerService extends IPackageManager.Stub\n                 return PackageManager.DELETE_FAILED_INTERNAL_ERROR;\n             }\n \n+            if (isSystemApp(uninstalledPs)\n+                    && (deleteFlags & PackageManager.DELETE_SYSTEM_APP) == 0) {\n+                UserInfo userInfo = mUserManager.getUserInfo(userId);\n+                if (userInfo == null || !userInfo.isAdmin()) {\n+                    Slog.w(TAG, \"Not removing package \" + packageName\n+                            + \" as only admin user may downgrade system apps\");\n+                    EventLog.writeEvent(0x534e4554, \"170646036\", -1, packageName);\n+                    return PackageManager.DELETE_FAILED_USER_RESTRICTED;\n+                }\n+            }\n+\n             disabledSystemPs = mSettings.getDisabledSystemPkgLPr(packageName);\n             // Static shared libs can be declared by any package, so let us not\n             // allow removing a package if it provides a lib others depend on.\n",
    "added_lines": 11,
    "deleted_lines": 0,
    "changed_methods": "PackageManagerService::deletePackageX"
   }
  ]
 },
 {
  "hash": "adeaf8cc25530afb8a92e4a04127651c0995bedd",
  "commit": "Limit the size of NotificationChannel and NotificationChannelGroup\n\nTest: android.app.NotificationChannelGroupTest\nTest: android.app.NotificationChannelTest\nTest: cts NotificationChannelTest\nTest: cts NotificationChannelGroupTest\nBug: 241764350\nBug: 241764340\nBug: 241764135\nBug: 242702935\nBug: 242703118\nBug: 242703202\nBug: 242702851\nBug: 242703217\nBug: 242703556\nChange-Id: I0925583ab54d6c81c415859618f6b907ab7baada\n(cherry picked from commit 3850857cb0e7f26702d5bd601731d7290390fa3b)\n(cherry picked from commit b664159aa809093eec69480e801f367215b78f10)\nMerged-In: I0925583ab54d6c81c415859618f6b907ab7baada",
  "files": [
   {
    "filename": "NotificationChannel.java",
    "diff": "@@ -124,8 +124,13 @@ public final class NotificationChannel implements Parcelable {\n     /**\n      * The maximum length for text fields in a NotificationChannel. Fields will be truncated at this\n      * limit.\n+     * @hide\n      */\n-    private static final int MAX_TEXT_LENGTH = 1000;\n+    public static final int MAX_TEXT_LENGTH = 1000;\n+    /**\n+     * @hide\n+     */\n+    public static final int MAX_VIBRATION_LENGTH = 1000;\n \n     private static final String TAG_CHANNEL = \"channel\";\n     private static final String ATT_NAME = \"name\";\n@@ -284,17 +289,17 @@ public final class NotificationChannel implements Parcelable {\n      */\n     protected NotificationChannel(Parcel in) {\n         if (in.readByte() != 0) {\n-            mId = in.readString();\n+            mId = getTrimmedString(in.readString());\n         } else {\n             mId = null;\n         }\n         if (in.readByte() != 0) {\n-            mName = in.readString();\n+            mName = getTrimmedString(in.readString());\n         } else {\n             mName = null;\n         }\n         if (in.readByte() != 0) {\n-            mDesc = in.readString();\n+            mDesc = getTrimmedString(in.readString());\n         } else {\n             mDesc = null;\n         }\n@@ -303,18 +308,22 @@ public final class NotificationChannel implements Parcelable {\n         mLockscreenVisibility = in.readInt();\n         if (in.readByte() != 0) {\n             mSound = Uri.CREATOR.createFromParcel(in);\n+            mSound = Uri.parse(getTrimmedString(mSound.toString()));\n         } else {\n             mSound = null;\n         }\n         mLights = in.readByte() != 0;\n         mVibration = in.createLongArray();\n+        if (mVibration != null && mVibration.length > MAX_VIBRATION_LENGTH) {\n+            mVibration = Arrays.copyOf(mVibration, MAX_VIBRATION_LENGTH);\n+        }\n         mUserLockedFields = in.readInt();\n         mFgServiceShown = in.readByte() != 0;\n         mVibrationEnabled = in.readByte() != 0;\n         mShowBadge = in.readByte() != 0;\n         mDeleted = in.readByte() != 0;\n         if (in.readByte() != 0) {\n-            mGroup = in.readString();\n+            mGroup = getTrimmedString(in.readString());\n         } else {\n             mGroup = null;\n         }\n@@ -324,8 +333,8 @@ public final class NotificationChannel implements Parcelable {\n         mAllowBubbles = in.readInt();\n         mImportanceLockedByOEM = in.readBoolean();\n         mOriginalImportance = in.readInt();\n-        mParentId = in.readString();\n-        mConversationId = in.readString();\n+        mParentId = getTrimmedString(in.readString());\n+        mConversationId = getTrimmedString(in.readString());\n         mDemoted = in.readBoolean();\n         mImportantConvo = in.readBoolean();\n         mDeletedTime = in.readLong();\n",
    "added_lines": 16,
    "deleted_lines": 7,
    "changed_methods": "NotificationChannel::NotificationChannel"
   },
   {
    "filename": "NotificationChannelGroup.java",
    "diff": "@@ -43,8 +43,9 @@ public final class NotificationChannelGroup implements Parcelable {\n     /**\n      * The maximum length for text fields in a NotificationChannelGroup. Fields will be truncated at\n      * this limit.\n+     * @hide\n      */\n-    private static final int MAX_TEXT_LENGTH = 1000;\n+    public static final int MAX_TEXT_LENGTH = 1000;\n \n     private static final String TAG_GROUP = \"channelGroup\";\n     private static final String ATT_NAME = \"name\";\n@@ -90,13 +91,14 @@ public final class NotificationChannelGroup implements Parcelable {\n      */\n     protected NotificationChannelGroup(Parcel in) {\n         if (in.readByte() != 0) {\n-            mId = in.readString();\n+            mId = getTrimmedString(in.readString());\n         } else {\n             mId = null;\n         }\n         mName = TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(in);\n+        mName = getTrimmedString(mName.toString());\n         if (in.readByte() != 0) {\n-            mDescription = in.readString();\n+            mDescription = getTrimmedString(in.readString());\n         } else {\n             mDescription = null;\n         }\n@@ -120,7 +122,7 @@ public final class NotificationChannelGroup implements Parcelable {\n         } else {\n             dest.writeByte((byte) 0);\n         }\n-        TextUtils.writeToParcel(mName, dest, flags);\n+        TextUtils.writeToParcel(mName.toString(), dest, flags);\n         if (mDescription != null) {\n             dest.writeByte((byte) 1);\n             dest.writeString(mDescription);\n",
    "added_lines": 6,
    "deleted_lines": 4,
    "changed_methods": "NotificationChannelGroup::NotificationChannelGroup, NotificationChannelGroup::writeToParcel"
   },
   {
    "filename": "NotificationChannelGroupTest.java",
    "diff": "@@ -0,0 +1,73 @@\n+/*\n+ * Copyright (C) 2022 The Android Open Source Project\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package android.app;\n+\n+import static junit.framework.TestCase.assertEquals;\n+\n+import android.os.Parcel;\n+import android.test.AndroidTestCase;\n+\n+import androidx.test.filters.SmallTest;\n+import androidx.test.runner.AndroidJUnit4;\n+\n+import com.google.common.base.Strings;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import java.lang.reflect.Field;\n+\n+@RunWith(AndroidJUnit4.class)\n+@SmallTest\n+public class NotificationChannelGroupTest {\n+    private final String CLASS = \"android.app.NotificationChannelGroup\";\n+\n+    @Test\n+    public void testLongStringFields() {\n+        NotificationChannelGroup group = new NotificationChannelGroup(\"my_group_01\", \"groupName\");\n+\n+        try {\n+            String longString = Strings.repeat(\"A\", 65536);\n+            Field mName = Class.forName(CLASS).getDeclaredField(\"mName\");\n+            mName.setAccessible(true);\n+            mName.set(group, longString);\n+            Field mId = Class.forName(CLASS).getDeclaredField(\"mId\");\n+            mId.setAccessible(true);\n+            mId.set(group, longString);\n+            Field mDescription = Class.forName(CLASS).getDeclaredField(\"mDescription\");\n+            mDescription.setAccessible(true);\n+            mDescription.set(group, longString);\n+        } catch (NoSuchFieldException e) {\n+            e.printStackTrace();\n+        } catch (ClassNotFoundException e) {\n+            e.printStackTrace();\n+        } catch (IllegalAccessException e) {\n+            e.printStackTrace();\n+        }\n+\n+        Parcel parcel = Parcel.obtain();\n+        group.writeToParcel(parcel, 0);\n+        parcel.setDataPosition(0);\n+\n+        NotificationChannelGroup fromParcel =\n+                NotificationChannelGroup.CREATOR.createFromParcel(parcel);\n+        assertEquals(NotificationChannelGroup.MAX_TEXT_LENGTH, fromParcel.getId().length());\n+        assertEquals(NotificationChannelGroup.MAX_TEXT_LENGTH, fromParcel.getName().length());\n+        assertEquals(NotificationChannelGroup.MAX_TEXT_LENGTH,\n+                fromParcel.getDescription().length());\n+    }\n+}\n",
    "added_lines": 73,
    "deleted_lines": 0,
    "changed_methods": "NotificationChannelGroupTest::testLongStringFields"
   },
   {
    "filename": "NotificationChannelTest.java",
    "diff": "@@ -0,0 +1,106 @@\n+/*\n+ * Copyright (C) 2022 The Android Open Source Project\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package android.app;\n+\n+import static junit.framework.TestCase.assertEquals;\n+\n+import android.net.Uri;\n+import android.os.Parcel;\n+\n+import androidx.test.filters.SmallTest;\n+import androidx.test.runner.AndroidJUnit4;\n+\n+import com.google.common.base.Strings;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import java.lang.reflect.Field;\n+\n+@RunWith(AndroidJUnit4.class)\n+@SmallTest\n+public class NotificationChannelTest {\n+    private final String CLASS = \"android.app.NotificationChannel\";\n+\n+    @Test\n+    public void testLongStringFields() {\n+        NotificationChannel channel = new NotificationChannel(\"id\", \"name\", 3);\n+\n+        try {\n+            String longString = Strings.repeat(\"A\", 65536);\n+            Field mName = Class.forName(CLASS).getDeclaredField(\"mName\");\n+            mName.setAccessible(true);\n+            mName.set(channel, longString);\n+            Field mId = Class.forName(CLASS).getDeclaredField(\"mId\");\n+            mId.setAccessible(true);\n+            mId.set(channel, longString);\n+            Field mDesc = Class.forName(CLASS).getDeclaredField(\"mDesc\");\n+            mDesc.setAccessible(true);\n+            mDesc.set(channel, longString);\n+            Field mParentId = Class.forName(CLASS).getDeclaredField(\"mParentId\");\n+            mParentId.setAccessible(true);\n+            mParentId.set(channel, longString);\n+            Field mGroup = Class.forName(CLASS).getDeclaredField(\"mGroup\");\n+            mGroup.setAccessible(true);\n+            mGroup.set(channel, longString);\n+            Field mConversationId = Class.forName(CLASS).getDeclaredField(\"mConversationId\");\n+            mConversationId.setAccessible(true);\n+            mConversationId.set(channel, longString);\n+        } catch (NoSuchFieldException e) {\n+            e.printStackTrace();\n+        } catch (ClassNotFoundException e) {\n+            e.printStackTrace();\n+        } catch (IllegalAccessException e) {\n+            e.printStackTrace();\n+        }\n+\n+        Parcel parcel = Parcel.obtain();\n+        channel.writeToParcel(parcel, 0);\n+        parcel.setDataPosition(0);\n+\n+        NotificationChannel fromParcel = NotificationChannel.CREATOR.createFromParcel(parcel);\n+        assertEquals(NotificationChannel.MAX_TEXT_LENGTH, fromParcel.getId().length());\n+        assertEquals(NotificationChannel.MAX_TEXT_LENGTH, fromParcel.getName().length());\n+        assertEquals(NotificationChannel.MAX_TEXT_LENGTH,\n+                fromParcel.getDescription().length());\n+        assertEquals(NotificationChannel.MAX_TEXT_LENGTH,\n+                fromParcel.getParentChannelId().length());\n+        assertEquals(NotificationChannel.MAX_TEXT_LENGTH,\n+                fromParcel.getGroup().length());\n+        assertEquals(NotificationChannel.MAX_TEXT_LENGTH,\n+                fromParcel.getConversationId().length());\n+    }\n+\n+    @Test\n+    public void testLongAlertFields() {\n+        NotificationChannel channel = new NotificationChannel(\"id\", \"name\", 3);\n+\n+        channel.setSound(Uri.parse(\"content://\" + Strings.repeat(\"A\",65536)),\n+                Notification.AUDIO_ATTRIBUTES_DEFAULT);\n+        channel.setVibrationPattern(new long[65550/2]);\n+\n+        Parcel parcel = Parcel.obtain();\n+        channel.writeToParcel(parcel, 0);\n+        parcel.setDataPosition(0);\n+\n+        NotificationChannel fromParcel = NotificationChannel.CREATOR.createFromParcel(parcel);\n+        assertEquals(NotificationChannel.MAX_VIBRATION_LENGTH,\n+                fromParcel.getVibrationPattern().length);\n+        assertEquals(NotificationChannel.MAX_TEXT_LENGTH,\n+                fromParcel.getSound().toString().length());\n+    }\n+}\n",
    "added_lines": 106,
    "deleted_lines": 0,
    "changed_methods": "NotificationChannelTest::testLongStringFields, NotificationChannelTest::testLongAlertFields"
   }
  ]
 },
 {
  "hash": "adeaf8cc25530afb8a92e4a04127651c0995bedd",
  "commit": "Limit the size of NotificationChannel and NotificationChannelGroup\n\nTest: android.app.NotificationChannelGroupTest\nTest: android.app.NotificationChannelTest\nTest: cts NotificationChannelTest\nTest: cts NotificationChannelGroupTest\nBug: 241764350\nBug: 241764340\nBug: 241764135\nBug: 242702935\nBug: 242703118\nBug: 242703202\nBug: 242702851\nBug: 242703217\nBug: 242703556\nChange-Id: I0925583ab54d6c81c415859618f6b907ab7baada\n(cherry picked from commit 3850857cb0e7f26702d5bd601731d7290390fa3b)\n(cherry picked from commit b664159aa809093eec69480e801f367215b78f10)\nMerged-In: I0925583ab54d6c81c415859618f6b907ab7baada",
  "files": [
   {
    "filename": "NotificationChannel.java",
    "diff": "@@ -124,8 +124,13 @@ public final class NotificationChannel implements Parcelable {\n     /**\n      * The maximum length for text fields in a NotificationChannel. Fields will be truncated at this\n      * limit.\n+     * @hide\n      */\n-    private static final int MAX_TEXT_LENGTH = 1000;\n+    public static final int MAX_TEXT_LENGTH = 1000;\n+    /**\n+     * @hide\n+     */\n+    public static final int MAX_VIBRATION_LENGTH = 1000;\n \n     private static final String TAG_CHANNEL = \"channel\";\n     private static final String ATT_NAME = \"name\";\n@@ -284,17 +289,17 @@ public final class NotificationChannel implements Parcelable {\n      */\n     protected NotificationChannel(Parcel in) {\n         if (in.readByte() != 0) {\n-            mId = in.readString();\n+            mId = getTrimmedString(in.readString());\n         } else {\n             mId = null;\n         }\n         if (in.readByte() != 0) {\n-            mName = in.readString();\n+            mName = getTrimmedString(in.readString());\n         } else {\n             mName = null;\n         }\n         if (in.readByte() != 0) {\n-            mDesc = in.readString();\n+            mDesc = getTrimmedString(in.readString());\n         } else {\n             mDesc = null;\n         }\n@@ -303,18 +308,22 @@ public final class NotificationChannel implements Parcelable {\n         mLockscreenVisibility = in.readInt();\n         if (in.readByte() != 0) {\n             mSound = Uri.CREATOR.createFromParcel(in);\n+            mSound = Uri.parse(getTrimmedString(mSound.toString()));\n         } else {\n             mSound = null;\n         }\n         mLights = in.readByte() != 0;\n         mVibration = in.createLongArray();\n+        if (mVibration != null && mVibration.length > MAX_VIBRATION_LENGTH) {\n+            mVibration = Arrays.copyOf(mVibration, MAX_VIBRATION_LENGTH);\n+        }\n         mUserLockedFields = in.readInt();\n         mFgServiceShown = in.readByte() != 0;\n         mVibrationEnabled = in.readByte() != 0;\n         mShowBadge = in.readByte() != 0;\n         mDeleted = in.readByte() != 0;\n         if (in.readByte() != 0) {\n-            mGroup = in.readString();\n+            mGroup = getTrimmedString(in.readString());\n         } else {\n             mGroup = null;\n         }\n@@ -324,8 +333,8 @@ public final class NotificationChannel implements Parcelable {\n         mAllowBubbles = in.readInt();\n         mImportanceLockedByOEM = in.readBoolean();\n         mOriginalImportance = in.readInt();\n-        mParentId = in.readString();\n-        mConversationId = in.readString();\n+        mParentId = getTrimmedString(in.readString());\n+        mConversationId = getTrimmedString(in.readString());\n         mDemoted = in.readBoolean();\n         mImportantConvo = in.readBoolean();\n         mDeletedTime = in.readLong();\n",
    "added_lines": 16,
    "deleted_lines": 7,
    "changed_methods": "NotificationChannel::NotificationChannel"
   },
   {
    "filename": "NotificationChannelGroup.java",
    "diff": "@@ -43,8 +43,9 @@ public final class NotificationChannelGroup implements Parcelable {\n     /**\n      * The maximum length for text fields in a NotificationChannelGroup. Fields will be truncated at\n      * this limit.\n+     * @hide\n      */\n-    private static final int MAX_TEXT_LENGTH = 1000;\n+    public static final int MAX_TEXT_LENGTH = 1000;\n \n     private static final String TAG_GROUP = \"channelGroup\";\n     private static final String ATT_NAME = \"name\";\n@@ -90,13 +91,14 @@ public final class NotificationChannelGroup implements Parcelable {\n      */\n     protected NotificationChannelGroup(Parcel in) {\n         if (in.readByte() != 0) {\n-            mId = in.readString();\n+            mId = getTrimmedString(in.readString());\n         } else {\n             mId = null;\n         }\n         mName = TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(in);\n+        mName = getTrimmedString(mName.toString());\n         if (in.readByte() != 0) {\n-            mDescription = in.readString();\n+            mDescription = getTrimmedString(in.readString());\n         } else {\n             mDescription = null;\n         }\n@@ -120,7 +122,7 @@ public final class NotificationChannelGroup implements Parcelable {\n         } else {\n             dest.writeByte((byte) 0);\n         }\n-        TextUtils.writeToParcel(mName, dest, flags);\n+        TextUtils.writeToParcel(mName.toString(), dest, flags);\n         if (mDescription != null) {\n             dest.writeByte((byte) 1);\n             dest.writeString(mDescription);\n",
    "added_lines": 6,
    "deleted_lines": 4,
    "changed_methods": "NotificationChannelGroup::NotificationChannelGroup, NotificationChannelGroup::writeToParcel"
   },
   {
    "filename": "NotificationChannelGroupTest.java",
    "diff": "@@ -0,0 +1,73 @@\n+/*\n+ * Copyright (C) 2022 The Android Open Source Project\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package android.app;\n+\n+import static junit.framework.TestCase.assertEquals;\n+\n+import android.os.Parcel;\n+import android.test.AndroidTestCase;\n+\n+import androidx.test.filters.SmallTest;\n+import androidx.test.runner.AndroidJUnit4;\n+\n+import com.google.common.base.Strings;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import java.lang.reflect.Field;\n+\n+@RunWith(AndroidJUnit4.class)\n+@SmallTest\n+public class NotificationChannelGroupTest {\n+    private final String CLASS = \"android.app.NotificationChannelGroup\";\n+\n+    @Test\n+    public void testLongStringFields() {\n+        NotificationChannelGroup group = new NotificationChannelGroup(\"my_group_01\", \"groupName\");\n+\n+        try {\n+            String longString = Strings.repeat(\"A\", 65536);\n+            Field mName = Class.forName(CLASS).getDeclaredField(\"mName\");\n+            mName.setAccessible(true);\n+            mName.set(group, longString);\n+            Field mId = Class.forName(CLASS).getDeclaredField(\"mId\");\n+            mId.setAccessible(true);\n+            mId.set(group, longString);\n+            Field mDescription = Class.forName(CLASS).getDeclaredField(\"mDescription\");\n+            mDescription.setAccessible(true);\n+            mDescription.set(group, longString);\n+        } catch (NoSuchFieldException e) {\n+            e.printStackTrace();\n+        } catch (ClassNotFoundException e) {\n+            e.printStackTrace();\n+        } catch (IllegalAccessException e) {\n+            e.printStackTrace();\n+        }\n+\n+        Parcel parcel = Parcel.obtain();\n+        group.writeToParcel(parcel, 0);\n+        parcel.setDataPosition(0);\n+\n+        NotificationChannelGroup fromParcel =\n+                NotificationChannelGroup.CREATOR.createFromParcel(parcel);\n+        assertEquals(NotificationChannelGroup.MAX_TEXT_LENGTH, fromParcel.getId().length());\n+        assertEquals(NotificationChannelGroup.MAX_TEXT_LENGTH, fromParcel.getName().length());\n+        assertEquals(NotificationChannelGroup.MAX_TEXT_LENGTH,\n+                fromParcel.getDescription().length());\n+    }\n+}\n",
    "added_lines": 73,
    "deleted_lines": 0,
    "changed_methods": "NotificationChannelGroupTest::testLongStringFields"
   },
   {
    "filename": "NotificationChannelTest.java",
    "diff": "@@ -0,0 +1,106 @@\n+/*\n+ * Copyright (C) 2022 The Android Open Source Project\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package android.app;\n+\n+import static junit.framework.TestCase.assertEquals;\n+\n+import android.net.Uri;\n+import android.os.Parcel;\n+\n+import androidx.test.filters.SmallTest;\n+import androidx.test.runner.AndroidJUnit4;\n+\n+import com.google.common.base.Strings;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import java.lang.reflect.Field;\n+\n+@RunWith(AndroidJUnit4.class)\n+@SmallTest\n+public class NotificationChannelTest {\n+    private final String CLASS = \"android.app.NotificationChannel\";\n+\n+    @Test\n+    public void testLongStringFields() {\n+        NotificationChannel channel = new NotificationChannel(\"id\", \"name\", 3);\n+\n+        try {\n+            String longString = Strings.repeat(\"A\", 65536);\n+            Field mName = Class.forName(CLASS).getDeclaredField(\"mName\");\n+            mName.setAccessible(true);\n+            mName.set(channel, longString);\n+            Field mId = Class.forName(CLASS).getDeclaredField(\"mId\");\n+            mId.setAccessible(true);\n+            mId.set(channel, longString);\n+            Field mDesc = Class.forName(CLASS).getDeclaredField(\"mDesc\");\n+            mDesc.setAccessible(true);\n+            mDesc.set(channel, longString);\n+            Field mParentId = Class.forName(CLASS).getDeclaredField(\"mParentId\");\n+            mParentId.setAccessible(true);\n+            mParentId.set(channel, longString);\n+            Field mGroup = Class.forName(CLASS).getDeclaredField(\"mGroup\");\n+            mGroup.setAccessible(true);\n+            mGroup.set(channel, longString);\n+            Field mConversationId = Class.forName(CLASS).getDeclaredField(\"mConversationId\");\n+            mConversationId.setAccessible(true);\n+            mConversationId.set(channel, longString);\n+        } catch (NoSuchFieldException e) {\n+            e.printStackTrace();\n+        } catch (ClassNotFoundException e) {\n+            e.printStackTrace();\n+        } catch (IllegalAccessException e) {\n+            e.printStackTrace();\n+        }\n+\n+        Parcel parcel = Parcel.obtain();\n+        channel.writeToParcel(parcel, 0);\n+        parcel.setDataPosition(0);\n+\n+        NotificationChannel fromParcel = NotificationChannel.CREATOR.createFromParcel(parcel);\n+        assertEquals(NotificationChannel.MAX_TEXT_LENGTH, fromParcel.getId().length());\n+        assertEquals(NotificationChannel.MAX_TEXT_LENGTH, fromParcel.getName().length());\n+        assertEquals(NotificationChannel.MAX_TEXT_LENGTH,\n+                fromParcel.getDescription().length());\n+        assertEquals(NotificationChannel.MAX_TEXT_LENGTH,\n+                fromParcel.getParentChannelId().length());\n+        assertEquals(NotificationChannel.MAX_TEXT_LENGTH,\n+                fromParcel.getGroup().length());\n+        assertEquals(NotificationChannel.MAX_TEXT_LENGTH,\n+                fromParcel.getConversationId().length());\n+    }\n+\n+    @Test\n+    public void testLongAlertFields() {\n+        NotificationChannel channel = new NotificationChannel(\"id\", \"name\", 3);\n+\n+        channel.setSound(Uri.parse(\"content://\" + Strings.repeat(\"A\",65536)),\n+                Notification.AUDIO_ATTRIBUTES_DEFAULT);\n+        channel.setVibrationPattern(new long[65550/2]);\n+\n+        Parcel parcel = Parcel.obtain();\n+        channel.writeToParcel(parcel, 0);\n+        parcel.setDataPosition(0);\n+\n+        NotificationChannel fromParcel = NotificationChannel.CREATOR.createFromParcel(parcel);\n+        assertEquals(NotificationChannel.MAX_VIBRATION_LENGTH,\n+                fromParcel.getVibrationPattern().length);\n+        assertEquals(NotificationChannel.MAX_TEXT_LENGTH,\n+                fromParcel.getSound().toString().length());\n+    }\n+}\n",
    "added_lines": 106,
    "deleted_lines": 0,
    "changed_methods": "NotificationChannelTest::testLongStringFields, NotificationChannelTest::testLongAlertFields"
   }
  ]
 },
 {
  "hash": "adeaf8cc25530afb8a92e4a04127651c0995bedd",
  "commit": "Limit the size of NotificationChannel and NotificationChannelGroup\n\nTest: android.app.NotificationChannelGroupTest\nTest: android.app.NotificationChannelTest\nTest: cts NotificationChannelTest\nTest: cts NotificationChannelGroupTest\nBug: 241764350\nBug: 241764340\nBug: 241764135\nBug: 242702935\nBug: 242703118\nBug: 242703202\nBug: 242702851\nBug: 242703217\nBug: 242703556\nChange-Id: I0925583ab54d6c81c415859618f6b907ab7baada\n(cherry picked from commit 3850857cb0e7f26702d5bd601731d7290390fa3b)\n(cherry picked from commit b664159aa809093eec69480e801f367215b78f10)\nMerged-In: I0925583ab54d6c81c415859618f6b907ab7baada",
  "files": [
   {
    "filename": "NotificationChannel.java",
    "diff": "@@ -124,8 +124,13 @@ public final class NotificationChannel implements Parcelable {\n     /**\n      * The maximum length for text fields in a NotificationChannel. Fields will be truncated at this\n      * limit.\n+     * @hide\n      */\n-    private static final int MAX_TEXT_LENGTH = 1000;\n+    public static final int MAX_TEXT_LENGTH = 1000;\n+    /**\n+     * @hide\n+     */\n+    public static final int MAX_VIBRATION_LENGTH = 1000;\n \n     private static final String TAG_CHANNEL = \"channel\";\n     private static final String ATT_NAME = \"name\";\n@@ -284,17 +289,17 @@ public final class NotificationChannel implements Parcelable {\n      */\n     protected NotificationChannel(Parcel in) {\n         if (in.readByte() != 0) {\n-            mId = in.readString();\n+            mId = getTrimmedString(in.readString());\n         } else {\n             mId = null;\n         }\n         if (in.readByte() != 0) {\n-            mName = in.readString();\n+            mName = getTrimmedString(in.readString());\n         } else {\n             mName = null;\n         }\n         if (in.readByte() != 0) {\n-            mDesc = in.readString();\n+            mDesc = getTrimmedString(in.readString());\n         } else {\n             mDesc = null;\n         }\n@@ -303,18 +308,22 @@ public final class NotificationChannel implements Parcelable {\n         mLockscreenVisibility = in.readInt();\n         if (in.readByte() != 0) {\n             mSound = Uri.CREATOR.createFromParcel(in);\n+            mSound = Uri.parse(getTrimmedString(mSound.toString()));\n         } else {\n             mSound = null;\n         }\n         mLights = in.readByte() != 0;\n         mVibration = in.createLongArray();\n+        if (mVibration != null && mVibration.length > MAX_VIBRATION_LENGTH) {\n+            mVibration = Arrays.copyOf(mVibration, MAX_VIBRATION_LENGTH);\n+        }\n         mUserLockedFields = in.readInt();\n         mFgServiceShown = in.readByte() != 0;\n         mVibrationEnabled = in.readByte() != 0;\n         mShowBadge = in.readByte() != 0;\n         mDeleted = in.readByte() != 0;\n         if (in.readByte() != 0) {\n-            mGroup = in.readString();\n+            mGroup = getTrimmedString(in.readString());\n         } else {\n             mGroup = null;\n         }\n@@ -324,8 +333,8 @@ public final class NotificationChannel implements Parcelable {\n         mAllowBubbles = in.readInt();\n         mImportanceLockedByOEM = in.readBoolean();\n         mOriginalImportance = in.readInt();\n-        mParentId = in.readString();\n-        mConversationId = in.readString();\n+        mParentId = getTrimmedString(in.readString());\n+        mConversationId = getTrimmedString(in.readString());\n         mDemoted = in.readBoolean();\n         mImportantConvo = in.readBoolean();\n         mDeletedTime = in.readLong();\n",
    "added_lines": 16,
    "deleted_lines": 7,
    "changed_methods": "NotificationChannel::NotificationChannel"
   },
   {
    "filename": "NotificationChannelGroup.java",
    "diff": "@@ -43,8 +43,9 @@ public final class NotificationChannelGroup implements Parcelable {\n     /**\n      * The maximum length for text fields in a NotificationChannelGroup. Fields will be truncated at\n      * this limit.\n+     * @hide\n      */\n-    private static final int MAX_TEXT_LENGTH = 1000;\n+    public static final int MAX_TEXT_LENGTH = 1000;\n \n     private static final String TAG_GROUP = \"channelGroup\";\n     private static final String ATT_NAME = \"name\";\n@@ -90,13 +91,14 @@ public final class NotificationChannelGroup implements Parcelable {\n      */\n     protected NotificationChannelGroup(Parcel in) {\n         if (in.readByte() != 0) {\n-            mId = in.readString();\n+            mId = getTrimmedString(in.readString());\n         } else {\n             mId = null;\n         }\n         mName = TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(in);\n+        mName = getTrimmedString(mName.toString());\n         if (in.readByte() != 0) {\n-            mDescription = in.readString();\n+            mDescription = getTrimmedString(in.readString());\n         } else {\n             mDescription = null;\n         }\n@@ -120,7 +122,7 @@ public final class NotificationChannelGroup implements Parcelable {\n         } else {\n             dest.writeByte((byte) 0);\n         }\n-        TextUtils.writeToParcel(mName, dest, flags);\n+        TextUtils.writeToParcel(mName.toString(), dest, flags);\n         if (mDescription != null) {\n             dest.writeByte((byte) 1);\n             dest.writeString(mDescription);\n",
    "added_lines": 6,
    "deleted_lines": 4,
    "changed_methods": "NotificationChannelGroup::NotificationChannelGroup, NotificationChannelGroup::writeToParcel"
   },
   {
    "filename": "NotificationChannelGroupTest.java",
    "diff": "@@ -0,0 +1,73 @@\n+/*\n+ * Copyright (C) 2022 The Android Open Source Project\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package android.app;\n+\n+import static junit.framework.TestCase.assertEquals;\n+\n+import android.os.Parcel;\n+import android.test.AndroidTestCase;\n+\n+import androidx.test.filters.SmallTest;\n+import androidx.test.runner.AndroidJUnit4;\n+\n+import com.google.common.base.Strings;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import java.lang.reflect.Field;\n+\n+@RunWith(AndroidJUnit4.class)\n+@SmallTest\n+public class NotificationChannelGroupTest {\n+    private final String CLASS = \"android.app.NotificationChannelGroup\";\n+\n+    @Test\n+    public void testLongStringFields() {\n+        NotificationChannelGroup group = new NotificationChannelGroup(\"my_group_01\", \"groupName\");\n+\n+        try {\n+            String longString = Strings.repeat(\"A\", 65536);\n+            Field mName = Class.forName(CLASS).getDeclaredField(\"mName\");\n+            mName.setAccessible(true);\n+            mName.set(group, longString);\n+            Field mId = Class.forName(CLASS).getDeclaredField(\"mId\");\n+            mId.setAccessible(true);\n+            mId.set(group, longString);\n+            Field mDescription = Class.forName(CLASS).getDeclaredField(\"mDescription\");\n+            mDescription.setAccessible(true);\n+            mDescription.set(group, longString);\n+        } catch (NoSuchFieldException e) {\n+            e.printStackTrace();\n+        } catch (ClassNotFoundException e) {\n+            e.printStackTrace();\n+        } catch (IllegalAccessException e) {\n+            e.printStackTrace();\n+        }\n+\n+        Parcel parcel = Parcel.obtain();\n+        group.writeToParcel(parcel, 0);\n+        parcel.setDataPosition(0);\n+\n+        NotificationChannelGroup fromParcel =\n+                NotificationChannelGroup.CREATOR.createFromParcel(parcel);\n+        assertEquals(NotificationChannelGroup.MAX_TEXT_LENGTH, fromParcel.getId().length());\n+        assertEquals(NotificationChannelGroup.MAX_TEXT_LENGTH, fromParcel.getName().length());\n+        assertEquals(NotificationChannelGroup.MAX_TEXT_LENGTH,\n+                fromParcel.getDescription().length());\n+    }\n+}\n",
    "added_lines": 73,
    "deleted_lines": 0,
    "changed_methods": "NotificationChannelGroupTest::testLongStringFields"
   },
   {
    "filename": "NotificationChannelTest.java",
    "diff": "@@ -0,0 +1,106 @@\n+/*\n+ * Copyright (C) 2022 The Android Open Source Project\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package android.app;\n+\n+import static junit.framework.TestCase.assertEquals;\n+\n+import android.net.Uri;\n+import android.os.Parcel;\n+\n+import androidx.test.filters.SmallTest;\n+import androidx.test.runner.AndroidJUnit4;\n+\n+import com.google.common.base.Strings;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import java.lang.reflect.Field;\n+\n+@RunWith(AndroidJUnit4.class)\n+@SmallTest\n+public class NotificationChannelTest {\n+    private final String CLASS = \"android.app.NotificationChannel\";\n+\n+    @Test\n+    public void testLongStringFields() {\n+        NotificationChannel channel = new NotificationChannel(\"id\", \"name\", 3);\n+\n+        try {\n+            String longString = Strings.repeat(\"A\", 65536);\n+            Field mName = Class.forName(CLASS).getDeclaredField(\"mName\");\n+            mName.setAccessible(true);\n+            mName.set(channel, longString);\n+            Field mId = Class.forName(CLASS).getDeclaredField(\"mId\");\n+            mId.setAccessible(true);\n+            mId.set(channel, longString);\n+            Field mDesc = Class.forName(CLASS).getDeclaredField(\"mDesc\");\n+            mDesc.setAccessible(true);\n+            mDesc.set(channel, longString);\n+            Field mParentId = Class.forName(CLASS).getDeclaredField(\"mParentId\");\n+            mParentId.setAccessible(true);\n+            mParentId.set(channel, longString);\n+            Field mGroup = Class.forName(CLASS).getDeclaredField(\"mGroup\");\n+            mGroup.setAccessible(true);\n+            mGroup.set(channel, longString);\n+            Field mConversationId = Class.forName(CLASS).getDeclaredField(\"mConversationId\");\n+            mConversationId.setAccessible(true);\n+            mConversationId.set(channel, longString);\n+        } catch (NoSuchFieldException e) {\n+            e.printStackTrace();\n+        } catch (ClassNotFoundException e) {\n+            e.printStackTrace();\n+        } catch (IllegalAccessException e) {\n+            e.printStackTrace();\n+        }\n+\n+        Parcel parcel = Parcel.obtain();\n+        channel.writeToParcel(parcel, 0);\n+        parcel.setDataPosition(0);\n+\n+        NotificationChannel fromParcel = NotificationChannel.CREATOR.createFromParcel(parcel);\n+        assertEquals(NotificationChannel.MAX_TEXT_LENGTH, fromParcel.getId().length());\n+        assertEquals(NotificationChannel.MAX_TEXT_LENGTH, fromParcel.getName().length());\n+        assertEquals(NotificationChannel.MAX_TEXT_LENGTH,\n+                fromParcel.getDescription().length());\n+        assertEquals(NotificationChannel.MAX_TEXT_LENGTH,\n+                fromParcel.getParentChannelId().length());\n+        assertEquals(NotificationChannel.MAX_TEXT_LENGTH,\n+                fromParcel.getGroup().length());\n+        assertEquals(NotificationChannel.MAX_TEXT_LENGTH,\n+                fromParcel.getConversationId().length());\n+    }\n+\n+    @Test\n+    public void testLongAlertFields() {\n+        NotificationChannel channel = new NotificationChannel(\"id\", \"name\", 3);\n+\n+        channel.setSound(Uri.parse(\"content://\" + Strings.repeat(\"A\",65536)),\n+                Notification.AUDIO_ATTRIBUTES_DEFAULT);\n+        channel.setVibrationPattern(new long[65550/2]);\n+\n+        Parcel parcel = Parcel.obtain();\n+        channel.writeToParcel(parcel, 0);\n+        parcel.setDataPosition(0);\n+\n+        NotificationChannel fromParcel = NotificationChannel.CREATOR.createFromParcel(parcel);\n+        assertEquals(NotificationChannel.MAX_VIBRATION_LENGTH,\n+                fromParcel.getVibrationPattern().length);\n+        assertEquals(NotificationChannel.MAX_TEXT_LENGTH,\n+                fromParcel.getSound().toString().length());\n+    }\n+}\n",
    "added_lines": 106,
    "deleted_lines": 0,
    "changed_methods": "NotificationChannelTest::testLongStringFields, NotificationChannelTest::testLongAlertFields"
   }
  ]
 },
 {
  "hash": "adeaf8cc25530afb8a92e4a04127651c0995bedd",
  "commit": "Limit the size of NotificationChannel and NotificationChannelGroup\n\nTest: android.app.NotificationChannelGroupTest\nTest: android.app.NotificationChannelTest\nTest: cts NotificationChannelTest\nTest: cts NotificationChannelGroupTest\nBug: 241764350\nBug: 241764340\nBug: 241764135\nBug: 242702935\nBug: 242703118\nBug: 242703202\nBug: 242702851\nBug: 242703217\nBug: 242703556\nChange-Id: I0925583ab54d6c81c415859618f6b907ab7baada\n(cherry picked from commit 3850857cb0e7f26702d5bd601731d7290390fa3b)\n(cherry picked from commit b664159aa809093eec69480e801f367215b78f10)\nMerged-In: I0925583ab54d6c81c415859618f6b907ab7baada",
  "files": [
   {
    "filename": "NotificationChannel.java",
    "diff": "@@ -124,8 +124,13 @@ public final class NotificationChannel implements Parcelable {\n     /**\n      * The maximum length for text fields in a NotificationChannel. Fields will be truncated at this\n      * limit.\n+     * @hide\n      */\n-    private static final int MAX_TEXT_LENGTH = 1000;\n+    public static final int MAX_TEXT_LENGTH = 1000;\n+    /**\n+     * @hide\n+     */\n+    public static final int MAX_VIBRATION_LENGTH = 1000;\n \n     private static final String TAG_CHANNEL = \"channel\";\n     private static final String ATT_NAME = \"name\";\n@@ -284,17 +289,17 @@ public final class NotificationChannel implements Parcelable {\n      */\n     protected NotificationChannel(Parcel in) {\n         if (in.readByte() != 0) {\n-            mId = in.readString();\n+            mId = getTrimmedString(in.readString());\n         } else {\n             mId = null;\n         }\n         if (in.readByte() != 0) {\n-            mName = in.readString();\n+            mName = getTrimmedString(in.readString());\n         } else {\n             mName = null;\n         }\n         if (in.readByte() != 0) {\n-            mDesc = in.readString();\n+            mDesc = getTrimmedString(in.readString());\n         } else {\n             mDesc = null;\n         }\n@@ -303,18 +308,22 @@ public final class NotificationChannel implements Parcelable {\n         mLockscreenVisibility = in.readInt();\n         if (in.readByte() != 0) {\n             mSound = Uri.CREATOR.createFromParcel(in);\n+            mSound = Uri.parse(getTrimmedString(mSound.toString()));\n         } else {\n             mSound = null;\n         }\n         mLights = in.readByte() != 0;\n         mVibration = in.createLongArray();\n+        if (mVibration != null && mVibration.length > MAX_VIBRATION_LENGTH) {\n+            mVibration = Arrays.copyOf(mVibration, MAX_VIBRATION_LENGTH);\n+        }\n         mUserLockedFields = in.readInt();\n         mFgServiceShown = in.readByte() != 0;\n         mVibrationEnabled = in.readByte() != 0;\n         mShowBadge = in.readByte() != 0;\n         mDeleted = in.readByte() != 0;\n         if (in.readByte() != 0) {\n-            mGroup = in.readString();\n+            mGroup = getTrimmedString(in.readString());\n         } else {\n             mGroup = null;\n         }\n@@ -324,8 +333,8 @@ public final class NotificationChannel implements Parcelable {\n         mAllowBubbles = in.readInt();\n         mImportanceLockedByOEM = in.readBoolean();\n         mOriginalImportance = in.readInt();\n-        mParentId = in.readString();\n-        mConversationId = in.readString();\n+        mParentId = getTrimmedString(in.readString());\n+        mConversationId = getTrimmedString(in.readString());\n         mDemoted = in.readBoolean();\n         mImportantConvo = in.readBoolean();\n         mDeletedTime = in.readLong();\n",
    "added_lines": 16,
    "deleted_lines": 7,
    "changed_methods": "NotificationChannel::NotificationChannel"
   },
   {
    "filename": "NotificationChannelGroup.java",
    "diff": "@@ -43,8 +43,9 @@ public final class NotificationChannelGroup implements Parcelable {\n     /**\n      * The maximum length for text fields in a NotificationChannelGroup. Fields will be truncated at\n      * this limit.\n+     * @hide\n      */\n-    private static final int MAX_TEXT_LENGTH = 1000;\n+    public static final int MAX_TEXT_LENGTH = 1000;\n \n     private static final String TAG_GROUP = \"channelGroup\";\n     private static final String ATT_NAME = \"name\";\n@@ -90,13 +91,14 @@ public final class NotificationChannelGroup implements Parcelable {\n      */\n     protected NotificationChannelGroup(Parcel in) {\n         if (in.readByte() != 0) {\n-            mId = in.readString();\n+            mId = getTrimmedString(in.readString());\n         } else {\n             mId = null;\n         }\n         mName = TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(in);\n+        mName = getTrimmedString(mName.toString());\n         if (in.readByte() != 0) {\n-            mDescription = in.readString();\n+            mDescription = getTrimmedString(in.readString());\n         } else {\n             mDescription = null;\n         }\n@@ -120,7 +122,7 @@ public final class NotificationChannelGroup implements Parcelable {\n         } else {\n             dest.writeByte((byte) 0);\n         }\n-        TextUtils.writeToParcel(mName, dest, flags);\n+        TextUtils.writeToParcel(mName.toString(), dest, flags);\n         if (mDescription != null) {\n             dest.writeByte((byte) 1);\n             dest.writeString(mDescription);\n",
    "added_lines": 6,
    "deleted_lines": 4,
    "changed_methods": "NotificationChannelGroup::NotificationChannelGroup, NotificationChannelGroup::writeToParcel"
   },
   {
    "filename": "NotificationChannelGroupTest.java",
    "diff": "@@ -0,0 +1,73 @@\n+/*\n+ * Copyright (C) 2022 The Android Open Source Project\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package android.app;\n+\n+import static junit.framework.TestCase.assertEquals;\n+\n+import android.os.Parcel;\n+import android.test.AndroidTestCase;\n+\n+import androidx.test.filters.SmallTest;\n+import androidx.test.runner.AndroidJUnit4;\n+\n+import com.google.common.base.Strings;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import java.lang.reflect.Field;\n+\n+@RunWith(AndroidJUnit4.class)\n+@SmallTest\n+public class NotificationChannelGroupTest {\n+    private final String CLASS = \"android.app.NotificationChannelGroup\";\n+\n+    @Test\n+    public void testLongStringFields() {\n+        NotificationChannelGroup group = new NotificationChannelGroup(\"my_group_01\", \"groupName\");\n+\n+        try {\n+            String longString = Strings.repeat(\"A\", 65536);\n+            Field mName = Class.forName(CLASS).getDeclaredField(\"mName\");\n+            mName.setAccessible(true);\n+            mName.set(group, longString);\n+            Field mId = Class.forName(CLASS).getDeclaredField(\"mId\");\n+            mId.setAccessible(true);\n+            mId.set(group, longString);\n+            Field mDescription = Class.forName(CLASS).getDeclaredField(\"mDescription\");\n+            mDescription.setAccessible(true);\n+            mDescription.set(group, longString);\n+        } catch (NoSuchFieldException e) {\n+            e.printStackTrace();\n+        } catch (ClassNotFoundException e) {\n+            e.printStackTrace();\n+        } catch (IllegalAccessException e) {\n+            e.printStackTrace();\n+        }\n+\n+        Parcel parcel = Parcel.obtain();\n+        group.writeToParcel(parcel, 0);\n+        parcel.setDataPosition(0);\n+\n+        NotificationChannelGroup fromParcel =\n+                NotificationChannelGroup.CREATOR.createFromParcel(parcel);\n+        assertEquals(NotificationChannelGroup.MAX_TEXT_LENGTH, fromParcel.getId().length());\n+        assertEquals(NotificationChannelGroup.MAX_TEXT_LENGTH, fromParcel.getName().length());\n+        assertEquals(NotificationChannelGroup.MAX_TEXT_LENGTH,\n+                fromParcel.getDescription().length());\n+    }\n+}\n",
    "added_lines": 73,
    "deleted_lines": 0,
    "changed_methods": "NotificationChannelGroupTest::testLongStringFields"
   },
   {
    "filename": "NotificationChannelTest.java",
    "diff": "@@ -0,0 +1,106 @@\n+/*\n+ * Copyright (C) 2022 The Android Open Source Project\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package android.app;\n+\n+import static junit.framework.TestCase.assertEquals;\n+\n+import android.net.Uri;\n+import android.os.Parcel;\n+\n+import androidx.test.filters.SmallTest;\n+import androidx.test.runner.AndroidJUnit4;\n+\n+import com.google.common.base.Strings;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import java.lang.reflect.Field;\n+\n+@RunWith(AndroidJUnit4.class)\n+@SmallTest\n+public class NotificationChannelTest {\n+    private final String CLASS = \"android.app.NotificationChannel\";\n+\n+    @Test\n+    public void testLongStringFields() {\n+        NotificationChannel channel = new NotificationChannel(\"id\", \"name\", 3);\n+\n+        try {\n+            String longString = Strings.repeat(\"A\", 65536);\n+            Field mName = Class.forName(CLASS).getDeclaredField(\"mName\");\n+            mName.setAccessible(true);\n+            mName.set(channel, longString);\n+            Field mId = Class.forName(CLASS).getDeclaredField(\"mId\");\n+            mId.setAccessible(true);\n+            mId.set(channel, longString);\n+            Field mDesc = Class.forName(CLASS).getDeclaredField(\"mDesc\");\n+            mDesc.setAccessible(true);\n+            mDesc.set(channel, longString);\n+            Field mParentId = Class.forName(CLASS).getDeclaredField(\"mParentId\");\n+            mParentId.setAccessible(true);\n+            mParentId.set(channel, longString);\n+            Field mGroup = Class.forName(CLASS).getDeclaredField(\"mGroup\");\n+            mGroup.setAccessible(true);\n+            mGroup.set(channel, longString);\n+            Field mConversationId = Class.forName(CLASS).getDeclaredField(\"mConversationId\");\n+            mConversationId.setAccessible(true);\n+            mConversationId.set(channel, longString);\n+        } catch (NoSuchFieldException e) {\n+            e.printStackTrace();\n+        } catch (ClassNotFoundException e) {\n+            e.printStackTrace();\n+        } catch (IllegalAccessException e) {\n+            e.printStackTrace();\n+        }\n+\n+        Parcel parcel = Parcel.obtain();\n+        channel.writeToParcel(parcel, 0);\n+        parcel.setDataPosition(0);\n+\n+        NotificationChannel fromParcel = NotificationChannel.CREATOR.createFromParcel(parcel);\n+        assertEquals(NotificationChannel.MAX_TEXT_LENGTH, fromParcel.getId().length());\n+        assertEquals(NotificationChannel.MAX_TEXT_LENGTH, fromParcel.getName().length());\n+        assertEquals(NotificationChannel.MAX_TEXT_LENGTH,\n+                fromParcel.getDescription().length());\n+        assertEquals(NotificationChannel.MAX_TEXT_LENGTH,\n+                fromParcel.getParentChannelId().length());\n+        assertEquals(NotificationChannel.MAX_TEXT_LENGTH,\n+                fromParcel.getGroup().length());\n+        assertEquals(NotificationChannel.MAX_TEXT_LENGTH,\n+                fromParcel.getConversationId().length());\n+    }\n+\n+    @Test\n+    public void testLongAlertFields() {\n+        NotificationChannel channel = new NotificationChannel(\"id\", \"name\", 3);\n+\n+        channel.setSound(Uri.parse(\"content://\" + Strings.repeat(\"A\",65536)),\n+                Notification.AUDIO_ATTRIBUTES_DEFAULT);\n+        channel.setVibrationPattern(new long[65550/2]);\n+\n+        Parcel parcel = Parcel.obtain();\n+        channel.writeToParcel(parcel, 0);\n+        parcel.setDataPosition(0);\n+\n+        NotificationChannel fromParcel = NotificationChannel.CREATOR.createFromParcel(parcel);\n+        assertEquals(NotificationChannel.MAX_VIBRATION_LENGTH,\n+                fromParcel.getVibrationPattern().length);\n+        assertEquals(NotificationChannel.MAX_TEXT_LENGTH,\n+                fromParcel.getSound().toString().length());\n+    }\n+}\n",
    "added_lines": 106,
    "deleted_lines": 0,
    "changed_methods": "NotificationChannelTest::testLongStringFields, NotificationChannelTest::testLongAlertFields"
   }
  ]
 },
 {
  "hash": "cfe51c00cd4c0b412d321bbb967a1faddcaa2216",
  "commit": "Include all enabled services when FEEDBACK_ALL_MASK.\n\nBug: 243849844\nTest: m sts;\n      sts-tradefed run sts-dynamic-develop -m CtsAccessibilityTestCases\nChange-Id: I4f93e06d1066085bd64e8f09882de2f4a72a0633\n(cherry picked from commit 2bc4d49c2b0265f5de1c62d1342b1426cc5e1377)\nMerged-In: I4f93e06d1066085bd64e8f09882de2f4a72a0633",
  "files": [
   {
    "filename": "AccessibilityManagerService.java",
    "diff": "@@ -935,7 +935,8 @@ public class AccessibilityManagerService extends IAccessibilityManager.Stub\n             final List<AccessibilityServiceInfo> result = new ArrayList<>(serviceCount);\n             for (int i = 0; i < serviceCount; ++i) {\n                 final AccessibilityServiceConnection service = services.get(i);\n-                if ((service.mFeedbackType & feedbackType) != 0) {\n+                if ((service.mFeedbackType & feedbackType) != 0\n+                        || feedbackType == AccessibilityServiceInfo.FEEDBACK_ALL_MASK) {\n                     result.add(service.getServiceInfo());\n                 }\n             }\n",
    "added_lines": 2,
    "deleted_lines": 1,
    "changed_methods": "AccessibilityManagerService::getEnabledAccessibilityServiceList"
   }
  ]
 },
 {
  "hash": "62d9be5800c460e7c1f323898306fc75ac37d66a",
  "commit": "[pm] forbid deletion of protected packages\n\nBUG: 242996180\nTest: adb shell pm uninstall --user 0 com.google.android.apps.work.oobconfig\nTest: Verified with the command above. Before this CL, the package can\nbe deleted. After this CL, the deletion will fail.\n\nChange-Id: Iba408e536b340ea5d66ab499442c0c4f828fa36f\n(cherry picked from commit 15f85c7fa97fe9faa540e6ad9e850990f46a5cca)\nMerged-In: Iba408e536b340ea5d66ab499442c0c4f828fa36f\n(cherry picked from commit dba7ceb57ecdf9485bcfe8eb554510ccf9ad773c)\nMerged-In: Iba408e536b340ea5d66ab499442c0c4f828fa36f",
  "files": [
   {
    "filename": "PackageManagerService.java",
    "diff": "@@ -21436,6 +21436,20 @@ public class PackageManagerService extends IPackageManager.Stub\n \n         final String packageName = versionedPackage.getPackageName();\n         final long versionCode = versionedPackage.getLongVersionCode();\n+\n+        if (mProtectedPackages.isPackageStateProtected(userId, packageName)) {\n+            mHandler.post(() -> {\n+                try {\n+                    Slog.w(TAG, \"Attempted to delete protected package: \" + packageName);\n+                    observer.onPackageDeleted(packageName,\n+                            PackageManager.DELETE_FAILED_INTERNAL_ERROR, null);\n+                } catch (RemoteException re) {\n+                }\n+            });\n+            return;\n+        }\n+\n+\n         final String internalPackageName;\n \n         try {\n",
    "added_lines": 14,
    "deleted_lines": 0,
    "changed_methods": "PackageManagerService::deletePackageVersionedInternal"
   }
  ]
 },
 {
  "hash": "78f58b477987e157ac4d73db4f99a19ecebd33bd",
  "commit": "Limit lengths of fields in Condition to a max length.\n\nThis app-generated input needs to not be too long to avoid errors in the process of writing to disk.\n\nBug: 242846316\nTest: cts ConditionTest; atest ConditionTest; manually verified exploit apk is OK\n\nChange-Id: Ic2fa8f06cc7a4c1f262115764fbd1be2a226b4b9\nMerged-In: Ic2fa8f06cc7a4c1f262115764fbd1be2a226b4b9\n(cherry picked from commit 81352c3775949c622441e10b468766441e35edc7)\n(cherry picked from commit 7059638be9271303e22b7b3e8aa6d58677f6143b)\nMerged-In: Ic2fa8f06cc7a4c1f262115764fbd1be2a226b4b9",
  "files": [
   {
    "filename": "Condition.java",
    "diff": "@@ -90,6 +90,12 @@ public final class Condition implements Parcelable {\n     public final int flags;\n     public final int icon;\n \n+    /**\n+     * The maximum string length for any string contained in this condition.\n+     * @hide\n+     */\n+    public static final int MAX_STRING_LENGTH = 1000;\n+\n     /**\n      * An object representing the current state of a {@link android.app.AutomaticZenRule}.\n      * @param id the {@link android.app.AutomaticZenRule#getConditionId()} of the zen rule\n@@ -104,16 +110,19 @@ public final class Condition implements Parcelable {\n         if (id == null) throw new IllegalArgumentException(\"id is required\");\n         if (summary == null) throw new IllegalArgumentException(\"summary is required\");\n         if (!isValidState(state)) throw new IllegalArgumentException(\"state is invalid: \" + state);\n-        this.id = id;\n-        this.summary = summary;\n-        this.line1 = line1;\n-        this.line2 = line2;\n+        this.id = getTrimmedUri(id);\n+        this.summary = getTrimmedString(summary);\n+        this.line1 = getTrimmedString(line1);\n+        this.line2 = getTrimmedString(line2);\n         this.icon = icon;\n         this.state = state;\n         this.flags = flags;\n     }\n \n     public Condition(Parcel source) {\n+        // This constructor passes all fields directly into the constructor that takes all the\n+        // fields as arguments; that constructor will trim each of the input strings to\n+        // max length if necessary.\n         this((Uri)source.readParcelable(Condition.class.getClassLoader()),\n                 source.readString(),\n                 source.readString(),\n@@ -240,4 +249,25 @@ public final class Condition implements Parcelable {\n             return new Condition[size];\n         }\n     };\n+\n+    /**\n+     * Returns a truncated copy of the string if the string is longer than MAX_STRING_LENGTH.\n+     */\n+    private static String getTrimmedString(String input) {\n+        if (input != null && input.length() > MAX_STRING_LENGTH) {\n+            return input.substring(0, MAX_STRING_LENGTH);\n+        }\n+        return input;\n+    }\n+\n+    /**\n+     * Returns a truncated copy of the Uri by trimming the string representation to the maximum\n+     * string length.\n+     */\n+    private static Uri getTrimmedUri(Uri input) {\n+        if (input != null && input.toString().length() > MAX_STRING_LENGTH) {\n+            return Uri.parse(getTrimmedString(input.toString()));\n+        }\n+        return input;\n+    }\n }\n",
    "added_lines": 34,
    "deleted_lines": 4,
    "changed_methods": "Condition::Condition, Condition::Condition, Condition::getTrimmedString, Condition::getTrimmedUri"
   },
   {
    "filename": "ConditionTest.java",
    "diff": "@@ -0,0 +1,101 @@\n+/*\n+ * Copyright (C) 2022 The Android Open Source Project\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package android.service.notification;\n+\n+import static junit.framework.Assert.assertEquals;\n+import static junit.framework.Assert.fail;\n+\n+import android.net.Uri;\n+import android.os.Parcel;\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4;\n+import androidx.test.filters.SmallTest;\n+\n+import com.google.common.base.Strings;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import java.lang.reflect.Field;\n+\n+@RunWith(AndroidJUnit4.class)\n+@SmallTest\n+public class ConditionTest {\n+    private static final String CLASS = \"android.service.notification.Condition\";\n+\n+    @Test\n+    public void testLongFields_inConstructors() {\n+        String longString = Strings.repeat(\"A\", 65536);\n+        Uri longUri = Uri.parse(\"uri://\" + Strings.repeat(\"A\", 65530));\n+\n+        // Confirm strings are truncated via short constructor\n+        Condition cond1 = new Condition(longUri, longString, Condition.STATE_TRUE);\n+\n+        assertEquals(Condition.MAX_STRING_LENGTH, cond1.id.toString().length());\n+        assertEquals(Condition.MAX_STRING_LENGTH, cond1.summary.length());\n+\n+        // Confirm strings are truncated via long constructor\n+        Condition cond2 = new Condition(longUri, longString, longString, longString,\n+                -1, Condition.STATE_TRUE, Condition.FLAG_RELEVANT_ALWAYS);\n+\n+        assertEquals(Condition.MAX_STRING_LENGTH, cond2.id.toString().length());\n+        assertEquals(Condition.MAX_STRING_LENGTH, cond2.summary.length());\n+        assertEquals(Condition.MAX_STRING_LENGTH, cond2.line1.length());\n+        assertEquals(Condition.MAX_STRING_LENGTH, cond2.line2.length());\n+    }\n+\n+    @Test\n+    public void testLongFields_viaParcel() {\n+        // Set fields via reflection to force them to be long, then parcel and unparcel to make sure\n+        // it gets truncated upon unparcelling.\n+        Condition cond = new Condition(Uri.parse(\"uri://placeholder\"), \"placeholder\",\n+                Condition.STATE_TRUE);\n+\n+        try {\n+            String longString = Strings.repeat(\"A\", 65536);\n+            Uri longUri = Uri.parse(\"uri://\" + Strings.repeat(\"A\", 65530));\n+            Field id = Class.forName(CLASS).getDeclaredField(\"id\");\n+            id.setAccessible(true);\n+            id.set(cond, longUri);\n+            Field summary = Class.forName(CLASS).getDeclaredField(\"summary\");\n+            summary.setAccessible(true);\n+            summary.set(cond, longString);\n+            Field line1 = Class.forName(CLASS).getDeclaredField(\"line1\");\n+            line1.setAccessible(true);\n+            line1.set(cond, longString);\n+            Field line2 = Class.forName(CLASS).getDeclaredField(\"line2\");\n+            line2.setAccessible(true);\n+            line2.set(cond, longString);\n+        } catch (NoSuchFieldException e) {\n+            fail(e.toString());\n+        } catch (ClassNotFoundException e) {\n+            fail(e.toString());\n+        } catch (IllegalAccessException e) {\n+            fail(e.toString());\n+        }\n+\n+        Parcel parcel = Parcel.obtain();\n+        cond.writeToParcel(parcel, 0);\n+        parcel.setDataPosition(0);\n+\n+        Condition fromParcel = new Condition(parcel);\n+        assertEquals(Condition.MAX_STRING_LENGTH, fromParcel.id.toString().length());\n+        assertEquals(Condition.MAX_STRING_LENGTH, fromParcel.summary.length());\n+        assertEquals(Condition.MAX_STRING_LENGTH, fromParcel.line1.length());\n+        assertEquals(Condition.MAX_STRING_LENGTH, fromParcel.line2.length());\n+    }\n+}\n",
    "added_lines": 101,
    "deleted_lines": 0,
    "changed_methods": "ConditionTest::testLongFields_viaParcel, ConditionTest::testLongFields_inConstructors"
   }
  ]
 },
 {
  "hash": "78f58b477987e157ac4d73db4f99a19ecebd33bd",
  "commit": "Limit lengths of fields in Condition to a max length.\n\nThis app-generated input needs to not be too long to avoid errors in the process of writing to disk.\n\nBug: 242846316\nTest: cts ConditionTest; atest ConditionTest; manually verified exploit apk is OK\n\nChange-Id: Ic2fa8f06cc7a4c1f262115764fbd1be2a226b4b9\nMerged-In: Ic2fa8f06cc7a4c1f262115764fbd1be2a226b4b9\n(cherry picked from commit 81352c3775949c622441e10b468766441e35edc7)\n(cherry picked from commit 7059638be9271303e22b7b3e8aa6d58677f6143b)\nMerged-In: Ic2fa8f06cc7a4c1f262115764fbd1be2a226b4b9",
  "files": [
   {
    "filename": "Condition.java",
    "diff": "@@ -90,6 +90,12 @@ public final class Condition implements Parcelable {\n     public final int flags;\n     public final int icon;\n \n+    /**\n+     * The maximum string length for any string contained in this condition.\n+     * @hide\n+     */\n+    public static final int MAX_STRING_LENGTH = 1000;\n+\n     /**\n      * An object representing the current state of a {@link android.app.AutomaticZenRule}.\n      * @param id the {@link android.app.AutomaticZenRule#getConditionId()} of the zen rule\n@@ -104,16 +110,19 @@ public final class Condition implements Parcelable {\n         if (id == null) throw new IllegalArgumentException(\"id is required\");\n         if (summary == null) throw new IllegalArgumentException(\"summary is required\");\n         if (!isValidState(state)) throw new IllegalArgumentException(\"state is invalid: \" + state);\n-        this.id = id;\n-        this.summary = summary;\n-        this.line1 = line1;\n-        this.line2 = line2;\n+        this.id = getTrimmedUri(id);\n+        this.summary = getTrimmedString(summary);\n+        this.line1 = getTrimmedString(line1);\n+        this.line2 = getTrimmedString(line2);\n         this.icon = icon;\n         this.state = state;\n         this.flags = flags;\n     }\n \n     public Condition(Parcel source) {\n+        // This constructor passes all fields directly into the constructor that takes all the\n+        // fields as arguments; that constructor will trim each of the input strings to\n+        // max length if necessary.\n         this((Uri)source.readParcelable(Condition.class.getClassLoader()),\n                 source.readString(),\n                 source.readString(),\n@@ -240,4 +249,25 @@ public final class Condition implements Parcelable {\n             return new Condition[size];\n         }\n     };\n+\n+    /**\n+     * Returns a truncated copy of the string if the string is longer than MAX_STRING_LENGTH.\n+     */\n+    private static String getTrimmedString(String input) {\n+        if (input != null && input.length() > MAX_STRING_LENGTH) {\n+            return input.substring(0, MAX_STRING_LENGTH);\n+        }\n+        return input;\n+    }\n+\n+    /**\n+     * Returns a truncated copy of the Uri by trimming the string representation to the maximum\n+     * string length.\n+     */\n+    private static Uri getTrimmedUri(Uri input) {\n+        if (input != null && input.toString().length() > MAX_STRING_LENGTH) {\n+            return Uri.parse(getTrimmedString(input.toString()));\n+        }\n+        return input;\n+    }\n }\n",
    "added_lines": 34,
    "deleted_lines": 4,
    "changed_methods": "Condition::Condition, Condition::Condition, Condition::getTrimmedString, Condition::getTrimmedUri"
   },
   {
    "filename": "ConditionTest.java",
    "diff": "@@ -0,0 +1,101 @@\n+/*\n+ * Copyright (C) 2022 The Android Open Source Project\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package android.service.notification;\n+\n+import static junit.framework.Assert.assertEquals;\n+import static junit.framework.Assert.fail;\n+\n+import android.net.Uri;\n+import android.os.Parcel;\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4;\n+import androidx.test.filters.SmallTest;\n+\n+import com.google.common.base.Strings;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import java.lang.reflect.Field;\n+\n+@RunWith(AndroidJUnit4.class)\n+@SmallTest\n+public class ConditionTest {\n+    private static final String CLASS = \"android.service.notification.Condition\";\n+\n+    @Test\n+    public void testLongFields_inConstructors() {\n+        String longString = Strings.repeat(\"A\", 65536);\n+        Uri longUri = Uri.parse(\"uri://\" + Strings.repeat(\"A\", 65530));\n+\n+        // Confirm strings are truncated via short constructor\n+        Condition cond1 = new Condition(longUri, longString, Condition.STATE_TRUE);\n+\n+        assertEquals(Condition.MAX_STRING_LENGTH, cond1.id.toString().length());\n+        assertEquals(Condition.MAX_STRING_LENGTH, cond1.summary.length());\n+\n+        // Confirm strings are truncated via long constructor\n+        Condition cond2 = new Condition(longUri, longString, longString, longString,\n+                -1, Condition.STATE_TRUE, Condition.FLAG_RELEVANT_ALWAYS);\n+\n+        assertEquals(Condition.MAX_STRING_LENGTH, cond2.id.toString().length());\n+        assertEquals(Condition.MAX_STRING_LENGTH, cond2.summary.length());\n+        assertEquals(Condition.MAX_STRING_LENGTH, cond2.line1.length());\n+        assertEquals(Condition.MAX_STRING_LENGTH, cond2.line2.length());\n+    }\n+\n+    @Test\n+    public void testLongFields_viaParcel() {\n+        // Set fields via reflection to force them to be long, then parcel and unparcel to make sure\n+        // it gets truncated upon unparcelling.\n+        Condition cond = new Condition(Uri.parse(\"uri://placeholder\"), \"placeholder\",\n+                Condition.STATE_TRUE);\n+\n+        try {\n+            String longString = Strings.repeat(\"A\", 65536);\n+            Uri longUri = Uri.parse(\"uri://\" + Strings.repeat(\"A\", 65530));\n+            Field id = Class.forName(CLASS).getDeclaredField(\"id\");\n+            id.setAccessible(true);\n+            id.set(cond, longUri);\n+            Field summary = Class.forName(CLASS).getDeclaredField(\"summary\");\n+            summary.setAccessible(true);\n+            summary.set(cond, longString);\n+            Field line1 = Class.forName(CLASS).getDeclaredField(\"line1\");\n+            line1.setAccessible(true);\n+            line1.set(cond, longString);\n+            Field line2 = Class.forName(CLASS).getDeclaredField(\"line2\");\n+            line2.setAccessible(true);\n+            line2.set(cond, longString);\n+        } catch (NoSuchFieldException e) {\n+            fail(e.toString());\n+        } catch (ClassNotFoundException e) {\n+            fail(e.toString());\n+        } catch (IllegalAccessException e) {\n+            fail(e.toString());\n+        }\n+\n+        Parcel parcel = Parcel.obtain();\n+        cond.writeToParcel(parcel, 0);\n+        parcel.setDataPosition(0);\n+\n+        Condition fromParcel = new Condition(parcel);\n+        assertEquals(Condition.MAX_STRING_LENGTH, fromParcel.id.toString().length());\n+        assertEquals(Condition.MAX_STRING_LENGTH, fromParcel.summary.length());\n+        assertEquals(Condition.MAX_STRING_LENGTH, fromParcel.line1.length());\n+        assertEquals(Condition.MAX_STRING_LENGTH, fromParcel.line2.length());\n+    }\n+}\n",
    "added_lines": 101,
    "deleted_lines": 0,
    "changed_methods": "ConditionTest::testLongFields_viaParcel, ConditionTest::testLongFields_inConstructors"
   }
  ]
 },
 {
  "hash": "d0b5819a37b7a06b07385d898742d558aac4e7da",
  "commit": "Fix NPE\n\nTest: NotificationChannelGroupTest\nTest: view notification settings for an app that doesn't use groups\nFixes: 244574602\nBug: 241764350\nBug: 241764340\nBug: 241764135\nBug: 242702935\nBug: 242703118\nBug: 242703202\nBug: 242702851\nBug: 242703217\nBug: 242703556\nChange-Id: I9c681106f6d645e62b0e44903d40aa523fee0e95\n(cherry picked from commit 6f02c07176d0fa4d6985c8f2200ccf49a1657d1c)\nMerged-In: I9c681106f6d645e62b0e44903d40aa523fee0e95\n(cherry picked from commit e51c402650c5e4400108cf63d460ec349577087c)\nMerged-In: I9c681106f6d645e62b0e44903d40aa523fee0e95",
  "files": [
   {
    "filename": "NotificationChannelGroup.java",
    "diff": "@@ -95,8 +95,11 @@ public final class NotificationChannelGroup implements Parcelable {\n         } else {\n             mId = null;\n         }\n-        mName = TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(in);\n-        mName = getTrimmedString(mName.toString());\n+        if (in.readByte() != 0) {\n+            mName = getTrimmedString(in.readString());\n+        } else {\n+            mName = \"\";\n+        }\n         if (in.readByte() != 0) {\n             mDescription = getTrimmedString(in.readString());\n         } else {\n@@ -122,7 +125,12 @@ public final class NotificationChannelGroup implements Parcelable {\n         } else {\n             dest.writeByte((byte) 0);\n         }\n-        TextUtils.writeToParcel(mName.toString(), dest, flags);\n+        if (mName != null) {\n+            dest.writeByte((byte) 1);\n+            dest.writeString(mName.toString());\n+        } else {\n+            dest.writeByte((byte) 0);\n+        }\n         if (mDescription != null) {\n             dest.writeByte((byte) 1);\n             dest.writeString(mDescription);\n",
    "added_lines": 11,
    "deleted_lines": 3,
    "changed_methods": "NotificationChannelGroup::NotificationChannelGroup, NotificationChannelGroup::writeToParcel"
   },
   {
    "filename": "NotificationChannelGroupTest.java",
    "diff": "@@ -17,9 +17,11 @@\n package android.app;\n \n import static junit.framework.TestCase.assertEquals;\n+import static junit.framework.TestCase.assertTrue;\n \n import android.os.Parcel;\n import android.test.AndroidTestCase;\n+import android.text.TextUtils;\n \n import androidx.test.filters.SmallTest;\n import androidx.test.runner.AndroidJUnit4;\n@@ -70,4 +72,18 @@ public class NotificationChannelGroupTest {\n         assertEquals(NotificationChannelGroup.MAX_TEXT_LENGTH,\n                 fromParcel.getDescription().length());\n     }\n+\n+    @Test\n+    public void testNullableFields() {\n+        NotificationChannelGroup group = new NotificationChannelGroup(\"my_group_01\", null);\n+\n+        Parcel parcel = Parcel.obtain();\n+        group.writeToParcel(parcel, 0);\n+        parcel.setDataPosition(0);\n+\n+        NotificationChannelGroup fromParcel =\n+                NotificationChannelGroup.CREATOR.createFromParcel(parcel);\n+        assertEquals(group.getId(), fromParcel.getId());\n+        assertTrue(TextUtils.isEmpty(fromParcel.getName()));\n+    }\n }\n",
    "added_lines": 16,
    "deleted_lines": 0,
    "changed_methods": "NotificationChannelGroupTest::testNullableFields"
   }
  ]
 },
 {
  "hash": "d0b5819a37b7a06b07385d898742d558aac4e7da",
  "commit": "Fix NPE\n\nTest: NotificationChannelGroupTest\nTest: view notification settings for an app that doesn't use groups\nFixes: 244574602\nBug: 241764350\nBug: 241764340\nBug: 241764135\nBug: 242702935\nBug: 242703118\nBug: 242703202\nBug: 242702851\nBug: 242703217\nBug: 242703556\nChange-Id: I9c681106f6d645e62b0e44903d40aa523fee0e95\n(cherry picked from commit 6f02c07176d0fa4d6985c8f2200ccf49a1657d1c)\nMerged-In: I9c681106f6d645e62b0e44903d40aa523fee0e95\n(cherry picked from commit e51c402650c5e4400108cf63d460ec349577087c)\nMerged-In: I9c681106f6d645e62b0e44903d40aa523fee0e95",
  "files": [
   {
    "filename": "NotificationChannelGroup.java",
    "diff": "@@ -95,8 +95,11 @@ public final class NotificationChannelGroup implements Parcelable {\n         } else {\n             mId = null;\n         }\n-        mName = TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(in);\n-        mName = getTrimmedString(mName.toString());\n+        if (in.readByte() != 0) {\n+            mName = getTrimmedString(in.readString());\n+        } else {\n+            mName = \"\";\n+        }\n         if (in.readByte() != 0) {\n             mDescription = getTrimmedString(in.readString());\n         } else {\n@@ -122,7 +125,12 @@ public final class NotificationChannelGroup implements Parcelable {\n         } else {\n             dest.writeByte((byte) 0);\n         }\n-        TextUtils.writeToParcel(mName.toString(), dest, flags);\n+        if (mName != null) {\n+            dest.writeByte((byte) 1);\n+            dest.writeString(mName.toString());\n+        } else {\n+            dest.writeByte((byte) 0);\n+        }\n         if (mDescription != null) {\n             dest.writeByte((byte) 1);\n             dest.writeString(mDescription);\n",
    "added_lines": 11,
    "deleted_lines": 3,
    "changed_methods": "NotificationChannelGroup::NotificationChannelGroup, NotificationChannelGroup::writeToParcel"
   },
   {
    "filename": "NotificationChannelGroupTest.java",
    "diff": "@@ -17,9 +17,11 @@\n package android.app;\n \n import static junit.framework.TestCase.assertEquals;\n+import static junit.framework.TestCase.assertTrue;\n \n import android.os.Parcel;\n import android.test.AndroidTestCase;\n+import android.text.TextUtils;\n \n import androidx.test.filters.SmallTest;\n import androidx.test.runner.AndroidJUnit4;\n@@ -70,4 +72,18 @@ public class NotificationChannelGroupTest {\n         assertEquals(NotificationChannelGroup.MAX_TEXT_LENGTH,\n                 fromParcel.getDescription().length());\n     }\n+\n+    @Test\n+    public void testNullableFields() {\n+        NotificationChannelGroup group = new NotificationChannelGroup(\"my_group_01\", null);\n+\n+        Parcel parcel = Parcel.obtain();\n+        group.writeToParcel(parcel, 0);\n+        parcel.setDataPosition(0);\n+\n+        NotificationChannelGroup fromParcel =\n+                NotificationChannelGroup.CREATOR.createFromParcel(parcel);\n+        assertEquals(group.getId(), fromParcel.getId());\n+        assertTrue(TextUtils.isEmpty(fromParcel.getName()));\n+    }\n }\n",
    "added_lines": 16,
    "deleted_lines": 0,
    "changed_methods": "NotificationChannelGroupTest::testNullableFields"
   }
  ]
 },
 {
  "hash": "82e4c08288424015d447681815554397cf793a1e",
  "commit": "Fix a security issue in app widget service.\n\nBug: 234013191\nTest: atest RemoteViewsAdapterTest\nChange-Id: Icd2eccb7a90124aca18a3dd463c3f79e3a595c20\nMerged-In: Icd2eccb7a90124aca18a3dd463c3f79e3a595c20\n(cherry picked from commit 263d7d0ba8818c471a27938c4e002bae33569f01)\n(cherry picked from commit 0ee21ef3e652c78c934d257632a4951bd6d38011)\nMerged-In: Icd2eccb7a90124aca18a3dd463c3f79e3a595c20",
  "files": [
   {
    "filename": "AppWidgetManager.java",
    "diff": "@@ -1130,7 +1130,9 @@ public class AppWidgetManager {\n      * @param intent        The intent of the service which will be providing the data to the\n      *                      RemoteViewsAdapter.\n      * @param connection    The callback interface to be notified when a connection is made or lost.\n-     * @param flags         Flags used for binding to the service\n+     * @param flags         Flags used for binding to the service. Currently only\n+     *                     {@link Context#BIND_AUTO_CREATE} and\n+     *                     {@link Context#BIND_FOREGROUND_SERVICE_WHILE_AWAKE} are supported.\n      *\n      * @see Context#getServiceDispatcher(ServiceConnection, Handler, int)\n      * @hide\n",
    "added_lines": 3,
    "deleted_lines": 1,
    "changed_methods": ""
   },
   {
    "filename": "AppWidgetServiceImpl.java",
    "diff": "@@ -1199,11 +1199,12 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n             try {\n                 // Ask ActivityManager to bind it. Notice that we are binding the service with the\n                 // caller app instead of DevicePolicyManagerService.\n-                if(ActivityManager.getService().bindService(\n+                if (ActivityManager.getService().bindService(\n                         caller, activtiyToken, intent,\n                         intent.resolveTypeIfNeeded(mContext.getContentResolver()),\n-                        connection, flags, mContext.getOpPackageName(),\n-                        widget.provider.getUserId()) != 0) {\n+                        connection, flags & (Context.BIND_AUTO_CREATE\n+                                | Context.BIND_FOREGROUND_SERVICE_WHILE_AWAKE),\n+                        mContext.getOpPackageName(), widget.provider.getUserId()) != 0) {\n \n                     // Add it to the mapping of RemoteViewsService to appWidgetIds so that we\n                     // can determine when we can call back to the RemoteViewsService later to\n",
    "added_lines": 4,
    "deleted_lines": 3,
    "changed_methods": "AppWidgetServiceImpl::bindRemoteViewsService"
   }
  ]
 },
 {
  "hash": "82e4c08288424015d447681815554397cf793a1e",
  "commit": "Fix a security issue in app widget service.\n\nBug: 234013191\nTest: atest RemoteViewsAdapterTest\nChange-Id: Icd2eccb7a90124aca18a3dd463c3f79e3a595c20\nMerged-In: Icd2eccb7a90124aca18a3dd463c3f79e3a595c20\n(cherry picked from commit 263d7d0ba8818c471a27938c4e002bae33569f01)\n(cherry picked from commit 0ee21ef3e652c78c934d257632a4951bd6d38011)\nMerged-In: Icd2eccb7a90124aca18a3dd463c3f79e3a595c20",
  "files": [
   {
    "filename": "AppWidgetManager.java",
    "diff": "@@ -1130,7 +1130,9 @@ public class AppWidgetManager {\n      * @param intent        The intent of the service which will be providing the data to the\n      *                      RemoteViewsAdapter.\n      * @param connection    The callback interface to be notified when a connection is made or lost.\n-     * @param flags         Flags used for binding to the service\n+     * @param flags         Flags used for binding to the service. Currently only\n+     *                     {@link Context#BIND_AUTO_CREATE} and\n+     *                     {@link Context#BIND_FOREGROUND_SERVICE_WHILE_AWAKE} are supported.\n      *\n      * @see Context#getServiceDispatcher(ServiceConnection, Handler, int)\n      * @hide\n",
    "added_lines": 3,
    "deleted_lines": 1,
    "changed_methods": ""
   },
   {
    "filename": "AppWidgetServiceImpl.java",
    "diff": "@@ -1199,11 +1199,12 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n             try {\n                 // Ask ActivityManager to bind it. Notice that we are binding the service with the\n                 // caller app instead of DevicePolicyManagerService.\n-                if(ActivityManager.getService().bindService(\n+                if (ActivityManager.getService().bindService(\n                         caller, activtiyToken, intent,\n                         intent.resolveTypeIfNeeded(mContext.getContentResolver()),\n-                        connection, flags, mContext.getOpPackageName(),\n-                        widget.provider.getUserId()) != 0) {\n+                        connection, flags & (Context.BIND_AUTO_CREATE\n+                                | Context.BIND_FOREGROUND_SERVICE_WHILE_AWAKE),\n+                        mContext.getOpPackageName(), widget.provider.getUserId()) != 0) {\n \n                     // Add it to the mapping of RemoteViewsService to appWidgetIds so that we\n                     // can determine when we can call back to the RemoteViewsService later to\n",
    "added_lines": 4,
    "deleted_lines": 3,
    "changed_methods": "AppWidgetServiceImpl::bindRemoteViewsService"
   }
  ]
 },
 {
  "hash": "67b29ab4020e94c433391aedc23d8457f79fe40b",
  "commit": "[RESTRICT AUTOMERGE] Allow activity to be reparent while allowTaskReparenting is applied\n\nAny malicious application could hijack tasks by\nandroid:allowTaskReparenting. This vulnerability can perform UI\nspoofing or spying on user\u2019s activities.\n\nThis CL only allows activities to be reparent while\nandroid:allowTaskReparenting is applied and the affinity of activity\nis same with the target task.\n\nBug: 240663194\nTest: atest IntentTests\nChange-Id: I73abb9ec05af95bc14f887ae825a9ada9600f771\n(cherry picked from commit 7af50c4d5f0354438872167b0e446930caca9deb)\nMerged-In: I73abb9ec05af95bc14f887ae825a9ada9600f771",
  "files": [
   {
    "filename": "ResetTargetTaskHelper.java",
    "diff": "@@ -146,15 +146,16 @@ class ResetTargetTaskHelper {\n             return false;\n \n         } else {\n-            mResultActivities.add(r);\n             if (r.resultTo != null) {\n                 // If this activity is sending a reply to a previous activity, we can't do\n                 // anything with it now until we reach the start of the reply chain.\n                 // NOTE: that we are assuming the result is always to the previous activity,\n                 // which is almost always the case but we really shouldn't count on.\n+                mResultActivities.add(r);\n                 return false;\n             } else if (mTargetTaskFound && allowTaskReparenting && mTargetTask.affinity != null\n                     && mTargetTask.affinity.equals(r.taskAffinity)) {\n+                mResultActivities.add(r);\n                 // This activity has an affinity for our task. Either remove it if we are\n                 // clearing or move it over to our task. Note that we currently punt on the case\n                 // where we are resetting a task that is not at the top but who has activities\n",
    "added_lines": 2,
    "deleted_lines": 1,
    "changed_methods": "ResetTargetTaskHelper::processActivity"
   }
  ]
 },
 {
  "hash": "a8afb70ebc208f6e6a285e83cf44b53202a7869e",
  "commit": "[DO NOT MERGE] Update window with FLAG_SECURE when bouncer is showing\n\nThis will prevent bouncer interactions from showing up in\nscreenrecords or screenshots.\n\nFixes: 215005011\nTest: atest NotificationShadeWindowControllerImpl && take screenshot\nwith bouncer up\n\nChange-Id: I3f59df865dc2dd13d4b9ac54bb2dacb7b23f0aa1\nMerged-In: I3f59df865dc2dd13d4b9ac54bb2dacb7b23f0aa1\n(cherry picked from commit 6888543d3a6cde5a9e16f9accb0a4256152aba2d)\n(cherry picked from commit 18ddad1f5a3d9592e063c3d3a70278bccc2e08e5)\nMerged-In: I3f59df865dc2dd13d4b9ac54bb2dacb7b23f0aa1",
  "files": [
   {
    "filename": "NotificationShadeWindowControllerImpl.java",
    "diff": "@@ -29,6 +29,7 @@ import android.content.pm.ActivityInfo;\n import android.database.ContentObserver;\n import android.graphics.PixelFormat;\n import android.os.Binder;\n+import android.os.Build;\n import android.os.Handler;\n import android.os.RemoteException;\n import android.os.Trace;\n@@ -343,6 +344,16 @@ public class NotificationShadeWindowControllerImpl implements NotificationShadeW\n             Trace.setCounter(\"display_max_refresh_rate\",\n                     (long) mLpChanged.preferredMaxDisplayRefreshRate);\n         }\n+\n+        if (state.mBouncerShowing && !isDebuggable()) {\n+            mLpChanged.flags |= LayoutParams.FLAG_SECURE;\n+        } else {\n+            mLpChanged.flags &= ~LayoutParams.FLAG_SECURE;\n+        }\n+    }\n+\n+    protected boolean isDebuggable() {\n+        return Build.IS_DEBUGGABLE;\n     }\n \n     private void adjustScreenOrientation(State state) {\n",
    "added_lines": 11,
    "deleted_lines": 0,
    "changed_methods": "NotificationShadeWindowControllerImpl::applyKeyguardFlags, NotificationShadeWindowControllerImpl::isDebuggable"
   },
   {
    "filename": "NotificationShadeWindowControllerImplTest.java",
    "diff": "@@ -18,6 +18,7 @@ package com.android.systemui.statusbar.phone;\n \n import static android.view.WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM;\n import static android.view.WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;\n+import static android.view.WindowManager.LayoutParams.FLAG_SECURE;\n import static android.view.WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER;\n \n import static com.google.common.truth.Truth.assertThat;\n@@ -90,7 +91,12 @@ public class NotificationShadeWindowControllerImplTest extends SysuiTestCase {\n                 mWindowManager, mActivityManager, mDozeParameters, mStatusBarStateController,\n                 mConfigurationController, mKeyguardViewMediator, mKeyguardBypassController,\n                 mColorExtractor, mDumpManager, mKeyguardStateController,\n-                mUnlockedScreenOffAnimationController, mAuthController);\n+                mUnlockedScreenOffAnimationController, mAuthController) {\n+                    @Override\n+                    protected boolean isDebuggable() {\n+                        return false;\n+                    }\n+            };\n         mNotificationShadeWindowController.setScrimsVisibilityListener((visibility) -> {});\n         mNotificationShadeWindowController.setNotificationShadeView(mNotificationShadeWindowView);\n \n@@ -239,4 +245,20 @@ public class NotificationShadeWindowControllerImplTest extends SysuiTestCase {\n         });\n         verify(mWindowManager).updateViewLayout(any(), any());\n     }\n+\n+    @Test\n+    public void setKeyguardShowing_enablesSecureFlag() {\n+        mNotificationShadeWindowController.setBouncerShowing(true);\n+\n+        verify(mWindowManager).updateViewLayout(any(), mLayoutParameters.capture());\n+        assertThat((mLayoutParameters.getValue().flags & FLAG_SECURE) != 0).isTrue();\n+    }\n+\n+    @Test\n+    public void setKeyguardNotShowing_disablesSecureFlag() {\n+        mNotificationShadeWindowController.setBouncerShowing(false);\n+\n+        verify(mWindowManager).updateViewLayout(any(), mLayoutParameters.capture());\n+        assertThat((mLayoutParameters.getValue().flags & FLAG_SECURE) == 0).isTrue();\n+    }\n }\n",
    "added_lines": 23,
    "deleted_lines": 1,
    "changed_methods": "NotificationShadeWindowControllerImplTest::setUp, NotificationShadeWindowControllerImplTest::setKeyguardShowing_enablesSecureFlag, NotificationShadeWindowControllerImplTest::setKeyguardNotShowing_disablesSecureFlag"
   }
  ]
 },
 {
  "hash": "a8afb70ebc208f6e6a285e83cf44b53202a7869e",
  "commit": "[DO NOT MERGE] Update window with FLAG_SECURE when bouncer is showing\n\nThis will prevent bouncer interactions from showing up in\nscreenrecords or screenshots.\n\nFixes: 215005011\nTest: atest NotificationShadeWindowControllerImpl && take screenshot\nwith bouncer up\n\nChange-Id: I3f59df865dc2dd13d4b9ac54bb2dacb7b23f0aa1\nMerged-In: I3f59df865dc2dd13d4b9ac54bb2dacb7b23f0aa1\n(cherry picked from commit 6888543d3a6cde5a9e16f9accb0a4256152aba2d)\n(cherry picked from commit 18ddad1f5a3d9592e063c3d3a70278bccc2e08e5)\nMerged-In: I3f59df865dc2dd13d4b9ac54bb2dacb7b23f0aa1",
  "files": [
   {
    "filename": "NotificationShadeWindowControllerImpl.java",
    "diff": "@@ -29,6 +29,7 @@ import android.content.pm.ActivityInfo;\n import android.database.ContentObserver;\n import android.graphics.PixelFormat;\n import android.os.Binder;\n+import android.os.Build;\n import android.os.Handler;\n import android.os.RemoteException;\n import android.os.Trace;\n@@ -343,6 +344,16 @@ public class NotificationShadeWindowControllerImpl implements NotificationShadeW\n             Trace.setCounter(\"display_max_refresh_rate\",\n                     (long) mLpChanged.preferredMaxDisplayRefreshRate);\n         }\n+\n+        if (state.mBouncerShowing && !isDebuggable()) {\n+            mLpChanged.flags |= LayoutParams.FLAG_SECURE;\n+        } else {\n+            mLpChanged.flags &= ~LayoutParams.FLAG_SECURE;\n+        }\n+    }\n+\n+    protected boolean isDebuggable() {\n+        return Build.IS_DEBUGGABLE;\n     }\n \n     private void adjustScreenOrientation(State state) {\n",
    "added_lines": 11,
    "deleted_lines": 0,
    "changed_methods": "NotificationShadeWindowControllerImpl::applyKeyguardFlags, NotificationShadeWindowControllerImpl::isDebuggable"
   },
   {
    "filename": "NotificationShadeWindowControllerImplTest.java",
    "diff": "@@ -18,6 +18,7 @@ package com.android.systemui.statusbar.phone;\n \n import static android.view.WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM;\n import static android.view.WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;\n+import static android.view.WindowManager.LayoutParams.FLAG_SECURE;\n import static android.view.WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER;\n \n import static com.google.common.truth.Truth.assertThat;\n@@ -90,7 +91,12 @@ public class NotificationShadeWindowControllerImplTest extends SysuiTestCase {\n                 mWindowManager, mActivityManager, mDozeParameters, mStatusBarStateController,\n                 mConfigurationController, mKeyguardViewMediator, mKeyguardBypassController,\n                 mColorExtractor, mDumpManager, mKeyguardStateController,\n-                mUnlockedScreenOffAnimationController, mAuthController);\n+                mUnlockedScreenOffAnimationController, mAuthController) {\n+                    @Override\n+                    protected boolean isDebuggable() {\n+                        return false;\n+                    }\n+            };\n         mNotificationShadeWindowController.setScrimsVisibilityListener((visibility) -> {});\n         mNotificationShadeWindowController.setNotificationShadeView(mNotificationShadeWindowView);\n \n@@ -239,4 +245,20 @@ public class NotificationShadeWindowControllerImplTest extends SysuiTestCase {\n         });\n         verify(mWindowManager).updateViewLayout(any(), any());\n     }\n+\n+    @Test\n+    public void setKeyguardShowing_enablesSecureFlag() {\n+        mNotificationShadeWindowController.setBouncerShowing(true);\n+\n+        verify(mWindowManager).updateViewLayout(any(), mLayoutParameters.capture());\n+        assertThat((mLayoutParameters.getValue().flags & FLAG_SECURE) != 0).isTrue();\n+    }\n+\n+    @Test\n+    public void setKeyguardNotShowing_disablesSecureFlag() {\n+        mNotificationShadeWindowController.setBouncerShowing(false);\n+\n+        verify(mWindowManager).updateViewLayout(any(), mLayoutParameters.capture());\n+        assertThat((mLayoutParameters.getValue().flags & FLAG_SECURE) == 0).isTrue();\n+    }\n }\n",
    "added_lines": 23,
    "deleted_lines": 1,
    "changed_methods": "NotificationShadeWindowControllerImplTest::setUp, NotificationShadeWindowControllerImplTest::setKeyguardShowing_enablesSecureFlag, NotificationShadeWindowControllerImplTest::setKeyguardNotShowing_disablesSecureFlag"
   }
  ]
 },
 {
  "hash": "ec5b5e1dfa1406a29e719430a3cd05a4f960f41a",
  "commit": "Prevent exfiltration of system files via avatar picker.\n\nThis adds mitigations to prevent system files being exfiltrated\nvia the settings content provider when a content URI is provided\nas a chosen user image.\n\nThe mitigations are:\n\n1) Copy the image to a new URI rather than the existing takePictureUri\nprior to cropping.\n\n2) Only allow a system handler to respond to the CROP intent.\n\nThis is a fixed version of ag/17071224, to address b/239513606.\n\nBug: 187702830\nTest: build and check functionality\nChange-Id: Ie352d07bbcfc7e0b0a1db1dbe3fd43085e0ecbb6\nMerged-In: Idf1ab60878d619ee30505d71e8afe31d8b0c0ebe\n(cherry picked from commit 1b48ca6b7f44bacdb7b9469bfaf08fe4881ea0ae)\nMerged-In: Ie352d07bbcfc7e0b0a1db1dbe3fd43085e0ecbb6",
  "files": [
   {
    "filename": "EditUserPhotoController.java",
    "diff": "@@ -21,6 +21,8 @@ import android.content.ClipData;\n import android.content.ContentResolver;\n import android.content.Context;\n import android.content.Intent;\n+import android.content.pm.PackageManager;\n+import android.content.pm.ResolveInfo;\n import android.database.Cursor;\n import android.graphics.Bitmap;\n import android.graphics.Bitmap.Config;\n@@ -83,6 +85,7 @@ public class EditUserPhotoController {\n     private static final int DEFAULT_PHOTO_SIZE = 500;\n \n     private static final String IMAGES_DIR = \"multi_user\";\n+    private static final String PRE_CROP_PICTURE_FILE_NAME = \"PreCropEditUserPhoto.jpg\";\n     private static final String CROP_PICTURE_FILE_NAME = \"CropEditUserPhoto.jpg\";\n     private static final String TAKE_PICTURE_FILE_NAME = \"TakeEditUserPhoto.jpg\";\n     private static final String NEW_USER_PHOTO_FILE_NAME = \"NewUserPhoto.png\";\n@@ -95,6 +98,7 @@ public class EditUserPhotoController {\n     private final String mFileAuthority;\n \n     private final File mImagesDir;\n+    private final Uri mPreCropPictureUri;\n     private final Uri mCropPictureUri;\n     private final Uri mTakePictureUri;\n \n@@ -110,6 +114,7 @@ public class EditUserPhotoController {\n \n         mImagesDir = new File(activity.getCacheDir(), IMAGES_DIR);\n         mImagesDir.mkdir();\n+        mPreCropPictureUri = createTempImageUri(activity, PRE_CROP_PICTURE_FILE_NAME, !waiting);\n         mCropPictureUri = createTempImageUri(activity, CROP_PICTURE_FILE_NAME, !waiting);\n         mTakePictureUri = createTempImageUri(activity, TAKE_PICTURE_FILE_NAME, !waiting);\n         mPhotoSize = getPhotoSize(activity);\n@@ -143,7 +148,7 @@ public class EditUserPhotoController {\n             case REQUEST_CODE_CHOOSE_PHOTO:\n                 if (mTakePictureUri.equals(pictureUri)) {\n                     if (PhotoCapabilityUtils.canCropPhoto(mActivity)) {\n-                        cropPhoto();\n+                        cropPhoto(pictureUri);\n                     } else {\n                         onPhotoNotCropped(pictureUri);\n                     }\n@@ -224,7 +229,7 @@ public class EditUserPhotoController {\n             protected Void doInBackground(Void... params) {\n                 final ContentResolver cr = mActivity.getContentResolver();\n                 try (InputStream in = cr.openInputStream(pictureUri);\n-                     OutputStream out = cr.openOutputStream(mTakePictureUri)) {\n+                        OutputStream out = cr.openOutputStream(mPreCropPictureUri)) {\n                     Streams.copy(in, out);\n                 } catch (IOException e) {\n                     Log.w(TAG, \"Failed to copy photo\", e);\n@@ -235,28 +240,41 @@ public class EditUserPhotoController {\n             @Override\n             protected void onPostExecute(Void result) {\n                 if (!mActivity.isFinishing() && !mActivity.isDestroyed()) {\n-                    cropPhoto();\n+                    cropPhoto(mPreCropPictureUri);\n                 }\n             }\n         }.execute();\n     }\n \n-    private void cropPhoto() {\n+    private void cropPhoto(final Uri pictureUri) {\n         // TODO: Use a public intent, when there is one.\n         Intent intent = new Intent(\"com.android.camera.action.CROP\");\n-        intent.setDataAndType(mTakePictureUri, \"image/*\");\n+        intent.setDataAndType(pictureUri, \"image/*\");\n         appendOutputExtra(intent, mCropPictureUri);\n         appendCropExtras(intent);\n-        if (intent.resolveActivity(mActivity.getPackageManager()) != null) {\n-            try {\n-                StrictMode.disableDeathOnFileUriExposure();\n-                mActivityStarter.startActivityForResult(intent, REQUEST_CODE_CROP_PHOTO);\n-            } finally {\n-                StrictMode.enableDeathOnFileUriExposure();\n+        try {\n+            StrictMode.disableDeathOnFileUriExposure();\n+            if (startSystemActivityForResult(intent, REQUEST_CODE_CROP_PHOTO)) {\n+                return;\n             }\n-        } else {\n-            onPhotoNotCropped(mTakePictureUri);\n+        } finally {\n+            StrictMode.enableDeathOnFileUriExposure();\n+        }\n+\n+        onPhotoNotCropped(mTakePictureUri);\n+\n+    }\n+\n+    private boolean startSystemActivityForResult(Intent intent, int code) {\n+        List<ResolveInfo> resolveInfos = mActivity.getPackageManager()\n+                .queryIntentActivities(intent, PackageManager.MATCH_SYSTEM_ONLY);\n+        if (resolveInfos.isEmpty()) {\n+            Log.w(TAG, \"No system package activity could be found for code \" + code);\n+            return false;\n         }\n+        intent.setPackage(resolveInfos.get(0).activityInfo.packageName);\n+        mActivityStarter.startActivityForResult(intent, code);\n+        return true;\n     }\n \n     private void appendOutputExtra(Intent intent, Uri pictureUri) {\n",
    "added_lines": 31,
    "deleted_lines": 13,
    "changed_methods": "EditUserPhotoController::EditUserPhotoController, EditUserPhotoController::startSystemActivityForResult, EditUserPhotoController::copyAndCropPhoto, EditUserPhotoController::cropPhoto, EditUserPhotoController::onActivityResult, EditUserPhotoController::cropPhoto"
   }
  ]
 },
 {
  "hash": "a0024d7805bc14fa7371124e9c9650df82be2513",
  "commit": "[Do Not Merge] Ignore malformed shortcuts\n\nAfter an app publishes a shortcut that contains malformed intent, the\nsystem can be stuck in boot-loop due to uncaught exception caused by\nparsing the malformed intent.\n\nThis CL ignores that particular malformed entry. Since shortcuts are\nconstantly writes back into the xml from system memory, the malformed\nentry will be removed from the xml the next time system persists\nshortcuts from memory to file system.\n\nBug: 246540168\nChange-Id: Ibbfd0891eabdce72f76571798382fe949d8f453d\nTest: manual\n(cherry picked from commit 36338a315218221e51c24a42e44c4f743d416f82)\nMerged-In: Ibbfd0891eabdce72f76571798382fe949d8f453d",
  "files": [
   {
    "filename": "ShortcutPackage.java",
    "diff": "@@ -1967,10 +1967,15 @@ class ShortcutPackage extends ShortcutPackageItem {\n \n                         continue;\n                     case TAG_SHORTCUT:\n-                        final ShortcutInfo si = parseShortcut(parser, packageName,\n-                                shortcutUser.getUserId(), fromBackup);\n-                        // Don't use addShortcut(), we don't need to save the icon.\n-                        ret.mShortcuts.put(si.getId(), si);\n+                        try {\n+                            final ShortcutInfo si = parseShortcut(parser, packageName,\n+                                    shortcutUser.getUserId(), fromBackup);\n+                            // Don't use addShortcut(), we don't need to save the icon.\n+                            ret.mShortcuts.put(si.getId(), si);\n+                        } catch (Exception e) {\n+                            // b/246540168 malformed shortcuts should be ignored\n+                            Slog.e(TAG, \"Failed parsing shortcut.\", e);\n+                        }\n                         continue;\n                     case TAG_SHARE_TARGET:\n                         ret.mShareTargets.add(ShareTargetInfo.loadFromXml(parser));\n",
    "added_lines": 9,
    "deleted_lines": 4,
    "changed_methods": "ShortcutPackage::loadFromXml"
   }
  ]
 },
 {
  "hash": "2d54a3bf75eae8280ffa37e6435d9dcdffcbc6a2",
  "commit": "Lower per-app notificationchannel limit\n\nTest: PreferencesHelperTest\nBug: 240422263\nChange-Id: I8c12e3fc73e4a88842af275feaf2acffcced0402\n(cherry picked from commit f528b337dd48b7e8071269e07e610bd4a3668c75)\nMerged-In: I8c12e3fc73e4a88842af275feaf2acffcced0402\n(cherry picked from commit 36acdd675890296151b7a99e05fa7436d59a289b)\nMerged-In: I8c12e3fc73e4a88842af275feaf2acffcced0402",
  "files": [
   {
    "filename": "PreferencesHelper.java",
    "diff": "@@ -97,7 +97,7 @@ public class PreferencesHelper implements RankingConfig {\n     private static final String NON_BLOCKABLE_CHANNEL_DELIM = \":\";\n \n     @VisibleForTesting\n-    static final int NOTIFICATION_CHANNEL_COUNT_LIMIT = 50000;\n+    static final int NOTIFICATION_CHANNEL_COUNT_LIMIT = 5000;\n \n     private static final int NOTIFICATION_PREFERENCES_PULL_LIMIT = 1000;\n     private static final int NOTIFICATION_CHANNEL_PULL_LIMIT = 2000;\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": ""
   }
  ]
 },
 {
  "hash": "1aa63338540fb0ada2b87ae7bbcdecd5d8bc08fc",
  "commit": "[DO NOT MERGE] Fix permanent denial of service via setComponentEnabledSetting\n\nDo not update invalid component enabled settings to prevent the\nmalicious apps from exhausting system server memory.\n\nBug: 240936919\nTest: atest android.security.cts.PackageManagerTest\nChange-Id: I08165337895e89f13a2b9fcce1201cba9ad13d7d\n(cherry picked from commit 24473590373902db492de502c7c557ef5ead485f)\nMerged-In: I08165337895e89f13a2b9fcce1201cba9ad13d7d",
  "files": [
   {
    "filename": "PackageManagerService.java",
    "diff": "@@ -24250,6 +24250,9 @@ public class PackageManagerService extends IPackageManager.Stub\n                     } else {\n                         Slog.w(TAG, \"Failed setComponentEnabledSetting: component class \"\n                                 + className + \" does not exist in \" + packageName);\n+                        // Safetynet logging for b/240936919\n+                        EventLog.writeEvent(0x534e4554, \"240936919\", callingUid);\n+                        return;\n                     }\n                 }\n                 switch (newState) {\n",
    "added_lines": 3,
    "deleted_lines": 0,
    "changed_methods": "PackageManagerService::setEnabledSetting"
   }
  ]
 },
 {
  "hash": "8565487dae2587227a32526de58b4b2898100bbe",
  "commit": "Add safety checks on KEY_INTENT mismatch.\n\nFor many years, Parcel mismatch typed exploits has been using the\nAccoungManagerService's passing of KEY_INTENT workflow, as a foothold of\nlaunching arbitrary intents. We are adding an extra check on the service\nside to simulate the final deserialization of the KEY_INTENT value, to\nmake sure the client side won't get a mismatched KEY_INTENT value.\n\nBug: 250588548\nBug: 240138294\nTest: atest CtsAccountManagerTestCases\nTest: local test, also see b/250588548\nChange-Id: I433e34f6e21ce15c89825044a15b1dec46bb25cc\n(cherry picked from commit eb9a0566a583fa13f8aff671c41f78a9e33eab82)\nMerged-In: I433e34f6e21ce15c89825044a15b1dec46bb25cc",
  "files": [
   {
    "filename": "AccountManagerService.java",
    "diff": "@@ -88,6 +88,7 @@ import android.os.UserHandle;\n import android.os.UserManager;\n import android.stats.devicepolicy.DevicePolicyEnums;\n import android.text.TextUtils;\n+import android.util.EventLog;\n import android.util.Log;\n import android.util.Pair;\n import android.util.Slog;\n@@ -3097,7 +3098,7 @@ public class AccountManagerService\n                              */\n                             if (!checkKeyIntent(\n                                     Binder.getCallingUid(),\n-                                    intent)) {\n+                                    result)) {\n                                 onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                                         \"invalid intent in bundle returned\");\n                                 return;\n@@ -3516,7 +3517,7 @@ public class AccountManagerService\n                     && (intent = result.getParcelable(AccountManager.KEY_INTENT)) != null) {\n                 if (!checkKeyIntent(\n                         Binder.getCallingUid(),\n-                        intent)) {\n+                        result)) {\n                     onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                             \"invalid intent in bundle returned\");\n                     return;\n@@ -4867,7 +4868,13 @@ public class AccountManagerService\n          * into launching arbitrary intents on the device via by tricking to click authenticator\n          * supplied entries in the system Settings app.\n          */\n-         protected boolean checkKeyIntent(int authUid, Intent intent) {\n+        protected boolean checkKeyIntent(int authUid, Bundle bundle) {\n+            if (!checkKeyIntentParceledCorrectly(bundle)) {\n+            \tEventLog.writeEvent(0x534e4554, \"250588548\", authUid, \"\");\n+                return false;\n+            }\n+\n+            Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT);\n             // Explicitly set an empty ClipData to ensure that we don't offer to\n             // promote any Uris contained inside for granting purposes\n             if (intent.getClipData() == null) {\n@@ -4904,6 +4911,25 @@ public class AccountManagerService\n             }\n         }\n \n+        /**\n+         * Simulate the client side's deserialization of KEY_INTENT value, to make sure they don't\n+         * violate our security policy.\n+         *\n+         * In particular we want to make sure the Authenticator doesn't trick users\n+         * into launching arbitrary intents on the device via exploiting any other Parcel read/write\n+         * mismatch problems.\n+         */\n+        private boolean checkKeyIntentParceledCorrectly(Bundle bundle) {\n+            Parcel p = Parcel.obtain();\n+            p.writeBundle(bundle);\n+            p.setDataPosition(0);\n+            Bundle simulateBundle = p.readBundle();\n+            p.recycle();\n+            Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT);\n+            Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT);\n+            return (intent.filterEquals(simulateIntent));\n+        }\n+\n         private boolean isExportedSystemActivity(ActivityInfo activityInfo) {\n             String className = activityInfo.name;\n             return \"android\".equals(activityInfo.packageName) &&\n@@ -5050,7 +5076,7 @@ public class AccountManagerService\n                     && (intent = result.getParcelable(AccountManager.KEY_INTENT)) != null) {\n                 if (!checkKeyIntent(\n                         Binder.getCallingUid(),\n-                        intent)) {\n+                        result)) {\n                     onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                             \"invalid intent in bundle returned\");\n                     return;\n",
    "added_lines": 30,
    "deleted_lines": 4,
    "changed_methods": "AccountManagerService::Session::checkKeyIntent, AccountManagerService::Session::checkKeyIntent, AccountManagerService::Session::checkKeyIntentParceledCorrectly, AccountManagerService::getAuthToken, AccountManagerService::StartAccountSession::onResult, AccountManagerService::Session::onResult"
   }
  ]
 },
 {
  "hash": "1c5e4928dcfb254c0204f78c60ecfe6b219a852d",
  "commit": "Validate package name passed to setApplicationRestrictions.\n\nThis adds validation that the package name passed to\nsetApplicationRestrictions is in the correct format. This will avoid\nan issue where a path could be entered resulting in a file being\nwritten to an unexpected place.\n\nBug: 239701237\nTest: atest UserManagerServiceTest\nChange-Id: I1ab2b7228470f10ec26fe3a608ae540cfc9e9a96\n(cherry picked from commit 31a582490d6e8952d24f267df47d669e3861cf67)\nMerged-In: I1ab2b7228470f10ec26fe3a608ae540cfc9e9a96\n(cherry picked from commit cfcfe6ca8c545f78603c05e23687f8638fd4b51d)\n(cherry picked from commit 91a821d2e4d80558cf39a6d728213d3df0826908)\nMerged-In: I1ab2b7228470f10ec26fe3a608ae540cfc9e9a96",
  "files": [
   {
    "filename": "UserManagerService.java",
    "diff": "@@ -88,6 +88,7 @@ import android.stats.devicepolicy.DevicePolicyEnums;\n import android.util.ArrayMap;\n import android.util.ArraySet;\n import android.util.AtomicFile;\n+import android.util.EventLog;\n import android.util.IndentingPrintWriter;\n import android.util.IntArray;\n import android.util.Slog;\n@@ -4499,6 +4500,13 @@ public class UserManagerService extends IUserManager.Stub {\n     public void setApplicationRestrictions(String packageName, Bundle restrictions,\n             @UserIdInt int userId) {\n         checkSystemOrRoot(\"set application restrictions\");\n+        String validationResult = validateName(packageName);\n+        if (validationResult != null) {\n+            if (packageName.contains(\"../\")) {\n+                EventLog.writeEvent(0x534e4554, \"239701237\", -1, \"\");\n+            }\n+            throw new IllegalArgumentException(\"Invalid package name: \" + validationResult);\n+        }\n         if (restrictions != null) {\n             restrictions.setDefusable(true);\n         }\n@@ -4525,6 +4533,39 @@ public class UserManagerService extends IUserManager.Stub {\n         mContext.sendBroadcastAsUser(changeIntent, UserHandle.of(userId));\n     }\n \n+    /**\n+     * Check if the given name is valid.\n+     *\n+     * Note: the logic is taken from FrameworkParsingPackageUtils in master, edited to remove\n+     * unnecessary parts. Copied here for a security fix.\n+     *\n+     * @param name The name to check.\n+     * @return null if it's valid, error message if not\n+     */\n+    @VisibleForTesting\n+    static String validateName(String name) {\n+        final int n = name.length();\n+        boolean front = true;\n+        for (int i = 0; i < n; i++) {\n+            final char c = name.charAt(i);\n+            if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) {\n+                front = false;\n+                continue;\n+            }\n+            if (!front) {\n+                if ((c >= '0' && c <= '9') || c == '_') {\n+                    continue;\n+                }\n+                if (c == '.') {\n+                    front = true;\n+                    continue;\n+                }\n+            }\n+            return \"bad character '\" + c + \"'\";\n+        }\n+        return null;\n+    }\n+\n     private int getUidForPackage(String packageName) {\n         final long ident = Binder.clearCallingIdentity();\n         try {\n",
    "added_lines": 41,
    "deleted_lines": 0,
    "changed_methods": "UserManagerService::setApplicationRestrictions, UserManagerService::validateName"
   },
   {
    "filename": "UserManagerServiceTest.java",
    "diff": "@@ -86,6 +86,13 @@ public class UserManagerServiceTest extends AndroidTestCase {\n         }\n     }\n \n+    public void testValidateName() {\n+        assertNull(UserManagerService.validateName(\"android\"));\n+        assertNull(UserManagerService.validateName(\"com.company.myapp\"));\n+        assertNotNull(UserManagerService.validateName(\"/../../data\"));\n+        assertNotNull(UserManagerService.validateName(\"/dir\"));\n+    }\n+\n     private Bundle createBundle() {\n         Bundle result = new Bundle();\n         // Tests for 6 allowed types: Integer, Boolean, String, String[], Bundle and Parcelable[]\n",
    "added_lines": 7,
    "deleted_lines": 0,
    "changed_methods": "UserManagerServiceTest::testValidateName"
   }
  ]
 },
 {
  "hash": "1c5e4928dcfb254c0204f78c60ecfe6b219a852d",
  "commit": "Validate package name passed to setApplicationRestrictions.\n\nThis adds validation that the package name passed to\nsetApplicationRestrictions is in the correct format. This will avoid\nan issue where a path could be entered resulting in a file being\nwritten to an unexpected place.\n\nBug: 239701237\nTest: atest UserManagerServiceTest\nChange-Id: I1ab2b7228470f10ec26fe3a608ae540cfc9e9a96\n(cherry picked from commit 31a582490d6e8952d24f267df47d669e3861cf67)\nMerged-In: I1ab2b7228470f10ec26fe3a608ae540cfc9e9a96\n(cherry picked from commit cfcfe6ca8c545f78603c05e23687f8638fd4b51d)\n(cherry picked from commit 91a821d2e4d80558cf39a6d728213d3df0826908)\nMerged-In: I1ab2b7228470f10ec26fe3a608ae540cfc9e9a96",
  "files": [
   {
    "filename": "UserManagerService.java",
    "diff": "@@ -88,6 +88,7 @@ import android.stats.devicepolicy.DevicePolicyEnums;\n import android.util.ArrayMap;\n import android.util.ArraySet;\n import android.util.AtomicFile;\n+import android.util.EventLog;\n import android.util.IndentingPrintWriter;\n import android.util.IntArray;\n import android.util.Slog;\n@@ -4499,6 +4500,13 @@ public class UserManagerService extends IUserManager.Stub {\n     public void setApplicationRestrictions(String packageName, Bundle restrictions,\n             @UserIdInt int userId) {\n         checkSystemOrRoot(\"set application restrictions\");\n+        String validationResult = validateName(packageName);\n+        if (validationResult != null) {\n+            if (packageName.contains(\"../\")) {\n+                EventLog.writeEvent(0x534e4554, \"239701237\", -1, \"\");\n+            }\n+            throw new IllegalArgumentException(\"Invalid package name: \" + validationResult);\n+        }\n         if (restrictions != null) {\n             restrictions.setDefusable(true);\n         }\n@@ -4525,6 +4533,39 @@ public class UserManagerService extends IUserManager.Stub {\n         mContext.sendBroadcastAsUser(changeIntent, UserHandle.of(userId));\n     }\n \n+    /**\n+     * Check if the given name is valid.\n+     *\n+     * Note: the logic is taken from FrameworkParsingPackageUtils in master, edited to remove\n+     * unnecessary parts. Copied here for a security fix.\n+     *\n+     * @param name The name to check.\n+     * @return null if it's valid, error message if not\n+     */\n+    @VisibleForTesting\n+    static String validateName(String name) {\n+        final int n = name.length();\n+        boolean front = true;\n+        for (int i = 0; i < n; i++) {\n+            final char c = name.charAt(i);\n+            if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) {\n+                front = false;\n+                continue;\n+            }\n+            if (!front) {\n+                if ((c >= '0' && c <= '9') || c == '_') {\n+                    continue;\n+                }\n+                if (c == '.') {\n+                    front = true;\n+                    continue;\n+                }\n+            }\n+            return \"bad character '\" + c + \"'\";\n+        }\n+        return null;\n+    }\n+\n     private int getUidForPackage(String packageName) {\n         final long ident = Binder.clearCallingIdentity();\n         try {\n",
    "added_lines": 41,
    "deleted_lines": 0,
    "changed_methods": "UserManagerService::setApplicationRestrictions, UserManagerService::validateName"
   },
   {
    "filename": "UserManagerServiceTest.java",
    "diff": "@@ -86,6 +86,13 @@ public class UserManagerServiceTest extends AndroidTestCase {\n         }\n     }\n \n+    public void testValidateName() {\n+        assertNull(UserManagerService.validateName(\"android\"));\n+        assertNull(UserManagerService.validateName(\"com.company.myapp\"));\n+        assertNotNull(UserManagerService.validateName(\"/../../data\"));\n+        assertNotNull(UserManagerService.validateName(\"/dir\"));\n+    }\n+\n     private Bundle createBundle() {\n         Bundle result = new Bundle();\n         // Tests for 6 allowed types: Integer, Boolean, String, String[], Bundle and Parcelable[]\n",
    "added_lines": 7,
    "deleted_lines": 0,
    "changed_methods": "UserManagerServiceTest::testValidateName"
   }
  ]
 },
 {
  "hash": "1832677b9a1dfd01c424b6d9090b6cf6183652b5",
  "commit": "[DO NOT MERGE] Revert \"Fix system zen rules by using owner package name if caller is system\"\n\nThis reverts commit 78245566a27882cce59c0d7cd4c60e1604392a3f.\n\nReason for revert: broke DND schedules in multi-user mode b/257477671\n\nChange-Id: I8a244a6ad0457ef2679b5216f48611d4025b9983\n(cherry picked from commit 7deb6e4565789dafcdcafea7107d03662a5ee86c)\nMerged-In: I8a244a6ad0457ef2679b5216f48611d4025b9983",
  "files": [
   {
    "filename": "NotificationManagerService.java",
    "diff": "@@ -4812,16 +4812,7 @@ public class NotificationManagerService extends SystemService {\n             }\n             enforcePolicyAccess(Binder.getCallingUid(), \"addAutomaticZenRule\");\n \n-            // If the caller is system, take the package name from the rule's owner rather than\n-            // from the caller's package.\n-            String rulePkg = pkg;\n-            if (isCallingUidSystem()) {\n-                if (automaticZenRule.getOwner() != null) {\n-                    rulePkg = automaticZenRule.getOwner().getPackageName();\n-                }\n-            }\n-\n-            return mZenModeHelper.addAutomaticZenRule(rulePkg, automaticZenRule,\n+            return mZenModeHelper.addAutomaticZenRule(pkg, automaticZenRule,\n                     \"addAutomaticZenRule\");\n         }\n \n",
    "added_lines": 1,
    "deleted_lines": 10,
    "changed_methods": "NotificationManagerService::Stub"
   },
   {
    "filename": "NotificationManagerServiceTest.java",
    "diff": "@@ -6748,43 +6748,6 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n         mBinderService.addAutomaticZenRule(rule, mContext.getPackageName());\n     }\n \n-    @Test\n-    public void testAddAutomaticZenRule_systemCallTakesPackageFromOwner() throws Exception {\n-        mService.isSystemUid = true;\n-        ZenModeHelper mockZenModeHelper = mock(ZenModeHelper.class);\n-        when(mConditionProviders.isPackageOrComponentAllowed(anyString(), anyInt()))\n-                .thenReturn(true);\n-        mService.setZenHelper(mockZenModeHelper);\n-        ComponentName owner = new ComponentName(\"android\", \"ProviderName\");\n-        ZenPolicy zenPolicy = new ZenPolicy.Builder().allowAlarms(true).build();\n-        boolean isEnabled = true;\n-        AutomaticZenRule rule = new AutomaticZenRule(\"test\", owner, owner, mock(Uri.class),\n-                zenPolicy, NotificationManager.INTERRUPTION_FILTER_PRIORITY, isEnabled);\n-        mBinderService.addAutomaticZenRule(rule, \"com.android.settings\");\n-\n-        // verify that zen mode helper gets passed in a package name of \"android\"\n-        verify(mockZenModeHelper).addAutomaticZenRule(eq(\"android\"), eq(rule), anyString());\n-    }\n-\n-    @Test\n-    public void testAddAutomaticZenRule_nonSystemCallTakesPackageFromArg() throws Exception {\n-        mService.isSystemUid = false;\n-        ZenModeHelper mockZenModeHelper = mock(ZenModeHelper.class);\n-        when(mConditionProviders.isPackageOrComponentAllowed(anyString(), anyInt()))\n-                .thenReturn(true);\n-        mService.setZenHelper(mockZenModeHelper);\n-        ComponentName owner = new ComponentName(\"android\", \"ProviderName\");\n-        ZenPolicy zenPolicy = new ZenPolicy.Builder().allowAlarms(true).build();\n-        boolean isEnabled = true;\n-        AutomaticZenRule rule = new AutomaticZenRule(\"test\", owner, owner, mock(Uri.class),\n-                zenPolicy, NotificationManager.INTERRUPTION_FILTER_PRIORITY, isEnabled);\n-        mBinderService.addAutomaticZenRule(rule, \"another.package\");\n-\n-        // verify that zen mode helper gets passed in the package name from the arg, not the owner\n-        verify(mockZenModeHelper).addAutomaticZenRule(\n-                eq(\"another.package\"), eq(rule), anyString());\n-    }\n-\n     @Test\n     public void testAreNotificationsEnabledForPackage_crossUser() throws Exception {\n         try {\n",
    "added_lines": 0,
    "deleted_lines": 37,
    "changed_methods": "NotificationManagerServiceTest::testAddAutomaticZenRule_nonSystemCallTakesPackageFromArg, NotificationManagerServiceTest::testAddAutomaticZenRule_systemCallTakesPackageFromOwner"
   }
  ]
 },
 {
  "hash": "1832677b9a1dfd01c424b6d9090b6cf6183652b5",
  "commit": "[DO NOT MERGE] Revert \"Fix system zen rules by using owner package name if caller is system\"\n\nThis reverts commit 78245566a27882cce59c0d7cd4c60e1604392a3f.\n\nReason for revert: broke DND schedules in multi-user mode b/257477671\n\nChange-Id: I8a244a6ad0457ef2679b5216f48611d4025b9983\n(cherry picked from commit 7deb6e4565789dafcdcafea7107d03662a5ee86c)\nMerged-In: I8a244a6ad0457ef2679b5216f48611d4025b9983",
  "files": [
   {
    "filename": "NotificationManagerService.java",
    "diff": "@@ -4812,16 +4812,7 @@ public class NotificationManagerService extends SystemService {\n             }\n             enforcePolicyAccess(Binder.getCallingUid(), \"addAutomaticZenRule\");\n \n-            // If the caller is system, take the package name from the rule's owner rather than\n-            // from the caller's package.\n-            String rulePkg = pkg;\n-            if (isCallingUidSystem()) {\n-                if (automaticZenRule.getOwner() != null) {\n-                    rulePkg = automaticZenRule.getOwner().getPackageName();\n-                }\n-            }\n-\n-            return mZenModeHelper.addAutomaticZenRule(rulePkg, automaticZenRule,\n+            return mZenModeHelper.addAutomaticZenRule(pkg, automaticZenRule,\n                     \"addAutomaticZenRule\");\n         }\n \n",
    "added_lines": 1,
    "deleted_lines": 10,
    "changed_methods": "NotificationManagerService::Stub"
   },
   {
    "filename": "NotificationManagerServiceTest.java",
    "diff": "@@ -6748,43 +6748,6 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n         mBinderService.addAutomaticZenRule(rule, mContext.getPackageName());\n     }\n \n-    @Test\n-    public void testAddAutomaticZenRule_systemCallTakesPackageFromOwner() throws Exception {\n-        mService.isSystemUid = true;\n-        ZenModeHelper mockZenModeHelper = mock(ZenModeHelper.class);\n-        when(mConditionProviders.isPackageOrComponentAllowed(anyString(), anyInt()))\n-                .thenReturn(true);\n-        mService.setZenHelper(mockZenModeHelper);\n-        ComponentName owner = new ComponentName(\"android\", \"ProviderName\");\n-        ZenPolicy zenPolicy = new ZenPolicy.Builder().allowAlarms(true).build();\n-        boolean isEnabled = true;\n-        AutomaticZenRule rule = new AutomaticZenRule(\"test\", owner, owner, mock(Uri.class),\n-                zenPolicy, NotificationManager.INTERRUPTION_FILTER_PRIORITY, isEnabled);\n-        mBinderService.addAutomaticZenRule(rule, \"com.android.settings\");\n-\n-        // verify that zen mode helper gets passed in a package name of \"android\"\n-        verify(mockZenModeHelper).addAutomaticZenRule(eq(\"android\"), eq(rule), anyString());\n-    }\n-\n-    @Test\n-    public void testAddAutomaticZenRule_nonSystemCallTakesPackageFromArg() throws Exception {\n-        mService.isSystemUid = false;\n-        ZenModeHelper mockZenModeHelper = mock(ZenModeHelper.class);\n-        when(mConditionProviders.isPackageOrComponentAllowed(anyString(), anyInt()))\n-                .thenReturn(true);\n-        mService.setZenHelper(mockZenModeHelper);\n-        ComponentName owner = new ComponentName(\"android\", \"ProviderName\");\n-        ZenPolicy zenPolicy = new ZenPolicy.Builder().allowAlarms(true).build();\n-        boolean isEnabled = true;\n-        AutomaticZenRule rule = new AutomaticZenRule(\"test\", owner, owner, mock(Uri.class),\n-                zenPolicy, NotificationManager.INTERRUPTION_FILTER_PRIORITY, isEnabled);\n-        mBinderService.addAutomaticZenRule(rule, \"another.package\");\n-\n-        // verify that zen mode helper gets passed in the package name from the arg, not the owner\n-        verify(mockZenModeHelper).addAutomaticZenRule(\n-                eq(\"another.package\"), eq(rule), anyString());\n-    }\n-\n     @Test\n     public void testAreNotificationsEnabledForPackage_crossUser() throws Exception {\n         try {\n",
    "added_lines": 0,
    "deleted_lines": 37,
    "changed_methods": "NotificationManagerServiceTest::testAddAutomaticZenRule_nonSystemCallTakesPackageFromArg, NotificationManagerServiceTest::testAddAutomaticZenRule_systemCallTakesPackageFromOwner"
   }
  ]
 },
 {
  "hash": "44fa57d2ebaa9ae4c41f94d9889115671dc82438",
  "commit": "[DO NOT MERGE] Revert \"Check rule package name in ZenModeHelper.addAutomaticRule\"\n\nThis reverts commit 59732d6232d7d82d03897b25be0381c3c510db9b.\n\nReason for revert: broke DND schedules in multi-user mode b/257477671\n\nChange-Id: I33dd64f8686e60db332361b6cde2955c33cff8d0\n(cherry picked from commit 3bba7fb1844c7d550b4b4a3665b641cffa1713fb)\nMerged-In: I33dd64f8686e60db332361b6cde2955c33cff8d0",
  "files": [
   {
    "filename": "ZenModeHelper.java",
    "diff": "@@ -310,7 +310,7 @@ public class ZenModeHelper {\n \n     public String addAutomaticZenRule(String pkg, AutomaticZenRule automaticZenRule,\n             String reason) {\n-        if (!ZenModeConfig.SYSTEM_AUTHORITY.equals(pkg)) {\n+        if (!isSystemRule(automaticZenRule)) {\n             PackageItemInfo component = getServiceInfo(automaticZenRule.getOwner());\n             if (component == null) {\n                 component = getActivityInfo(automaticZenRule.getConfigurationActivity());\n@@ -566,6 +566,11 @@ public class ZenModeHelper {\n         }\n     }\n \n+    private boolean isSystemRule(AutomaticZenRule rule) {\n+        return rule.getOwner() != null\n+                && ZenModeConfig.SYSTEM_AUTHORITY.equals(rule.getOwner().getPackageName());\n+    }\n+\n     private ServiceInfo getServiceInfo(ComponentName owner) {\n         Intent queryIntent = new Intent();\n         queryIntent.setComponent(owner);\n",
    "added_lines": 6,
    "deleted_lines": 1,
    "changed_methods": "ZenModeHelper::isSystemRule, ZenModeHelper::addAutomaticZenRule"
   },
   {
    "filename": "ZenModeHelperTest.java",
    "diff": "@@ -1667,36 +1667,6 @@ public class ZenModeHelperTest extends UiServiceTestCase {\n         }\n     }\n \n-    @Test\n-    public void testAddAutomaticZenRule_claimedSystemOwner() {\n-        // Make sure anything that claims to have a \"system\" owner but not actually part of the\n-        // system package still gets limited on number of rules\n-        for (int i = 0; i < RULE_LIMIT_PER_PACKAGE; i++) {\n-            ScheduleInfo si = new ScheduleInfo();\n-            si.startHour = i;\n-            AutomaticZenRule zenRule = new AutomaticZenRule(\"name\" + i,\n-                    new ComponentName(\"android\", \"ScheduleConditionProvider\" + i),\n-                    null, // configuration activity\n-                    ZenModeConfig.toScheduleConditionId(si),\n-                    new ZenPolicy.Builder().build(),\n-                    NotificationManager.INTERRUPTION_FILTER_PRIORITY, true);\n-            String id = mZenModeHelperSpy.addAutomaticZenRule(\"pkgname\", zenRule, \"test\");\n-            assertNotNull(id);\n-        }\n-        try {\n-            AutomaticZenRule zenRule = new AutomaticZenRule(\"name\",\n-                    new ComponentName(\"android\", \"ScheduleConditionProviderFinal\"),\n-                    null, // configuration activity\n-                    ZenModeConfig.toScheduleConditionId(new ScheduleInfo()),\n-                    new ZenPolicy.Builder().build(),\n-                    NotificationManager.INTERRUPTION_FILTER_PRIORITY, true);\n-            String id = mZenModeHelperSpy.addAutomaticZenRule(\"pkgname\", zenRule, \"test\");\n-            fail(\"allowed too many rules to be created\");\n-        } catch (IllegalArgumentException e) {\n-            // yay\n-        }\n-    }\n-\n     @Test\n     public void testAddAutomaticZenRule_CA() {\n         AutomaticZenRule zenRule = new AutomaticZenRule(\"name\",\n",
    "added_lines": 0,
    "deleted_lines": 30,
    "changed_methods": "ZenModeHelperTest::testAddAutomaticZenRule_claimedSystemOwner"
   }
  ]
 },
 {
  "hash": "44fa57d2ebaa9ae4c41f94d9889115671dc82438",
  "commit": "[DO NOT MERGE] Revert \"Check rule package name in ZenModeHelper.addAutomaticRule\"\n\nThis reverts commit 59732d6232d7d82d03897b25be0381c3c510db9b.\n\nReason for revert: broke DND schedules in multi-user mode b/257477671\n\nChange-Id: I33dd64f8686e60db332361b6cde2955c33cff8d0\n(cherry picked from commit 3bba7fb1844c7d550b4b4a3665b641cffa1713fb)\nMerged-In: I33dd64f8686e60db332361b6cde2955c33cff8d0",
  "files": [
   {
    "filename": "ZenModeHelper.java",
    "diff": "@@ -310,7 +310,7 @@ public class ZenModeHelper {\n \n     public String addAutomaticZenRule(String pkg, AutomaticZenRule automaticZenRule,\n             String reason) {\n-        if (!ZenModeConfig.SYSTEM_AUTHORITY.equals(pkg)) {\n+        if (!isSystemRule(automaticZenRule)) {\n             PackageItemInfo component = getServiceInfo(automaticZenRule.getOwner());\n             if (component == null) {\n                 component = getActivityInfo(automaticZenRule.getConfigurationActivity());\n@@ -566,6 +566,11 @@ public class ZenModeHelper {\n         }\n     }\n \n+    private boolean isSystemRule(AutomaticZenRule rule) {\n+        return rule.getOwner() != null\n+                && ZenModeConfig.SYSTEM_AUTHORITY.equals(rule.getOwner().getPackageName());\n+    }\n+\n     private ServiceInfo getServiceInfo(ComponentName owner) {\n         Intent queryIntent = new Intent();\n         queryIntent.setComponent(owner);\n",
    "added_lines": 6,
    "deleted_lines": 1,
    "changed_methods": "ZenModeHelper::isSystemRule, ZenModeHelper::addAutomaticZenRule"
   },
   {
    "filename": "ZenModeHelperTest.java",
    "diff": "@@ -1667,36 +1667,6 @@ public class ZenModeHelperTest extends UiServiceTestCase {\n         }\n     }\n \n-    @Test\n-    public void testAddAutomaticZenRule_claimedSystemOwner() {\n-        // Make sure anything that claims to have a \"system\" owner but not actually part of the\n-        // system package still gets limited on number of rules\n-        for (int i = 0; i < RULE_LIMIT_PER_PACKAGE; i++) {\n-            ScheduleInfo si = new ScheduleInfo();\n-            si.startHour = i;\n-            AutomaticZenRule zenRule = new AutomaticZenRule(\"name\" + i,\n-                    new ComponentName(\"android\", \"ScheduleConditionProvider\" + i),\n-                    null, // configuration activity\n-                    ZenModeConfig.toScheduleConditionId(si),\n-                    new ZenPolicy.Builder().build(),\n-                    NotificationManager.INTERRUPTION_FILTER_PRIORITY, true);\n-            String id = mZenModeHelperSpy.addAutomaticZenRule(\"pkgname\", zenRule, \"test\");\n-            assertNotNull(id);\n-        }\n-        try {\n-            AutomaticZenRule zenRule = new AutomaticZenRule(\"name\",\n-                    new ComponentName(\"android\", \"ScheduleConditionProviderFinal\"),\n-                    null, // configuration activity\n-                    ZenModeConfig.toScheduleConditionId(new ScheduleInfo()),\n-                    new ZenPolicy.Builder().build(),\n-                    NotificationManager.INTERRUPTION_FILTER_PRIORITY, true);\n-            String id = mZenModeHelperSpy.addAutomaticZenRule(\"pkgname\", zenRule, \"test\");\n-            fail(\"allowed too many rules to be created\");\n-        } catch (IllegalArgumentException e) {\n-            // yay\n-        }\n-    }\n-\n     @Test\n     public void testAddAutomaticZenRule_CA() {\n         AutomaticZenRule zenRule = new AutomaticZenRule(\"name\",\n",
    "added_lines": 0,
    "deleted_lines": 30,
    "changed_methods": "ZenModeHelperTest::testAddAutomaticZenRule_claimedSystemOwner"
   }
  ]
 },
 {
  "hash": "2a05a951ba34fa2b690a676dcd5744716c27499c",
  "commit": "Limit length and number of MIME types you can set\n\nLimit character length of MIME types to 255. If this length is exceeded\nthen a IllegalArugmentException is thrown. The number of MIME types that\ncan be set is also limited to 500 per MIME group with the number of\ntotal MIME Groups also limited to 500. A IllegalStateException is thrown if this number is exceeded.\n\nBug: 237291548\nTest: Installed and ran POC app from b/237291548\nChange-Id: I1d57e674f778cfacdc89225ac3273c432a39af63\nMerged-In: I1d57e674f778cfacdc89225ac3273c432a39af63\n(cherry picked from commit 3ae3406b9706163073c282a8c4081faa32b606b2)\nMerged-In: I1d57e674f778cfacdc89225ac3273c432a39af63",
  "files": [
   {
    "filename": "ParsingPackageImpl.java",
    "diff": "@@ -1695,6 +1695,9 @@ public class ParsingPackageImpl implements ParsingPackage, Parcelable {\n         for (int i = component.getIntents().size() - 1; i >= 0; i--) {\n             IntentFilter filter = component.getIntents().get(i);\n             for (int groupIndex = filter.countMimeGroups() - 1; groupIndex >= 0; groupIndex--) {\n+                if (mimeGroups != null && mimeGroups.size() > 500) {\n+                    throw new IllegalStateException(\"Max limit on number of MIME Groups reached\");\n+                }\n                 mimeGroups = ArrayUtils.add(mimeGroups, filter.getMimeGroup(groupIndex));\n             }\n         }\n",
    "added_lines": 3,
    "deleted_lines": 0,
    "changed_methods": "ParsingPackageImpl::addMimeGroupsFromComponent"
   },
   {
    "filename": "PackageSetting.java",
    "diff": "@@ -328,11 +328,20 @@ public class PackageSetting extends PackageSettingBase {\n     }\n \n     public boolean setMimeGroup(String mimeGroup, List<String> mimeTypes) {\n+        for (String mimeType : mimeTypes) {\n+            if (mimeType.length() > 255) {\n+                throw new IllegalArgumentException(\"MIME type length exceeds 255 characters\");\n+            }\n+        }\n         ArraySet<String> oldMimeTypes = getMimeGroupInternal(mimeGroup);\n         if (oldMimeTypes == null) {\n             throw new IllegalArgumentException(\"Unknown MIME group \" + mimeGroup\n                     + \" for package \" + name);\n         }\n+        if (mimeTypes.size() > 500) {\n+            throw new IllegalStateException(\"Max limit on MIME types for MIME group \"\n+                    + mimeGroup + \" exceeded for package \" + name);\n+        }\n \n         ArraySet<String> newMimeTypes = new ArraySet<>(mimeTypes);\n         boolean hasChanges = !newMimeTypes.equals(oldMimeTypes);\n",
    "added_lines": 9,
    "deleted_lines": 0,
    "changed_methods": "PackageSetting::setMimeGroup"
   }
  ]
 },
 {
  "hash": "2a05a951ba34fa2b690a676dcd5744716c27499c",
  "commit": "Limit length and number of MIME types you can set\n\nLimit character length of MIME types to 255. If this length is exceeded\nthen a IllegalArugmentException is thrown. The number of MIME types that\ncan be set is also limited to 500 per MIME group with the number of\ntotal MIME Groups also limited to 500. A IllegalStateException is thrown if this number is exceeded.\n\nBug: 237291548\nTest: Installed and ran POC app from b/237291548\nChange-Id: I1d57e674f778cfacdc89225ac3273c432a39af63\nMerged-In: I1d57e674f778cfacdc89225ac3273c432a39af63\n(cherry picked from commit 3ae3406b9706163073c282a8c4081faa32b606b2)\nMerged-In: I1d57e674f778cfacdc89225ac3273c432a39af63",
  "files": [
   {
    "filename": "ParsingPackageImpl.java",
    "diff": "@@ -1695,6 +1695,9 @@ public class ParsingPackageImpl implements ParsingPackage, Parcelable {\n         for (int i = component.getIntents().size() - 1; i >= 0; i--) {\n             IntentFilter filter = component.getIntents().get(i);\n             for (int groupIndex = filter.countMimeGroups() - 1; groupIndex >= 0; groupIndex--) {\n+                if (mimeGroups != null && mimeGroups.size() > 500) {\n+                    throw new IllegalStateException(\"Max limit on number of MIME Groups reached\");\n+                }\n                 mimeGroups = ArrayUtils.add(mimeGroups, filter.getMimeGroup(groupIndex));\n             }\n         }\n",
    "added_lines": 3,
    "deleted_lines": 0,
    "changed_methods": "ParsingPackageImpl::addMimeGroupsFromComponent"
   },
   {
    "filename": "PackageSetting.java",
    "diff": "@@ -328,11 +328,20 @@ public class PackageSetting extends PackageSettingBase {\n     }\n \n     public boolean setMimeGroup(String mimeGroup, List<String> mimeTypes) {\n+        for (String mimeType : mimeTypes) {\n+            if (mimeType.length() > 255) {\n+                throw new IllegalArgumentException(\"MIME type length exceeds 255 characters\");\n+            }\n+        }\n         ArraySet<String> oldMimeTypes = getMimeGroupInternal(mimeGroup);\n         if (oldMimeTypes == null) {\n             throw new IllegalArgumentException(\"Unknown MIME group \" + mimeGroup\n                     + \" for package \" + name);\n         }\n+        if (mimeTypes.size() > 500) {\n+            throw new IllegalStateException(\"Max limit on MIME types for MIME group \"\n+                    + mimeGroup + \" exceeded for package \" + name);\n+        }\n \n         ArraySet<String> newMimeTypes = new ArraySet<>(mimeTypes);\n         boolean hasChanges = !newMimeTypes.equals(oldMimeTypes);\n",
    "added_lines": 9,
    "deleted_lines": 0,
    "changed_methods": "PackageSetting::setMimeGroup"
   }
  ]
 },
 {
  "hash": "f30e24fbc849472d74b7a600a83881a23196667f",
  "commit": "Disable all A11yServices from an uninstalled package.\n\nPrevious logic would exit the loop after removing the first service\nmatching the uninstalled package.\n\nBug: 243378132\nTest: atest AccessibilityEndToEndTest\nTest: m sts;\n      sts-tradefed run sts-dynamic-develop -m \\\n        CtsAccessibilityServiceTestCases\nChange-Id: I4ba30345d8600674ee8a9ea3ff411aecbf3655a3\n(cherry picked from commit e1f343acdeeddd9a08c9f6c832faf788ce101763)\nMerged-In: I4ba30345d8600674ee8a9ea3ff411aecbf3655a3",
  "files": [
   {
    "filename": "AccessibilityManagerService.java",
    "diff": "@@ -506,25 +506,27 @@ public class AccessibilityManagerService extends IAccessibilityManager.Stub\n                     userState.mBindingServices.removeIf(filter);\n                     userState.mCrashedServices.removeIf(filter);\n                     final Iterator<ComponentName> it = userState.mEnabledServices.iterator();\n+                    boolean anyServiceRemoved = false;\n                     while (it.hasNext()) {\n                         final ComponentName comp = it.next();\n                         final String compPkg = comp.getPackageName();\n                         if (compPkg.equals(packageName)) {\n                             it.remove();\n-                            // Update the enabled services setting.\n-                            persistComponentNamesToSettingLocked(\n-                                    Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES,\n-                                    userState.mEnabledServices, userId);\n-                            // Update the touch exploration granted services setting.\n                             userState.mTouchExplorationGrantedServices.remove(comp);\n-                            persistComponentNamesToSettingLocked(\n-                                    Settings.Secure.\n-                                    TOUCH_EXPLORATION_GRANTED_ACCESSIBILITY_SERVICES,\n-                                    userState.mTouchExplorationGrantedServices, userId);\n-                            onUserStateChangedLocked(userState);\n-                            return;\n+                            anyServiceRemoved = true;\n                         }\n                     }\n+                    if (anyServiceRemoved) {\n+                        // Update the enabled services setting.\n+                        persistComponentNamesToSettingLocked(\n+                                Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES,\n+                                userState.mEnabledServices, userId);\n+                        // Update the touch exploration granted services setting.\n+                        persistComponentNamesToSettingLocked(\n+                                Settings.Secure.TOUCH_EXPLORATION_GRANTED_ACCESSIBILITY_SERVICES,\n+                                userState.mTouchExplorationGrantedServices, userId);\n+                        onUserStateChangedLocked(userState);\n+                    }\n                 }\n             }\n \n",
    "added_lines": 13,
    "deleted_lines": 11,
    "changed_methods": "AccessibilityManagerService::registerBroadcastReceivers"
   }
  ]
 },
 {
  "hash": "19702ea591fc2fe045ed9366127e5d824bfba474",
  "commit": "[DO NOT MERGE] Fix conditionId string trimming in AutomaticZenRule\n\nThis change only applies to S branches and earlier.\n\nBug: 253085433\nBug: 242703460\nBug: 242703505\nBug: 242703780\nBug: 242704043\nBug: 243794204\nTest: AutomaticZenRuleTest\nChange-Id: Iae423d93b777df8946ecf1c3baf640fcf74990ec\nMerged-In: Iae423d93b777df8946ecf1c3baf640fcf74990ec\n(cherry picked from commit 7533d0420d85d56ec42bdb30a2ef1ae55ae95080)\nMerged-In: Iae423d93b777df8946ecf1c3baf640fcf74990ec",
  "files": [
   {
    "filename": "AutomaticZenRule.java",
    "diff": "@@ -125,7 +125,7 @@ public final class AutomaticZenRule implements Parcelable {\n             name = getTrimmedString(source.readString());\n         }\n         interruptionFilter = source.readInt();\n-        conditionId = source.readParcelable(null);\n+        conditionId = getTrimmedUri(source.readParcelable(null));\n         owner = getTrimmedComponentName(source.readParcelable(null));\n         configurationActivity = getTrimmedComponentName(source.readParcelable(null));\n         creationTime = source.readLong();\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "AutomaticZenRule::AutomaticZenRule"
   }
  ]
 },
 {
  "hash": "d10614e8de0f69aae3abbcb9439606305696286a",
  "commit": "[RESTRICT AUTOMERGE] [SettingsProvider] mem limit should be checked before settings are updated\n\nPreviously, a setting is updated before the memory usage limit\ncheck, which can be exploited by malicious apps and cause OoM DoS.\n\nThis CL changes the logic to checkMemLimit -> update -> updateMemUsage.\n\nBUG: 239415861\nTest: atest com.android.providers.settings.SettingsStateTest\n\n(cherry picked from commit 8eeb92950f4a7012d4cf282106a1418fd211f475)\nMerged-In: I20551a2dba9aa79efa0c064824f349f551c2c2e4\nChange-Id: I20551a2dba9aa79efa0c064824f349f551c2c2e4\n(cherry picked from commit 966b597383d1f5cbbc943affeb24b9b225b2ddae)\nMerged-In: I20551a2dba9aa79efa0c064824f349f551c2c2e4",
  "files": [
   {
    "filename": "SettingsState.java",
    "diff": "@@ -375,9 +375,11 @@ final class SettingsState {\n             Setting newSetting = new Setting(name, oldSetting.getValue(), null,\n                     oldSetting.getPackageName(), oldSetting.getTag(), false,\n                     oldSetting.getId());\n-            mSettings.put(name, newSetting);\n-            updateMemoryUsagePerPackageLocked(newSetting.getPackageName(), oldValue,\n+            int newSize = getNewMemoryUsagePerPackageLocked(newSetting.getPackageName(), oldValue,\n                     newSetting.getValue(), oldDefaultValue, newSetting.getDefaultValue());\n+            checkNewMemoryUsagePerPackageLocked(newSetting.getPackageName(), newSize);\n+            mSettings.put(name, newSetting);\n+            updateMemoryUsagePerPackageLocked(newSetting.getPackageName(), newSize);\n             scheduleWriteIfNeededLocked();\n         }\n     }\n@@ -410,6 +412,12 @@ final class SettingsState {\n         Setting oldState = mSettings.get(name);\n         String oldValue = (oldState != null) ? oldState.value : null;\n         String oldDefaultValue = (oldState != null) ? oldState.defaultValue : null;\n+        String newDefaultValue = makeDefault ? value : oldDefaultValue;\n+\n+        int newSize = getNewMemoryUsagePerPackageLocked(packageName, oldValue, value,\n+                oldDefaultValue, newDefaultValue);\n+        checkNewMemoryUsagePerPackageLocked(packageName, newSize);\n+\n         Setting newState;\n \n         if (oldState != null) {\n@@ -430,8 +438,7 @@ final class SettingsState {\n \n         addHistoricalOperationLocked(HISTORICAL_OPERATION_UPDATE, newState);\n \n-        updateMemoryUsagePerPackageLocked(packageName, oldValue, value,\n-                oldDefaultValue, newState.getDefaultValue());\n+        updateMemoryUsagePerPackageLocked(packageName, newSize);\n \n         scheduleWriteIfNeededLocked();\n \n@@ -552,13 +559,14 @@ final class SettingsState {\n         }\n \n         Setting oldState = mSettings.remove(name);\n+        int newSize = getNewMemoryUsagePerPackageLocked(oldState.packageName, oldState.value,\n+                null, oldState.defaultValue, null);\n \n         FrameworkStatsLog.write(FrameworkStatsLog.SETTING_CHANGED, name, /* value= */ \"\",\n                 /* newValue= */ \"\", oldState.value, /* tag */ \"\", false, getUserIdFromKey(mKey),\n                 FrameworkStatsLog.SETTING_CHANGED__REASON__DELETED);\n \n-        updateMemoryUsagePerPackageLocked(oldState.packageName, oldState.value,\n-                null, oldState.defaultValue, null);\n+        updateMemoryUsagePerPackageLocked(oldState.packageName, newSize);\n \n         addHistoricalOperationLocked(HISTORICAL_OPERATION_DELETE, oldState);\n \n@@ -579,16 +587,18 @@ final class SettingsState {\n         Setting oldSetting = new Setting(setting);\n         String oldValue = setting.getValue();\n         String oldDefaultValue = setting.getDefaultValue();\n+        String newValue = oldDefaultValue;\n+        String newDefaultValue = oldDefaultValue;\n+\n+        int newSize = getNewMemoryUsagePerPackageLocked(setting.packageName, oldValue,\n+                newValue, oldDefaultValue, newDefaultValue);\n+        checkNewMemoryUsagePerPackageLocked(setting.packageName, newSize);\n \n         if (!setting.reset()) {\n             return false;\n         }\n \n-        String newValue = setting.getValue();\n-        String newDefaultValue = setting.getDefaultValue();\n-\n-        updateMemoryUsagePerPackageLocked(setting.packageName, oldValue,\n-                newValue, oldDefaultValue, newDefaultValue);\n+        updateMemoryUsagePerPackageLocked(setting.packageName, newSize);\n \n         addHistoricalOperationLocked(HISTORICAL_OPERATION_RESET, oldSetting);\n \n@@ -696,38 +706,49 @@ final class SettingsState {\n     }\n \n     @GuardedBy(\"mLock\")\n-    private void updateMemoryUsagePerPackageLocked(String packageName, String oldValue,\n-            String newValue, String oldDefaultValue, String newDefaultValue) {\n-        if (mMaxBytesPerAppPackage == MAX_BYTES_PER_APP_PACKAGE_UNLIMITED) {\n-            return;\n-        }\n+    private boolean isExemptFromMemoryUsageCap(String packageName) {\n+        return mMaxBytesPerAppPackage == MAX_BYTES_PER_APP_PACKAGE_UNLIMITED\n+                || SYSTEM_PACKAGE_NAME.equals(packageName);\n+    }\n \n-        if (SYSTEM_PACKAGE_NAME.equals(packageName)) {\n+    @GuardedBy(\"mLock\")\n+    private void checkNewMemoryUsagePerPackageLocked(String packageName, int newSize)\n+            throws IllegalStateException {\n+        if (isExemptFromMemoryUsageCap(packageName)) {\n             return;\n         }\n+        if (newSize > mMaxBytesPerAppPackage) {\n+            throw new IllegalStateException(\"You are adding too many system settings. \"\n+                    + \"You should stop using system settings for app specific data\"\n+                    + \" package: \" + packageName);\n+        }\n+    }\n \n+    @GuardedBy(\"mLock\")\n+    private int getNewMemoryUsagePerPackageLocked(String packageName, String oldValue,\n+            String newValue, String oldDefaultValue, String newDefaultValue) {\n+        if (isExemptFromMemoryUsageCap(packageName)) {\n+            return 0;\n+        }\n+        final Integer currentSize = mPackageToMemoryUsage.get(packageName);\n         final int oldValueSize = (oldValue != null) ? oldValue.length() : 0;\n         final int newValueSize = (newValue != null) ? newValue.length() : 0;\n         final int oldDefaultValueSize = (oldDefaultValue != null) ? oldDefaultValue.length() : 0;\n         final int newDefaultValueSize = (newDefaultValue != null) ? newDefaultValue.length() : 0;\n         final int deltaSize = newValueSize + newDefaultValueSize\n                 - oldValueSize - oldDefaultValueSize;\n+        return Math.max((currentSize != null) ? currentSize + deltaSize : deltaSize, 0);\n+    }\n \n-        Integer currentSize = mPackageToMemoryUsage.get(packageName);\n-        final int newSize = Math.max((currentSize != null)\n-                ? currentSize + deltaSize : deltaSize, 0);\n-\n-        if (newSize > mMaxBytesPerAppPackage) {\n-            throw new IllegalStateException(\"You are adding too many system settings. \"\n-                    + \"You should stop using system settings for app specific data\"\n-                    + \" package: \" + packageName);\n+    @GuardedBy(\"mLock\")\n+    private void updateMemoryUsagePerPackageLocked(String packageName, int newSize) {\n+        if (isExemptFromMemoryUsageCap(packageName)) {\n+            return;\n         }\n-\n         if (DEBUG) {\n             Slog.i(LOG_TAG, \"Settings for package: \" + packageName\n                     + \" size: \" + newSize + \" bytes.\");\n         }\n-\n         mPackageToMemoryUsage.put(packageName, newSize);\n     }\n \n",
    "added_lines": 48,
    "deleted_lines": 27,
    "changed_methods": "SettingsState::insertSettingLocked, SettingsState::updateMemoryUsagePerPackageLocked, SettingsState::resetSettingDefaultValueLocked, SettingsState::resetSettingLocked, SettingsState::checkNewMemoryUsagePerPackageLocked, SettingsState::getNewMemoryUsagePerPackageLocked, SettingsState::updateMemoryUsagePerPackageLocked, SettingsState::isExemptFromMemoryUsageCap, SettingsState::deleteSettingLocked"
   },
   {
    "filename": "SettingsStateTest.java",
    "diff": "@@ -20,6 +20,8 @@ import android.test.AndroidTestCase;\n import android.util.TypedXmlSerializer;\n import android.util.Xml;\n \n+import com.google.common.base.Strings;\n+\n import java.io.ByteArrayOutputStream;\n import java.io.File;\n import java.io.FileOutputStream;\n@@ -276,4 +278,40 @@ public class SettingsStateTest extends AndroidTestCase {\n         settingsState.setVersionLocked(SettingsState.SETTINGS_VERSION_NEW_ENCODING);\n         return settingsState;\n     }\n+\n+    public void testInsertSetting_memoryUsage() {\n+        SettingsState settingsState = new SettingsState(getContext(), mLock, mSettingsFile, 1,\n+                SettingsState.MAX_BYTES_PER_APP_PACKAGE_UNLIMITED, Looper.getMainLooper());\n+        // No exception should be thrown when there is no cap\n+        settingsState.insertSettingLocked(SETTING_NAME, Strings.repeat(\"A\", 20001),\n+                null, false, \"p1\");\n+        settingsState.deleteSettingLocked(SETTING_NAME);\n+\n+        settingsState = new SettingsState(getContext(), mLock, mSettingsFile, 1,\n+                SettingsState.MAX_BYTES_PER_APP_PACKAGE_LIMITED, Looper.getMainLooper());\n+        // System package doesn't have memory usage limit\n+        settingsState.insertSettingLocked(SETTING_NAME, Strings.repeat(\"A\", 20001),\n+                null, false, SYSTEM_PACKAGE);\n+        settingsState.deleteSettingLocked(SETTING_NAME);\n+\n+        // Should not throw if usage is under the cap\n+        settingsState.insertSettingLocked(SETTING_NAME, Strings.repeat(\"A\", 19999),\n+                null, false, \"p1\");\n+        settingsState.deleteSettingLocked(SETTING_NAME);\n+        try {\n+            settingsState.insertSettingLocked(SETTING_NAME, Strings.repeat(\"A\", 20001),\n+                    null, false, \"p1\");\n+            fail(\"Should throw because it exceeded per package memory usage\");\n+        } catch (IllegalStateException ex) {\n+            assertTrue(ex.getMessage().contains(\"p1\"));\n+        }\n+        try {\n+            settingsState.insertSettingLocked(SETTING_NAME, Strings.repeat(\"A\", 20001),\n+                    null, false, \"p1\");\n+            fail(\"Should throw because it exceeded per package memory usage\");\n+        } catch (IllegalStateException ex) {\n+            assertTrue(ex.getMessage().contains(\"p1\"));\n+        }\n+        assertTrue(settingsState.getSettingLocked(SETTING_NAME).isNull());\n+    }\n }\n",
    "added_lines": 38,
    "deleted_lines": 0,
    "changed_methods": "SettingsStateTest::testInsertSetting_memoryUsage"
   }
  ]
 },
 {
  "hash": "d10614e8de0f69aae3abbcb9439606305696286a",
  "commit": "[RESTRICT AUTOMERGE] [SettingsProvider] mem limit should be checked before settings are updated\n\nPreviously, a setting is updated before the memory usage limit\ncheck, which can be exploited by malicious apps and cause OoM DoS.\n\nThis CL changes the logic to checkMemLimit -> update -> updateMemUsage.\n\nBUG: 239415861\nTest: atest com.android.providers.settings.SettingsStateTest\n\n(cherry picked from commit 8eeb92950f4a7012d4cf282106a1418fd211f475)\nMerged-In: I20551a2dba9aa79efa0c064824f349f551c2c2e4\nChange-Id: I20551a2dba9aa79efa0c064824f349f551c2c2e4\n(cherry picked from commit 966b597383d1f5cbbc943affeb24b9b225b2ddae)\nMerged-In: I20551a2dba9aa79efa0c064824f349f551c2c2e4",
  "files": [
   {
    "filename": "SettingsState.java",
    "diff": "@@ -375,9 +375,11 @@ final class SettingsState {\n             Setting newSetting = new Setting(name, oldSetting.getValue(), null,\n                     oldSetting.getPackageName(), oldSetting.getTag(), false,\n                     oldSetting.getId());\n-            mSettings.put(name, newSetting);\n-            updateMemoryUsagePerPackageLocked(newSetting.getPackageName(), oldValue,\n+            int newSize = getNewMemoryUsagePerPackageLocked(newSetting.getPackageName(), oldValue,\n                     newSetting.getValue(), oldDefaultValue, newSetting.getDefaultValue());\n+            checkNewMemoryUsagePerPackageLocked(newSetting.getPackageName(), newSize);\n+            mSettings.put(name, newSetting);\n+            updateMemoryUsagePerPackageLocked(newSetting.getPackageName(), newSize);\n             scheduleWriteIfNeededLocked();\n         }\n     }\n@@ -410,6 +412,12 @@ final class SettingsState {\n         Setting oldState = mSettings.get(name);\n         String oldValue = (oldState != null) ? oldState.value : null;\n         String oldDefaultValue = (oldState != null) ? oldState.defaultValue : null;\n+        String newDefaultValue = makeDefault ? value : oldDefaultValue;\n+\n+        int newSize = getNewMemoryUsagePerPackageLocked(packageName, oldValue, value,\n+                oldDefaultValue, newDefaultValue);\n+        checkNewMemoryUsagePerPackageLocked(packageName, newSize);\n+\n         Setting newState;\n \n         if (oldState != null) {\n@@ -430,8 +438,7 @@ final class SettingsState {\n \n         addHistoricalOperationLocked(HISTORICAL_OPERATION_UPDATE, newState);\n \n-        updateMemoryUsagePerPackageLocked(packageName, oldValue, value,\n-                oldDefaultValue, newState.getDefaultValue());\n+        updateMemoryUsagePerPackageLocked(packageName, newSize);\n \n         scheduleWriteIfNeededLocked();\n \n@@ -552,13 +559,14 @@ final class SettingsState {\n         }\n \n         Setting oldState = mSettings.remove(name);\n+        int newSize = getNewMemoryUsagePerPackageLocked(oldState.packageName, oldState.value,\n+                null, oldState.defaultValue, null);\n \n         FrameworkStatsLog.write(FrameworkStatsLog.SETTING_CHANGED, name, /* value= */ \"\",\n                 /* newValue= */ \"\", oldState.value, /* tag */ \"\", false, getUserIdFromKey(mKey),\n                 FrameworkStatsLog.SETTING_CHANGED__REASON__DELETED);\n \n-        updateMemoryUsagePerPackageLocked(oldState.packageName, oldState.value,\n-                null, oldState.defaultValue, null);\n+        updateMemoryUsagePerPackageLocked(oldState.packageName, newSize);\n \n         addHistoricalOperationLocked(HISTORICAL_OPERATION_DELETE, oldState);\n \n@@ -579,16 +587,18 @@ final class SettingsState {\n         Setting oldSetting = new Setting(setting);\n         String oldValue = setting.getValue();\n         String oldDefaultValue = setting.getDefaultValue();\n+        String newValue = oldDefaultValue;\n+        String newDefaultValue = oldDefaultValue;\n+\n+        int newSize = getNewMemoryUsagePerPackageLocked(setting.packageName, oldValue,\n+                newValue, oldDefaultValue, newDefaultValue);\n+        checkNewMemoryUsagePerPackageLocked(setting.packageName, newSize);\n \n         if (!setting.reset()) {\n             return false;\n         }\n \n-        String newValue = setting.getValue();\n-        String newDefaultValue = setting.getDefaultValue();\n-\n-        updateMemoryUsagePerPackageLocked(setting.packageName, oldValue,\n-                newValue, oldDefaultValue, newDefaultValue);\n+        updateMemoryUsagePerPackageLocked(setting.packageName, newSize);\n \n         addHistoricalOperationLocked(HISTORICAL_OPERATION_RESET, oldSetting);\n \n@@ -696,38 +706,49 @@ final class SettingsState {\n     }\n \n     @GuardedBy(\"mLock\")\n-    private void updateMemoryUsagePerPackageLocked(String packageName, String oldValue,\n-            String newValue, String oldDefaultValue, String newDefaultValue) {\n-        if (mMaxBytesPerAppPackage == MAX_BYTES_PER_APP_PACKAGE_UNLIMITED) {\n-            return;\n-        }\n+    private boolean isExemptFromMemoryUsageCap(String packageName) {\n+        return mMaxBytesPerAppPackage == MAX_BYTES_PER_APP_PACKAGE_UNLIMITED\n+                || SYSTEM_PACKAGE_NAME.equals(packageName);\n+    }\n \n-        if (SYSTEM_PACKAGE_NAME.equals(packageName)) {\n+    @GuardedBy(\"mLock\")\n+    private void checkNewMemoryUsagePerPackageLocked(String packageName, int newSize)\n+            throws IllegalStateException {\n+        if (isExemptFromMemoryUsageCap(packageName)) {\n             return;\n         }\n+        if (newSize > mMaxBytesPerAppPackage) {\n+            throw new IllegalStateException(\"You are adding too many system settings. \"\n+                    + \"You should stop using system settings for app specific data\"\n+                    + \" package: \" + packageName);\n+        }\n+    }\n \n+    @GuardedBy(\"mLock\")\n+    private int getNewMemoryUsagePerPackageLocked(String packageName, String oldValue,\n+            String newValue, String oldDefaultValue, String newDefaultValue) {\n+        if (isExemptFromMemoryUsageCap(packageName)) {\n+            return 0;\n+        }\n+        final Integer currentSize = mPackageToMemoryUsage.get(packageName);\n         final int oldValueSize = (oldValue != null) ? oldValue.length() : 0;\n         final int newValueSize = (newValue != null) ? newValue.length() : 0;\n         final int oldDefaultValueSize = (oldDefaultValue != null) ? oldDefaultValue.length() : 0;\n         final int newDefaultValueSize = (newDefaultValue != null) ? newDefaultValue.length() : 0;\n         final int deltaSize = newValueSize + newDefaultValueSize\n                 - oldValueSize - oldDefaultValueSize;\n+        return Math.max((currentSize != null) ? currentSize + deltaSize : deltaSize, 0);\n+    }\n \n-        Integer currentSize = mPackageToMemoryUsage.get(packageName);\n-        final int newSize = Math.max((currentSize != null)\n-                ? currentSize + deltaSize : deltaSize, 0);\n-\n-        if (newSize > mMaxBytesPerAppPackage) {\n-            throw new IllegalStateException(\"You are adding too many system settings. \"\n-                    + \"You should stop using system settings for app specific data\"\n-                    + \" package: \" + packageName);\n+    @GuardedBy(\"mLock\")\n+    private void updateMemoryUsagePerPackageLocked(String packageName, int newSize) {\n+        if (isExemptFromMemoryUsageCap(packageName)) {\n+            return;\n         }\n-\n         if (DEBUG) {\n             Slog.i(LOG_TAG, \"Settings for package: \" + packageName\n                     + \" size: \" + newSize + \" bytes.\");\n         }\n-\n         mPackageToMemoryUsage.put(packageName, newSize);\n     }\n \n",
    "added_lines": 48,
    "deleted_lines": 27,
    "changed_methods": "SettingsState::insertSettingLocked, SettingsState::updateMemoryUsagePerPackageLocked, SettingsState::resetSettingDefaultValueLocked, SettingsState::resetSettingLocked, SettingsState::checkNewMemoryUsagePerPackageLocked, SettingsState::getNewMemoryUsagePerPackageLocked, SettingsState::updateMemoryUsagePerPackageLocked, SettingsState::isExemptFromMemoryUsageCap, SettingsState::deleteSettingLocked"
   },
   {
    "filename": "SettingsStateTest.java",
    "diff": "@@ -20,6 +20,8 @@ import android.test.AndroidTestCase;\n import android.util.TypedXmlSerializer;\n import android.util.Xml;\n \n+import com.google.common.base.Strings;\n+\n import java.io.ByteArrayOutputStream;\n import java.io.File;\n import java.io.FileOutputStream;\n@@ -276,4 +278,40 @@ public class SettingsStateTest extends AndroidTestCase {\n         settingsState.setVersionLocked(SettingsState.SETTINGS_VERSION_NEW_ENCODING);\n         return settingsState;\n     }\n+\n+    public void testInsertSetting_memoryUsage() {\n+        SettingsState settingsState = new SettingsState(getContext(), mLock, mSettingsFile, 1,\n+                SettingsState.MAX_BYTES_PER_APP_PACKAGE_UNLIMITED, Looper.getMainLooper());\n+        // No exception should be thrown when there is no cap\n+        settingsState.insertSettingLocked(SETTING_NAME, Strings.repeat(\"A\", 20001),\n+                null, false, \"p1\");\n+        settingsState.deleteSettingLocked(SETTING_NAME);\n+\n+        settingsState = new SettingsState(getContext(), mLock, mSettingsFile, 1,\n+                SettingsState.MAX_BYTES_PER_APP_PACKAGE_LIMITED, Looper.getMainLooper());\n+        // System package doesn't have memory usage limit\n+        settingsState.insertSettingLocked(SETTING_NAME, Strings.repeat(\"A\", 20001),\n+                null, false, SYSTEM_PACKAGE);\n+        settingsState.deleteSettingLocked(SETTING_NAME);\n+\n+        // Should not throw if usage is under the cap\n+        settingsState.insertSettingLocked(SETTING_NAME, Strings.repeat(\"A\", 19999),\n+                null, false, \"p1\");\n+        settingsState.deleteSettingLocked(SETTING_NAME);\n+        try {\n+            settingsState.insertSettingLocked(SETTING_NAME, Strings.repeat(\"A\", 20001),\n+                    null, false, \"p1\");\n+            fail(\"Should throw because it exceeded per package memory usage\");\n+        } catch (IllegalStateException ex) {\n+            assertTrue(ex.getMessage().contains(\"p1\"));\n+        }\n+        try {\n+            settingsState.insertSettingLocked(SETTING_NAME, Strings.repeat(\"A\", 20001),\n+                    null, false, \"p1\");\n+            fail(\"Should throw because it exceeded per package memory usage\");\n+        } catch (IllegalStateException ex) {\n+            assertTrue(ex.getMessage().contains(\"p1\"));\n+        }\n+        assertTrue(settingsState.getSettingLocked(SETTING_NAME).isNull());\n+    }\n }\n",
    "added_lines": 38,
    "deleted_lines": 0,
    "changed_methods": "SettingsStateTest::testInsertSetting_memoryUsage"
   }
  ]
 },
 {
  "hash": "33c13c17865d57cb5e55f301ae8eaa7fdf5b8f9c",
  "commit": "Backport missing permission check for querying main activity intent\n\n- This was fixed in T in ag/16820166, but the original code was\n  submitted in S.  This ensures that the caller of this method\n  is either holding the ACCESS_SHORTCUTS permission or is the\n  default launcher.\n\nBug: 229256049\nTest: atest WMShellUnitTests\n\nChange-Id: Ib233ad754a6c6e3c4e0d0e10ed788ab8e055cccc\nMerged-In: Ib233ad754a6c6e3c4e0d0e10ed788ab8e055cccc\n(cherry picked from commit f4ed441e180d7113b5f6ebfe711e61a2dd3fd8b1)\n(cherry picked from commit b3192809643eff948d9457c8a7b36b968a7388a1)\nMerged-In: Ib233ad754a6c6e3c4e0d0e10ed788ab8e055cccc",
  "files": [
   {
    "filename": "LauncherApps.java",
    "diff": "@@ -752,7 +752,8 @@ public class LauncherApps {\n         }\n         try {\n             // due to b/209607104, startActivityOptions will be ignored\n-            return mService.getActivityLaunchIntent(component, null /* opts */, user);\n+            return mService.getActivityLaunchIntent(mContext.getPackageName(), component,\n+                    null /* opts */, user);\n         } catch (RemoteException re) {\n             throw re.rethrowFromSystemServer();\n         }\n",
    "added_lines": 2,
    "deleted_lines": 1,
    "changed_methods": "LauncherApps::getMainActivityLaunchIntent"
   },
   {
    "filename": "LauncherAppsService.java",
    "diff": "@@ -1098,8 +1098,9 @@ public class LauncherAppsService extends SystemService {\n         }\n \n         @Override\n-        public PendingIntent getActivityLaunchIntent(ComponentName component, Bundle opts,\n-                UserHandle user) {\n+        public PendingIntent getActivityLaunchIntent(String callingPackage, ComponentName component,\n+                Bundle opts, UserHandle user) {\n+            ensureShortcutPermission(callingPackage);\n             if (!canAccessProfile(user.getIdentifier(), \"Cannot start activity\")) {\n                 throw new ActivityNotFoundException(\"Activity could not be found\");\n             }\n",
    "added_lines": 3,
    "deleted_lines": 2,
    "changed_methods": "LauncherAppsService::LauncherAppsImpl::getActivityLaunchIntent, LauncherAppsService::LauncherAppsImpl::getActivityLaunchIntent"
   }
  ]
 },
 {
  "hash": "33c13c17865d57cb5e55f301ae8eaa7fdf5b8f9c",
  "commit": "Backport missing permission check for querying main activity intent\n\n- This was fixed in T in ag/16820166, but the original code was\n  submitted in S.  This ensures that the caller of this method\n  is either holding the ACCESS_SHORTCUTS permission or is the\n  default launcher.\n\nBug: 229256049\nTest: atest WMShellUnitTests\n\nChange-Id: Ib233ad754a6c6e3c4e0d0e10ed788ab8e055cccc\nMerged-In: Ib233ad754a6c6e3c4e0d0e10ed788ab8e055cccc\n(cherry picked from commit f4ed441e180d7113b5f6ebfe711e61a2dd3fd8b1)\n(cherry picked from commit b3192809643eff948d9457c8a7b36b968a7388a1)\nMerged-In: Ib233ad754a6c6e3c4e0d0e10ed788ab8e055cccc",
  "files": [
   {
    "filename": "LauncherApps.java",
    "diff": "@@ -752,7 +752,8 @@ public class LauncherApps {\n         }\n         try {\n             // due to b/209607104, startActivityOptions will be ignored\n-            return mService.getActivityLaunchIntent(component, null /* opts */, user);\n+            return mService.getActivityLaunchIntent(mContext.getPackageName(), component,\n+                    null /* opts */, user);\n         } catch (RemoteException re) {\n             throw re.rethrowFromSystemServer();\n         }\n",
    "added_lines": 2,
    "deleted_lines": 1,
    "changed_methods": "LauncherApps::getMainActivityLaunchIntent"
   },
   {
    "filename": "LauncherAppsService.java",
    "diff": "@@ -1098,8 +1098,9 @@ public class LauncherAppsService extends SystemService {\n         }\n \n         @Override\n-        public PendingIntent getActivityLaunchIntent(ComponentName component, Bundle opts,\n-                UserHandle user) {\n+        public PendingIntent getActivityLaunchIntent(String callingPackage, ComponentName component,\n+                Bundle opts, UserHandle user) {\n+            ensureShortcutPermission(callingPackage);\n             if (!canAccessProfile(user.getIdentifier(), \"Cannot start activity\")) {\n                 throw new ActivityNotFoundException(\"Activity could not be found\");\n             }\n",
    "added_lines": 3,
    "deleted_lines": 2,
    "changed_methods": "LauncherAppsService::LauncherAppsImpl::getActivityLaunchIntent, LauncherAppsService::LauncherAppsImpl::getActivityLaunchIntent"
   }
  ]
 },
 {
  "hash": "53ece2aea297fb9a5c78a7bffaf3dad485908736",
  "commit": "RESTRICT AUTOMERGE Validate permission tree size on permission update\n\nBug: 242537498\nTest: manual\nChange-Id: I15343e84c1802d6b89249106263319a6539fa73b\n(cherry picked from commit 1d86c8b29922525972559e00e26c1fcd6f496353)\nMerged-In: I15343e84c1802d6b89249106263319a6539fa73b",
  "files": [
   {
    "filename": "PermissionManagerService.java",
    "diff": "@@ -657,8 +657,8 @@ public class PermissionManagerService extends IPermissionManager.Stub {\n             Permission bp = mRegistry.getPermission(info.name);\n             added = bp == null;\n             int fixedLevel = PermissionInfo.fixProtectionLevel(info.protectionLevel);\n+            enforcePermissionCapLocked(info, tree);\n             if (added) {\n-                enforcePermissionCapLocked(info, tree);\n                 bp = new Permission(info.name, tree.getPackageName(), Permission.TYPE_DYNAMIC);\n             } else if (!bp.isDynamic()) {\n                 throw new SecurityException(\"Not allowed to modify non-dynamic permission \"\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "PermissionManagerService::addPermission"
   }
  ]
 },
 {
  "hash": "14bf3cb0902a769dcf700e6c1f596f5c1d5eefe6",
  "commit": "[RESTRICT AUTOMERGE][SettingsProvider] key size limit for mutating settings\n\nPrior to targetSdk 22, apps could add random system settings keys which\nopens an opportunity for OOM attacks. This CL adds a key size limit.\n\nBUG: 239415997\nTest: manual; will add cts test\nMerged-In: Ic9e88c0cc3d7206c64ba5b5c7d15b50d1ffc9adc\nChange-Id: Ic9e88c0cc3d7206c64ba5b5c7d15b50d1ffc9adc\n(cherry picked from commit 783bcba343c480f6ccedaaff41ba7171a1082e0c)\n(cherry picked from commit 0123e873d2e5f4c88aaa6bdf2e287461903fa6e5)\nMerged-In: Ic9e88c0cc3d7206c64ba5b5c7d15b50d1ffc9adc",
  "files": [
   {
    "filename": "SettingsState.java",
    "diff": "@@ -47,6 +47,7 @@ import android.util.Xml;\n import android.util.proto.ProtoOutputStream;\n \n import com.android.internal.annotations.GuardedBy;\n+import com.android.internal.annotations.VisibleForTesting;\n import com.android.internal.util.FrameworkStatsLog;\n \n import libcore.io.IoUtils;\n@@ -375,8 +376,8 @@ final class SettingsState {\n             Setting newSetting = new Setting(name, oldSetting.getValue(), null,\n                     oldSetting.getPackageName(), oldSetting.getTag(), false,\n                     oldSetting.getId());\n-            int newSize = getNewMemoryUsagePerPackageLocked(newSetting.getPackageName(), oldValue,\n-                    newSetting.getValue(), oldDefaultValue, newSetting.getDefaultValue());\n+            int newSize = getNewMemoryUsagePerPackageLocked(newSetting.getPackageName(), 0,\n+                    oldValue, newSetting.getValue(), oldDefaultValue, newSetting.getDefaultValue());\n             checkNewMemoryUsagePerPackageLocked(newSetting.getPackageName(), newSize);\n             mSettings.put(name, newSetting);\n             updateMemoryUsagePerPackageLocked(newSetting.getPackageName(), newSize);\n@@ -414,8 +415,9 @@ final class SettingsState {\n         String oldDefaultValue = (oldState != null) ? oldState.defaultValue : null;\n         String newDefaultValue = makeDefault ? value : oldDefaultValue;\n \n-        int newSize = getNewMemoryUsagePerPackageLocked(packageName, oldValue, value,\n-                oldDefaultValue, newDefaultValue);\n+        int newSize = getNewMemoryUsagePerPackageLocked(packageName,\n+                oldValue == null ? name.length() : 0 /* deltaKeySize */,\n+                oldValue, value, oldDefaultValue, newDefaultValue);\n         checkNewMemoryUsagePerPackageLocked(packageName, newSize);\n \n         Setting newState;\n@@ -559,8 +561,12 @@ final class SettingsState {\n         }\n \n         Setting oldState = mSettings.remove(name);\n-        int newSize = getNewMemoryUsagePerPackageLocked(oldState.packageName, oldState.value,\n-                null, oldState.defaultValue, null);\n+        if (oldState == null) {\n+            return false;\n+        }\n+        int newSize = getNewMemoryUsagePerPackageLocked(oldState.packageName,\n+                -name.length() /* deltaKeySize */,\n+                oldState.value, null, oldState.defaultValue, null);\n \n         FrameworkStatsLog.write(FrameworkStatsLog.SETTING_CHANGED, name, /* value= */ \"\",\n                 /* newValue= */ \"\", oldState.value, /* tag */ \"\", false, getUserIdFromKey(mKey),\n@@ -583,15 +589,16 @@ final class SettingsState {\n         }\n \n         Setting setting = mSettings.get(name);\n+        if (setting == null) {\n+            return false;\n+        }\n \n         Setting oldSetting = new Setting(setting);\n         String oldValue = setting.getValue();\n         String oldDefaultValue = setting.getDefaultValue();\n-        String newValue = oldDefaultValue;\n-        String newDefaultValue = oldDefaultValue;\n \n-        int newSize = getNewMemoryUsagePerPackageLocked(setting.packageName, oldValue,\n-                newValue, oldDefaultValue, newDefaultValue);\n+        int newSize = getNewMemoryUsagePerPackageLocked(setting.packageName, 0, oldValue,\n+                oldDefaultValue, oldDefaultValue, oldDefaultValue);\n         checkNewMemoryUsagePerPackageLocked(setting.packageName, newSize);\n \n         if (!setting.reset()) {\n@@ -725,8 +732,8 @@ final class SettingsState {\n     }\n \n     @GuardedBy(\"mLock\")\n-    private int getNewMemoryUsagePerPackageLocked(String packageName, String oldValue,\n-            String newValue, String oldDefaultValue, String newDefaultValue) {\n+    private int getNewMemoryUsagePerPackageLocked(String packageName, int deltaKeySize,\n+            String oldValue, String newValue, String oldDefaultValue, String newDefaultValue) {\n         if (isExemptFromMemoryUsageCap(packageName)) {\n             return 0;\n         }\n@@ -735,7 +742,7 @@ final class SettingsState {\n         final int newValueSize = (newValue != null) ? newValue.length() : 0;\n         final int oldDefaultValueSize = (oldDefaultValue != null) ? oldDefaultValue.length() : 0;\n         final int newDefaultValueSize = (newDefaultValue != null) ? newDefaultValue.length() : 0;\n-        final int deltaSize = newValueSize + newDefaultValueSize\n+        final int deltaSize = deltaKeySize + newValueSize + newDefaultValueSize\n                 - oldValueSize - oldDefaultValueSize;\n         return Math.max((currentSize != null) ? currentSize + deltaSize : deltaSize, 0);\n     }\n@@ -1556,4 +1563,11 @@ final class SettingsState {\n         }\n         return false;\n     }\n+\n+    @VisibleForTesting\n+    public int getMemoryUsage(String packageName) {\n+        synchronized (mLock) {\n+            return mPackageToMemoryUsage.getOrDefault(packageName, 0);\n+        }\n+    }\n }\n",
    "added_lines": 27,
    "deleted_lines": 13,
    "changed_methods": "SettingsState::getNewMemoryUsagePerPackageLocked, SettingsState::insertSettingLocked, SettingsState::resetSettingDefaultValueLocked, SettingsState::resetSettingLocked, SettingsState::getMemoryUsage, SettingsState::getNewMemoryUsagePerPackageLocked, SettingsState::deleteSettingLocked"
   },
   {
    "filename": "SettingsStateTest.java",
    "diff": "@@ -295,7 +295,7 @@ public class SettingsStateTest extends AndroidTestCase {\n         settingsState.deleteSettingLocked(SETTING_NAME);\n \n         // Should not throw if usage is under the cap\n-        settingsState.insertSettingLocked(SETTING_NAME, Strings.repeat(\"A\", 19999),\n+        settingsState.insertSettingLocked(SETTING_NAME, Strings.repeat(\"A\", 19975),\n                 null, false, \"p1\");\n         settingsState.deleteSettingLocked(SETTING_NAME);\n         try {\n@@ -313,5 +313,97 @@ public class SettingsStateTest extends AndroidTestCase {\n             assertTrue(ex.getMessage().contains(\"p1\"));\n         }\n         assertTrue(settingsState.getSettingLocked(SETTING_NAME).isNull());\n+        try {\n+            settingsState.insertSettingLocked(Strings.repeat(\"A\", 20001), \"\",\n+                    null, false, \"p1\");\n+            fail(\"Should throw because it exceeded per package memory usage\");\n+        } catch (IllegalStateException ex) {\n+            assertTrue(ex.getMessage().contains(\"You are adding too many system settings\"));\n+        }\n+    }\n+\n+    public void testMemoryUsagePerPackage() {\n+        SettingsState settingsState = new SettingsState(getContext(), mLock, mSettingsFile, 1,\n+                SettingsState.MAX_BYTES_PER_APP_PACKAGE_LIMITED, Looper.getMainLooper());\n+\n+        // Test inserting one key with default\n+        final String testKey1 = SETTING_NAME;\n+        final String testValue1 = Strings.repeat(\"A\", 100);\n+        settingsState.insertSettingLocked(testKey1, testValue1, null, true, TEST_PACKAGE);\n+        int expectedMemUsage = testKey1.length() + testValue1.length()\n+                + testValue1.length() /* size for default */;\n+        assertEquals(expectedMemUsage, settingsState.getMemoryUsage(TEST_PACKAGE));\n+\n+        // Test inserting another key\n+        final String testKey2 = SETTING_NAME + \"2\";\n+        settingsState.insertSettingLocked(testKey2, testValue1, null, false, TEST_PACKAGE);\n+        expectedMemUsage += testKey2.length() + testValue1.length();\n+        assertEquals(expectedMemUsage, settingsState.getMemoryUsage(TEST_PACKAGE));\n+\n+        // Test updating first key with new default\n+        final String testValue2 = Strings.repeat(\"A\", 300);\n+        settingsState.insertSettingLocked(testKey1, testValue2, null, true, TEST_PACKAGE);\n+        expectedMemUsage += (testValue2.length() - testValue1.length()) * 2;\n+        assertEquals(expectedMemUsage, settingsState.getMemoryUsage(TEST_PACKAGE));\n+\n+        // Test updating first key without new default\n+        final String testValue3 = Strings.repeat(\"A\", 50);\n+        settingsState.insertSettingLocked(testKey1, testValue3, null, false, TEST_PACKAGE);\n+        expectedMemUsage -= testValue2.length() - testValue3.length();\n+        assertEquals(expectedMemUsage, settingsState.getMemoryUsage(TEST_PACKAGE));\n+\n+        // Test updating second key\n+        settingsState.insertSettingLocked(testKey2, testValue2, null, false, TEST_PACKAGE);\n+        expectedMemUsage -= testValue1.length() - testValue2.length();\n+        assertEquals(expectedMemUsage, settingsState.getMemoryUsage(TEST_PACKAGE));\n+\n+        // Test resetting key\n+        settingsState.resetSettingLocked(testKey1);\n+        expectedMemUsage += testValue2.length() - testValue3.length();\n+        assertEquals(expectedMemUsage, settingsState.getMemoryUsage(TEST_PACKAGE));\n+\n+        // Test resetting default value\n+        settingsState.resetSettingDefaultValueLocked(testKey1);\n+        expectedMemUsage -= testValue2.length();\n+        assertEquals(expectedMemUsage, settingsState.getMemoryUsage(TEST_PACKAGE));\n+\n+        // Test deletion\n+        settingsState.deleteSettingLocked(testKey2);\n+        expectedMemUsage -= testValue2.length() + testKey2.length() /* key is deleted too */;\n+        assertEquals(expectedMemUsage, settingsState.getMemoryUsage(TEST_PACKAGE));\n+\n+        // Test another package with a different key\n+        final String testPackage2 = TEST_PACKAGE + \"2\";\n+        final String testKey3 = SETTING_NAME + \"3\";\n+        settingsState.insertSettingLocked(testKey3, testValue1, null, true, testPackage2);\n+        assertEquals(expectedMemUsage, settingsState.getMemoryUsage(TEST_PACKAGE));\n+        final int expectedMemUsage2 = testKey3.length() + testValue1.length() * 2;\n+        assertEquals(expectedMemUsage2, settingsState.getMemoryUsage(testPackage2));\n+\n+        // Test system package\n+        settingsState.insertSettingLocked(testKey1, testValue1, null, true, SYSTEM_PACKAGE);\n+        assertEquals(expectedMemUsage, settingsState.getMemoryUsage(TEST_PACKAGE));\n+        assertEquals(expectedMemUsage2, settingsState.getMemoryUsage(testPackage2));\n+        assertEquals(0, settingsState.getMemoryUsage(SYSTEM_PACKAGE));\n+\n+        // Test invalid value\n+        try {\n+            settingsState.insertSettingLocked(testKey1, Strings.repeat(\"A\", 20001), null, false,\n+                    TEST_PACKAGE);\n+            fail(\"Should throw because it exceeded per package memory usage\");\n+        } catch (IllegalStateException ex) {\n+            assertTrue(ex.getMessage().contains(\"You are adding too many system settings\"));\n+        }\n+        assertEquals(expectedMemUsage, settingsState.getMemoryUsage(TEST_PACKAGE));\n+\n+        // Test invalid key\n+        try {\n+            settingsState.insertSettingLocked(Strings.repeat(\"A\", 20001), \"\", null, false,\n+                    TEST_PACKAGE);\n+            fail(\"Should throw because it exceeded per package memory usage\");\n+        } catch (IllegalStateException ex) {\n+            assertTrue(ex.getMessage().contains(\"You are adding too many system settings\"));\n+        }\n+        assertEquals(expectedMemUsage, settingsState.getMemoryUsage(TEST_PACKAGE));\n     }\n }\n",
    "added_lines": 93,
    "deleted_lines": 1,
    "changed_methods": "SettingsStateTest::testInsertSetting_memoryUsage, SettingsStateTest::testMemoryUsagePerPackage"
   }
  ]
 },
 {
  "hash": "14bf3cb0902a769dcf700e6c1f596f5c1d5eefe6",
  "commit": "[RESTRICT AUTOMERGE][SettingsProvider] key size limit for mutating settings\n\nPrior to targetSdk 22, apps could add random system settings keys which\nopens an opportunity for OOM attacks. This CL adds a key size limit.\n\nBUG: 239415997\nTest: manual; will add cts test\nMerged-In: Ic9e88c0cc3d7206c64ba5b5c7d15b50d1ffc9adc\nChange-Id: Ic9e88c0cc3d7206c64ba5b5c7d15b50d1ffc9adc\n(cherry picked from commit 783bcba343c480f6ccedaaff41ba7171a1082e0c)\n(cherry picked from commit 0123e873d2e5f4c88aaa6bdf2e287461903fa6e5)\nMerged-In: Ic9e88c0cc3d7206c64ba5b5c7d15b50d1ffc9adc",
  "files": [
   {
    "filename": "SettingsState.java",
    "diff": "@@ -47,6 +47,7 @@ import android.util.Xml;\n import android.util.proto.ProtoOutputStream;\n \n import com.android.internal.annotations.GuardedBy;\n+import com.android.internal.annotations.VisibleForTesting;\n import com.android.internal.util.FrameworkStatsLog;\n \n import libcore.io.IoUtils;\n@@ -375,8 +376,8 @@ final class SettingsState {\n             Setting newSetting = new Setting(name, oldSetting.getValue(), null,\n                     oldSetting.getPackageName(), oldSetting.getTag(), false,\n                     oldSetting.getId());\n-            int newSize = getNewMemoryUsagePerPackageLocked(newSetting.getPackageName(), oldValue,\n-                    newSetting.getValue(), oldDefaultValue, newSetting.getDefaultValue());\n+            int newSize = getNewMemoryUsagePerPackageLocked(newSetting.getPackageName(), 0,\n+                    oldValue, newSetting.getValue(), oldDefaultValue, newSetting.getDefaultValue());\n             checkNewMemoryUsagePerPackageLocked(newSetting.getPackageName(), newSize);\n             mSettings.put(name, newSetting);\n             updateMemoryUsagePerPackageLocked(newSetting.getPackageName(), newSize);\n@@ -414,8 +415,9 @@ final class SettingsState {\n         String oldDefaultValue = (oldState != null) ? oldState.defaultValue : null;\n         String newDefaultValue = makeDefault ? value : oldDefaultValue;\n \n-        int newSize = getNewMemoryUsagePerPackageLocked(packageName, oldValue, value,\n-                oldDefaultValue, newDefaultValue);\n+        int newSize = getNewMemoryUsagePerPackageLocked(packageName,\n+                oldValue == null ? name.length() : 0 /* deltaKeySize */,\n+                oldValue, value, oldDefaultValue, newDefaultValue);\n         checkNewMemoryUsagePerPackageLocked(packageName, newSize);\n \n         Setting newState;\n@@ -559,8 +561,12 @@ final class SettingsState {\n         }\n \n         Setting oldState = mSettings.remove(name);\n-        int newSize = getNewMemoryUsagePerPackageLocked(oldState.packageName, oldState.value,\n-                null, oldState.defaultValue, null);\n+        if (oldState == null) {\n+            return false;\n+        }\n+        int newSize = getNewMemoryUsagePerPackageLocked(oldState.packageName,\n+                -name.length() /* deltaKeySize */,\n+                oldState.value, null, oldState.defaultValue, null);\n \n         FrameworkStatsLog.write(FrameworkStatsLog.SETTING_CHANGED, name, /* value= */ \"\",\n                 /* newValue= */ \"\", oldState.value, /* tag */ \"\", false, getUserIdFromKey(mKey),\n@@ -583,15 +589,16 @@ final class SettingsState {\n         }\n \n         Setting setting = mSettings.get(name);\n+        if (setting == null) {\n+            return false;\n+        }\n \n         Setting oldSetting = new Setting(setting);\n         String oldValue = setting.getValue();\n         String oldDefaultValue = setting.getDefaultValue();\n-        String newValue = oldDefaultValue;\n-        String newDefaultValue = oldDefaultValue;\n \n-        int newSize = getNewMemoryUsagePerPackageLocked(setting.packageName, oldValue,\n-                newValue, oldDefaultValue, newDefaultValue);\n+        int newSize = getNewMemoryUsagePerPackageLocked(setting.packageName, 0, oldValue,\n+                oldDefaultValue, oldDefaultValue, oldDefaultValue);\n         checkNewMemoryUsagePerPackageLocked(setting.packageName, newSize);\n \n         if (!setting.reset()) {\n@@ -725,8 +732,8 @@ final class SettingsState {\n     }\n \n     @GuardedBy(\"mLock\")\n-    private int getNewMemoryUsagePerPackageLocked(String packageName, String oldValue,\n-            String newValue, String oldDefaultValue, String newDefaultValue) {\n+    private int getNewMemoryUsagePerPackageLocked(String packageName, int deltaKeySize,\n+            String oldValue, String newValue, String oldDefaultValue, String newDefaultValue) {\n         if (isExemptFromMemoryUsageCap(packageName)) {\n             return 0;\n         }\n@@ -735,7 +742,7 @@ final class SettingsState {\n         final int newValueSize = (newValue != null) ? newValue.length() : 0;\n         final int oldDefaultValueSize = (oldDefaultValue != null) ? oldDefaultValue.length() : 0;\n         final int newDefaultValueSize = (newDefaultValue != null) ? newDefaultValue.length() : 0;\n-        final int deltaSize = newValueSize + newDefaultValueSize\n+        final int deltaSize = deltaKeySize + newValueSize + newDefaultValueSize\n                 - oldValueSize - oldDefaultValueSize;\n         return Math.max((currentSize != null) ? currentSize + deltaSize : deltaSize, 0);\n     }\n@@ -1556,4 +1563,11 @@ final class SettingsState {\n         }\n         return false;\n     }\n+\n+    @VisibleForTesting\n+    public int getMemoryUsage(String packageName) {\n+        synchronized (mLock) {\n+            return mPackageToMemoryUsage.getOrDefault(packageName, 0);\n+        }\n+    }\n }\n",
    "added_lines": 27,
    "deleted_lines": 13,
    "changed_methods": "SettingsState::getNewMemoryUsagePerPackageLocked, SettingsState::insertSettingLocked, SettingsState::resetSettingDefaultValueLocked, SettingsState::resetSettingLocked, SettingsState::getMemoryUsage, SettingsState::getNewMemoryUsagePerPackageLocked, SettingsState::deleteSettingLocked"
   },
   {
    "filename": "SettingsStateTest.java",
    "diff": "@@ -295,7 +295,7 @@ public class SettingsStateTest extends AndroidTestCase {\n         settingsState.deleteSettingLocked(SETTING_NAME);\n \n         // Should not throw if usage is under the cap\n-        settingsState.insertSettingLocked(SETTING_NAME, Strings.repeat(\"A\", 19999),\n+        settingsState.insertSettingLocked(SETTING_NAME, Strings.repeat(\"A\", 19975),\n                 null, false, \"p1\");\n         settingsState.deleteSettingLocked(SETTING_NAME);\n         try {\n@@ -313,5 +313,97 @@ public class SettingsStateTest extends AndroidTestCase {\n             assertTrue(ex.getMessage().contains(\"p1\"));\n         }\n         assertTrue(settingsState.getSettingLocked(SETTING_NAME).isNull());\n+        try {\n+            settingsState.insertSettingLocked(Strings.repeat(\"A\", 20001), \"\",\n+                    null, false, \"p1\");\n+            fail(\"Should throw because it exceeded per package memory usage\");\n+        } catch (IllegalStateException ex) {\n+            assertTrue(ex.getMessage().contains(\"You are adding too many system settings\"));\n+        }\n+    }\n+\n+    public void testMemoryUsagePerPackage() {\n+        SettingsState settingsState = new SettingsState(getContext(), mLock, mSettingsFile, 1,\n+                SettingsState.MAX_BYTES_PER_APP_PACKAGE_LIMITED, Looper.getMainLooper());\n+\n+        // Test inserting one key with default\n+        final String testKey1 = SETTING_NAME;\n+        final String testValue1 = Strings.repeat(\"A\", 100);\n+        settingsState.insertSettingLocked(testKey1, testValue1, null, true, TEST_PACKAGE);\n+        int expectedMemUsage = testKey1.length() + testValue1.length()\n+                + testValue1.length() /* size for default */;\n+        assertEquals(expectedMemUsage, settingsState.getMemoryUsage(TEST_PACKAGE));\n+\n+        // Test inserting another key\n+        final String testKey2 = SETTING_NAME + \"2\";\n+        settingsState.insertSettingLocked(testKey2, testValue1, null, false, TEST_PACKAGE);\n+        expectedMemUsage += testKey2.length() + testValue1.length();\n+        assertEquals(expectedMemUsage, settingsState.getMemoryUsage(TEST_PACKAGE));\n+\n+        // Test updating first key with new default\n+        final String testValue2 = Strings.repeat(\"A\", 300);\n+        settingsState.insertSettingLocked(testKey1, testValue2, null, true, TEST_PACKAGE);\n+        expectedMemUsage += (testValue2.length() - testValue1.length()) * 2;\n+        assertEquals(expectedMemUsage, settingsState.getMemoryUsage(TEST_PACKAGE));\n+\n+        // Test updating first key without new default\n+        final String testValue3 = Strings.repeat(\"A\", 50);\n+        settingsState.insertSettingLocked(testKey1, testValue3, null, false, TEST_PACKAGE);\n+        expectedMemUsage -= testValue2.length() - testValue3.length();\n+        assertEquals(expectedMemUsage, settingsState.getMemoryUsage(TEST_PACKAGE));\n+\n+        // Test updating second key\n+        settingsState.insertSettingLocked(testKey2, testValue2, null, false, TEST_PACKAGE);\n+        expectedMemUsage -= testValue1.length() - testValue2.length();\n+        assertEquals(expectedMemUsage, settingsState.getMemoryUsage(TEST_PACKAGE));\n+\n+        // Test resetting key\n+        settingsState.resetSettingLocked(testKey1);\n+        expectedMemUsage += testValue2.length() - testValue3.length();\n+        assertEquals(expectedMemUsage, settingsState.getMemoryUsage(TEST_PACKAGE));\n+\n+        // Test resetting default value\n+        settingsState.resetSettingDefaultValueLocked(testKey1);\n+        expectedMemUsage -= testValue2.length();\n+        assertEquals(expectedMemUsage, settingsState.getMemoryUsage(TEST_PACKAGE));\n+\n+        // Test deletion\n+        settingsState.deleteSettingLocked(testKey2);\n+        expectedMemUsage -= testValue2.length() + testKey2.length() /* key is deleted too */;\n+        assertEquals(expectedMemUsage, settingsState.getMemoryUsage(TEST_PACKAGE));\n+\n+        // Test another package with a different key\n+        final String testPackage2 = TEST_PACKAGE + \"2\";\n+        final String testKey3 = SETTING_NAME + \"3\";\n+        settingsState.insertSettingLocked(testKey3, testValue1, null, true, testPackage2);\n+        assertEquals(expectedMemUsage, settingsState.getMemoryUsage(TEST_PACKAGE));\n+        final int expectedMemUsage2 = testKey3.length() + testValue1.length() * 2;\n+        assertEquals(expectedMemUsage2, settingsState.getMemoryUsage(testPackage2));\n+\n+        // Test system package\n+        settingsState.insertSettingLocked(testKey1, testValue1, null, true, SYSTEM_PACKAGE);\n+        assertEquals(expectedMemUsage, settingsState.getMemoryUsage(TEST_PACKAGE));\n+        assertEquals(expectedMemUsage2, settingsState.getMemoryUsage(testPackage2));\n+        assertEquals(0, settingsState.getMemoryUsage(SYSTEM_PACKAGE));\n+\n+        // Test invalid value\n+        try {\n+            settingsState.insertSettingLocked(testKey1, Strings.repeat(\"A\", 20001), null, false,\n+                    TEST_PACKAGE);\n+            fail(\"Should throw because it exceeded per package memory usage\");\n+        } catch (IllegalStateException ex) {\n+            assertTrue(ex.getMessage().contains(\"You are adding too many system settings\"));\n+        }\n+        assertEquals(expectedMemUsage, settingsState.getMemoryUsage(TEST_PACKAGE));\n+\n+        // Test invalid key\n+        try {\n+            settingsState.insertSettingLocked(Strings.repeat(\"A\", 20001), \"\", null, false,\n+                    TEST_PACKAGE);\n+            fail(\"Should throw because it exceeded per package memory usage\");\n+        } catch (IllegalStateException ex) {\n+            assertTrue(ex.getMessage().contains(\"You are adding too many system settings\"));\n+        }\n+        assertEquals(expectedMemUsage, settingsState.getMemoryUsage(TEST_PACKAGE));\n     }\n }\n",
    "added_lines": 93,
    "deleted_lines": 1,
    "changed_methods": "SettingsStateTest::testInsertSetting_memoryUsage, SettingsStateTest::testMemoryUsagePerPackage"
   }
  ]
 },
 {
  "hash": "b1dacbcb32d699c8e68ec630c25a457d9684ef03",
  "commit": "[RESTRICT AUTOMERGE] Trim the activity info of another uid if no privilege\n\nThe activity info could be from another uid which is different\nfrom the app that hosts the task. The information should be\ntrimmed if the caller app doesn't have the privilege.\n\nBug: 243130512\nTest: verified locally\nTest: atest RecentTasksTest\nChange-Id: Ia343ac70e5bb9aeae718fca6674e1ca491a14512\nMerged-In: Ia343ac70e5bb9aeae718fca6674e1ca491a14512\n(cherry picked from commit fa8d6362348738284b3f33a13e1fa5cdd0af67b2)\nMerged-In: Ia343ac70e5bb9aeae718fca6674e1ca491a14512",
  "files": [
   {
    "filename": "AppTaskImpl.java",
    "diff": "@@ -84,7 +84,7 @@ class AppTaskImpl extends IAppTask.Stub {\n                     throw new IllegalArgumentException(\"Unable to find task ID \" + mTaskId);\n                 }\n                 return mService.getRecentTasks().createRecentTaskInfo(task,\n-                        false /* stripExtras */);\n+                        false /* stripExtras */, true /* getTasksAllowed */);\n             } finally {\n                 Binder.restoreCallingIdentity(origId);\n             }\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "AppTaskImpl::getTaskInfo"
   },
   {
    "filename": "RecentTasks.java",
    "diff": "@@ -974,7 +974,7 @@ class RecentTasks {\n                 continue;\n             }\n \n-            res.add(createRecentTaskInfo(task, true /* stripExtras */));\n+            res.add(createRecentTaskInfo(task, true /* stripExtras */, getTasksAllowed));\n         }\n         return res;\n     }\n@@ -1890,7 +1890,8 @@ class RecentTasks {\n     /**\n      * Creates a new RecentTaskInfo from a Task.\n      */\n-    ActivityManager.RecentTaskInfo createRecentTaskInfo(Task tr, boolean stripExtras) {\n+    ActivityManager.RecentTaskInfo createRecentTaskInfo(Task tr, boolean stripExtras,\n+            boolean getTasksAllowed) {\n         final ActivityManager.RecentTaskInfo rti = new ActivityManager.RecentTaskInfo();\n         // If the recent Task is detached, we consider it will be re-attached to the default\n         // TaskDisplayArea because we currently only support recent overview in the default TDA.\n@@ -1902,6 +1903,9 @@ class RecentTasks {\n         rti.id = rti.isRunning ? rti.taskId : INVALID_TASK_ID;\n         rti.persistentId = rti.taskId;\n         rti.lastSnapshotData.set(tr.mLastTaskSnapshotData);\n+        if (!getTasksAllowed) {\n+            Task.trimIneffectiveInfo(tr, rti);\n+        }\n \n         // Fill in organized child task info for the task created by organizer.\n         if (tr.mCreatedByOrganizer) {\n",
    "added_lines": 6,
    "deleted_lines": 2,
    "changed_methods": "RecentTasks::createRecentTaskInfo, RecentTasks::getRecentTasksImpl, RecentTasks::createRecentTaskInfo"
   },
   {
    "filename": "RunningTasks.java",
    "diff": "@@ -150,6 +150,10 @@ class RunningTasks {\n         task.fillTaskInfo(rti, !mKeepIntentExtra);\n         // Fill in some deprecated values\n         rti.id = rti.taskId;\n+\n+        if (!mAllowed) {\n+            Task.trimIneffectiveInfo(task, rti);\n+        }\n         return rti;\n     }\n }\n",
    "added_lines": 4,
    "deleted_lines": 0,
    "changed_methods": "RunningTasks::createRunningTaskInfo"
   },
   {
    "filename": "Task.java",
    "diff": "@@ -3484,6 +3484,27 @@ class Task extends TaskFragment {\n         info.mTopActivityLocusId = topRecord != null ? topRecord.getLocusId() : null;\n     }\n \n+    /**\n+     * Removes the activity info if the activity belongs to a different uid, which is\n+     * different from the app that hosts the task.\n+     */\n+    static void trimIneffectiveInfo(Task task, TaskInfo info) {\n+        final ActivityRecord baseActivity = task.getActivity(r -> !r.finishing,\n+                false /* traverseTopToBottom */);\n+        final int baseActivityUid =\n+                baseActivity != null ? baseActivity.getUid() : task.effectiveUid;\n+\n+        if (info.topActivityInfo != null\n+                && task.effectiveUid != info.topActivityInfo.applicationInfo.uid) {\n+            info.topActivity = null;\n+            info.topActivityInfo = null;\n+        }\n+\n+        if (task.effectiveUid != baseActivityUid) {\n+            info.baseActivity = null;\n+        }\n+    }\n+\n     @Nullable PictureInPictureParams getPictureInPictureParams() {\n         return getPictureInPictureParams(getTopMostTask());\n     }\n",
    "added_lines": 21,
    "deleted_lines": 0,
    "changed_methods": "Task::trimIneffectiveInfo"
   },
   {
    "filename": "RecentTasksTest.java",
    "diff": "@@ -30,6 +30,7 @@ import static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;\n import static android.content.pm.ActivityInfo.LAUNCH_MULTIPLE;\n import static android.content.pm.ActivityInfo.LAUNCH_SINGLE_INSTANCE;\n import static android.content.res.Configuration.ORIENTATION_PORTRAIT;\n+import static android.os.Process.NOBODY_UID;\n \n import static com.android.dx.mockito.inline.extended.ExtendedMockito.doNothing;\n import static com.android.dx.mockito.inline.extended.ExtendedMockito.doReturn;\n@@ -1195,21 +1196,35 @@ public class RecentTasksTest extends WindowTestsBase {\n \n     @Test\n     public void testCreateRecentTaskInfo_detachedTask() {\n-        final Task task = createTaskBuilder(\".Task\").setCreateActivity(true).build();\n+        final Task task = createTaskBuilder(\".Task\").build();\n+        new ActivityBuilder(mSupervisor.mService)\n+                .setTask(task)\n+                .setUid(NOBODY_UID)\n+                .setComponent(new ComponentName(\"com.foo\", \".BarActivity\"))\n+                .build();\n         final TaskDisplayArea tda = task.getDisplayArea();\n \n         assertTrue(task.isAttached());\n         assertTrue(task.supportsMultiWindow());\n \n-        RecentTaskInfo info = mRecentTasks.createRecentTaskInfo(task, true);\n+        RecentTaskInfo info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,\n+                true /* getTasksAllowed */);\n \n         assertTrue(info.supportsMultiWindow);\n         assertTrue(info.supportsSplitScreenMultiWindow);\n \n+        info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,\n+                false /* getTasksAllowed */);\n+\n+        assertTrue(info.topActivity == null);\n+        assertTrue(info.topActivityInfo == null);\n+        assertTrue(info.baseActivity == null);\n+\n         // The task can be put in split screen even if it is not attached now.\n         task.removeImmediately();\n \n-        info = mRecentTasks.createRecentTaskInfo(task, true);\n+        info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,\n+                true /* getTasksAllowed */);\n \n         assertTrue(info.supportsMultiWindow);\n         assertTrue(info.supportsSplitScreenMultiWindow);\n@@ -1219,7 +1234,8 @@ public class RecentTasksTest extends WindowTestsBase {\n         doReturn(false).when(tda).supportsNonResizableMultiWindow();\n         doReturn(false).when(task).isResizeable();\n \n-        info = mRecentTasks.createRecentTaskInfo(task, true);\n+        info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,\n+                true /* getTasksAllowed */);\n \n         assertFalse(info.supportsMultiWindow);\n         assertFalse(info.supportsSplitScreenMultiWindow);\n@@ -1228,7 +1244,8 @@ public class RecentTasksTest extends WindowTestsBase {\n         // the device supports it.\n         doReturn(true).when(tda).supportsNonResizableMultiWindow();\n \n-        info = mRecentTasks.createRecentTaskInfo(task, true);\n+        info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,\n+                true /* getTasksAllowed */);\n \n         assertTrue(info.supportsMultiWindow);\n         assertTrue(info.supportsSplitScreenMultiWindow);\n",
    "added_lines": 22,
    "deleted_lines": 5,
    "changed_methods": "RecentTasksTest::testCreateRecentTaskInfo_detachedTask"
   }
  ]
 },
 {
  "hash": "b1dacbcb32d699c8e68ec630c25a457d9684ef03",
  "commit": "[RESTRICT AUTOMERGE] Trim the activity info of another uid if no privilege\n\nThe activity info could be from another uid which is different\nfrom the app that hosts the task. The information should be\ntrimmed if the caller app doesn't have the privilege.\n\nBug: 243130512\nTest: verified locally\nTest: atest RecentTasksTest\nChange-Id: Ia343ac70e5bb9aeae718fca6674e1ca491a14512\nMerged-In: Ia343ac70e5bb9aeae718fca6674e1ca491a14512\n(cherry picked from commit fa8d6362348738284b3f33a13e1fa5cdd0af67b2)\nMerged-In: Ia343ac70e5bb9aeae718fca6674e1ca491a14512",
  "files": [
   {
    "filename": "AppTaskImpl.java",
    "diff": "@@ -84,7 +84,7 @@ class AppTaskImpl extends IAppTask.Stub {\n                     throw new IllegalArgumentException(\"Unable to find task ID \" + mTaskId);\n                 }\n                 return mService.getRecentTasks().createRecentTaskInfo(task,\n-                        false /* stripExtras */);\n+                        false /* stripExtras */, true /* getTasksAllowed */);\n             } finally {\n                 Binder.restoreCallingIdentity(origId);\n             }\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "AppTaskImpl::getTaskInfo"
   },
   {
    "filename": "RecentTasks.java",
    "diff": "@@ -974,7 +974,7 @@ class RecentTasks {\n                 continue;\n             }\n \n-            res.add(createRecentTaskInfo(task, true /* stripExtras */));\n+            res.add(createRecentTaskInfo(task, true /* stripExtras */, getTasksAllowed));\n         }\n         return res;\n     }\n@@ -1890,7 +1890,8 @@ class RecentTasks {\n     /**\n      * Creates a new RecentTaskInfo from a Task.\n      */\n-    ActivityManager.RecentTaskInfo createRecentTaskInfo(Task tr, boolean stripExtras) {\n+    ActivityManager.RecentTaskInfo createRecentTaskInfo(Task tr, boolean stripExtras,\n+            boolean getTasksAllowed) {\n         final ActivityManager.RecentTaskInfo rti = new ActivityManager.RecentTaskInfo();\n         // If the recent Task is detached, we consider it will be re-attached to the default\n         // TaskDisplayArea because we currently only support recent overview in the default TDA.\n@@ -1902,6 +1903,9 @@ class RecentTasks {\n         rti.id = rti.isRunning ? rti.taskId : INVALID_TASK_ID;\n         rti.persistentId = rti.taskId;\n         rti.lastSnapshotData.set(tr.mLastTaskSnapshotData);\n+        if (!getTasksAllowed) {\n+            Task.trimIneffectiveInfo(tr, rti);\n+        }\n \n         // Fill in organized child task info for the task created by organizer.\n         if (tr.mCreatedByOrganizer) {\n",
    "added_lines": 6,
    "deleted_lines": 2,
    "changed_methods": "RecentTasks::createRecentTaskInfo, RecentTasks::getRecentTasksImpl, RecentTasks::createRecentTaskInfo"
   },
   {
    "filename": "RunningTasks.java",
    "diff": "@@ -150,6 +150,10 @@ class RunningTasks {\n         task.fillTaskInfo(rti, !mKeepIntentExtra);\n         // Fill in some deprecated values\n         rti.id = rti.taskId;\n+\n+        if (!mAllowed) {\n+            Task.trimIneffectiveInfo(task, rti);\n+        }\n         return rti;\n     }\n }\n",
    "added_lines": 4,
    "deleted_lines": 0,
    "changed_methods": "RunningTasks::createRunningTaskInfo"
   },
   {
    "filename": "Task.java",
    "diff": "@@ -3484,6 +3484,27 @@ class Task extends TaskFragment {\n         info.mTopActivityLocusId = topRecord != null ? topRecord.getLocusId() : null;\n     }\n \n+    /**\n+     * Removes the activity info if the activity belongs to a different uid, which is\n+     * different from the app that hosts the task.\n+     */\n+    static void trimIneffectiveInfo(Task task, TaskInfo info) {\n+        final ActivityRecord baseActivity = task.getActivity(r -> !r.finishing,\n+                false /* traverseTopToBottom */);\n+        final int baseActivityUid =\n+                baseActivity != null ? baseActivity.getUid() : task.effectiveUid;\n+\n+        if (info.topActivityInfo != null\n+                && task.effectiveUid != info.topActivityInfo.applicationInfo.uid) {\n+            info.topActivity = null;\n+            info.topActivityInfo = null;\n+        }\n+\n+        if (task.effectiveUid != baseActivityUid) {\n+            info.baseActivity = null;\n+        }\n+    }\n+\n     @Nullable PictureInPictureParams getPictureInPictureParams() {\n         return getPictureInPictureParams(getTopMostTask());\n     }\n",
    "added_lines": 21,
    "deleted_lines": 0,
    "changed_methods": "Task::trimIneffectiveInfo"
   },
   {
    "filename": "RecentTasksTest.java",
    "diff": "@@ -30,6 +30,7 @@ import static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;\n import static android.content.pm.ActivityInfo.LAUNCH_MULTIPLE;\n import static android.content.pm.ActivityInfo.LAUNCH_SINGLE_INSTANCE;\n import static android.content.res.Configuration.ORIENTATION_PORTRAIT;\n+import static android.os.Process.NOBODY_UID;\n \n import static com.android.dx.mockito.inline.extended.ExtendedMockito.doNothing;\n import static com.android.dx.mockito.inline.extended.ExtendedMockito.doReturn;\n@@ -1195,21 +1196,35 @@ public class RecentTasksTest extends WindowTestsBase {\n \n     @Test\n     public void testCreateRecentTaskInfo_detachedTask() {\n-        final Task task = createTaskBuilder(\".Task\").setCreateActivity(true).build();\n+        final Task task = createTaskBuilder(\".Task\").build();\n+        new ActivityBuilder(mSupervisor.mService)\n+                .setTask(task)\n+                .setUid(NOBODY_UID)\n+                .setComponent(new ComponentName(\"com.foo\", \".BarActivity\"))\n+                .build();\n         final TaskDisplayArea tda = task.getDisplayArea();\n \n         assertTrue(task.isAttached());\n         assertTrue(task.supportsMultiWindow());\n \n-        RecentTaskInfo info = mRecentTasks.createRecentTaskInfo(task, true);\n+        RecentTaskInfo info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,\n+                true /* getTasksAllowed */);\n \n         assertTrue(info.supportsMultiWindow);\n         assertTrue(info.supportsSplitScreenMultiWindow);\n \n+        info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,\n+                false /* getTasksAllowed */);\n+\n+        assertTrue(info.topActivity == null);\n+        assertTrue(info.topActivityInfo == null);\n+        assertTrue(info.baseActivity == null);\n+\n         // The task can be put in split screen even if it is not attached now.\n         task.removeImmediately();\n \n-        info = mRecentTasks.createRecentTaskInfo(task, true);\n+        info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,\n+                true /* getTasksAllowed */);\n \n         assertTrue(info.supportsMultiWindow);\n         assertTrue(info.supportsSplitScreenMultiWindow);\n@@ -1219,7 +1234,8 @@ public class RecentTasksTest extends WindowTestsBase {\n         doReturn(false).when(tda).supportsNonResizableMultiWindow();\n         doReturn(false).when(task).isResizeable();\n \n-        info = mRecentTasks.createRecentTaskInfo(task, true);\n+        info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,\n+                true /* getTasksAllowed */);\n \n         assertFalse(info.supportsMultiWindow);\n         assertFalse(info.supportsSplitScreenMultiWindow);\n@@ -1228,7 +1244,8 @@ public class RecentTasksTest extends WindowTestsBase {\n         // the device supports it.\n         doReturn(true).when(tda).supportsNonResizableMultiWindow();\n \n-        info = mRecentTasks.createRecentTaskInfo(task, true);\n+        info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,\n+                true /* getTasksAllowed */);\n \n         assertTrue(info.supportsMultiWindow);\n         assertTrue(info.supportsSplitScreenMultiWindow);\n",
    "added_lines": 22,
    "deleted_lines": 5,
    "changed_methods": "RecentTasksTest::testCreateRecentTaskInfo_detachedTask"
   }
  ]
 },
 {
  "hash": "b1dacbcb32d699c8e68ec630c25a457d9684ef03",
  "commit": "[RESTRICT AUTOMERGE] Trim the activity info of another uid if no privilege\n\nThe activity info could be from another uid which is different\nfrom the app that hosts the task. The information should be\ntrimmed if the caller app doesn't have the privilege.\n\nBug: 243130512\nTest: verified locally\nTest: atest RecentTasksTest\nChange-Id: Ia343ac70e5bb9aeae718fca6674e1ca491a14512\nMerged-In: Ia343ac70e5bb9aeae718fca6674e1ca491a14512\n(cherry picked from commit fa8d6362348738284b3f33a13e1fa5cdd0af67b2)\nMerged-In: Ia343ac70e5bb9aeae718fca6674e1ca491a14512",
  "files": [
   {
    "filename": "AppTaskImpl.java",
    "diff": "@@ -84,7 +84,7 @@ class AppTaskImpl extends IAppTask.Stub {\n                     throw new IllegalArgumentException(\"Unable to find task ID \" + mTaskId);\n                 }\n                 return mService.getRecentTasks().createRecentTaskInfo(task,\n-                        false /* stripExtras */);\n+                        false /* stripExtras */, true /* getTasksAllowed */);\n             } finally {\n                 Binder.restoreCallingIdentity(origId);\n             }\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "AppTaskImpl::getTaskInfo"
   },
   {
    "filename": "RecentTasks.java",
    "diff": "@@ -974,7 +974,7 @@ class RecentTasks {\n                 continue;\n             }\n \n-            res.add(createRecentTaskInfo(task, true /* stripExtras */));\n+            res.add(createRecentTaskInfo(task, true /* stripExtras */, getTasksAllowed));\n         }\n         return res;\n     }\n@@ -1890,7 +1890,8 @@ class RecentTasks {\n     /**\n      * Creates a new RecentTaskInfo from a Task.\n      */\n-    ActivityManager.RecentTaskInfo createRecentTaskInfo(Task tr, boolean stripExtras) {\n+    ActivityManager.RecentTaskInfo createRecentTaskInfo(Task tr, boolean stripExtras,\n+            boolean getTasksAllowed) {\n         final ActivityManager.RecentTaskInfo rti = new ActivityManager.RecentTaskInfo();\n         // If the recent Task is detached, we consider it will be re-attached to the default\n         // TaskDisplayArea because we currently only support recent overview in the default TDA.\n@@ -1902,6 +1903,9 @@ class RecentTasks {\n         rti.id = rti.isRunning ? rti.taskId : INVALID_TASK_ID;\n         rti.persistentId = rti.taskId;\n         rti.lastSnapshotData.set(tr.mLastTaskSnapshotData);\n+        if (!getTasksAllowed) {\n+            Task.trimIneffectiveInfo(tr, rti);\n+        }\n \n         // Fill in organized child task info for the task created by organizer.\n         if (tr.mCreatedByOrganizer) {\n",
    "added_lines": 6,
    "deleted_lines": 2,
    "changed_methods": "RecentTasks::createRecentTaskInfo, RecentTasks::getRecentTasksImpl, RecentTasks::createRecentTaskInfo"
   },
   {
    "filename": "RunningTasks.java",
    "diff": "@@ -150,6 +150,10 @@ class RunningTasks {\n         task.fillTaskInfo(rti, !mKeepIntentExtra);\n         // Fill in some deprecated values\n         rti.id = rti.taskId;\n+\n+        if (!mAllowed) {\n+            Task.trimIneffectiveInfo(task, rti);\n+        }\n         return rti;\n     }\n }\n",
    "added_lines": 4,
    "deleted_lines": 0,
    "changed_methods": "RunningTasks::createRunningTaskInfo"
   },
   {
    "filename": "Task.java",
    "diff": "@@ -3484,6 +3484,27 @@ class Task extends TaskFragment {\n         info.mTopActivityLocusId = topRecord != null ? topRecord.getLocusId() : null;\n     }\n \n+    /**\n+     * Removes the activity info if the activity belongs to a different uid, which is\n+     * different from the app that hosts the task.\n+     */\n+    static void trimIneffectiveInfo(Task task, TaskInfo info) {\n+        final ActivityRecord baseActivity = task.getActivity(r -> !r.finishing,\n+                false /* traverseTopToBottom */);\n+        final int baseActivityUid =\n+                baseActivity != null ? baseActivity.getUid() : task.effectiveUid;\n+\n+        if (info.topActivityInfo != null\n+                && task.effectiveUid != info.topActivityInfo.applicationInfo.uid) {\n+            info.topActivity = null;\n+            info.topActivityInfo = null;\n+        }\n+\n+        if (task.effectiveUid != baseActivityUid) {\n+            info.baseActivity = null;\n+        }\n+    }\n+\n     @Nullable PictureInPictureParams getPictureInPictureParams() {\n         return getPictureInPictureParams(getTopMostTask());\n     }\n",
    "added_lines": 21,
    "deleted_lines": 0,
    "changed_methods": "Task::trimIneffectiveInfo"
   },
   {
    "filename": "RecentTasksTest.java",
    "diff": "@@ -30,6 +30,7 @@ import static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;\n import static android.content.pm.ActivityInfo.LAUNCH_MULTIPLE;\n import static android.content.pm.ActivityInfo.LAUNCH_SINGLE_INSTANCE;\n import static android.content.res.Configuration.ORIENTATION_PORTRAIT;\n+import static android.os.Process.NOBODY_UID;\n \n import static com.android.dx.mockito.inline.extended.ExtendedMockito.doNothing;\n import static com.android.dx.mockito.inline.extended.ExtendedMockito.doReturn;\n@@ -1195,21 +1196,35 @@ public class RecentTasksTest extends WindowTestsBase {\n \n     @Test\n     public void testCreateRecentTaskInfo_detachedTask() {\n-        final Task task = createTaskBuilder(\".Task\").setCreateActivity(true).build();\n+        final Task task = createTaskBuilder(\".Task\").build();\n+        new ActivityBuilder(mSupervisor.mService)\n+                .setTask(task)\n+                .setUid(NOBODY_UID)\n+                .setComponent(new ComponentName(\"com.foo\", \".BarActivity\"))\n+                .build();\n         final TaskDisplayArea tda = task.getDisplayArea();\n \n         assertTrue(task.isAttached());\n         assertTrue(task.supportsMultiWindow());\n \n-        RecentTaskInfo info = mRecentTasks.createRecentTaskInfo(task, true);\n+        RecentTaskInfo info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,\n+                true /* getTasksAllowed */);\n \n         assertTrue(info.supportsMultiWindow);\n         assertTrue(info.supportsSplitScreenMultiWindow);\n \n+        info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,\n+                false /* getTasksAllowed */);\n+\n+        assertTrue(info.topActivity == null);\n+        assertTrue(info.topActivityInfo == null);\n+        assertTrue(info.baseActivity == null);\n+\n         // The task can be put in split screen even if it is not attached now.\n         task.removeImmediately();\n \n-        info = mRecentTasks.createRecentTaskInfo(task, true);\n+        info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,\n+                true /* getTasksAllowed */);\n \n         assertTrue(info.supportsMultiWindow);\n         assertTrue(info.supportsSplitScreenMultiWindow);\n@@ -1219,7 +1234,8 @@ public class RecentTasksTest extends WindowTestsBase {\n         doReturn(false).when(tda).supportsNonResizableMultiWindow();\n         doReturn(false).when(task).isResizeable();\n \n-        info = mRecentTasks.createRecentTaskInfo(task, true);\n+        info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,\n+                true /* getTasksAllowed */);\n \n         assertFalse(info.supportsMultiWindow);\n         assertFalse(info.supportsSplitScreenMultiWindow);\n@@ -1228,7 +1244,8 @@ public class RecentTasksTest extends WindowTestsBase {\n         // the device supports it.\n         doReturn(true).when(tda).supportsNonResizableMultiWindow();\n \n-        info = mRecentTasks.createRecentTaskInfo(task, true);\n+        info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,\n+                true /* getTasksAllowed */);\n \n         assertTrue(info.supportsMultiWindow);\n         assertTrue(info.supportsSplitScreenMultiWindow);\n",
    "added_lines": 22,
    "deleted_lines": 5,
    "changed_methods": "RecentTasksTest::testCreateRecentTaskInfo_detachedTask"
   }
  ]
 },
 {
  "hash": "b1dacbcb32d699c8e68ec630c25a457d9684ef03",
  "commit": "[RESTRICT AUTOMERGE] Trim the activity info of another uid if no privilege\n\nThe activity info could be from another uid which is different\nfrom the app that hosts the task. The information should be\ntrimmed if the caller app doesn't have the privilege.\n\nBug: 243130512\nTest: verified locally\nTest: atest RecentTasksTest\nChange-Id: Ia343ac70e5bb9aeae718fca6674e1ca491a14512\nMerged-In: Ia343ac70e5bb9aeae718fca6674e1ca491a14512\n(cherry picked from commit fa8d6362348738284b3f33a13e1fa5cdd0af67b2)\nMerged-In: Ia343ac70e5bb9aeae718fca6674e1ca491a14512",
  "files": [
   {
    "filename": "AppTaskImpl.java",
    "diff": "@@ -84,7 +84,7 @@ class AppTaskImpl extends IAppTask.Stub {\n                     throw new IllegalArgumentException(\"Unable to find task ID \" + mTaskId);\n                 }\n                 return mService.getRecentTasks().createRecentTaskInfo(task,\n-                        false /* stripExtras */);\n+                        false /* stripExtras */, true /* getTasksAllowed */);\n             } finally {\n                 Binder.restoreCallingIdentity(origId);\n             }\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "AppTaskImpl::getTaskInfo"
   },
   {
    "filename": "RecentTasks.java",
    "diff": "@@ -974,7 +974,7 @@ class RecentTasks {\n                 continue;\n             }\n \n-            res.add(createRecentTaskInfo(task, true /* stripExtras */));\n+            res.add(createRecentTaskInfo(task, true /* stripExtras */, getTasksAllowed));\n         }\n         return res;\n     }\n@@ -1890,7 +1890,8 @@ class RecentTasks {\n     /**\n      * Creates a new RecentTaskInfo from a Task.\n      */\n-    ActivityManager.RecentTaskInfo createRecentTaskInfo(Task tr, boolean stripExtras) {\n+    ActivityManager.RecentTaskInfo createRecentTaskInfo(Task tr, boolean stripExtras,\n+            boolean getTasksAllowed) {\n         final ActivityManager.RecentTaskInfo rti = new ActivityManager.RecentTaskInfo();\n         // If the recent Task is detached, we consider it will be re-attached to the default\n         // TaskDisplayArea because we currently only support recent overview in the default TDA.\n@@ -1902,6 +1903,9 @@ class RecentTasks {\n         rti.id = rti.isRunning ? rti.taskId : INVALID_TASK_ID;\n         rti.persistentId = rti.taskId;\n         rti.lastSnapshotData.set(tr.mLastTaskSnapshotData);\n+        if (!getTasksAllowed) {\n+            Task.trimIneffectiveInfo(tr, rti);\n+        }\n \n         // Fill in organized child task info for the task created by organizer.\n         if (tr.mCreatedByOrganizer) {\n",
    "added_lines": 6,
    "deleted_lines": 2,
    "changed_methods": "RecentTasks::createRecentTaskInfo, RecentTasks::getRecentTasksImpl, RecentTasks::createRecentTaskInfo"
   },
   {
    "filename": "RunningTasks.java",
    "diff": "@@ -150,6 +150,10 @@ class RunningTasks {\n         task.fillTaskInfo(rti, !mKeepIntentExtra);\n         // Fill in some deprecated values\n         rti.id = rti.taskId;\n+\n+        if (!mAllowed) {\n+            Task.trimIneffectiveInfo(task, rti);\n+        }\n         return rti;\n     }\n }\n",
    "added_lines": 4,
    "deleted_lines": 0,
    "changed_methods": "RunningTasks::createRunningTaskInfo"
   },
   {
    "filename": "Task.java",
    "diff": "@@ -3484,6 +3484,27 @@ class Task extends TaskFragment {\n         info.mTopActivityLocusId = topRecord != null ? topRecord.getLocusId() : null;\n     }\n \n+    /**\n+     * Removes the activity info if the activity belongs to a different uid, which is\n+     * different from the app that hosts the task.\n+     */\n+    static void trimIneffectiveInfo(Task task, TaskInfo info) {\n+        final ActivityRecord baseActivity = task.getActivity(r -> !r.finishing,\n+                false /* traverseTopToBottom */);\n+        final int baseActivityUid =\n+                baseActivity != null ? baseActivity.getUid() : task.effectiveUid;\n+\n+        if (info.topActivityInfo != null\n+                && task.effectiveUid != info.topActivityInfo.applicationInfo.uid) {\n+            info.topActivity = null;\n+            info.topActivityInfo = null;\n+        }\n+\n+        if (task.effectiveUid != baseActivityUid) {\n+            info.baseActivity = null;\n+        }\n+    }\n+\n     @Nullable PictureInPictureParams getPictureInPictureParams() {\n         return getPictureInPictureParams(getTopMostTask());\n     }\n",
    "added_lines": 21,
    "deleted_lines": 0,
    "changed_methods": "Task::trimIneffectiveInfo"
   },
   {
    "filename": "RecentTasksTest.java",
    "diff": "@@ -30,6 +30,7 @@ import static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;\n import static android.content.pm.ActivityInfo.LAUNCH_MULTIPLE;\n import static android.content.pm.ActivityInfo.LAUNCH_SINGLE_INSTANCE;\n import static android.content.res.Configuration.ORIENTATION_PORTRAIT;\n+import static android.os.Process.NOBODY_UID;\n \n import static com.android.dx.mockito.inline.extended.ExtendedMockito.doNothing;\n import static com.android.dx.mockito.inline.extended.ExtendedMockito.doReturn;\n@@ -1195,21 +1196,35 @@ public class RecentTasksTest extends WindowTestsBase {\n \n     @Test\n     public void testCreateRecentTaskInfo_detachedTask() {\n-        final Task task = createTaskBuilder(\".Task\").setCreateActivity(true).build();\n+        final Task task = createTaskBuilder(\".Task\").build();\n+        new ActivityBuilder(mSupervisor.mService)\n+                .setTask(task)\n+                .setUid(NOBODY_UID)\n+                .setComponent(new ComponentName(\"com.foo\", \".BarActivity\"))\n+                .build();\n         final TaskDisplayArea tda = task.getDisplayArea();\n \n         assertTrue(task.isAttached());\n         assertTrue(task.supportsMultiWindow());\n \n-        RecentTaskInfo info = mRecentTasks.createRecentTaskInfo(task, true);\n+        RecentTaskInfo info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,\n+                true /* getTasksAllowed */);\n \n         assertTrue(info.supportsMultiWindow);\n         assertTrue(info.supportsSplitScreenMultiWindow);\n \n+        info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,\n+                false /* getTasksAllowed */);\n+\n+        assertTrue(info.topActivity == null);\n+        assertTrue(info.topActivityInfo == null);\n+        assertTrue(info.baseActivity == null);\n+\n         // The task can be put in split screen even if it is not attached now.\n         task.removeImmediately();\n \n-        info = mRecentTasks.createRecentTaskInfo(task, true);\n+        info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,\n+                true /* getTasksAllowed */);\n \n         assertTrue(info.supportsMultiWindow);\n         assertTrue(info.supportsSplitScreenMultiWindow);\n@@ -1219,7 +1234,8 @@ public class RecentTasksTest extends WindowTestsBase {\n         doReturn(false).when(tda).supportsNonResizableMultiWindow();\n         doReturn(false).when(task).isResizeable();\n \n-        info = mRecentTasks.createRecentTaskInfo(task, true);\n+        info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,\n+                true /* getTasksAllowed */);\n \n         assertFalse(info.supportsMultiWindow);\n         assertFalse(info.supportsSplitScreenMultiWindow);\n@@ -1228,7 +1244,8 @@ public class RecentTasksTest extends WindowTestsBase {\n         // the device supports it.\n         doReturn(true).when(tda).supportsNonResizableMultiWindow();\n \n-        info = mRecentTasks.createRecentTaskInfo(task, true);\n+        info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,\n+                true /* getTasksAllowed */);\n \n         assertTrue(info.supportsMultiWindow);\n         assertTrue(info.supportsSplitScreenMultiWindow);\n",
    "added_lines": 22,
    "deleted_lines": 5,
    "changed_methods": "RecentTasksTest::testCreateRecentTaskInfo_detachedTask"
   }
  ]
 },
 {
  "hash": "b1dacbcb32d699c8e68ec630c25a457d9684ef03",
  "commit": "[RESTRICT AUTOMERGE] Trim the activity info of another uid if no privilege\n\nThe activity info could be from another uid which is different\nfrom the app that hosts the task. The information should be\ntrimmed if the caller app doesn't have the privilege.\n\nBug: 243130512\nTest: verified locally\nTest: atest RecentTasksTest\nChange-Id: Ia343ac70e5bb9aeae718fca6674e1ca491a14512\nMerged-In: Ia343ac70e5bb9aeae718fca6674e1ca491a14512\n(cherry picked from commit fa8d6362348738284b3f33a13e1fa5cdd0af67b2)\nMerged-In: Ia343ac70e5bb9aeae718fca6674e1ca491a14512",
  "files": [
   {
    "filename": "AppTaskImpl.java",
    "diff": "@@ -84,7 +84,7 @@ class AppTaskImpl extends IAppTask.Stub {\n                     throw new IllegalArgumentException(\"Unable to find task ID \" + mTaskId);\n                 }\n                 return mService.getRecentTasks().createRecentTaskInfo(task,\n-                        false /* stripExtras */);\n+                        false /* stripExtras */, true /* getTasksAllowed */);\n             } finally {\n                 Binder.restoreCallingIdentity(origId);\n             }\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "AppTaskImpl::getTaskInfo"
   },
   {
    "filename": "RecentTasks.java",
    "diff": "@@ -974,7 +974,7 @@ class RecentTasks {\n                 continue;\n             }\n \n-            res.add(createRecentTaskInfo(task, true /* stripExtras */));\n+            res.add(createRecentTaskInfo(task, true /* stripExtras */, getTasksAllowed));\n         }\n         return res;\n     }\n@@ -1890,7 +1890,8 @@ class RecentTasks {\n     /**\n      * Creates a new RecentTaskInfo from a Task.\n      */\n-    ActivityManager.RecentTaskInfo createRecentTaskInfo(Task tr, boolean stripExtras) {\n+    ActivityManager.RecentTaskInfo createRecentTaskInfo(Task tr, boolean stripExtras,\n+            boolean getTasksAllowed) {\n         final ActivityManager.RecentTaskInfo rti = new ActivityManager.RecentTaskInfo();\n         // If the recent Task is detached, we consider it will be re-attached to the default\n         // TaskDisplayArea because we currently only support recent overview in the default TDA.\n@@ -1902,6 +1903,9 @@ class RecentTasks {\n         rti.id = rti.isRunning ? rti.taskId : INVALID_TASK_ID;\n         rti.persistentId = rti.taskId;\n         rti.lastSnapshotData.set(tr.mLastTaskSnapshotData);\n+        if (!getTasksAllowed) {\n+            Task.trimIneffectiveInfo(tr, rti);\n+        }\n \n         // Fill in organized child task info for the task created by organizer.\n         if (tr.mCreatedByOrganizer) {\n",
    "added_lines": 6,
    "deleted_lines": 2,
    "changed_methods": "RecentTasks::createRecentTaskInfo, RecentTasks::getRecentTasksImpl, RecentTasks::createRecentTaskInfo"
   },
   {
    "filename": "RunningTasks.java",
    "diff": "@@ -150,6 +150,10 @@ class RunningTasks {\n         task.fillTaskInfo(rti, !mKeepIntentExtra);\n         // Fill in some deprecated values\n         rti.id = rti.taskId;\n+\n+        if (!mAllowed) {\n+            Task.trimIneffectiveInfo(task, rti);\n+        }\n         return rti;\n     }\n }\n",
    "added_lines": 4,
    "deleted_lines": 0,
    "changed_methods": "RunningTasks::createRunningTaskInfo"
   },
   {
    "filename": "Task.java",
    "diff": "@@ -3484,6 +3484,27 @@ class Task extends TaskFragment {\n         info.mTopActivityLocusId = topRecord != null ? topRecord.getLocusId() : null;\n     }\n \n+    /**\n+     * Removes the activity info if the activity belongs to a different uid, which is\n+     * different from the app that hosts the task.\n+     */\n+    static void trimIneffectiveInfo(Task task, TaskInfo info) {\n+        final ActivityRecord baseActivity = task.getActivity(r -> !r.finishing,\n+                false /* traverseTopToBottom */);\n+        final int baseActivityUid =\n+                baseActivity != null ? baseActivity.getUid() : task.effectiveUid;\n+\n+        if (info.topActivityInfo != null\n+                && task.effectiveUid != info.topActivityInfo.applicationInfo.uid) {\n+            info.topActivity = null;\n+            info.topActivityInfo = null;\n+        }\n+\n+        if (task.effectiveUid != baseActivityUid) {\n+            info.baseActivity = null;\n+        }\n+    }\n+\n     @Nullable PictureInPictureParams getPictureInPictureParams() {\n         return getPictureInPictureParams(getTopMostTask());\n     }\n",
    "added_lines": 21,
    "deleted_lines": 0,
    "changed_methods": "Task::trimIneffectiveInfo"
   },
   {
    "filename": "RecentTasksTest.java",
    "diff": "@@ -30,6 +30,7 @@ import static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;\n import static android.content.pm.ActivityInfo.LAUNCH_MULTIPLE;\n import static android.content.pm.ActivityInfo.LAUNCH_SINGLE_INSTANCE;\n import static android.content.res.Configuration.ORIENTATION_PORTRAIT;\n+import static android.os.Process.NOBODY_UID;\n \n import static com.android.dx.mockito.inline.extended.ExtendedMockito.doNothing;\n import static com.android.dx.mockito.inline.extended.ExtendedMockito.doReturn;\n@@ -1195,21 +1196,35 @@ public class RecentTasksTest extends WindowTestsBase {\n \n     @Test\n     public void testCreateRecentTaskInfo_detachedTask() {\n-        final Task task = createTaskBuilder(\".Task\").setCreateActivity(true).build();\n+        final Task task = createTaskBuilder(\".Task\").build();\n+        new ActivityBuilder(mSupervisor.mService)\n+                .setTask(task)\n+                .setUid(NOBODY_UID)\n+                .setComponent(new ComponentName(\"com.foo\", \".BarActivity\"))\n+                .build();\n         final TaskDisplayArea tda = task.getDisplayArea();\n \n         assertTrue(task.isAttached());\n         assertTrue(task.supportsMultiWindow());\n \n-        RecentTaskInfo info = mRecentTasks.createRecentTaskInfo(task, true);\n+        RecentTaskInfo info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,\n+                true /* getTasksAllowed */);\n \n         assertTrue(info.supportsMultiWindow);\n         assertTrue(info.supportsSplitScreenMultiWindow);\n \n+        info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,\n+                false /* getTasksAllowed */);\n+\n+        assertTrue(info.topActivity == null);\n+        assertTrue(info.topActivityInfo == null);\n+        assertTrue(info.baseActivity == null);\n+\n         // The task can be put in split screen even if it is not attached now.\n         task.removeImmediately();\n \n-        info = mRecentTasks.createRecentTaskInfo(task, true);\n+        info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,\n+                true /* getTasksAllowed */);\n \n         assertTrue(info.supportsMultiWindow);\n         assertTrue(info.supportsSplitScreenMultiWindow);\n@@ -1219,7 +1234,8 @@ public class RecentTasksTest extends WindowTestsBase {\n         doReturn(false).when(tda).supportsNonResizableMultiWindow();\n         doReturn(false).when(task).isResizeable();\n \n-        info = mRecentTasks.createRecentTaskInfo(task, true);\n+        info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,\n+                true /* getTasksAllowed */);\n \n         assertFalse(info.supportsMultiWindow);\n         assertFalse(info.supportsSplitScreenMultiWindow);\n@@ -1228,7 +1244,8 @@ public class RecentTasksTest extends WindowTestsBase {\n         // the device supports it.\n         doReturn(true).when(tda).supportsNonResizableMultiWindow();\n \n-        info = mRecentTasks.createRecentTaskInfo(task, true);\n+        info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,\n+                true /* getTasksAllowed */);\n \n         assertTrue(info.supportsMultiWindow);\n         assertTrue(info.supportsSplitScreenMultiWindow);\n",
    "added_lines": 22,
    "deleted_lines": 5,
    "changed_methods": "RecentTasksTest::testCreateRecentTaskInfo_detachedTask"
   }
  ]
 },
 {
  "hash": "ce0a326a0c700a2d71b697219bc39fb7b3eb1038",
  "commit": "RESTRICT AUTOMERGE Revoke SYSTEM_ALERT_WINDOW on upgrade past api 23\n\nBug: 221040577\nTest: atest PermissionTest23#testPre23AppsWithSystemAlertWindowGetDeniedOnUpgrade\nChange-Id: I4b4605aaae107875811070dea6d031c5d9f25c96\n(cherry picked from commit 5e80fcf8c423f288a87d727f48ae38112177d716)\nMerged-In: I4b4605aaae107875811070dea6d031c5d9f25c96",
  "files": [
   {
    "filename": "PermissionManagerService.java",
    "diff": "@@ -2248,6 +2248,46 @@ public class PermissionManagerService extends IPermissionManager.Stub {\n \n     }\n \n+    /**\n+     * If the package was below api 23, got the SYSTEM_ALERT_WINDOW permission automatically, and\n+     * then updated past api 23, and the app does not satisfy any of the other SAW permission flags,\n+     * the permission should be revoked.\n+     *\n+     * @param newPackage The new package that was installed\n+     * @param oldPackage The old package that was updated\n+     */\n+    private void revokeSystemAlertWindowIfUpgradedPast23(\n+            @NonNull AndroidPackage newPackage,\n+            @NonNull AndroidPackage oldPackage) {\n+        if (oldPackage.getTargetSdkVersion() >= Build.VERSION_CODES.M\n+                || newPackage.getTargetSdkVersion() < Build.VERSION_CODES.M\n+                || !newPackage.getRequestedPermissions()\n+                .contains(Manifest.permission.SYSTEM_ALERT_WINDOW)) {\n+            return;\n+        }\n+\n+        Permission saw;\n+        synchronized (mLock) {\n+            saw = mRegistry.getPermission(Manifest.permission.SYSTEM_ALERT_WINDOW);\n+        }\n+        final PackageSetting ps = (PackageSetting)\n+                mPackageManagerInt.getPackageSetting(newPackage.getPackageName());\n+        if (shouldGrantPermissionByProtectionFlags(newPackage, ps, saw, new ArraySet<>())\n+                    || shouldGrantPermissionBySignature(newPackage, saw)) {\n+            return;\n+        }\n+        for (int userId : getAllUserIds()) {\n+            try {\n+                revokePermissionFromPackageForUser(newPackage.getPackageName(),\n+                        Manifest.permission.SYSTEM_ALERT_WINDOW, false, userId,\n+                        mDefaultPermissionCallback);\n+            } catch (IllegalStateException | SecurityException e) {\n+                Log.e(TAG, \"unable to revoke SYSTEM_ALERT_WINDOW for \"\n+                        + newPackage.getPackageName() + \" user \" + userId, e);\n+            }\n+        }\n+    }\n+\n     /**\n      * We might auto-grant permissions if any permission of the group is already granted. Hence if\n      * the group of a granted permission changes we need to revoke it to avoid having permissions of\n@@ -4814,6 +4854,7 @@ public class PermissionManagerService extends IPermissionManager.Stub {\n                 if (hasOldPkg) {\n                     revokeRuntimePermissionsIfGroupChangedInternal(pkg, oldPkg);\n                     revokeStoragePermissionsIfScopeExpandedInternal(pkg, oldPkg);\n+                    revokeSystemAlertWindowIfUpgradedPast23(pkg, oldPkg);\n                 }\n                 if (hasPermissionDefinitionChanges) {\n                     revokeRuntimePermissionsIfPermissionDefinitionChangedInternal(\n",
    "added_lines": 41,
    "deleted_lines": 0,
    "changed_methods": "PermissionManagerService::revokeSystemAlertWindowIfUpgradedPast23, PermissionManagerService::onPackageAddedInternal"
   }
  ]
 },
 {
  "hash": "f089bd6a11e3afcbcdfc5a2c286bc78d79be0600",
  "commit": "Add protections against queueing a UsbRequest when the underlying UsbDeviceConnection is closed.\n\nBug: 204584366\nTest: CTS Verifier: USB Accessory Test & USB Device Test\nTest: No HWASan use-after-free reports with a test app\nChange-Id: Ia3a9b10349efc0236b1539c81465f479cb32e02b\n(cherry picked from commit 1691b54b1fda4239249a3871d2c17ed1ec753061)\nMerged-In: Ia3a9b10349efc0236b1539c81465f479cb32e02b",
  "files": [
   {
    "filename": "UsbDeviceConnection.java",
    "diff": "@@ -107,6 +107,34 @@ public class UsbDeviceConnection {\n         }\n     }\n \n+    /**\n+     * This is meant to be called by UsbRequest's queue() in order to synchronize on\n+     * UsbDeviceConnection's mLock to prevent the connection being closed while queueing.\n+     */\n+    /* package */ boolean queueRequest(UsbRequest request, ByteBuffer buffer, int length) {\n+        synchronized (mLock) {\n+            if (!isOpen()) {\n+                return false;\n+            }\n+\n+            return request.queueIfConnectionOpen(buffer, length);\n+        }\n+    }\n+\n+    /**\n+     * This is meant to be called by UsbRequest's queue() in order to synchronize on\n+     * UsbDeviceConnection's mLock to prevent the connection being closed while queueing.\n+     */\n+    /* package */ boolean queueRequest(UsbRequest request, @Nullable ByteBuffer buffer) {\n+        synchronized (mLock) {\n+            if (!isOpen()) {\n+                return false;\n+            }\n+\n+            return request.queueIfConnectionOpen(buffer);\n+        }\n+    }\n+\n     /**\n      * Releases all system resources related to the device.\n      * Once the object is closed it cannot be used again.\n",
    "added_lines": 28,
    "deleted_lines": 0,
    "changed_methods": "UsbDeviceConnection::queueRequest, UsbDeviceConnection::queueRequest"
   },
   {
    "filename": "UsbRequest.java",
    "diff": "@@ -113,11 +113,13 @@ public class UsbRequest {\n      * Releases all resources related to this request.\n      */\n     public void close() {\n-        if (mNativeContext != 0) {\n-            mEndpoint = null;\n-            mConnection = null;\n-            native_close();\n-            mCloseGuard.close();\n+        synchronized (mLock) {\n+            if (mNativeContext != 0) {\n+                mEndpoint = null;\n+                mConnection = null;\n+                native_close();\n+                mCloseGuard.close();\n+            }\n         }\n     }\n \n@@ -191,10 +193,32 @@ public class UsbRequest {\n      */\n     @Deprecated\n     public boolean queue(ByteBuffer buffer, int length) {\n+        UsbDeviceConnection connection = mConnection;\n+        if (connection == null) {\n+            // The expected exception by CTS Verifier - USB Device test\n+            throw new NullPointerException(\"invalid connection\");\n+        }\n+\n+        // Calling into the underlying UsbDeviceConnection to synchronize on its lock, to prevent\n+        // the connection being closed while queueing.\n+        return connection.queueRequest(this, buffer, length);\n+    }\n+\n+    /**\n+     * This is meant to be called from UsbDeviceConnection after synchronizing using the lock over\n+     * there, to prevent the connection being closed while queueing.\n+     */\n+    /* package */ boolean queueIfConnectionOpen(ByteBuffer buffer, int length) {\n+        UsbDeviceConnection connection = mConnection;\n+        if (connection == null || !connection.isOpen()) {\n+            // The expected exception by CTS Verifier - USB Device test\n+            throw new NullPointerException(\"invalid connection\");\n+        }\n+\n         boolean out = (mEndpoint.getDirection() == UsbConstants.USB_DIR_OUT);\n         boolean result;\n \n-        if (mConnection.getContext().getApplicationInfo().targetSdkVersion < Build.VERSION_CODES.P\n+        if (connection.getContext().getApplicationInfo().targetSdkVersion < Build.VERSION_CODES.P\n                 && length > MAX_USBFS_BUFFER_SIZE) {\n             length = MAX_USBFS_BUFFER_SIZE;\n         }\n@@ -243,6 +267,28 @@ public class UsbRequest {\n      * @return true if the queueing operation succeeded\n      */\n     public boolean queue(@Nullable ByteBuffer buffer) {\n+        UsbDeviceConnection connection = mConnection;\n+        if (connection == null) {\n+            // The expected exception by CTS Verifier - USB Device test\n+            throw new IllegalStateException(\"invalid connection\");\n+        }\n+\n+        // Calling into the underlying UsbDeviceConnection to synchronize on its lock, to prevent\n+        // the connection being closed while queueing.\n+        return connection.queueRequest(this, buffer);\n+    }\n+\n+    /**\n+     * This is meant to be called from UsbDeviceConnection after synchronizing using the lock over\n+     * there, to prevent the connection being closed while queueing.\n+     */\n+    /* package */ boolean queueIfConnectionOpen(@Nullable ByteBuffer buffer) {\n+        UsbDeviceConnection connection = mConnection;\n+        if (connection == null || !connection.isOpen()) {\n+            // The expected exception by CTS Verifier - USB Device test\n+            throw new IllegalStateException(\"invalid connection\");\n+        }\n+\n         // Request need to be initialized\n         Preconditions.checkState(mNativeContext != 0, \"request is not initialized\");\n \n@@ -260,7 +306,7 @@ public class UsbRequest {\n                 mIsUsingNewQueue = true;\n                 wasQueued = native_queue(null, 0, 0);\n             } else {\n-                if (mConnection.getContext().getApplicationInfo().targetSdkVersion\n+                if (connection.getContext().getApplicationInfo().targetSdkVersion\n                         < Build.VERSION_CODES.P) {\n                     // Can only send/receive MAX_USBFS_BUFFER_SIZE bytes at once\n                     Preconditions.checkArgumentInRange(buffer.remaining(), 0, MAX_USBFS_BUFFER_SIZE,\n@@ -363,11 +409,12 @@ public class UsbRequest {\n      * @return true if cancelling succeeded\n      */\n     public boolean cancel() {\n-        if (mConnection == null) {\n+        UsbDeviceConnection connection = mConnection;\n+        if (connection == null) {\n             return false;\n         }\n \n-        return mConnection.cancelRequest(this);\n+        return connection.cancelRequest(this);\n     }\n \n     /**\n@@ -382,7 +429,8 @@ public class UsbRequest {\n      * @return true if cancelling succeeded.\n      */\n     /* package */ boolean cancelIfOpen() {\n-        if (mNativeContext == 0 || (mConnection != null && !mConnection.isOpen())) {\n+        UsbDeviceConnection connection = mConnection;\n+        if (mNativeContext == 0 || (connection != null && !connection.isOpen())) {\n             Log.w(TAG,\n                     \"Detected attempt to cancel a request on a connection which isn't open\");\n             return false;\n",
    "added_lines": 58,
    "deleted_lines": 10,
    "changed_methods": "UsbRequest::close, UsbRequest::queueIfConnectionOpen, UsbRequest::cancel, UsbRequest::cancelIfOpen, UsbRequest::queue, UsbRequest::queue, UsbRequest::queueIfConnectionOpen"
   }
  ]
 },
 {
  "hash": "f089bd6a11e3afcbcdfc5a2c286bc78d79be0600",
  "commit": "Add protections against queueing a UsbRequest when the underlying UsbDeviceConnection is closed.\n\nBug: 204584366\nTest: CTS Verifier: USB Accessory Test & USB Device Test\nTest: No HWASan use-after-free reports with a test app\nChange-Id: Ia3a9b10349efc0236b1539c81465f479cb32e02b\n(cherry picked from commit 1691b54b1fda4239249a3871d2c17ed1ec753061)\nMerged-In: Ia3a9b10349efc0236b1539c81465f479cb32e02b",
  "files": [
   {
    "filename": "UsbDeviceConnection.java",
    "diff": "@@ -107,6 +107,34 @@ public class UsbDeviceConnection {\n         }\n     }\n \n+    /**\n+     * This is meant to be called by UsbRequest's queue() in order to synchronize on\n+     * UsbDeviceConnection's mLock to prevent the connection being closed while queueing.\n+     */\n+    /* package */ boolean queueRequest(UsbRequest request, ByteBuffer buffer, int length) {\n+        synchronized (mLock) {\n+            if (!isOpen()) {\n+                return false;\n+            }\n+\n+            return request.queueIfConnectionOpen(buffer, length);\n+        }\n+    }\n+\n+    /**\n+     * This is meant to be called by UsbRequest's queue() in order to synchronize on\n+     * UsbDeviceConnection's mLock to prevent the connection being closed while queueing.\n+     */\n+    /* package */ boolean queueRequest(UsbRequest request, @Nullable ByteBuffer buffer) {\n+        synchronized (mLock) {\n+            if (!isOpen()) {\n+                return false;\n+            }\n+\n+            return request.queueIfConnectionOpen(buffer);\n+        }\n+    }\n+\n     /**\n      * Releases all system resources related to the device.\n      * Once the object is closed it cannot be used again.\n",
    "added_lines": 28,
    "deleted_lines": 0,
    "changed_methods": "UsbDeviceConnection::queueRequest, UsbDeviceConnection::queueRequest"
   },
   {
    "filename": "UsbRequest.java",
    "diff": "@@ -113,11 +113,13 @@ public class UsbRequest {\n      * Releases all resources related to this request.\n      */\n     public void close() {\n-        if (mNativeContext != 0) {\n-            mEndpoint = null;\n-            mConnection = null;\n-            native_close();\n-            mCloseGuard.close();\n+        synchronized (mLock) {\n+            if (mNativeContext != 0) {\n+                mEndpoint = null;\n+                mConnection = null;\n+                native_close();\n+                mCloseGuard.close();\n+            }\n         }\n     }\n \n@@ -191,10 +193,32 @@ public class UsbRequest {\n      */\n     @Deprecated\n     public boolean queue(ByteBuffer buffer, int length) {\n+        UsbDeviceConnection connection = mConnection;\n+        if (connection == null) {\n+            // The expected exception by CTS Verifier - USB Device test\n+            throw new NullPointerException(\"invalid connection\");\n+        }\n+\n+        // Calling into the underlying UsbDeviceConnection to synchronize on its lock, to prevent\n+        // the connection being closed while queueing.\n+        return connection.queueRequest(this, buffer, length);\n+    }\n+\n+    /**\n+     * This is meant to be called from UsbDeviceConnection after synchronizing using the lock over\n+     * there, to prevent the connection being closed while queueing.\n+     */\n+    /* package */ boolean queueIfConnectionOpen(ByteBuffer buffer, int length) {\n+        UsbDeviceConnection connection = mConnection;\n+        if (connection == null || !connection.isOpen()) {\n+            // The expected exception by CTS Verifier - USB Device test\n+            throw new NullPointerException(\"invalid connection\");\n+        }\n+\n         boolean out = (mEndpoint.getDirection() == UsbConstants.USB_DIR_OUT);\n         boolean result;\n \n-        if (mConnection.getContext().getApplicationInfo().targetSdkVersion < Build.VERSION_CODES.P\n+        if (connection.getContext().getApplicationInfo().targetSdkVersion < Build.VERSION_CODES.P\n                 && length > MAX_USBFS_BUFFER_SIZE) {\n             length = MAX_USBFS_BUFFER_SIZE;\n         }\n@@ -243,6 +267,28 @@ public class UsbRequest {\n      * @return true if the queueing operation succeeded\n      */\n     public boolean queue(@Nullable ByteBuffer buffer) {\n+        UsbDeviceConnection connection = mConnection;\n+        if (connection == null) {\n+            // The expected exception by CTS Verifier - USB Device test\n+            throw new IllegalStateException(\"invalid connection\");\n+        }\n+\n+        // Calling into the underlying UsbDeviceConnection to synchronize on its lock, to prevent\n+        // the connection being closed while queueing.\n+        return connection.queueRequest(this, buffer);\n+    }\n+\n+    /**\n+     * This is meant to be called from UsbDeviceConnection after synchronizing using the lock over\n+     * there, to prevent the connection being closed while queueing.\n+     */\n+    /* package */ boolean queueIfConnectionOpen(@Nullable ByteBuffer buffer) {\n+        UsbDeviceConnection connection = mConnection;\n+        if (connection == null || !connection.isOpen()) {\n+            // The expected exception by CTS Verifier - USB Device test\n+            throw new IllegalStateException(\"invalid connection\");\n+        }\n+\n         // Request need to be initialized\n         Preconditions.checkState(mNativeContext != 0, \"request is not initialized\");\n \n@@ -260,7 +306,7 @@ public class UsbRequest {\n                 mIsUsingNewQueue = true;\n                 wasQueued = native_queue(null, 0, 0);\n             } else {\n-                if (mConnection.getContext().getApplicationInfo().targetSdkVersion\n+                if (connection.getContext().getApplicationInfo().targetSdkVersion\n                         < Build.VERSION_CODES.P) {\n                     // Can only send/receive MAX_USBFS_BUFFER_SIZE bytes at once\n                     Preconditions.checkArgumentInRange(buffer.remaining(), 0, MAX_USBFS_BUFFER_SIZE,\n@@ -363,11 +409,12 @@ public class UsbRequest {\n      * @return true if cancelling succeeded\n      */\n     public boolean cancel() {\n-        if (mConnection == null) {\n+        UsbDeviceConnection connection = mConnection;\n+        if (connection == null) {\n             return false;\n         }\n \n-        return mConnection.cancelRequest(this);\n+        return connection.cancelRequest(this);\n     }\n \n     /**\n@@ -382,7 +429,8 @@ public class UsbRequest {\n      * @return true if cancelling succeeded.\n      */\n     /* package */ boolean cancelIfOpen() {\n-        if (mNativeContext == 0 || (mConnection != null && !mConnection.isOpen())) {\n+        UsbDeviceConnection connection = mConnection;\n+        if (mNativeContext == 0 || (connection != null && !connection.isOpen())) {\n             Log.w(TAG,\n                     \"Detected attempt to cancel a request on a connection which isn't open\");\n             return false;\n",
    "added_lines": 58,
    "deleted_lines": 10,
    "changed_methods": "UsbRequest::close, UsbRequest::queueIfConnectionOpen, UsbRequest::cancel, UsbRequest::cancelIfOpen, UsbRequest::queue, UsbRequest::queue, UsbRequest::queueIfConnectionOpen"
   }
  ]
 },
 {
  "hash": "b0acd540cd5194b529aedaf87e00dff377da4448",
  "commit": "Fix sharing to another profile where an app has multiple targets\n\nMoves the fixUris call from onTargetSelected directly to the intent\nlaunch to ensure the intent which is actually started is updated with\nuserId specific URIs.\n\nThis is a backport of ag/19657256 and ag/20063949.\n\nBug:242165528\nBug:244876518\nBug:242605257\nTest: manually share image from personal profile to work gmail,\nfirst with chat target then backing up and selecting the main target\nTest: manually share image from work Photos app to personal WhatsApp's\nfrequent contact target.\n\nChange-Id: Id815984e691bf962e19e30a54f7247d16060b3b8\nMerged-In: Id815984e691bf962e19e30a54f7247d16060b3b8\nMerged-In: Ib41c8a3c46afcc2d62a4c1a924212bcd98bcfbe4\nMerged-In: Iabf5dcf2612fe718f2f0886e2e5e9b76f37af1e1\n(cherry picked from commit f50ced5f1e619d7fa7858748d6a9dbe861354f04)\nMerged-In: Id815984e691bf962e19e30a54f7247d16060b3b8",
  "files": [
   {
    "filename": "ResolverActivity.java",
    "diff": "@@ -1227,9 +1227,6 @@ public class ResolverActivity extends Activity implements\n         }\n \n         if (target != null) {\n-            if (intent != null && isLaunchingTargetInOtherProfile()) {\n-                prepareIntentForCrossProfileLaunch(intent);\n-            }\n             safelyStartActivity(target);\n \n             // Rely on the ActivityManager to pop up a dialog regarding app suspension\n@@ -1242,15 +1239,6 @@ public class ResolverActivity extends Activity implements\n         return true;\n     }\n \n-    private void prepareIntentForCrossProfileLaunch(Intent intent) {\n-        intent.fixUris(UserHandle.myUserId());\n-    }\n-\n-    private boolean isLaunchingTargetInOtherProfile() {\n-        return mMultiProfilePagerAdapter.getCurrentUserHandle().getIdentifier()\n-                != UserHandle.myUserId();\n-    }\n-\n     @VisibleForTesting\n     public void safelyStartActivity(TargetInfo cti) {\n         // We're dispatching intents that might be coming from legacy apps, so\n",
    "added_lines": 0,
    "deleted_lines": 12,
    "changed_methods": "ResolverActivity::isLaunchingTargetInOtherProfile, ResolverActivity::onTargetSelected, ResolverActivity::prepareIntentForCrossProfileLaunch"
   },
   {
    "filename": "DisplayResolveInfo.java",
    "diff": "@@ -181,6 +181,7 @@ public class DisplayResolveInfo implements TargetInfo, Parcelable {\n         if (ENABLE_CHOOSER_DELEGATE) {\n             return activity.startAsCallerImpl(mResolvedIntent, options, false, userId);\n         } else {\n+            TargetInfo.prepareIntentForCrossProfileLaunch(mResolvedIntent, userId);\n             activity.startActivityAsCaller(mResolvedIntent, options, null, false, userId);\n             return true;\n         }\n@@ -188,6 +189,7 @@ public class DisplayResolveInfo implements TargetInfo, Parcelable {\n \n     @Override\n     public boolean startAsUser(Activity activity, Bundle options, UserHandle user) {\n+        TargetInfo.prepareIntentForCrossProfileLaunch(mResolvedIntent, user.getIdentifier());\n         activity.startActivityAsUser(mResolvedIntent, options, user);\n         return false;\n     }\n",
    "added_lines": 2,
    "deleted_lines": 0,
    "changed_methods": "DisplayResolveInfo::startAsUser, DisplayResolveInfo::startAsCaller"
   },
   {
    "filename": "SelectableTargetInfo.java",
    "diff": "@@ -229,6 +229,7 @@ public final class SelectableTargetInfo implements ChooserTargetInfo {\n         }\n         intent.setComponent(mChooserTarget.getComponentName());\n         intent.putExtras(mChooserTarget.getIntentExtras());\n+        TargetInfo.prepareIntentForCrossProfileLaunch(intent, userId);\n \n         // Important: we will ignore the target security checks in ActivityManager\n         // if and only if the ChooserTarget's target package is the same package\n",
    "added_lines": 1,
    "deleted_lines": 0,
    "changed_methods": "SelectableTargetInfo::startAsCaller"
   },
   {
    "filename": "TargetInfo.java",
    "diff": "@@ -130,4 +130,15 @@ public interface TargetInfo {\n      * @return true if this target should be pinned to the front by the request of the user\n      */\n     boolean isPinned();\n+\n+    /**\n+     * Fix the URIs in {@code intent} if cross-profile sharing is required. This should be called\n+     * before launching the intent as another user.\n+     */\n+    static void prepareIntentForCrossProfileLaunch(Intent intent, int targetUserId) {\n+        final int currentUserId = UserHandle.myUserId();\n+        if (targetUserId != currentUserId) {\n+            intent.fixUris(currentUserId);\n+        }\n+    }\n }\n",
    "added_lines": 11,
    "deleted_lines": 0,
    "changed_methods": "prepareIntentForCrossProfileLaunch"
   }
  ]
 },
 {
  "hash": "b0acd540cd5194b529aedaf87e00dff377da4448",
  "commit": "Fix sharing to another profile where an app has multiple targets\n\nMoves the fixUris call from onTargetSelected directly to the intent\nlaunch to ensure the intent which is actually started is updated with\nuserId specific URIs.\n\nThis is a backport of ag/19657256 and ag/20063949.\n\nBug:242165528\nBug:244876518\nBug:242605257\nTest: manually share image from personal profile to work gmail,\nfirst with chat target then backing up and selecting the main target\nTest: manually share image from work Photos app to personal WhatsApp's\nfrequent contact target.\n\nChange-Id: Id815984e691bf962e19e30a54f7247d16060b3b8\nMerged-In: Id815984e691bf962e19e30a54f7247d16060b3b8\nMerged-In: Ib41c8a3c46afcc2d62a4c1a924212bcd98bcfbe4\nMerged-In: Iabf5dcf2612fe718f2f0886e2e5e9b76f37af1e1\n(cherry picked from commit f50ced5f1e619d7fa7858748d6a9dbe861354f04)\nMerged-In: Id815984e691bf962e19e30a54f7247d16060b3b8",
  "files": [
   {
    "filename": "ResolverActivity.java",
    "diff": "@@ -1227,9 +1227,6 @@ public class ResolverActivity extends Activity implements\n         }\n \n         if (target != null) {\n-            if (intent != null && isLaunchingTargetInOtherProfile()) {\n-                prepareIntentForCrossProfileLaunch(intent);\n-            }\n             safelyStartActivity(target);\n \n             // Rely on the ActivityManager to pop up a dialog regarding app suspension\n@@ -1242,15 +1239,6 @@ public class ResolverActivity extends Activity implements\n         return true;\n     }\n \n-    private void prepareIntentForCrossProfileLaunch(Intent intent) {\n-        intent.fixUris(UserHandle.myUserId());\n-    }\n-\n-    private boolean isLaunchingTargetInOtherProfile() {\n-        return mMultiProfilePagerAdapter.getCurrentUserHandle().getIdentifier()\n-                != UserHandle.myUserId();\n-    }\n-\n     @VisibleForTesting\n     public void safelyStartActivity(TargetInfo cti) {\n         // We're dispatching intents that might be coming from legacy apps, so\n",
    "added_lines": 0,
    "deleted_lines": 12,
    "changed_methods": "ResolverActivity::isLaunchingTargetInOtherProfile, ResolverActivity::onTargetSelected, ResolverActivity::prepareIntentForCrossProfileLaunch"
   },
   {
    "filename": "DisplayResolveInfo.java",
    "diff": "@@ -181,6 +181,7 @@ public class DisplayResolveInfo implements TargetInfo, Parcelable {\n         if (ENABLE_CHOOSER_DELEGATE) {\n             return activity.startAsCallerImpl(mResolvedIntent, options, false, userId);\n         } else {\n+            TargetInfo.prepareIntentForCrossProfileLaunch(mResolvedIntent, userId);\n             activity.startActivityAsCaller(mResolvedIntent, options, null, false, userId);\n             return true;\n         }\n@@ -188,6 +189,7 @@ public class DisplayResolveInfo implements TargetInfo, Parcelable {\n \n     @Override\n     public boolean startAsUser(Activity activity, Bundle options, UserHandle user) {\n+        TargetInfo.prepareIntentForCrossProfileLaunch(mResolvedIntent, user.getIdentifier());\n         activity.startActivityAsUser(mResolvedIntent, options, user);\n         return false;\n     }\n",
    "added_lines": 2,
    "deleted_lines": 0,
    "changed_methods": "DisplayResolveInfo::startAsUser, DisplayResolveInfo::startAsCaller"
   },
   {
    "filename": "SelectableTargetInfo.java",
    "diff": "@@ -229,6 +229,7 @@ public final class SelectableTargetInfo implements ChooserTargetInfo {\n         }\n         intent.setComponent(mChooserTarget.getComponentName());\n         intent.putExtras(mChooserTarget.getIntentExtras());\n+        TargetInfo.prepareIntentForCrossProfileLaunch(intent, userId);\n \n         // Important: we will ignore the target security checks in ActivityManager\n         // if and only if the ChooserTarget's target package is the same package\n",
    "added_lines": 1,
    "deleted_lines": 0,
    "changed_methods": "SelectableTargetInfo::startAsCaller"
   },
   {
    "filename": "TargetInfo.java",
    "diff": "@@ -130,4 +130,15 @@ public interface TargetInfo {\n      * @return true if this target should be pinned to the front by the request of the user\n      */\n     boolean isPinned();\n+\n+    /**\n+     * Fix the URIs in {@code intent} if cross-profile sharing is required. This should be called\n+     * before launching the intent as another user.\n+     */\n+    static void prepareIntentForCrossProfileLaunch(Intent intent, int targetUserId) {\n+        final int currentUserId = UserHandle.myUserId();\n+        if (targetUserId != currentUserId) {\n+            intent.fixUris(currentUserId);\n+        }\n+    }\n }\n",
    "added_lines": 11,
    "deleted_lines": 0,
    "changed_methods": "prepareIntentForCrossProfileLaunch"
   }
  ]
 },
 {
  "hash": "b0acd540cd5194b529aedaf87e00dff377da4448",
  "commit": "Fix sharing to another profile where an app has multiple targets\n\nMoves the fixUris call from onTargetSelected directly to the intent\nlaunch to ensure the intent which is actually started is updated with\nuserId specific URIs.\n\nThis is a backport of ag/19657256 and ag/20063949.\n\nBug:242165528\nBug:244876518\nBug:242605257\nTest: manually share image from personal profile to work gmail,\nfirst with chat target then backing up and selecting the main target\nTest: manually share image from work Photos app to personal WhatsApp's\nfrequent contact target.\n\nChange-Id: Id815984e691bf962e19e30a54f7247d16060b3b8\nMerged-In: Id815984e691bf962e19e30a54f7247d16060b3b8\nMerged-In: Ib41c8a3c46afcc2d62a4c1a924212bcd98bcfbe4\nMerged-In: Iabf5dcf2612fe718f2f0886e2e5e9b76f37af1e1\n(cherry picked from commit f50ced5f1e619d7fa7858748d6a9dbe861354f04)\nMerged-In: Id815984e691bf962e19e30a54f7247d16060b3b8",
  "files": [
   {
    "filename": "ResolverActivity.java",
    "diff": "@@ -1227,9 +1227,6 @@ public class ResolverActivity extends Activity implements\n         }\n \n         if (target != null) {\n-            if (intent != null && isLaunchingTargetInOtherProfile()) {\n-                prepareIntentForCrossProfileLaunch(intent);\n-            }\n             safelyStartActivity(target);\n \n             // Rely on the ActivityManager to pop up a dialog regarding app suspension\n@@ -1242,15 +1239,6 @@ public class ResolverActivity extends Activity implements\n         return true;\n     }\n \n-    private void prepareIntentForCrossProfileLaunch(Intent intent) {\n-        intent.fixUris(UserHandle.myUserId());\n-    }\n-\n-    private boolean isLaunchingTargetInOtherProfile() {\n-        return mMultiProfilePagerAdapter.getCurrentUserHandle().getIdentifier()\n-                != UserHandle.myUserId();\n-    }\n-\n     @VisibleForTesting\n     public void safelyStartActivity(TargetInfo cti) {\n         // We're dispatching intents that might be coming from legacy apps, so\n",
    "added_lines": 0,
    "deleted_lines": 12,
    "changed_methods": "ResolverActivity::isLaunchingTargetInOtherProfile, ResolverActivity::onTargetSelected, ResolverActivity::prepareIntentForCrossProfileLaunch"
   },
   {
    "filename": "DisplayResolveInfo.java",
    "diff": "@@ -181,6 +181,7 @@ public class DisplayResolveInfo implements TargetInfo, Parcelable {\n         if (ENABLE_CHOOSER_DELEGATE) {\n             return activity.startAsCallerImpl(mResolvedIntent, options, false, userId);\n         } else {\n+            TargetInfo.prepareIntentForCrossProfileLaunch(mResolvedIntent, userId);\n             activity.startActivityAsCaller(mResolvedIntent, options, null, false, userId);\n             return true;\n         }\n@@ -188,6 +189,7 @@ public class DisplayResolveInfo implements TargetInfo, Parcelable {\n \n     @Override\n     public boolean startAsUser(Activity activity, Bundle options, UserHandle user) {\n+        TargetInfo.prepareIntentForCrossProfileLaunch(mResolvedIntent, user.getIdentifier());\n         activity.startActivityAsUser(mResolvedIntent, options, user);\n         return false;\n     }\n",
    "added_lines": 2,
    "deleted_lines": 0,
    "changed_methods": "DisplayResolveInfo::startAsUser, DisplayResolveInfo::startAsCaller"
   },
   {
    "filename": "SelectableTargetInfo.java",
    "diff": "@@ -229,6 +229,7 @@ public final class SelectableTargetInfo implements ChooserTargetInfo {\n         }\n         intent.setComponent(mChooserTarget.getComponentName());\n         intent.putExtras(mChooserTarget.getIntentExtras());\n+        TargetInfo.prepareIntentForCrossProfileLaunch(intent, userId);\n \n         // Important: we will ignore the target security checks in ActivityManager\n         // if and only if the ChooserTarget's target package is the same package\n",
    "added_lines": 1,
    "deleted_lines": 0,
    "changed_methods": "SelectableTargetInfo::startAsCaller"
   },
   {
    "filename": "TargetInfo.java",
    "diff": "@@ -130,4 +130,15 @@ public interface TargetInfo {\n      * @return true if this target should be pinned to the front by the request of the user\n      */\n     boolean isPinned();\n+\n+    /**\n+     * Fix the URIs in {@code intent} if cross-profile sharing is required. This should be called\n+     * before launching the intent as another user.\n+     */\n+    static void prepareIntentForCrossProfileLaunch(Intent intent, int targetUserId) {\n+        final int currentUserId = UserHandle.myUserId();\n+        if (targetUserId != currentUserId) {\n+            intent.fixUris(currentUserId);\n+        }\n+    }\n }\n",
    "added_lines": 11,
    "deleted_lines": 0,
    "changed_methods": "prepareIntentForCrossProfileLaunch"
   }
  ]
 },
 {
  "hash": "b0acd540cd5194b529aedaf87e00dff377da4448",
  "commit": "Fix sharing to another profile where an app has multiple targets\n\nMoves the fixUris call from onTargetSelected directly to the intent\nlaunch to ensure the intent which is actually started is updated with\nuserId specific URIs.\n\nThis is a backport of ag/19657256 and ag/20063949.\n\nBug:242165528\nBug:244876518\nBug:242605257\nTest: manually share image from personal profile to work gmail,\nfirst with chat target then backing up and selecting the main target\nTest: manually share image from work Photos app to personal WhatsApp's\nfrequent contact target.\n\nChange-Id: Id815984e691bf962e19e30a54f7247d16060b3b8\nMerged-In: Id815984e691bf962e19e30a54f7247d16060b3b8\nMerged-In: Ib41c8a3c46afcc2d62a4c1a924212bcd98bcfbe4\nMerged-In: Iabf5dcf2612fe718f2f0886e2e5e9b76f37af1e1\n(cherry picked from commit f50ced5f1e619d7fa7858748d6a9dbe861354f04)\nMerged-In: Id815984e691bf962e19e30a54f7247d16060b3b8",
  "files": [
   {
    "filename": "ResolverActivity.java",
    "diff": "@@ -1227,9 +1227,6 @@ public class ResolverActivity extends Activity implements\n         }\n \n         if (target != null) {\n-            if (intent != null && isLaunchingTargetInOtherProfile()) {\n-                prepareIntentForCrossProfileLaunch(intent);\n-            }\n             safelyStartActivity(target);\n \n             // Rely on the ActivityManager to pop up a dialog regarding app suspension\n@@ -1242,15 +1239,6 @@ public class ResolverActivity extends Activity implements\n         return true;\n     }\n \n-    private void prepareIntentForCrossProfileLaunch(Intent intent) {\n-        intent.fixUris(UserHandle.myUserId());\n-    }\n-\n-    private boolean isLaunchingTargetInOtherProfile() {\n-        return mMultiProfilePagerAdapter.getCurrentUserHandle().getIdentifier()\n-                != UserHandle.myUserId();\n-    }\n-\n     @VisibleForTesting\n     public void safelyStartActivity(TargetInfo cti) {\n         // We're dispatching intents that might be coming from legacy apps, so\n",
    "added_lines": 0,
    "deleted_lines": 12,
    "changed_methods": "ResolverActivity::isLaunchingTargetInOtherProfile, ResolverActivity::onTargetSelected, ResolverActivity::prepareIntentForCrossProfileLaunch"
   },
   {
    "filename": "DisplayResolveInfo.java",
    "diff": "@@ -181,6 +181,7 @@ public class DisplayResolveInfo implements TargetInfo, Parcelable {\n         if (ENABLE_CHOOSER_DELEGATE) {\n             return activity.startAsCallerImpl(mResolvedIntent, options, false, userId);\n         } else {\n+            TargetInfo.prepareIntentForCrossProfileLaunch(mResolvedIntent, userId);\n             activity.startActivityAsCaller(mResolvedIntent, options, null, false, userId);\n             return true;\n         }\n@@ -188,6 +189,7 @@ public class DisplayResolveInfo implements TargetInfo, Parcelable {\n \n     @Override\n     public boolean startAsUser(Activity activity, Bundle options, UserHandle user) {\n+        TargetInfo.prepareIntentForCrossProfileLaunch(mResolvedIntent, user.getIdentifier());\n         activity.startActivityAsUser(mResolvedIntent, options, user);\n         return false;\n     }\n",
    "added_lines": 2,
    "deleted_lines": 0,
    "changed_methods": "DisplayResolveInfo::startAsUser, DisplayResolveInfo::startAsCaller"
   },
   {
    "filename": "SelectableTargetInfo.java",
    "diff": "@@ -229,6 +229,7 @@ public final class SelectableTargetInfo implements ChooserTargetInfo {\n         }\n         intent.setComponent(mChooserTarget.getComponentName());\n         intent.putExtras(mChooserTarget.getIntentExtras());\n+        TargetInfo.prepareIntentForCrossProfileLaunch(intent, userId);\n \n         // Important: we will ignore the target security checks in ActivityManager\n         // if and only if the ChooserTarget's target package is the same package\n",
    "added_lines": 1,
    "deleted_lines": 0,
    "changed_methods": "SelectableTargetInfo::startAsCaller"
   },
   {
    "filename": "TargetInfo.java",
    "diff": "@@ -130,4 +130,15 @@ public interface TargetInfo {\n      * @return true if this target should be pinned to the front by the request of the user\n      */\n     boolean isPinned();\n+\n+    /**\n+     * Fix the URIs in {@code intent} if cross-profile sharing is required. This should be called\n+     * before launching the intent as another user.\n+     */\n+    static void prepareIntentForCrossProfileLaunch(Intent intent, int targetUserId) {\n+        final int currentUserId = UserHandle.myUserId();\n+        if (targetUserId != currentUserId) {\n+            intent.fixUris(currentUserId);\n+        }\n+    }\n }\n",
    "added_lines": 11,
    "deleted_lines": 0,
    "changed_methods": "prepareIntentForCrossProfileLaunch"
   }
  ]
 },
 {
  "hash": "57cc81a61b64c23a84e5a232e0aa822e90b85241",
  "commit": "Ensure that only SysUI can override pending intent launch flags\n\n- Originally added in ag/5139951, this method ensured that activities\n  launched from widgets are always started in a new task (if the\n  activity is launched in the home task, the task is not brough forward\n  with the recents transition).  We can restrict this to only recents\n  callers since this only applies to 1p launchers in gesture nav\n  (both the gesture with 3p launchers and button nav in general will\n  always start the home intent directly, which makes adding the\n  NEW_TASK flag unnecessary).\n\nBug: 243794108\nTest: Ensure that the original bug b/112508020 still works (with the\n      test app in the bug, swipe up still works after launching an\n      activity from the widget, and fails without applying the\n      override flags)\nChange-Id: Id53c6a2aa6da5933d488ca06a0bfc4ef89a4c343\n(cherry picked from commit c4d3106e347922610f8c554de3ae238175ed393e)\nMerged-In: Id53c6a2aa6da5933d488ca06a0bfc4ef89a4c343",
  "files": [
   {
    "filename": "PendingIntentRecord.java",
    "diff": "@@ -350,11 +350,16 @@ public final class PendingIntentRecord extends IIntentSender.Stub {\n                 resolvedType = key.requestResolvedType;\n             }\n \n-            // Apply any launch flags from the ActivityOptions. This is to ensure that the caller\n-            // can specify a consistent launch mode even if the PendingIntent is immutable\n+            // Apply any launch flags from the ActivityOptions. This is used only by SystemUI\n+            // to ensure that we can launch the pending intent with a consistent launch mode even\n+            // if the provided PendingIntent is immutable (ie. to force an activity to launch into\n+            // a new task, or to launch multiple instances if supported by the app)\n             final ActivityOptions opts = ActivityOptions.fromBundle(options);\n             if (opts != null) {\n-                finalIntent.addFlags(opts.getPendingIntentLaunchFlags());\n+                // TODO(b/254490217): Move this check into SafeActivityOptions\n+                if (controller.mAtmInternal.isCallerRecents(Binder.getCallingUid())) {\n+                    finalIntent.addFlags(opts.getPendingIntentLaunchFlags());\n+                }\n             }\n \n             // Extract options before clearing calling identity\n",
    "added_lines": 8,
    "deleted_lines": 3,
    "changed_methods": "PendingIntentRecord::sendInner"
   }
  ]
 },
 {
  "hash": "b702b280e4cbf89243d6d1e272cdd7869dce2d07",
  "commit": "[DO NOT MERGE] Do not clear calling identify when using BiometricPrompt from FingerprintService.\n\nBug: 214261879\nTest: atest AuthControllerTest\nTest: Manually verify with test apps in bug\nChange-Id: I8ae9f2b8a970bf7e5d32121dc358f7d0f0d060b8\n(cherry picked from commit ac89f8682f0558c775e360d3c5fb84702e914989)\nMerged-In: I8ae9f2b8a970bf7e5d32121dc358f7d0f0d060b8",
  "files": [
   {
    "filename": "BiometricPrompt.java",
    "diff": "@@ -420,6 +420,18 @@ public class BiometricPrompt implements BiometricAuthenticator, BiometricConstan\n             return this;\n         }\n \n+        /**\n+         * Set if BiometricPrompt is being used by the legacy fingerprint manager API.\n+         * @param sensorId sensor id\n+         * @return This builder.\n+         * @hide\n+         */\n+        @NonNull\n+        public Builder setIsForLegacyFingerprintManager(int sensorId) {\n+            mPromptInfo.setIsForLegacyFingerprintManager(sensorId);\n+            return this;\n+        }\n+\n         /**\n          * Creates a {@link BiometricPrompt}.\n          *\n@@ -861,28 +873,36 @@ public class BiometricPrompt implements BiometricAuthenticator, BiometricConstan\n             @NonNull @CallbackExecutor Executor executor,\n             @NonNull AuthenticationCallback callback,\n             int userId) {\n-        authenticateUserForOperation(cancel, executor, callback, userId, 0 /* operationId */);\n+        if (cancel == null) {\n+            throw new IllegalArgumentException(\"Must supply a cancellation signal\");\n+        }\n+        if (executor == null) {\n+            throw new IllegalArgumentException(\"Must supply an executor\");\n+        }\n+        if (callback == null) {\n+            throw new IllegalArgumentException(\"Must supply a callback\");\n+        }\n+\n+        authenticateInternal(0 /* operationId */, cancel, executor, callback, userId);\n     }\n \n     /**\n-     * Authenticates for the given user and keystore operation.\n+     * Authenticates for the given keystore operation.\n      *\n      * @param cancel An object that can be used to cancel authentication\n      * @param executor An executor to handle callback events\n      * @param callback An object to receive authentication events\n-     * @param userId The user to authenticate\n      * @param operationId The keystore operation associated with authentication\n      *\n      * @return A requestId that can be used to cancel this operation.\n      *\n      * @hide\n      */\n-    @RequiresPermission(USE_BIOMETRIC_INTERNAL)\n-    public long authenticateUserForOperation(\n+    @RequiresPermission(USE_BIOMETRIC)\n+    public long authenticateForOperation(\n             @NonNull CancellationSignal cancel,\n             @NonNull @CallbackExecutor Executor executor,\n             @NonNull AuthenticationCallback callback,\n-            int userId,\n             long operationId) {\n         if (cancel == null) {\n             throw new IllegalArgumentException(\"Must supply a cancellation signal\");\n@@ -894,7 +914,7 @@ public class BiometricPrompt implements BiometricAuthenticator, BiometricConstan\n             throw new IllegalArgumentException(\"Must supply a callback\");\n         }\n \n-        return authenticateInternal(operationId, cancel, executor, callback, userId);\n+        return authenticateInternal(operationId, cancel, executor, callback, mContext.getUserId());\n     }\n \n     /**\n@@ -1028,7 +1048,7 @@ public class BiometricPrompt implements BiometricAuthenticator, BiometricConstan\n     private void cancelAuthentication(long requestId) {\n         if (mService != null) {\n             try {\n-                mService.cancelAuthentication(mToken, mContext.getOpPackageName(), requestId);\n+                mService.cancelAuthentication(mToken, mContext.getPackageName(), requestId);\n             } catch (RemoteException e) {\n                 Log.e(TAG, \"Unable to cancel authentication\", e);\n             }\n@@ -1087,7 +1107,7 @@ public class BiometricPrompt implements BiometricAuthenticator, BiometricConstan\n             }\n \n             final long authId = mService.authenticate(mToken, operationId, userId,\n-                    mBiometricServiceReceiver, mContext.getOpPackageName(), promptInfo);\n+                    mBiometricServiceReceiver, mContext.getPackageName(), promptInfo);\n             cancel.setOnCancelListener(new OnAuthenticationCancelListener(authId));\n             return authId;\n         } catch (RemoteException e) {\n",
    "added_lines": 29,
    "deleted_lines": 9,
    "changed_methods": "BiometricPrompt::Builder::setIsForLegacyFingerprintManager, BiometricPrompt::authenticateUserForOperation, BiometricPrompt::authenticateForOperation, BiometricPrompt::authenticateUser, BiometricPrompt::authenticateInternal, BiometricPrompt::cancelAuthentication"
   },
   {
    "filename": "PromptInfo.java",
    "diff": "@@ -46,6 +46,7 @@ public class PromptInfo implements Parcelable {\n     @NonNull private List<Integer> mAllowedSensorIds = new ArrayList<>();\n     private boolean mAllowBackgroundAuthentication;\n     private boolean mIgnoreEnrollmentState;\n+    private boolean mIsForLegacyFingerprintManager = false;\n \n     public PromptInfo() {\n \n@@ -68,6 +69,7 @@ public class PromptInfo implements Parcelable {\n         mAllowedSensorIds = in.readArrayList(Integer.class.getClassLoader());\n         mAllowBackgroundAuthentication = in.readBoolean();\n         mIgnoreEnrollmentState = in.readBoolean();\n+        mIsForLegacyFingerprintManager = in.readBoolean();\n     }\n \n     public static final Creator<PromptInfo> CREATOR = new Creator<PromptInfo>() {\n@@ -105,10 +107,15 @@ public class PromptInfo implements Parcelable {\n         dest.writeList(mAllowedSensorIds);\n         dest.writeBoolean(mAllowBackgroundAuthentication);\n         dest.writeBoolean(mIgnoreEnrollmentState);\n+        dest.writeBoolean(mIsForLegacyFingerprintManager);\n     }\n \n     public boolean containsTestConfigurations() {\n-        if (!mAllowedSensorIds.isEmpty()) {\n+        if (mIsForLegacyFingerprintManager\n+                && mAllowedSensorIds.size() == 1\n+                && !mAllowBackgroundAuthentication) {\n+            return false;\n+        } else if (!mAllowedSensorIds.isEmpty()) {\n             return true;\n         } else if (mAllowBackgroundAuthentication) {\n             return true;\n@@ -188,7 +195,8 @@ public class PromptInfo implements Parcelable {\n     }\n \n     public void setAllowedSensorIds(@NonNull List<Integer> sensorIds) {\n-        mAllowedSensorIds = sensorIds;\n+        mAllowedSensorIds.clear();\n+        mAllowedSensorIds.addAll(sensorIds);\n     }\n \n     public void setAllowBackgroundAuthentication(boolean allow) {\n@@ -199,6 +207,12 @@ public class PromptInfo implements Parcelable {\n         mIgnoreEnrollmentState = ignoreEnrollmentState;\n     }\n \n+    public void setIsForLegacyFingerprintManager(int sensorId) {\n+        mIsForLegacyFingerprintManager = true;\n+        mAllowedSensorIds.clear();\n+        mAllowedSensorIds.add(sensorId);\n+    }\n+\n     // Getters\n \n     public CharSequence getTitle() {\n@@ -272,4 +286,8 @@ public class PromptInfo implements Parcelable {\n     public boolean isIgnoreEnrollmentState() {\n         return mIgnoreEnrollmentState;\n     }\n+\n+    public boolean isForLegacyFingerprintManager() {\n+        return mIsForLegacyFingerprintManager;\n+    }\n }\n",
    "added_lines": 20,
    "deleted_lines": 2,
    "changed_methods": "PromptInfo::PromptInfo, PromptInfo::isForLegacyFingerprintManager, PromptInfo::setIsForLegacyFingerprintManager, PromptInfo::containsTestConfigurations, PromptInfo::setAllowedSensorIds, PromptInfo::writeToParcel"
   },
   {
    "filename": "AuthController.java",
    "diff": "@@ -134,7 +134,7 @@ public class AuthController extends SystemUI implements CommandQueue.Callbacks,\n     private class BiometricTaskStackListener extends TaskStackListener {\n         @Override\n         public void onTaskStackChanged() {\n-            mHandler.post(AuthController.this::handleTaskStackChanged);\n+            mHandler.post(AuthController.this::cancelIfOwnerIsNotInForeground);\n         }\n     }\n \n@@ -181,7 +181,7 @@ public class AuthController extends SystemUI implements CommandQueue.Callbacks,\n         }\n     };\n \n-    private void handleTaskStackChanged() {\n+    private void cancelIfOwnerIsNotInForeground() {\n         mExecution.assertIsMainThread();\n         if (mCurrentDialog != null) {\n             try {\n@@ -193,7 +193,7 @@ public class AuthController extends SystemUI implements CommandQueue.Callbacks,\n                     final String topPackage = runningTasks.get(0).topActivity.getPackageName();\n                     if (!topPackage.contentEquals(clientPackage)\n                             && !Utils.isSystem(mContext, clientPackage)) {\n-                        Log.w(TAG, \"Evicting client due to: \" + topPackage);\n+                        Log.e(TAG, \"Evicting client due to: \" + topPackage);\n                         mCurrentDialog.dismissWithoutCallback(true /* animate */);\n                         mCurrentDialog = null;\n                         mOrientationListener.disable();\n@@ -814,6 +814,10 @@ public class AuthController extends SystemUI implements CommandQueue.Callbacks,\n         mCurrentDialog = newDialog;\n         mCurrentDialog.show(mWindowManager, savedState);\n         mOrientationListener.enable();\n+\n+        if (!promptInfo.isAllowBackgroundAuthentication()) {\n+            mHandler.post(this::cancelIfOwnerIsNotInForeground);\n+        }\n     }\n \n     private void onDialogDismissed(@DismissedReason int reason) {\n",
    "added_lines": 7,
    "deleted_lines": 3,
    "changed_methods": "AuthController::handleTaskStackChanged, AuthController::BiometricTaskStackListener::onTaskStackChanged, AuthController::cancelIfOwnerIsNotInForeground, AuthController::showDialog"
   },
   {
    "filename": "AuthControllerTest.java",
    "diff": "@@ -554,16 +554,26 @@ public class AuthControllerTest extends SysuiTestCase {\n                 mAuthController.mLastBiometricPromptInfo.getAuthenticators());\n     }\n \n+    @Test\n+    public void testClientNotified_whenTaskStackChangesDuringShow() throws Exception {\n+        switchTask(\"other_package\");\n+        showDialog(new int[] {1} /* sensorIds */, false /* credentialAllowed */);\n+\n+        waitForIdleSync();\n+\n+        assertNull(mAuthController.mCurrentDialog);\n+        assertNull(mAuthController.mReceiver);\n+        verify(mDialog1).dismissWithoutCallback(true /* animate */);\n+        verify(mReceiver).onDialogDismissed(\n+                eq(BiometricPrompt.DISMISSED_REASON_USER_CANCEL),\n+                eq(null) /* credentialAttestation */);\n+    }\n+\n     @Test\n     public void testClientNotified_whenTaskStackChangesDuringAuthentication() throws Exception {\n         showDialog(new int[] {1} /* sensorIds */, false /* credentialAllowed */);\n \n-        List<ActivityManager.RunningTaskInfo> tasks = new ArrayList<>();\n-        ActivityManager.RunningTaskInfo taskInfo = mock(ActivityManager.RunningTaskInfo.class);\n-        taskInfo.topActivity = mock(ComponentName.class);\n-        when(taskInfo.topActivity.getPackageName()).thenReturn(\"other_package\");\n-        tasks.add(taskInfo);\n-        when(mActivityTaskManager.getTasks(anyInt())).thenReturn(tasks);\n+        switchTask(\"other_package\");\n \n         mAuthController.mTaskStackListener.onTaskStackChanged();\n         mTestableLooper.processAllMessages();\n@@ -640,6 +650,16 @@ public class AuthControllerTest extends SysuiTestCase {\n                 BIOMETRIC_MULTI_SENSOR_FACE_THEN_FINGERPRINT);\n     }\n \n+    private void switchTask(String packageName) {\n+        final List<ActivityManager.RunningTaskInfo> tasks = new ArrayList<>();\n+        final ActivityManager.RunningTaskInfo taskInfo =\n+                mock(ActivityManager.RunningTaskInfo.class);\n+        taskInfo.topActivity = mock(ComponentName.class);\n+        when(taskInfo.topActivity.getPackageName()).thenReturn(packageName);\n+        tasks.add(taskInfo);\n+        when(mActivityTaskManager.getTasks(anyInt())).thenReturn(tasks);\n+    }\n+\n     private PromptInfo createTestPromptInfo() {\n         PromptInfo promptInfo = new PromptInfo();\n \n",
    "added_lines": 26,
    "deleted_lines": 6,
    "changed_methods": "AuthControllerTest::switchTask, AuthControllerTest::testClientNotified_whenTaskStackChangesDuringShow, AuthControllerTest::testClientNotified_whenTaskStackChangesDuringAuthentication"
   },
   {
    "filename": "AuthenticationClient.java",
    "diff": "@@ -118,7 +118,7 @@ public abstract class AuthenticationClient<T> extends AcquisitionClient<T>\n         mIsStrongBiometric = isStrongBiometric;\n         mOperationId = operationId;\n         mRequireConfirmation = requireConfirmation;\n-        mActivityTaskManager = ActivityTaskManager.getInstance();\n+        mActivityTaskManager = getActivityTaskManager();\n         mBiometricManager = context.getSystemService(BiometricManager.class);\n         mTaskStackListener = taskStackListener;\n         mLockoutTracker = lockoutTracker;\n@@ -146,6 +146,10 @@ public abstract class AuthenticationClient<T> extends AcquisitionClient<T>\n         return mStartTimeMs;\n     }\n \n+    protected ActivityTaskManager getActivityTaskManager() {\n+        return ActivityTaskManager.getInstance();\n+    }\n+\n     @Override\n     public void binderDied() {\n         final boolean clearListener = !isBiometricPrompt();\n@@ -322,45 +326,50 @@ public abstract class AuthenticationClient<T> extends AcquisitionClient<T>\n                     sendCancelOnly(listener);\n                 }\n             });\n-        } else {\n-            // Allow system-defined limit of number of attempts before giving up\n-            final @LockoutTracker.LockoutMode int lockoutMode =\n-                    handleFailedAttempt(getTargetUserId());\n-            if (lockoutMode != LockoutTracker.LOCKOUT_NONE) {\n-                markAlreadyDone();\n-            }\n-\n-            final CoexCoordinator coordinator = CoexCoordinator.getInstance();\n-            coordinator.onAuthenticationRejected(SystemClock.uptimeMillis(), this, lockoutMode,\n-                    new CoexCoordinator.Callback() {\n-                @Override\n-                public void sendAuthenticationResult(boolean addAuthTokenIfStrong) {\n-                    if (listener != null) {\n-                        try {\n-                            listener.onAuthenticationFailed(getSensorId());\n-                        } catch (RemoteException e) {\n-                            Slog.e(TAG, \"Unable to notify listener\", e);\n-                        }\n-                    }\n+        } else { // not authenticated\n+            if (isBackgroundAuth) {\n+                Slog.e(TAG, \"cancelling due to background auth\");\n+                cancel();\n+            } else {\n+                // Allow system-defined limit of number of attempts before giving up\n+                final @LockoutTracker.LockoutMode int lockoutMode =\n+                        handleFailedAttempt(getTargetUserId());\n+                if (lockoutMode != LockoutTracker.LOCKOUT_NONE) {\n+                    markAlreadyDone();\n                 }\n \n-                @Override\n-                public void sendHapticFeedback() {\n-                    if (listener != null && mShouldVibrate) {\n-                        vibrateError();\n-                    }\n-                }\n+                final CoexCoordinator coordinator = CoexCoordinator.getInstance();\n+                coordinator.onAuthenticationRejected(SystemClock.uptimeMillis(), this, lockoutMode,\n+                        new CoexCoordinator.Callback() {\n+                            @Override\n+                            public void sendAuthenticationResult(boolean addAuthTokenIfStrong) {\n+                                if (listener != null) {\n+                                    try {\n+                                        listener.onAuthenticationFailed(getSensorId());\n+                                    } catch (RemoteException e) {\n+                                        Slog.e(TAG, \"Unable to notify listener\", e);\n+                                    }\n+                                }\n+                            }\n \n-                @Override\n-                public void handleLifecycleAfterAuth() {\n-                    AuthenticationClient.this.handleLifecycleAfterAuth(false /* authenticated */);\n-                }\n+                            @Override\n+                            public void sendHapticFeedback() {\n+                                if (listener != null && mShouldVibrate) {\n+                                    vibrateError();\n+                                }\n+                            }\n \n-                @Override\n-                public void sendAuthenticationCanceled() {\n-                    sendCancelOnly(listener);\n-                }\n-            });\n+                            @Override\n+                            public void handleLifecycleAfterAuth() {\n+                                AuthenticationClient.this.handleLifecycleAfterAuth(false /* authenticated */);\n+                            }\n+\n+                            @Override\n+                            public void sendAuthenticationCanceled() {\n+                                sendCancelOnly(listener);\n+                            }\n+                        });\n+            }\n         }\n     }\n \n",
    "added_lines": 45,
    "deleted_lines": 36,
    "changed_methods": "AuthenticationClient::getActivityTaskManager, AuthenticationClient::onAuthenticated, AuthenticationClient::AuthenticationClient"
   },
   {
    "filename": "FingerprintService.java",
    "diff": "@@ -331,12 +331,11 @@ public class FingerprintService extends SystemService {\n                     provider.second.getSensorProperties(sensorId);\n             if (!isKeyguard && !Utils.isSettings(getContext(), opPackageName)\n                     && sensorProps != null && sensorProps.isAnyUdfpsType()) {\n-                identity = Binder.clearCallingIdentity();\n                 try {\n                     return authenticateWithPrompt(operationId, sensorProps, userId, receiver,\n-                            ignoreEnrollmentState);\n-                } finally {\n-                    Binder.restoreCallingIdentity(identity);\n+                            ignoreEnrollmentState, opPackageName);\n+                } catch (PackageManager.NameNotFoundException e) {\n+                    Slog.e(TAG, \"Invalid package\", e);\n                 }\n             }\n             return provider.second.scheduleAuthenticate(provider.first, token, operationId, userId,\n@@ -349,12 +348,15 @@ public class FingerprintService extends SystemService {\n                 @NonNull final FingerprintSensorPropertiesInternal props,\n                 final int userId,\n                 final IFingerprintServiceReceiver receiver,\n-                boolean ignoreEnrollmentState) {\n+                boolean ignoreEnrollmentState,\n+                final String opPackageName) throws PackageManager.NameNotFoundException {\n \n             final Context context = getUiContext();\n+            final Context promptContext = context.createPackageContextAsUser(\n+                    opPackageName, 0 /* flags */, UserHandle.getUserHandleForUid(userId));\n             final Executor executor = context.getMainExecutor();\n \n-            final BiometricPrompt biometricPrompt = new BiometricPrompt.Builder(context)\n+            final BiometricPrompt biometricPrompt = new BiometricPrompt.Builder(promptContext)\n                     .setTitle(context.getString(R.string.biometric_dialog_default_title))\n                     .setSubtitle(context.getString(R.string.fingerprint_dialog_default_subtitle))\n                     .setNegativeButton(\n@@ -368,8 +370,7 @@ public class FingerprintService extends SystemService {\n                                     Slog.e(TAG, \"Remote exception in negative button onClick()\", e);\n                                 }\n                             })\n-                    .setAllowedSensorIds(new ArrayList<>(\n-                            Collections.singletonList(props.sensorId)))\n+                    .setIsForLegacyFingerprintManager(props.sensorId)\n                     .setIgnoreEnrollmentState(ignoreEnrollmentState)\n                     .build();\n \n@@ -423,8 +424,8 @@ public class FingerprintService extends SystemService {\n                         }\n                     };\n \n-            return biometricPrompt.authenticateUserForOperation(\n-                    new CancellationSignal(), executor, promptCallback, userId, operationId);\n+            return biometricPrompt.authenticateForOperation(\n+                    new CancellationSignal(), executor, promptCallback, operationId);\n         }\n \n         @Override\n",
    "added_lines": 11,
    "deleted_lines": 10,
    "changed_methods": "FingerprintService::FingerprintServiceWrapper::authenticateWithPrompt, FingerprintService::FingerprintServiceWrapper::authenticateWithPrompt, FingerprintService::FingerprintServiceWrapper::authenticate"
   }
  ]
 },
 {
  "hash": "b702b280e4cbf89243d6d1e272cdd7869dce2d07",
  "commit": "[DO NOT MERGE] Do not clear calling identify when using BiometricPrompt from FingerprintService.\n\nBug: 214261879\nTest: atest AuthControllerTest\nTest: Manually verify with test apps in bug\nChange-Id: I8ae9f2b8a970bf7e5d32121dc358f7d0f0d060b8\n(cherry picked from commit ac89f8682f0558c775e360d3c5fb84702e914989)\nMerged-In: I8ae9f2b8a970bf7e5d32121dc358f7d0f0d060b8",
  "files": [
   {
    "filename": "BiometricPrompt.java",
    "diff": "@@ -420,6 +420,18 @@ public class BiometricPrompt implements BiometricAuthenticator, BiometricConstan\n             return this;\n         }\n \n+        /**\n+         * Set if BiometricPrompt is being used by the legacy fingerprint manager API.\n+         * @param sensorId sensor id\n+         * @return This builder.\n+         * @hide\n+         */\n+        @NonNull\n+        public Builder setIsForLegacyFingerprintManager(int sensorId) {\n+            mPromptInfo.setIsForLegacyFingerprintManager(sensorId);\n+            return this;\n+        }\n+\n         /**\n          * Creates a {@link BiometricPrompt}.\n          *\n@@ -861,28 +873,36 @@ public class BiometricPrompt implements BiometricAuthenticator, BiometricConstan\n             @NonNull @CallbackExecutor Executor executor,\n             @NonNull AuthenticationCallback callback,\n             int userId) {\n-        authenticateUserForOperation(cancel, executor, callback, userId, 0 /* operationId */);\n+        if (cancel == null) {\n+            throw new IllegalArgumentException(\"Must supply a cancellation signal\");\n+        }\n+        if (executor == null) {\n+            throw new IllegalArgumentException(\"Must supply an executor\");\n+        }\n+        if (callback == null) {\n+            throw new IllegalArgumentException(\"Must supply a callback\");\n+        }\n+\n+        authenticateInternal(0 /* operationId */, cancel, executor, callback, userId);\n     }\n \n     /**\n-     * Authenticates for the given user and keystore operation.\n+     * Authenticates for the given keystore operation.\n      *\n      * @param cancel An object that can be used to cancel authentication\n      * @param executor An executor to handle callback events\n      * @param callback An object to receive authentication events\n-     * @param userId The user to authenticate\n      * @param operationId The keystore operation associated with authentication\n      *\n      * @return A requestId that can be used to cancel this operation.\n      *\n      * @hide\n      */\n-    @RequiresPermission(USE_BIOMETRIC_INTERNAL)\n-    public long authenticateUserForOperation(\n+    @RequiresPermission(USE_BIOMETRIC)\n+    public long authenticateForOperation(\n             @NonNull CancellationSignal cancel,\n             @NonNull @CallbackExecutor Executor executor,\n             @NonNull AuthenticationCallback callback,\n-            int userId,\n             long operationId) {\n         if (cancel == null) {\n             throw new IllegalArgumentException(\"Must supply a cancellation signal\");\n@@ -894,7 +914,7 @@ public class BiometricPrompt implements BiometricAuthenticator, BiometricConstan\n             throw new IllegalArgumentException(\"Must supply a callback\");\n         }\n \n-        return authenticateInternal(operationId, cancel, executor, callback, userId);\n+        return authenticateInternal(operationId, cancel, executor, callback, mContext.getUserId());\n     }\n \n     /**\n@@ -1028,7 +1048,7 @@ public class BiometricPrompt implements BiometricAuthenticator, BiometricConstan\n     private void cancelAuthentication(long requestId) {\n         if (mService != null) {\n             try {\n-                mService.cancelAuthentication(mToken, mContext.getOpPackageName(), requestId);\n+                mService.cancelAuthentication(mToken, mContext.getPackageName(), requestId);\n             } catch (RemoteException e) {\n                 Log.e(TAG, \"Unable to cancel authentication\", e);\n             }\n@@ -1087,7 +1107,7 @@ public class BiometricPrompt implements BiometricAuthenticator, BiometricConstan\n             }\n \n             final long authId = mService.authenticate(mToken, operationId, userId,\n-                    mBiometricServiceReceiver, mContext.getOpPackageName(), promptInfo);\n+                    mBiometricServiceReceiver, mContext.getPackageName(), promptInfo);\n             cancel.setOnCancelListener(new OnAuthenticationCancelListener(authId));\n             return authId;\n         } catch (RemoteException e) {\n",
    "added_lines": 29,
    "deleted_lines": 9,
    "changed_methods": "BiometricPrompt::Builder::setIsForLegacyFingerprintManager, BiometricPrompt::authenticateUserForOperation, BiometricPrompt::authenticateForOperation, BiometricPrompt::authenticateUser, BiometricPrompt::authenticateInternal, BiometricPrompt::cancelAuthentication"
   },
   {
    "filename": "PromptInfo.java",
    "diff": "@@ -46,6 +46,7 @@ public class PromptInfo implements Parcelable {\n     @NonNull private List<Integer> mAllowedSensorIds = new ArrayList<>();\n     private boolean mAllowBackgroundAuthentication;\n     private boolean mIgnoreEnrollmentState;\n+    private boolean mIsForLegacyFingerprintManager = false;\n \n     public PromptInfo() {\n \n@@ -68,6 +69,7 @@ public class PromptInfo implements Parcelable {\n         mAllowedSensorIds = in.readArrayList(Integer.class.getClassLoader());\n         mAllowBackgroundAuthentication = in.readBoolean();\n         mIgnoreEnrollmentState = in.readBoolean();\n+        mIsForLegacyFingerprintManager = in.readBoolean();\n     }\n \n     public static final Creator<PromptInfo> CREATOR = new Creator<PromptInfo>() {\n@@ -105,10 +107,15 @@ public class PromptInfo implements Parcelable {\n         dest.writeList(mAllowedSensorIds);\n         dest.writeBoolean(mAllowBackgroundAuthentication);\n         dest.writeBoolean(mIgnoreEnrollmentState);\n+        dest.writeBoolean(mIsForLegacyFingerprintManager);\n     }\n \n     public boolean containsTestConfigurations() {\n-        if (!mAllowedSensorIds.isEmpty()) {\n+        if (mIsForLegacyFingerprintManager\n+                && mAllowedSensorIds.size() == 1\n+                && !mAllowBackgroundAuthentication) {\n+            return false;\n+        } else if (!mAllowedSensorIds.isEmpty()) {\n             return true;\n         } else if (mAllowBackgroundAuthentication) {\n             return true;\n@@ -188,7 +195,8 @@ public class PromptInfo implements Parcelable {\n     }\n \n     public void setAllowedSensorIds(@NonNull List<Integer> sensorIds) {\n-        mAllowedSensorIds = sensorIds;\n+        mAllowedSensorIds.clear();\n+        mAllowedSensorIds.addAll(sensorIds);\n     }\n \n     public void setAllowBackgroundAuthentication(boolean allow) {\n@@ -199,6 +207,12 @@ public class PromptInfo implements Parcelable {\n         mIgnoreEnrollmentState = ignoreEnrollmentState;\n     }\n \n+    public void setIsForLegacyFingerprintManager(int sensorId) {\n+        mIsForLegacyFingerprintManager = true;\n+        mAllowedSensorIds.clear();\n+        mAllowedSensorIds.add(sensorId);\n+    }\n+\n     // Getters\n \n     public CharSequence getTitle() {\n@@ -272,4 +286,8 @@ public class PromptInfo implements Parcelable {\n     public boolean isIgnoreEnrollmentState() {\n         return mIgnoreEnrollmentState;\n     }\n+\n+    public boolean isForLegacyFingerprintManager() {\n+        return mIsForLegacyFingerprintManager;\n+    }\n }\n",
    "added_lines": 20,
    "deleted_lines": 2,
    "changed_methods": "PromptInfo::PromptInfo, PromptInfo::isForLegacyFingerprintManager, PromptInfo::setIsForLegacyFingerprintManager, PromptInfo::containsTestConfigurations, PromptInfo::setAllowedSensorIds, PromptInfo::writeToParcel"
   },
   {
    "filename": "AuthController.java",
    "diff": "@@ -134,7 +134,7 @@ public class AuthController extends SystemUI implements CommandQueue.Callbacks,\n     private class BiometricTaskStackListener extends TaskStackListener {\n         @Override\n         public void onTaskStackChanged() {\n-            mHandler.post(AuthController.this::handleTaskStackChanged);\n+            mHandler.post(AuthController.this::cancelIfOwnerIsNotInForeground);\n         }\n     }\n \n@@ -181,7 +181,7 @@ public class AuthController extends SystemUI implements CommandQueue.Callbacks,\n         }\n     };\n \n-    private void handleTaskStackChanged() {\n+    private void cancelIfOwnerIsNotInForeground() {\n         mExecution.assertIsMainThread();\n         if (mCurrentDialog != null) {\n             try {\n@@ -193,7 +193,7 @@ public class AuthController extends SystemUI implements CommandQueue.Callbacks,\n                     final String topPackage = runningTasks.get(0).topActivity.getPackageName();\n                     if (!topPackage.contentEquals(clientPackage)\n                             && !Utils.isSystem(mContext, clientPackage)) {\n-                        Log.w(TAG, \"Evicting client due to: \" + topPackage);\n+                        Log.e(TAG, \"Evicting client due to: \" + topPackage);\n                         mCurrentDialog.dismissWithoutCallback(true /* animate */);\n                         mCurrentDialog = null;\n                         mOrientationListener.disable();\n@@ -814,6 +814,10 @@ public class AuthController extends SystemUI implements CommandQueue.Callbacks,\n         mCurrentDialog = newDialog;\n         mCurrentDialog.show(mWindowManager, savedState);\n         mOrientationListener.enable();\n+\n+        if (!promptInfo.isAllowBackgroundAuthentication()) {\n+            mHandler.post(this::cancelIfOwnerIsNotInForeground);\n+        }\n     }\n \n     private void onDialogDismissed(@DismissedReason int reason) {\n",
    "added_lines": 7,
    "deleted_lines": 3,
    "changed_methods": "AuthController::handleTaskStackChanged, AuthController::BiometricTaskStackListener::onTaskStackChanged, AuthController::cancelIfOwnerIsNotInForeground, AuthController::showDialog"
   },
   {
    "filename": "AuthControllerTest.java",
    "diff": "@@ -554,16 +554,26 @@ public class AuthControllerTest extends SysuiTestCase {\n                 mAuthController.mLastBiometricPromptInfo.getAuthenticators());\n     }\n \n+    @Test\n+    public void testClientNotified_whenTaskStackChangesDuringShow() throws Exception {\n+        switchTask(\"other_package\");\n+        showDialog(new int[] {1} /* sensorIds */, false /* credentialAllowed */);\n+\n+        waitForIdleSync();\n+\n+        assertNull(mAuthController.mCurrentDialog);\n+        assertNull(mAuthController.mReceiver);\n+        verify(mDialog1).dismissWithoutCallback(true /* animate */);\n+        verify(mReceiver).onDialogDismissed(\n+                eq(BiometricPrompt.DISMISSED_REASON_USER_CANCEL),\n+                eq(null) /* credentialAttestation */);\n+    }\n+\n     @Test\n     public void testClientNotified_whenTaskStackChangesDuringAuthentication() throws Exception {\n         showDialog(new int[] {1} /* sensorIds */, false /* credentialAllowed */);\n \n-        List<ActivityManager.RunningTaskInfo> tasks = new ArrayList<>();\n-        ActivityManager.RunningTaskInfo taskInfo = mock(ActivityManager.RunningTaskInfo.class);\n-        taskInfo.topActivity = mock(ComponentName.class);\n-        when(taskInfo.topActivity.getPackageName()).thenReturn(\"other_package\");\n-        tasks.add(taskInfo);\n-        when(mActivityTaskManager.getTasks(anyInt())).thenReturn(tasks);\n+        switchTask(\"other_package\");\n \n         mAuthController.mTaskStackListener.onTaskStackChanged();\n         mTestableLooper.processAllMessages();\n@@ -640,6 +650,16 @@ public class AuthControllerTest extends SysuiTestCase {\n                 BIOMETRIC_MULTI_SENSOR_FACE_THEN_FINGERPRINT);\n     }\n \n+    private void switchTask(String packageName) {\n+        final List<ActivityManager.RunningTaskInfo> tasks = new ArrayList<>();\n+        final ActivityManager.RunningTaskInfo taskInfo =\n+                mock(ActivityManager.RunningTaskInfo.class);\n+        taskInfo.topActivity = mock(ComponentName.class);\n+        when(taskInfo.topActivity.getPackageName()).thenReturn(packageName);\n+        tasks.add(taskInfo);\n+        when(mActivityTaskManager.getTasks(anyInt())).thenReturn(tasks);\n+    }\n+\n     private PromptInfo createTestPromptInfo() {\n         PromptInfo promptInfo = new PromptInfo();\n \n",
    "added_lines": 26,
    "deleted_lines": 6,
    "changed_methods": "AuthControllerTest::switchTask, AuthControllerTest::testClientNotified_whenTaskStackChangesDuringShow, AuthControllerTest::testClientNotified_whenTaskStackChangesDuringAuthentication"
   },
   {
    "filename": "AuthenticationClient.java",
    "diff": "@@ -118,7 +118,7 @@ public abstract class AuthenticationClient<T> extends AcquisitionClient<T>\n         mIsStrongBiometric = isStrongBiometric;\n         mOperationId = operationId;\n         mRequireConfirmation = requireConfirmation;\n-        mActivityTaskManager = ActivityTaskManager.getInstance();\n+        mActivityTaskManager = getActivityTaskManager();\n         mBiometricManager = context.getSystemService(BiometricManager.class);\n         mTaskStackListener = taskStackListener;\n         mLockoutTracker = lockoutTracker;\n@@ -146,6 +146,10 @@ public abstract class AuthenticationClient<T> extends AcquisitionClient<T>\n         return mStartTimeMs;\n     }\n \n+    protected ActivityTaskManager getActivityTaskManager() {\n+        return ActivityTaskManager.getInstance();\n+    }\n+\n     @Override\n     public void binderDied() {\n         final boolean clearListener = !isBiometricPrompt();\n@@ -322,45 +326,50 @@ public abstract class AuthenticationClient<T> extends AcquisitionClient<T>\n                     sendCancelOnly(listener);\n                 }\n             });\n-        } else {\n-            // Allow system-defined limit of number of attempts before giving up\n-            final @LockoutTracker.LockoutMode int lockoutMode =\n-                    handleFailedAttempt(getTargetUserId());\n-            if (lockoutMode != LockoutTracker.LOCKOUT_NONE) {\n-                markAlreadyDone();\n-            }\n-\n-            final CoexCoordinator coordinator = CoexCoordinator.getInstance();\n-            coordinator.onAuthenticationRejected(SystemClock.uptimeMillis(), this, lockoutMode,\n-                    new CoexCoordinator.Callback() {\n-                @Override\n-                public void sendAuthenticationResult(boolean addAuthTokenIfStrong) {\n-                    if (listener != null) {\n-                        try {\n-                            listener.onAuthenticationFailed(getSensorId());\n-                        } catch (RemoteException e) {\n-                            Slog.e(TAG, \"Unable to notify listener\", e);\n-                        }\n-                    }\n+        } else { // not authenticated\n+            if (isBackgroundAuth) {\n+                Slog.e(TAG, \"cancelling due to background auth\");\n+                cancel();\n+            } else {\n+                // Allow system-defined limit of number of attempts before giving up\n+                final @LockoutTracker.LockoutMode int lockoutMode =\n+                        handleFailedAttempt(getTargetUserId());\n+                if (lockoutMode != LockoutTracker.LOCKOUT_NONE) {\n+                    markAlreadyDone();\n                 }\n \n-                @Override\n-                public void sendHapticFeedback() {\n-                    if (listener != null && mShouldVibrate) {\n-                        vibrateError();\n-                    }\n-                }\n+                final CoexCoordinator coordinator = CoexCoordinator.getInstance();\n+                coordinator.onAuthenticationRejected(SystemClock.uptimeMillis(), this, lockoutMode,\n+                        new CoexCoordinator.Callback() {\n+                            @Override\n+                            public void sendAuthenticationResult(boolean addAuthTokenIfStrong) {\n+                                if (listener != null) {\n+                                    try {\n+                                        listener.onAuthenticationFailed(getSensorId());\n+                                    } catch (RemoteException e) {\n+                                        Slog.e(TAG, \"Unable to notify listener\", e);\n+                                    }\n+                                }\n+                            }\n \n-                @Override\n-                public void handleLifecycleAfterAuth() {\n-                    AuthenticationClient.this.handleLifecycleAfterAuth(false /* authenticated */);\n-                }\n+                            @Override\n+                            public void sendHapticFeedback() {\n+                                if (listener != null && mShouldVibrate) {\n+                                    vibrateError();\n+                                }\n+                            }\n \n-                @Override\n-                public void sendAuthenticationCanceled() {\n-                    sendCancelOnly(listener);\n-                }\n-            });\n+                            @Override\n+                            public void handleLifecycleAfterAuth() {\n+                                AuthenticationClient.this.handleLifecycleAfterAuth(false /* authenticated */);\n+                            }\n+\n+                            @Override\n+                            public void sendAuthenticationCanceled() {\n+                                sendCancelOnly(listener);\n+                            }\n+                        });\n+            }\n         }\n     }\n \n",
    "added_lines": 45,
    "deleted_lines": 36,
    "changed_methods": "AuthenticationClient::getActivityTaskManager, AuthenticationClient::onAuthenticated, AuthenticationClient::AuthenticationClient"
   },
   {
    "filename": "FingerprintService.java",
    "diff": "@@ -331,12 +331,11 @@ public class FingerprintService extends SystemService {\n                     provider.second.getSensorProperties(sensorId);\n             if (!isKeyguard && !Utils.isSettings(getContext(), opPackageName)\n                     && sensorProps != null && sensorProps.isAnyUdfpsType()) {\n-                identity = Binder.clearCallingIdentity();\n                 try {\n                     return authenticateWithPrompt(operationId, sensorProps, userId, receiver,\n-                            ignoreEnrollmentState);\n-                } finally {\n-                    Binder.restoreCallingIdentity(identity);\n+                            ignoreEnrollmentState, opPackageName);\n+                } catch (PackageManager.NameNotFoundException e) {\n+                    Slog.e(TAG, \"Invalid package\", e);\n                 }\n             }\n             return provider.second.scheduleAuthenticate(provider.first, token, operationId, userId,\n@@ -349,12 +348,15 @@ public class FingerprintService extends SystemService {\n                 @NonNull final FingerprintSensorPropertiesInternal props,\n                 final int userId,\n                 final IFingerprintServiceReceiver receiver,\n-                boolean ignoreEnrollmentState) {\n+                boolean ignoreEnrollmentState,\n+                final String opPackageName) throws PackageManager.NameNotFoundException {\n \n             final Context context = getUiContext();\n+            final Context promptContext = context.createPackageContextAsUser(\n+                    opPackageName, 0 /* flags */, UserHandle.getUserHandleForUid(userId));\n             final Executor executor = context.getMainExecutor();\n \n-            final BiometricPrompt biometricPrompt = new BiometricPrompt.Builder(context)\n+            final BiometricPrompt biometricPrompt = new BiometricPrompt.Builder(promptContext)\n                     .setTitle(context.getString(R.string.biometric_dialog_default_title))\n                     .setSubtitle(context.getString(R.string.fingerprint_dialog_default_subtitle))\n                     .setNegativeButton(\n@@ -368,8 +370,7 @@ public class FingerprintService extends SystemService {\n                                     Slog.e(TAG, \"Remote exception in negative button onClick()\", e);\n                                 }\n                             })\n-                    .setAllowedSensorIds(new ArrayList<>(\n-                            Collections.singletonList(props.sensorId)))\n+                    .setIsForLegacyFingerprintManager(props.sensorId)\n                     .setIgnoreEnrollmentState(ignoreEnrollmentState)\n                     .build();\n \n@@ -423,8 +424,8 @@ public class FingerprintService extends SystemService {\n                         }\n                     };\n \n-            return biometricPrompt.authenticateUserForOperation(\n-                    new CancellationSignal(), executor, promptCallback, userId, operationId);\n+            return biometricPrompt.authenticateForOperation(\n+                    new CancellationSignal(), executor, promptCallback, operationId);\n         }\n \n         @Override\n",
    "added_lines": 11,
    "deleted_lines": 10,
    "changed_methods": "FingerprintService::FingerprintServiceWrapper::authenticateWithPrompt, FingerprintService::FingerprintServiceWrapper::authenticateWithPrompt, FingerprintService::FingerprintServiceWrapper::authenticate"
   }
  ]
 },
 {
  "hash": "b702b280e4cbf89243d6d1e272cdd7869dce2d07",
  "commit": "[DO NOT MERGE] Do not clear calling identify when using BiometricPrompt from FingerprintService.\n\nBug: 214261879\nTest: atest AuthControllerTest\nTest: Manually verify with test apps in bug\nChange-Id: I8ae9f2b8a970bf7e5d32121dc358f7d0f0d060b8\n(cherry picked from commit ac89f8682f0558c775e360d3c5fb84702e914989)\nMerged-In: I8ae9f2b8a970bf7e5d32121dc358f7d0f0d060b8",
  "files": [
   {
    "filename": "BiometricPrompt.java",
    "diff": "@@ -420,6 +420,18 @@ public class BiometricPrompt implements BiometricAuthenticator, BiometricConstan\n             return this;\n         }\n \n+        /**\n+         * Set if BiometricPrompt is being used by the legacy fingerprint manager API.\n+         * @param sensorId sensor id\n+         * @return This builder.\n+         * @hide\n+         */\n+        @NonNull\n+        public Builder setIsForLegacyFingerprintManager(int sensorId) {\n+            mPromptInfo.setIsForLegacyFingerprintManager(sensorId);\n+            return this;\n+        }\n+\n         /**\n          * Creates a {@link BiometricPrompt}.\n          *\n@@ -861,28 +873,36 @@ public class BiometricPrompt implements BiometricAuthenticator, BiometricConstan\n             @NonNull @CallbackExecutor Executor executor,\n             @NonNull AuthenticationCallback callback,\n             int userId) {\n-        authenticateUserForOperation(cancel, executor, callback, userId, 0 /* operationId */);\n+        if (cancel == null) {\n+            throw new IllegalArgumentException(\"Must supply a cancellation signal\");\n+        }\n+        if (executor == null) {\n+            throw new IllegalArgumentException(\"Must supply an executor\");\n+        }\n+        if (callback == null) {\n+            throw new IllegalArgumentException(\"Must supply a callback\");\n+        }\n+\n+        authenticateInternal(0 /* operationId */, cancel, executor, callback, userId);\n     }\n \n     /**\n-     * Authenticates for the given user and keystore operation.\n+     * Authenticates for the given keystore operation.\n      *\n      * @param cancel An object that can be used to cancel authentication\n      * @param executor An executor to handle callback events\n      * @param callback An object to receive authentication events\n-     * @param userId The user to authenticate\n      * @param operationId The keystore operation associated with authentication\n      *\n      * @return A requestId that can be used to cancel this operation.\n      *\n      * @hide\n      */\n-    @RequiresPermission(USE_BIOMETRIC_INTERNAL)\n-    public long authenticateUserForOperation(\n+    @RequiresPermission(USE_BIOMETRIC)\n+    public long authenticateForOperation(\n             @NonNull CancellationSignal cancel,\n             @NonNull @CallbackExecutor Executor executor,\n             @NonNull AuthenticationCallback callback,\n-            int userId,\n             long operationId) {\n         if (cancel == null) {\n             throw new IllegalArgumentException(\"Must supply a cancellation signal\");\n@@ -894,7 +914,7 @@ public class BiometricPrompt implements BiometricAuthenticator, BiometricConstan\n             throw new IllegalArgumentException(\"Must supply a callback\");\n         }\n \n-        return authenticateInternal(operationId, cancel, executor, callback, userId);\n+        return authenticateInternal(operationId, cancel, executor, callback, mContext.getUserId());\n     }\n \n     /**\n@@ -1028,7 +1048,7 @@ public class BiometricPrompt implements BiometricAuthenticator, BiometricConstan\n     private void cancelAuthentication(long requestId) {\n         if (mService != null) {\n             try {\n-                mService.cancelAuthentication(mToken, mContext.getOpPackageName(), requestId);\n+                mService.cancelAuthentication(mToken, mContext.getPackageName(), requestId);\n             } catch (RemoteException e) {\n                 Log.e(TAG, \"Unable to cancel authentication\", e);\n             }\n@@ -1087,7 +1107,7 @@ public class BiometricPrompt implements BiometricAuthenticator, BiometricConstan\n             }\n \n             final long authId = mService.authenticate(mToken, operationId, userId,\n-                    mBiometricServiceReceiver, mContext.getOpPackageName(), promptInfo);\n+                    mBiometricServiceReceiver, mContext.getPackageName(), promptInfo);\n             cancel.setOnCancelListener(new OnAuthenticationCancelListener(authId));\n             return authId;\n         } catch (RemoteException e) {\n",
    "added_lines": 29,
    "deleted_lines": 9,
    "changed_methods": "BiometricPrompt::Builder::setIsForLegacyFingerprintManager, BiometricPrompt::authenticateUserForOperation, BiometricPrompt::authenticateForOperation, BiometricPrompt::authenticateUser, BiometricPrompt::authenticateInternal, BiometricPrompt::cancelAuthentication"
   },
   {
    "filename": "PromptInfo.java",
    "diff": "@@ -46,6 +46,7 @@ public class PromptInfo implements Parcelable {\n     @NonNull private List<Integer> mAllowedSensorIds = new ArrayList<>();\n     private boolean mAllowBackgroundAuthentication;\n     private boolean mIgnoreEnrollmentState;\n+    private boolean mIsForLegacyFingerprintManager = false;\n \n     public PromptInfo() {\n \n@@ -68,6 +69,7 @@ public class PromptInfo implements Parcelable {\n         mAllowedSensorIds = in.readArrayList(Integer.class.getClassLoader());\n         mAllowBackgroundAuthentication = in.readBoolean();\n         mIgnoreEnrollmentState = in.readBoolean();\n+        mIsForLegacyFingerprintManager = in.readBoolean();\n     }\n \n     public static final Creator<PromptInfo> CREATOR = new Creator<PromptInfo>() {\n@@ -105,10 +107,15 @@ public class PromptInfo implements Parcelable {\n         dest.writeList(mAllowedSensorIds);\n         dest.writeBoolean(mAllowBackgroundAuthentication);\n         dest.writeBoolean(mIgnoreEnrollmentState);\n+        dest.writeBoolean(mIsForLegacyFingerprintManager);\n     }\n \n     public boolean containsTestConfigurations() {\n-        if (!mAllowedSensorIds.isEmpty()) {\n+        if (mIsForLegacyFingerprintManager\n+                && mAllowedSensorIds.size() == 1\n+                && !mAllowBackgroundAuthentication) {\n+            return false;\n+        } else if (!mAllowedSensorIds.isEmpty()) {\n             return true;\n         } else if (mAllowBackgroundAuthentication) {\n             return true;\n@@ -188,7 +195,8 @@ public class PromptInfo implements Parcelable {\n     }\n \n     public void setAllowedSensorIds(@NonNull List<Integer> sensorIds) {\n-        mAllowedSensorIds = sensorIds;\n+        mAllowedSensorIds.clear();\n+        mAllowedSensorIds.addAll(sensorIds);\n     }\n \n     public void setAllowBackgroundAuthentication(boolean allow) {\n@@ -199,6 +207,12 @@ public class PromptInfo implements Parcelable {\n         mIgnoreEnrollmentState = ignoreEnrollmentState;\n     }\n \n+    public void setIsForLegacyFingerprintManager(int sensorId) {\n+        mIsForLegacyFingerprintManager = true;\n+        mAllowedSensorIds.clear();\n+        mAllowedSensorIds.add(sensorId);\n+    }\n+\n     // Getters\n \n     public CharSequence getTitle() {\n@@ -272,4 +286,8 @@ public class PromptInfo implements Parcelable {\n     public boolean isIgnoreEnrollmentState() {\n         return mIgnoreEnrollmentState;\n     }\n+\n+    public boolean isForLegacyFingerprintManager() {\n+        return mIsForLegacyFingerprintManager;\n+    }\n }\n",
    "added_lines": 20,
    "deleted_lines": 2,
    "changed_methods": "PromptInfo::PromptInfo, PromptInfo::isForLegacyFingerprintManager, PromptInfo::setIsForLegacyFingerprintManager, PromptInfo::containsTestConfigurations, PromptInfo::setAllowedSensorIds, PromptInfo::writeToParcel"
   },
   {
    "filename": "AuthController.java",
    "diff": "@@ -134,7 +134,7 @@ public class AuthController extends SystemUI implements CommandQueue.Callbacks,\n     private class BiometricTaskStackListener extends TaskStackListener {\n         @Override\n         public void onTaskStackChanged() {\n-            mHandler.post(AuthController.this::handleTaskStackChanged);\n+            mHandler.post(AuthController.this::cancelIfOwnerIsNotInForeground);\n         }\n     }\n \n@@ -181,7 +181,7 @@ public class AuthController extends SystemUI implements CommandQueue.Callbacks,\n         }\n     };\n \n-    private void handleTaskStackChanged() {\n+    private void cancelIfOwnerIsNotInForeground() {\n         mExecution.assertIsMainThread();\n         if (mCurrentDialog != null) {\n             try {\n@@ -193,7 +193,7 @@ public class AuthController extends SystemUI implements CommandQueue.Callbacks,\n                     final String topPackage = runningTasks.get(0).topActivity.getPackageName();\n                     if (!topPackage.contentEquals(clientPackage)\n                             && !Utils.isSystem(mContext, clientPackage)) {\n-                        Log.w(TAG, \"Evicting client due to: \" + topPackage);\n+                        Log.e(TAG, \"Evicting client due to: \" + topPackage);\n                         mCurrentDialog.dismissWithoutCallback(true /* animate */);\n                         mCurrentDialog = null;\n                         mOrientationListener.disable();\n@@ -814,6 +814,10 @@ public class AuthController extends SystemUI implements CommandQueue.Callbacks,\n         mCurrentDialog = newDialog;\n         mCurrentDialog.show(mWindowManager, savedState);\n         mOrientationListener.enable();\n+\n+        if (!promptInfo.isAllowBackgroundAuthentication()) {\n+            mHandler.post(this::cancelIfOwnerIsNotInForeground);\n+        }\n     }\n \n     private void onDialogDismissed(@DismissedReason int reason) {\n",
    "added_lines": 7,
    "deleted_lines": 3,
    "changed_methods": "AuthController::handleTaskStackChanged, AuthController::BiometricTaskStackListener::onTaskStackChanged, AuthController::cancelIfOwnerIsNotInForeground, AuthController::showDialog"
   },
   {
    "filename": "AuthControllerTest.java",
    "diff": "@@ -554,16 +554,26 @@ public class AuthControllerTest extends SysuiTestCase {\n                 mAuthController.mLastBiometricPromptInfo.getAuthenticators());\n     }\n \n+    @Test\n+    public void testClientNotified_whenTaskStackChangesDuringShow() throws Exception {\n+        switchTask(\"other_package\");\n+        showDialog(new int[] {1} /* sensorIds */, false /* credentialAllowed */);\n+\n+        waitForIdleSync();\n+\n+        assertNull(mAuthController.mCurrentDialog);\n+        assertNull(mAuthController.mReceiver);\n+        verify(mDialog1).dismissWithoutCallback(true /* animate */);\n+        verify(mReceiver).onDialogDismissed(\n+                eq(BiometricPrompt.DISMISSED_REASON_USER_CANCEL),\n+                eq(null) /* credentialAttestation */);\n+    }\n+\n     @Test\n     public void testClientNotified_whenTaskStackChangesDuringAuthentication() throws Exception {\n         showDialog(new int[] {1} /* sensorIds */, false /* credentialAllowed */);\n \n-        List<ActivityManager.RunningTaskInfo> tasks = new ArrayList<>();\n-        ActivityManager.RunningTaskInfo taskInfo = mock(ActivityManager.RunningTaskInfo.class);\n-        taskInfo.topActivity = mock(ComponentName.class);\n-        when(taskInfo.topActivity.getPackageName()).thenReturn(\"other_package\");\n-        tasks.add(taskInfo);\n-        when(mActivityTaskManager.getTasks(anyInt())).thenReturn(tasks);\n+        switchTask(\"other_package\");\n \n         mAuthController.mTaskStackListener.onTaskStackChanged();\n         mTestableLooper.processAllMessages();\n@@ -640,6 +650,16 @@ public class AuthControllerTest extends SysuiTestCase {\n                 BIOMETRIC_MULTI_SENSOR_FACE_THEN_FINGERPRINT);\n     }\n \n+    private void switchTask(String packageName) {\n+        final List<ActivityManager.RunningTaskInfo> tasks = new ArrayList<>();\n+        final ActivityManager.RunningTaskInfo taskInfo =\n+                mock(ActivityManager.RunningTaskInfo.class);\n+        taskInfo.topActivity = mock(ComponentName.class);\n+        when(taskInfo.topActivity.getPackageName()).thenReturn(packageName);\n+        tasks.add(taskInfo);\n+        when(mActivityTaskManager.getTasks(anyInt())).thenReturn(tasks);\n+    }\n+\n     private PromptInfo createTestPromptInfo() {\n         PromptInfo promptInfo = new PromptInfo();\n \n",
    "added_lines": 26,
    "deleted_lines": 6,
    "changed_methods": "AuthControllerTest::switchTask, AuthControllerTest::testClientNotified_whenTaskStackChangesDuringShow, AuthControllerTest::testClientNotified_whenTaskStackChangesDuringAuthentication"
   },
   {
    "filename": "AuthenticationClient.java",
    "diff": "@@ -118,7 +118,7 @@ public abstract class AuthenticationClient<T> extends AcquisitionClient<T>\n         mIsStrongBiometric = isStrongBiometric;\n         mOperationId = operationId;\n         mRequireConfirmation = requireConfirmation;\n-        mActivityTaskManager = ActivityTaskManager.getInstance();\n+        mActivityTaskManager = getActivityTaskManager();\n         mBiometricManager = context.getSystemService(BiometricManager.class);\n         mTaskStackListener = taskStackListener;\n         mLockoutTracker = lockoutTracker;\n@@ -146,6 +146,10 @@ public abstract class AuthenticationClient<T> extends AcquisitionClient<T>\n         return mStartTimeMs;\n     }\n \n+    protected ActivityTaskManager getActivityTaskManager() {\n+        return ActivityTaskManager.getInstance();\n+    }\n+\n     @Override\n     public void binderDied() {\n         final boolean clearListener = !isBiometricPrompt();\n@@ -322,45 +326,50 @@ public abstract class AuthenticationClient<T> extends AcquisitionClient<T>\n                     sendCancelOnly(listener);\n                 }\n             });\n-        } else {\n-            // Allow system-defined limit of number of attempts before giving up\n-            final @LockoutTracker.LockoutMode int lockoutMode =\n-                    handleFailedAttempt(getTargetUserId());\n-            if (lockoutMode != LockoutTracker.LOCKOUT_NONE) {\n-                markAlreadyDone();\n-            }\n-\n-            final CoexCoordinator coordinator = CoexCoordinator.getInstance();\n-            coordinator.onAuthenticationRejected(SystemClock.uptimeMillis(), this, lockoutMode,\n-                    new CoexCoordinator.Callback() {\n-                @Override\n-                public void sendAuthenticationResult(boolean addAuthTokenIfStrong) {\n-                    if (listener != null) {\n-                        try {\n-                            listener.onAuthenticationFailed(getSensorId());\n-                        } catch (RemoteException e) {\n-                            Slog.e(TAG, \"Unable to notify listener\", e);\n-                        }\n-                    }\n+        } else { // not authenticated\n+            if (isBackgroundAuth) {\n+                Slog.e(TAG, \"cancelling due to background auth\");\n+                cancel();\n+            } else {\n+                // Allow system-defined limit of number of attempts before giving up\n+                final @LockoutTracker.LockoutMode int lockoutMode =\n+                        handleFailedAttempt(getTargetUserId());\n+                if (lockoutMode != LockoutTracker.LOCKOUT_NONE) {\n+                    markAlreadyDone();\n                 }\n \n-                @Override\n-                public void sendHapticFeedback() {\n-                    if (listener != null && mShouldVibrate) {\n-                        vibrateError();\n-                    }\n-                }\n+                final CoexCoordinator coordinator = CoexCoordinator.getInstance();\n+                coordinator.onAuthenticationRejected(SystemClock.uptimeMillis(), this, lockoutMode,\n+                        new CoexCoordinator.Callback() {\n+                            @Override\n+                            public void sendAuthenticationResult(boolean addAuthTokenIfStrong) {\n+                                if (listener != null) {\n+                                    try {\n+                                        listener.onAuthenticationFailed(getSensorId());\n+                                    } catch (RemoteException e) {\n+                                        Slog.e(TAG, \"Unable to notify listener\", e);\n+                                    }\n+                                }\n+                            }\n \n-                @Override\n-                public void handleLifecycleAfterAuth() {\n-                    AuthenticationClient.this.handleLifecycleAfterAuth(false /* authenticated */);\n-                }\n+                            @Override\n+                            public void sendHapticFeedback() {\n+                                if (listener != null && mShouldVibrate) {\n+                                    vibrateError();\n+                                }\n+                            }\n \n-                @Override\n-                public void sendAuthenticationCanceled() {\n-                    sendCancelOnly(listener);\n-                }\n-            });\n+                            @Override\n+                            public void handleLifecycleAfterAuth() {\n+                                AuthenticationClient.this.handleLifecycleAfterAuth(false /* authenticated */);\n+                            }\n+\n+                            @Override\n+                            public void sendAuthenticationCanceled() {\n+                                sendCancelOnly(listener);\n+                            }\n+                        });\n+            }\n         }\n     }\n \n",
    "added_lines": 45,
    "deleted_lines": 36,
    "changed_methods": "AuthenticationClient::getActivityTaskManager, AuthenticationClient::onAuthenticated, AuthenticationClient::AuthenticationClient"
   },
   {
    "filename": "FingerprintService.java",
    "diff": "@@ -331,12 +331,11 @@ public class FingerprintService extends SystemService {\n                     provider.second.getSensorProperties(sensorId);\n             if (!isKeyguard && !Utils.isSettings(getContext(), opPackageName)\n                     && sensorProps != null && sensorProps.isAnyUdfpsType()) {\n-                identity = Binder.clearCallingIdentity();\n                 try {\n                     return authenticateWithPrompt(operationId, sensorProps, userId, receiver,\n-                            ignoreEnrollmentState);\n-                } finally {\n-                    Binder.restoreCallingIdentity(identity);\n+                            ignoreEnrollmentState, opPackageName);\n+                } catch (PackageManager.NameNotFoundException e) {\n+                    Slog.e(TAG, \"Invalid package\", e);\n                 }\n             }\n             return provider.second.scheduleAuthenticate(provider.first, token, operationId, userId,\n@@ -349,12 +348,15 @@ public class FingerprintService extends SystemService {\n                 @NonNull final FingerprintSensorPropertiesInternal props,\n                 final int userId,\n                 final IFingerprintServiceReceiver receiver,\n-                boolean ignoreEnrollmentState) {\n+                boolean ignoreEnrollmentState,\n+                final String opPackageName) throws PackageManager.NameNotFoundException {\n \n             final Context context = getUiContext();\n+            final Context promptContext = context.createPackageContextAsUser(\n+                    opPackageName, 0 /* flags */, UserHandle.getUserHandleForUid(userId));\n             final Executor executor = context.getMainExecutor();\n \n-            final BiometricPrompt biometricPrompt = new BiometricPrompt.Builder(context)\n+            final BiometricPrompt biometricPrompt = new BiometricPrompt.Builder(promptContext)\n                     .setTitle(context.getString(R.string.biometric_dialog_default_title))\n                     .setSubtitle(context.getString(R.string.fingerprint_dialog_default_subtitle))\n                     .setNegativeButton(\n@@ -368,8 +370,7 @@ public class FingerprintService extends SystemService {\n                                     Slog.e(TAG, \"Remote exception in negative button onClick()\", e);\n                                 }\n                             })\n-                    .setAllowedSensorIds(new ArrayList<>(\n-                            Collections.singletonList(props.sensorId)))\n+                    .setIsForLegacyFingerprintManager(props.sensorId)\n                     .setIgnoreEnrollmentState(ignoreEnrollmentState)\n                     .build();\n \n@@ -423,8 +424,8 @@ public class FingerprintService extends SystemService {\n                         }\n                     };\n \n-            return biometricPrompt.authenticateUserForOperation(\n-                    new CancellationSignal(), executor, promptCallback, userId, operationId);\n+            return biometricPrompt.authenticateForOperation(\n+                    new CancellationSignal(), executor, promptCallback, operationId);\n         }\n \n         @Override\n",
    "added_lines": 11,
    "deleted_lines": 10,
    "changed_methods": "FingerprintService::FingerprintServiceWrapper::authenticateWithPrompt, FingerprintService::FingerprintServiceWrapper::authenticateWithPrompt, FingerprintService::FingerprintServiceWrapper::authenticate"
   }
  ]
 },
 {
  "hash": "b702b280e4cbf89243d6d1e272cdd7869dce2d07",
  "commit": "[DO NOT MERGE] Do not clear calling identify when using BiometricPrompt from FingerprintService.\n\nBug: 214261879\nTest: atest AuthControllerTest\nTest: Manually verify with test apps in bug\nChange-Id: I8ae9f2b8a970bf7e5d32121dc358f7d0f0d060b8\n(cherry picked from commit ac89f8682f0558c775e360d3c5fb84702e914989)\nMerged-In: I8ae9f2b8a970bf7e5d32121dc358f7d0f0d060b8",
  "files": [
   {
    "filename": "BiometricPrompt.java",
    "diff": "@@ -420,6 +420,18 @@ public class BiometricPrompt implements BiometricAuthenticator, BiometricConstan\n             return this;\n         }\n \n+        /**\n+         * Set if BiometricPrompt is being used by the legacy fingerprint manager API.\n+         * @param sensorId sensor id\n+         * @return This builder.\n+         * @hide\n+         */\n+        @NonNull\n+        public Builder setIsForLegacyFingerprintManager(int sensorId) {\n+            mPromptInfo.setIsForLegacyFingerprintManager(sensorId);\n+            return this;\n+        }\n+\n         /**\n          * Creates a {@link BiometricPrompt}.\n          *\n@@ -861,28 +873,36 @@ public class BiometricPrompt implements BiometricAuthenticator, BiometricConstan\n             @NonNull @CallbackExecutor Executor executor,\n             @NonNull AuthenticationCallback callback,\n             int userId) {\n-        authenticateUserForOperation(cancel, executor, callback, userId, 0 /* operationId */);\n+        if (cancel == null) {\n+            throw new IllegalArgumentException(\"Must supply a cancellation signal\");\n+        }\n+        if (executor == null) {\n+            throw new IllegalArgumentException(\"Must supply an executor\");\n+        }\n+        if (callback == null) {\n+            throw new IllegalArgumentException(\"Must supply a callback\");\n+        }\n+\n+        authenticateInternal(0 /* operationId */, cancel, executor, callback, userId);\n     }\n \n     /**\n-     * Authenticates for the given user and keystore operation.\n+     * Authenticates for the given keystore operation.\n      *\n      * @param cancel An object that can be used to cancel authentication\n      * @param executor An executor to handle callback events\n      * @param callback An object to receive authentication events\n-     * @param userId The user to authenticate\n      * @param operationId The keystore operation associated with authentication\n      *\n      * @return A requestId that can be used to cancel this operation.\n      *\n      * @hide\n      */\n-    @RequiresPermission(USE_BIOMETRIC_INTERNAL)\n-    public long authenticateUserForOperation(\n+    @RequiresPermission(USE_BIOMETRIC)\n+    public long authenticateForOperation(\n             @NonNull CancellationSignal cancel,\n             @NonNull @CallbackExecutor Executor executor,\n             @NonNull AuthenticationCallback callback,\n-            int userId,\n             long operationId) {\n         if (cancel == null) {\n             throw new IllegalArgumentException(\"Must supply a cancellation signal\");\n@@ -894,7 +914,7 @@ public class BiometricPrompt implements BiometricAuthenticator, BiometricConstan\n             throw new IllegalArgumentException(\"Must supply a callback\");\n         }\n \n-        return authenticateInternal(operationId, cancel, executor, callback, userId);\n+        return authenticateInternal(operationId, cancel, executor, callback, mContext.getUserId());\n     }\n \n     /**\n@@ -1028,7 +1048,7 @@ public class BiometricPrompt implements BiometricAuthenticator, BiometricConstan\n     private void cancelAuthentication(long requestId) {\n         if (mService != null) {\n             try {\n-                mService.cancelAuthentication(mToken, mContext.getOpPackageName(), requestId);\n+                mService.cancelAuthentication(mToken, mContext.getPackageName(), requestId);\n             } catch (RemoteException e) {\n                 Log.e(TAG, \"Unable to cancel authentication\", e);\n             }\n@@ -1087,7 +1107,7 @@ public class BiometricPrompt implements BiometricAuthenticator, BiometricConstan\n             }\n \n             final long authId = mService.authenticate(mToken, operationId, userId,\n-                    mBiometricServiceReceiver, mContext.getOpPackageName(), promptInfo);\n+                    mBiometricServiceReceiver, mContext.getPackageName(), promptInfo);\n             cancel.setOnCancelListener(new OnAuthenticationCancelListener(authId));\n             return authId;\n         } catch (RemoteException e) {\n",
    "added_lines": 29,
    "deleted_lines": 9,
    "changed_methods": "BiometricPrompt::Builder::setIsForLegacyFingerprintManager, BiometricPrompt::authenticateUserForOperation, BiometricPrompt::authenticateForOperation, BiometricPrompt::authenticateUser, BiometricPrompt::authenticateInternal, BiometricPrompt::cancelAuthentication"
   },
   {
    "filename": "PromptInfo.java",
    "diff": "@@ -46,6 +46,7 @@ public class PromptInfo implements Parcelable {\n     @NonNull private List<Integer> mAllowedSensorIds = new ArrayList<>();\n     private boolean mAllowBackgroundAuthentication;\n     private boolean mIgnoreEnrollmentState;\n+    private boolean mIsForLegacyFingerprintManager = false;\n \n     public PromptInfo() {\n \n@@ -68,6 +69,7 @@ public class PromptInfo implements Parcelable {\n         mAllowedSensorIds = in.readArrayList(Integer.class.getClassLoader());\n         mAllowBackgroundAuthentication = in.readBoolean();\n         mIgnoreEnrollmentState = in.readBoolean();\n+        mIsForLegacyFingerprintManager = in.readBoolean();\n     }\n \n     public static final Creator<PromptInfo> CREATOR = new Creator<PromptInfo>() {\n@@ -105,10 +107,15 @@ public class PromptInfo implements Parcelable {\n         dest.writeList(mAllowedSensorIds);\n         dest.writeBoolean(mAllowBackgroundAuthentication);\n         dest.writeBoolean(mIgnoreEnrollmentState);\n+        dest.writeBoolean(mIsForLegacyFingerprintManager);\n     }\n \n     public boolean containsTestConfigurations() {\n-        if (!mAllowedSensorIds.isEmpty()) {\n+        if (mIsForLegacyFingerprintManager\n+                && mAllowedSensorIds.size() == 1\n+                && !mAllowBackgroundAuthentication) {\n+            return false;\n+        } else if (!mAllowedSensorIds.isEmpty()) {\n             return true;\n         } else if (mAllowBackgroundAuthentication) {\n             return true;\n@@ -188,7 +195,8 @@ public class PromptInfo implements Parcelable {\n     }\n \n     public void setAllowedSensorIds(@NonNull List<Integer> sensorIds) {\n-        mAllowedSensorIds = sensorIds;\n+        mAllowedSensorIds.clear();\n+        mAllowedSensorIds.addAll(sensorIds);\n     }\n \n     public void setAllowBackgroundAuthentication(boolean allow) {\n@@ -199,6 +207,12 @@ public class PromptInfo implements Parcelable {\n         mIgnoreEnrollmentState = ignoreEnrollmentState;\n     }\n \n+    public void setIsForLegacyFingerprintManager(int sensorId) {\n+        mIsForLegacyFingerprintManager = true;\n+        mAllowedSensorIds.clear();\n+        mAllowedSensorIds.add(sensorId);\n+    }\n+\n     // Getters\n \n     public CharSequence getTitle() {\n@@ -272,4 +286,8 @@ public class PromptInfo implements Parcelable {\n     public boolean isIgnoreEnrollmentState() {\n         return mIgnoreEnrollmentState;\n     }\n+\n+    public boolean isForLegacyFingerprintManager() {\n+        return mIsForLegacyFingerprintManager;\n+    }\n }\n",
    "added_lines": 20,
    "deleted_lines": 2,
    "changed_methods": "PromptInfo::PromptInfo, PromptInfo::isForLegacyFingerprintManager, PromptInfo::setIsForLegacyFingerprintManager, PromptInfo::containsTestConfigurations, PromptInfo::setAllowedSensorIds, PromptInfo::writeToParcel"
   },
   {
    "filename": "AuthController.java",
    "diff": "@@ -134,7 +134,7 @@ public class AuthController extends SystemUI implements CommandQueue.Callbacks,\n     private class BiometricTaskStackListener extends TaskStackListener {\n         @Override\n         public void onTaskStackChanged() {\n-            mHandler.post(AuthController.this::handleTaskStackChanged);\n+            mHandler.post(AuthController.this::cancelIfOwnerIsNotInForeground);\n         }\n     }\n \n@@ -181,7 +181,7 @@ public class AuthController extends SystemUI implements CommandQueue.Callbacks,\n         }\n     };\n \n-    private void handleTaskStackChanged() {\n+    private void cancelIfOwnerIsNotInForeground() {\n         mExecution.assertIsMainThread();\n         if (mCurrentDialog != null) {\n             try {\n@@ -193,7 +193,7 @@ public class AuthController extends SystemUI implements CommandQueue.Callbacks,\n                     final String topPackage = runningTasks.get(0).topActivity.getPackageName();\n                     if (!topPackage.contentEquals(clientPackage)\n                             && !Utils.isSystem(mContext, clientPackage)) {\n-                        Log.w(TAG, \"Evicting client due to: \" + topPackage);\n+                        Log.e(TAG, \"Evicting client due to: \" + topPackage);\n                         mCurrentDialog.dismissWithoutCallback(true /* animate */);\n                         mCurrentDialog = null;\n                         mOrientationListener.disable();\n@@ -814,6 +814,10 @@ public class AuthController extends SystemUI implements CommandQueue.Callbacks,\n         mCurrentDialog = newDialog;\n         mCurrentDialog.show(mWindowManager, savedState);\n         mOrientationListener.enable();\n+\n+        if (!promptInfo.isAllowBackgroundAuthentication()) {\n+            mHandler.post(this::cancelIfOwnerIsNotInForeground);\n+        }\n     }\n \n     private void onDialogDismissed(@DismissedReason int reason) {\n",
    "added_lines": 7,
    "deleted_lines": 3,
    "changed_methods": "AuthController::handleTaskStackChanged, AuthController::BiometricTaskStackListener::onTaskStackChanged, AuthController::cancelIfOwnerIsNotInForeground, AuthController::showDialog"
   },
   {
    "filename": "AuthControllerTest.java",
    "diff": "@@ -554,16 +554,26 @@ public class AuthControllerTest extends SysuiTestCase {\n                 mAuthController.mLastBiometricPromptInfo.getAuthenticators());\n     }\n \n+    @Test\n+    public void testClientNotified_whenTaskStackChangesDuringShow() throws Exception {\n+        switchTask(\"other_package\");\n+        showDialog(new int[] {1} /* sensorIds */, false /* credentialAllowed */);\n+\n+        waitForIdleSync();\n+\n+        assertNull(mAuthController.mCurrentDialog);\n+        assertNull(mAuthController.mReceiver);\n+        verify(mDialog1).dismissWithoutCallback(true /* animate */);\n+        verify(mReceiver).onDialogDismissed(\n+                eq(BiometricPrompt.DISMISSED_REASON_USER_CANCEL),\n+                eq(null) /* credentialAttestation */);\n+    }\n+\n     @Test\n     public void testClientNotified_whenTaskStackChangesDuringAuthentication() throws Exception {\n         showDialog(new int[] {1} /* sensorIds */, false /* credentialAllowed */);\n \n-        List<ActivityManager.RunningTaskInfo> tasks = new ArrayList<>();\n-        ActivityManager.RunningTaskInfo taskInfo = mock(ActivityManager.RunningTaskInfo.class);\n-        taskInfo.topActivity = mock(ComponentName.class);\n-        when(taskInfo.topActivity.getPackageName()).thenReturn(\"other_package\");\n-        tasks.add(taskInfo);\n-        when(mActivityTaskManager.getTasks(anyInt())).thenReturn(tasks);\n+        switchTask(\"other_package\");\n \n         mAuthController.mTaskStackListener.onTaskStackChanged();\n         mTestableLooper.processAllMessages();\n@@ -640,6 +650,16 @@ public class AuthControllerTest extends SysuiTestCase {\n                 BIOMETRIC_MULTI_SENSOR_FACE_THEN_FINGERPRINT);\n     }\n \n+    private void switchTask(String packageName) {\n+        final List<ActivityManager.RunningTaskInfo> tasks = new ArrayList<>();\n+        final ActivityManager.RunningTaskInfo taskInfo =\n+                mock(ActivityManager.RunningTaskInfo.class);\n+        taskInfo.topActivity = mock(ComponentName.class);\n+        when(taskInfo.topActivity.getPackageName()).thenReturn(packageName);\n+        tasks.add(taskInfo);\n+        when(mActivityTaskManager.getTasks(anyInt())).thenReturn(tasks);\n+    }\n+\n     private PromptInfo createTestPromptInfo() {\n         PromptInfo promptInfo = new PromptInfo();\n \n",
    "added_lines": 26,
    "deleted_lines": 6,
    "changed_methods": "AuthControllerTest::switchTask, AuthControllerTest::testClientNotified_whenTaskStackChangesDuringShow, AuthControllerTest::testClientNotified_whenTaskStackChangesDuringAuthentication"
   },
   {
    "filename": "AuthenticationClient.java",
    "diff": "@@ -118,7 +118,7 @@ public abstract class AuthenticationClient<T> extends AcquisitionClient<T>\n         mIsStrongBiometric = isStrongBiometric;\n         mOperationId = operationId;\n         mRequireConfirmation = requireConfirmation;\n-        mActivityTaskManager = ActivityTaskManager.getInstance();\n+        mActivityTaskManager = getActivityTaskManager();\n         mBiometricManager = context.getSystemService(BiometricManager.class);\n         mTaskStackListener = taskStackListener;\n         mLockoutTracker = lockoutTracker;\n@@ -146,6 +146,10 @@ public abstract class AuthenticationClient<T> extends AcquisitionClient<T>\n         return mStartTimeMs;\n     }\n \n+    protected ActivityTaskManager getActivityTaskManager() {\n+        return ActivityTaskManager.getInstance();\n+    }\n+\n     @Override\n     public void binderDied() {\n         final boolean clearListener = !isBiometricPrompt();\n@@ -322,45 +326,50 @@ public abstract class AuthenticationClient<T> extends AcquisitionClient<T>\n                     sendCancelOnly(listener);\n                 }\n             });\n-        } else {\n-            // Allow system-defined limit of number of attempts before giving up\n-            final @LockoutTracker.LockoutMode int lockoutMode =\n-                    handleFailedAttempt(getTargetUserId());\n-            if (lockoutMode != LockoutTracker.LOCKOUT_NONE) {\n-                markAlreadyDone();\n-            }\n-\n-            final CoexCoordinator coordinator = CoexCoordinator.getInstance();\n-            coordinator.onAuthenticationRejected(SystemClock.uptimeMillis(), this, lockoutMode,\n-                    new CoexCoordinator.Callback() {\n-                @Override\n-                public void sendAuthenticationResult(boolean addAuthTokenIfStrong) {\n-                    if (listener != null) {\n-                        try {\n-                            listener.onAuthenticationFailed(getSensorId());\n-                        } catch (RemoteException e) {\n-                            Slog.e(TAG, \"Unable to notify listener\", e);\n-                        }\n-                    }\n+        } else { // not authenticated\n+            if (isBackgroundAuth) {\n+                Slog.e(TAG, \"cancelling due to background auth\");\n+                cancel();\n+            } else {\n+                // Allow system-defined limit of number of attempts before giving up\n+                final @LockoutTracker.LockoutMode int lockoutMode =\n+                        handleFailedAttempt(getTargetUserId());\n+                if (lockoutMode != LockoutTracker.LOCKOUT_NONE) {\n+                    markAlreadyDone();\n                 }\n \n-                @Override\n-                public void sendHapticFeedback() {\n-                    if (listener != null && mShouldVibrate) {\n-                        vibrateError();\n-                    }\n-                }\n+                final CoexCoordinator coordinator = CoexCoordinator.getInstance();\n+                coordinator.onAuthenticationRejected(SystemClock.uptimeMillis(), this, lockoutMode,\n+                        new CoexCoordinator.Callback() {\n+                            @Override\n+                            public void sendAuthenticationResult(boolean addAuthTokenIfStrong) {\n+                                if (listener != null) {\n+                                    try {\n+                                        listener.onAuthenticationFailed(getSensorId());\n+                                    } catch (RemoteException e) {\n+                                        Slog.e(TAG, \"Unable to notify listener\", e);\n+                                    }\n+                                }\n+                            }\n \n-                @Override\n-                public void handleLifecycleAfterAuth() {\n-                    AuthenticationClient.this.handleLifecycleAfterAuth(false /* authenticated */);\n-                }\n+                            @Override\n+                            public void sendHapticFeedback() {\n+                                if (listener != null && mShouldVibrate) {\n+                                    vibrateError();\n+                                }\n+                            }\n \n-                @Override\n-                public void sendAuthenticationCanceled() {\n-                    sendCancelOnly(listener);\n-                }\n-            });\n+                            @Override\n+                            public void handleLifecycleAfterAuth() {\n+                                AuthenticationClient.this.handleLifecycleAfterAuth(false /* authenticated */);\n+                            }\n+\n+                            @Override\n+                            public void sendAuthenticationCanceled() {\n+                                sendCancelOnly(listener);\n+                            }\n+                        });\n+            }\n         }\n     }\n \n",
    "added_lines": 45,
    "deleted_lines": 36,
    "changed_methods": "AuthenticationClient::getActivityTaskManager, AuthenticationClient::onAuthenticated, AuthenticationClient::AuthenticationClient"
   },
   {
    "filename": "FingerprintService.java",
    "diff": "@@ -331,12 +331,11 @@ public class FingerprintService extends SystemService {\n                     provider.second.getSensorProperties(sensorId);\n             if (!isKeyguard && !Utils.isSettings(getContext(), opPackageName)\n                     && sensorProps != null && sensorProps.isAnyUdfpsType()) {\n-                identity = Binder.clearCallingIdentity();\n                 try {\n                     return authenticateWithPrompt(operationId, sensorProps, userId, receiver,\n-                            ignoreEnrollmentState);\n-                } finally {\n-                    Binder.restoreCallingIdentity(identity);\n+                            ignoreEnrollmentState, opPackageName);\n+                } catch (PackageManager.NameNotFoundException e) {\n+                    Slog.e(TAG, \"Invalid package\", e);\n                 }\n             }\n             return provider.second.scheduleAuthenticate(provider.first, token, operationId, userId,\n@@ -349,12 +348,15 @@ public class FingerprintService extends SystemService {\n                 @NonNull final FingerprintSensorPropertiesInternal props,\n                 final int userId,\n                 final IFingerprintServiceReceiver receiver,\n-                boolean ignoreEnrollmentState) {\n+                boolean ignoreEnrollmentState,\n+                final String opPackageName) throws PackageManager.NameNotFoundException {\n \n             final Context context = getUiContext();\n+            final Context promptContext = context.createPackageContextAsUser(\n+                    opPackageName, 0 /* flags */, UserHandle.getUserHandleForUid(userId));\n             final Executor executor = context.getMainExecutor();\n \n-            final BiometricPrompt biometricPrompt = new BiometricPrompt.Builder(context)\n+            final BiometricPrompt biometricPrompt = new BiometricPrompt.Builder(promptContext)\n                     .setTitle(context.getString(R.string.biometric_dialog_default_title))\n                     .setSubtitle(context.getString(R.string.fingerprint_dialog_default_subtitle))\n                     .setNegativeButton(\n@@ -368,8 +370,7 @@ public class FingerprintService extends SystemService {\n                                     Slog.e(TAG, \"Remote exception in negative button onClick()\", e);\n                                 }\n                             })\n-                    .setAllowedSensorIds(new ArrayList<>(\n-                            Collections.singletonList(props.sensorId)))\n+                    .setIsForLegacyFingerprintManager(props.sensorId)\n                     .setIgnoreEnrollmentState(ignoreEnrollmentState)\n                     .build();\n \n@@ -423,8 +424,8 @@ public class FingerprintService extends SystemService {\n                         }\n                     };\n \n-            return biometricPrompt.authenticateUserForOperation(\n-                    new CancellationSignal(), executor, promptCallback, userId, operationId);\n+            return biometricPrompt.authenticateForOperation(\n+                    new CancellationSignal(), executor, promptCallback, operationId);\n         }\n \n         @Override\n",
    "added_lines": 11,
    "deleted_lines": 10,
    "changed_methods": "FingerprintService::FingerprintServiceWrapper::authenticateWithPrompt, FingerprintService::FingerprintServiceWrapper::authenticateWithPrompt, FingerprintService::FingerprintServiceWrapper::authenticate"
   }
  ]
 },
 {
  "hash": "b702b280e4cbf89243d6d1e272cdd7869dce2d07",
  "commit": "[DO NOT MERGE] Do not clear calling identify when using BiometricPrompt from FingerprintService.\n\nBug: 214261879\nTest: atest AuthControllerTest\nTest: Manually verify with test apps in bug\nChange-Id: I8ae9f2b8a970bf7e5d32121dc358f7d0f0d060b8\n(cherry picked from commit ac89f8682f0558c775e360d3c5fb84702e914989)\nMerged-In: I8ae9f2b8a970bf7e5d32121dc358f7d0f0d060b8",
  "files": [
   {
    "filename": "BiometricPrompt.java",
    "diff": "@@ -420,6 +420,18 @@ public class BiometricPrompt implements BiometricAuthenticator, BiometricConstan\n             return this;\n         }\n \n+        /**\n+         * Set if BiometricPrompt is being used by the legacy fingerprint manager API.\n+         * @param sensorId sensor id\n+         * @return This builder.\n+         * @hide\n+         */\n+        @NonNull\n+        public Builder setIsForLegacyFingerprintManager(int sensorId) {\n+            mPromptInfo.setIsForLegacyFingerprintManager(sensorId);\n+            return this;\n+        }\n+\n         /**\n          * Creates a {@link BiometricPrompt}.\n          *\n@@ -861,28 +873,36 @@ public class BiometricPrompt implements BiometricAuthenticator, BiometricConstan\n             @NonNull @CallbackExecutor Executor executor,\n             @NonNull AuthenticationCallback callback,\n             int userId) {\n-        authenticateUserForOperation(cancel, executor, callback, userId, 0 /* operationId */);\n+        if (cancel == null) {\n+            throw new IllegalArgumentException(\"Must supply a cancellation signal\");\n+        }\n+        if (executor == null) {\n+            throw new IllegalArgumentException(\"Must supply an executor\");\n+        }\n+        if (callback == null) {\n+            throw new IllegalArgumentException(\"Must supply a callback\");\n+        }\n+\n+        authenticateInternal(0 /* operationId */, cancel, executor, callback, userId);\n     }\n \n     /**\n-     * Authenticates for the given user and keystore operation.\n+     * Authenticates for the given keystore operation.\n      *\n      * @param cancel An object that can be used to cancel authentication\n      * @param executor An executor to handle callback events\n      * @param callback An object to receive authentication events\n-     * @param userId The user to authenticate\n      * @param operationId The keystore operation associated with authentication\n      *\n      * @return A requestId that can be used to cancel this operation.\n      *\n      * @hide\n      */\n-    @RequiresPermission(USE_BIOMETRIC_INTERNAL)\n-    public long authenticateUserForOperation(\n+    @RequiresPermission(USE_BIOMETRIC)\n+    public long authenticateForOperation(\n             @NonNull CancellationSignal cancel,\n             @NonNull @CallbackExecutor Executor executor,\n             @NonNull AuthenticationCallback callback,\n-            int userId,\n             long operationId) {\n         if (cancel == null) {\n             throw new IllegalArgumentException(\"Must supply a cancellation signal\");\n@@ -894,7 +914,7 @@ public class BiometricPrompt implements BiometricAuthenticator, BiometricConstan\n             throw new IllegalArgumentException(\"Must supply a callback\");\n         }\n \n-        return authenticateInternal(operationId, cancel, executor, callback, userId);\n+        return authenticateInternal(operationId, cancel, executor, callback, mContext.getUserId());\n     }\n \n     /**\n@@ -1028,7 +1048,7 @@ public class BiometricPrompt implements BiometricAuthenticator, BiometricConstan\n     private void cancelAuthentication(long requestId) {\n         if (mService != null) {\n             try {\n-                mService.cancelAuthentication(mToken, mContext.getOpPackageName(), requestId);\n+                mService.cancelAuthentication(mToken, mContext.getPackageName(), requestId);\n             } catch (RemoteException e) {\n                 Log.e(TAG, \"Unable to cancel authentication\", e);\n             }\n@@ -1087,7 +1107,7 @@ public class BiometricPrompt implements BiometricAuthenticator, BiometricConstan\n             }\n \n             final long authId = mService.authenticate(mToken, operationId, userId,\n-                    mBiometricServiceReceiver, mContext.getOpPackageName(), promptInfo);\n+                    mBiometricServiceReceiver, mContext.getPackageName(), promptInfo);\n             cancel.setOnCancelListener(new OnAuthenticationCancelListener(authId));\n             return authId;\n         } catch (RemoteException e) {\n",
    "added_lines": 29,
    "deleted_lines": 9,
    "changed_methods": "BiometricPrompt::Builder::setIsForLegacyFingerprintManager, BiometricPrompt::authenticateUserForOperation, BiometricPrompt::authenticateForOperation, BiometricPrompt::authenticateUser, BiometricPrompt::authenticateInternal, BiometricPrompt::cancelAuthentication"
   },
   {
    "filename": "PromptInfo.java",
    "diff": "@@ -46,6 +46,7 @@ public class PromptInfo implements Parcelable {\n     @NonNull private List<Integer> mAllowedSensorIds = new ArrayList<>();\n     private boolean mAllowBackgroundAuthentication;\n     private boolean mIgnoreEnrollmentState;\n+    private boolean mIsForLegacyFingerprintManager = false;\n \n     public PromptInfo() {\n \n@@ -68,6 +69,7 @@ public class PromptInfo implements Parcelable {\n         mAllowedSensorIds = in.readArrayList(Integer.class.getClassLoader());\n         mAllowBackgroundAuthentication = in.readBoolean();\n         mIgnoreEnrollmentState = in.readBoolean();\n+        mIsForLegacyFingerprintManager = in.readBoolean();\n     }\n \n     public static final Creator<PromptInfo> CREATOR = new Creator<PromptInfo>() {\n@@ -105,10 +107,15 @@ public class PromptInfo implements Parcelable {\n         dest.writeList(mAllowedSensorIds);\n         dest.writeBoolean(mAllowBackgroundAuthentication);\n         dest.writeBoolean(mIgnoreEnrollmentState);\n+        dest.writeBoolean(mIsForLegacyFingerprintManager);\n     }\n \n     public boolean containsTestConfigurations() {\n-        if (!mAllowedSensorIds.isEmpty()) {\n+        if (mIsForLegacyFingerprintManager\n+                && mAllowedSensorIds.size() == 1\n+                && !mAllowBackgroundAuthentication) {\n+            return false;\n+        } else if (!mAllowedSensorIds.isEmpty()) {\n             return true;\n         } else if (mAllowBackgroundAuthentication) {\n             return true;\n@@ -188,7 +195,8 @@ public class PromptInfo implements Parcelable {\n     }\n \n     public void setAllowedSensorIds(@NonNull List<Integer> sensorIds) {\n-        mAllowedSensorIds = sensorIds;\n+        mAllowedSensorIds.clear();\n+        mAllowedSensorIds.addAll(sensorIds);\n     }\n \n     public void setAllowBackgroundAuthentication(boolean allow) {\n@@ -199,6 +207,12 @@ public class PromptInfo implements Parcelable {\n         mIgnoreEnrollmentState = ignoreEnrollmentState;\n     }\n \n+    public void setIsForLegacyFingerprintManager(int sensorId) {\n+        mIsForLegacyFingerprintManager = true;\n+        mAllowedSensorIds.clear();\n+        mAllowedSensorIds.add(sensorId);\n+    }\n+\n     // Getters\n \n     public CharSequence getTitle() {\n@@ -272,4 +286,8 @@ public class PromptInfo implements Parcelable {\n     public boolean isIgnoreEnrollmentState() {\n         return mIgnoreEnrollmentState;\n     }\n+\n+    public boolean isForLegacyFingerprintManager() {\n+        return mIsForLegacyFingerprintManager;\n+    }\n }\n",
    "added_lines": 20,
    "deleted_lines": 2,
    "changed_methods": "PromptInfo::PromptInfo, PromptInfo::isForLegacyFingerprintManager, PromptInfo::setIsForLegacyFingerprintManager, PromptInfo::containsTestConfigurations, PromptInfo::setAllowedSensorIds, PromptInfo::writeToParcel"
   },
   {
    "filename": "AuthController.java",
    "diff": "@@ -134,7 +134,7 @@ public class AuthController extends SystemUI implements CommandQueue.Callbacks,\n     private class BiometricTaskStackListener extends TaskStackListener {\n         @Override\n         public void onTaskStackChanged() {\n-            mHandler.post(AuthController.this::handleTaskStackChanged);\n+            mHandler.post(AuthController.this::cancelIfOwnerIsNotInForeground);\n         }\n     }\n \n@@ -181,7 +181,7 @@ public class AuthController extends SystemUI implements CommandQueue.Callbacks,\n         }\n     };\n \n-    private void handleTaskStackChanged() {\n+    private void cancelIfOwnerIsNotInForeground() {\n         mExecution.assertIsMainThread();\n         if (mCurrentDialog != null) {\n             try {\n@@ -193,7 +193,7 @@ public class AuthController extends SystemUI implements CommandQueue.Callbacks,\n                     final String topPackage = runningTasks.get(0).topActivity.getPackageName();\n                     if (!topPackage.contentEquals(clientPackage)\n                             && !Utils.isSystem(mContext, clientPackage)) {\n-                        Log.w(TAG, \"Evicting client due to: \" + topPackage);\n+                        Log.e(TAG, \"Evicting client due to: \" + topPackage);\n                         mCurrentDialog.dismissWithoutCallback(true /* animate */);\n                         mCurrentDialog = null;\n                         mOrientationListener.disable();\n@@ -814,6 +814,10 @@ public class AuthController extends SystemUI implements CommandQueue.Callbacks,\n         mCurrentDialog = newDialog;\n         mCurrentDialog.show(mWindowManager, savedState);\n         mOrientationListener.enable();\n+\n+        if (!promptInfo.isAllowBackgroundAuthentication()) {\n+            mHandler.post(this::cancelIfOwnerIsNotInForeground);\n+        }\n     }\n \n     private void onDialogDismissed(@DismissedReason int reason) {\n",
    "added_lines": 7,
    "deleted_lines": 3,
    "changed_methods": "AuthController::handleTaskStackChanged, AuthController::BiometricTaskStackListener::onTaskStackChanged, AuthController::cancelIfOwnerIsNotInForeground, AuthController::showDialog"
   },
   {
    "filename": "AuthControllerTest.java",
    "diff": "@@ -554,16 +554,26 @@ public class AuthControllerTest extends SysuiTestCase {\n                 mAuthController.mLastBiometricPromptInfo.getAuthenticators());\n     }\n \n+    @Test\n+    public void testClientNotified_whenTaskStackChangesDuringShow() throws Exception {\n+        switchTask(\"other_package\");\n+        showDialog(new int[] {1} /* sensorIds */, false /* credentialAllowed */);\n+\n+        waitForIdleSync();\n+\n+        assertNull(mAuthController.mCurrentDialog);\n+        assertNull(mAuthController.mReceiver);\n+        verify(mDialog1).dismissWithoutCallback(true /* animate */);\n+        verify(mReceiver).onDialogDismissed(\n+                eq(BiometricPrompt.DISMISSED_REASON_USER_CANCEL),\n+                eq(null) /* credentialAttestation */);\n+    }\n+\n     @Test\n     public void testClientNotified_whenTaskStackChangesDuringAuthentication() throws Exception {\n         showDialog(new int[] {1} /* sensorIds */, false /* credentialAllowed */);\n \n-        List<ActivityManager.RunningTaskInfo> tasks = new ArrayList<>();\n-        ActivityManager.RunningTaskInfo taskInfo = mock(ActivityManager.RunningTaskInfo.class);\n-        taskInfo.topActivity = mock(ComponentName.class);\n-        when(taskInfo.topActivity.getPackageName()).thenReturn(\"other_package\");\n-        tasks.add(taskInfo);\n-        when(mActivityTaskManager.getTasks(anyInt())).thenReturn(tasks);\n+        switchTask(\"other_package\");\n \n         mAuthController.mTaskStackListener.onTaskStackChanged();\n         mTestableLooper.processAllMessages();\n@@ -640,6 +650,16 @@ public class AuthControllerTest extends SysuiTestCase {\n                 BIOMETRIC_MULTI_SENSOR_FACE_THEN_FINGERPRINT);\n     }\n \n+    private void switchTask(String packageName) {\n+        final List<ActivityManager.RunningTaskInfo> tasks = new ArrayList<>();\n+        final ActivityManager.RunningTaskInfo taskInfo =\n+                mock(ActivityManager.RunningTaskInfo.class);\n+        taskInfo.topActivity = mock(ComponentName.class);\n+        when(taskInfo.topActivity.getPackageName()).thenReturn(packageName);\n+        tasks.add(taskInfo);\n+        when(mActivityTaskManager.getTasks(anyInt())).thenReturn(tasks);\n+    }\n+\n     private PromptInfo createTestPromptInfo() {\n         PromptInfo promptInfo = new PromptInfo();\n \n",
    "added_lines": 26,
    "deleted_lines": 6,
    "changed_methods": "AuthControllerTest::switchTask, AuthControllerTest::testClientNotified_whenTaskStackChangesDuringShow, AuthControllerTest::testClientNotified_whenTaskStackChangesDuringAuthentication"
   },
   {
    "filename": "AuthenticationClient.java",
    "diff": "@@ -118,7 +118,7 @@ public abstract class AuthenticationClient<T> extends AcquisitionClient<T>\n         mIsStrongBiometric = isStrongBiometric;\n         mOperationId = operationId;\n         mRequireConfirmation = requireConfirmation;\n-        mActivityTaskManager = ActivityTaskManager.getInstance();\n+        mActivityTaskManager = getActivityTaskManager();\n         mBiometricManager = context.getSystemService(BiometricManager.class);\n         mTaskStackListener = taskStackListener;\n         mLockoutTracker = lockoutTracker;\n@@ -146,6 +146,10 @@ public abstract class AuthenticationClient<T> extends AcquisitionClient<T>\n         return mStartTimeMs;\n     }\n \n+    protected ActivityTaskManager getActivityTaskManager() {\n+        return ActivityTaskManager.getInstance();\n+    }\n+\n     @Override\n     public void binderDied() {\n         final boolean clearListener = !isBiometricPrompt();\n@@ -322,45 +326,50 @@ public abstract class AuthenticationClient<T> extends AcquisitionClient<T>\n                     sendCancelOnly(listener);\n                 }\n             });\n-        } else {\n-            // Allow system-defined limit of number of attempts before giving up\n-            final @LockoutTracker.LockoutMode int lockoutMode =\n-                    handleFailedAttempt(getTargetUserId());\n-            if (lockoutMode != LockoutTracker.LOCKOUT_NONE) {\n-                markAlreadyDone();\n-            }\n-\n-            final CoexCoordinator coordinator = CoexCoordinator.getInstance();\n-            coordinator.onAuthenticationRejected(SystemClock.uptimeMillis(), this, lockoutMode,\n-                    new CoexCoordinator.Callback() {\n-                @Override\n-                public void sendAuthenticationResult(boolean addAuthTokenIfStrong) {\n-                    if (listener != null) {\n-                        try {\n-                            listener.onAuthenticationFailed(getSensorId());\n-                        } catch (RemoteException e) {\n-                            Slog.e(TAG, \"Unable to notify listener\", e);\n-                        }\n-                    }\n+        } else { // not authenticated\n+            if (isBackgroundAuth) {\n+                Slog.e(TAG, \"cancelling due to background auth\");\n+                cancel();\n+            } else {\n+                // Allow system-defined limit of number of attempts before giving up\n+                final @LockoutTracker.LockoutMode int lockoutMode =\n+                        handleFailedAttempt(getTargetUserId());\n+                if (lockoutMode != LockoutTracker.LOCKOUT_NONE) {\n+                    markAlreadyDone();\n                 }\n \n-                @Override\n-                public void sendHapticFeedback() {\n-                    if (listener != null && mShouldVibrate) {\n-                        vibrateError();\n-                    }\n-                }\n+                final CoexCoordinator coordinator = CoexCoordinator.getInstance();\n+                coordinator.onAuthenticationRejected(SystemClock.uptimeMillis(), this, lockoutMode,\n+                        new CoexCoordinator.Callback() {\n+                            @Override\n+                            public void sendAuthenticationResult(boolean addAuthTokenIfStrong) {\n+                                if (listener != null) {\n+                                    try {\n+                                        listener.onAuthenticationFailed(getSensorId());\n+                                    } catch (RemoteException e) {\n+                                        Slog.e(TAG, \"Unable to notify listener\", e);\n+                                    }\n+                                }\n+                            }\n \n-                @Override\n-                public void handleLifecycleAfterAuth() {\n-                    AuthenticationClient.this.handleLifecycleAfterAuth(false /* authenticated */);\n-                }\n+                            @Override\n+                            public void sendHapticFeedback() {\n+                                if (listener != null && mShouldVibrate) {\n+                                    vibrateError();\n+                                }\n+                            }\n \n-                @Override\n-                public void sendAuthenticationCanceled() {\n-                    sendCancelOnly(listener);\n-                }\n-            });\n+                            @Override\n+                            public void handleLifecycleAfterAuth() {\n+                                AuthenticationClient.this.handleLifecycleAfterAuth(false /* authenticated */);\n+                            }\n+\n+                            @Override\n+                            public void sendAuthenticationCanceled() {\n+                                sendCancelOnly(listener);\n+                            }\n+                        });\n+            }\n         }\n     }\n \n",
    "added_lines": 45,
    "deleted_lines": 36,
    "changed_methods": "AuthenticationClient::getActivityTaskManager, AuthenticationClient::onAuthenticated, AuthenticationClient::AuthenticationClient"
   },
   {
    "filename": "FingerprintService.java",
    "diff": "@@ -331,12 +331,11 @@ public class FingerprintService extends SystemService {\n                     provider.second.getSensorProperties(sensorId);\n             if (!isKeyguard && !Utils.isSettings(getContext(), opPackageName)\n                     && sensorProps != null && sensorProps.isAnyUdfpsType()) {\n-                identity = Binder.clearCallingIdentity();\n                 try {\n                     return authenticateWithPrompt(operationId, sensorProps, userId, receiver,\n-                            ignoreEnrollmentState);\n-                } finally {\n-                    Binder.restoreCallingIdentity(identity);\n+                            ignoreEnrollmentState, opPackageName);\n+                } catch (PackageManager.NameNotFoundException e) {\n+                    Slog.e(TAG, \"Invalid package\", e);\n                 }\n             }\n             return provider.second.scheduleAuthenticate(provider.first, token, operationId, userId,\n@@ -349,12 +348,15 @@ public class FingerprintService extends SystemService {\n                 @NonNull final FingerprintSensorPropertiesInternal props,\n                 final int userId,\n                 final IFingerprintServiceReceiver receiver,\n-                boolean ignoreEnrollmentState) {\n+                boolean ignoreEnrollmentState,\n+                final String opPackageName) throws PackageManager.NameNotFoundException {\n \n             final Context context = getUiContext();\n+            final Context promptContext = context.createPackageContextAsUser(\n+                    opPackageName, 0 /* flags */, UserHandle.getUserHandleForUid(userId));\n             final Executor executor = context.getMainExecutor();\n \n-            final BiometricPrompt biometricPrompt = new BiometricPrompt.Builder(context)\n+            final BiometricPrompt biometricPrompt = new BiometricPrompt.Builder(promptContext)\n                     .setTitle(context.getString(R.string.biometric_dialog_default_title))\n                     .setSubtitle(context.getString(R.string.fingerprint_dialog_default_subtitle))\n                     .setNegativeButton(\n@@ -368,8 +370,7 @@ public class FingerprintService extends SystemService {\n                                     Slog.e(TAG, \"Remote exception in negative button onClick()\", e);\n                                 }\n                             })\n-                    .setAllowedSensorIds(new ArrayList<>(\n-                            Collections.singletonList(props.sensorId)))\n+                    .setIsForLegacyFingerprintManager(props.sensorId)\n                     .setIgnoreEnrollmentState(ignoreEnrollmentState)\n                     .build();\n \n@@ -423,8 +424,8 @@ public class FingerprintService extends SystemService {\n                         }\n                     };\n \n-            return biometricPrompt.authenticateUserForOperation(\n-                    new CancellationSignal(), executor, promptCallback, userId, operationId);\n+            return biometricPrompt.authenticateForOperation(\n+                    new CancellationSignal(), executor, promptCallback, operationId);\n         }\n \n         @Override\n",
    "added_lines": 11,
    "deleted_lines": 10,
    "changed_methods": "FingerprintService::FingerprintServiceWrapper::authenticateWithPrompt, FingerprintService::FingerprintServiceWrapper::authenticateWithPrompt, FingerprintService::FingerprintServiceWrapper::authenticate"
   }
  ]
 },
 {
  "hash": "b702b280e4cbf89243d6d1e272cdd7869dce2d07",
  "commit": "[DO NOT MERGE] Do not clear calling identify when using BiometricPrompt from FingerprintService.\n\nBug: 214261879\nTest: atest AuthControllerTest\nTest: Manually verify with test apps in bug\nChange-Id: I8ae9f2b8a970bf7e5d32121dc358f7d0f0d060b8\n(cherry picked from commit ac89f8682f0558c775e360d3c5fb84702e914989)\nMerged-In: I8ae9f2b8a970bf7e5d32121dc358f7d0f0d060b8",
  "files": [
   {
    "filename": "BiometricPrompt.java",
    "diff": "@@ -420,6 +420,18 @@ public class BiometricPrompt implements BiometricAuthenticator, BiometricConstan\n             return this;\n         }\n \n+        /**\n+         * Set if BiometricPrompt is being used by the legacy fingerprint manager API.\n+         * @param sensorId sensor id\n+         * @return This builder.\n+         * @hide\n+         */\n+        @NonNull\n+        public Builder setIsForLegacyFingerprintManager(int sensorId) {\n+            mPromptInfo.setIsForLegacyFingerprintManager(sensorId);\n+            return this;\n+        }\n+\n         /**\n          * Creates a {@link BiometricPrompt}.\n          *\n@@ -861,28 +873,36 @@ public class BiometricPrompt implements BiometricAuthenticator, BiometricConstan\n             @NonNull @CallbackExecutor Executor executor,\n             @NonNull AuthenticationCallback callback,\n             int userId) {\n-        authenticateUserForOperation(cancel, executor, callback, userId, 0 /* operationId */);\n+        if (cancel == null) {\n+            throw new IllegalArgumentException(\"Must supply a cancellation signal\");\n+        }\n+        if (executor == null) {\n+            throw new IllegalArgumentException(\"Must supply an executor\");\n+        }\n+        if (callback == null) {\n+            throw new IllegalArgumentException(\"Must supply a callback\");\n+        }\n+\n+        authenticateInternal(0 /* operationId */, cancel, executor, callback, userId);\n     }\n \n     /**\n-     * Authenticates for the given user and keystore operation.\n+     * Authenticates for the given keystore operation.\n      *\n      * @param cancel An object that can be used to cancel authentication\n      * @param executor An executor to handle callback events\n      * @param callback An object to receive authentication events\n-     * @param userId The user to authenticate\n      * @param operationId The keystore operation associated with authentication\n      *\n      * @return A requestId that can be used to cancel this operation.\n      *\n      * @hide\n      */\n-    @RequiresPermission(USE_BIOMETRIC_INTERNAL)\n-    public long authenticateUserForOperation(\n+    @RequiresPermission(USE_BIOMETRIC)\n+    public long authenticateForOperation(\n             @NonNull CancellationSignal cancel,\n             @NonNull @CallbackExecutor Executor executor,\n             @NonNull AuthenticationCallback callback,\n-            int userId,\n             long operationId) {\n         if (cancel == null) {\n             throw new IllegalArgumentException(\"Must supply a cancellation signal\");\n@@ -894,7 +914,7 @@ public class BiometricPrompt implements BiometricAuthenticator, BiometricConstan\n             throw new IllegalArgumentException(\"Must supply a callback\");\n         }\n \n-        return authenticateInternal(operationId, cancel, executor, callback, userId);\n+        return authenticateInternal(operationId, cancel, executor, callback, mContext.getUserId());\n     }\n \n     /**\n@@ -1028,7 +1048,7 @@ public class BiometricPrompt implements BiometricAuthenticator, BiometricConstan\n     private void cancelAuthentication(long requestId) {\n         if (mService != null) {\n             try {\n-                mService.cancelAuthentication(mToken, mContext.getOpPackageName(), requestId);\n+                mService.cancelAuthentication(mToken, mContext.getPackageName(), requestId);\n             } catch (RemoteException e) {\n                 Log.e(TAG, \"Unable to cancel authentication\", e);\n             }\n@@ -1087,7 +1107,7 @@ public class BiometricPrompt implements BiometricAuthenticator, BiometricConstan\n             }\n \n             final long authId = mService.authenticate(mToken, operationId, userId,\n-                    mBiometricServiceReceiver, mContext.getOpPackageName(), promptInfo);\n+                    mBiometricServiceReceiver, mContext.getPackageName(), promptInfo);\n             cancel.setOnCancelListener(new OnAuthenticationCancelListener(authId));\n             return authId;\n         } catch (RemoteException e) {\n",
    "added_lines": 29,
    "deleted_lines": 9,
    "changed_methods": "BiometricPrompt::Builder::setIsForLegacyFingerprintManager, BiometricPrompt::authenticateUserForOperation, BiometricPrompt::authenticateForOperation, BiometricPrompt::authenticateUser, BiometricPrompt::authenticateInternal, BiometricPrompt::cancelAuthentication"
   },
   {
    "filename": "PromptInfo.java",
    "diff": "@@ -46,6 +46,7 @@ public class PromptInfo implements Parcelable {\n     @NonNull private List<Integer> mAllowedSensorIds = new ArrayList<>();\n     private boolean mAllowBackgroundAuthentication;\n     private boolean mIgnoreEnrollmentState;\n+    private boolean mIsForLegacyFingerprintManager = false;\n \n     public PromptInfo() {\n \n@@ -68,6 +69,7 @@ public class PromptInfo implements Parcelable {\n         mAllowedSensorIds = in.readArrayList(Integer.class.getClassLoader());\n         mAllowBackgroundAuthentication = in.readBoolean();\n         mIgnoreEnrollmentState = in.readBoolean();\n+        mIsForLegacyFingerprintManager = in.readBoolean();\n     }\n \n     public static final Creator<PromptInfo> CREATOR = new Creator<PromptInfo>() {\n@@ -105,10 +107,15 @@ public class PromptInfo implements Parcelable {\n         dest.writeList(mAllowedSensorIds);\n         dest.writeBoolean(mAllowBackgroundAuthentication);\n         dest.writeBoolean(mIgnoreEnrollmentState);\n+        dest.writeBoolean(mIsForLegacyFingerprintManager);\n     }\n \n     public boolean containsTestConfigurations() {\n-        if (!mAllowedSensorIds.isEmpty()) {\n+        if (mIsForLegacyFingerprintManager\n+                && mAllowedSensorIds.size() == 1\n+                && !mAllowBackgroundAuthentication) {\n+            return false;\n+        } else if (!mAllowedSensorIds.isEmpty()) {\n             return true;\n         } else if (mAllowBackgroundAuthentication) {\n             return true;\n@@ -188,7 +195,8 @@ public class PromptInfo implements Parcelable {\n     }\n \n     public void setAllowedSensorIds(@NonNull List<Integer> sensorIds) {\n-        mAllowedSensorIds = sensorIds;\n+        mAllowedSensorIds.clear();\n+        mAllowedSensorIds.addAll(sensorIds);\n     }\n \n     public void setAllowBackgroundAuthentication(boolean allow) {\n@@ -199,6 +207,12 @@ public class PromptInfo implements Parcelable {\n         mIgnoreEnrollmentState = ignoreEnrollmentState;\n     }\n \n+    public void setIsForLegacyFingerprintManager(int sensorId) {\n+        mIsForLegacyFingerprintManager = true;\n+        mAllowedSensorIds.clear();\n+        mAllowedSensorIds.add(sensorId);\n+    }\n+\n     // Getters\n \n     public CharSequence getTitle() {\n@@ -272,4 +286,8 @@ public class PromptInfo implements Parcelable {\n     public boolean isIgnoreEnrollmentState() {\n         return mIgnoreEnrollmentState;\n     }\n+\n+    public boolean isForLegacyFingerprintManager() {\n+        return mIsForLegacyFingerprintManager;\n+    }\n }\n",
    "added_lines": 20,
    "deleted_lines": 2,
    "changed_methods": "PromptInfo::PromptInfo, PromptInfo::isForLegacyFingerprintManager, PromptInfo::setIsForLegacyFingerprintManager, PromptInfo::containsTestConfigurations, PromptInfo::setAllowedSensorIds, PromptInfo::writeToParcel"
   },
   {
    "filename": "AuthController.java",
    "diff": "@@ -134,7 +134,7 @@ public class AuthController extends SystemUI implements CommandQueue.Callbacks,\n     private class BiometricTaskStackListener extends TaskStackListener {\n         @Override\n         public void onTaskStackChanged() {\n-            mHandler.post(AuthController.this::handleTaskStackChanged);\n+            mHandler.post(AuthController.this::cancelIfOwnerIsNotInForeground);\n         }\n     }\n \n@@ -181,7 +181,7 @@ public class AuthController extends SystemUI implements CommandQueue.Callbacks,\n         }\n     };\n \n-    private void handleTaskStackChanged() {\n+    private void cancelIfOwnerIsNotInForeground() {\n         mExecution.assertIsMainThread();\n         if (mCurrentDialog != null) {\n             try {\n@@ -193,7 +193,7 @@ public class AuthController extends SystemUI implements CommandQueue.Callbacks,\n                     final String topPackage = runningTasks.get(0).topActivity.getPackageName();\n                     if (!topPackage.contentEquals(clientPackage)\n                             && !Utils.isSystem(mContext, clientPackage)) {\n-                        Log.w(TAG, \"Evicting client due to: \" + topPackage);\n+                        Log.e(TAG, \"Evicting client due to: \" + topPackage);\n                         mCurrentDialog.dismissWithoutCallback(true /* animate */);\n                         mCurrentDialog = null;\n                         mOrientationListener.disable();\n@@ -814,6 +814,10 @@ public class AuthController extends SystemUI implements CommandQueue.Callbacks,\n         mCurrentDialog = newDialog;\n         mCurrentDialog.show(mWindowManager, savedState);\n         mOrientationListener.enable();\n+\n+        if (!promptInfo.isAllowBackgroundAuthentication()) {\n+            mHandler.post(this::cancelIfOwnerIsNotInForeground);\n+        }\n     }\n \n     private void onDialogDismissed(@DismissedReason int reason) {\n",
    "added_lines": 7,
    "deleted_lines": 3,
    "changed_methods": "AuthController::handleTaskStackChanged, AuthController::BiometricTaskStackListener::onTaskStackChanged, AuthController::cancelIfOwnerIsNotInForeground, AuthController::showDialog"
   },
   {
    "filename": "AuthControllerTest.java",
    "diff": "@@ -554,16 +554,26 @@ public class AuthControllerTest extends SysuiTestCase {\n                 mAuthController.mLastBiometricPromptInfo.getAuthenticators());\n     }\n \n+    @Test\n+    public void testClientNotified_whenTaskStackChangesDuringShow() throws Exception {\n+        switchTask(\"other_package\");\n+        showDialog(new int[] {1} /* sensorIds */, false /* credentialAllowed */);\n+\n+        waitForIdleSync();\n+\n+        assertNull(mAuthController.mCurrentDialog);\n+        assertNull(mAuthController.mReceiver);\n+        verify(mDialog1).dismissWithoutCallback(true /* animate */);\n+        verify(mReceiver).onDialogDismissed(\n+                eq(BiometricPrompt.DISMISSED_REASON_USER_CANCEL),\n+                eq(null) /* credentialAttestation */);\n+    }\n+\n     @Test\n     public void testClientNotified_whenTaskStackChangesDuringAuthentication() throws Exception {\n         showDialog(new int[] {1} /* sensorIds */, false /* credentialAllowed */);\n \n-        List<ActivityManager.RunningTaskInfo> tasks = new ArrayList<>();\n-        ActivityManager.RunningTaskInfo taskInfo = mock(ActivityManager.RunningTaskInfo.class);\n-        taskInfo.topActivity = mock(ComponentName.class);\n-        when(taskInfo.topActivity.getPackageName()).thenReturn(\"other_package\");\n-        tasks.add(taskInfo);\n-        when(mActivityTaskManager.getTasks(anyInt())).thenReturn(tasks);\n+        switchTask(\"other_package\");\n \n         mAuthController.mTaskStackListener.onTaskStackChanged();\n         mTestableLooper.processAllMessages();\n@@ -640,6 +650,16 @@ public class AuthControllerTest extends SysuiTestCase {\n                 BIOMETRIC_MULTI_SENSOR_FACE_THEN_FINGERPRINT);\n     }\n \n+    private void switchTask(String packageName) {\n+        final List<ActivityManager.RunningTaskInfo> tasks = new ArrayList<>();\n+        final ActivityManager.RunningTaskInfo taskInfo =\n+                mock(ActivityManager.RunningTaskInfo.class);\n+        taskInfo.topActivity = mock(ComponentName.class);\n+        when(taskInfo.topActivity.getPackageName()).thenReturn(packageName);\n+        tasks.add(taskInfo);\n+        when(mActivityTaskManager.getTasks(anyInt())).thenReturn(tasks);\n+    }\n+\n     private PromptInfo createTestPromptInfo() {\n         PromptInfo promptInfo = new PromptInfo();\n \n",
    "added_lines": 26,
    "deleted_lines": 6,
    "changed_methods": "AuthControllerTest::switchTask, AuthControllerTest::testClientNotified_whenTaskStackChangesDuringShow, AuthControllerTest::testClientNotified_whenTaskStackChangesDuringAuthentication"
   },
   {
    "filename": "AuthenticationClient.java",
    "diff": "@@ -118,7 +118,7 @@ public abstract class AuthenticationClient<T> extends AcquisitionClient<T>\n         mIsStrongBiometric = isStrongBiometric;\n         mOperationId = operationId;\n         mRequireConfirmation = requireConfirmation;\n-        mActivityTaskManager = ActivityTaskManager.getInstance();\n+        mActivityTaskManager = getActivityTaskManager();\n         mBiometricManager = context.getSystemService(BiometricManager.class);\n         mTaskStackListener = taskStackListener;\n         mLockoutTracker = lockoutTracker;\n@@ -146,6 +146,10 @@ public abstract class AuthenticationClient<T> extends AcquisitionClient<T>\n         return mStartTimeMs;\n     }\n \n+    protected ActivityTaskManager getActivityTaskManager() {\n+        return ActivityTaskManager.getInstance();\n+    }\n+\n     @Override\n     public void binderDied() {\n         final boolean clearListener = !isBiometricPrompt();\n@@ -322,45 +326,50 @@ public abstract class AuthenticationClient<T> extends AcquisitionClient<T>\n                     sendCancelOnly(listener);\n                 }\n             });\n-        } else {\n-            // Allow system-defined limit of number of attempts before giving up\n-            final @LockoutTracker.LockoutMode int lockoutMode =\n-                    handleFailedAttempt(getTargetUserId());\n-            if (lockoutMode != LockoutTracker.LOCKOUT_NONE) {\n-                markAlreadyDone();\n-            }\n-\n-            final CoexCoordinator coordinator = CoexCoordinator.getInstance();\n-            coordinator.onAuthenticationRejected(SystemClock.uptimeMillis(), this, lockoutMode,\n-                    new CoexCoordinator.Callback() {\n-                @Override\n-                public void sendAuthenticationResult(boolean addAuthTokenIfStrong) {\n-                    if (listener != null) {\n-                        try {\n-                            listener.onAuthenticationFailed(getSensorId());\n-                        } catch (RemoteException e) {\n-                            Slog.e(TAG, \"Unable to notify listener\", e);\n-                        }\n-                    }\n+        } else { // not authenticated\n+            if (isBackgroundAuth) {\n+                Slog.e(TAG, \"cancelling due to background auth\");\n+                cancel();\n+            } else {\n+                // Allow system-defined limit of number of attempts before giving up\n+                final @LockoutTracker.LockoutMode int lockoutMode =\n+                        handleFailedAttempt(getTargetUserId());\n+                if (lockoutMode != LockoutTracker.LOCKOUT_NONE) {\n+                    markAlreadyDone();\n                 }\n \n-                @Override\n-                public void sendHapticFeedback() {\n-                    if (listener != null && mShouldVibrate) {\n-                        vibrateError();\n-                    }\n-                }\n+                final CoexCoordinator coordinator = CoexCoordinator.getInstance();\n+                coordinator.onAuthenticationRejected(SystemClock.uptimeMillis(), this, lockoutMode,\n+                        new CoexCoordinator.Callback() {\n+                            @Override\n+                            public void sendAuthenticationResult(boolean addAuthTokenIfStrong) {\n+                                if (listener != null) {\n+                                    try {\n+                                        listener.onAuthenticationFailed(getSensorId());\n+                                    } catch (RemoteException e) {\n+                                        Slog.e(TAG, \"Unable to notify listener\", e);\n+                                    }\n+                                }\n+                            }\n \n-                @Override\n-                public void handleLifecycleAfterAuth() {\n-                    AuthenticationClient.this.handleLifecycleAfterAuth(false /* authenticated */);\n-                }\n+                            @Override\n+                            public void sendHapticFeedback() {\n+                                if (listener != null && mShouldVibrate) {\n+                                    vibrateError();\n+                                }\n+                            }\n \n-                @Override\n-                public void sendAuthenticationCanceled() {\n-                    sendCancelOnly(listener);\n-                }\n-            });\n+                            @Override\n+                            public void handleLifecycleAfterAuth() {\n+                                AuthenticationClient.this.handleLifecycleAfterAuth(false /* authenticated */);\n+                            }\n+\n+                            @Override\n+                            public void sendAuthenticationCanceled() {\n+                                sendCancelOnly(listener);\n+                            }\n+                        });\n+            }\n         }\n     }\n \n",
    "added_lines": 45,
    "deleted_lines": 36,
    "changed_methods": "AuthenticationClient::getActivityTaskManager, AuthenticationClient::onAuthenticated, AuthenticationClient::AuthenticationClient"
   },
   {
    "filename": "FingerprintService.java",
    "diff": "@@ -331,12 +331,11 @@ public class FingerprintService extends SystemService {\n                     provider.second.getSensorProperties(sensorId);\n             if (!isKeyguard && !Utils.isSettings(getContext(), opPackageName)\n                     && sensorProps != null && sensorProps.isAnyUdfpsType()) {\n-                identity = Binder.clearCallingIdentity();\n                 try {\n                     return authenticateWithPrompt(operationId, sensorProps, userId, receiver,\n-                            ignoreEnrollmentState);\n-                } finally {\n-                    Binder.restoreCallingIdentity(identity);\n+                            ignoreEnrollmentState, opPackageName);\n+                } catch (PackageManager.NameNotFoundException e) {\n+                    Slog.e(TAG, \"Invalid package\", e);\n                 }\n             }\n             return provider.second.scheduleAuthenticate(provider.first, token, operationId, userId,\n@@ -349,12 +348,15 @@ public class FingerprintService extends SystemService {\n                 @NonNull final FingerprintSensorPropertiesInternal props,\n                 final int userId,\n                 final IFingerprintServiceReceiver receiver,\n-                boolean ignoreEnrollmentState) {\n+                boolean ignoreEnrollmentState,\n+                final String opPackageName) throws PackageManager.NameNotFoundException {\n \n             final Context context = getUiContext();\n+            final Context promptContext = context.createPackageContextAsUser(\n+                    opPackageName, 0 /* flags */, UserHandle.getUserHandleForUid(userId));\n             final Executor executor = context.getMainExecutor();\n \n-            final BiometricPrompt biometricPrompt = new BiometricPrompt.Builder(context)\n+            final BiometricPrompt biometricPrompt = new BiometricPrompt.Builder(promptContext)\n                     .setTitle(context.getString(R.string.biometric_dialog_default_title))\n                     .setSubtitle(context.getString(R.string.fingerprint_dialog_default_subtitle))\n                     .setNegativeButton(\n@@ -368,8 +370,7 @@ public class FingerprintService extends SystemService {\n                                     Slog.e(TAG, \"Remote exception in negative button onClick()\", e);\n                                 }\n                             })\n-                    .setAllowedSensorIds(new ArrayList<>(\n-                            Collections.singletonList(props.sensorId)))\n+                    .setIsForLegacyFingerprintManager(props.sensorId)\n                     .setIgnoreEnrollmentState(ignoreEnrollmentState)\n                     .build();\n \n@@ -423,8 +424,8 @@ public class FingerprintService extends SystemService {\n                         }\n                     };\n \n-            return biometricPrompt.authenticateUserForOperation(\n-                    new CancellationSignal(), executor, promptCallback, userId, operationId);\n+            return biometricPrompt.authenticateForOperation(\n+                    new CancellationSignal(), executor, promptCallback, operationId);\n         }\n \n         @Override\n",
    "added_lines": 11,
    "deleted_lines": 10,
    "changed_methods": "FingerprintService::FingerprintServiceWrapper::authenticateWithPrompt, FingerprintService::FingerprintServiceWrapper::authenticateWithPrompt, FingerprintService::FingerprintServiceWrapper::authenticate"
   }
  ]
 },
 {
  "hash": "bbf844775b20357ca64729263aaa75ea64ec2fe3",
  "commit": "Make Activites touch opaque - DO NOT MERGE\n\nBlock touches from passing through activities by adding a dedicated\nsurface that consumes all touches that would otherwise pass through the\nbounds availble to the Activity.\n\nBug: 194480991\nTest: atest CtsWindowManagerDeviceTestCases:ActivityRecordInputSinkTests\nTest: atest CtsWindowManagerDeviceTestCases:CrossAppDragAndDropTests\nTest: atest CtsWindowManagerDeviceTestCases:PinnedStackTests\nTest: Manually ran through go/wm-smoke (verified pip and splitscreen\nstill work)\nTest: Manually verfied that freeform windows work and don't consume\ntouches outside their bounds\n\nChange-Id: I01b35e34a63868dead4e728a3d359ae0942302f9\n(cherry picked from commit 22261fa6649f6ec6441646743ad98132fcf47fe0)\nMerged-In: I01b35e34a63868dead4e728a3d359ae0942302f9",
  "files": [
   {
    "filename": "ActivityRecord.java",
    "diff": "@@ -804,6 +804,13 @@ final class ActivityRecord extends WindowToken implements WindowManagerService.A\n \n     private AppSaturationInfo mLastAppSaturationInfo;\n \n+    private final ActivityRecordInputSink mActivityRecordInputSink;\n+\n+    // Activities with this uid are allowed to not create an input sink while being in the same\n+    // task and directly above this ActivityRecord. This field is updated whenever a new activity\n+    // is launched from this ActivityRecord. Touches are always allowed within the same uid.\n+    int mAllowedTouchUid;\n+\n     private final ColorDisplayService.ColorTransformController mColorTransformController =\n             (matrix, translation) -> mWmService.mH.post(() -> {\n                 synchronized (mWmService.mGlobalLock) {\n@@ -1841,6 +1848,8 @@ final class ActivityRecord extends WindowToken implements WindowManagerService.A\n             createTime = _createTime;\n         }\n         mAtmService.mPackageConfigPersister.updateConfigIfNeeded(this, mUserId, packageName);\n+\n+        mActivityRecordInputSink = new ActivityRecordInputSink(this, sourceRecord);\n     }\n \n     /**\n@@ -3767,6 +3776,7 @@ final class ActivityRecord extends WindowToken implements WindowManagerService.A\n         } else {\n             onRemovedFromDisplay();\n         }\n+        mActivityRecordInputSink.releaseSurfaceControl();\n         super.removeImmediately();\n     }\n \n@@ -6926,6 +6936,9 @@ final class ActivityRecord extends WindowToken implements WindowManagerService.A\n             } else if (!show && mLastSurfaceShowing) {\n                 getSyncTransaction().hide(mSurfaceControl);\n             }\n+            if (show) {\n+                mActivityRecordInputSink.applyChangesToSurfaceIfChanged(getSyncTransaction());\n+            }\n         }\n         if (mThumbnail != null) {\n             mThumbnail.setShowing(getPendingTransaction(), show);\n",
    "added_lines": 13,
    "deleted_lines": 0,
    "changed_methods": "ActivityRecord::ActivityRecord, ActivityRecord::prepareSurfaces, ActivityRecord::removeImmediately"
   },
   {
    "filename": "ActivityRecordInputSink.java",
    "diff": "@@ -0,0 +1,113 @@\n+/*\n+ * Copyright (C) 2022 The Android Open Source Project\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.android.server.wm;\n+\n+import android.os.Process;\n+import android.view.InputWindowHandle;\n+import android.view.SurfaceControl;\n+import android.view.WindowManager;\n+\n+/**\n+ * Creates a InputWindowHandle that catches all touches that would otherwise pass through an\n+ * Activity.\n+ */\n+class ActivityRecordInputSink {\n+\n+    private final ActivityRecord mActivityRecord;\n+    private final String mName;\n+\n+    private InputWindowHandle mInputWindowHandle;\n+    private SurfaceControl mSurfaceControl;\n+\n+    ActivityRecordInputSink(ActivityRecord activityRecord, ActivityRecord sourceRecord) {\n+        mActivityRecord = activityRecord;\n+        mName = Integer.toHexString(System.identityHashCode(this)) + \" ActivityRecordInputSink \"\n+                + mActivityRecord.mActivityComponent.flattenToShortString();\n+        if (sourceRecord != null) {\n+            sourceRecord.mAllowedTouchUid = mActivityRecord.getUid();\n+        }\n+    }\n+\n+    public void applyChangesToSurfaceIfChanged(SurfaceControl.Transaction transaction) {\n+        boolean windowHandleChanged = updateInputWindowHandle();\n+        if (mSurfaceControl == null) {\n+            mSurfaceControl = createSurface(transaction);\n+        }\n+        if (windowHandleChanged) {\n+            transaction.setInputWindowInfo(mSurfaceControl, mInputWindowHandle);\n+        }\n+    }\n+\n+    private SurfaceControl createSurface(SurfaceControl.Transaction t) {\n+        SurfaceControl surfaceControl = mActivityRecord.makeChildSurface(null)\n+                .setName(mName)\n+                .setHidden(false)\n+                .setCallsite(\"ActivityRecordInputSink.createSurface\")\n+                .build();\n+        // Put layer below all siblings (and the parent surface too)\n+        t.setLayer(surfaceControl, Integer.MIN_VALUE);\n+        return surfaceControl;\n+    }\n+\n+    private boolean updateInputWindowHandle() {\n+        boolean changed = false;\n+        if (mInputWindowHandle == null) {\n+            mInputWindowHandle = createInputWindowHandle();\n+            changed = true;\n+        }\n+        // Don't block touches from passing through to an activity below us in the same task, if\n+        // that activity is either from the same uid or if that activity has launched an activity\n+        // in our uid.\n+        final ActivityRecord activityBelowInTask =\n+                mActivityRecord.getTask().getActivityBelow(mActivityRecord);\n+        final boolean allowPassthrough = activityBelowInTask != null && (\n+                activityBelowInTask.mAllowedTouchUid == mActivityRecord.getUid()\n+                        || activityBelowInTask.isUid(mActivityRecord.getUid()));\n+        boolean notTouchable = (mInputWindowHandle.layoutParamsFlags\n+                & WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE) != 0;\n+        if (allowPassthrough || mActivityRecord.isAppTransitioning()) {\n+            mInputWindowHandle.layoutParamsFlags |= WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;\n+            changed |= !notTouchable;\n+        } else {\n+            mInputWindowHandle.layoutParamsFlags &= ~WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;\n+            changed |= notTouchable;\n+        }\n+        return changed;\n+    }\n+\n+    private InputWindowHandle createInputWindowHandle() {\n+        InputWindowHandle inputWindowHandle = new InputWindowHandle(null,\n+                mActivityRecord.getDisplayId());\n+        inputWindowHandle.replaceTouchableRegionWithCrop = true;\n+        inputWindowHandle.name = mName;\n+        inputWindowHandle.layoutParamsType = WindowManager.LayoutParams.TYPE_INPUT_CONSUMER;\n+        inputWindowHandle.ownerUid = Process.myUid();\n+        inputWindowHandle.ownerPid = Process.myPid();\n+        inputWindowHandle.layoutParamsFlags = WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;\n+        inputWindowHandle.inputFeatures =\n+                WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL;\n+        return inputWindowHandle;\n+    }\n+\n+    void releaseSurfaceControl() {\n+        if (mSurfaceControl != null) {\n+            mSurfaceControl.release();\n+            mSurfaceControl = null;\n+        }\n+    }\n+\n+}\n",
    "added_lines": 113,
    "deleted_lines": 0,
    "changed_methods": "ActivityRecordInputSink::releaseSurfaceControl, ActivityRecordInputSink::applyChangesToSurfaceIfChanged, ActivityRecordInputSink::ActivityRecordInputSink, ActivityRecordInputSink::updateInputWindowHandle, ActivityRecordInputSink::createSurface, ActivityRecordInputSink::createInputWindowHandle"
   }
  ]
 },
 {
  "hash": "bbf844775b20357ca64729263aaa75ea64ec2fe3",
  "commit": "Make Activites touch opaque - DO NOT MERGE\n\nBlock touches from passing through activities by adding a dedicated\nsurface that consumes all touches that would otherwise pass through the\nbounds availble to the Activity.\n\nBug: 194480991\nTest: atest CtsWindowManagerDeviceTestCases:ActivityRecordInputSinkTests\nTest: atest CtsWindowManagerDeviceTestCases:CrossAppDragAndDropTests\nTest: atest CtsWindowManagerDeviceTestCases:PinnedStackTests\nTest: Manually ran through go/wm-smoke (verified pip and splitscreen\nstill work)\nTest: Manually verfied that freeform windows work and don't consume\ntouches outside their bounds\n\nChange-Id: I01b35e34a63868dead4e728a3d359ae0942302f9\n(cherry picked from commit 22261fa6649f6ec6441646743ad98132fcf47fe0)\nMerged-In: I01b35e34a63868dead4e728a3d359ae0942302f9",
  "files": [
   {
    "filename": "ActivityRecord.java",
    "diff": "@@ -804,6 +804,13 @@ final class ActivityRecord extends WindowToken implements WindowManagerService.A\n \n     private AppSaturationInfo mLastAppSaturationInfo;\n \n+    private final ActivityRecordInputSink mActivityRecordInputSink;\n+\n+    // Activities with this uid are allowed to not create an input sink while being in the same\n+    // task and directly above this ActivityRecord. This field is updated whenever a new activity\n+    // is launched from this ActivityRecord. Touches are always allowed within the same uid.\n+    int mAllowedTouchUid;\n+\n     private final ColorDisplayService.ColorTransformController mColorTransformController =\n             (matrix, translation) -> mWmService.mH.post(() -> {\n                 synchronized (mWmService.mGlobalLock) {\n@@ -1841,6 +1848,8 @@ final class ActivityRecord extends WindowToken implements WindowManagerService.A\n             createTime = _createTime;\n         }\n         mAtmService.mPackageConfigPersister.updateConfigIfNeeded(this, mUserId, packageName);\n+\n+        mActivityRecordInputSink = new ActivityRecordInputSink(this, sourceRecord);\n     }\n \n     /**\n@@ -3767,6 +3776,7 @@ final class ActivityRecord extends WindowToken implements WindowManagerService.A\n         } else {\n             onRemovedFromDisplay();\n         }\n+        mActivityRecordInputSink.releaseSurfaceControl();\n         super.removeImmediately();\n     }\n \n@@ -6926,6 +6936,9 @@ final class ActivityRecord extends WindowToken implements WindowManagerService.A\n             } else if (!show && mLastSurfaceShowing) {\n                 getSyncTransaction().hide(mSurfaceControl);\n             }\n+            if (show) {\n+                mActivityRecordInputSink.applyChangesToSurfaceIfChanged(getSyncTransaction());\n+            }\n         }\n         if (mThumbnail != null) {\n             mThumbnail.setShowing(getPendingTransaction(), show);\n",
    "added_lines": 13,
    "deleted_lines": 0,
    "changed_methods": "ActivityRecord::ActivityRecord, ActivityRecord::prepareSurfaces, ActivityRecord::removeImmediately"
   },
   {
    "filename": "ActivityRecordInputSink.java",
    "diff": "@@ -0,0 +1,113 @@\n+/*\n+ * Copyright (C) 2022 The Android Open Source Project\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.android.server.wm;\n+\n+import android.os.Process;\n+import android.view.InputWindowHandle;\n+import android.view.SurfaceControl;\n+import android.view.WindowManager;\n+\n+/**\n+ * Creates a InputWindowHandle that catches all touches that would otherwise pass through an\n+ * Activity.\n+ */\n+class ActivityRecordInputSink {\n+\n+    private final ActivityRecord mActivityRecord;\n+    private final String mName;\n+\n+    private InputWindowHandle mInputWindowHandle;\n+    private SurfaceControl mSurfaceControl;\n+\n+    ActivityRecordInputSink(ActivityRecord activityRecord, ActivityRecord sourceRecord) {\n+        mActivityRecord = activityRecord;\n+        mName = Integer.toHexString(System.identityHashCode(this)) + \" ActivityRecordInputSink \"\n+                + mActivityRecord.mActivityComponent.flattenToShortString();\n+        if (sourceRecord != null) {\n+            sourceRecord.mAllowedTouchUid = mActivityRecord.getUid();\n+        }\n+    }\n+\n+    public void applyChangesToSurfaceIfChanged(SurfaceControl.Transaction transaction) {\n+        boolean windowHandleChanged = updateInputWindowHandle();\n+        if (mSurfaceControl == null) {\n+            mSurfaceControl = createSurface(transaction);\n+        }\n+        if (windowHandleChanged) {\n+            transaction.setInputWindowInfo(mSurfaceControl, mInputWindowHandle);\n+        }\n+    }\n+\n+    private SurfaceControl createSurface(SurfaceControl.Transaction t) {\n+        SurfaceControl surfaceControl = mActivityRecord.makeChildSurface(null)\n+                .setName(mName)\n+                .setHidden(false)\n+                .setCallsite(\"ActivityRecordInputSink.createSurface\")\n+                .build();\n+        // Put layer below all siblings (and the parent surface too)\n+        t.setLayer(surfaceControl, Integer.MIN_VALUE);\n+        return surfaceControl;\n+    }\n+\n+    private boolean updateInputWindowHandle() {\n+        boolean changed = false;\n+        if (mInputWindowHandle == null) {\n+            mInputWindowHandle = createInputWindowHandle();\n+            changed = true;\n+        }\n+        // Don't block touches from passing through to an activity below us in the same task, if\n+        // that activity is either from the same uid or if that activity has launched an activity\n+        // in our uid.\n+        final ActivityRecord activityBelowInTask =\n+                mActivityRecord.getTask().getActivityBelow(mActivityRecord);\n+        final boolean allowPassthrough = activityBelowInTask != null && (\n+                activityBelowInTask.mAllowedTouchUid == mActivityRecord.getUid()\n+                        || activityBelowInTask.isUid(mActivityRecord.getUid()));\n+        boolean notTouchable = (mInputWindowHandle.layoutParamsFlags\n+                & WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE) != 0;\n+        if (allowPassthrough || mActivityRecord.isAppTransitioning()) {\n+            mInputWindowHandle.layoutParamsFlags |= WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;\n+            changed |= !notTouchable;\n+        } else {\n+            mInputWindowHandle.layoutParamsFlags &= ~WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;\n+            changed |= notTouchable;\n+        }\n+        return changed;\n+    }\n+\n+    private InputWindowHandle createInputWindowHandle() {\n+        InputWindowHandle inputWindowHandle = new InputWindowHandle(null,\n+                mActivityRecord.getDisplayId());\n+        inputWindowHandle.replaceTouchableRegionWithCrop = true;\n+        inputWindowHandle.name = mName;\n+        inputWindowHandle.layoutParamsType = WindowManager.LayoutParams.TYPE_INPUT_CONSUMER;\n+        inputWindowHandle.ownerUid = Process.myUid();\n+        inputWindowHandle.ownerPid = Process.myPid();\n+        inputWindowHandle.layoutParamsFlags = WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;\n+        inputWindowHandle.inputFeatures =\n+                WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL;\n+        return inputWindowHandle;\n+    }\n+\n+    void releaseSurfaceControl() {\n+        if (mSurfaceControl != null) {\n+            mSurfaceControl.release();\n+            mSurfaceControl = null;\n+        }\n+    }\n+\n+}\n",
    "added_lines": 113,
    "deleted_lines": 0,
    "changed_methods": "ActivityRecordInputSink::releaseSurfaceControl, ActivityRecordInputSink::applyChangesToSurfaceIfChanged, ActivityRecordInputSink::ActivityRecordInputSink, ActivityRecordInputSink::updateInputWindowHandle, ActivityRecordInputSink::createSurface, ActivityRecordInputSink::createInputWindowHandle"
   }
  ]
 },
 {
  "hash": "f64cb7e161e2a2f8e26430f2aec1795ff8f5ab5e",
  "commit": "[DO NOT MERGE] fpService#authWithPrompt uses correct user handle.\n\nCTS > BYOD Managed Provisioning > Authentication Bound Keys\n\nVerified Fingerprint-bound key test works as expected.\n\nTest: Manually verified CTS\nBug: 231932206\nChange-Id: I473c9c28cd0fbb01f4dd48447ddea8aa32834131\n(cherry picked from commit f3650a6dee1ebe5f681699e4170c244e7bd7f9fc)\n(cherry picked from commit c79346286e9cb03df8bf8417c15059aed0f0b41a)\nMerged-In: I473c9c28cd0fbb01f4dd48447ddea8aa32834131",
  "files": [
   {
    "filename": "FingerprintService.java",
    "diff": "@@ -332,8 +332,8 @@ public class FingerprintService extends SystemService {\n             if (!isKeyguard && !Utils.isSettings(getContext(), opPackageName)\n                     && sensorProps != null && sensorProps.isAnyUdfpsType()) {\n                 try {\n-                    return authenticateWithPrompt(operationId, sensorProps, userId, receiver,\n-                            ignoreEnrollmentState, opPackageName);\n+                    return authenticateWithPrompt(operationId, sensorProps, callingUid,\n+                            callingUserId, receiver, ignoreEnrollmentState, opPackageName);\n                 } catch (PackageManager.NameNotFoundException e) {\n                     Slog.e(TAG, \"Invalid package\", e);\n                 }\n@@ -346,6 +346,7 @@ public class FingerprintService extends SystemService {\n         private long authenticateWithPrompt(\n                 final long operationId,\n                 @NonNull final FingerprintSensorPropertiesInternal props,\n+                final int uId,\n                 final int userId,\n                 final IFingerprintServiceReceiver receiver,\n                 boolean ignoreEnrollmentState,\n@@ -353,7 +354,7 @@ public class FingerprintService extends SystemService {\n \n             final Context context = getUiContext();\n             final Context promptContext = context.createPackageContextAsUser(\n-                    opPackageName, 0 /* flags */, UserHandle.getUserHandleForUid(userId));\n+                    opPackageName, 0 /* flags */, UserHandle.getUserHandleForUid(uId));\n             final Executor executor = context.getMainExecutor();\n \n             final BiometricPrompt biometricPrompt = new BiometricPrompt.Builder(promptContext)\n",
    "added_lines": 4,
    "deleted_lines": 3,
    "changed_methods": "FingerprintService::FingerprintServiceWrapper::authenticateWithPrompt, FingerprintService::FingerprintServiceWrapper::authenticateWithPrompt, FingerprintService::FingerprintServiceWrapper::authenticate"
   }
  ]
 },
 {
  "hash": "373dc024fe540a11b4167e870733704bd9b877b9",
  "commit": "[RESTRICT AUTOMERGE] Correct the behavior of ACTION_PACKAGE_DATA_CLEARED\n\nThis action should be only broadcasted when the user data is cleared\nsuccessfully. Broadcasting this action when failed case may result in\nunexpected result.\n\nBug: 240267890\nTest: manually using the PoC in the buganizer to ensure the symptom\n      no longer exists.\nChange-Id: Iac8de8cf7837223dbd960b8d954ae6f40c702745\n(cherry picked from commit 1748c4e3569c960b3cc7af6fe76dc56b7929fc74)\nMerged-In: Iac8de8cf7837223dbd960b8d954ae6f40c702745",
  "files": [
   {
    "filename": "ActivityManagerService.java",
    "diff": "@@ -3544,20 +3544,25 @@ public class ActivityManagerService extends IActivityManager.Stub\n                             finishForceStopPackageLocked(packageName, appInfo.uid);\n                         }\n                     }\n-                    final Intent intent = new Intent(Intent.ACTION_PACKAGE_DATA_CLEARED,\n-                            Uri.fromParts(\"package\", packageName, null));\n-                    intent.addFlags(Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);\n-                    intent.putExtra(Intent.EXTRA_UID, (appInfo != null) ? appInfo.uid : -1);\n-                    intent.putExtra(Intent.EXTRA_USER_HANDLE, resolvedUserId);\n-                    if (isInstantApp) {\n-                        intent.putExtra(Intent.EXTRA_PACKAGE_NAME, packageName);\n-                        broadcastIntentInPackage(\"android\", null, SYSTEM_UID, uid, pid, intent,\n-                                null, null, 0, null, null, permission.ACCESS_INSTANT_APPS, null,\n-                                false, false, resolvedUserId, false, null);\n-                    } else {\n-                        broadcastIntentInPackage(\"android\", null, SYSTEM_UID, uid, pid, intent,\n-                                null, null, 0, null, null, null, null, false, false, resolvedUserId,\n-                                false, null);\n+\n+                    if (succeeded) {\n+                        final Intent intent = new Intent(Intent.ACTION_PACKAGE_DATA_CLEARED,\n+                                Uri.fromParts(\"package\", packageName, null /* fragment */));\n+                        intent.addFlags(Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);\n+                        intent.putExtra(Intent.EXTRA_UID,\n+                                (appInfo != null) ? appInfo.uid : INVALID_UID);\n+                        intent.putExtra(Intent.EXTRA_USER_HANDLE, resolvedUserId);\n+                        if (isInstantApp) {\n+                            intent.putExtra(Intent.EXTRA_PACKAGE_NAME, packageName);\n+                        }\n+\n+                        broadcastIntentInPackage(\"android\", null /* featureId */, SYSTEM_UID,\n+                                uid, pid, intent, null /* resolvedType */, null /* resultTo */,\n+                                0 /* resultCode */, null /* resultData */, null /* resultExtras */,\n+                                isInstantApp ? permission.ACCESS_INSTANT_APPS : null,\n+                                null /* bOptions */, false /* serialized */, false /* sticky */,\n+                                resolvedUserId, false /* allowBackgroundActivityStarts */,\n+                                null /* backgroundActivityStartsToken */);\n                     }\n \n                     if (observer != null) {\n",
    "added_lines": 19,
    "deleted_lines": 14,
    "changed_methods": "ActivityManagerService::clearApplicationUserData"
   }
  ]
 },
 {
  "hash": "68be9dcda50c0ac555a4a04e6648283c1ee80cc5",
  "commit": "Convert argument to intent in ChooseTypeAndAccountActivity\n\nBug: 244154558\nTest: manual\nChange-Id: I5a86639cd571e14e9a9f5d5ded631b5a7c08db7e\n(cherry picked from commit ede0a767c26f144e38b4a0c1c2f530b05ffd29a8)\nMerged-In: I5a86639cd571e14e9a9f5d5ded631b5a7c08db7e",
  "files": [
   {
    "filename": "ChooseTypeAndAccountActivity.java",
    "diff": "@@ -396,7 +396,7 @@ public class ChooseTypeAndAccountActivity extends Activity\n                 mExistingAccounts = AccountManager.get(this).getAccountsForPackage(mCallingPackage,\n                         mCallingUid);\n                 intent.setFlags(intent.getFlags() & ~Intent.FLAG_ACTIVITY_NEW_TASK);\n-                startActivityForResult(intent, REQUEST_ADD_ACCOUNT);\n+                startActivityForResult(new Intent(intent), REQUEST_ADD_ACCOUNT);\n                 return;\n             }\n         } catch (OperationCanceledException e) {\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "ChooseTypeAndAccountActivity::run"
   }
  ]
 },
 {
  "hash": "fff7a19e27e1026ad9a20a80d60a809343c6bc34",
  "commit": "Use rule package name in addAutomaticZenRule; specify \"android\" for all system apps\n\nThis is a roll forward of two reverted changes combined into one:\ncommit b6d04416628ab29df57efcd738332912d9260cea\ncommit e5e51116fb767162966a8e0d23fafb4f0ff46e86\n\nIt additionally fixes an issue where in multi-user profiles (such as a guest user), rules would be incorrectly identified as not created by the system and would therefore fail to be created in settings.\n\nBug: 257477671\nBug: 245236706\nBug: 242537431\nTest: NotificationManagerServiceTest; ZenModeHelperTest; manually verified that it's possible to create zen schedules from guest mode\nChange-Id: I0c4c705cfe5fc875151958957daaf8657fbc21a7\nMerged-In: I0c4c705cfe5fc875151958957daaf8657fbc21a7\n(cherry picked from commit 7261cdd30bf18965d421fc28c68c61e380bc952d)\n(cherry picked from commit 6e34748bdc541dbc841d6f29c0fb19a2eedec57d)\nMerged-In: I0c4c705cfe5fc875151958957daaf8657fbc21a7",
  "files": [
   {
    "filename": "NotificationManagerService.java",
    "diff": "@@ -4812,7 +4812,16 @@ public class NotificationManagerService extends SystemService {\n             }\n             enforcePolicyAccess(Binder.getCallingUid(), \"addAutomaticZenRule\");\n \n-            return mZenModeHelper.addAutomaticZenRule(pkg, automaticZenRule,\n+            // If the calling app is the system (from any user), take the package name from the\n+            // rule's owner rather than from the caller's package.\n+            String rulePkg = pkg;\n+            if (isCallingAppIdSystem()) {\n+                if (automaticZenRule.getOwner() != null) {\n+                    rulePkg = automaticZenRule.getOwner().getPackageName();\n+                }\n+            }\n+\n+            return mZenModeHelper.addAutomaticZenRule(rulePkg, automaticZenRule,\n                     \"addAutomaticZenRule\");\n         }\n \n@@ -9312,6 +9321,12 @@ public class NotificationManagerService extends SystemService {\n         return uid == Process.SYSTEM_UID;\n     }\n \n+    protected boolean isCallingAppIdSystem() {\n+        final int uid = Binder.getCallingUid();\n+        final int appid = UserHandle.getAppId(uid);\n+        return appid == Process.SYSTEM_UID;\n+    }\n+\n     protected boolean isUidSystemOrPhone(int uid) {\n         final int appid = UserHandle.getAppId(uid);\n         return (appid == Process.SYSTEM_UID || appid == Process.PHONE_UID\n",
    "added_lines": 16,
    "deleted_lines": 1,
    "changed_methods": "NotificationManagerService::Stub, NotificationManagerService::isCallingAppIdSystem"
   },
   {
    "filename": "ZenModeHelper.java",
    "diff": "@@ -310,7 +310,7 @@ public class ZenModeHelper {\n \n     public String addAutomaticZenRule(String pkg, AutomaticZenRule automaticZenRule,\n             String reason) {\n-        if (!isSystemRule(automaticZenRule)) {\n+        if (!ZenModeConfig.SYSTEM_AUTHORITY.equals(pkg)) {\n             PackageItemInfo component = getServiceInfo(automaticZenRule.getOwner());\n             if (component == null) {\n                 component = getActivityInfo(automaticZenRule.getConfigurationActivity());\n@@ -566,11 +566,6 @@ public class ZenModeHelper {\n         }\n     }\n \n-    private boolean isSystemRule(AutomaticZenRule rule) {\n-        return rule.getOwner() != null\n-                && ZenModeConfig.SYSTEM_AUTHORITY.equals(rule.getOwner().getPackageName());\n-    }\n-\n     private ServiceInfo getServiceInfo(ComponentName owner) {\n         Intent queryIntent = new Intent();\n         queryIntent.setComponent(owner);\n",
    "added_lines": 1,
    "deleted_lines": 6,
    "changed_methods": "ZenModeHelper::isSystemRule, ZenModeHelper::addAutomaticZenRule"
   },
   {
    "filename": "NotificationManagerServiceTest.java",
    "diff": "@@ -340,6 +340,7 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n     private static class TestableNotificationManagerService extends NotificationManagerService {\n         int countSystemChecks = 0;\n         boolean isSystemUid = true;\n+        boolean isSystemAppId = true;\n         int countLogSmartSuggestionsVisible = 0;\n         @Nullable\n         NotificationAssistantAccessGrantedCallback mNotificationAssistantAccessGrantedCallback;\n@@ -359,6 +360,12 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n             return isSystemUid;\n         }\n \n+        @Override\n+        protected boolean isCallingAppIdSystem() {\n+            countSystemChecks++;\n+            return isSystemUid || isSystemAppId;\n+        }\n+\n         @Override\n         protected boolean isCallerSystemOrPhone() {\n             countSystemChecks++;\n@@ -6748,6 +6755,65 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n         mBinderService.addAutomaticZenRule(rule, mContext.getPackageName());\n     }\n \n+    @Test\n+    public void testAddAutomaticZenRule_systemCallTakesPackageFromOwner() throws Exception {\n+        mService.isSystemUid = true;\n+        ZenModeHelper mockZenModeHelper = mock(ZenModeHelper.class);\n+        when(mConditionProviders.isPackageOrComponentAllowed(anyString(), anyInt()))\n+                .thenReturn(true);\n+        mService.setZenHelper(mockZenModeHelper);\n+        ComponentName owner = new ComponentName(\"android\", \"ProviderName\");\n+        ZenPolicy zenPolicy = new ZenPolicy.Builder().allowAlarms(true).build();\n+        boolean isEnabled = true;\n+        AutomaticZenRule rule = new AutomaticZenRule(\"test\", owner, owner, mock(Uri.class),\n+                zenPolicy, NotificationManager.INTERRUPTION_FILTER_PRIORITY, isEnabled);\n+        mBinderService.addAutomaticZenRule(rule, \"com.android.settings\");\n+\n+        // verify that zen mode helper gets passed in a package name of \"android\"\n+        verify(mockZenModeHelper).addAutomaticZenRule(eq(\"android\"), eq(rule), anyString());\n+    }\n+\n+    @Test\n+    public void testAddAutomaticZenRule_systemAppIdCallTakesPackageFromOwner() throws Exception {\n+        // The multi-user case: where the calling uid doesn't match the system uid, but the calling\n+        // *appid* is the system.\n+        mService.isSystemUid = false;\n+        mService.isSystemAppId = true;\n+        ZenModeHelper mockZenModeHelper = mock(ZenModeHelper.class);\n+        when(mConditionProviders.isPackageOrComponentAllowed(anyString(), anyInt()))\n+                .thenReturn(true);\n+        mService.setZenHelper(mockZenModeHelper);\n+        ComponentName owner = new ComponentName(\"android\", \"ProviderName\");\n+        ZenPolicy zenPolicy = new ZenPolicy.Builder().allowAlarms(true).build();\n+        boolean isEnabled = true;\n+        AutomaticZenRule rule = new AutomaticZenRule(\"test\", owner, owner, mock(Uri.class),\n+                zenPolicy, NotificationManager.INTERRUPTION_FILTER_PRIORITY, isEnabled);\n+        mBinderService.addAutomaticZenRule(rule, \"com.android.settings\");\n+\n+        // verify that zen mode helper gets passed in a package name of \"android\"\n+        verify(mockZenModeHelper).addAutomaticZenRule(eq(\"android\"), eq(rule), anyString());\n+    }\n+\n+    @Test\n+    public void testAddAutomaticZenRule_nonSystemCallTakesPackageFromArg() throws Exception {\n+        mService.isSystemUid = false;\n+        mService.isSystemAppId = false;\n+        ZenModeHelper mockZenModeHelper = mock(ZenModeHelper.class);\n+        when(mConditionProviders.isPackageOrComponentAllowed(anyString(), anyInt()))\n+                .thenReturn(true);\n+        mService.setZenHelper(mockZenModeHelper);\n+        ComponentName owner = new ComponentName(\"android\", \"ProviderName\");\n+        ZenPolicy zenPolicy = new ZenPolicy.Builder().allowAlarms(true).build();\n+        boolean isEnabled = true;\n+        AutomaticZenRule rule = new AutomaticZenRule(\"test\", owner, owner, mock(Uri.class),\n+                zenPolicy, NotificationManager.INTERRUPTION_FILTER_PRIORITY, isEnabled);\n+        mBinderService.addAutomaticZenRule(rule, \"another.package\");\n+\n+        // verify that zen mode helper gets passed in the package name from the arg, not the owner\n+        verify(mockZenModeHelper).addAutomaticZenRule(\n+                eq(\"another.package\"), eq(rule), anyString());\n+    }\n+\n     @Test\n     public void testAreNotificationsEnabledForPackage_crossUser() throws Exception {\n         try {\n",
    "added_lines": 66,
    "deleted_lines": 0,
    "changed_methods": "NotificationManagerServiceTest::testAddAutomaticZenRule_nonSystemCallTakesPackageFromArg, NotificationManagerServiceTest::testAddAutomaticZenRule_systemAppIdCallTakesPackageFromOwner, NotificationManagerServiceTest::testAddAutomaticZenRule_systemCallTakesPackageFromOwner, NotificationManagerServiceTest::TestableNotificationManagerService::isCallingAppIdSystem"
   },
   {
    "filename": "ZenModeHelperTest.java",
    "diff": "@@ -1667,6 +1667,36 @@ public class ZenModeHelperTest extends UiServiceTestCase {\n         }\n     }\n \n+    @Test\n+    public void testAddAutomaticZenRule_claimedSystemOwner() {\n+        // Make sure anything that claims to have a \"system\" owner but not actually part of the\n+        // system package still gets limited on number of rules\n+        for (int i = 0; i < RULE_LIMIT_PER_PACKAGE; i++) {\n+            ScheduleInfo si = new ScheduleInfo();\n+            si.startHour = i;\n+            AutomaticZenRule zenRule = new AutomaticZenRule(\"name\" + i,\n+                    new ComponentName(\"android\", \"ScheduleConditionProvider\" + i),\n+                    null, // configuration activity\n+                    ZenModeConfig.toScheduleConditionId(si),\n+                    new ZenPolicy.Builder().build(),\n+                    NotificationManager.INTERRUPTION_FILTER_PRIORITY, true);\n+            String id = mZenModeHelperSpy.addAutomaticZenRule(\"pkgname\", zenRule, \"test\");\n+            assertNotNull(id);\n+        }\n+        try {\n+            AutomaticZenRule zenRule = new AutomaticZenRule(\"name\",\n+                    new ComponentName(\"android\", \"ScheduleConditionProviderFinal\"),\n+                    null, // configuration activity\n+                    ZenModeConfig.toScheduleConditionId(new ScheduleInfo()),\n+                    new ZenPolicy.Builder().build(),\n+                    NotificationManager.INTERRUPTION_FILTER_PRIORITY, true);\n+            String id = mZenModeHelperSpy.addAutomaticZenRule(\"pkgname\", zenRule, \"test\");\n+            fail(\"allowed too many rules to be created\");\n+        } catch (IllegalArgumentException e) {\n+            // yay\n+        }\n+    }\n+\n     @Test\n     public void testAddAutomaticZenRule_CA() {\n         AutomaticZenRule zenRule = new AutomaticZenRule(\"name\",\n",
    "added_lines": 30,
    "deleted_lines": 0,
    "changed_methods": "ZenModeHelperTest::testAddAutomaticZenRule_claimedSystemOwner"
   }
  ]
 },
 {
  "hash": "fff7a19e27e1026ad9a20a80d60a809343c6bc34",
  "commit": "Use rule package name in addAutomaticZenRule; specify \"android\" for all system apps\n\nThis is a roll forward of two reverted changes combined into one:\ncommit b6d04416628ab29df57efcd738332912d9260cea\ncommit e5e51116fb767162966a8e0d23fafb4f0ff46e86\n\nIt additionally fixes an issue where in multi-user profiles (such as a guest user), rules would be incorrectly identified as not created by the system and would therefore fail to be created in settings.\n\nBug: 257477671\nBug: 245236706\nBug: 242537431\nTest: NotificationManagerServiceTest; ZenModeHelperTest; manually verified that it's possible to create zen schedules from guest mode\nChange-Id: I0c4c705cfe5fc875151958957daaf8657fbc21a7\nMerged-In: I0c4c705cfe5fc875151958957daaf8657fbc21a7\n(cherry picked from commit 7261cdd30bf18965d421fc28c68c61e380bc952d)\n(cherry picked from commit 6e34748bdc541dbc841d6f29c0fb19a2eedec57d)\nMerged-In: I0c4c705cfe5fc875151958957daaf8657fbc21a7",
  "files": [
   {
    "filename": "NotificationManagerService.java",
    "diff": "@@ -4812,7 +4812,16 @@ public class NotificationManagerService extends SystemService {\n             }\n             enforcePolicyAccess(Binder.getCallingUid(), \"addAutomaticZenRule\");\n \n-            return mZenModeHelper.addAutomaticZenRule(pkg, automaticZenRule,\n+            // If the calling app is the system (from any user), take the package name from the\n+            // rule's owner rather than from the caller's package.\n+            String rulePkg = pkg;\n+            if (isCallingAppIdSystem()) {\n+                if (automaticZenRule.getOwner() != null) {\n+                    rulePkg = automaticZenRule.getOwner().getPackageName();\n+                }\n+            }\n+\n+            return mZenModeHelper.addAutomaticZenRule(rulePkg, automaticZenRule,\n                     \"addAutomaticZenRule\");\n         }\n \n@@ -9312,6 +9321,12 @@ public class NotificationManagerService extends SystemService {\n         return uid == Process.SYSTEM_UID;\n     }\n \n+    protected boolean isCallingAppIdSystem() {\n+        final int uid = Binder.getCallingUid();\n+        final int appid = UserHandle.getAppId(uid);\n+        return appid == Process.SYSTEM_UID;\n+    }\n+\n     protected boolean isUidSystemOrPhone(int uid) {\n         final int appid = UserHandle.getAppId(uid);\n         return (appid == Process.SYSTEM_UID || appid == Process.PHONE_UID\n",
    "added_lines": 16,
    "deleted_lines": 1,
    "changed_methods": "NotificationManagerService::Stub, NotificationManagerService::isCallingAppIdSystem"
   },
   {
    "filename": "ZenModeHelper.java",
    "diff": "@@ -310,7 +310,7 @@ public class ZenModeHelper {\n \n     public String addAutomaticZenRule(String pkg, AutomaticZenRule automaticZenRule,\n             String reason) {\n-        if (!isSystemRule(automaticZenRule)) {\n+        if (!ZenModeConfig.SYSTEM_AUTHORITY.equals(pkg)) {\n             PackageItemInfo component = getServiceInfo(automaticZenRule.getOwner());\n             if (component == null) {\n                 component = getActivityInfo(automaticZenRule.getConfigurationActivity());\n@@ -566,11 +566,6 @@ public class ZenModeHelper {\n         }\n     }\n \n-    private boolean isSystemRule(AutomaticZenRule rule) {\n-        return rule.getOwner() != null\n-                && ZenModeConfig.SYSTEM_AUTHORITY.equals(rule.getOwner().getPackageName());\n-    }\n-\n     private ServiceInfo getServiceInfo(ComponentName owner) {\n         Intent queryIntent = new Intent();\n         queryIntent.setComponent(owner);\n",
    "added_lines": 1,
    "deleted_lines": 6,
    "changed_methods": "ZenModeHelper::isSystemRule, ZenModeHelper::addAutomaticZenRule"
   },
   {
    "filename": "NotificationManagerServiceTest.java",
    "diff": "@@ -340,6 +340,7 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n     private static class TestableNotificationManagerService extends NotificationManagerService {\n         int countSystemChecks = 0;\n         boolean isSystemUid = true;\n+        boolean isSystemAppId = true;\n         int countLogSmartSuggestionsVisible = 0;\n         @Nullable\n         NotificationAssistantAccessGrantedCallback mNotificationAssistantAccessGrantedCallback;\n@@ -359,6 +360,12 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n             return isSystemUid;\n         }\n \n+        @Override\n+        protected boolean isCallingAppIdSystem() {\n+            countSystemChecks++;\n+            return isSystemUid || isSystemAppId;\n+        }\n+\n         @Override\n         protected boolean isCallerSystemOrPhone() {\n             countSystemChecks++;\n@@ -6748,6 +6755,65 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n         mBinderService.addAutomaticZenRule(rule, mContext.getPackageName());\n     }\n \n+    @Test\n+    public void testAddAutomaticZenRule_systemCallTakesPackageFromOwner() throws Exception {\n+        mService.isSystemUid = true;\n+        ZenModeHelper mockZenModeHelper = mock(ZenModeHelper.class);\n+        when(mConditionProviders.isPackageOrComponentAllowed(anyString(), anyInt()))\n+                .thenReturn(true);\n+        mService.setZenHelper(mockZenModeHelper);\n+        ComponentName owner = new ComponentName(\"android\", \"ProviderName\");\n+        ZenPolicy zenPolicy = new ZenPolicy.Builder().allowAlarms(true).build();\n+        boolean isEnabled = true;\n+        AutomaticZenRule rule = new AutomaticZenRule(\"test\", owner, owner, mock(Uri.class),\n+                zenPolicy, NotificationManager.INTERRUPTION_FILTER_PRIORITY, isEnabled);\n+        mBinderService.addAutomaticZenRule(rule, \"com.android.settings\");\n+\n+        // verify that zen mode helper gets passed in a package name of \"android\"\n+        verify(mockZenModeHelper).addAutomaticZenRule(eq(\"android\"), eq(rule), anyString());\n+    }\n+\n+    @Test\n+    public void testAddAutomaticZenRule_systemAppIdCallTakesPackageFromOwner() throws Exception {\n+        // The multi-user case: where the calling uid doesn't match the system uid, but the calling\n+        // *appid* is the system.\n+        mService.isSystemUid = false;\n+        mService.isSystemAppId = true;\n+        ZenModeHelper mockZenModeHelper = mock(ZenModeHelper.class);\n+        when(mConditionProviders.isPackageOrComponentAllowed(anyString(), anyInt()))\n+                .thenReturn(true);\n+        mService.setZenHelper(mockZenModeHelper);\n+        ComponentName owner = new ComponentName(\"android\", \"ProviderName\");\n+        ZenPolicy zenPolicy = new ZenPolicy.Builder().allowAlarms(true).build();\n+        boolean isEnabled = true;\n+        AutomaticZenRule rule = new AutomaticZenRule(\"test\", owner, owner, mock(Uri.class),\n+                zenPolicy, NotificationManager.INTERRUPTION_FILTER_PRIORITY, isEnabled);\n+        mBinderService.addAutomaticZenRule(rule, \"com.android.settings\");\n+\n+        // verify that zen mode helper gets passed in a package name of \"android\"\n+        verify(mockZenModeHelper).addAutomaticZenRule(eq(\"android\"), eq(rule), anyString());\n+    }\n+\n+    @Test\n+    public void testAddAutomaticZenRule_nonSystemCallTakesPackageFromArg() throws Exception {\n+        mService.isSystemUid = false;\n+        mService.isSystemAppId = false;\n+        ZenModeHelper mockZenModeHelper = mock(ZenModeHelper.class);\n+        when(mConditionProviders.isPackageOrComponentAllowed(anyString(), anyInt()))\n+                .thenReturn(true);\n+        mService.setZenHelper(mockZenModeHelper);\n+        ComponentName owner = new ComponentName(\"android\", \"ProviderName\");\n+        ZenPolicy zenPolicy = new ZenPolicy.Builder().allowAlarms(true).build();\n+        boolean isEnabled = true;\n+        AutomaticZenRule rule = new AutomaticZenRule(\"test\", owner, owner, mock(Uri.class),\n+                zenPolicy, NotificationManager.INTERRUPTION_FILTER_PRIORITY, isEnabled);\n+        mBinderService.addAutomaticZenRule(rule, \"another.package\");\n+\n+        // verify that zen mode helper gets passed in the package name from the arg, not the owner\n+        verify(mockZenModeHelper).addAutomaticZenRule(\n+                eq(\"another.package\"), eq(rule), anyString());\n+    }\n+\n     @Test\n     public void testAreNotificationsEnabledForPackage_crossUser() throws Exception {\n         try {\n",
    "added_lines": 66,
    "deleted_lines": 0,
    "changed_methods": "NotificationManagerServiceTest::testAddAutomaticZenRule_nonSystemCallTakesPackageFromArg, NotificationManagerServiceTest::testAddAutomaticZenRule_systemAppIdCallTakesPackageFromOwner, NotificationManagerServiceTest::testAddAutomaticZenRule_systemCallTakesPackageFromOwner, NotificationManagerServiceTest::TestableNotificationManagerService::isCallingAppIdSystem"
   },
   {
    "filename": "ZenModeHelperTest.java",
    "diff": "@@ -1667,6 +1667,36 @@ public class ZenModeHelperTest extends UiServiceTestCase {\n         }\n     }\n \n+    @Test\n+    public void testAddAutomaticZenRule_claimedSystemOwner() {\n+        // Make sure anything that claims to have a \"system\" owner but not actually part of the\n+        // system package still gets limited on number of rules\n+        for (int i = 0; i < RULE_LIMIT_PER_PACKAGE; i++) {\n+            ScheduleInfo si = new ScheduleInfo();\n+            si.startHour = i;\n+            AutomaticZenRule zenRule = new AutomaticZenRule(\"name\" + i,\n+                    new ComponentName(\"android\", \"ScheduleConditionProvider\" + i),\n+                    null, // configuration activity\n+                    ZenModeConfig.toScheduleConditionId(si),\n+                    new ZenPolicy.Builder().build(),\n+                    NotificationManager.INTERRUPTION_FILTER_PRIORITY, true);\n+            String id = mZenModeHelperSpy.addAutomaticZenRule(\"pkgname\", zenRule, \"test\");\n+            assertNotNull(id);\n+        }\n+        try {\n+            AutomaticZenRule zenRule = new AutomaticZenRule(\"name\",\n+                    new ComponentName(\"android\", \"ScheduleConditionProviderFinal\"),\n+                    null, // configuration activity\n+                    ZenModeConfig.toScheduleConditionId(new ScheduleInfo()),\n+                    new ZenPolicy.Builder().build(),\n+                    NotificationManager.INTERRUPTION_FILTER_PRIORITY, true);\n+            String id = mZenModeHelperSpy.addAutomaticZenRule(\"pkgname\", zenRule, \"test\");\n+            fail(\"allowed too many rules to be created\");\n+        } catch (IllegalArgumentException e) {\n+            // yay\n+        }\n+    }\n+\n     @Test\n     public void testAddAutomaticZenRule_CA() {\n         AutomaticZenRule zenRule = new AutomaticZenRule(\"name\",\n",
    "added_lines": 30,
    "deleted_lines": 0,
    "changed_methods": "ZenModeHelperTest::testAddAutomaticZenRule_claimedSystemOwner"
   }
  ]
 },
 {
  "hash": "fff7a19e27e1026ad9a20a80d60a809343c6bc34",
  "commit": "Use rule package name in addAutomaticZenRule; specify \"android\" for all system apps\n\nThis is a roll forward of two reverted changes combined into one:\ncommit b6d04416628ab29df57efcd738332912d9260cea\ncommit e5e51116fb767162966a8e0d23fafb4f0ff46e86\n\nIt additionally fixes an issue where in multi-user profiles (such as a guest user), rules would be incorrectly identified as not created by the system and would therefore fail to be created in settings.\n\nBug: 257477671\nBug: 245236706\nBug: 242537431\nTest: NotificationManagerServiceTest; ZenModeHelperTest; manually verified that it's possible to create zen schedules from guest mode\nChange-Id: I0c4c705cfe5fc875151958957daaf8657fbc21a7\nMerged-In: I0c4c705cfe5fc875151958957daaf8657fbc21a7\n(cherry picked from commit 7261cdd30bf18965d421fc28c68c61e380bc952d)\n(cherry picked from commit 6e34748bdc541dbc841d6f29c0fb19a2eedec57d)\nMerged-In: I0c4c705cfe5fc875151958957daaf8657fbc21a7",
  "files": [
   {
    "filename": "NotificationManagerService.java",
    "diff": "@@ -4812,7 +4812,16 @@ public class NotificationManagerService extends SystemService {\n             }\n             enforcePolicyAccess(Binder.getCallingUid(), \"addAutomaticZenRule\");\n \n-            return mZenModeHelper.addAutomaticZenRule(pkg, automaticZenRule,\n+            // If the calling app is the system (from any user), take the package name from the\n+            // rule's owner rather than from the caller's package.\n+            String rulePkg = pkg;\n+            if (isCallingAppIdSystem()) {\n+                if (automaticZenRule.getOwner() != null) {\n+                    rulePkg = automaticZenRule.getOwner().getPackageName();\n+                }\n+            }\n+\n+            return mZenModeHelper.addAutomaticZenRule(rulePkg, automaticZenRule,\n                     \"addAutomaticZenRule\");\n         }\n \n@@ -9312,6 +9321,12 @@ public class NotificationManagerService extends SystemService {\n         return uid == Process.SYSTEM_UID;\n     }\n \n+    protected boolean isCallingAppIdSystem() {\n+        final int uid = Binder.getCallingUid();\n+        final int appid = UserHandle.getAppId(uid);\n+        return appid == Process.SYSTEM_UID;\n+    }\n+\n     protected boolean isUidSystemOrPhone(int uid) {\n         final int appid = UserHandle.getAppId(uid);\n         return (appid == Process.SYSTEM_UID || appid == Process.PHONE_UID\n",
    "added_lines": 16,
    "deleted_lines": 1,
    "changed_methods": "NotificationManagerService::Stub, NotificationManagerService::isCallingAppIdSystem"
   },
   {
    "filename": "ZenModeHelper.java",
    "diff": "@@ -310,7 +310,7 @@ public class ZenModeHelper {\n \n     public String addAutomaticZenRule(String pkg, AutomaticZenRule automaticZenRule,\n             String reason) {\n-        if (!isSystemRule(automaticZenRule)) {\n+        if (!ZenModeConfig.SYSTEM_AUTHORITY.equals(pkg)) {\n             PackageItemInfo component = getServiceInfo(automaticZenRule.getOwner());\n             if (component == null) {\n                 component = getActivityInfo(automaticZenRule.getConfigurationActivity());\n@@ -566,11 +566,6 @@ public class ZenModeHelper {\n         }\n     }\n \n-    private boolean isSystemRule(AutomaticZenRule rule) {\n-        return rule.getOwner() != null\n-                && ZenModeConfig.SYSTEM_AUTHORITY.equals(rule.getOwner().getPackageName());\n-    }\n-\n     private ServiceInfo getServiceInfo(ComponentName owner) {\n         Intent queryIntent = new Intent();\n         queryIntent.setComponent(owner);\n",
    "added_lines": 1,
    "deleted_lines": 6,
    "changed_methods": "ZenModeHelper::isSystemRule, ZenModeHelper::addAutomaticZenRule"
   },
   {
    "filename": "NotificationManagerServiceTest.java",
    "diff": "@@ -340,6 +340,7 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n     private static class TestableNotificationManagerService extends NotificationManagerService {\n         int countSystemChecks = 0;\n         boolean isSystemUid = true;\n+        boolean isSystemAppId = true;\n         int countLogSmartSuggestionsVisible = 0;\n         @Nullable\n         NotificationAssistantAccessGrantedCallback mNotificationAssistantAccessGrantedCallback;\n@@ -359,6 +360,12 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n             return isSystemUid;\n         }\n \n+        @Override\n+        protected boolean isCallingAppIdSystem() {\n+            countSystemChecks++;\n+            return isSystemUid || isSystemAppId;\n+        }\n+\n         @Override\n         protected boolean isCallerSystemOrPhone() {\n             countSystemChecks++;\n@@ -6748,6 +6755,65 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n         mBinderService.addAutomaticZenRule(rule, mContext.getPackageName());\n     }\n \n+    @Test\n+    public void testAddAutomaticZenRule_systemCallTakesPackageFromOwner() throws Exception {\n+        mService.isSystemUid = true;\n+        ZenModeHelper mockZenModeHelper = mock(ZenModeHelper.class);\n+        when(mConditionProviders.isPackageOrComponentAllowed(anyString(), anyInt()))\n+                .thenReturn(true);\n+        mService.setZenHelper(mockZenModeHelper);\n+        ComponentName owner = new ComponentName(\"android\", \"ProviderName\");\n+        ZenPolicy zenPolicy = new ZenPolicy.Builder().allowAlarms(true).build();\n+        boolean isEnabled = true;\n+        AutomaticZenRule rule = new AutomaticZenRule(\"test\", owner, owner, mock(Uri.class),\n+                zenPolicy, NotificationManager.INTERRUPTION_FILTER_PRIORITY, isEnabled);\n+        mBinderService.addAutomaticZenRule(rule, \"com.android.settings\");\n+\n+        // verify that zen mode helper gets passed in a package name of \"android\"\n+        verify(mockZenModeHelper).addAutomaticZenRule(eq(\"android\"), eq(rule), anyString());\n+    }\n+\n+    @Test\n+    public void testAddAutomaticZenRule_systemAppIdCallTakesPackageFromOwner() throws Exception {\n+        // The multi-user case: where the calling uid doesn't match the system uid, but the calling\n+        // *appid* is the system.\n+        mService.isSystemUid = false;\n+        mService.isSystemAppId = true;\n+        ZenModeHelper mockZenModeHelper = mock(ZenModeHelper.class);\n+        when(mConditionProviders.isPackageOrComponentAllowed(anyString(), anyInt()))\n+                .thenReturn(true);\n+        mService.setZenHelper(mockZenModeHelper);\n+        ComponentName owner = new ComponentName(\"android\", \"ProviderName\");\n+        ZenPolicy zenPolicy = new ZenPolicy.Builder().allowAlarms(true).build();\n+        boolean isEnabled = true;\n+        AutomaticZenRule rule = new AutomaticZenRule(\"test\", owner, owner, mock(Uri.class),\n+                zenPolicy, NotificationManager.INTERRUPTION_FILTER_PRIORITY, isEnabled);\n+        mBinderService.addAutomaticZenRule(rule, \"com.android.settings\");\n+\n+        // verify that zen mode helper gets passed in a package name of \"android\"\n+        verify(mockZenModeHelper).addAutomaticZenRule(eq(\"android\"), eq(rule), anyString());\n+    }\n+\n+    @Test\n+    public void testAddAutomaticZenRule_nonSystemCallTakesPackageFromArg() throws Exception {\n+        mService.isSystemUid = false;\n+        mService.isSystemAppId = false;\n+        ZenModeHelper mockZenModeHelper = mock(ZenModeHelper.class);\n+        when(mConditionProviders.isPackageOrComponentAllowed(anyString(), anyInt()))\n+                .thenReturn(true);\n+        mService.setZenHelper(mockZenModeHelper);\n+        ComponentName owner = new ComponentName(\"android\", \"ProviderName\");\n+        ZenPolicy zenPolicy = new ZenPolicy.Builder().allowAlarms(true).build();\n+        boolean isEnabled = true;\n+        AutomaticZenRule rule = new AutomaticZenRule(\"test\", owner, owner, mock(Uri.class),\n+                zenPolicy, NotificationManager.INTERRUPTION_FILTER_PRIORITY, isEnabled);\n+        mBinderService.addAutomaticZenRule(rule, \"another.package\");\n+\n+        // verify that zen mode helper gets passed in the package name from the arg, not the owner\n+        verify(mockZenModeHelper).addAutomaticZenRule(\n+                eq(\"another.package\"), eq(rule), anyString());\n+    }\n+\n     @Test\n     public void testAreNotificationsEnabledForPackage_crossUser() throws Exception {\n         try {\n",
    "added_lines": 66,
    "deleted_lines": 0,
    "changed_methods": "NotificationManagerServiceTest::testAddAutomaticZenRule_nonSystemCallTakesPackageFromArg, NotificationManagerServiceTest::testAddAutomaticZenRule_systemAppIdCallTakesPackageFromOwner, NotificationManagerServiceTest::testAddAutomaticZenRule_systemCallTakesPackageFromOwner, NotificationManagerServiceTest::TestableNotificationManagerService::isCallingAppIdSystem"
   },
   {
    "filename": "ZenModeHelperTest.java",
    "diff": "@@ -1667,6 +1667,36 @@ public class ZenModeHelperTest extends UiServiceTestCase {\n         }\n     }\n \n+    @Test\n+    public void testAddAutomaticZenRule_claimedSystemOwner() {\n+        // Make sure anything that claims to have a \"system\" owner but not actually part of the\n+        // system package still gets limited on number of rules\n+        for (int i = 0; i < RULE_LIMIT_PER_PACKAGE; i++) {\n+            ScheduleInfo si = new ScheduleInfo();\n+            si.startHour = i;\n+            AutomaticZenRule zenRule = new AutomaticZenRule(\"name\" + i,\n+                    new ComponentName(\"android\", \"ScheduleConditionProvider\" + i),\n+                    null, // configuration activity\n+                    ZenModeConfig.toScheduleConditionId(si),\n+                    new ZenPolicy.Builder().build(),\n+                    NotificationManager.INTERRUPTION_FILTER_PRIORITY, true);\n+            String id = mZenModeHelperSpy.addAutomaticZenRule(\"pkgname\", zenRule, \"test\");\n+            assertNotNull(id);\n+        }\n+        try {\n+            AutomaticZenRule zenRule = new AutomaticZenRule(\"name\",\n+                    new ComponentName(\"android\", \"ScheduleConditionProviderFinal\"),\n+                    null, // configuration activity\n+                    ZenModeConfig.toScheduleConditionId(new ScheduleInfo()),\n+                    new ZenPolicy.Builder().build(),\n+                    NotificationManager.INTERRUPTION_FILTER_PRIORITY, true);\n+            String id = mZenModeHelperSpy.addAutomaticZenRule(\"pkgname\", zenRule, \"test\");\n+            fail(\"allowed too many rules to be created\");\n+        } catch (IllegalArgumentException e) {\n+            // yay\n+        }\n+    }\n+\n     @Test\n     public void testAddAutomaticZenRule_CA() {\n         AutomaticZenRule zenRule = new AutomaticZenRule(\"name\",\n",
    "added_lines": 30,
    "deleted_lines": 0,
    "changed_methods": "ZenModeHelperTest::testAddAutomaticZenRule_claimedSystemOwner"
   }
  ]
 },
 {
  "hash": "fff7a19e27e1026ad9a20a80d60a809343c6bc34",
  "commit": "Use rule package name in addAutomaticZenRule; specify \"android\" for all system apps\n\nThis is a roll forward of two reverted changes combined into one:\ncommit b6d04416628ab29df57efcd738332912d9260cea\ncommit e5e51116fb767162966a8e0d23fafb4f0ff46e86\n\nIt additionally fixes an issue where in multi-user profiles (such as a guest user), rules would be incorrectly identified as not created by the system and would therefore fail to be created in settings.\n\nBug: 257477671\nBug: 245236706\nBug: 242537431\nTest: NotificationManagerServiceTest; ZenModeHelperTest; manually verified that it's possible to create zen schedules from guest mode\nChange-Id: I0c4c705cfe5fc875151958957daaf8657fbc21a7\nMerged-In: I0c4c705cfe5fc875151958957daaf8657fbc21a7\n(cherry picked from commit 7261cdd30bf18965d421fc28c68c61e380bc952d)\n(cherry picked from commit 6e34748bdc541dbc841d6f29c0fb19a2eedec57d)\nMerged-In: I0c4c705cfe5fc875151958957daaf8657fbc21a7",
  "files": [
   {
    "filename": "NotificationManagerService.java",
    "diff": "@@ -4812,7 +4812,16 @@ public class NotificationManagerService extends SystemService {\n             }\n             enforcePolicyAccess(Binder.getCallingUid(), \"addAutomaticZenRule\");\n \n-            return mZenModeHelper.addAutomaticZenRule(pkg, automaticZenRule,\n+            // If the calling app is the system (from any user), take the package name from the\n+            // rule's owner rather than from the caller's package.\n+            String rulePkg = pkg;\n+            if (isCallingAppIdSystem()) {\n+                if (automaticZenRule.getOwner() != null) {\n+                    rulePkg = automaticZenRule.getOwner().getPackageName();\n+                }\n+            }\n+\n+            return mZenModeHelper.addAutomaticZenRule(rulePkg, automaticZenRule,\n                     \"addAutomaticZenRule\");\n         }\n \n@@ -9312,6 +9321,12 @@ public class NotificationManagerService extends SystemService {\n         return uid == Process.SYSTEM_UID;\n     }\n \n+    protected boolean isCallingAppIdSystem() {\n+        final int uid = Binder.getCallingUid();\n+        final int appid = UserHandle.getAppId(uid);\n+        return appid == Process.SYSTEM_UID;\n+    }\n+\n     protected boolean isUidSystemOrPhone(int uid) {\n         final int appid = UserHandle.getAppId(uid);\n         return (appid == Process.SYSTEM_UID || appid == Process.PHONE_UID\n",
    "added_lines": 16,
    "deleted_lines": 1,
    "changed_methods": "NotificationManagerService::Stub, NotificationManagerService::isCallingAppIdSystem"
   },
   {
    "filename": "ZenModeHelper.java",
    "diff": "@@ -310,7 +310,7 @@ public class ZenModeHelper {\n \n     public String addAutomaticZenRule(String pkg, AutomaticZenRule automaticZenRule,\n             String reason) {\n-        if (!isSystemRule(automaticZenRule)) {\n+        if (!ZenModeConfig.SYSTEM_AUTHORITY.equals(pkg)) {\n             PackageItemInfo component = getServiceInfo(automaticZenRule.getOwner());\n             if (component == null) {\n                 component = getActivityInfo(automaticZenRule.getConfigurationActivity());\n@@ -566,11 +566,6 @@ public class ZenModeHelper {\n         }\n     }\n \n-    private boolean isSystemRule(AutomaticZenRule rule) {\n-        return rule.getOwner() != null\n-                && ZenModeConfig.SYSTEM_AUTHORITY.equals(rule.getOwner().getPackageName());\n-    }\n-\n     private ServiceInfo getServiceInfo(ComponentName owner) {\n         Intent queryIntent = new Intent();\n         queryIntent.setComponent(owner);\n",
    "added_lines": 1,
    "deleted_lines": 6,
    "changed_methods": "ZenModeHelper::isSystemRule, ZenModeHelper::addAutomaticZenRule"
   },
   {
    "filename": "NotificationManagerServiceTest.java",
    "diff": "@@ -340,6 +340,7 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n     private static class TestableNotificationManagerService extends NotificationManagerService {\n         int countSystemChecks = 0;\n         boolean isSystemUid = true;\n+        boolean isSystemAppId = true;\n         int countLogSmartSuggestionsVisible = 0;\n         @Nullable\n         NotificationAssistantAccessGrantedCallback mNotificationAssistantAccessGrantedCallback;\n@@ -359,6 +360,12 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n             return isSystemUid;\n         }\n \n+        @Override\n+        protected boolean isCallingAppIdSystem() {\n+            countSystemChecks++;\n+            return isSystemUid || isSystemAppId;\n+        }\n+\n         @Override\n         protected boolean isCallerSystemOrPhone() {\n             countSystemChecks++;\n@@ -6748,6 +6755,65 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n         mBinderService.addAutomaticZenRule(rule, mContext.getPackageName());\n     }\n \n+    @Test\n+    public void testAddAutomaticZenRule_systemCallTakesPackageFromOwner() throws Exception {\n+        mService.isSystemUid = true;\n+        ZenModeHelper mockZenModeHelper = mock(ZenModeHelper.class);\n+        when(mConditionProviders.isPackageOrComponentAllowed(anyString(), anyInt()))\n+                .thenReturn(true);\n+        mService.setZenHelper(mockZenModeHelper);\n+        ComponentName owner = new ComponentName(\"android\", \"ProviderName\");\n+        ZenPolicy zenPolicy = new ZenPolicy.Builder().allowAlarms(true).build();\n+        boolean isEnabled = true;\n+        AutomaticZenRule rule = new AutomaticZenRule(\"test\", owner, owner, mock(Uri.class),\n+                zenPolicy, NotificationManager.INTERRUPTION_FILTER_PRIORITY, isEnabled);\n+        mBinderService.addAutomaticZenRule(rule, \"com.android.settings\");\n+\n+        // verify that zen mode helper gets passed in a package name of \"android\"\n+        verify(mockZenModeHelper).addAutomaticZenRule(eq(\"android\"), eq(rule), anyString());\n+    }\n+\n+    @Test\n+    public void testAddAutomaticZenRule_systemAppIdCallTakesPackageFromOwner() throws Exception {\n+        // The multi-user case: where the calling uid doesn't match the system uid, but the calling\n+        // *appid* is the system.\n+        mService.isSystemUid = false;\n+        mService.isSystemAppId = true;\n+        ZenModeHelper mockZenModeHelper = mock(ZenModeHelper.class);\n+        when(mConditionProviders.isPackageOrComponentAllowed(anyString(), anyInt()))\n+                .thenReturn(true);\n+        mService.setZenHelper(mockZenModeHelper);\n+        ComponentName owner = new ComponentName(\"android\", \"ProviderName\");\n+        ZenPolicy zenPolicy = new ZenPolicy.Builder().allowAlarms(true).build();\n+        boolean isEnabled = true;\n+        AutomaticZenRule rule = new AutomaticZenRule(\"test\", owner, owner, mock(Uri.class),\n+                zenPolicy, NotificationManager.INTERRUPTION_FILTER_PRIORITY, isEnabled);\n+        mBinderService.addAutomaticZenRule(rule, \"com.android.settings\");\n+\n+        // verify that zen mode helper gets passed in a package name of \"android\"\n+        verify(mockZenModeHelper).addAutomaticZenRule(eq(\"android\"), eq(rule), anyString());\n+    }\n+\n+    @Test\n+    public void testAddAutomaticZenRule_nonSystemCallTakesPackageFromArg() throws Exception {\n+        mService.isSystemUid = false;\n+        mService.isSystemAppId = false;\n+        ZenModeHelper mockZenModeHelper = mock(ZenModeHelper.class);\n+        when(mConditionProviders.isPackageOrComponentAllowed(anyString(), anyInt()))\n+                .thenReturn(true);\n+        mService.setZenHelper(mockZenModeHelper);\n+        ComponentName owner = new ComponentName(\"android\", \"ProviderName\");\n+        ZenPolicy zenPolicy = new ZenPolicy.Builder().allowAlarms(true).build();\n+        boolean isEnabled = true;\n+        AutomaticZenRule rule = new AutomaticZenRule(\"test\", owner, owner, mock(Uri.class),\n+                zenPolicy, NotificationManager.INTERRUPTION_FILTER_PRIORITY, isEnabled);\n+        mBinderService.addAutomaticZenRule(rule, \"another.package\");\n+\n+        // verify that zen mode helper gets passed in the package name from the arg, not the owner\n+        verify(mockZenModeHelper).addAutomaticZenRule(\n+                eq(\"another.package\"), eq(rule), anyString());\n+    }\n+\n     @Test\n     public void testAreNotificationsEnabledForPackage_crossUser() throws Exception {\n         try {\n",
    "added_lines": 66,
    "deleted_lines": 0,
    "changed_methods": "NotificationManagerServiceTest::testAddAutomaticZenRule_nonSystemCallTakesPackageFromArg, NotificationManagerServiceTest::testAddAutomaticZenRule_systemAppIdCallTakesPackageFromOwner, NotificationManagerServiceTest::testAddAutomaticZenRule_systemCallTakesPackageFromOwner, NotificationManagerServiceTest::TestableNotificationManagerService::isCallingAppIdSystem"
   },
   {
    "filename": "ZenModeHelperTest.java",
    "diff": "@@ -1667,6 +1667,36 @@ public class ZenModeHelperTest extends UiServiceTestCase {\n         }\n     }\n \n+    @Test\n+    public void testAddAutomaticZenRule_claimedSystemOwner() {\n+        // Make sure anything that claims to have a \"system\" owner but not actually part of the\n+        // system package still gets limited on number of rules\n+        for (int i = 0; i < RULE_LIMIT_PER_PACKAGE; i++) {\n+            ScheduleInfo si = new ScheduleInfo();\n+            si.startHour = i;\n+            AutomaticZenRule zenRule = new AutomaticZenRule(\"name\" + i,\n+                    new ComponentName(\"android\", \"ScheduleConditionProvider\" + i),\n+                    null, // configuration activity\n+                    ZenModeConfig.toScheduleConditionId(si),\n+                    new ZenPolicy.Builder().build(),\n+                    NotificationManager.INTERRUPTION_FILTER_PRIORITY, true);\n+            String id = mZenModeHelperSpy.addAutomaticZenRule(\"pkgname\", zenRule, \"test\");\n+            assertNotNull(id);\n+        }\n+        try {\n+            AutomaticZenRule zenRule = new AutomaticZenRule(\"name\",\n+                    new ComponentName(\"android\", \"ScheduleConditionProviderFinal\"),\n+                    null, // configuration activity\n+                    ZenModeConfig.toScheduleConditionId(new ScheduleInfo()),\n+                    new ZenPolicy.Builder().build(),\n+                    NotificationManager.INTERRUPTION_FILTER_PRIORITY, true);\n+            String id = mZenModeHelperSpy.addAutomaticZenRule(\"pkgname\", zenRule, \"test\");\n+            fail(\"allowed too many rules to be created\");\n+        } catch (IllegalArgumentException e) {\n+            // yay\n+        }\n+    }\n+\n     @Test\n     public void testAddAutomaticZenRule_CA() {\n         AutomaticZenRule zenRule = new AutomaticZenRule(\"name\",\n",
    "added_lines": 30,
    "deleted_lines": 0,
    "changed_methods": "ZenModeHelperTest::testAddAutomaticZenRule_claimedSystemOwner"
   }
  ]
 },
 {
  "hash": "693e82f72cdf40d65a151c24e9168f345ee551af",
  "commit": "RESTRICT AUTOMERGE Use chain start token in performOpTransaction\n\nBug: 258672042\nTest: atest CtsPermission4TestCases\nChange-Id: I1d484ed7c72d4ae73f4cbec47522a18ae9088f6e\n(cherry picked from commit 9d09846798bce7253ed1202adb61257d4eefbd1d)\nMerged-In: I1d484ed7c72d4ae73f4cbec47522a18ae9088f6e",
  "files": [
   {
    "filename": "AppOpsManager.java",
    "diff": "@@ -8888,8 +8888,9 @@ public class AppOpsManager {\n      */\n     public int startProxyOpNoThrow(int op, @NonNull AttributionSource attributionSource,\n             @Nullable String message, boolean skipProxyOperation) {\n-        return startProxyOpNoThrow(op, attributionSource, message, skipProxyOperation,\n-                ATTRIBUTION_FLAGS_NONE, ATTRIBUTION_FLAGS_NONE, ATTRIBUTION_CHAIN_ID_NONE);\n+        return startProxyOpNoThrow(attributionSource.getToken(), op, attributionSource, message,\n+                skipProxyOperation, ATTRIBUTION_FLAGS_NONE, ATTRIBUTION_FLAGS_NONE,\n+                ATTRIBUTION_CHAIN_ID_NONE);\n     }\n \n     /**\n@@ -8901,7 +8902,8 @@ public class AppOpsManager {\n      *\n      * @hide\n      */\n-    public int startProxyOpNoThrow(int op, @NonNull AttributionSource attributionSource,\n+    public int startProxyOpNoThrow(@NonNull IBinder clientId, int op,\n+            @NonNull AttributionSource attributionSource,\n             @Nullable String message, boolean skipProxyOperation, @AttributionFlags\n             int proxyAttributionFlags, @AttributionFlags int proxiedAttributionFlags,\n             int attributionChainId) {\n@@ -8919,7 +8921,7 @@ public class AppOpsManager {\n                 }\n             }\n \n-            SyncNotedAppOp syncOp = mService.startProxyOperation(op,\n+            SyncNotedAppOp syncOp = mService.startProxyOperation(clientId, op,\n                     attributionSource, false, collectionMode == COLLECT_ASYNC, message,\n                     shouldCollectMessage, skipProxyOperation, proxyAttributionFlags,\n                     proxiedAttributionFlags, attributionChainId);\n@@ -9017,9 +9019,10 @@ public class AppOpsManager {\n      */\n     public void finishProxyOp(@NonNull String op, int proxiedUid,\n             @NonNull String proxiedPackageName, @Nullable String proxiedAttributionTag) {\n-        finishProxyOp(op, new AttributionSource(mContext.getAttributionSource(),\n+        IBinder token = mContext.getAttributionSource().getToken();\n+        finishProxyOp(token, op, new AttributionSource(mContext.getAttributionSource(),\n                 new AttributionSource(proxiedUid, proxiedPackageName,  proxiedAttributionTag,\n-                        mContext.getAttributionSource().getToken())), /*skipProxyOperation*/ false);\n+                        token)), /*skipProxyOperation*/ false);\n     }\n \n     /**\n@@ -9034,10 +9037,11 @@ public class AppOpsManager {\n      *\n      * @hide\n      */\n-    public void finishProxyOp(@NonNull String op, @NonNull AttributionSource attributionSource,\n-            boolean skipProxyOperation) {\n+    public void finishProxyOp(@NonNull IBinder clientId, @NonNull String op,\n+            @NonNull AttributionSource attributionSource, boolean skipProxyOperation) {\n         try {\n-            mService.finishProxyOperation(strOpToOp(op), attributionSource, skipProxyOperation);\n+            mService.finishProxyOperation(clientId, strOpToOp(op), attributionSource,\n+                    skipProxyOperation);\n         } catch (RemoteException e) {\n             throw e.rethrowFromSystemServer();\n         }\n",
    "added_lines": 13,
    "deleted_lines": 9,
    "changed_methods": "AppOpsManager::startProxyOpNoThrow, AppOpsManager::startProxyOpNoThrow, AppOpsManager::startProxyOpNoThrow, AppOpsManager::finishProxyOp, AppOpsManager::finishProxyOp, AppOpsManager::finishProxyOp"
   },
   {
    "filename": "AppOpsManagerInternal.java",
    "diff": "@@ -26,13 +26,11 @@ import android.util.SparseArray;\n import android.util.SparseIntArray;\n \n import com.android.internal.app.IAppOpsCallback;\n-import com.android.internal.util.function.DecFunction;\n import com.android.internal.util.function.HeptFunction;\n import com.android.internal.util.function.HexFunction;\n import com.android.internal.util.function.QuadFunction;\n import com.android.internal.util.function.QuintConsumer;\n import com.android.internal.util.function.QuintFunction;\n-import com.android.internal.util.function.TriFunction;\n import com.android.internal.util.function.UndecFunction;\n \n /**\n@@ -135,6 +133,7 @@ public abstract class AppOpsManagerInternal {\n         /**\n          * Allows overriding start proxy operation behavior.\n          *\n+         * @param clientId The client calling start, represented by an IBinder\n          * @param code The op code to start.\n          * @param attributionSource The permission identity of the caller.\n          * @param startIfModeDefault Whether to start the op of the mode is default.\n@@ -148,11 +147,12 @@ public abstract class AppOpsManagerInternal {\n          * @param superImpl The super implementation.\n          * @return The app op note result.\n          */\n-        SyncNotedAppOp startProxyOperation(int code, @NonNull AttributionSource attributionSource,\n-                boolean startIfModeDefault, boolean shouldCollectAsyncNotedOp, String message,\n-                boolean shouldCollectMessage, boolean skipProxyOperation, @AttributionFlags\n-                int proxyAttributionFlags, @AttributionFlags int proxiedAttributionFlags,\n-                int attributionChainId, @NonNull DecFunction<Integer, AttributionSource, Boolean,\n+        SyncNotedAppOp startProxyOperation(@NonNull IBinder clientId, int code,\n+                @NonNull AttributionSource attributionSource, boolean startIfModeDefault,\n+                boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n+                boolean skipProxyOperation, @AttributionFlags int proxyAttributionFlags,\n+                @AttributionFlags int proxiedAttributionFlags, int attributionChainId,\n+                @NonNull UndecFunction<IBinder, Integer, AttributionSource, Boolean,\n                         Boolean, String, Boolean, Boolean, Integer, Integer, Integer,\n                         SyncNotedAppOp> superImpl);\n \n@@ -176,10 +176,15 @@ public abstract class AppOpsManagerInternal {\n          *\n          * @param code The op code to finish.\n          * @param attributionSource The permission identity of the caller.\n+         * @param skipProxyOperation Whether to skip the proxy in the proxy/proxied operation\n+         * @param clientId The client calling finishProxyOperation\n+         * @param superImpl The \"standard\" implementation to potentially call\n          */\n-        void finishProxyOperation(int code, @NonNull AttributionSource attributionSource,\n+        void finishProxyOperation(@NonNull IBinder clientId, int code,\n+                @NonNull AttributionSource attributionSource,\n                 boolean skipProxyOperation,\n-                @NonNull TriFunction<Integer, AttributionSource, Boolean, Void> superImpl);\n+                @NonNull QuadFunction<IBinder, Integer, AttributionSource, Boolean,\n+                        Void> superImpl);\n     }\n \n     /**\n",
    "added_lines": 14,
    "deleted_lines": 9,
    "changed_methods": ""
   },
   {
    "filename": "ActivityManagerService.java",
    "diff": "@@ -351,12 +351,10 @@ import com.android.internal.util.FastPrintWriter;\n import com.android.internal.util.FrameworkStatsLog;\n import com.android.internal.util.MemInfoReader;\n import com.android.internal.util.Preconditions;\n-import com.android.internal.util.function.DecFunction;\n import com.android.internal.util.function.HeptFunction;\n import com.android.internal.util.function.HexFunction;\n import com.android.internal.util.function.QuadFunction;\n import com.android.internal.util.function.QuintFunction;\n-import com.android.internal.util.function.TriFunction;\n import com.android.internal.util.function.UndecFunction;\n import com.android.server.AlarmManagerInternal;\n import com.android.server.DeviceIdleInternal;\n@@ -17128,19 +17126,20 @@ public class ActivityManagerService extends IActivityManager.Stub\n         }\n \n         @Override\n-        public SyncNotedAppOp startProxyOperation(int code,\n+        public SyncNotedAppOp startProxyOperation(@NonNull IBinder clientId, int code,\n                 @NonNull AttributionSource attributionSource, boolean startIfModeDefault,\n                 boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n                 boolean skipProxyOperation, @AttributionFlags int proxyAttributionFlags,\n                 @AttributionFlags int proxiedAttributionFlags, int attributionChainId,\n-                @NonNull DecFunction<Integer, AttributionSource, Boolean, Boolean, String, Boolean,\n-                        Boolean, Integer, Integer, Integer, SyncNotedAppOp> superImpl) {\n+                @NonNull UndecFunction<IBinder, Integer, AttributionSource,\n+                        Boolean, Boolean, String, Boolean, Boolean, Integer, Integer, Integer,\n+                        SyncNotedAppOp> superImpl) {\n             if (attributionSource.getUid() == mTargetUid && isTargetOp(code)) {\n                 final int shellUid = UserHandle.getUid(UserHandle.getUserId(\n                         attributionSource.getUid()), Process.SHELL_UID);\n                 final long identity = Binder.clearCallingIdentity();\n                 try {\n-                    return superImpl.apply(code, new AttributionSource(shellUid,\n+                    return superImpl.apply(clientId, code, new AttributionSource(shellUid,\n                             \"com.android.shell\", attributionSource.getAttributionTag(),\n                             attributionSource.getToken(), attributionSource.getNext()),\n                             startIfModeDefault, shouldCollectAsyncNotedOp, message,\n@@ -17150,21 +17149,22 @@ public class ActivityManagerService extends IActivityManager.Stub\n                     Binder.restoreCallingIdentity(identity);\n                 }\n             }\n-            return superImpl.apply(code, attributionSource, startIfModeDefault,\n+            return superImpl.apply(clientId, code, attributionSource, startIfModeDefault,\n                     shouldCollectAsyncNotedOp, message, shouldCollectMessage, skipProxyOperation,\n                     proxyAttributionFlags, proxiedAttributionFlags, attributionChainId);\n         }\n \n         @Override\n-        public void finishProxyOperation(int code, @NonNull AttributionSource attributionSource,\n-                boolean skipProxyOperation, @NonNull TriFunction<Integer, AttributionSource,\n-                        Boolean, Void> superImpl) {\n+        public void finishProxyOperation(@NonNull IBinder clientId, int code,\n+                @NonNull AttributionSource attributionSource, boolean skipProxyOperation,\n+                @NonNull QuadFunction<IBinder, Integer, AttributionSource, Boolean,\n+                        Void> superImpl) {\n             if (attributionSource.getUid() == mTargetUid && isTargetOp(code)) {\n                 final int shellUid = UserHandle.getUid(UserHandle.getUserId(\n                         attributionSource.getUid()), Process.SHELL_UID);\n                 final long identity = Binder.clearCallingIdentity();\n                 try {\n-                    superImpl.apply(code, new AttributionSource(shellUid,\n+                    superImpl.apply(clientId, code, new AttributionSource(shellUid,\n                             \"com.android.shell\", attributionSource.getAttributionTag(),\n                             attributionSource.getToken(), attributionSource.getNext()),\n                             skipProxyOperation);\n@@ -17172,7 +17172,7 @@ public class ActivityManagerService extends IActivityManager.Stub\n                     Binder.restoreCallingIdentity(identity);\n                 }\n             }\n-            superImpl.apply(code, attributionSource, skipProxyOperation);\n+            superImpl.apply(clientId, code, attributionSource, skipProxyOperation);\n         }\n \n         private boolean isTargetOp(int code) {\n",
    "added_lines": 12,
    "deleted_lines": 12,
    "changed_methods": "ActivityManagerService::ShellDelegate::finishProxyOperation, ActivityManagerService::ShellDelegate::startProxyOperation, ActivityManagerService::ShellDelegate::finishProxyOperation, ActivityManagerService::ShellDelegate::startProxyOperation"
   },
   {
    "filename": "AppOpsService.java",
    "diff": "@@ -3839,18 +3839,18 @@ public class AppOpsService extends IAppOpsService.Stub {\n     }\n \n     @Override\n-    public SyncNotedAppOp startProxyOperation(int code,\n+    public SyncNotedAppOp startProxyOperation(@NonNull IBinder clientId, int code,\n             @NonNull AttributionSource attributionSource, boolean startIfModeDefault,\n             boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n             boolean skipProxyOperation, @AttributionFlags int proxyAttributionFlags,\n             @AttributionFlags int proxiedAttributionFlags, int attributionChainId) {\n-        return mCheckOpsDelegateDispatcher.startProxyOperation(code, attributionSource,\n+        return mCheckOpsDelegateDispatcher.startProxyOperation(clientId, code, attributionSource,\n                 startIfModeDefault, shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                 skipProxyOperation, proxyAttributionFlags, proxiedAttributionFlags,\n                 attributionChainId);\n     }\n \n-    private SyncNotedAppOp startProxyOperationImpl(int code,\n+    private SyncNotedAppOp startProxyOperationImpl(@NonNull IBinder clientId, int code,\n             @NonNull AttributionSource attributionSource,\n             boolean startIfModeDefault, boolean shouldCollectAsyncNotedOp, String message,\n             boolean shouldCollectMessage, boolean skipProxyOperation, @AttributionFlags\n@@ -3859,11 +3859,9 @@ public class AppOpsService extends IAppOpsService.Stub {\n         final int proxyUid = attributionSource.getUid();\n         final String proxyPackageName = attributionSource.getPackageName();\n         final String proxyAttributionTag = attributionSource.getAttributionTag();\n-        final IBinder proxyToken = attributionSource.getToken();\n         final int proxiedUid = attributionSource.getNextUid();\n         final String proxiedPackageName = attributionSource.getNextPackageName();\n         final String proxiedAttributionTag = attributionSource.getNextAttributionTag();\n-        final IBinder proxiedToken = attributionSource.getNextToken();\n \n         verifyIncomingProxyUid(attributionSource);\n         verifyIncomingOp(code);\n@@ -3902,7 +3900,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n \n         if (!skipProxyOperation) {\n             // Test if the proxied operation will succeed before starting the proxy operation\n-            final SyncNotedAppOp testProxiedOp = startOperationUnchecked(proxiedToken, code,\n+            final SyncNotedAppOp testProxiedOp = startOperationUnchecked(clientId, code,\n                     proxiedUid, resolvedProxiedPackageName, proxiedAttributionTag, proxyUid,\n                     resolvedProxyPackageName, proxyAttributionTag, proxiedFlags, startIfModeDefault,\n                     shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n@@ -3914,7 +3912,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n             final int proxyFlags = isProxyTrusted ? AppOpsManager.OP_FLAG_TRUSTED_PROXY\n                     : AppOpsManager.OP_FLAG_UNTRUSTED_PROXY;\n \n-            final SyncNotedAppOp proxyAppOp = startOperationUnchecked(proxyToken, code, proxyUid,\n+            final SyncNotedAppOp proxyAppOp = startOperationUnchecked(clientId, code, proxyUid,\n                     resolvedProxyPackageName, proxyAttributionTag, Process.INVALID_UID, null, null,\n                     proxyFlags, startIfModeDefault, !isProxyTrusted, \"proxy \" + message,\n                     shouldCollectMessage, proxyAttributionFlags, attributionChainId,\n@@ -3924,7 +3922,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n             }\n         }\n \n-        return startOperationUnchecked(proxiedToken, code, proxiedUid, resolvedProxiedPackageName,\n+        return startOperationUnchecked(clientId, code, proxiedUid, resolvedProxiedPackageName,\n                 proxiedAttributionTag, proxyUid, resolvedProxyPackageName, proxyAttributionTag,\n                 proxiedFlags, startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                 shouldCollectMessage, proxiedAttributionFlags, attributionChainId,\n@@ -4065,22 +4063,20 @@ public class AppOpsService extends IAppOpsService.Stub {\n     }\n \n     @Override\n-    public void finishProxyOperation(int code, @NonNull AttributionSource attributionSource,\n-            boolean skipProxyOperation) {\n-        mCheckOpsDelegateDispatcher.finishProxyOperation(code, attributionSource,\n+    public void finishProxyOperation(@NonNull IBinder clientId, int code,\n+            @NonNull AttributionSource attributionSource, boolean skipProxyOperation) {\n+        mCheckOpsDelegateDispatcher.finishProxyOperation(clientId, code, attributionSource,\n                 skipProxyOperation);\n     }\n \n-    private Void finishProxyOperationImpl(int code, @NonNull AttributionSource attributionSource,\n-            boolean skipProxyOperation) {\n+    private Void finishProxyOperationImpl(IBinder clientId, int code,\n+            @NonNull AttributionSource attributionSource, boolean skipProxyOperation) {\n         final int proxyUid = attributionSource.getUid();\n         final String proxyPackageName = attributionSource.getPackageName();\n         final String proxyAttributionTag = attributionSource.getAttributionTag();\n-        final IBinder proxyToken = attributionSource.getToken();\n         final int proxiedUid = attributionSource.getNextUid();\n         final String proxiedPackageName = attributionSource.getNextPackageName();\n         final String proxiedAttributionTag = attributionSource.getNextAttributionTag();\n-        final IBinder proxiedToken = attributionSource.getNextToken();\n \n         skipProxyOperation = skipProxyOperation\n                 && isCallerAndAttributionTrusted(attributionSource);\n@@ -4097,7 +4093,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n         }\n \n         if (!skipProxyOperation) {\n-            finishOperationUnchecked(proxyToken, code, proxyUid, resolvedProxyPackageName,\n+            finishOperationUnchecked(clientId, code, proxyUid, resolvedProxyPackageName,\n                     proxyAttributionTag);\n         }\n \n@@ -4107,7 +4103,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n             return null;\n         }\n \n-        finishOperationUnchecked(proxiedToken, code, proxiedUid, resolvedProxiedPackageName,\n+        finishOperationUnchecked(clientId, code, proxiedUid, resolvedProxiedPackageName,\n                 proxiedAttributionTag);\n \n         return null;\n@@ -7642,42 +7638,42 @@ public class AppOpsService extends IAppOpsService.Stub {\n                     attributionFlags, attributionChainId, AppOpsService.this::startOperationImpl);\n         }\n \n-        public SyncNotedAppOp startProxyOperation(int code,\n+        public SyncNotedAppOp startProxyOperation(@NonNull IBinder clientId, int code,\n                 @NonNull AttributionSource attributionSource, boolean startIfModeDefault,\n                 boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n                 boolean skipProxyOperation, @AttributionFlags int proxyAttributionFlags,\n                 @AttributionFlags int proxiedAttributionFlags, int attributionChainId) {\n             if (mPolicy != null) {\n                 if (mCheckOpsDelegate != null) {\n-                    return mPolicy.startProxyOperation(code, attributionSource,\n+                    return mPolicy.startProxyOperation(clientId, code, attributionSource,\n                             startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                             shouldCollectMessage, skipProxyOperation, proxyAttributionFlags,\n                             proxiedAttributionFlags, attributionChainId,\n                             this::startDelegateProxyOperationImpl);\n                 } else {\n-                    return mPolicy.startProxyOperation(code, attributionSource,\n+                    return mPolicy.startProxyOperation(clientId, code, attributionSource,\n                             startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                             shouldCollectMessage, skipProxyOperation, proxyAttributionFlags,\n                             proxiedAttributionFlags, attributionChainId,\n                             AppOpsService.this::startProxyOperationImpl);\n                 }\n             } else if (mCheckOpsDelegate != null) {\n-                return startDelegateProxyOperationImpl(code, attributionSource,\n+                return startDelegateProxyOperationImpl(clientId, code, attributionSource,\n                         startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                         shouldCollectMessage, skipProxyOperation, proxyAttributionFlags,\n                         proxiedAttributionFlags, attributionChainId);\n             }\n-            return startProxyOperationImpl(code, attributionSource, startIfModeDefault,\n+            return startProxyOperationImpl(clientId, code, attributionSource, startIfModeDefault,\n                     shouldCollectAsyncNotedOp, message, shouldCollectMessage, skipProxyOperation,\n                     proxyAttributionFlags, proxiedAttributionFlags, attributionChainId);\n         }\n \n-        private SyncNotedAppOp startDelegateProxyOperationImpl(int code,\n+        private SyncNotedAppOp startDelegateProxyOperationImpl(@NonNull IBinder clientId, int code,\n                 @NonNull AttributionSource attributionSource, boolean startIfModeDefault,\n                 boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n                 boolean skipProxyOperation, @AttributionFlags int proxyAttributionFlags,\n                 @AttributionFlags int proxiedAttributionFlsgs, int attributionChainId) {\n-            return mCheckOpsDelegate.startProxyOperation(code, attributionSource,\n+            return mCheckOpsDelegate.startProxyOperation(clientId, code, attributionSource,\n                     startIfModeDefault, shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                     skipProxyOperation, proxyAttributionFlags, proxiedAttributionFlsgs,\n                     attributionChainId, AppOpsService.this::startProxyOperationImpl);\n@@ -7706,27 +7702,28 @@ public class AppOpsService extends IAppOpsService.Stub {\n                     AppOpsService.this::finishOperationImpl);\n         }\n \n-        public void finishProxyOperation(int code,\n+        public void finishProxyOperation(@NonNull IBinder clientId, int code,\n                 @NonNull AttributionSource attributionSource, boolean skipProxyOperation) {\n             if (mPolicy != null) {\n                 if (mCheckOpsDelegate != null) {\n-                    mPolicy.finishProxyOperation(code, attributionSource,\n+                    mPolicy.finishProxyOperation(clientId, code, attributionSource,\n                             skipProxyOperation, this::finishDelegateProxyOperationImpl);\n                 } else {\n-                    mPolicy.finishProxyOperation(code, attributionSource,\n+                    mPolicy.finishProxyOperation(clientId, code, attributionSource,\n                             skipProxyOperation, AppOpsService.this::finishProxyOperationImpl);\n                 }\n             } else if (mCheckOpsDelegate != null) {\n-                finishDelegateProxyOperationImpl(code, attributionSource, skipProxyOperation);\n+                finishDelegateProxyOperationImpl(clientId, code, attributionSource,\n+                        skipProxyOperation);\n             } else {\n-                finishProxyOperationImpl(code, attributionSource, skipProxyOperation);\n+                finishProxyOperationImpl(clientId, code, attributionSource, skipProxyOperation);\n             }\n         }\n \n-        private Void finishDelegateProxyOperationImpl(int code,\n+        private Void finishDelegateProxyOperationImpl(@NonNull IBinder clientId, int code,\n                 @NonNull AttributionSource attributionSource, boolean skipProxyOperation) {\n-            mCheckOpsDelegate.finishProxyOperation(code, attributionSource, skipProxyOperation,\n-                    AppOpsService.this::finishProxyOperationImpl);\n+            mCheckOpsDelegate.finishProxyOperation(clientId, code, attributionSource,\n+                    skipProxyOperation, AppOpsService.this::finishProxyOperationImpl);\n             return null;\n         }\n     }\n",
    "added_lines": 29,
    "deleted_lines": 32,
    "changed_methods": "AppOpsService::CheckOpsDelegateDispatcher::finishProxyOperation, AppOpsService::finishProxyOperationImpl, AppOpsService::CheckOpsDelegateDispatcher::startDelegateProxyOperationImpl, AppOpsService::CheckOpsDelegateDispatcher::startProxyOperation, AppOpsService::startProxyOperationImpl, AppOpsService::CheckOpsDelegateDispatcher::startProxyOperation, AppOpsService::startProxyOperation, AppOpsService::CheckOpsDelegateDispatcher::startDelegateProxyOperationImpl, AppOpsService::startProxyOperationImpl, AppOpsService::finishProxyOperation, AppOpsService::startProxyOperation, AppOpsService::CheckOpsDelegateDispatcher::finishProxyOperation, AppOpsService::CheckOpsDelegateDispatcher::finishDelegateProxyOperationImpl, AppOpsService::CheckOpsDelegateDispatcher::finishDelegateProxyOperationImpl, AppOpsService::finishProxyOperationImpl, AppOpsService::finishProxyOperation"
   },
   {
    "filename": "PermissionManagerService.java",
    "diff": "@@ -5650,7 +5650,7 @@ public class PermissionManagerService extends IPermissionManager.Stub {\n                     if (resolvedPackageName == null) {\n                         return;\n                     }\n-                    appOpsManager.finishOp(accessorSource.getToken(), op,\n+                    appOpsManager.finishOp(attributionSourceState.token, op,\n                             accessorSource.getUid(), resolvedPackageName,\n                             accessorSource.getAttributionTag());\n                 } else {\n@@ -5659,8 +5659,9 @@ public class PermissionManagerService extends IPermissionManager.Stub {\n                     if (resolvedAttributionSource.getPackageName() == null) {\n                         return;\n                     }\n-                    appOpsManager.finishProxyOp(AppOpsManager.opToPublicName(op),\n-                            resolvedAttributionSource, skipCurrentFinish);\n+                    appOpsManager.finishProxyOp(attributionSourceState.token,\n+                            AppOpsManager.opToPublicName(op), resolvedAttributionSource,\n+                            skipCurrentFinish);\n                 }\n \n                 if (next == null || next.getNext() == null) {\n@@ -5770,10 +5771,11 @@ public class PermissionManagerService extends IPermissionManager.Stub {\n                         && next.getNext() == null);\n                 final boolean selfAccess = singleReceiverFromDatasource || next == null;\n \n-                final int opMode = performOpTransaction(context, op, current, message,\n-                        forDataDelivery, /*startDataDelivery*/ false, skipCurrentChecks,\n-                        selfAccess, singleReceiverFromDatasource, AppOpsManager.OP_NONE,\n-                        AppOpsManager.ATTRIBUTION_FLAGS_NONE, AppOpsManager.ATTRIBUTION_FLAGS_NONE,\n+                final int opMode = performOpTransaction(context, attributionSource.getToken(), op,\n+                        current, message, forDataDelivery, /*startDataDelivery*/ false,\n+                        skipCurrentChecks, selfAccess, singleReceiverFromDatasource,\n+                        AppOpsManager.OP_NONE, AppOpsManager.ATTRIBUTION_FLAGS_NONE,\n+                        AppOpsManager.ATTRIBUTION_FLAGS_NONE,\n                         AppOpsManager.ATTRIBUTION_CHAIN_ID_NONE);\n \n                 switch (opMode) {\n@@ -5875,10 +5877,10 @@ public class PermissionManagerService extends IPermissionManager.Stub {\n                         attributionSource, next, fromDatasource, startDataDelivery, selfAccess,\n                         isLinkTrusted) : ATTRIBUTION_FLAGS_NONE;\n \n-                final int opMode = performOpTransaction(context, op, current, message,\n-                        forDataDelivery, startDataDelivery, skipCurrentChecks, selfAccess,\n-                        singleReceiverFromDatasource, attributedOp, proxyAttributionFlags,\n-                        proxiedAttributionFlags, attributionChainId);\n+                final int opMode = performOpTransaction(context, attributionSource.getToken(), op,\n+                        current, message, forDataDelivery, startDataDelivery, skipCurrentChecks,\n+                        selfAccess, singleReceiverFromDatasource, attributedOp,\n+                        proxyAttributionFlags, proxiedAttributionFlags, attributionChainId);\n \n                 switch (opMode) {\n                     case AppOpsManager.MODE_ERRORED: {\n@@ -6023,8 +6025,8 @@ public class PermissionManagerService extends IPermissionManager.Stub {\n                         attributionSource, next, /*fromDatasource*/ false, startDataDelivery,\n                         selfAccess, isLinkTrusted) : ATTRIBUTION_FLAGS_NONE;\n \n-                final int opMode = performOpTransaction(context, op, current, message,\n-                        forDataDelivery, startDataDelivery, skipCurrentChecks, selfAccess,\n+                final int opMode = performOpTransaction(context, current.getToken(), op, current,\n+                        message, forDataDelivery, startDataDelivery, skipCurrentChecks, selfAccess,\n                         /*fromDatasource*/ false, AppOpsManager.OP_NONE, proxyAttributionFlags,\n                         proxiedAttributionFlags, attributionChainId);\n \n@@ -6046,7 +6048,8 @@ public class PermissionManagerService extends IPermissionManager.Stub {\n         }\n \n         @SuppressWarnings(\"ConstantConditions\")\n-        private static int performOpTransaction(@NonNull Context context, int op,\n+        private static int performOpTransaction(@NonNull Context context,\n+                @NonNull IBinder chainStartToken, int op,\n                 @NonNull AttributionSource attributionSource, @Nullable String message,\n                 boolean forDataDelivery, boolean startDataDelivery, boolean skipProxyOperation,\n                 boolean selfAccess, boolean singleReceiverFromDatasource, int attributedOp,\n@@ -6108,7 +6111,7 @@ public class PermissionManagerService extends IPermissionManager.Stub {\n                 if (selfAccess) {\n                     try {\n                         startedOpResult = appOpsManager.startOpNoThrow(\n-                                resolvedAttributionSource.getToken(), startedOp,\n+                                chainStartToken, startedOp,\n                                 resolvedAttributionSource.getUid(),\n                                 resolvedAttributionSource.getPackageName(),\n                                 /*startIfModeDefault*/ false,\n@@ -6119,12 +6122,12 @@ public class PermissionManagerService extends IPermissionManager.Stub {\n                                 + \" platform defined runtime permission \"\n                                 + AppOpsManager.opToPermission(op) + \" while not having \"\n                                 + Manifest.permission.UPDATE_APP_OPS_STATS);\n-                        startedOpResult = appOpsManager.startProxyOpNoThrow(attributedOp,\n-                                attributionSource, message, skipProxyOperation,\n+                        startedOpResult = appOpsManager.startProxyOpNoThrow(chainStartToken,\n+                                attributedOp, attributionSource, message, skipProxyOperation,\n                                 proxyAttributionFlags, proxiedAttributionFlags, attributionChainId);\n                     }\n                 } else {\n-                    startedOpResult = appOpsManager.startProxyOpNoThrow(startedOp,\n+                    startedOpResult = appOpsManager.startProxyOpNoThrow(chainStartToken, startedOp,\n                             resolvedAttributionSource, message, skipProxyOperation,\n                             proxyAttributionFlags, proxiedAttributionFlags, attributionChainId);\n                 }\n",
    "added_lines": 21,
    "deleted_lines": 18,
    "changed_methods": "PermissionManagerService::PermissionCheckerService::finishDataDelivery, PermissionManagerService::PermissionCheckerService::checkRuntimePermission, PermissionManagerService::PermissionCheckerService::checkAppOpPermission, PermissionManagerService::PermissionCheckerService::performOpTransaction, PermissionManagerService::PermissionCheckerService::checkOp, PermissionManagerService::PermissionCheckerService::performOpTransaction"
   },
   {
    "filename": "AppOpsPolicy.java",
    "diff": "@@ -44,13 +44,11 @@ import android.util.Log;\n import android.util.SparseArray;\n \n import com.android.internal.annotations.GuardedBy;\n-import com.android.internal.util.function.DecFunction;\n import com.android.internal.util.function.HeptFunction;\n import com.android.internal.util.function.HexFunction;\n import com.android.internal.util.function.QuadFunction;\n import com.android.internal.util.function.QuintConsumer;\n import com.android.internal.util.function.QuintFunction;\n-import com.android.internal.util.function.TriFunction;\n import com.android.internal.util.function.UndecFunction;\n import com.android.server.LocalServices;\n \n@@ -255,14 +253,14 @@ public final class AppOpsPolicy implements AppOpsManagerInternal.CheckOpsDelegat\n     }\n \n     @Override\n-    public SyncNotedAppOp startProxyOperation(int code,\n+    public SyncNotedAppOp startProxyOperation(@NonNull IBinder clientId, int code,\n             @NonNull AttributionSource attributionSource, boolean startIfModeDefault,\n             boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n             boolean skipProxyOperation, @AttributionFlags int proxyAttributionFlags,\n             @AttributionFlags int proxiedAttributionFlags, int attributionChainId,\n-            @NonNull DecFunction<Integer, AttributionSource, Boolean, Boolean, String, Boolean,\n-                    Boolean, Integer, Integer, Integer, SyncNotedAppOp> superImpl) {\n-        return superImpl.apply(resolveDatasourceOp(code, attributionSource.getUid(),\n+            @NonNull UndecFunction<IBinder, Integer, AttributionSource, Boolean, Boolean, String,\n+                    Boolean, Boolean, Integer, Integer, Integer, SyncNotedAppOp> superImpl) {\n+        return superImpl.apply(clientId, resolveDatasourceOp(code, attributionSource.getUid(),\n                 attributionSource.getPackageName(), attributionSource.getAttributionTag()),\n                 attributionSource, startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                 shouldCollectMessage, skipProxyOperation, proxyAttributionFlags,\n@@ -278,10 +276,10 @@ public final class AppOpsPolicy implements AppOpsManagerInternal.CheckOpsDelegat\n     }\n \n     @Override\n-    public void finishProxyOperation(int code, @NonNull AttributionSource attributionSource,\n-            boolean skipProxyOperation, @NonNull TriFunction<Integer, AttributionSource,\n-            Boolean, Void> superImpl) {\n-        superImpl.apply(resolveDatasourceOp(code, attributionSource.getUid(),\n+    public void finishProxyOperation(@NonNull IBinder clientId, int code,\n+            @NonNull AttributionSource attributionSource, boolean skipProxyOperation,\n+            @NonNull QuadFunction<IBinder, Integer, AttributionSource, Boolean, Void> superImpl) {\n+        superImpl.apply(clientId, resolveDatasourceOp(code, attributionSource.getUid(),\n                 attributionSource.getPackageName(), attributionSource.getAttributionTag()),\n                 attributionSource, skipProxyOperation);\n     }\n",
    "added_lines": 8,
    "deleted_lines": 10,
    "changed_methods": "AppOpsPolicy::startProxyOperation, AppOpsPolicy::finishProxyOperation, AppOpsPolicy::finishProxyOperation, AppOpsPolicy::startProxyOperation"
   }
  ]
 },
 {
  "hash": "693e82f72cdf40d65a151c24e9168f345ee551af",
  "commit": "RESTRICT AUTOMERGE Use chain start token in performOpTransaction\n\nBug: 258672042\nTest: atest CtsPermission4TestCases\nChange-Id: I1d484ed7c72d4ae73f4cbec47522a18ae9088f6e\n(cherry picked from commit 9d09846798bce7253ed1202adb61257d4eefbd1d)\nMerged-In: I1d484ed7c72d4ae73f4cbec47522a18ae9088f6e",
  "files": [
   {
    "filename": "AppOpsManager.java",
    "diff": "@@ -8888,8 +8888,9 @@ public class AppOpsManager {\n      */\n     public int startProxyOpNoThrow(int op, @NonNull AttributionSource attributionSource,\n             @Nullable String message, boolean skipProxyOperation) {\n-        return startProxyOpNoThrow(op, attributionSource, message, skipProxyOperation,\n-                ATTRIBUTION_FLAGS_NONE, ATTRIBUTION_FLAGS_NONE, ATTRIBUTION_CHAIN_ID_NONE);\n+        return startProxyOpNoThrow(attributionSource.getToken(), op, attributionSource, message,\n+                skipProxyOperation, ATTRIBUTION_FLAGS_NONE, ATTRIBUTION_FLAGS_NONE,\n+                ATTRIBUTION_CHAIN_ID_NONE);\n     }\n \n     /**\n@@ -8901,7 +8902,8 @@ public class AppOpsManager {\n      *\n      * @hide\n      */\n-    public int startProxyOpNoThrow(int op, @NonNull AttributionSource attributionSource,\n+    public int startProxyOpNoThrow(@NonNull IBinder clientId, int op,\n+            @NonNull AttributionSource attributionSource,\n             @Nullable String message, boolean skipProxyOperation, @AttributionFlags\n             int proxyAttributionFlags, @AttributionFlags int proxiedAttributionFlags,\n             int attributionChainId) {\n@@ -8919,7 +8921,7 @@ public class AppOpsManager {\n                 }\n             }\n \n-            SyncNotedAppOp syncOp = mService.startProxyOperation(op,\n+            SyncNotedAppOp syncOp = mService.startProxyOperation(clientId, op,\n                     attributionSource, false, collectionMode == COLLECT_ASYNC, message,\n                     shouldCollectMessage, skipProxyOperation, proxyAttributionFlags,\n                     proxiedAttributionFlags, attributionChainId);\n@@ -9017,9 +9019,10 @@ public class AppOpsManager {\n      */\n     public void finishProxyOp(@NonNull String op, int proxiedUid,\n             @NonNull String proxiedPackageName, @Nullable String proxiedAttributionTag) {\n-        finishProxyOp(op, new AttributionSource(mContext.getAttributionSource(),\n+        IBinder token = mContext.getAttributionSource().getToken();\n+        finishProxyOp(token, op, new AttributionSource(mContext.getAttributionSource(),\n                 new AttributionSource(proxiedUid, proxiedPackageName,  proxiedAttributionTag,\n-                        mContext.getAttributionSource().getToken())), /*skipProxyOperation*/ false);\n+                        token)), /*skipProxyOperation*/ false);\n     }\n \n     /**\n@@ -9034,10 +9037,11 @@ public class AppOpsManager {\n      *\n      * @hide\n      */\n-    public void finishProxyOp(@NonNull String op, @NonNull AttributionSource attributionSource,\n-            boolean skipProxyOperation) {\n+    public void finishProxyOp(@NonNull IBinder clientId, @NonNull String op,\n+            @NonNull AttributionSource attributionSource, boolean skipProxyOperation) {\n         try {\n-            mService.finishProxyOperation(strOpToOp(op), attributionSource, skipProxyOperation);\n+            mService.finishProxyOperation(clientId, strOpToOp(op), attributionSource,\n+                    skipProxyOperation);\n         } catch (RemoteException e) {\n             throw e.rethrowFromSystemServer();\n         }\n",
    "added_lines": 13,
    "deleted_lines": 9,
    "changed_methods": "AppOpsManager::startProxyOpNoThrow, AppOpsManager::startProxyOpNoThrow, AppOpsManager::startProxyOpNoThrow, AppOpsManager::finishProxyOp, AppOpsManager::finishProxyOp, AppOpsManager::finishProxyOp"
   },
   {
    "filename": "AppOpsManagerInternal.java",
    "diff": "@@ -26,13 +26,11 @@ import android.util.SparseArray;\n import android.util.SparseIntArray;\n \n import com.android.internal.app.IAppOpsCallback;\n-import com.android.internal.util.function.DecFunction;\n import com.android.internal.util.function.HeptFunction;\n import com.android.internal.util.function.HexFunction;\n import com.android.internal.util.function.QuadFunction;\n import com.android.internal.util.function.QuintConsumer;\n import com.android.internal.util.function.QuintFunction;\n-import com.android.internal.util.function.TriFunction;\n import com.android.internal.util.function.UndecFunction;\n \n /**\n@@ -135,6 +133,7 @@ public abstract class AppOpsManagerInternal {\n         /**\n          * Allows overriding start proxy operation behavior.\n          *\n+         * @param clientId The client calling start, represented by an IBinder\n          * @param code The op code to start.\n          * @param attributionSource The permission identity of the caller.\n          * @param startIfModeDefault Whether to start the op of the mode is default.\n@@ -148,11 +147,12 @@ public abstract class AppOpsManagerInternal {\n          * @param superImpl The super implementation.\n          * @return The app op note result.\n          */\n-        SyncNotedAppOp startProxyOperation(int code, @NonNull AttributionSource attributionSource,\n-                boolean startIfModeDefault, boolean shouldCollectAsyncNotedOp, String message,\n-                boolean shouldCollectMessage, boolean skipProxyOperation, @AttributionFlags\n-                int proxyAttributionFlags, @AttributionFlags int proxiedAttributionFlags,\n-                int attributionChainId, @NonNull DecFunction<Integer, AttributionSource, Boolean,\n+        SyncNotedAppOp startProxyOperation(@NonNull IBinder clientId, int code,\n+                @NonNull AttributionSource attributionSource, boolean startIfModeDefault,\n+                boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n+                boolean skipProxyOperation, @AttributionFlags int proxyAttributionFlags,\n+                @AttributionFlags int proxiedAttributionFlags, int attributionChainId,\n+                @NonNull UndecFunction<IBinder, Integer, AttributionSource, Boolean,\n                         Boolean, String, Boolean, Boolean, Integer, Integer, Integer,\n                         SyncNotedAppOp> superImpl);\n \n@@ -176,10 +176,15 @@ public abstract class AppOpsManagerInternal {\n          *\n          * @param code The op code to finish.\n          * @param attributionSource The permission identity of the caller.\n+         * @param skipProxyOperation Whether to skip the proxy in the proxy/proxied operation\n+         * @param clientId The client calling finishProxyOperation\n+         * @param superImpl The \"standard\" implementation to potentially call\n          */\n-        void finishProxyOperation(int code, @NonNull AttributionSource attributionSource,\n+        void finishProxyOperation(@NonNull IBinder clientId, int code,\n+                @NonNull AttributionSource attributionSource,\n                 boolean skipProxyOperation,\n-                @NonNull TriFunction<Integer, AttributionSource, Boolean, Void> superImpl);\n+                @NonNull QuadFunction<IBinder, Integer, AttributionSource, Boolean,\n+                        Void> superImpl);\n     }\n \n     /**\n",
    "added_lines": 14,
    "deleted_lines": 9,
    "changed_methods": ""
   },
   {
    "filename": "ActivityManagerService.java",
    "diff": "@@ -351,12 +351,10 @@ import com.android.internal.util.FastPrintWriter;\n import com.android.internal.util.FrameworkStatsLog;\n import com.android.internal.util.MemInfoReader;\n import com.android.internal.util.Preconditions;\n-import com.android.internal.util.function.DecFunction;\n import com.android.internal.util.function.HeptFunction;\n import com.android.internal.util.function.HexFunction;\n import com.android.internal.util.function.QuadFunction;\n import com.android.internal.util.function.QuintFunction;\n-import com.android.internal.util.function.TriFunction;\n import com.android.internal.util.function.UndecFunction;\n import com.android.server.AlarmManagerInternal;\n import com.android.server.DeviceIdleInternal;\n@@ -17128,19 +17126,20 @@ public class ActivityManagerService extends IActivityManager.Stub\n         }\n \n         @Override\n-        public SyncNotedAppOp startProxyOperation(int code,\n+        public SyncNotedAppOp startProxyOperation(@NonNull IBinder clientId, int code,\n                 @NonNull AttributionSource attributionSource, boolean startIfModeDefault,\n                 boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n                 boolean skipProxyOperation, @AttributionFlags int proxyAttributionFlags,\n                 @AttributionFlags int proxiedAttributionFlags, int attributionChainId,\n-                @NonNull DecFunction<Integer, AttributionSource, Boolean, Boolean, String, Boolean,\n-                        Boolean, Integer, Integer, Integer, SyncNotedAppOp> superImpl) {\n+                @NonNull UndecFunction<IBinder, Integer, AttributionSource,\n+                        Boolean, Boolean, String, Boolean, Boolean, Integer, Integer, Integer,\n+                        SyncNotedAppOp> superImpl) {\n             if (attributionSource.getUid() == mTargetUid && isTargetOp(code)) {\n                 final int shellUid = UserHandle.getUid(UserHandle.getUserId(\n                         attributionSource.getUid()), Process.SHELL_UID);\n                 final long identity = Binder.clearCallingIdentity();\n                 try {\n-                    return superImpl.apply(code, new AttributionSource(shellUid,\n+                    return superImpl.apply(clientId, code, new AttributionSource(shellUid,\n                             \"com.android.shell\", attributionSource.getAttributionTag(),\n                             attributionSource.getToken(), attributionSource.getNext()),\n                             startIfModeDefault, shouldCollectAsyncNotedOp, message,\n@@ -17150,21 +17149,22 @@ public class ActivityManagerService extends IActivityManager.Stub\n                     Binder.restoreCallingIdentity(identity);\n                 }\n             }\n-            return superImpl.apply(code, attributionSource, startIfModeDefault,\n+            return superImpl.apply(clientId, code, attributionSource, startIfModeDefault,\n                     shouldCollectAsyncNotedOp, message, shouldCollectMessage, skipProxyOperation,\n                     proxyAttributionFlags, proxiedAttributionFlags, attributionChainId);\n         }\n \n         @Override\n-        public void finishProxyOperation(int code, @NonNull AttributionSource attributionSource,\n-                boolean skipProxyOperation, @NonNull TriFunction<Integer, AttributionSource,\n-                        Boolean, Void> superImpl) {\n+        public void finishProxyOperation(@NonNull IBinder clientId, int code,\n+                @NonNull AttributionSource attributionSource, boolean skipProxyOperation,\n+                @NonNull QuadFunction<IBinder, Integer, AttributionSource, Boolean,\n+                        Void> superImpl) {\n             if (attributionSource.getUid() == mTargetUid && isTargetOp(code)) {\n                 final int shellUid = UserHandle.getUid(UserHandle.getUserId(\n                         attributionSource.getUid()), Process.SHELL_UID);\n                 final long identity = Binder.clearCallingIdentity();\n                 try {\n-                    superImpl.apply(code, new AttributionSource(shellUid,\n+                    superImpl.apply(clientId, code, new AttributionSource(shellUid,\n                             \"com.android.shell\", attributionSource.getAttributionTag(),\n                             attributionSource.getToken(), attributionSource.getNext()),\n                             skipProxyOperation);\n@@ -17172,7 +17172,7 @@ public class ActivityManagerService extends IActivityManager.Stub\n                     Binder.restoreCallingIdentity(identity);\n                 }\n             }\n-            superImpl.apply(code, attributionSource, skipProxyOperation);\n+            superImpl.apply(clientId, code, attributionSource, skipProxyOperation);\n         }\n \n         private boolean isTargetOp(int code) {\n",
    "added_lines": 12,
    "deleted_lines": 12,
    "changed_methods": "ActivityManagerService::ShellDelegate::finishProxyOperation, ActivityManagerService::ShellDelegate::startProxyOperation, ActivityManagerService::ShellDelegate::finishProxyOperation, ActivityManagerService::ShellDelegate::startProxyOperation"
   },
   {
    "filename": "AppOpsService.java",
    "diff": "@@ -3839,18 +3839,18 @@ public class AppOpsService extends IAppOpsService.Stub {\n     }\n \n     @Override\n-    public SyncNotedAppOp startProxyOperation(int code,\n+    public SyncNotedAppOp startProxyOperation(@NonNull IBinder clientId, int code,\n             @NonNull AttributionSource attributionSource, boolean startIfModeDefault,\n             boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n             boolean skipProxyOperation, @AttributionFlags int proxyAttributionFlags,\n             @AttributionFlags int proxiedAttributionFlags, int attributionChainId) {\n-        return mCheckOpsDelegateDispatcher.startProxyOperation(code, attributionSource,\n+        return mCheckOpsDelegateDispatcher.startProxyOperation(clientId, code, attributionSource,\n                 startIfModeDefault, shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                 skipProxyOperation, proxyAttributionFlags, proxiedAttributionFlags,\n                 attributionChainId);\n     }\n \n-    private SyncNotedAppOp startProxyOperationImpl(int code,\n+    private SyncNotedAppOp startProxyOperationImpl(@NonNull IBinder clientId, int code,\n             @NonNull AttributionSource attributionSource,\n             boolean startIfModeDefault, boolean shouldCollectAsyncNotedOp, String message,\n             boolean shouldCollectMessage, boolean skipProxyOperation, @AttributionFlags\n@@ -3859,11 +3859,9 @@ public class AppOpsService extends IAppOpsService.Stub {\n         final int proxyUid = attributionSource.getUid();\n         final String proxyPackageName = attributionSource.getPackageName();\n         final String proxyAttributionTag = attributionSource.getAttributionTag();\n-        final IBinder proxyToken = attributionSource.getToken();\n         final int proxiedUid = attributionSource.getNextUid();\n         final String proxiedPackageName = attributionSource.getNextPackageName();\n         final String proxiedAttributionTag = attributionSource.getNextAttributionTag();\n-        final IBinder proxiedToken = attributionSource.getNextToken();\n \n         verifyIncomingProxyUid(attributionSource);\n         verifyIncomingOp(code);\n@@ -3902,7 +3900,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n \n         if (!skipProxyOperation) {\n             // Test if the proxied operation will succeed before starting the proxy operation\n-            final SyncNotedAppOp testProxiedOp = startOperationUnchecked(proxiedToken, code,\n+            final SyncNotedAppOp testProxiedOp = startOperationUnchecked(clientId, code,\n                     proxiedUid, resolvedProxiedPackageName, proxiedAttributionTag, proxyUid,\n                     resolvedProxyPackageName, proxyAttributionTag, proxiedFlags, startIfModeDefault,\n                     shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n@@ -3914,7 +3912,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n             final int proxyFlags = isProxyTrusted ? AppOpsManager.OP_FLAG_TRUSTED_PROXY\n                     : AppOpsManager.OP_FLAG_UNTRUSTED_PROXY;\n \n-            final SyncNotedAppOp proxyAppOp = startOperationUnchecked(proxyToken, code, proxyUid,\n+            final SyncNotedAppOp proxyAppOp = startOperationUnchecked(clientId, code, proxyUid,\n                     resolvedProxyPackageName, proxyAttributionTag, Process.INVALID_UID, null, null,\n                     proxyFlags, startIfModeDefault, !isProxyTrusted, \"proxy \" + message,\n                     shouldCollectMessage, proxyAttributionFlags, attributionChainId,\n@@ -3924,7 +3922,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n             }\n         }\n \n-        return startOperationUnchecked(proxiedToken, code, proxiedUid, resolvedProxiedPackageName,\n+        return startOperationUnchecked(clientId, code, proxiedUid, resolvedProxiedPackageName,\n                 proxiedAttributionTag, proxyUid, resolvedProxyPackageName, proxyAttributionTag,\n                 proxiedFlags, startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                 shouldCollectMessage, proxiedAttributionFlags, attributionChainId,\n@@ -4065,22 +4063,20 @@ public class AppOpsService extends IAppOpsService.Stub {\n     }\n \n     @Override\n-    public void finishProxyOperation(int code, @NonNull AttributionSource attributionSource,\n-            boolean skipProxyOperation) {\n-        mCheckOpsDelegateDispatcher.finishProxyOperation(code, attributionSource,\n+    public void finishProxyOperation(@NonNull IBinder clientId, int code,\n+            @NonNull AttributionSource attributionSource, boolean skipProxyOperation) {\n+        mCheckOpsDelegateDispatcher.finishProxyOperation(clientId, code, attributionSource,\n                 skipProxyOperation);\n     }\n \n-    private Void finishProxyOperationImpl(int code, @NonNull AttributionSource attributionSource,\n-            boolean skipProxyOperation) {\n+    private Void finishProxyOperationImpl(IBinder clientId, int code,\n+            @NonNull AttributionSource attributionSource, boolean skipProxyOperation) {\n         final int proxyUid = attributionSource.getUid();\n         final String proxyPackageName = attributionSource.getPackageName();\n         final String proxyAttributionTag = attributionSource.getAttributionTag();\n-        final IBinder proxyToken = attributionSource.getToken();\n         final int proxiedUid = attributionSource.getNextUid();\n         final String proxiedPackageName = attributionSource.getNextPackageName();\n         final String proxiedAttributionTag = attributionSource.getNextAttributionTag();\n-        final IBinder proxiedToken = attributionSource.getNextToken();\n \n         skipProxyOperation = skipProxyOperation\n                 && isCallerAndAttributionTrusted(attributionSource);\n@@ -4097,7 +4093,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n         }\n \n         if (!skipProxyOperation) {\n-            finishOperationUnchecked(proxyToken, code, proxyUid, resolvedProxyPackageName,\n+            finishOperationUnchecked(clientId, code, proxyUid, resolvedProxyPackageName,\n                     proxyAttributionTag);\n         }\n \n@@ -4107,7 +4103,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n             return null;\n         }\n \n-        finishOperationUnchecked(proxiedToken, code, proxiedUid, resolvedProxiedPackageName,\n+        finishOperationUnchecked(clientId, code, proxiedUid, resolvedProxiedPackageName,\n                 proxiedAttributionTag);\n \n         return null;\n@@ -7642,42 +7638,42 @@ public class AppOpsService extends IAppOpsService.Stub {\n                     attributionFlags, attributionChainId, AppOpsService.this::startOperationImpl);\n         }\n \n-        public SyncNotedAppOp startProxyOperation(int code,\n+        public SyncNotedAppOp startProxyOperation(@NonNull IBinder clientId, int code,\n                 @NonNull AttributionSource attributionSource, boolean startIfModeDefault,\n                 boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n                 boolean skipProxyOperation, @AttributionFlags int proxyAttributionFlags,\n                 @AttributionFlags int proxiedAttributionFlags, int attributionChainId) {\n             if (mPolicy != null) {\n                 if (mCheckOpsDelegate != null) {\n-                    return mPolicy.startProxyOperation(code, attributionSource,\n+                    return mPolicy.startProxyOperation(clientId, code, attributionSource,\n                             startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                             shouldCollectMessage, skipProxyOperation, proxyAttributionFlags,\n                             proxiedAttributionFlags, attributionChainId,\n                             this::startDelegateProxyOperationImpl);\n                 } else {\n-                    return mPolicy.startProxyOperation(code, attributionSource,\n+                    return mPolicy.startProxyOperation(clientId, code, attributionSource,\n                             startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                             shouldCollectMessage, skipProxyOperation, proxyAttributionFlags,\n                             proxiedAttributionFlags, attributionChainId,\n                             AppOpsService.this::startProxyOperationImpl);\n                 }\n             } else if (mCheckOpsDelegate != null) {\n-                return startDelegateProxyOperationImpl(code, attributionSource,\n+                return startDelegateProxyOperationImpl(clientId, code, attributionSource,\n                         startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                         shouldCollectMessage, skipProxyOperation, proxyAttributionFlags,\n                         proxiedAttributionFlags, attributionChainId);\n             }\n-            return startProxyOperationImpl(code, attributionSource, startIfModeDefault,\n+            return startProxyOperationImpl(clientId, code, attributionSource, startIfModeDefault,\n                     shouldCollectAsyncNotedOp, message, shouldCollectMessage, skipProxyOperation,\n                     proxyAttributionFlags, proxiedAttributionFlags, attributionChainId);\n         }\n \n-        private SyncNotedAppOp startDelegateProxyOperationImpl(int code,\n+        private SyncNotedAppOp startDelegateProxyOperationImpl(@NonNull IBinder clientId, int code,\n                 @NonNull AttributionSource attributionSource, boolean startIfModeDefault,\n                 boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n                 boolean skipProxyOperation, @AttributionFlags int proxyAttributionFlags,\n                 @AttributionFlags int proxiedAttributionFlsgs, int attributionChainId) {\n-            return mCheckOpsDelegate.startProxyOperation(code, attributionSource,\n+            return mCheckOpsDelegate.startProxyOperation(clientId, code, attributionSource,\n                     startIfModeDefault, shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                     skipProxyOperation, proxyAttributionFlags, proxiedAttributionFlsgs,\n                     attributionChainId, AppOpsService.this::startProxyOperationImpl);\n@@ -7706,27 +7702,28 @@ public class AppOpsService extends IAppOpsService.Stub {\n                     AppOpsService.this::finishOperationImpl);\n         }\n \n-        public void finishProxyOperation(int code,\n+        public void finishProxyOperation(@NonNull IBinder clientId, int code,\n                 @NonNull AttributionSource attributionSource, boolean skipProxyOperation) {\n             if (mPolicy != null) {\n                 if (mCheckOpsDelegate != null) {\n-                    mPolicy.finishProxyOperation(code, attributionSource,\n+                    mPolicy.finishProxyOperation(clientId, code, attributionSource,\n                             skipProxyOperation, this::finishDelegateProxyOperationImpl);\n                 } else {\n-                    mPolicy.finishProxyOperation(code, attributionSource,\n+                    mPolicy.finishProxyOperation(clientId, code, attributionSource,\n                             skipProxyOperation, AppOpsService.this::finishProxyOperationImpl);\n                 }\n             } else if (mCheckOpsDelegate != null) {\n-                finishDelegateProxyOperationImpl(code, attributionSource, skipProxyOperation);\n+                finishDelegateProxyOperationImpl(clientId, code, attributionSource,\n+                        skipProxyOperation);\n             } else {\n-                finishProxyOperationImpl(code, attributionSource, skipProxyOperation);\n+                finishProxyOperationImpl(clientId, code, attributionSource, skipProxyOperation);\n             }\n         }\n \n-        private Void finishDelegateProxyOperationImpl(int code,\n+        private Void finishDelegateProxyOperationImpl(@NonNull IBinder clientId, int code,\n                 @NonNull AttributionSource attributionSource, boolean skipProxyOperation) {\n-            mCheckOpsDelegate.finishProxyOperation(code, attributionSource, skipProxyOperation,\n-                    AppOpsService.this::finishProxyOperationImpl);\n+            mCheckOpsDelegate.finishProxyOperation(clientId, code, attributionSource,\n+                    skipProxyOperation, AppOpsService.this::finishProxyOperationImpl);\n             return null;\n         }\n     }\n",
    "added_lines": 29,
    "deleted_lines": 32,
    "changed_methods": "AppOpsService::CheckOpsDelegateDispatcher::finishProxyOperation, AppOpsService::finishProxyOperationImpl, AppOpsService::CheckOpsDelegateDispatcher::startDelegateProxyOperationImpl, AppOpsService::CheckOpsDelegateDispatcher::startProxyOperation, AppOpsService::startProxyOperationImpl, AppOpsService::CheckOpsDelegateDispatcher::startProxyOperation, AppOpsService::startProxyOperation, AppOpsService::CheckOpsDelegateDispatcher::startDelegateProxyOperationImpl, AppOpsService::startProxyOperationImpl, AppOpsService::finishProxyOperation, AppOpsService::startProxyOperation, AppOpsService::CheckOpsDelegateDispatcher::finishProxyOperation, AppOpsService::CheckOpsDelegateDispatcher::finishDelegateProxyOperationImpl, AppOpsService::CheckOpsDelegateDispatcher::finishDelegateProxyOperationImpl, AppOpsService::finishProxyOperationImpl, AppOpsService::finishProxyOperation"
   },
   {
    "filename": "PermissionManagerService.java",
    "diff": "@@ -5650,7 +5650,7 @@ public class PermissionManagerService extends IPermissionManager.Stub {\n                     if (resolvedPackageName == null) {\n                         return;\n                     }\n-                    appOpsManager.finishOp(accessorSource.getToken(), op,\n+                    appOpsManager.finishOp(attributionSourceState.token, op,\n                             accessorSource.getUid(), resolvedPackageName,\n                             accessorSource.getAttributionTag());\n                 } else {\n@@ -5659,8 +5659,9 @@ public class PermissionManagerService extends IPermissionManager.Stub {\n                     if (resolvedAttributionSource.getPackageName() == null) {\n                         return;\n                     }\n-                    appOpsManager.finishProxyOp(AppOpsManager.opToPublicName(op),\n-                            resolvedAttributionSource, skipCurrentFinish);\n+                    appOpsManager.finishProxyOp(attributionSourceState.token,\n+                            AppOpsManager.opToPublicName(op), resolvedAttributionSource,\n+                            skipCurrentFinish);\n                 }\n \n                 if (next == null || next.getNext() == null) {\n@@ -5770,10 +5771,11 @@ public class PermissionManagerService extends IPermissionManager.Stub {\n                         && next.getNext() == null);\n                 final boolean selfAccess = singleReceiverFromDatasource || next == null;\n \n-                final int opMode = performOpTransaction(context, op, current, message,\n-                        forDataDelivery, /*startDataDelivery*/ false, skipCurrentChecks,\n-                        selfAccess, singleReceiverFromDatasource, AppOpsManager.OP_NONE,\n-                        AppOpsManager.ATTRIBUTION_FLAGS_NONE, AppOpsManager.ATTRIBUTION_FLAGS_NONE,\n+                final int opMode = performOpTransaction(context, attributionSource.getToken(), op,\n+                        current, message, forDataDelivery, /*startDataDelivery*/ false,\n+                        skipCurrentChecks, selfAccess, singleReceiverFromDatasource,\n+                        AppOpsManager.OP_NONE, AppOpsManager.ATTRIBUTION_FLAGS_NONE,\n+                        AppOpsManager.ATTRIBUTION_FLAGS_NONE,\n                         AppOpsManager.ATTRIBUTION_CHAIN_ID_NONE);\n \n                 switch (opMode) {\n@@ -5875,10 +5877,10 @@ public class PermissionManagerService extends IPermissionManager.Stub {\n                         attributionSource, next, fromDatasource, startDataDelivery, selfAccess,\n                         isLinkTrusted) : ATTRIBUTION_FLAGS_NONE;\n \n-                final int opMode = performOpTransaction(context, op, current, message,\n-                        forDataDelivery, startDataDelivery, skipCurrentChecks, selfAccess,\n-                        singleReceiverFromDatasource, attributedOp, proxyAttributionFlags,\n-                        proxiedAttributionFlags, attributionChainId);\n+                final int opMode = performOpTransaction(context, attributionSource.getToken(), op,\n+                        current, message, forDataDelivery, startDataDelivery, skipCurrentChecks,\n+                        selfAccess, singleReceiverFromDatasource, attributedOp,\n+                        proxyAttributionFlags, proxiedAttributionFlags, attributionChainId);\n \n                 switch (opMode) {\n                     case AppOpsManager.MODE_ERRORED: {\n@@ -6023,8 +6025,8 @@ public class PermissionManagerService extends IPermissionManager.Stub {\n                         attributionSource, next, /*fromDatasource*/ false, startDataDelivery,\n                         selfAccess, isLinkTrusted) : ATTRIBUTION_FLAGS_NONE;\n \n-                final int opMode = performOpTransaction(context, op, current, message,\n-                        forDataDelivery, startDataDelivery, skipCurrentChecks, selfAccess,\n+                final int opMode = performOpTransaction(context, current.getToken(), op, current,\n+                        message, forDataDelivery, startDataDelivery, skipCurrentChecks, selfAccess,\n                         /*fromDatasource*/ false, AppOpsManager.OP_NONE, proxyAttributionFlags,\n                         proxiedAttributionFlags, attributionChainId);\n \n@@ -6046,7 +6048,8 @@ public class PermissionManagerService extends IPermissionManager.Stub {\n         }\n \n         @SuppressWarnings(\"ConstantConditions\")\n-        private static int performOpTransaction(@NonNull Context context, int op,\n+        private static int performOpTransaction(@NonNull Context context,\n+                @NonNull IBinder chainStartToken, int op,\n                 @NonNull AttributionSource attributionSource, @Nullable String message,\n                 boolean forDataDelivery, boolean startDataDelivery, boolean skipProxyOperation,\n                 boolean selfAccess, boolean singleReceiverFromDatasource, int attributedOp,\n@@ -6108,7 +6111,7 @@ public class PermissionManagerService extends IPermissionManager.Stub {\n                 if (selfAccess) {\n                     try {\n                         startedOpResult = appOpsManager.startOpNoThrow(\n-                                resolvedAttributionSource.getToken(), startedOp,\n+                                chainStartToken, startedOp,\n                                 resolvedAttributionSource.getUid(),\n                                 resolvedAttributionSource.getPackageName(),\n                                 /*startIfModeDefault*/ false,\n@@ -6119,12 +6122,12 @@ public class PermissionManagerService extends IPermissionManager.Stub {\n                                 + \" platform defined runtime permission \"\n                                 + AppOpsManager.opToPermission(op) + \" while not having \"\n                                 + Manifest.permission.UPDATE_APP_OPS_STATS);\n-                        startedOpResult = appOpsManager.startProxyOpNoThrow(attributedOp,\n-                                attributionSource, message, skipProxyOperation,\n+                        startedOpResult = appOpsManager.startProxyOpNoThrow(chainStartToken,\n+                                attributedOp, attributionSource, message, skipProxyOperation,\n                                 proxyAttributionFlags, proxiedAttributionFlags, attributionChainId);\n                     }\n                 } else {\n-                    startedOpResult = appOpsManager.startProxyOpNoThrow(startedOp,\n+                    startedOpResult = appOpsManager.startProxyOpNoThrow(chainStartToken, startedOp,\n                             resolvedAttributionSource, message, skipProxyOperation,\n                             proxyAttributionFlags, proxiedAttributionFlags, attributionChainId);\n                 }\n",
    "added_lines": 21,
    "deleted_lines": 18,
    "changed_methods": "PermissionManagerService::PermissionCheckerService::finishDataDelivery, PermissionManagerService::PermissionCheckerService::checkRuntimePermission, PermissionManagerService::PermissionCheckerService::checkAppOpPermission, PermissionManagerService::PermissionCheckerService::performOpTransaction, PermissionManagerService::PermissionCheckerService::checkOp, PermissionManagerService::PermissionCheckerService::performOpTransaction"
   },
   {
    "filename": "AppOpsPolicy.java",
    "diff": "@@ -44,13 +44,11 @@ import android.util.Log;\n import android.util.SparseArray;\n \n import com.android.internal.annotations.GuardedBy;\n-import com.android.internal.util.function.DecFunction;\n import com.android.internal.util.function.HeptFunction;\n import com.android.internal.util.function.HexFunction;\n import com.android.internal.util.function.QuadFunction;\n import com.android.internal.util.function.QuintConsumer;\n import com.android.internal.util.function.QuintFunction;\n-import com.android.internal.util.function.TriFunction;\n import com.android.internal.util.function.UndecFunction;\n import com.android.server.LocalServices;\n \n@@ -255,14 +253,14 @@ public final class AppOpsPolicy implements AppOpsManagerInternal.CheckOpsDelegat\n     }\n \n     @Override\n-    public SyncNotedAppOp startProxyOperation(int code,\n+    public SyncNotedAppOp startProxyOperation(@NonNull IBinder clientId, int code,\n             @NonNull AttributionSource attributionSource, boolean startIfModeDefault,\n             boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n             boolean skipProxyOperation, @AttributionFlags int proxyAttributionFlags,\n             @AttributionFlags int proxiedAttributionFlags, int attributionChainId,\n-            @NonNull DecFunction<Integer, AttributionSource, Boolean, Boolean, String, Boolean,\n-                    Boolean, Integer, Integer, Integer, SyncNotedAppOp> superImpl) {\n-        return superImpl.apply(resolveDatasourceOp(code, attributionSource.getUid(),\n+            @NonNull UndecFunction<IBinder, Integer, AttributionSource, Boolean, Boolean, String,\n+                    Boolean, Boolean, Integer, Integer, Integer, SyncNotedAppOp> superImpl) {\n+        return superImpl.apply(clientId, resolveDatasourceOp(code, attributionSource.getUid(),\n                 attributionSource.getPackageName(), attributionSource.getAttributionTag()),\n                 attributionSource, startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                 shouldCollectMessage, skipProxyOperation, proxyAttributionFlags,\n@@ -278,10 +276,10 @@ public final class AppOpsPolicy implements AppOpsManagerInternal.CheckOpsDelegat\n     }\n \n     @Override\n-    public void finishProxyOperation(int code, @NonNull AttributionSource attributionSource,\n-            boolean skipProxyOperation, @NonNull TriFunction<Integer, AttributionSource,\n-            Boolean, Void> superImpl) {\n-        superImpl.apply(resolveDatasourceOp(code, attributionSource.getUid(),\n+    public void finishProxyOperation(@NonNull IBinder clientId, int code,\n+            @NonNull AttributionSource attributionSource, boolean skipProxyOperation,\n+            @NonNull QuadFunction<IBinder, Integer, AttributionSource, Boolean, Void> superImpl) {\n+        superImpl.apply(clientId, resolveDatasourceOp(code, attributionSource.getUid(),\n                 attributionSource.getPackageName(), attributionSource.getAttributionTag()),\n                 attributionSource, skipProxyOperation);\n     }\n",
    "added_lines": 8,
    "deleted_lines": 10,
    "changed_methods": "AppOpsPolicy::startProxyOperation, AppOpsPolicy::finishProxyOperation, AppOpsPolicy::finishProxyOperation, AppOpsPolicy::startProxyOperation"
   }
  ]
 },
 {
  "hash": "693e82f72cdf40d65a151c24e9168f345ee551af",
  "commit": "RESTRICT AUTOMERGE Use chain start token in performOpTransaction\n\nBug: 258672042\nTest: atest CtsPermission4TestCases\nChange-Id: I1d484ed7c72d4ae73f4cbec47522a18ae9088f6e\n(cherry picked from commit 9d09846798bce7253ed1202adb61257d4eefbd1d)\nMerged-In: I1d484ed7c72d4ae73f4cbec47522a18ae9088f6e",
  "files": [
   {
    "filename": "AppOpsManager.java",
    "diff": "@@ -8888,8 +8888,9 @@ public class AppOpsManager {\n      */\n     public int startProxyOpNoThrow(int op, @NonNull AttributionSource attributionSource,\n             @Nullable String message, boolean skipProxyOperation) {\n-        return startProxyOpNoThrow(op, attributionSource, message, skipProxyOperation,\n-                ATTRIBUTION_FLAGS_NONE, ATTRIBUTION_FLAGS_NONE, ATTRIBUTION_CHAIN_ID_NONE);\n+        return startProxyOpNoThrow(attributionSource.getToken(), op, attributionSource, message,\n+                skipProxyOperation, ATTRIBUTION_FLAGS_NONE, ATTRIBUTION_FLAGS_NONE,\n+                ATTRIBUTION_CHAIN_ID_NONE);\n     }\n \n     /**\n@@ -8901,7 +8902,8 @@ public class AppOpsManager {\n      *\n      * @hide\n      */\n-    public int startProxyOpNoThrow(int op, @NonNull AttributionSource attributionSource,\n+    public int startProxyOpNoThrow(@NonNull IBinder clientId, int op,\n+            @NonNull AttributionSource attributionSource,\n             @Nullable String message, boolean skipProxyOperation, @AttributionFlags\n             int proxyAttributionFlags, @AttributionFlags int proxiedAttributionFlags,\n             int attributionChainId) {\n@@ -8919,7 +8921,7 @@ public class AppOpsManager {\n                 }\n             }\n \n-            SyncNotedAppOp syncOp = mService.startProxyOperation(op,\n+            SyncNotedAppOp syncOp = mService.startProxyOperation(clientId, op,\n                     attributionSource, false, collectionMode == COLLECT_ASYNC, message,\n                     shouldCollectMessage, skipProxyOperation, proxyAttributionFlags,\n                     proxiedAttributionFlags, attributionChainId);\n@@ -9017,9 +9019,10 @@ public class AppOpsManager {\n      */\n     public void finishProxyOp(@NonNull String op, int proxiedUid,\n             @NonNull String proxiedPackageName, @Nullable String proxiedAttributionTag) {\n-        finishProxyOp(op, new AttributionSource(mContext.getAttributionSource(),\n+        IBinder token = mContext.getAttributionSource().getToken();\n+        finishProxyOp(token, op, new AttributionSource(mContext.getAttributionSource(),\n                 new AttributionSource(proxiedUid, proxiedPackageName,  proxiedAttributionTag,\n-                        mContext.getAttributionSource().getToken())), /*skipProxyOperation*/ false);\n+                        token)), /*skipProxyOperation*/ false);\n     }\n \n     /**\n@@ -9034,10 +9037,11 @@ public class AppOpsManager {\n      *\n      * @hide\n      */\n-    public void finishProxyOp(@NonNull String op, @NonNull AttributionSource attributionSource,\n-            boolean skipProxyOperation) {\n+    public void finishProxyOp(@NonNull IBinder clientId, @NonNull String op,\n+            @NonNull AttributionSource attributionSource, boolean skipProxyOperation) {\n         try {\n-            mService.finishProxyOperation(strOpToOp(op), attributionSource, skipProxyOperation);\n+            mService.finishProxyOperation(clientId, strOpToOp(op), attributionSource,\n+                    skipProxyOperation);\n         } catch (RemoteException e) {\n             throw e.rethrowFromSystemServer();\n         }\n",
    "added_lines": 13,
    "deleted_lines": 9,
    "changed_methods": "AppOpsManager::startProxyOpNoThrow, AppOpsManager::startProxyOpNoThrow, AppOpsManager::startProxyOpNoThrow, AppOpsManager::finishProxyOp, AppOpsManager::finishProxyOp, AppOpsManager::finishProxyOp"
   },
   {
    "filename": "AppOpsManagerInternal.java",
    "diff": "@@ -26,13 +26,11 @@ import android.util.SparseArray;\n import android.util.SparseIntArray;\n \n import com.android.internal.app.IAppOpsCallback;\n-import com.android.internal.util.function.DecFunction;\n import com.android.internal.util.function.HeptFunction;\n import com.android.internal.util.function.HexFunction;\n import com.android.internal.util.function.QuadFunction;\n import com.android.internal.util.function.QuintConsumer;\n import com.android.internal.util.function.QuintFunction;\n-import com.android.internal.util.function.TriFunction;\n import com.android.internal.util.function.UndecFunction;\n \n /**\n@@ -135,6 +133,7 @@ public abstract class AppOpsManagerInternal {\n         /**\n          * Allows overriding start proxy operation behavior.\n          *\n+         * @param clientId The client calling start, represented by an IBinder\n          * @param code The op code to start.\n          * @param attributionSource The permission identity of the caller.\n          * @param startIfModeDefault Whether to start the op of the mode is default.\n@@ -148,11 +147,12 @@ public abstract class AppOpsManagerInternal {\n          * @param superImpl The super implementation.\n          * @return The app op note result.\n          */\n-        SyncNotedAppOp startProxyOperation(int code, @NonNull AttributionSource attributionSource,\n-                boolean startIfModeDefault, boolean shouldCollectAsyncNotedOp, String message,\n-                boolean shouldCollectMessage, boolean skipProxyOperation, @AttributionFlags\n-                int proxyAttributionFlags, @AttributionFlags int proxiedAttributionFlags,\n-                int attributionChainId, @NonNull DecFunction<Integer, AttributionSource, Boolean,\n+        SyncNotedAppOp startProxyOperation(@NonNull IBinder clientId, int code,\n+                @NonNull AttributionSource attributionSource, boolean startIfModeDefault,\n+                boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n+                boolean skipProxyOperation, @AttributionFlags int proxyAttributionFlags,\n+                @AttributionFlags int proxiedAttributionFlags, int attributionChainId,\n+                @NonNull UndecFunction<IBinder, Integer, AttributionSource, Boolean,\n                         Boolean, String, Boolean, Boolean, Integer, Integer, Integer,\n                         SyncNotedAppOp> superImpl);\n \n@@ -176,10 +176,15 @@ public abstract class AppOpsManagerInternal {\n          *\n          * @param code The op code to finish.\n          * @param attributionSource The permission identity of the caller.\n+         * @param skipProxyOperation Whether to skip the proxy in the proxy/proxied operation\n+         * @param clientId The client calling finishProxyOperation\n+         * @param superImpl The \"standard\" implementation to potentially call\n          */\n-        void finishProxyOperation(int code, @NonNull AttributionSource attributionSource,\n+        void finishProxyOperation(@NonNull IBinder clientId, int code,\n+                @NonNull AttributionSource attributionSource,\n                 boolean skipProxyOperation,\n-                @NonNull TriFunction<Integer, AttributionSource, Boolean, Void> superImpl);\n+                @NonNull QuadFunction<IBinder, Integer, AttributionSource, Boolean,\n+                        Void> superImpl);\n     }\n \n     /**\n",
    "added_lines": 14,
    "deleted_lines": 9,
    "changed_methods": ""
   },
   {
    "filename": "ActivityManagerService.java",
    "diff": "@@ -351,12 +351,10 @@ import com.android.internal.util.FastPrintWriter;\n import com.android.internal.util.FrameworkStatsLog;\n import com.android.internal.util.MemInfoReader;\n import com.android.internal.util.Preconditions;\n-import com.android.internal.util.function.DecFunction;\n import com.android.internal.util.function.HeptFunction;\n import com.android.internal.util.function.HexFunction;\n import com.android.internal.util.function.QuadFunction;\n import com.android.internal.util.function.QuintFunction;\n-import com.android.internal.util.function.TriFunction;\n import com.android.internal.util.function.UndecFunction;\n import com.android.server.AlarmManagerInternal;\n import com.android.server.DeviceIdleInternal;\n@@ -17128,19 +17126,20 @@ public class ActivityManagerService extends IActivityManager.Stub\n         }\n \n         @Override\n-        public SyncNotedAppOp startProxyOperation(int code,\n+        public SyncNotedAppOp startProxyOperation(@NonNull IBinder clientId, int code,\n                 @NonNull AttributionSource attributionSource, boolean startIfModeDefault,\n                 boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n                 boolean skipProxyOperation, @AttributionFlags int proxyAttributionFlags,\n                 @AttributionFlags int proxiedAttributionFlags, int attributionChainId,\n-                @NonNull DecFunction<Integer, AttributionSource, Boolean, Boolean, String, Boolean,\n-                        Boolean, Integer, Integer, Integer, SyncNotedAppOp> superImpl) {\n+                @NonNull UndecFunction<IBinder, Integer, AttributionSource,\n+                        Boolean, Boolean, String, Boolean, Boolean, Integer, Integer, Integer,\n+                        SyncNotedAppOp> superImpl) {\n             if (attributionSource.getUid() == mTargetUid && isTargetOp(code)) {\n                 final int shellUid = UserHandle.getUid(UserHandle.getUserId(\n                         attributionSource.getUid()), Process.SHELL_UID);\n                 final long identity = Binder.clearCallingIdentity();\n                 try {\n-                    return superImpl.apply(code, new AttributionSource(shellUid,\n+                    return superImpl.apply(clientId, code, new AttributionSource(shellUid,\n                             \"com.android.shell\", attributionSource.getAttributionTag(),\n                             attributionSource.getToken(), attributionSource.getNext()),\n                             startIfModeDefault, shouldCollectAsyncNotedOp, message,\n@@ -17150,21 +17149,22 @@ public class ActivityManagerService extends IActivityManager.Stub\n                     Binder.restoreCallingIdentity(identity);\n                 }\n             }\n-            return superImpl.apply(code, attributionSource, startIfModeDefault,\n+            return superImpl.apply(clientId, code, attributionSource, startIfModeDefault,\n                     shouldCollectAsyncNotedOp, message, shouldCollectMessage, skipProxyOperation,\n                     proxyAttributionFlags, proxiedAttributionFlags, attributionChainId);\n         }\n \n         @Override\n-        public void finishProxyOperation(int code, @NonNull AttributionSource attributionSource,\n-                boolean skipProxyOperation, @NonNull TriFunction<Integer, AttributionSource,\n-                        Boolean, Void> superImpl) {\n+        public void finishProxyOperation(@NonNull IBinder clientId, int code,\n+                @NonNull AttributionSource attributionSource, boolean skipProxyOperation,\n+                @NonNull QuadFunction<IBinder, Integer, AttributionSource, Boolean,\n+                        Void> superImpl) {\n             if (attributionSource.getUid() == mTargetUid && isTargetOp(code)) {\n                 final int shellUid = UserHandle.getUid(UserHandle.getUserId(\n                         attributionSource.getUid()), Process.SHELL_UID);\n                 final long identity = Binder.clearCallingIdentity();\n                 try {\n-                    superImpl.apply(code, new AttributionSource(shellUid,\n+                    superImpl.apply(clientId, code, new AttributionSource(shellUid,\n                             \"com.android.shell\", attributionSource.getAttributionTag(),\n                             attributionSource.getToken(), attributionSource.getNext()),\n                             skipProxyOperation);\n@@ -17172,7 +17172,7 @@ public class ActivityManagerService extends IActivityManager.Stub\n                     Binder.restoreCallingIdentity(identity);\n                 }\n             }\n-            superImpl.apply(code, attributionSource, skipProxyOperation);\n+            superImpl.apply(clientId, code, attributionSource, skipProxyOperation);\n         }\n \n         private boolean isTargetOp(int code) {\n",
    "added_lines": 12,
    "deleted_lines": 12,
    "changed_methods": "ActivityManagerService::ShellDelegate::finishProxyOperation, ActivityManagerService::ShellDelegate::startProxyOperation, ActivityManagerService::ShellDelegate::finishProxyOperation, ActivityManagerService::ShellDelegate::startProxyOperation"
   },
   {
    "filename": "AppOpsService.java",
    "diff": "@@ -3839,18 +3839,18 @@ public class AppOpsService extends IAppOpsService.Stub {\n     }\n \n     @Override\n-    public SyncNotedAppOp startProxyOperation(int code,\n+    public SyncNotedAppOp startProxyOperation(@NonNull IBinder clientId, int code,\n             @NonNull AttributionSource attributionSource, boolean startIfModeDefault,\n             boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n             boolean skipProxyOperation, @AttributionFlags int proxyAttributionFlags,\n             @AttributionFlags int proxiedAttributionFlags, int attributionChainId) {\n-        return mCheckOpsDelegateDispatcher.startProxyOperation(code, attributionSource,\n+        return mCheckOpsDelegateDispatcher.startProxyOperation(clientId, code, attributionSource,\n                 startIfModeDefault, shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                 skipProxyOperation, proxyAttributionFlags, proxiedAttributionFlags,\n                 attributionChainId);\n     }\n \n-    private SyncNotedAppOp startProxyOperationImpl(int code,\n+    private SyncNotedAppOp startProxyOperationImpl(@NonNull IBinder clientId, int code,\n             @NonNull AttributionSource attributionSource,\n             boolean startIfModeDefault, boolean shouldCollectAsyncNotedOp, String message,\n             boolean shouldCollectMessage, boolean skipProxyOperation, @AttributionFlags\n@@ -3859,11 +3859,9 @@ public class AppOpsService extends IAppOpsService.Stub {\n         final int proxyUid = attributionSource.getUid();\n         final String proxyPackageName = attributionSource.getPackageName();\n         final String proxyAttributionTag = attributionSource.getAttributionTag();\n-        final IBinder proxyToken = attributionSource.getToken();\n         final int proxiedUid = attributionSource.getNextUid();\n         final String proxiedPackageName = attributionSource.getNextPackageName();\n         final String proxiedAttributionTag = attributionSource.getNextAttributionTag();\n-        final IBinder proxiedToken = attributionSource.getNextToken();\n \n         verifyIncomingProxyUid(attributionSource);\n         verifyIncomingOp(code);\n@@ -3902,7 +3900,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n \n         if (!skipProxyOperation) {\n             // Test if the proxied operation will succeed before starting the proxy operation\n-            final SyncNotedAppOp testProxiedOp = startOperationUnchecked(proxiedToken, code,\n+            final SyncNotedAppOp testProxiedOp = startOperationUnchecked(clientId, code,\n                     proxiedUid, resolvedProxiedPackageName, proxiedAttributionTag, proxyUid,\n                     resolvedProxyPackageName, proxyAttributionTag, proxiedFlags, startIfModeDefault,\n                     shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n@@ -3914,7 +3912,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n             final int proxyFlags = isProxyTrusted ? AppOpsManager.OP_FLAG_TRUSTED_PROXY\n                     : AppOpsManager.OP_FLAG_UNTRUSTED_PROXY;\n \n-            final SyncNotedAppOp proxyAppOp = startOperationUnchecked(proxyToken, code, proxyUid,\n+            final SyncNotedAppOp proxyAppOp = startOperationUnchecked(clientId, code, proxyUid,\n                     resolvedProxyPackageName, proxyAttributionTag, Process.INVALID_UID, null, null,\n                     proxyFlags, startIfModeDefault, !isProxyTrusted, \"proxy \" + message,\n                     shouldCollectMessage, proxyAttributionFlags, attributionChainId,\n@@ -3924,7 +3922,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n             }\n         }\n \n-        return startOperationUnchecked(proxiedToken, code, proxiedUid, resolvedProxiedPackageName,\n+        return startOperationUnchecked(clientId, code, proxiedUid, resolvedProxiedPackageName,\n                 proxiedAttributionTag, proxyUid, resolvedProxyPackageName, proxyAttributionTag,\n                 proxiedFlags, startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                 shouldCollectMessage, proxiedAttributionFlags, attributionChainId,\n@@ -4065,22 +4063,20 @@ public class AppOpsService extends IAppOpsService.Stub {\n     }\n \n     @Override\n-    public void finishProxyOperation(int code, @NonNull AttributionSource attributionSource,\n-            boolean skipProxyOperation) {\n-        mCheckOpsDelegateDispatcher.finishProxyOperation(code, attributionSource,\n+    public void finishProxyOperation(@NonNull IBinder clientId, int code,\n+            @NonNull AttributionSource attributionSource, boolean skipProxyOperation) {\n+        mCheckOpsDelegateDispatcher.finishProxyOperation(clientId, code, attributionSource,\n                 skipProxyOperation);\n     }\n \n-    private Void finishProxyOperationImpl(int code, @NonNull AttributionSource attributionSource,\n-            boolean skipProxyOperation) {\n+    private Void finishProxyOperationImpl(IBinder clientId, int code,\n+            @NonNull AttributionSource attributionSource, boolean skipProxyOperation) {\n         final int proxyUid = attributionSource.getUid();\n         final String proxyPackageName = attributionSource.getPackageName();\n         final String proxyAttributionTag = attributionSource.getAttributionTag();\n-        final IBinder proxyToken = attributionSource.getToken();\n         final int proxiedUid = attributionSource.getNextUid();\n         final String proxiedPackageName = attributionSource.getNextPackageName();\n         final String proxiedAttributionTag = attributionSource.getNextAttributionTag();\n-        final IBinder proxiedToken = attributionSource.getNextToken();\n \n         skipProxyOperation = skipProxyOperation\n                 && isCallerAndAttributionTrusted(attributionSource);\n@@ -4097,7 +4093,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n         }\n \n         if (!skipProxyOperation) {\n-            finishOperationUnchecked(proxyToken, code, proxyUid, resolvedProxyPackageName,\n+            finishOperationUnchecked(clientId, code, proxyUid, resolvedProxyPackageName,\n                     proxyAttributionTag);\n         }\n \n@@ -4107,7 +4103,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n             return null;\n         }\n \n-        finishOperationUnchecked(proxiedToken, code, proxiedUid, resolvedProxiedPackageName,\n+        finishOperationUnchecked(clientId, code, proxiedUid, resolvedProxiedPackageName,\n                 proxiedAttributionTag);\n \n         return null;\n@@ -7642,42 +7638,42 @@ public class AppOpsService extends IAppOpsService.Stub {\n                     attributionFlags, attributionChainId, AppOpsService.this::startOperationImpl);\n         }\n \n-        public SyncNotedAppOp startProxyOperation(int code,\n+        public SyncNotedAppOp startProxyOperation(@NonNull IBinder clientId, int code,\n                 @NonNull AttributionSource attributionSource, boolean startIfModeDefault,\n                 boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n                 boolean skipProxyOperation, @AttributionFlags int proxyAttributionFlags,\n                 @AttributionFlags int proxiedAttributionFlags, int attributionChainId) {\n             if (mPolicy != null) {\n                 if (mCheckOpsDelegate != null) {\n-                    return mPolicy.startProxyOperation(code, attributionSource,\n+                    return mPolicy.startProxyOperation(clientId, code, attributionSource,\n                             startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                             shouldCollectMessage, skipProxyOperation, proxyAttributionFlags,\n                             proxiedAttributionFlags, attributionChainId,\n                             this::startDelegateProxyOperationImpl);\n                 } else {\n-                    return mPolicy.startProxyOperation(code, attributionSource,\n+                    return mPolicy.startProxyOperation(clientId, code, attributionSource,\n                             startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                             shouldCollectMessage, skipProxyOperation, proxyAttributionFlags,\n                             proxiedAttributionFlags, attributionChainId,\n                             AppOpsService.this::startProxyOperationImpl);\n                 }\n             } else if (mCheckOpsDelegate != null) {\n-                return startDelegateProxyOperationImpl(code, attributionSource,\n+                return startDelegateProxyOperationImpl(clientId, code, attributionSource,\n                         startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                         shouldCollectMessage, skipProxyOperation, proxyAttributionFlags,\n                         proxiedAttributionFlags, attributionChainId);\n             }\n-            return startProxyOperationImpl(code, attributionSource, startIfModeDefault,\n+            return startProxyOperationImpl(clientId, code, attributionSource, startIfModeDefault,\n                     shouldCollectAsyncNotedOp, message, shouldCollectMessage, skipProxyOperation,\n                     proxyAttributionFlags, proxiedAttributionFlags, attributionChainId);\n         }\n \n-        private SyncNotedAppOp startDelegateProxyOperationImpl(int code,\n+        private SyncNotedAppOp startDelegateProxyOperationImpl(@NonNull IBinder clientId, int code,\n                 @NonNull AttributionSource attributionSource, boolean startIfModeDefault,\n                 boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n                 boolean skipProxyOperation, @AttributionFlags int proxyAttributionFlags,\n                 @AttributionFlags int proxiedAttributionFlsgs, int attributionChainId) {\n-            return mCheckOpsDelegate.startProxyOperation(code, attributionSource,\n+            return mCheckOpsDelegate.startProxyOperation(clientId, code, attributionSource,\n                     startIfModeDefault, shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                     skipProxyOperation, proxyAttributionFlags, proxiedAttributionFlsgs,\n                     attributionChainId, AppOpsService.this::startProxyOperationImpl);\n@@ -7706,27 +7702,28 @@ public class AppOpsService extends IAppOpsService.Stub {\n                     AppOpsService.this::finishOperationImpl);\n         }\n \n-        public void finishProxyOperation(int code,\n+        public void finishProxyOperation(@NonNull IBinder clientId, int code,\n                 @NonNull AttributionSource attributionSource, boolean skipProxyOperation) {\n             if (mPolicy != null) {\n                 if (mCheckOpsDelegate != null) {\n-                    mPolicy.finishProxyOperation(code, attributionSource,\n+                    mPolicy.finishProxyOperation(clientId, code, attributionSource,\n                             skipProxyOperation, this::finishDelegateProxyOperationImpl);\n                 } else {\n-                    mPolicy.finishProxyOperation(code, attributionSource,\n+                    mPolicy.finishProxyOperation(clientId, code, attributionSource,\n                             skipProxyOperation, AppOpsService.this::finishProxyOperationImpl);\n                 }\n             } else if (mCheckOpsDelegate != null) {\n-                finishDelegateProxyOperationImpl(code, attributionSource, skipProxyOperation);\n+                finishDelegateProxyOperationImpl(clientId, code, attributionSource,\n+                        skipProxyOperation);\n             } else {\n-                finishProxyOperationImpl(code, attributionSource, skipProxyOperation);\n+                finishProxyOperationImpl(clientId, code, attributionSource, skipProxyOperation);\n             }\n         }\n \n-        private Void finishDelegateProxyOperationImpl(int code,\n+        private Void finishDelegateProxyOperationImpl(@NonNull IBinder clientId, int code,\n                 @NonNull AttributionSource attributionSource, boolean skipProxyOperation) {\n-            mCheckOpsDelegate.finishProxyOperation(code, attributionSource, skipProxyOperation,\n-                    AppOpsService.this::finishProxyOperationImpl);\n+            mCheckOpsDelegate.finishProxyOperation(clientId, code, attributionSource,\n+                    skipProxyOperation, AppOpsService.this::finishProxyOperationImpl);\n             return null;\n         }\n     }\n",
    "added_lines": 29,
    "deleted_lines": 32,
    "changed_methods": "AppOpsService::CheckOpsDelegateDispatcher::finishProxyOperation, AppOpsService::finishProxyOperationImpl, AppOpsService::CheckOpsDelegateDispatcher::startDelegateProxyOperationImpl, AppOpsService::CheckOpsDelegateDispatcher::startProxyOperation, AppOpsService::startProxyOperationImpl, AppOpsService::CheckOpsDelegateDispatcher::startProxyOperation, AppOpsService::startProxyOperation, AppOpsService::CheckOpsDelegateDispatcher::startDelegateProxyOperationImpl, AppOpsService::startProxyOperationImpl, AppOpsService::finishProxyOperation, AppOpsService::startProxyOperation, AppOpsService::CheckOpsDelegateDispatcher::finishProxyOperation, AppOpsService::CheckOpsDelegateDispatcher::finishDelegateProxyOperationImpl, AppOpsService::CheckOpsDelegateDispatcher::finishDelegateProxyOperationImpl, AppOpsService::finishProxyOperationImpl, AppOpsService::finishProxyOperation"
   },
   {
    "filename": "PermissionManagerService.java",
    "diff": "@@ -5650,7 +5650,7 @@ public class PermissionManagerService extends IPermissionManager.Stub {\n                     if (resolvedPackageName == null) {\n                         return;\n                     }\n-                    appOpsManager.finishOp(accessorSource.getToken(), op,\n+                    appOpsManager.finishOp(attributionSourceState.token, op,\n                             accessorSource.getUid(), resolvedPackageName,\n                             accessorSource.getAttributionTag());\n                 } else {\n@@ -5659,8 +5659,9 @@ public class PermissionManagerService extends IPermissionManager.Stub {\n                     if (resolvedAttributionSource.getPackageName() == null) {\n                         return;\n                     }\n-                    appOpsManager.finishProxyOp(AppOpsManager.opToPublicName(op),\n-                            resolvedAttributionSource, skipCurrentFinish);\n+                    appOpsManager.finishProxyOp(attributionSourceState.token,\n+                            AppOpsManager.opToPublicName(op), resolvedAttributionSource,\n+                            skipCurrentFinish);\n                 }\n \n                 if (next == null || next.getNext() == null) {\n@@ -5770,10 +5771,11 @@ public class PermissionManagerService extends IPermissionManager.Stub {\n                         && next.getNext() == null);\n                 final boolean selfAccess = singleReceiverFromDatasource || next == null;\n \n-                final int opMode = performOpTransaction(context, op, current, message,\n-                        forDataDelivery, /*startDataDelivery*/ false, skipCurrentChecks,\n-                        selfAccess, singleReceiverFromDatasource, AppOpsManager.OP_NONE,\n-                        AppOpsManager.ATTRIBUTION_FLAGS_NONE, AppOpsManager.ATTRIBUTION_FLAGS_NONE,\n+                final int opMode = performOpTransaction(context, attributionSource.getToken(), op,\n+                        current, message, forDataDelivery, /*startDataDelivery*/ false,\n+                        skipCurrentChecks, selfAccess, singleReceiverFromDatasource,\n+                        AppOpsManager.OP_NONE, AppOpsManager.ATTRIBUTION_FLAGS_NONE,\n+                        AppOpsManager.ATTRIBUTION_FLAGS_NONE,\n                         AppOpsManager.ATTRIBUTION_CHAIN_ID_NONE);\n \n                 switch (opMode) {\n@@ -5875,10 +5877,10 @@ public class PermissionManagerService extends IPermissionManager.Stub {\n                         attributionSource, next, fromDatasource, startDataDelivery, selfAccess,\n                         isLinkTrusted) : ATTRIBUTION_FLAGS_NONE;\n \n-                final int opMode = performOpTransaction(context, op, current, message,\n-                        forDataDelivery, startDataDelivery, skipCurrentChecks, selfAccess,\n-                        singleReceiverFromDatasource, attributedOp, proxyAttributionFlags,\n-                        proxiedAttributionFlags, attributionChainId);\n+                final int opMode = performOpTransaction(context, attributionSource.getToken(), op,\n+                        current, message, forDataDelivery, startDataDelivery, skipCurrentChecks,\n+                        selfAccess, singleReceiverFromDatasource, attributedOp,\n+                        proxyAttributionFlags, proxiedAttributionFlags, attributionChainId);\n \n                 switch (opMode) {\n                     case AppOpsManager.MODE_ERRORED: {\n@@ -6023,8 +6025,8 @@ public class PermissionManagerService extends IPermissionManager.Stub {\n                         attributionSource, next, /*fromDatasource*/ false, startDataDelivery,\n                         selfAccess, isLinkTrusted) : ATTRIBUTION_FLAGS_NONE;\n \n-                final int opMode = performOpTransaction(context, op, current, message,\n-                        forDataDelivery, startDataDelivery, skipCurrentChecks, selfAccess,\n+                final int opMode = performOpTransaction(context, current.getToken(), op, current,\n+                        message, forDataDelivery, startDataDelivery, skipCurrentChecks, selfAccess,\n                         /*fromDatasource*/ false, AppOpsManager.OP_NONE, proxyAttributionFlags,\n                         proxiedAttributionFlags, attributionChainId);\n \n@@ -6046,7 +6048,8 @@ public class PermissionManagerService extends IPermissionManager.Stub {\n         }\n \n         @SuppressWarnings(\"ConstantConditions\")\n-        private static int performOpTransaction(@NonNull Context context, int op,\n+        private static int performOpTransaction(@NonNull Context context,\n+                @NonNull IBinder chainStartToken, int op,\n                 @NonNull AttributionSource attributionSource, @Nullable String message,\n                 boolean forDataDelivery, boolean startDataDelivery, boolean skipProxyOperation,\n                 boolean selfAccess, boolean singleReceiverFromDatasource, int attributedOp,\n@@ -6108,7 +6111,7 @@ public class PermissionManagerService extends IPermissionManager.Stub {\n                 if (selfAccess) {\n                     try {\n                         startedOpResult = appOpsManager.startOpNoThrow(\n-                                resolvedAttributionSource.getToken(), startedOp,\n+                                chainStartToken, startedOp,\n                                 resolvedAttributionSource.getUid(),\n                                 resolvedAttributionSource.getPackageName(),\n                                 /*startIfModeDefault*/ false,\n@@ -6119,12 +6122,12 @@ public class PermissionManagerService extends IPermissionManager.Stub {\n                                 + \" platform defined runtime permission \"\n                                 + AppOpsManager.opToPermission(op) + \" while not having \"\n                                 + Manifest.permission.UPDATE_APP_OPS_STATS);\n-                        startedOpResult = appOpsManager.startProxyOpNoThrow(attributedOp,\n-                                attributionSource, message, skipProxyOperation,\n+                        startedOpResult = appOpsManager.startProxyOpNoThrow(chainStartToken,\n+                                attributedOp, attributionSource, message, skipProxyOperation,\n                                 proxyAttributionFlags, proxiedAttributionFlags, attributionChainId);\n                     }\n                 } else {\n-                    startedOpResult = appOpsManager.startProxyOpNoThrow(startedOp,\n+                    startedOpResult = appOpsManager.startProxyOpNoThrow(chainStartToken, startedOp,\n                             resolvedAttributionSource, message, skipProxyOperation,\n                             proxyAttributionFlags, proxiedAttributionFlags, attributionChainId);\n                 }\n",
    "added_lines": 21,
    "deleted_lines": 18,
    "changed_methods": "PermissionManagerService::PermissionCheckerService::finishDataDelivery, PermissionManagerService::PermissionCheckerService::checkRuntimePermission, PermissionManagerService::PermissionCheckerService::checkAppOpPermission, PermissionManagerService::PermissionCheckerService::performOpTransaction, PermissionManagerService::PermissionCheckerService::checkOp, PermissionManagerService::PermissionCheckerService::performOpTransaction"
   },
   {
    "filename": "AppOpsPolicy.java",
    "diff": "@@ -44,13 +44,11 @@ import android.util.Log;\n import android.util.SparseArray;\n \n import com.android.internal.annotations.GuardedBy;\n-import com.android.internal.util.function.DecFunction;\n import com.android.internal.util.function.HeptFunction;\n import com.android.internal.util.function.HexFunction;\n import com.android.internal.util.function.QuadFunction;\n import com.android.internal.util.function.QuintConsumer;\n import com.android.internal.util.function.QuintFunction;\n-import com.android.internal.util.function.TriFunction;\n import com.android.internal.util.function.UndecFunction;\n import com.android.server.LocalServices;\n \n@@ -255,14 +253,14 @@ public final class AppOpsPolicy implements AppOpsManagerInternal.CheckOpsDelegat\n     }\n \n     @Override\n-    public SyncNotedAppOp startProxyOperation(int code,\n+    public SyncNotedAppOp startProxyOperation(@NonNull IBinder clientId, int code,\n             @NonNull AttributionSource attributionSource, boolean startIfModeDefault,\n             boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n             boolean skipProxyOperation, @AttributionFlags int proxyAttributionFlags,\n             @AttributionFlags int proxiedAttributionFlags, int attributionChainId,\n-            @NonNull DecFunction<Integer, AttributionSource, Boolean, Boolean, String, Boolean,\n-                    Boolean, Integer, Integer, Integer, SyncNotedAppOp> superImpl) {\n-        return superImpl.apply(resolveDatasourceOp(code, attributionSource.getUid(),\n+            @NonNull UndecFunction<IBinder, Integer, AttributionSource, Boolean, Boolean, String,\n+                    Boolean, Boolean, Integer, Integer, Integer, SyncNotedAppOp> superImpl) {\n+        return superImpl.apply(clientId, resolveDatasourceOp(code, attributionSource.getUid(),\n                 attributionSource.getPackageName(), attributionSource.getAttributionTag()),\n                 attributionSource, startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                 shouldCollectMessage, skipProxyOperation, proxyAttributionFlags,\n@@ -278,10 +276,10 @@ public final class AppOpsPolicy implements AppOpsManagerInternal.CheckOpsDelegat\n     }\n \n     @Override\n-    public void finishProxyOperation(int code, @NonNull AttributionSource attributionSource,\n-            boolean skipProxyOperation, @NonNull TriFunction<Integer, AttributionSource,\n-            Boolean, Void> superImpl) {\n-        superImpl.apply(resolveDatasourceOp(code, attributionSource.getUid(),\n+    public void finishProxyOperation(@NonNull IBinder clientId, int code,\n+            @NonNull AttributionSource attributionSource, boolean skipProxyOperation,\n+            @NonNull QuadFunction<IBinder, Integer, AttributionSource, Boolean, Void> superImpl) {\n+        superImpl.apply(clientId, resolveDatasourceOp(code, attributionSource.getUid(),\n                 attributionSource.getPackageName(), attributionSource.getAttributionTag()),\n                 attributionSource, skipProxyOperation);\n     }\n",
    "added_lines": 8,
    "deleted_lines": 10,
    "changed_methods": "AppOpsPolicy::startProxyOperation, AppOpsPolicy::finishProxyOperation, AppOpsPolicy::finishProxyOperation, AppOpsPolicy::startProxyOperation"
   }
  ]
 },
 {
  "hash": "693e82f72cdf40d65a151c24e9168f345ee551af",
  "commit": "RESTRICT AUTOMERGE Use chain start token in performOpTransaction\n\nBug: 258672042\nTest: atest CtsPermission4TestCases\nChange-Id: I1d484ed7c72d4ae73f4cbec47522a18ae9088f6e\n(cherry picked from commit 9d09846798bce7253ed1202adb61257d4eefbd1d)\nMerged-In: I1d484ed7c72d4ae73f4cbec47522a18ae9088f6e",
  "files": [
   {
    "filename": "AppOpsManager.java",
    "diff": "@@ -8888,8 +8888,9 @@ public class AppOpsManager {\n      */\n     public int startProxyOpNoThrow(int op, @NonNull AttributionSource attributionSource,\n             @Nullable String message, boolean skipProxyOperation) {\n-        return startProxyOpNoThrow(op, attributionSource, message, skipProxyOperation,\n-                ATTRIBUTION_FLAGS_NONE, ATTRIBUTION_FLAGS_NONE, ATTRIBUTION_CHAIN_ID_NONE);\n+        return startProxyOpNoThrow(attributionSource.getToken(), op, attributionSource, message,\n+                skipProxyOperation, ATTRIBUTION_FLAGS_NONE, ATTRIBUTION_FLAGS_NONE,\n+                ATTRIBUTION_CHAIN_ID_NONE);\n     }\n \n     /**\n@@ -8901,7 +8902,8 @@ public class AppOpsManager {\n      *\n      * @hide\n      */\n-    public int startProxyOpNoThrow(int op, @NonNull AttributionSource attributionSource,\n+    public int startProxyOpNoThrow(@NonNull IBinder clientId, int op,\n+            @NonNull AttributionSource attributionSource,\n             @Nullable String message, boolean skipProxyOperation, @AttributionFlags\n             int proxyAttributionFlags, @AttributionFlags int proxiedAttributionFlags,\n             int attributionChainId) {\n@@ -8919,7 +8921,7 @@ public class AppOpsManager {\n                 }\n             }\n \n-            SyncNotedAppOp syncOp = mService.startProxyOperation(op,\n+            SyncNotedAppOp syncOp = mService.startProxyOperation(clientId, op,\n                     attributionSource, false, collectionMode == COLLECT_ASYNC, message,\n                     shouldCollectMessage, skipProxyOperation, proxyAttributionFlags,\n                     proxiedAttributionFlags, attributionChainId);\n@@ -9017,9 +9019,10 @@ public class AppOpsManager {\n      */\n     public void finishProxyOp(@NonNull String op, int proxiedUid,\n             @NonNull String proxiedPackageName, @Nullable String proxiedAttributionTag) {\n-        finishProxyOp(op, new AttributionSource(mContext.getAttributionSource(),\n+        IBinder token = mContext.getAttributionSource().getToken();\n+        finishProxyOp(token, op, new AttributionSource(mContext.getAttributionSource(),\n                 new AttributionSource(proxiedUid, proxiedPackageName,  proxiedAttributionTag,\n-                        mContext.getAttributionSource().getToken())), /*skipProxyOperation*/ false);\n+                        token)), /*skipProxyOperation*/ false);\n     }\n \n     /**\n@@ -9034,10 +9037,11 @@ public class AppOpsManager {\n      *\n      * @hide\n      */\n-    public void finishProxyOp(@NonNull String op, @NonNull AttributionSource attributionSource,\n-            boolean skipProxyOperation) {\n+    public void finishProxyOp(@NonNull IBinder clientId, @NonNull String op,\n+            @NonNull AttributionSource attributionSource, boolean skipProxyOperation) {\n         try {\n-            mService.finishProxyOperation(strOpToOp(op), attributionSource, skipProxyOperation);\n+            mService.finishProxyOperation(clientId, strOpToOp(op), attributionSource,\n+                    skipProxyOperation);\n         } catch (RemoteException e) {\n             throw e.rethrowFromSystemServer();\n         }\n",
    "added_lines": 13,
    "deleted_lines": 9,
    "changed_methods": "AppOpsManager::startProxyOpNoThrow, AppOpsManager::startProxyOpNoThrow, AppOpsManager::startProxyOpNoThrow, AppOpsManager::finishProxyOp, AppOpsManager::finishProxyOp, AppOpsManager::finishProxyOp"
   },
   {
    "filename": "AppOpsManagerInternal.java",
    "diff": "@@ -26,13 +26,11 @@ import android.util.SparseArray;\n import android.util.SparseIntArray;\n \n import com.android.internal.app.IAppOpsCallback;\n-import com.android.internal.util.function.DecFunction;\n import com.android.internal.util.function.HeptFunction;\n import com.android.internal.util.function.HexFunction;\n import com.android.internal.util.function.QuadFunction;\n import com.android.internal.util.function.QuintConsumer;\n import com.android.internal.util.function.QuintFunction;\n-import com.android.internal.util.function.TriFunction;\n import com.android.internal.util.function.UndecFunction;\n \n /**\n@@ -135,6 +133,7 @@ public abstract class AppOpsManagerInternal {\n         /**\n          * Allows overriding start proxy operation behavior.\n          *\n+         * @param clientId The client calling start, represented by an IBinder\n          * @param code The op code to start.\n          * @param attributionSource The permission identity of the caller.\n          * @param startIfModeDefault Whether to start the op of the mode is default.\n@@ -148,11 +147,12 @@ public abstract class AppOpsManagerInternal {\n          * @param superImpl The super implementation.\n          * @return The app op note result.\n          */\n-        SyncNotedAppOp startProxyOperation(int code, @NonNull AttributionSource attributionSource,\n-                boolean startIfModeDefault, boolean shouldCollectAsyncNotedOp, String message,\n-                boolean shouldCollectMessage, boolean skipProxyOperation, @AttributionFlags\n-                int proxyAttributionFlags, @AttributionFlags int proxiedAttributionFlags,\n-                int attributionChainId, @NonNull DecFunction<Integer, AttributionSource, Boolean,\n+        SyncNotedAppOp startProxyOperation(@NonNull IBinder clientId, int code,\n+                @NonNull AttributionSource attributionSource, boolean startIfModeDefault,\n+                boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n+                boolean skipProxyOperation, @AttributionFlags int proxyAttributionFlags,\n+                @AttributionFlags int proxiedAttributionFlags, int attributionChainId,\n+                @NonNull UndecFunction<IBinder, Integer, AttributionSource, Boolean,\n                         Boolean, String, Boolean, Boolean, Integer, Integer, Integer,\n                         SyncNotedAppOp> superImpl);\n \n@@ -176,10 +176,15 @@ public abstract class AppOpsManagerInternal {\n          *\n          * @param code The op code to finish.\n          * @param attributionSource The permission identity of the caller.\n+         * @param skipProxyOperation Whether to skip the proxy in the proxy/proxied operation\n+         * @param clientId The client calling finishProxyOperation\n+         * @param superImpl The \"standard\" implementation to potentially call\n          */\n-        void finishProxyOperation(int code, @NonNull AttributionSource attributionSource,\n+        void finishProxyOperation(@NonNull IBinder clientId, int code,\n+                @NonNull AttributionSource attributionSource,\n                 boolean skipProxyOperation,\n-                @NonNull TriFunction<Integer, AttributionSource, Boolean, Void> superImpl);\n+                @NonNull QuadFunction<IBinder, Integer, AttributionSource, Boolean,\n+                        Void> superImpl);\n     }\n \n     /**\n",
    "added_lines": 14,
    "deleted_lines": 9,
    "changed_methods": ""
   },
   {
    "filename": "ActivityManagerService.java",
    "diff": "@@ -351,12 +351,10 @@ import com.android.internal.util.FastPrintWriter;\n import com.android.internal.util.FrameworkStatsLog;\n import com.android.internal.util.MemInfoReader;\n import com.android.internal.util.Preconditions;\n-import com.android.internal.util.function.DecFunction;\n import com.android.internal.util.function.HeptFunction;\n import com.android.internal.util.function.HexFunction;\n import com.android.internal.util.function.QuadFunction;\n import com.android.internal.util.function.QuintFunction;\n-import com.android.internal.util.function.TriFunction;\n import com.android.internal.util.function.UndecFunction;\n import com.android.server.AlarmManagerInternal;\n import com.android.server.DeviceIdleInternal;\n@@ -17128,19 +17126,20 @@ public class ActivityManagerService extends IActivityManager.Stub\n         }\n \n         @Override\n-        public SyncNotedAppOp startProxyOperation(int code,\n+        public SyncNotedAppOp startProxyOperation(@NonNull IBinder clientId, int code,\n                 @NonNull AttributionSource attributionSource, boolean startIfModeDefault,\n                 boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n                 boolean skipProxyOperation, @AttributionFlags int proxyAttributionFlags,\n                 @AttributionFlags int proxiedAttributionFlags, int attributionChainId,\n-                @NonNull DecFunction<Integer, AttributionSource, Boolean, Boolean, String, Boolean,\n-                        Boolean, Integer, Integer, Integer, SyncNotedAppOp> superImpl) {\n+                @NonNull UndecFunction<IBinder, Integer, AttributionSource,\n+                        Boolean, Boolean, String, Boolean, Boolean, Integer, Integer, Integer,\n+                        SyncNotedAppOp> superImpl) {\n             if (attributionSource.getUid() == mTargetUid && isTargetOp(code)) {\n                 final int shellUid = UserHandle.getUid(UserHandle.getUserId(\n                         attributionSource.getUid()), Process.SHELL_UID);\n                 final long identity = Binder.clearCallingIdentity();\n                 try {\n-                    return superImpl.apply(code, new AttributionSource(shellUid,\n+                    return superImpl.apply(clientId, code, new AttributionSource(shellUid,\n                             \"com.android.shell\", attributionSource.getAttributionTag(),\n                             attributionSource.getToken(), attributionSource.getNext()),\n                             startIfModeDefault, shouldCollectAsyncNotedOp, message,\n@@ -17150,21 +17149,22 @@ public class ActivityManagerService extends IActivityManager.Stub\n                     Binder.restoreCallingIdentity(identity);\n                 }\n             }\n-            return superImpl.apply(code, attributionSource, startIfModeDefault,\n+            return superImpl.apply(clientId, code, attributionSource, startIfModeDefault,\n                     shouldCollectAsyncNotedOp, message, shouldCollectMessage, skipProxyOperation,\n                     proxyAttributionFlags, proxiedAttributionFlags, attributionChainId);\n         }\n \n         @Override\n-        public void finishProxyOperation(int code, @NonNull AttributionSource attributionSource,\n-                boolean skipProxyOperation, @NonNull TriFunction<Integer, AttributionSource,\n-                        Boolean, Void> superImpl) {\n+        public void finishProxyOperation(@NonNull IBinder clientId, int code,\n+                @NonNull AttributionSource attributionSource, boolean skipProxyOperation,\n+                @NonNull QuadFunction<IBinder, Integer, AttributionSource, Boolean,\n+                        Void> superImpl) {\n             if (attributionSource.getUid() == mTargetUid && isTargetOp(code)) {\n                 final int shellUid = UserHandle.getUid(UserHandle.getUserId(\n                         attributionSource.getUid()), Process.SHELL_UID);\n                 final long identity = Binder.clearCallingIdentity();\n                 try {\n-                    superImpl.apply(code, new AttributionSource(shellUid,\n+                    superImpl.apply(clientId, code, new AttributionSource(shellUid,\n                             \"com.android.shell\", attributionSource.getAttributionTag(),\n                             attributionSource.getToken(), attributionSource.getNext()),\n                             skipProxyOperation);\n@@ -17172,7 +17172,7 @@ public class ActivityManagerService extends IActivityManager.Stub\n                     Binder.restoreCallingIdentity(identity);\n                 }\n             }\n-            superImpl.apply(code, attributionSource, skipProxyOperation);\n+            superImpl.apply(clientId, code, attributionSource, skipProxyOperation);\n         }\n \n         private boolean isTargetOp(int code) {\n",
    "added_lines": 12,
    "deleted_lines": 12,
    "changed_methods": "ActivityManagerService::ShellDelegate::finishProxyOperation, ActivityManagerService::ShellDelegate::startProxyOperation, ActivityManagerService::ShellDelegate::finishProxyOperation, ActivityManagerService::ShellDelegate::startProxyOperation"
   },
   {
    "filename": "AppOpsService.java",
    "diff": "@@ -3839,18 +3839,18 @@ public class AppOpsService extends IAppOpsService.Stub {\n     }\n \n     @Override\n-    public SyncNotedAppOp startProxyOperation(int code,\n+    public SyncNotedAppOp startProxyOperation(@NonNull IBinder clientId, int code,\n             @NonNull AttributionSource attributionSource, boolean startIfModeDefault,\n             boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n             boolean skipProxyOperation, @AttributionFlags int proxyAttributionFlags,\n             @AttributionFlags int proxiedAttributionFlags, int attributionChainId) {\n-        return mCheckOpsDelegateDispatcher.startProxyOperation(code, attributionSource,\n+        return mCheckOpsDelegateDispatcher.startProxyOperation(clientId, code, attributionSource,\n                 startIfModeDefault, shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                 skipProxyOperation, proxyAttributionFlags, proxiedAttributionFlags,\n                 attributionChainId);\n     }\n \n-    private SyncNotedAppOp startProxyOperationImpl(int code,\n+    private SyncNotedAppOp startProxyOperationImpl(@NonNull IBinder clientId, int code,\n             @NonNull AttributionSource attributionSource,\n             boolean startIfModeDefault, boolean shouldCollectAsyncNotedOp, String message,\n             boolean shouldCollectMessage, boolean skipProxyOperation, @AttributionFlags\n@@ -3859,11 +3859,9 @@ public class AppOpsService extends IAppOpsService.Stub {\n         final int proxyUid = attributionSource.getUid();\n         final String proxyPackageName = attributionSource.getPackageName();\n         final String proxyAttributionTag = attributionSource.getAttributionTag();\n-        final IBinder proxyToken = attributionSource.getToken();\n         final int proxiedUid = attributionSource.getNextUid();\n         final String proxiedPackageName = attributionSource.getNextPackageName();\n         final String proxiedAttributionTag = attributionSource.getNextAttributionTag();\n-        final IBinder proxiedToken = attributionSource.getNextToken();\n \n         verifyIncomingProxyUid(attributionSource);\n         verifyIncomingOp(code);\n@@ -3902,7 +3900,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n \n         if (!skipProxyOperation) {\n             // Test if the proxied operation will succeed before starting the proxy operation\n-            final SyncNotedAppOp testProxiedOp = startOperationUnchecked(proxiedToken, code,\n+            final SyncNotedAppOp testProxiedOp = startOperationUnchecked(clientId, code,\n                     proxiedUid, resolvedProxiedPackageName, proxiedAttributionTag, proxyUid,\n                     resolvedProxyPackageName, proxyAttributionTag, proxiedFlags, startIfModeDefault,\n                     shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n@@ -3914,7 +3912,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n             final int proxyFlags = isProxyTrusted ? AppOpsManager.OP_FLAG_TRUSTED_PROXY\n                     : AppOpsManager.OP_FLAG_UNTRUSTED_PROXY;\n \n-            final SyncNotedAppOp proxyAppOp = startOperationUnchecked(proxyToken, code, proxyUid,\n+            final SyncNotedAppOp proxyAppOp = startOperationUnchecked(clientId, code, proxyUid,\n                     resolvedProxyPackageName, proxyAttributionTag, Process.INVALID_UID, null, null,\n                     proxyFlags, startIfModeDefault, !isProxyTrusted, \"proxy \" + message,\n                     shouldCollectMessage, proxyAttributionFlags, attributionChainId,\n@@ -3924,7 +3922,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n             }\n         }\n \n-        return startOperationUnchecked(proxiedToken, code, proxiedUid, resolvedProxiedPackageName,\n+        return startOperationUnchecked(clientId, code, proxiedUid, resolvedProxiedPackageName,\n                 proxiedAttributionTag, proxyUid, resolvedProxyPackageName, proxyAttributionTag,\n                 proxiedFlags, startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                 shouldCollectMessage, proxiedAttributionFlags, attributionChainId,\n@@ -4065,22 +4063,20 @@ public class AppOpsService extends IAppOpsService.Stub {\n     }\n \n     @Override\n-    public void finishProxyOperation(int code, @NonNull AttributionSource attributionSource,\n-            boolean skipProxyOperation) {\n-        mCheckOpsDelegateDispatcher.finishProxyOperation(code, attributionSource,\n+    public void finishProxyOperation(@NonNull IBinder clientId, int code,\n+            @NonNull AttributionSource attributionSource, boolean skipProxyOperation) {\n+        mCheckOpsDelegateDispatcher.finishProxyOperation(clientId, code, attributionSource,\n                 skipProxyOperation);\n     }\n \n-    private Void finishProxyOperationImpl(int code, @NonNull AttributionSource attributionSource,\n-            boolean skipProxyOperation) {\n+    private Void finishProxyOperationImpl(IBinder clientId, int code,\n+            @NonNull AttributionSource attributionSource, boolean skipProxyOperation) {\n         final int proxyUid = attributionSource.getUid();\n         final String proxyPackageName = attributionSource.getPackageName();\n         final String proxyAttributionTag = attributionSource.getAttributionTag();\n-        final IBinder proxyToken = attributionSource.getToken();\n         final int proxiedUid = attributionSource.getNextUid();\n         final String proxiedPackageName = attributionSource.getNextPackageName();\n         final String proxiedAttributionTag = attributionSource.getNextAttributionTag();\n-        final IBinder proxiedToken = attributionSource.getNextToken();\n \n         skipProxyOperation = skipProxyOperation\n                 && isCallerAndAttributionTrusted(attributionSource);\n@@ -4097,7 +4093,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n         }\n \n         if (!skipProxyOperation) {\n-            finishOperationUnchecked(proxyToken, code, proxyUid, resolvedProxyPackageName,\n+            finishOperationUnchecked(clientId, code, proxyUid, resolvedProxyPackageName,\n                     proxyAttributionTag);\n         }\n \n@@ -4107,7 +4103,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n             return null;\n         }\n \n-        finishOperationUnchecked(proxiedToken, code, proxiedUid, resolvedProxiedPackageName,\n+        finishOperationUnchecked(clientId, code, proxiedUid, resolvedProxiedPackageName,\n                 proxiedAttributionTag);\n \n         return null;\n@@ -7642,42 +7638,42 @@ public class AppOpsService extends IAppOpsService.Stub {\n                     attributionFlags, attributionChainId, AppOpsService.this::startOperationImpl);\n         }\n \n-        public SyncNotedAppOp startProxyOperation(int code,\n+        public SyncNotedAppOp startProxyOperation(@NonNull IBinder clientId, int code,\n                 @NonNull AttributionSource attributionSource, boolean startIfModeDefault,\n                 boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n                 boolean skipProxyOperation, @AttributionFlags int proxyAttributionFlags,\n                 @AttributionFlags int proxiedAttributionFlags, int attributionChainId) {\n             if (mPolicy != null) {\n                 if (mCheckOpsDelegate != null) {\n-                    return mPolicy.startProxyOperation(code, attributionSource,\n+                    return mPolicy.startProxyOperation(clientId, code, attributionSource,\n                             startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                             shouldCollectMessage, skipProxyOperation, proxyAttributionFlags,\n                             proxiedAttributionFlags, attributionChainId,\n                             this::startDelegateProxyOperationImpl);\n                 } else {\n-                    return mPolicy.startProxyOperation(code, attributionSource,\n+                    return mPolicy.startProxyOperation(clientId, code, attributionSource,\n                             startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                             shouldCollectMessage, skipProxyOperation, proxyAttributionFlags,\n                             proxiedAttributionFlags, attributionChainId,\n                             AppOpsService.this::startProxyOperationImpl);\n                 }\n             } else if (mCheckOpsDelegate != null) {\n-                return startDelegateProxyOperationImpl(code, attributionSource,\n+                return startDelegateProxyOperationImpl(clientId, code, attributionSource,\n                         startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                         shouldCollectMessage, skipProxyOperation, proxyAttributionFlags,\n                         proxiedAttributionFlags, attributionChainId);\n             }\n-            return startProxyOperationImpl(code, attributionSource, startIfModeDefault,\n+            return startProxyOperationImpl(clientId, code, attributionSource, startIfModeDefault,\n                     shouldCollectAsyncNotedOp, message, shouldCollectMessage, skipProxyOperation,\n                     proxyAttributionFlags, proxiedAttributionFlags, attributionChainId);\n         }\n \n-        private SyncNotedAppOp startDelegateProxyOperationImpl(int code,\n+        private SyncNotedAppOp startDelegateProxyOperationImpl(@NonNull IBinder clientId, int code,\n                 @NonNull AttributionSource attributionSource, boolean startIfModeDefault,\n                 boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n                 boolean skipProxyOperation, @AttributionFlags int proxyAttributionFlags,\n                 @AttributionFlags int proxiedAttributionFlsgs, int attributionChainId) {\n-            return mCheckOpsDelegate.startProxyOperation(code, attributionSource,\n+            return mCheckOpsDelegate.startProxyOperation(clientId, code, attributionSource,\n                     startIfModeDefault, shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                     skipProxyOperation, proxyAttributionFlags, proxiedAttributionFlsgs,\n                     attributionChainId, AppOpsService.this::startProxyOperationImpl);\n@@ -7706,27 +7702,28 @@ public class AppOpsService extends IAppOpsService.Stub {\n                     AppOpsService.this::finishOperationImpl);\n         }\n \n-        public void finishProxyOperation(int code,\n+        public void finishProxyOperation(@NonNull IBinder clientId, int code,\n                 @NonNull AttributionSource attributionSource, boolean skipProxyOperation) {\n             if (mPolicy != null) {\n                 if (mCheckOpsDelegate != null) {\n-                    mPolicy.finishProxyOperation(code, attributionSource,\n+                    mPolicy.finishProxyOperation(clientId, code, attributionSource,\n                             skipProxyOperation, this::finishDelegateProxyOperationImpl);\n                 } else {\n-                    mPolicy.finishProxyOperation(code, attributionSource,\n+                    mPolicy.finishProxyOperation(clientId, code, attributionSource,\n                             skipProxyOperation, AppOpsService.this::finishProxyOperationImpl);\n                 }\n             } else if (mCheckOpsDelegate != null) {\n-                finishDelegateProxyOperationImpl(code, attributionSource, skipProxyOperation);\n+                finishDelegateProxyOperationImpl(clientId, code, attributionSource,\n+                        skipProxyOperation);\n             } else {\n-                finishProxyOperationImpl(code, attributionSource, skipProxyOperation);\n+                finishProxyOperationImpl(clientId, code, attributionSource, skipProxyOperation);\n             }\n         }\n \n-        private Void finishDelegateProxyOperationImpl(int code,\n+        private Void finishDelegateProxyOperationImpl(@NonNull IBinder clientId, int code,\n                 @NonNull AttributionSource attributionSource, boolean skipProxyOperation) {\n-            mCheckOpsDelegate.finishProxyOperation(code, attributionSource, skipProxyOperation,\n-                    AppOpsService.this::finishProxyOperationImpl);\n+            mCheckOpsDelegate.finishProxyOperation(clientId, code, attributionSource,\n+                    skipProxyOperation, AppOpsService.this::finishProxyOperationImpl);\n             return null;\n         }\n     }\n",
    "added_lines": 29,
    "deleted_lines": 32,
    "changed_methods": "AppOpsService::CheckOpsDelegateDispatcher::finishProxyOperation, AppOpsService::finishProxyOperationImpl, AppOpsService::CheckOpsDelegateDispatcher::startDelegateProxyOperationImpl, AppOpsService::CheckOpsDelegateDispatcher::startProxyOperation, AppOpsService::startProxyOperationImpl, AppOpsService::CheckOpsDelegateDispatcher::startProxyOperation, AppOpsService::startProxyOperation, AppOpsService::CheckOpsDelegateDispatcher::startDelegateProxyOperationImpl, AppOpsService::startProxyOperationImpl, AppOpsService::finishProxyOperation, AppOpsService::startProxyOperation, AppOpsService::CheckOpsDelegateDispatcher::finishProxyOperation, AppOpsService::CheckOpsDelegateDispatcher::finishDelegateProxyOperationImpl, AppOpsService::CheckOpsDelegateDispatcher::finishDelegateProxyOperationImpl, AppOpsService::finishProxyOperationImpl, AppOpsService::finishProxyOperation"
   },
   {
    "filename": "PermissionManagerService.java",
    "diff": "@@ -5650,7 +5650,7 @@ public class PermissionManagerService extends IPermissionManager.Stub {\n                     if (resolvedPackageName == null) {\n                         return;\n                     }\n-                    appOpsManager.finishOp(accessorSource.getToken(), op,\n+                    appOpsManager.finishOp(attributionSourceState.token, op,\n                             accessorSource.getUid(), resolvedPackageName,\n                             accessorSource.getAttributionTag());\n                 } else {\n@@ -5659,8 +5659,9 @@ public class PermissionManagerService extends IPermissionManager.Stub {\n                     if (resolvedAttributionSource.getPackageName() == null) {\n                         return;\n                     }\n-                    appOpsManager.finishProxyOp(AppOpsManager.opToPublicName(op),\n-                            resolvedAttributionSource, skipCurrentFinish);\n+                    appOpsManager.finishProxyOp(attributionSourceState.token,\n+                            AppOpsManager.opToPublicName(op), resolvedAttributionSource,\n+                            skipCurrentFinish);\n                 }\n \n                 if (next == null || next.getNext() == null) {\n@@ -5770,10 +5771,11 @@ public class PermissionManagerService extends IPermissionManager.Stub {\n                         && next.getNext() == null);\n                 final boolean selfAccess = singleReceiverFromDatasource || next == null;\n \n-                final int opMode = performOpTransaction(context, op, current, message,\n-                        forDataDelivery, /*startDataDelivery*/ false, skipCurrentChecks,\n-                        selfAccess, singleReceiverFromDatasource, AppOpsManager.OP_NONE,\n-                        AppOpsManager.ATTRIBUTION_FLAGS_NONE, AppOpsManager.ATTRIBUTION_FLAGS_NONE,\n+                final int opMode = performOpTransaction(context, attributionSource.getToken(), op,\n+                        current, message, forDataDelivery, /*startDataDelivery*/ false,\n+                        skipCurrentChecks, selfAccess, singleReceiverFromDatasource,\n+                        AppOpsManager.OP_NONE, AppOpsManager.ATTRIBUTION_FLAGS_NONE,\n+                        AppOpsManager.ATTRIBUTION_FLAGS_NONE,\n                         AppOpsManager.ATTRIBUTION_CHAIN_ID_NONE);\n \n                 switch (opMode) {\n@@ -5875,10 +5877,10 @@ public class PermissionManagerService extends IPermissionManager.Stub {\n                         attributionSource, next, fromDatasource, startDataDelivery, selfAccess,\n                         isLinkTrusted) : ATTRIBUTION_FLAGS_NONE;\n \n-                final int opMode = performOpTransaction(context, op, current, message,\n-                        forDataDelivery, startDataDelivery, skipCurrentChecks, selfAccess,\n-                        singleReceiverFromDatasource, attributedOp, proxyAttributionFlags,\n-                        proxiedAttributionFlags, attributionChainId);\n+                final int opMode = performOpTransaction(context, attributionSource.getToken(), op,\n+                        current, message, forDataDelivery, startDataDelivery, skipCurrentChecks,\n+                        selfAccess, singleReceiverFromDatasource, attributedOp,\n+                        proxyAttributionFlags, proxiedAttributionFlags, attributionChainId);\n \n                 switch (opMode) {\n                     case AppOpsManager.MODE_ERRORED: {\n@@ -6023,8 +6025,8 @@ public class PermissionManagerService extends IPermissionManager.Stub {\n                         attributionSource, next, /*fromDatasource*/ false, startDataDelivery,\n                         selfAccess, isLinkTrusted) : ATTRIBUTION_FLAGS_NONE;\n \n-                final int opMode = performOpTransaction(context, op, current, message,\n-                        forDataDelivery, startDataDelivery, skipCurrentChecks, selfAccess,\n+                final int opMode = performOpTransaction(context, current.getToken(), op, current,\n+                        message, forDataDelivery, startDataDelivery, skipCurrentChecks, selfAccess,\n                         /*fromDatasource*/ false, AppOpsManager.OP_NONE, proxyAttributionFlags,\n                         proxiedAttributionFlags, attributionChainId);\n \n@@ -6046,7 +6048,8 @@ public class PermissionManagerService extends IPermissionManager.Stub {\n         }\n \n         @SuppressWarnings(\"ConstantConditions\")\n-        private static int performOpTransaction(@NonNull Context context, int op,\n+        private static int performOpTransaction(@NonNull Context context,\n+                @NonNull IBinder chainStartToken, int op,\n                 @NonNull AttributionSource attributionSource, @Nullable String message,\n                 boolean forDataDelivery, boolean startDataDelivery, boolean skipProxyOperation,\n                 boolean selfAccess, boolean singleReceiverFromDatasource, int attributedOp,\n@@ -6108,7 +6111,7 @@ public class PermissionManagerService extends IPermissionManager.Stub {\n                 if (selfAccess) {\n                     try {\n                         startedOpResult = appOpsManager.startOpNoThrow(\n-                                resolvedAttributionSource.getToken(), startedOp,\n+                                chainStartToken, startedOp,\n                                 resolvedAttributionSource.getUid(),\n                                 resolvedAttributionSource.getPackageName(),\n                                 /*startIfModeDefault*/ false,\n@@ -6119,12 +6122,12 @@ public class PermissionManagerService extends IPermissionManager.Stub {\n                                 + \" platform defined runtime permission \"\n                                 + AppOpsManager.opToPermission(op) + \" while not having \"\n                                 + Manifest.permission.UPDATE_APP_OPS_STATS);\n-                        startedOpResult = appOpsManager.startProxyOpNoThrow(attributedOp,\n-                                attributionSource, message, skipProxyOperation,\n+                        startedOpResult = appOpsManager.startProxyOpNoThrow(chainStartToken,\n+                                attributedOp, attributionSource, message, skipProxyOperation,\n                                 proxyAttributionFlags, proxiedAttributionFlags, attributionChainId);\n                     }\n                 } else {\n-                    startedOpResult = appOpsManager.startProxyOpNoThrow(startedOp,\n+                    startedOpResult = appOpsManager.startProxyOpNoThrow(chainStartToken, startedOp,\n                             resolvedAttributionSource, message, skipProxyOperation,\n                             proxyAttributionFlags, proxiedAttributionFlags, attributionChainId);\n                 }\n",
    "added_lines": 21,
    "deleted_lines": 18,
    "changed_methods": "PermissionManagerService::PermissionCheckerService::finishDataDelivery, PermissionManagerService::PermissionCheckerService::checkRuntimePermission, PermissionManagerService::PermissionCheckerService::checkAppOpPermission, PermissionManagerService::PermissionCheckerService::performOpTransaction, PermissionManagerService::PermissionCheckerService::checkOp, PermissionManagerService::PermissionCheckerService::performOpTransaction"
   },
   {
    "filename": "AppOpsPolicy.java",
    "diff": "@@ -44,13 +44,11 @@ import android.util.Log;\n import android.util.SparseArray;\n \n import com.android.internal.annotations.GuardedBy;\n-import com.android.internal.util.function.DecFunction;\n import com.android.internal.util.function.HeptFunction;\n import com.android.internal.util.function.HexFunction;\n import com.android.internal.util.function.QuadFunction;\n import com.android.internal.util.function.QuintConsumer;\n import com.android.internal.util.function.QuintFunction;\n-import com.android.internal.util.function.TriFunction;\n import com.android.internal.util.function.UndecFunction;\n import com.android.server.LocalServices;\n \n@@ -255,14 +253,14 @@ public final class AppOpsPolicy implements AppOpsManagerInternal.CheckOpsDelegat\n     }\n \n     @Override\n-    public SyncNotedAppOp startProxyOperation(int code,\n+    public SyncNotedAppOp startProxyOperation(@NonNull IBinder clientId, int code,\n             @NonNull AttributionSource attributionSource, boolean startIfModeDefault,\n             boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n             boolean skipProxyOperation, @AttributionFlags int proxyAttributionFlags,\n             @AttributionFlags int proxiedAttributionFlags, int attributionChainId,\n-            @NonNull DecFunction<Integer, AttributionSource, Boolean, Boolean, String, Boolean,\n-                    Boolean, Integer, Integer, Integer, SyncNotedAppOp> superImpl) {\n-        return superImpl.apply(resolveDatasourceOp(code, attributionSource.getUid(),\n+            @NonNull UndecFunction<IBinder, Integer, AttributionSource, Boolean, Boolean, String,\n+                    Boolean, Boolean, Integer, Integer, Integer, SyncNotedAppOp> superImpl) {\n+        return superImpl.apply(clientId, resolveDatasourceOp(code, attributionSource.getUid(),\n                 attributionSource.getPackageName(), attributionSource.getAttributionTag()),\n                 attributionSource, startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                 shouldCollectMessage, skipProxyOperation, proxyAttributionFlags,\n@@ -278,10 +276,10 @@ public final class AppOpsPolicy implements AppOpsManagerInternal.CheckOpsDelegat\n     }\n \n     @Override\n-    public void finishProxyOperation(int code, @NonNull AttributionSource attributionSource,\n-            boolean skipProxyOperation, @NonNull TriFunction<Integer, AttributionSource,\n-            Boolean, Void> superImpl) {\n-        superImpl.apply(resolveDatasourceOp(code, attributionSource.getUid(),\n+    public void finishProxyOperation(@NonNull IBinder clientId, int code,\n+            @NonNull AttributionSource attributionSource, boolean skipProxyOperation,\n+            @NonNull QuadFunction<IBinder, Integer, AttributionSource, Boolean, Void> superImpl) {\n+        superImpl.apply(clientId, resolveDatasourceOp(code, attributionSource.getUid(),\n                 attributionSource.getPackageName(), attributionSource.getAttributionTag()),\n                 attributionSource, skipProxyOperation);\n     }\n",
    "added_lines": 8,
    "deleted_lines": 10,
    "changed_methods": "AppOpsPolicy::startProxyOperation, AppOpsPolicy::finishProxyOperation, AppOpsPolicy::finishProxyOperation, AppOpsPolicy::startProxyOperation"
   }
  ]
 },
 {
  "hash": "693e82f72cdf40d65a151c24e9168f345ee551af",
  "commit": "RESTRICT AUTOMERGE Use chain start token in performOpTransaction\n\nBug: 258672042\nTest: atest CtsPermission4TestCases\nChange-Id: I1d484ed7c72d4ae73f4cbec47522a18ae9088f6e\n(cherry picked from commit 9d09846798bce7253ed1202adb61257d4eefbd1d)\nMerged-In: I1d484ed7c72d4ae73f4cbec47522a18ae9088f6e",
  "files": [
   {
    "filename": "AppOpsManager.java",
    "diff": "@@ -8888,8 +8888,9 @@ public class AppOpsManager {\n      */\n     public int startProxyOpNoThrow(int op, @NonNull AttributionSource attributionSource,\n             @Nullable String message, boolean skipProxyOperation) {\n-        return startProxyOpNoThrow(op, attributionSource, message, skipProxyOperation,\n-                ATTRIBUTION_FLAGS_NONE, ATTRIBUTION_FLAGS_NONE, ATTRIBUTION_CHAIN_ID_NONE);\n+        return startProxyOpNoThrow(attributionSource.getToken(), op, attributionSource, message,\n+                skipProxyOperation, ATTRIBUTION_FLAGS_NONE, ATTRIBUTION_FLAGS_NONE,\n+                ATTRIBUTION_CHAIN_ID_NONE);\n     }\n \n     /**\n@@ -8901,7 +8902,8 @@ public class AppOpsManager {\n      *\n      * @hide\n      */\n-    public int startProxyOpNoThrow(int op, @NonNull AttributionSource attributionSource,\n+    public int startProxyOpNoThrow(@NonNull IBinder clientId, int op,\n+            @NonNull AttributionSource attributionSource,\n             @Nullable String message, boolean skipProxyOperation, @AttributionFlags\n             int proxyAttributionFlags, @AttributionFlags int proxiedAttributionFlags,\n             int attributionChainId) {\n@@ -8919,7 +8921,7 @@ public class AppOpsManager {\n                 }\n             }\n \n-            SyncNotedAppOp syncOp = mService.startProxyOperation(op,\n+            SyncNotedAppOp syncOp = mService.startProxyOperation(clientId, op,\n                     attributionSource, false, collectionMode == COLLECT_ASYNC, message,\n                     shouldCollectMessage, skipProxyOperation, proxyAttributionFlags,\n                     proxiedAttributionFlags, attributionChainId);\n@@ -9017,9 +9019,10 @@ public class AppOpsManager {\n      */\n     public void finishProxyOp(@NonNull String op, int proxiedUid,\n             @NonNull String proxiedPackageName, @Nullable String proxiedAttributionTag) {\n-        finishProxyOp(op, new AttributionSource(mContext.getAttributionSource(),\n+        IBinder token = mContext.getAttributionSource().getToken();\n+        finishProxyOp(token, op, new AttributionSource(mContext.getAttributionSource(),\n                 new AttributionSource(proxiedUid, proxiedPackageName,  proxiedAttributionTag,\n-                        mContext.getAttributionSource().getToken())), /*skipProxyOperation*/ false);\n+                        token)), /*skipProxyOperation*/ false);\n     }\n \n     /**\n@@ -9034,10 +9037,11 @@ public class AppOpsManager {\n      *\n      * @hide\n      */\n-    public void finishProxyOp(@NonNull String op, @NonNull AttributionSource attributionSource,\n-            boolean skipProxyOperation) {\n+    public void finishProxyOp(@NonNull IBinder clientId, @NonNull String op,\n+            @NonNull AttributionSource attributionSource, boolean skipProxyOperation) {\n         try {\n-            mService.finishProxyOperation(strOpToOp(op), attributionSource, skipProxyOperation);\n+            mService.finishProxyOperation(clientId, strOpToOp(op), attributionSource,\n+                    skipProxyOperation);\n         } catch (RemoteException e) {\n             throw e.rethrowFromSystemServer();\n         }\n",
    "added_lines": 13,
    "deleted_lines": 9,
    "changed_methods": "AppOpsManager::startProxyOpNoThrow, AppOpsManager::startProxyOpNoThrow, AppOpsManager::startProxyOpNoThrow, AppOpsManager::finishProxyOp, AppOpsManager::finishProxyOp, AppOpsManager::finishProxyOp"
   },
   {
    "filename": "AppOpsManagerInternal.java",
    "diff": "@@ -26,13 +26,11 @@ import android.util.SparseArray;\n import android.util.SparseIntArray;\n \n import com.android.internal.app.IAppOpsCallback;\n-import com.android.internal.util.function.DecFunction;\n import com.android.internal.util.function.HeptFunction;\n import com.android.internal.util.function.HexFunction;\n import com.android.internal.util.function.QuadFunction;\n import com.android.internal.util.function.QuintConsumer;\n import com.android.internal.util.function.QuintFunction;\n-import com.android.internal.util.function.TriFunction;\n import com.android.internal.util.function.UndecFunction;\n \n /**\n@@ -135,6 +133,7 @@ public abstract class AppOpsManagerInternal {\n         /**\n          * Allows overriding start proxy operation behavior.\n          *\n+         * @param clientId The client calling start, represented by an IBinder\n          * @param code The op code to start.\n          * @param attributionSource The permission identity of the caller.\n          * @param startIfModeDefault Whether to start the op of the mode is default.\n@@ -148,11 +147,12 @@ public abstract class AppOpsManagerInternal {\n          * @param superImpl The super implementation.\n          * @return The app op note result.\n          */\n-        SyncNotedAppOp startProxyOperation(int code, @NonNull AttributionSource attributionSource,\n-                boolean startIfModeDefault, boolean shouldCollectAsyncNotedOp, String message,\n-                boolean shouldCollectMessage, boolean skipProxyOperation, @AttributionFlags\n-                int proxyAttributionFlags, @AttributionFlags int proxiedAttributionFlags,\n-                int attributionChainId, @NonNull DecFunction<Integer, AttributionSource, Boolean,\n+        SyncNotedAppOp startProxyOperation(@NonNull IBinder clientId, int code,\n+                @NonNull AttributionSource attributionSource, boolean startIfModeDefault,\n+                boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n+                boolean skipProxyOperation, @AttributionFlags int proxyAttributionFlags,\n+                @AttributionFlags int proxiedAttributionFlags, int attributionChainId,\n+                @NonNull UndecFunction<IBinder, Integer, AttributionSource, Boolean,\n                         Boolean, String, Boolean, Boolean, Integer, Integer, Integer,\n                         SyncNotedAppOp> superImpl);\n \n@@ -176,10 +176,15 @@ public abstract class AppOpsManagerInternal {\n          *\n          * @param code The op code to finish.\n          * @param attributionSource The permission identity of the caller.\n+         * @param skipProxyOperation Whether to skip the proxy in the proxy/proxied operation\n+         * @param clientId The client calling finishProxyOperation\n+         * @param superImpl The \"standard\" implementation to potentially call\n          */\n-        void finishProxyOperation(int code, @NonNull AttributionSource attributionSource,\n+        void finishProxyOperation(@NonNull IBinder clientId, int code,\n+                @NonNull AttributionSource attributionSource,\n                 boolean skipProxyOperation,\n-                @NonNull TriFunction<Integer, AttributionSource, Boolean, Void> superImpl);\n+                @NonNull QuadFunction<IBinder, Integer, AttributionSource, Boolean,\n+                        Void> superImpl);\n     }\n \n     /**\n",
    "added_lines": 14,
    "deleted_lines": 9,
    "changed_methods": ""
   },
   {
    "filename": "ActivityManagerService.java",
    "diff": "@@ -351,12 +351,10 @@ import com.android.internal.util.FastPrintWriter;\n import com.android.internal.util.FrameworkStatsLog;\n import com.android.internal.util.MemInfoReader;\n import com.android.internal.util.Preconditions;\n-import com.android.internal.util.function.DecFunction;\n import com.android.internal.util.function.HeptFunction;\n import com.android.internal.util.function.HexFunction;\n import com.android.internal.util.function.QuadFunction;\n import com.android.internal.util.function.QuintFunction;\n-import com.android.internal.util.function.TriFunction;\n import com.android.internal.util.function.UndecFunction;\n import com.android.server.AlarmManagerInternal;\n import com.android.server.DeviceIdleInternal;\n@@ -17128,19 +17126,20 @@ public class ActivityManagerService extends IActivityManager.Stub\n         }\n \n         @Override\n-        public SyncNotedAppOp startProxyOperation(int code,\n+        public SyncNotedAppOp startProxyOperation(@NonNull IBinder clientId, int code,\n                 @NonNull AttributionSource attributionSource, boolean startIfModeDefault,\n                 boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n                 boolean skipProxyOperation, @AttributionFlags int proxyAttributionFlags,\n                 @AttributionFlags int proxiedAttributionFlags, int attributionChainId,\n-                @NonNull DecFunction<Integer, AttributionSource, Boolean, Boolean, String, Boolean,\n-                        Boolean, Integer, Integer, Integer, SyncNotedAppOp> superImpl) {\n+                @NonNull UndecFunction<IBinder, Integer, AttributionSource,\n+                        Boolean, Boolean, String, Boolean, Boolean, Integer, Integer, Integer,\n+                        SyncNotedAppOp> superImpl) {\n             if (attributionSource.getUid() == mTargetUid && isTargetOp(code)) {\n                 final int shellUid = UserHandle.getUid(UserHandle.getUserId(\n                         attributionSource.getUid()), Process.SHELL_UID);\n                 final long identity = Binder.clearCallingIdentity();\n                 try {\n-                    return superImpl.apply(code, new AttributionSource(shellUid,\n+                    return superImpl.apply(clientId, code, new AttributionSource(shellUid,\n                             \"com.android.shell\", attributionSource.getAttributionTag(),\n                             attributionSource.getToken(), attributionSource.getNext()),\n                             startIfModeDefault, shouldCollectAsyncNotedOp, message,\n@@ -17150,21 +17149,22 @@ public class ActivityManagerService extends IActivityManager.Stub\n                     Binder.restoreCallingIdentity(identity);\n                 }\n             }\n-            return superImpl.apply(code, attributionSource, startIfModeDefault,\n+            return superImpl.apply(clientId, code, attributionSource, startIfModeDefault,\n                     shouldCollectAsyncNotedOp, message, shouldCollectMessage, skipProxyOperation,\n                     proxyAttributionFlags, proxiedAttributionFlags, attributionChainId);\n         }\n \n         @Override\n-        public void finishProxyOperation(int code, @NonNull AttributionSource attributionSource,\n-                boolean skipProxyOperation, @NonNull TriFunction<Integer, AttributionSource,\n-                        Boolean, Void> superImpl) {\n+        public void finishProxyOperation(@NonNull IBinder clientId, int code,\n+                @NonNull AttributionSource attributionSource, boolean skipProxyOperation,\n+                @NonNull QuadFunction<IBinder, Integer, AttributionSource, Boolean,\n+                        Void> superImpl) {\n             if (attributionSource.getUid() == mTargetUid && isTargetOp(code)) {\n                 final int shellUid = UserHandle.getUid(UserHandle.getUserId(\n                         attributionSource.getUid()), Process.SHELL_UID);\n                 final long identity = Binder.clearCallingIdentity();\n                 try {\n-                    superImpl.apply(code, new AttributionSource(shellUid,\n+                    superImpl.apply(clientId, code, new AttributionSource(shellUid,\n                             \"com.android.shell\", attributionSource.getAttributionTag(),\n                             attributionSource.getToken(), attributionSource.getNext()),\n                             skipProxyOperation);\n@@ -17172,7 +17172,7 @@ public class ActivityManagerService extends IActivityManager.Stub\n                     Binder.restoreCallingIdentity(identity);\n                 }\n             }\n-            superImpl.apply(code, attributionSource, skipProxyOperation);\n+            superImpl.apply(clientId, code, attributionSource, skipProxyOperation);\n         }\n \n         private boolean isTargetOp(int code) {\n",
    "added_lines": 12,
    "deleted_lines": 12,
    "changed_methods": "ActivityManagerService::ShellDelegate::finishProxyOperation, ActivityManagerService::ShellDelegate::startProxyOperation, ActivityManagerService::ShellDelegate::finishProxyOperation, ActivityManagerService::ShellDelegate::startProxyOperation"
   },
   {
    "filename": "AppOpsService.java",
    "diff": "@@ -3839,18 +3839,18 @@ public class AppOpsService extends IAppOpsService.Stub {\n     }\n \n     @Override\n-    public SyncNotedAppOp startProxyOperation(int code,\n+    public SyncNotedAppOp startProxyOperation(@NonNull IBinder clientId, int code,\n             @NonNull AttributionSource attributionSource, boolean startIfModeDefault,\n             boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n             boolean skipProxyOperation, @AttributionFlags int proxyAttributionFlags,\n             @AttributionFlags int proxiedAttributionFlags, int attributionChainId) {\n-        return mCheckOpsDelegateDispatcher.startProxyOperation(code, attributionSource,\n+        return mCheckOpsDelegateDispatcher.startProxyOperation(clientId, code, attributionSource,\n                 startIfModeDefault, shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                 skipProxyOperation, proxyAttributionFlags, proxiedAttributionFlags,\n                 attributionChainId);\n     }\n \n-    private SyncNotedAppOp startProxyOperationImpl(int code,\n+    private SyncNotedAppOp startProxyOperationImpl(@NonNull IBinder clientId, int code,\n             @NonNull AttributionSource attributionSource,\n             boolean startIfModeDefault, boolean shouldCollectAsyncNotedOp, String message,\n             boolean shouldCollectMessage, boolean skipProxyOperation, @AttributionFlags\n@@ -3859,11 +3859,9 @@ public class AppOpsService extends IAppOpsService.Stub {\n         final int proxyUid = attributionSource.getUid();\n         final String proxyPackageName = attributionSource.getPackageName();\n         final String proxyAttributionTag = attributionSource.getAttributionTag();\n-        final IBinder proxyToken = attributionSource.getToken();\n         final int proxiedUid = attributionSource.getNextUid();\n         final String proxiedPackageName = attributionSource.getNextPackageName();\n         final String proxiedAttributionTag = attributionSource.getNextAttributionTag();\n-        final IBinder proxiedToken = attributionSource.getNextToken();\n \n         verifyIncomingProxyUid(attributionSource);\n         verifyIncomingOp(code);\n@@ -3902,7 +3900,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n \n         if (!skipProxyOperation) {\n             // Test if the proxied operation will succeed before starting the proxy operation\n-            final SyncNotedAppOp testProxiedOp = startOperationUnchecked(proxiedToken, code,\n+            final SyncNotedAppOp testProxiedOp = startOperationUnchecked(clientId, code,\n                     proxiedUid, resolvedProxiedPackageName, proxiedAttributionTag, proxyUid,\n                     resolvedProxyPackageName, proxyAttributionTag, proxiedFlags, startIfModeDefault,\n                     shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n@@ -3914,7 +3912,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n             final int proxyFlags = isProxyTrusted ? AppOpsManager.OP_FLAG_TRUSTED_PROXY\n                     : AppOpsManager.OP_FLAG_UNTRUSTED_PROXY;\n \n-            final SyncNotedAppOp proxyAppOp = startOperationUnchecked(proxyToken, code, proxyUid,\n+            final SyncNotedAppOp proxyAppOp = startOperationUnchecked(clientId, code, proxyUid,\n                     resolvedProxyPackageName, proxyAttributionTag, Process.INVALID_UID, null, null,\n                     proxyFlags, startIfModeDefault, !isProxyTrusted, \"proxy \" + message,\n                     shouldCollectMessage, proxyAttributionFlags, attributionChainId,\n@@ -3924,7 +3922,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n             }\n         }\n \n-        return startOperationUnchecked(proxiedToken, code, proxiedUid, resolvedProxiedPackageName,\n+        return startOperationUnchecked(clientId, code, proxiedUid, resolvedProxiedPackageName,\n                 proxiedAttributionTag, proxyUid, resolvedProxyPackageName, proxyAttributionTag,\n                 proxiedFlags, startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                 shouldCollectMessage, proxiedAttributionFlags, attributionChainId,\n@@ -4065,22 +4063,20 @@ public class AppOpsService extends IAppOpsService.Stub {\n     }\n \n     @Override\n-    public void finishProxyOperation(int code, @NonNull AttributionSource attributionSource,\n-            boolean skipProxyOperation) {\n-        mCheckOpsDelegateDispatcher.finishProxyOperation(code, attributionSource,\n+    public void finishProxyOperation(@NonNull IBinder clientId, int code,\n+            @NonNull AttributionSource attributionSource, boolean skipProxyOperation) {\n+        mCheckOpsDelegateDispatcher.finishProxyOperation(clientId, code, attributionSource,\n                 skipProxyOperation);\n     }\n \n-    private Void finishProxyOperationImpl(int code, @NonNull AttributionSource attributionSource,\n-            boolean skipProxyOperation) {\n+    private Void finishProxyOperationImpl(IBinder clientId, int code,\n+            @NonNull AttributionSource attributionSource, boolean skipProxyOperation) {\n         final int proxyUid = attributionSource.getUid();\n         final String proxyPackageName = attributionSource.getPackageName();\n         final String proxyAttributionTag = attributionSource.getAttributionTag();\n-        final IBinder proxyToken = attributionSource.getToken();\n         final int proxiedUid = attributionSource.getNextUid();\n         final String proxiedPackageName = attributionSource.getNextPackageName();\n         final String proxiedAttributionTag = attributionSource.getNextAttributionTag();\n-        final IBinder proxiedToken = attributionSource.getNextToken();\n \n         skipProxyOperation = skipProxyOperation\n                 && isCallerAndAttributionTrusted(attributionSource);\n@@ -4097,7 +4093,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n         }\n \n         if (!skipProxyOperation) {\n-            finishOperationUnchecked(proxyToken, code, proxyUid, resolvedProxyPackageName,\n+            finishOperationUnchecked(clientId, code, proxyUid, resolvedProxyPackageName,\n                     proxyAttributionTag);\n         }\n \n@@ -4107,7 +4103,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n             return null;\n         }\n \n-        finishOperationUnchecked(proxiedToken, code, proxiedUid, resolvedProxiedPackageName,\n+        finishOperationUnchecked(clientId, code, proxiedUid, resolvedProxiedPackageName,\n                 proxiedAttributionTag);\n \n         return null;\n@@ -7642,42 +7638,42 @@ public class AppOpsService extends IAppOpsService.Stub {\n                     attributionFlags, attributionChainId, AppOpsService.this::startOperationImpl);\n         }\n \n-        public SyncNotedAppOp startProxyOperation(int code,\n+        public SyncNotedAppOp startProxyOperation(@NonNull IBinder clientId, int code,\n                 @NonNull AttributionSource attributionSource, boolean startIfModeDefault,\n                 boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n                 boolean skipProxyOperation, @AttributionFlags int proxyAttributionFlags,\n                 @AttributionFlags int proxiedAttributionFlags, int attributionChainId) {\n             if (mPolicy != null) {\n                 if (mCheckOpsDelegate != null) {\n-                    return mPolicy.startProxyOperation(code, attributionSource,\n+                    return mPolicy.startProxyOperation(clientId, code, attributionSource,\n                             startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                             shouldCollectMessage, skipProxyOperation, proxyAttributionFlags,\n                             proxiedAttributionFlags, attributionChainId,\n                             this::startDelegateProxyOperationImpl);\n                 } else {\n-                    return mPolicy.startProxyOperation(code, attributionSource,\n+                    return mPolicy.startProxyOperation(clientId, code, attributionSource,\n                             startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                             shouldCollectMessage, skipProxyOperation, proxyAttributionFlags,\n                             proxiedAttributionFlags, attributionChainId,\n                             AppOpsService.this::startProxyOperationImpl);\n                 }\n             } else if (mCheckOpsDelegate != null) {\n-                return startDelegateProxyOperationImpl(code, attributionSource,\n+                return startDelegateProxyOperationImpl(clientId, code, attributionSource,\n                         startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                         shouldCollectMessage, skipProxyOperation, proxyAttributionFlags,\n                         proxiedAttributionFlags, attributionChainId);\n             }\n-            return startProxyOperationImpl(code, attributionSource, startIfModeDefault,\n+            return startProxyOperationImpl(clientId, code, attributionSource, startIfModeDefault,\n                     shouldCollectAsyncNotedOp, message, shouldCollectMessage, skipProxyOperation,\n                     proxyAttributionFlags, proxiedAttributionFlags, attributionChainId);\n         }\n \n-        private SyncNotedAppOp startDelegateProxyOperationImpl(int code,\n+        private SyncNotedAppOp startDelegateProxyOperationImpl(@NonNull IBinder clientId, int code,\n                 @NonNull AttributionSource attributionSource, boolean startIfModeDefault,\n                 boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n                 boolean skipProxyOperation, @AttributionFlags int proxyAttributionFlags,\n                 @AttributionFlags int proxiedAttributionFlsgs, int attributionChainId) {\n-            return mCheckOpsDelegate.startProxyOperation(code, attributionSource,\n+            return mCheckOpsDelegate.startProxyOperation(clientId, code, attributionSource,\n                     startIfModeDefault, shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                     skipProxyOperation, proxyAttributionFlags, proxiedAttributionFlsgs,\n                     attributionChainId, AppOpsService.this::startProxyOperationImpl);\n@@ -7706,27 +7702,28 @@ public class AppOpsService extends IAppOpsService.Stub {\n                     AppOpsService.this::finishOperationImpl);\n         }\n \n-        public void finishProxyOperation(int code,\n+        public void finishProxyOperation(@NonNull IBinder clientId, int code,\n                 @NonNull AttributionSource attributionSource, boolean skipProxyOperation) {\n             if (mPolicy != null) {\n                 if (mCheckOpsDelegate != null) {\n-                    mPolicy.finishProxyOperation(code, attributionSource,\n+                    mPolicy.finishProxyOperation(clientId, code, attributionSource,\n                             skipProxyOperation, this::finishDelegateProxyOperationImpl);\n                 } else {\n-                    mPolicy.finishProxyOperation(code, attributionSource,\n+                    mPolicy.finishProxyOperation(clientId, code, attributionSource,\n                             skipProxyOperation, AppOpsService.this::finishProxyOperationImpl);\n                 }\n             } else if (mCheckOpsDelegate != null) {\n-                finishDelegateProxyOperationImpl(code, attributionSource, skipProxyOperation);\n+                finishDelegateProxyOperationImpl(clientId, code, attributionSource,\n+                        skipProxyOperation);\n             } else {\n-                finishProxyOperationImpl(code, attributionSource, skipProxyOperation);\n+                finishProxyOperationImpl(clientId, code, attributionSource, skipProxyOperation);\n             }\n         }\n \n-        private Void finishDelegateProxyOperationImpl(int code,\n+        private Void finishDelegateProxyOperationImpl(@NonNull IBinder clientId, int code,\n                 @NonNull AttributionSource attributionSource, boolean skipProxyOperation) {\n-            mCheckOpsDelegate.finishProxyOperation(code, attributionSource, skipProxyOperation,\n-                    AppOpsService.this::finishProxyOperationImpl);\n+            mCheckOpsDelegate.finishProxyOperation(clientId, code, attributionSource,\n+                    skipProxyOperation, AppOpsService.this::finishProxyOperationImpl);\n             return null;\n         }\n     }\n",
    "added_lines": 29,
    "deleted_lines": 32,
    "changed_methods": "AppOpsService::CheckOpsDelegateDispatcher::finishProxyOperation, AppOpsService::finishProxyOperationImpl, AppOpsService::CheckOpsDelegateDispatcher::startDelegateProxyOperationImpl, AppOpsService::CheckOpsDelegateDispatcher::startProxyOperation, AppOpsService::startProxyOperationImpl, AppOpsService::CheckOpsDelegateDispatcher::startProxyOperation, AppOpsService::startProxyOperation, AppOpsService::CheckOpsDelegateDispatcher::startDelegateProxyOperationImpl, AppOpsService::startProxyOperationImpl, AppOpsService::finishProxyOperation, AppOpsService::startProxyOperation, AppOpsService::CheckOpsDelegateDispatcher::finishProxyOperation, AppOpsService::CheckOpsDelegateDispatcher::finishDelegateProxyOperationImpl, AppOpsService::CheckOpsDelegateDispatcher::finishDelegateProxyOperationImpl, AppOpsService::finishProxyOperationImpl, AppOpsService::finishProxyOperation"
   },
   {
    "filename": "PermissionManagerService.java",
    "diff": "@@ -5650,7 +5650,7 @@ public class PermissionManagerService extends IPermissionManager.Stub {\n                     if (resolvedPackageName == null) {\n                         return;\n                     }\n-                    appOpsManager.finishOp(accessorSource.getToken(), op,\n+                    appOpsManager.finishOp(attributionSourceState.token, op,\n                             accessorSource.getUid(), resolvedPackageName,\n                             accessorSource.getAttributionTag());\n                 } else {\n@@ -5659,8 +5659,9 @@ public class PermissionManagerService extends IPermissionManager.Stub {\n                     if (resolvedAttributionSource.getPackageName() == null) {\n                         return;\n                     }\n-                    appOpsManager.finishProxyOp(AppOpsManager.opToPublicName(op),\n-                            resolvedAttributionSource, skipCurrentFinish);\n+                    appOpsManager.finishProxyOp(attributionSourceState.token,\n+                            AppOpsManager.opToPublicName(op), resolvedAttributionSource,\n+                            skipCurrentFinish);\n                 }\n \n                 if (next == null || next.getNext() == null) {\n@@ -5770,10 +5771,11 @@ public class PermissionManagerService extends IPermissionManager.Stub {\n                         && next.getNext() == null);\n                 final boolean selfAccess = singleReceiverFromDatasource || next == null;\n \n-                final int opMode = performOpTransaction(context, op, current, message,\n-                        forDataDelivery, /*startDataDelivery*/ false, skipCurrentChecks,\n-                        selfAccess, singleReceiverFromDatasource, AppOpsManager.OP_NONE,\n-                        AppOpsManager.ATTRIBUTION_FLAGS_NONE, AppOpsManager.ATTRIBUTION_FLAGS_NONE,\n+                final int opMode = performOpTransaction(context, attributionSource.getToken(), op,\n+                        current, message, forDataDelivery, /*startDataDelivery*/ false,\n+                        skipCurrentChecks, selfAccess, singleReceiverFromDatasource,\n+                        AppOpsManager.OP_NONE, AppOpsManager.ATTRIBUTION_FLAGS_NONE,\n+                        AppOpsManager.ATTRIBUTION_FLAGS_NONE,\n                         AppOpsManager.ATTRIBUTION_CHAIN_ID_NONE);\n \n                 switch (opMode) {\n@@ -5875,10 +5877,10 @@ public class PermissionManagerService extends IPermissionManager.Stub {\n                         attributionSource, next, fromDatasource, startDataDelivery, selfAccess,\n                         isLinkTrusted) : ATTRIBUTION_FLAGS_NONE;\n \n-                final int opMode = performOpTransaction(context, op, current, message,\n-                        forDataDelivery, startDataDelivery, skipCurrentChecks, selfAccess,\n-                        singleReceiverFromDatasource, attributedOp, proxyAttributionFlags,\n-                        proxiedAttributionFlags, attributionChainId);\n+                final int opMode = performOpTransaction(context, attributionSource.getToken(), op,\n+                        current, message, forDataDelivery, startDataDelivery, skipCurrentChecks,\n+                        selfAccess, singleReceiverFromDatasource, attributedOp,\n+                        proxyAttributionFlags, proxiedAttributionFlags, attributionChainId);\n \n                 switch (opMode) {\n                     case AppOpsManager.MODE_ERRORED: {\n@@ -6023,8 +6025,8 @@ public class PermissionManagerService extends IPermissionManager.Stub {\n                         attributionSource, next, /*fromDatasource*/ false, startDataDelivery,\n                         selfAccess, isLinkTrusted) : ATTRIBUTION_FLAGS_NONE;\n \n-                final int opMode = performOpTransaction(context, op, current, message,\n-                        forDataDelivery, startDataDelivery, skipCurrentChecks, selfAccess,\n+                final int opMode = performOpTransaction(context, current.getToken(), op, current,\n+                        message, forDataDelivery, startDataDelivery, skipCurrentChecks, selfAccess,\n                         /*fromDatasource*/ false, AppOpsManager.OP_NONE, proxyAttributionFlags,\n                         proxiedAttributionFlags, attributionChainId);\n \n@@ -6046,7 +6048,8 @@ public class PermissionManagerService extends IPermissionManager.Stub {\n         }\n \n         @SuppressWarnings(\"ConstantConditions\")\n-        private static int performOpTransaction(@NonNull Context context, int op,\n+        private static int performOpTransaction(@NonNull Context context,\n+                @NonNull IBinder chainStartToken, int op,\n                 @NonNull AttributionSource attributionSource, @Nullable String message,\n                 boolean forDataDelivery, boolean startDataDelivery, boolean skipProxyOperation,\n                 boolean selfAccess, boolean singleReceiverFromDatasource, int attributedOp,\n@@ -6108,7 +6111,7 @@ public class PermissionManagerService extends IPermissionManager.Stub {\n                 if (selfAccess) {\n                     try {\n                         startedOpResult = appOpsManager.startOpNoThrow(\n-                                resolvedAttributionSource.getToken(), startedOp,\n+                                chainStartToken, startedOp,\n                                 resolvedAttributionSource.getUid(),\n                                 resolvedAttributionSource.getPackageName(),\n                                 /*startIfModeDefault*/ false,\n@@ -6119,12 +6122,12 @@ public class PermissionManagerService extends IPermissionManager.Stub {\n                                 + \" platform defined runtime permission \"\n                                 + AppOpsManager.opToPermission(op) + \" while not having \"\n                                 + Manifest.permission.UPDATE_APP_OPS_STATS);\n-                        startedOpResult = appOpsManager.startProxyOpNoThrow(attributedOp,\n-                                attributionSource, message, skipProxyOperation,\n+                        startedOpResult = appOpsManager.startProxyOpNoThrow(chainStartToken,\n+                                attributedOp, attributionSource, message, skipProxyOperation,\n                                 proxyAttributionFlags, proxiedAttributionFlags, attributionChainId);\n                     }\n                 } else {\n-                    startedOpResult = appOpsManager.startProxyOpNoThrow(startedOp,\n+                    startedOpResult = appOpsManager.startProxyOpNoThrow(chainStartToken, startedOp,\n                             resolvedAttributionSource, message, skipProxyOperation,\n                             proxyAttributionFlags, proxiedAttributionFlags, attributionChainId);\n                 }\n",
    "added_lines": 21,
    "deleted_lines": 18,
    "changed_methods": "PermissionManagerService::PermissionCheckerService::finishDataDelivery, PermissionManagerService::PermissionCheckerService::checkRuntimePermission, PermissionManagerService::PermissionCheckerService::checkAppOpPermission, PermissionManagerService::PermissionCheckerService::performOpTransaction, PermissionManagerService::PermissionCheckerService::checkOp, PermissionManagerService::PermissionCheckerService::performOpTransaction"
   },
   {
    "filename": "AppOpsPolicy.java",
    "diff": "@@ -44,13 +44,11 @@ import android.util.Log;\n import android.util.SparseArray;\n \n import com.android.internal.annotations.GuardedBy;\n-import com.android.internal.util.function.DecFunction;\n import com.android.internal.util.function.HeptFunction;\n import com.android.internal.util.function.HexFunction;\n import com.android.internal.util.function.QuadFunction;\n import com.android.internal.util.function.QuintConsumer;\n import com.android.internal.util.function.QuintFunction;\n-import com.android.internal.util.function.TriFunction;\n import com.android.internal.util.function.UndecFunction;\n import com.android.server.LocalServices;\n \n@@ -255,14 +253,14 @@ public final class AppOpsPolicy implements AppOpsManagerInternal.CheckOpsDelegat\n     }\n \n     @Override\n-    public SyncNotedAppOp startProxyOperation(int code,\n+    public SyncNotedAppOp startProxyOperation(@NonNull IBinder clientId, int code,\n             @NonNull AttributionSource attributionSource, boolean startIfModeDefault,\n             boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n             boolean skipProxyOperation, @AttributionFlags int proxyAttributionFlags,\n             @AttributionFlags int proxiedAttributionFlags, int attributionChainId,\n-            @NonNull DecFunction<Integer, AttributionSource, Boolean, Boolean, String, Boolean,\n-                    Boolean, Integer, Integer, Integer, SyncNotedAppOp> superImpl) {\n-        return superImpl.apply(resolveDatasourceOp(code, attributionSource.getUid(),\n+            @NonNull UndecFunction<IBinder, Integer, AttributionSource, Boolean, Boolean, String,\n+                    Boolean, Boolean, Integer, Integer, Integer, SyncNotedAppOp> superImpl) {\n+        return superImpl.apply(clientId, resolveDatasourceOp(code, attributionSource.getUid(),\n                 attributionSource.getPackageName(), attributionSource.getAttributionTag()),\n                 attributionSource, startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                 shouldCollectMessage, skipProxyOperation, proxyAttributionFlags,\n@@ -278,10 +276,10 @@ public final class AppOpsPolicy implements AppOpsManagerInternal.CheckOpsDelegat\n     }\n \n     @Override\n-    public void finishProxyOperation(int code, @NonNull AttributionSource attributionSource,\n-            boolean skipProxyOperation, @NonNull TriFunction<Integer, AttributionSource,\n-            Boolean, Void> superImpl) {\n-        superImpl.apply(resolveDatasourceOp(code, attributionSource.getUid(),\n+    public void finishProxyOperation(@NonNull IBinder clientId, int code,\n+            @NonNull AttributionSource attributionSource, boolean skipProxyOperation,\n+            @NonNull QuadFunction<IBinder, Integer, AttributionSource, Boolean, Void> superImpl) {\n+        superImpl.apply(clientId, resolveDatasourceOp(code, attributionSource.getUid(),\n                 attributionSource.getPackageName(), attributionSource.getAttributionTag()),\n                 attributionSource, skipProxyOperation);\n     }\n",
    "added_lines": 8,
    "deleted_lines": 10,
    "changed_methods": "AppOpsPolicy::startProxyOperation, AppOpsPolicy::finishProxyOperation, AppOpsPolicy::finishProxyOperation, AppOpsPolicy::startProxyOperation"
   }
  ]
 },
 {
  "hash": "693e82f72cdf40d65a151c24e9168f345ee551af",
  "commit": "RESTRICT AUTOMERGE Use chain start token in performOpTransaction\n\nBug: 258672042\nTest: atest CtsPermission4TestCases\nChange-Id: I1d484ed7c72d4ae73f4cbec47522a18ae9088f6e\n(cherry picked from commit 9d09846798bce7253ed1202adb61257d4eefbd1d)\nMerged-In: I1d484ed7c72d4ae73f4cbec47522a18ae9088f6e",
  "files": [
   {
    "filename": "AppOpsManager.java",
    "diff": "@@ -8888,8 +8888,9 @@ public class AppOpsManager {\n      */\n     public int startProxyOpNoThrow(int op, @NonNull AttributionSource attributionSource,\n             @Nullable String message, boolean skipProxyOperation) {\n-        return startProxyOpNoThrow(op, attributionSource, message, skipProxyOperation,\n-                ATTRIBUTION_FLAGS_NONE, ATTRIBUTION_FLAGS_NONE, ATTRIBUTION_CHAIN_ID_NONE);\n+        return startProxyOpNoThrow(attributionSource.getToken(), op, attributionSource, message,\n+                skipProxyOperation, ATTRIBUTION_FLAGS_NONE, ATTRIBUTION_FLAGS_NONE,\n+                ATTRIBUTION_CHAIN_ID_NONE);\n     }\n \n     /**\n@@ -8901,7 +8902,8 @@ public class AppOpsManager {\n      *\n      * @hide\n      */\n-    public int startProxyOpNoThrow(int op, @NonNull AttributionSource attributionSource,\n+    public int startProxyOpNoThrow(@NonNull IBinder clientId, int op,\n+            @NonNull AttributionSource attributionSource,\n             @Nullable String message, boolean skipProxyOperation, @AttributionFlags\n             int proxyAttributionFlags, @AttributionFlags int proxiedAttributionFlags,\n             int attributionChainId) {\n@@ -8919,7 +8921,7 @@ public class AppOpsManager {\n                 }\n             }\n \n-            SyncNotedAppOp syncOp = mService.startProxyOperation(op,\n+            SyncNotedAppOp syncOp = mService.startProxyOperation(clientId, op,\n                     attributionSource, false, collectionMode == COLLECT_ASYNC, message,\n                     shouldCollectMessage, skipProxyOperation, proxyAttributionFlags,\n                     proxiedAttributionFlags, attributionChainId);\n@@ -9017,9 +9019,10 @@ public class AppOpsManager {\n      */\n     public void finishProxyOp(@NonNull String op, int proxiedUid,\n             @NonNull String proxiedPackageName, @Nullable String proxiedAttributionTag) {\n-        finishProxyOp(op, new AttributionSource(mContext.getAttributionSource(),\n+        IBinder token = mContext.getAttributionSource().getToken();\n+        finishProxyOp(token, op, new AttributionSource(mContext.getAttributionSource(),\n                 new AttributionSource(proxiedUid, proxiedPackageName,  proxiedAttributionTag,\n-                        mContext.getAttributionSource().getToken())), /*skipProxyOperation*/ false);\n+                        token)), /*skipProxyOperation*/ false);\n     }\n \n     /**\n@@ -9034,10 +9037,11 @@ public class AppOpsManager {\n      *\n      * @hide\n      */\n-    public void finishProxyOp(@NonNull String op, @NonNull AttributionSource attributionSource,\n-            boolean skipProxyOperation) {\n+    public void finishProxyOp(@NonNull IBinder clientId, @NonNull String op,\n+            @NonNull AttributionSource attributionSource, boolean skipProxyOperation) {\n         try {\n-            mService.finishProxyOperation(strOpToOp(op), attributionSource, skipProxyOperation);\n+            mService.finishProxyOperation(clientId, strOpToOp(op), attributionSource,\n+                    skipProxyOperation);\n         } catch (RemoteException e) {\n             throw e.rethrowFromSystemServer();\n         }\n",
    "added_lines": 13,
    "deleted_lines": 9,
    "changed_methods": "AppOpsManager::startProxyOpNoThrow, AppOpsManager::startProxyOpNoThrow, AppOpsManager::startProxyOpNoThrow, AppOpsManager::finishProxyOp, AppOpsManager::finishProxyOp, AppOpsManager::finishProxyOp"
   },
   {
    "filename": "AppOpsManagerInternal.java",
    "diff": "@@ -26,13 +26,11 @@ import android.util.SparseArray;\n import android.util.SparseIntArray;\n \n import com.android.internal.app.IAppOpsCallback;\n-import com.android.internal.util.function.DecFunction;\n import com.android.internal.util.function.HeptFunction;\n import com.android.internal.util.function.HexFunction;\n import com.android.internal.util.function.QuadFunction;\n import com.android.internal.util.function.QuintConsumer;\n import com.android.internal.util.function.QuintFunction;\n-import com.android.internal.util.function.TriFunction;\n import com.android.internal.util.function.UndecFunction;\n \n /**\n@@ -135,6 +133,7 @@ public abstract class AppOpsManagerInternal {\n         /**\n          * Allows overriding start proxy operation behavior.\n          *\n+         * @param clientId The client calling start, represented by an IBinder\n          * @param code The op code to start.\n          * @param attributionSource The permission identity of the caller.\n          * @param startIfModeDefault Whether to start the op of the mode is default.\n@@ -148,11 +147,12 @@ public abstract class AppOpsManagerInternal {\n          * @param superImpl The super implementation.\n          * @return The app op note result.\n          */\n-        SyncNotedAppOp startProxyOperation(int code, @NonNull AttributionSource attributionSource,\n-                boolean startIfModeDefault, boolean shouldCollectAsyncNotedOp, String message,\n-                boolean shouldCollectMessage, boolean skipProxyOperation, @AttributionFlags\n-                int proxyAttributionFlags, @AttributionFlags int proxiedAttributionFlags,\n-                int attributionChainId, @NonNull DecFunction<Integer, AttributionSource, Boolean,\n+        SyncNotedAppOp startProxyOperation(@NonNull IBinder clientId, int code,\n+                @NonNull AttributionSource attributionSource, boolean startIfModeDefault,\n+                boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n+                boolean skipProxyOperation, @AttributionFlags int proxyAttributionFlags,\n+                @AttributionFlags int proxiedAttributionFlags, int attributionChainId,\n+                @NonNull UndecFunction<IBinder, Integer, AttributionSource, Boolean,\n                         Boolean, String, Boolean, Boolean, Integer, Integer, Integer,\n                         SyncNotedAppOp> superImpl);\n \n@@ -176,10 +176,15 @@ public abstract class AppOpsManagerInternal {\n          *\n          * @param code The op code to finish.\n          * @param attributionSource The permission identity of the caller.\n+         * @param skipProxyOperation Whether to skip the proxy in the proxy/proxied operation\n+         * @param clientId The client calling finishProxyOperation\n+         * @param superImpl The \"standard\" implementation to potentially call\n          */\n-        void finishProxyOperation(int code, @NonNull AttributionSource attributionSource,\n+        void finishProxyOperation(@NonNull IBinder clientId, int code,\n+                @NonNull AttributionSource attributionSource,\n                 boolean skipProxyOperation,\n-                @NonNull TriFunction<Integer, AttributionSource, Boolean, Void> superImpl);\n+                @NonNull QuadFunction<IBinder, Integer, AttributionSource, Boolean,\n+                        Void> superImpl);\n     }\n \n     /**\n",
    "added_lines": 14,
    "deleted_lines": 9,
    "changed_methods": ""
   },
   {
    "filename": "ActivityManagerService.java",
    "diff": "@@ -351,12 +351,10 @@ import com.android.internal.util.FastPrintWriter;\n import com.android.internal.util.FrameworkStatsLog;\n import com.android.internal.util.MemInfoReader;\n import com.android.internal.util.Preconditions;\n-import com.android.internal.util.function.DecFunction;\n import com.android.internal.util.function.HeptFunction;\n import com.android.internal.util.function.HexFunction;\n import com.android.internal.util.function.QuadFunction;\n import com.android.internal.util.function.QuintFunction;\n-import com.android.internal.util.function.TriFunction;\n import com.android.internal.util.function.UndecFunction;\n import com.android.server.AlarmManagerInternal;\n import com.android.server.DeviceIdleInternal;\n@@ -17128,19 +17126,20 @@ public class ActivityManagerService extends IActivityManager.Stub\n         }\n \n         @Override\n-        public SyncNotedAppOp startProxyOperation(int code,\n+        public SyncNotedAppOp startProxyOperation(@NonNull IBinder clientId, int code,\n                 @NonNull AttributionSource attributionSource, boolean startIfModeDefault,\n                 boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n                 boolean skipProxyOperation, @AttributionFlags int proxyAttributionFlags,\n                 @AttributionFlags int proxiedAttributionFlags, int attributionChainId,\n-                @NonNull DecFunction<Integer, AttributionSource, Boolean, Boolean, String, Boolean,\n-                        Boolean, Integer, Integer, Integer, SyncNotedAppOp> superImpl) {\n+                @NonNull UndecFunction<IBinder, Integer, AttributionSource,\n+                        Boolean, Boolean, String, Boolean, Boolean, Integer, Integer, Integer,\n+                        SyncNotedAppOp> superImpl) {\n             if (attributionSource.getUid() == mTargetUid && isTargetOp(code)) {\n                 final int shellUid = UserHandle.getUid(UserHandle.getUserId(\n                         attributionSource.getUid()), Process.SHELL_UID);\n                 final long identity = Binder.clearCallingIdentity();\n                 try {\n-                    return superImpl.apply(code, new AttributionSource(shellUid,\n+                    return superImpl.apply(clientId, code, new AttributionSource(shellUid,\n                             \"com.android.shell\", attributionSource.getAttributionTag(),\n                             attributionSource.getToken(), attributionSource.getNext()),\n                             startIfModeDefault, shouldCollectAsyncNotedOp, message,\n@@ -17150,21 +17149,22 @@ public class ActivityManagerService extends IActivityManager.Stub\n                     Binder.restoreCallingIdentity(identity);\n                 }\n             }\n-            return superImpl.apply(code, attributionSource, startIfModeDefault,\n+            return superImpl.apply(clientId, code, attributionSource, startIfModeDefault,\n                     shouldCollectAsyncNotedOp, message, shouldCollectMessage, skipProxyOperation,\n                     proxyAttributionFlags, proxiedAttributionFlags, attributionChainId);\n         }\n \n         @Override\n-        public void finishProxyOperation(int code, @NonNull AttributionSource attributionSource,\n-                boolean skipProxyOperation, @NonNull TriFunction<Integer, AttributionSource,\n-                        Boolean, Void> superImpl) {\n+        public void finishProxyOperation(@NonNull IBinder clientId, int code,\n+                @NonNull AttributionSource attributionSource, boolean skipProxyOperation,\n+                @NonNull QuadFunction<IBinder, Integer, AttributionSource, Boolean,\n+                        Void> superImpl) {\n             if (attributionSource.getUid() == mTargetUid && isTargetOp(code)) {\n                 final int shellUid = UserHandle.getUid(UserHandle.getUserId(\n                         attributionSource.getUid()), Process.SHELL_UID);\n                 final long identity = Binder.clearCallingIdentity();\n                 try {\n-                    superImpl.apply(code, new AttributionSource(shellUid,\n+                    superImpl.apply(clientId, code, new AttributionSource(shellUid,\n                             \"com.android.shell\", attributionSource.getAttributionTag(),\n                             attributionSource.getToken(), attributionSource.getNext()),\n                             skipProxyOperation);\n@@ -17172,7 +17172,7 @@ public class ActivityManagerService extends IActivityManager.Stub\n                     Binder.restoreCallingIdentity(identity);\n                 }\n             }\n-            superImpl.apply(code, attributionSource, skipProxyOperation);\n+            superImpl.apply(clientId, code, attributionSource, skipProxyOperation);\n         }\n \n         private boolean isTargetOp(int code) {\n",
    "added_lines": 12,
    "deleted_lines": 12,
    "changed_methods": "ActivityManagerService::ShellDelegate::finishProxyOperation, ActivityManagerService::ShellDelegate::startProxyOperation, ActivityManagerService::ShellDelegate::finishProxyOperation, ActivityManagerService::ShellDelegate::startProxyOperation"
   },
   {
    "filename": "AppOpsService.java",
    "diff": "@@ -3839,18 +3839,18 @@ public class AppOpsService extends IAppOpsService.Stub {\n     }\n \n     @Override\n-    public SyncNotedAppOp startProxyOperation(int code,\n+    public SyncNotedAppOp startProxyOperation(@NonNull IBinder clientId, int code,\n             @NonNull AttributionSource attributionSource, boolean startIfModeDefault,\n             boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n             boolean skipProxyOperation, @AttributionFlags int proxyAttributionFlags,\n             @AttributionFlags int proxiedAttributionFlags, int attributionChainId) {\n-        return mCheckOpsDelegateDispatcher.startProxyOperation(code, attributionSource,\n+        return mCheckOpsDelegateDispatcher.startProxyOperation(clientId, code, attributionSource,\n                 startIfModeDefault, shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                 skipProxyOperation, proxyAttributionFlags, proxiedAttributionFlags,\n                 attributionChainId);\n     }\n \n-    private SyncNotedAppOp startProxyOperationImpl(int code,\n+    private SyncNotedAppOp startProxyOperationImpl(@NonNull IBinder clientId, int code,\n             @NonNull AttributionSource attributionSource,\n             boolean startIfModeDefault, boolean shouldCollectAsyncNotedOp, String message,\n             boolean shouldCollectMessage, boolean skipProxyOperation, @AttributionFlags\n@@ -3859,11 +3859,9 @@ public class AppOpsService extends IAppOpsService.Stub {\n         final int proxyUid = attributionSource.getUid();\n         final String proxyPackageName = attributionSource.getPackageName();\n         final String proxyAttributionTag = attributionSource.getAttributionTag();\n-        final IBinder proxyToken = attributionSource.getToken();\n         final int proxiedUid = attributionSource.getNextUid();\n         final String proxiedPackageName = attributionSource.getNextPackageName();\n         final String proxiedAttributionTag = attributionSource.getNextAttributionTag();\n-        final IBinder proxiedToken = attributionSource.getNextToken();\n \n         verifyIncomingProxyUid(attributionSource);\n         verifyIncomingOp(code);\n@@ -3902,7 +3900,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n \n         if (!skipProxyOperation) {\n             // Test if the proxied operation will succeed before starting the proxy operation\n-            final SyncNotedAppOp testProxiedOp = startOperationUnchecked(proxiedToken, code,\n+            final SyncNotedAppOp testProxiedOp = startOperationUnchecked(clientId, code,\n                     proxiedUid, resolvedProxiedPackageName, proxiedAttributionTag, proxyUid,\n                     resolvedProxyPackageName, proxyAttributionTag, proxiedFlags, startIfModeDefault,\n                     shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n@@ -3914,7 +3912,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n             final int proxyFlags = isProxyTrusted ? AppOpsManager.OP_FLAG_TRUSTED_PROXY\n                     : AppOpsManager.OP_FLAG_UNTRUSTED_PROXY;\n \n-            final SyncNotedAppOp proxyAppOp = startOperationUnchecked(proxyToken, code, proxyUid,\n+            final SyncNotedAppOp proxyAppOp = startOperationUnchecked(clientId, code, proxyUid,\n                     resolvedProxyPackageName, proxyAttributionTag, Process.INVALID_UID, null, null,\n                     proxyFlags, startIfModeDefault, !isProxyTrusted, \"proxy \" + message,\n                     shouldCollectMessage, proxyAttributionFlags, attributionChainId,\n@@ -3924,7 +3922,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n             }\n         }\n \n-        return startOperationUnchecked(proxiedToken, code, proxiedUid, resolvedProxiedPackageName,\n+        return startOperationUnchecked(clientId, code, proxiedUid, resolvedProxiedPackageName,\n                 proxiedAttributionTag, proxyUid, resolvedProxyPackageName, proxyAttributionTag,\n                 proxiedFlags, startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                 shouldCollectMessage, proxiedAttributionFlags, attributionChainId,\n@@ -4065,22 +4063,20 @@ public class AppOpsService extends IAppOpsService.Stub {\n     }\n \n     @Override\n-    public void finishProxyOperation(int code, @NonNull AttributionSource attributionSource,\n-            boolean skipProxyOperation) {\n-        mCheckOpsDelegateDispatcher.finishProxyOperation(code, attributionSource,\n+    public void finishProxyOperation(@NonNull IBinder clientId, int code,\n+            @NonNull AttributionSource attributionSource, boolean skipProxyOperation) {\n+        mCheckOpsDelegateDispatcher.finishProxyOperation(clientId, code, attributionSource,\n                 skipProxyOperation);\n     }\n \n-    private Void finishProxyOperationImpl(int code, @NonNull AttributionSource attributionSource,\n-            boolean skipProxyOperation) {\n+    private Void finishProxyOperationImpl(IBinder clientId, int code,\n+            @NonNull AttributionSource attributionSource, boolean skipProxyOperation) {\n         final int proxyUid = attributionSource.getUid();\n         final String proxyPackageName = attributionSource.getPackageName();\n         final String proxyAttributionTag = attributionSource.getAttributionTag();\n-        final IBinder proxyToken = attributionSource.getToken();\n         final int proxiedUid = attributionSource.getNextUid();\n         final String proxiedPackageName = attributionSource.getNextPackageName();\n         final String proxiedAttributionTag = attributionSource.getNextAttributionTag();\n-        final IBinder proxiedToken = attributionSource.getNextToken();\n \n         skipProxyOperation = skipProxyOperation\n                 && isCallerAndAttributionTrusted(attributionSource);\n@@ -4097,7 +4093,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n         }\n \n         if (!skipProxyOperation) {\n-            finishOperationUnchecked(proxyToken, code, proxyUid, resolvedProxyPackageName,\n+            finishOperationUnchecked(clientId, code, proxyUid, resolvedProxyPackageName,\n                     proxyAttributionTag);\n         }\n \n@@ -4107,7 +4103,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n             return null;\n         }\n \n-        finishOperationUnchecked(proxiedToken, code, proxiedUid, resolvedProxiedPackageName,\n+        finishOperationUnchecked(clientId, code, proxiedUid, resolvedProxiedPackageName,\n                 proxiedAttributionTag);\n \n         return null;\n@@ -7642,42 +7638,42 @@ public class AppOpsService extends IAppOpsService.Stub {\n                     attributionFlags, attributionChainId, AppOpsService.this::startOperationImpl);\n         }\n \n-        public SyncNotedAppOp startProxyOperation(int code,\n+        public SyncNotedAppOp startProxyOperation(@NonNull IBinder clientId, int code,\n                 @NonNull AttributionSource attributionSource, boolean startIfModeDefault,\n                 boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n                 boolean skipProxyOperation, @AttributionFlags int proxyAttributionFlags,\n                 @AttributionFlags int proxiedAttributionFlags, int attributionChainId) {\n             if (mPolicy != null) {\n                 if (mCheckOpsDelegate != null) {\n-                    return mPolicy.startProxyOperation(code, attributionSource,\n+                    return mPolicy.startProxyOperation(clientId, code, attributionSource,\n                             startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                             shouldCollectMessage, skipProxyOperation, proxyAttributionFlags,\n                             proxiedAttributionFlags, attributionChainId,\n                             this::startDelegateProxyOperationImpl);\n                 } else {\n-                    return mPolicy.startProxyOperation(code, attributionSource,\n+                    return mPolicy.startProxyOperation(clientId, code, attributionSource,\n                             startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                             shouldCollectMessage, skipProxyOperation, proxyAttributionFlags,\n                             proxiedAttributionFlags, attributionChainId,\n                             AppOpsService.this::startProxyOperationImpl);\n                 }\n             } else if (mCheckOpsDelegate != null) {\n-                return startDelegateProxyOperationImpl(code, attributionSource,\n+                return startDelegateProxyOperationImpl(clientId, code, attributionSource,\n                         startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                         shouldCollectMessage, skipProxyOperation, proxyAttributionFlags,\n                         proxiedAttributionFlags, attributionChainId);\n             }\n-            return startProxyOperationImpl(code, attributionSource, startIfModeDefault,\n+            return startProxyOperationImpl(clientId, code, attributionSource, startIfModeDefault,\n                     shouldCollectAsyncNotedOp, message, shouldCollectMessage, skipProxyOperation,\n                     proxyAttributionFlags, proxiedAttributionFlags, attributionChainId);\n         }\n \n-        private SyncNotedAppOp startDelegateProxyOperationImpl(int code,\n+        private SyncNotedAppOp startDelegateProxyOperationImpl(@NonNull IBinder clientId, int code,\n                 @NonNull AttributionSource attributionSource, boolean startIfModeDefault,\n                 boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n                 boolean skipProxyOperation, @AttributionFlags int proxyAttributionFlags,\n                 @AttributionFlags int proxiedAttributionFlsgs, int attributionChainId) {\n-            return mCheckOpsDelegate.startProxyOperation(code, attributionSource,\n+            return mCheckOpsDelegate.startProxyOperation(clientId, code, attributionSource,\n                     startIfModeDefault, shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                     skipProxyOperation, proxyAttributionFlags, proxiedAttributionFlsgs,\n                     attributionChainId, AppOpsService.this::startProxyOperationImpl);\n@@ -7706,27 +7702,28 @@ public class AppOpsService extends IAppOpsService.Stub {\n                     AppOpsService.this::finishOperationImpl);\n         }\n \n-        public void finishProxyOperation(int code,\n+        public void finishProxyOperation(@NonNull IBinder clientId, int code,\n                 @NonNull AttributionSource attributionSource, boolean skipProxyOperation) {\n             if (mPolicy != null) {\n                 if (mCheckOpsDelegate != null) {\n-                    mPolicy.finishProxyOperation(code, attributionSource,\n+                    mPolicy.finishProxyOperation(clientId, code, attributionSource,\n                             skipProxyOperation, this::finishDelegateProxyOperationImpl);\n                 } else {\n-                    mPolicy.finishProxyOperation(code, attributionSource,\n+                    mPolicy.finishProxyOperation(clientId, code, attributionSource,\n                             skipProxyOperation, AppOpsService.this::finishProxyOperationImpl);\n                 }\n             } else if (mCheckOpsDelegate != null) {\n-                finishDelegateProxyOperationImpl(code, attributionSource, skipProxyOperation);\n+                finishDelegateProxyOperationImpl(clientId, code, attributionSource,\n+                        skipProxyOperation);\n             } else {\n-                finishProxyOperationImpl(code, attributionSource, skipProxyOperation);\n+                finishProxyOperationImpl(clientId, code, attributionSource, skipProxyOperation);\n             }\n         }\n \n-        private Void finishDelegateProxyOperationImpl(int code,\n+        private Void finishDelegateProxyOperationImpl(@NonNull IBinder clientId, int code,\n                 @NonNull AttributionSource attributionSource, boolean skipProxyOperation) {\n-            mCheckOpsDelegate.finishProxyOperation(code, attributionSource, skipProxyOperation,\n-                    AppOpsService.this::finishProxyOperationImpl);\n+            mCheckOpsDelegate.finishProxyOperation(clientId, code, attributionSource,\n+                    skipProxyOperation, AppOpsService.this::finishProxyOperationImpl);\n             return null;\n         }\n     }\n",
    "added_lines": 29,
    "deleted_lines": 32,
    "changed_methods": "AppOpsService::CheckOpsDelegateDispatcher::finishProxyOperation, AppOpsService::finishProxyOperationImpl, AppOpsService::CheckOpsDelegateDispatcher::startDelegateProxyOperationImpl, AppOpsService::CheckOpsDelegateDispatcher::startProxyOperation, AppOpsService::startProxyOperationImpl, AppOpsService::CheckOpsDelegateDispatcher::startProxyOperation, AppOpsService::startProxyOperation, AppOpsService::CheckOpsDelegateDispatcher::startDelegateProxyOperationImpl, AppOpsService::startProxyOperationImpl, AppOpsService::finishProxyOperation, AppOpsService::startProxyOperation, AppOpsService::CheckOpsDelegateDispatcher::finishProxyOperation, AppOpsService::CheckOpsDelegateDispatcher::finishDelegateProxyOperationImpl, AppOpsService::CheckOpsDelegateDispatcher::finishDelegateProxyOperationImpl, AppOpsService::finishProxyOperationImpl, AppOpsService::finishProxyOperation"
   },
   {
    "filename": "PermissionManagerService.java",
    "diff": "@@ -5650,7 +5650,7 @@ public class PermissionManagerService extends IPermissionManager.Stub {\n                     if (resolvedPackageName == null) {\n                         return;\n                     }\n-                    appOpsManager.finishOp(accessorSource.getToken(), op,\n+                    appOpsManager.finishOp(attributionSourceState.token, op,\n                             accessorSource.getUid(), resolvedPackageName,\n                             accessorSource.getAttributionTag());\n                 } else {\n@@ -5659,8 +5659,9 @@ public class PermissionManagerService extends IPermissionManager.Stub {\n                     if (resolvedAttributionSource.getPackageName() == null) {\n                         return;\n                     }\n-                    appOpsManager.finishProxyOp(AppOpsManager.opToPublicName(op),\n-                            resolvedAttributionSource, skipCurrentFinish);\n+                    appOpsManager.finishProxyOp(attributionSourceState.token,\n+                            AppOpsManager.opToPublicName(op), resolvedAttributionSource,\n+                            skipCurrentFinish);\n                 }\n \n                 if (next == null || next.getNext() == null) {\n@@ -5770,10 +5771,11 @@ public class PermissionManagerService extends IPermissionManager.Stub {\n                         && next.getNext() == null);\n                 final boolean selfAccess = singleReceiverFromDatasource || next == null;\n \n-                final int opMode = performOpTransaction(context, op, current, message,\n-                        forDataDelivery, /*startDataDelivery*/ false, skipCurrentChecks,\n-                        selfAccess, singleReceiverFromDatasource, AppOpsManager.OP_NONE,\n-                        AppOpsManager.ATTRIBUTION_FLAGS_NONE, AppOpsManager.ATTRIBUTION_FLAGS_NONE,\n+                final int opMode = performOpTransaction(context, attributionSource.getToken(), op,\n+                        current, message, forDataDelivery, /*startDataDelivery*/ false,\n+                        skipCurrentChecks, selfAccess, singleReceiverFromDatasource,\n+                        AppOpsManager.OP_NONE, AppOpsManager.ATTRIBUTION_FLAGS_NONE,\n+                        AppOpsManager.ATTRIBUTION_FLAGS_NONE,\n                         AppOpsManager.ATTRIBUTION_CHAIN_ID_NONE);\n \n                 switch (opMode) {\n@@ -5875,10 +5877,10 @@ public class PermissionManagerService extends IPermissionManager.Stub {\n                         attributionSource, next, fromDatasource, startDataDelivery, selfAccess,\n                         isLinkTrusted) : ATTRIBUTION_FLAGS_NONE;\n \n-                final int opMode = performOpTransaction(context, op, current, message,\n-                        forDataDelivery, startDataDelivery, skipCurrentChecks, selfAccess,\n-                        singleReceiverFromDatasource, attributedOp, proxyAttributionFlags,\n-                        proxiedAttributionFlags, attributionChainId);\n+                final int opMode = performOpTransaction(context, attributionSource.getToken(), op,\n+                        current, message, forDataDelivery, startDataDelivery, skipCurrentChecks,\n+                        selfAccess, singleReceiverFromDatasource, attributedOp,\n+                        proxyAttributionFlags, proxiedAttributionFlags, attributionChainId);\n \n                 switch (opMode) {\n                     case AppOpsManager.MODE_ERRORED: {\n@@ -6023,8 +6025,8 @@ public class PermissionManagerService extends IPermissionManager.Stub {\n                         attributionSource, next, /*fromDatasource*/ false, startDataDelivery,\n                         selfAccess, isLinkTrusted) : ATTRIBUTION_FLAGS_NONE;\n \n-                final int opMode = performOpTransaction(context, op, current, message,\n-                        forDataDelivery, startDataDelivery, skipCurrentChecks, selfAccess,\n+                final int opMode = performOpTransaction(context, current.getToken(), op, current,\n+                        message, forDataDelivery, startDataDelivery, skipCurrentChecks, selfAccess,\n                         /*fromDatasource*/ false, AppOpsManager.OP_NONE, proxyAttributionFlags,\n                         proxiedAttributionFlags, attributionChainId);\n \n@@ -6046,7 +6048,8 @@ public class PermissionManagerService extends IPermissionManager.Stub {\n         }\n \n         @SuppressWarnings(\"ConstantConditions\")\n-        private static int performOpTransaction(@NonNull Context context, int op,\n+        private static int performOpTransaction(@NonNull Context context,\n+                @NonNull IBinder chainStartToken, int op,\n                 @NonNull AttributionSource attributionSource, @Nullable String message,\n                 boolean forDataDelivery, boolean startDataDelivery, boolean skipProxyOperation,\n                 boolean selfAccess, boolean singleReceiverFromDatasource, int attributedOp,\n@@ -6108,7 +6111,7 @@ public class PermissionManagerService extends IPermissionManager.Stub {\n                 if (selfAccess) {\n                     try {\n                         startedOpResult = appOpsManager.startOpNoThrow(\n-                                resolvedAttributionSource.getToken(), startedOp,\n+                                chainStartToken, startedOp,\n                                 resolvedAttributionSource.getUid(),\n                                 resolvedAttributionSource.getPackageName(),\n                                 /*startIfModeDefault*/ false,\n@@ -6119,12 +6122,12 @@ public class PermissionManagerService extends IPermissionManager.Stub {\n                                 + \" platform defined runtime permission \"\n                                 + AppOpsManager.opToPermission(op) + \" while not having \"\n                                 + Manifest.permission.UPDATE_APP_OPS_STATS);\n-                        startedOpResult = appOpsManager.startProxyOpNoThrow(attributedOp,\n-                                attributionSource, message, skipProxyOperation,\n+                        startedOpResult = appOpsManager.startProxyOpNoThrow(chainStartToken,\n+                                attributedOp, attributionSource, message, skipProxyOperation,\n                                 proxyAttributionFlags, proxiedAttributionFlags, attributionChainId);\n                     }\n                 } else {\n-                    startedOpResult = appOpsManager.startProxyOpNoThrow(startedOp,\n+                    startedOpResult = appOpsManager.startProxyOpNoThrow(chainStartToken, startedOp,\n                             resolvedAttributionSource, message, skipProxyOperation,\n                             proxyAttributionFlags, proxiedAttributionFlags, attributionChainId);\n                 }\n",
    "added_lines": 21,
    "deleted_lines": 18,
    "changed_methods": "PermissionManagerService::PermissionCheckerService::finishDataDelivery, PermissionManagerService::PermissionCheckerService::checkRuntimePermission, PermissionManagerService::PermissionCheckerService::checkAppOpPermission, PermissionManagerService::PermissionCheckerService::performOpTransaction, PermissionManagerService::PermissionCheckerService::checkOp, PermissionManagerService::PermissionCheckerService::performOpTransaction"
   },
   {
    "filename": "AppOpsPolicy.java",
    "diff": "@@ -44,13 +44,11 @@ import android.util.Log;\n import android.util.SparseArray;\n \n import com.android.internal.annotations.GuardedBy;\n-import com.android.internal.util.function.DecFunction;\n import com.android.internal.util.function.HeptFunction;\n import com.android.internal.util.function.HexFunction;\n import com.android.internal.util.function.QuadFunction;\n import com.android.internal.util.function.QuintConsumer;\n import com.android.internal.util.function.QuintFunction;\n-import com.android.internal.util.function.TriFunction;\n import com.android.internal.util.function.UndecFunction;\n import com.android.server.LocalServices;\n \n@@ -255,14 +253,14 @@ public final class AppOpsPolicy implements AppOpsManagerInternal.CheckOpsDelegat\n     }\n \n     @Override\n-    public SyncNotedAppOp startProxyOperation(int code,\n+    public SyncNotedAppOp startProxyOperation(@NonNull IBinder clientId, int code,\n             @NonNull AttributionSource attributionSource, boolean startIfModeDefault,\n             boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n             boolean skipProxyOperation, @AttributionFlags int proxyAttributionFlags,\n             @AttributionFlags int proxiedAttributionFlags, int attributionChainId,\n-            @NonNull DecFunction<Integer, AttributionSource, Boolean, Boolean, String, Boolean,\n-                    Boolean, Integer, Integer, Integer, SyncNotedAppOp> superImpl) {\n-        return superImpl.apply(resolveDatasourceOp(code, attributionSource.getUid(),\n+            @NonNull UndecFunction<IBinder, Integer, AttributionSource, Boolean, Boolean, String,\n+                    Boolean, Boolean, Integer, Integer, Integer, SyncNotedAppOp> superImpl) {\n+        return superImpl.apply(clientId, resolveDatasourceOp(code, attributionSource.getUid(),\n                 attributionSource.getPackageName(), attributionSource.getAttributionTag()),\n                 attributionSource, startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                 shouldCollectMessage, skipProxyOperation, proxyAttributionFlags,\n@@ -278,10 +276,10 @@ public final class AppOpsPolicy implements AppOpsManagerInternal.CheckOpsDelegat\n     }\n \n     @Override\n-    public void finishProxyOperation(int code, @NonNull AttributionSource attributionSource,\n-            boolean skipProxyOperation, @NonNull TriFunction<Integer, AttributionSource,\n-            Boolean, Void> superImpl) {\n-        superImpl.apply(resolveDatasourceOp(code, attributionSource.getUid(),\n+    public void finishProxyOperation(@NonNull IBinder clientId, int code,\n+            @NonNull AttributionSource attributionSource, boolean skipProxyOperation,\n+            @NonNull QuadFunction<IBinder, Integer, AttributionSource, Boolean, Void> superImpl) {\n+        superImpl.apply(clientId, resolveDatasourceOp(code, attributionSource.getUid(),\n                 attributionSource.getPackageName(), attributionSource.getAttributionTag()),\n                 attributionSource, skipProxyOperation);\n     }\n",
    "added_lines": 8,
    "deleted_lines": 10,
    "changed_methods": "AppOpsPolicy::startProxyOperation, AppOpsPolicy::finishProxyOperation, AppOpsPolicy::finishProxyOperation, AppOpsPolicy::startProxyOperation"
   }
  ]
 },
 {
  "hash": "39bd18cfa37bcc403288bb6c7fb2219385405312",
  "commit": "Revert \"[RESTRICT AUTOMERGE] Trim the activity info of another uid if no privilege\"\n\nThis reverts commit fa8d6362348738284b3f33a13e1fa5cdd0af67b2.\n\nReason for revert: apps crashed due to the top activity info trimmed\n\nBug: 264269392 263434196 263438172\nChange-Id: I57d37649acb31bd93bd5aa10507f548cd77fc8f2\n(cherry picked from commit b37e4e7e6f465c4b6a291be6c65587dbd75b4ae4)\nMerged-In: I57d37649acb31bd93bd5aa10507f548cd77fc8f2",
  "files": [
   {
    "filename": "AppTaskImpl.java",
    "diff": "@@ -84,7 +84,7 @@ class AppTaskImpl extends IAppTask.Stub {\n                     throw new IllegalArgumentException(\"Unable to find task ID \" + mTaskId);\n                 }\n                 return mService.getRecentTasks().createRecentTaskInfo(task,\n-                        false /* stripExtras */, true /* getTasksAllowed */);\n+                        false /* stripExtras */);\n             } finally {\n                 Binder.restoreCallingIdentity(origId);\n             }\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "AppTaskImpl::getTaskInfo"
   },
   {
    "filename": "RecentTasks.java",
    "diff": "@@ -974,7 +974,7 @@ class RecentTasks {\n                 continue;\n             }\n \n-            res.add(createRecentTaskInfo(task, true /* stripExtras */, getTasksAllowed));\n+            res.add(createRecentTaskInfo(task, true /* stripExtras */));\n         }\n         return res;\n     }\n@@ -1890,8 +1890,7 @@ class RecentTasks {\n     /**\n      * Creates a new RecentTaskInfo from a Task.\n      */\n-    ActivityManager.RecentTaskInfo createRecentTaskInfo(Task tr, boolean stripExtras,\n-            boolean getTasksAllowed) {\n+    ActivityManager.RecentTaskInfo createRecentTaskInfo(Task tr, boolean stripExtras) {\n         final ActivityManager.RecentTaskInfo rti = new ActivityManager.RecentTaskInfo();\n         // If the recent Task is detached, we consider it will be re-attached to the default\n         // TaskDisplayArea because we currently only support recent overview in the default TDA.\n@@ -1903,9 +1902,6 @@ class RecentTasks {\n         rti.id = rti.isRunning ? rti.taskId : INVALID_TASK_ID;\n         rti.persistentId = rti.taskId;\n         rti.lastSnapshotData.set(tr.mLastTaskSnapshotData);\n-        if (!getTasksAllowed) {\n-            Task.trimIneffectiveInfo(tr, rti);\n-        }\n \n         // Fill in organized child task info for the task created by organizer.\n         if (tr.mCreatedByOrganizer) {\n",
    "added_lines": 2,
    "deleted_lines": 6,
    "changed_methods": "RecentTasks::createRecentTaskInfo, RecentTasks::getRecentTasksImpl, RecentTasks::createRecentTaskInfo"
   },
   {
    "filename": "RunningTasks.java",
    "diff": "@@ -150,10 +150,6 @@ class RunningTasks {\n         task.fillTaskInfo(rti, !mKeepIntentExtra);\n         // Fill in some deprecated values\n         rti.id = rti.taskId;\n-\n-        if (!mAllowed) {\n-            Task.trimIneffectiveInfo(task, rti);\n-        }\n         return rti;\n     }\n }\n",
    "added_lines": 0,
    "deleted_lines": 4,
    "changed_methods": "RunningTasks::createRunningTaskInfo"
   },
   {
    "filename": "Task.java",
    "diff": "@@ -3484,27 +3484,6 @@ class Task extends TaskFragment {\n         info.mTopActivityLocusId = topRecord != null ? topRecord.getLocusId() : null;\n     }\n \n-    /**\n-     * Removes the activity info if the activity belongs to a different uid, which is\n-     * different from the app that hosts the task.\n-     */\n-    static void trimIneffectiveInfo(Task task, TaskInfo info) {\n-        final ActivityRecord baseActivity = task.getActivity(r -> !r.finishing,\n-                false /* traverseTopToBottom */);\n-        final int baseActivityUid =\n-                baseActivity != null ? baseActivity.getUid() : task.effectiveUid;\n-\n-        if (info.topActivityInfo != null\n-                && task.effectiveUid != info.topActivityInfo.applicationInfo.uid) {\n-            info.topActivity = null;\n-            info.topActivityInfo = null;\n-        }\n-\n-        if (task.effectiveUid != baseActivityUid) {\n-            info.baseActivity = null;\n-        }\n-    }\n-\n     @Nullable PictureInPictureParams getPictureInPictureParams() {\n         return getPictureInPictureParams(getTopMostTask());\n     }\n",
    "added_lines": 0,
    "deleted_lines": 21,
    "changed_methods": "Task::trimIneffectiveInfo"
   },
   {
    "filename": "RecentTasksTest.java",
    "diff": "@@ -30,7 +30,6 @@ import static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;\n import static android.content.pm.ActivityInfo.LAUNCH_MULTIPLE;\n import static android.content.pm.ActivityInfo.LAUNCH_SINGLE_INSTANCE;\n import static android.content.res.Configuration.ORIENTATION_PORTRAIT;\n-import static android.os.Process.NOBODY_UID;\n \n import static com.android.dx.mockito.inline.extended.ExtendedMockito.doNothing;\n import static com.android.dx.mockito.inline.extended.ExtendedMockito.doReturn;\n@@ -1196,35 +1195,21 @@ public class RecentTasksTest extends WindowTestsBase {\n \n     @Test\n     public void testCreateRecentTaskInfo_detachedTask() {\n-        final Task task = createTaskBuilder(\".Task\").build();\n-        new ActivityBuilder(mSupervisor.mService)\n-                .setTask(task)\n-                .setUid(NOBODY_UID)\n-                .setComponent(new ComponentName(\"com.foo\", \".BarActivity\"))\n-                .build();\n+        final Task task = createTaskBuilder(\".Task\").setCreateActivity(true).build();\n         final TaskDisplayArea tda = task.getDisplayArea();\n \n         assertTrue(task.isAttached());\n         assertTrue(task.supportsMultiWindow());\n \n-        RecentTaskInfo info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,\n-                true /* getTasksAllowed */);\n+        RecentTaskInfo info = mRecentTasks.createRecentTaskInfo(task, true);\n \n         assertTrue(info.supportsMultiWindow);\n         assertTrue(info.supportsSplitScreenMultiWindow);\n \n-        info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,\n-                false /* getTasksAllowed */);\n-\n-        assertTrue(info.topActivity == null);\n-        assertTrue(info.topActivityInfo == null);\n-        assertTrue(info.baseActivity == null);\n-\n         // The task can be put in split screen even if it is not attached now.\n         task.removeImmediately();\n \n-        info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,\n-                true /* getTasksAllowed */);\n+        info = mRecentTasks.createRecentTaskInfo(task, true);\n \n         assertTrue(info.supportsMultiWindow);\n         assertTrue(info.supportsSplitScreenMultiWindow);\n@@ -1234,8 +1219,7 @@ public class RecentTasksTest extends WindowTestsBase {\n         doReturn(false).when(tda).supportsNonResizableMultiWindow();\n         doReturn(false).when(task).isResizeable();\n \n-        info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,\n-                true /* getTasksAllowed */);\n+        info = mRecentTasks.createRecentTaskInfo(task, true);\n \n         assertFalse(info.supportsMultiWindow);\n         assertFalse(info.supportsSplitScreenMultiWindow);\n@@ -1244,8 +1228,7 @@ public class RecentTasksTest extends WindowTestsBase {\n         // the device supports it.\n         doReturn(true).when(tda).supportsNonResizableMultiWindow();\n \n-        info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,\n-                true /* getTasksAllowed */);\n+        info = mRecentTasks.createRecentTaskInfo(task, true);\n \n         assertTrue(info.supportsMultiWindow);\n         assertTrue(info.supportsSplitScreenMultiWindow);\n",
    "added_lines": 5,
    "deleted_lines": 22,
    "changed_methods": "RecentTasksTest::testCreateRecentTaskInfo_detachedTask"
   }
  ]
 },
 {
  "hash": "39bd18cfa37bcc403288bb6c7fb2219385405312",
  "commit": "Revert \"[RESTRICT AUTOMERGE] Trim the activity info of another uid if no privilege\"\n\nThis reverts commit fa8d6362348738284b3f33a13e1fa5cdd0af67b2.\n\nReason for revert: apps crashed due to the top activity info trimmed\n\nBug: 264269392 263434196 263438172\nChange-Id: I57d37649acb31bd93bd5aa10507f548cd77fc8f2\n(cherry picked from commit b37e4e7e6f465c4b6a291be6c65587dbd75b4ae4)\nMerged-In: I57d37649acb31bd93bd5aa10507f548cd77fc8f2",
  "files": [
   {
    "filename": "AppTaskImpl.java",
    "diff": "@@ -84,7 +84,7 @@ class AppTaskImpl extends IAppTask.Stub {\n                     throw new IllegalArgumentException(\"Unable to find task ID \" + mTaskId);\n                 }\n                 return mService.getRecentTasks().createRecentTaskInfo(task,\n-                        false /* stripExtras */, true /* getTasksAllowed */);\n+                        false /* stripExtras */);\n             } finally {\n                 Binder.restoreCallingIdentity(origId);\n             }\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "AppTaskImpl::getTaskInfo"
   },
   {
    "filename": "RecentTasks.java",
    "diff": "@@ -974,7 +974,7 @@ class RecentTasks {\n                 continue;\n             }\n \n-            res.add(createRecentTaskInfo(task, true /* stripExtras */, getTasksAllowed));\n+            res.add(createRecentTaskInfo(task, true /* stripExtras */));\n         }\n         return res;\n     }\n@@ -1890,8 +1890,7 @@ class RecentTasks {\n     /**\n      * Creates a new RecentTaskInfo from a Task.\n      */\n-    ActivityManager.RecentTaskInfo createRecentTaskInfo(Task tr, boolean stripExtras,\n-            boolean getTasksAllowed) {\n+    ActivityManager.RecentTaskInfo createRecentTaskInfo(Task tr, boolean stripExtras) {\n         final ActivityManager.RecentTaskInfo rti = new ActivityManager.RecentTaskInfo();\n         // If the recent Task is detached, we consider it will be re-attached to the default\n         // TaskDisplayArea because we currently only support recent overview in the default TDA.\n@@ -1903,9 +1902,6 @@ class RecentTasks {\n         rti.id = rti.isRunning ? rti.taskId : INVALID_TASK_ID;\n         rti.persistentId = rti.taskId;\n         rti.lastSnapshotData.set(tr.mLastTaskSnapshotData);\n-        if (!getTasksAllowed) {\n-            Task.trimIneffectiveInfo(tr, rti);\n-        }\n \n         // Fill in organized child task info for the task created by organizer.\n         if (tr.mCreatedByOrganizer) {\n",
    "added_lines": 2,
    "deleted_lines": 6,
    "changed_methods": "RecentTasks::createRecentTaskInfo, RecentTasks::getRecentTasksImpl, RecentTasks::createRecentTaskInfo"
   },
   {
    "filename": "RunningTasks.java",
    "diff": "@@ -150,10 +150,6 @@ class RunningTasks {\n         task.fillTaskInfo(rti, !mKeepIntentExtra);\n         // Fill in some deprecated values\n         rti.id = rti.taskId;\n-\n-        if (!mAllowed) {\n-            Task.trimIneffectiveInfo(task, rti);\n-        }\n         return rti;\n     }\n }\n",
    "added_lines": 0,
    "deleted_lines": 4,
    "changed_methods": "RunningTasks::createRunningTaskInfo"
   },
   {
    "filename": "Task.java",
    "diff": "@@ -3484,27 +3484,6 @@ class Task extends TaskFragment {\n         info.mTopActivityLocusId = topRecord != null ? topRecord.getLocusId() : null;\n     }\n \n-    /**\n-     * Removes the activity info if the activity belongs to a different uid, which is\n-     * different from the app that hosts the task.\n-     */\n-    static void trimIneffectiveInfo(Task task, TaskInfo info) {\n-        final ActivityRecord baseActivity = task.getActivity(r -> !r.finishing,\n-                false /* traverseTopToBottom */);\n-        final int baseActivityUid =\n-                baseActivity != null ? baseActivity.getUid() : task.effectiveUid;\n-\n-        if (info.topActivityInfo != null\n-                && task.effectiveUid != info.topActivityInfo.applicationInfo.uid) {\n-            info.topActivity = null;\n-            info.topActivityInfo = null;\n-        }\n-\n-        if (task.effectiveUid != baseActivityUid) {\n-            info.baseActivity = null;\n-        }\n-    }\n-\n     @Nullable PictureInPictureParams getPictureInPictureParams() {\n         return getPictureInPictureParams(getTopMostTask());\n     }\n",
    "added_lines": 0,
    "deleted_lines": 21,
    "changed_methods": "Task::trimIneffectiveInfo"
   },
   {
    "filename": "RecentTasksTest.java",
    "diff": "@@ -30,7 +30,6 @@ import static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;\n import static android.content.pm.ActivityInfo.LAUNCH_MULTIPLE;\n import static android.content.pm.ActivityInfo.LAUNCH_SINGLE_INSTANCE;\n import static android.content.res.Configuration.ORIENTATION_PORTRAIT;\n-import static android.os.Process.NOBODY_UID;\n \n import static com.android.dx.mockito.inline.extended.ExtendedMockito.doNothing;\n import static com.android.dx.mockito.inline.extended.ExtendedMockito.doReturn;\n@@ -1196,35 +1195,21 @@ public class RecentTasksTest extends WindowTestsBase {\n \n     @Test\n     public void testCreateRecentTaskInfo_detachedTask() {\n-        final Task task = createTaskBuilder(\".Task\").build();\n-        new ActivityBuilder(mSupervisor.mService)\n-                .setTask(task)\n-                .setUid(NOBODY_UID)\n-                .setComponent(new ComponentName(\"com.foo\", \".BarActivity\"))\n-                .build();\n+        final Task task = createTaskBuilder(\".Task\").setCreateActivity(true).build();\n         final TaskDisplayArea tda = task.getDisplayArea();\n \n         assertTrue(task.isAttached());\n         assertTrue(task.supportsMultiWindow());\n \n-        RecentTaskInfo info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,\n-                true /* getTasksAllowed */);\n+        RecentTaskInfo info = mRecentTasks.createRecentTaskInfo(task, true);\n \n         assertTrue(info.supportsMultiWindow);\n         assertTrue(info.supportsSplitScreenMultiWindow);\n \n-        info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,\n-                false /* getTasksAllowed */);\n-\n-        assertTrue(info.topActivity == null);\n-        assertTrue(info.topActivityInfo == null);\n-        assertTrue(info.baseActivity == null);\n-\n         // The task can be put in split screen even if it is not attached now.\n         task.removeImmediately();\n \n-        info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,\n-                true /* getTasksAllowed */);\n+        info = mRecentTasks.createRecentTaskInfo(task, true);\n \n         assertTrue(info.supportsMultiWindow);\n         assertTrue(info.supportsSplitScreenMultiWindow);\n@@ -1234,8 +1219,7 @@ public class RecentTasksTest extends WindowTestsBase {\n         doReturn(false).when(tda).supportsNonResizableMultiWindow();\n         doReturn(false).when(task).isResizeable();\n \n-        info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,\n-                true /* getTasksAllowed */);\n+        info = mRecentTasks.createRecentTaskInfo(task, true);\n \n         assertFalse(info.supportsMultiWindow);\n         assertFalse(info.supportsSplitScreenMultiWindow);\n@@ -1244,8 +1228,7 @@ public class RecentTasksTest extends WindowTestsBase {\n         // the device supports it.\n         doReturn(true).when(tda).supportsNonResizableMultiWindow();\n \n-        info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,\n-                true /* getTasksAllowed */);\n+        info = mRecentTasks.createRecentTaskInfo(task, true);\n \n         assertTrue(info.supportsMultiWindow);\n         assertTrue(info.supportsSplitScreenMultiWindow);\n",
    "added_lines": 5,
    "deleted_lines": 22,
    "changed_methods": "RecentTasksTest::testCreateRecentTaskInfo_detachedTask"
   }
  ]
 },
 {
  "hash": "39bd18cfa37bcc403288bb6c7fb2219385405312",
  "commit": "Revert \"[RESTRICT AUTOMERGE] Trim the activity info of another uid if no privilege\"\n\nThis reverts commit fa8d6362348738284b3f33a13e1fa5cdd0af67b2.\n\nReason for revert: apps crashed due to the top activity info trimmed\n\nBug: 264269392 263434196 263438172\nChange-Id: I57d37649acb31bd93bd5aa10507f548cd77fc8f2\n(cherry picked from commit b37e4e7e6f465c4b6a291be6c65587dbd75b4ae4)\nMerged-In: I57d37649acb31bd93bd5aa10507f548cd77fc8f2",
  "files": [
   {
    "filename": "AppTaskImpl.java",
    "diff": "@@ -84,7 +84,7 @@ class AppTaskImpl extends IAppTask.Stub {\n                     throw new IllegalArgumentException(\"Unable to find task ID \" + mTaskId);\n                 }\n                 return mService.getRecentTasks().createRecentTaskInfo(task,\n-                        false /* stripExtras */, true /* getTasksAllowed */);\n+                        false /* stripExtras */);\n             } finally {\n                 Binder.restoreCallingIdentity(origId);\n             }\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "AppTaskImpl::getTaskInfo"
   },
   {
    "filename": "RecentTasks.java",
    "diff": "@@ -974,7 +974,7 @@ class RecentTasks {\n                 continue;\n             }\n \n-            res.add(createRecentTaskInfo(task, true /* stripExtras */, getTasksAllowed));\n+            res.add(createRecentTaskInfo(task, true /* stripExtras */));\n         }\n         return res;\n     }\n@@ -1890,8 +1890,7 @@ class RecentTasks {\n     /**\n      * Creates a new RecentTaskInfo from a Task.\n      */\n-    ActivityManager.RecentTaskInfo createRecentTaskInfo(Task tr, boolean stripExtras,\n-            boolean getTasksAllowed) {\n+    ActivityManager.RecentTaskInfo createRecentTaskInfo(Task tr, boolean stripExtras) {\n         final ActivityManager.RecentTaskInfo rti = new ActivityManager.RecentTaskInfo();\n         // If the recent Task is detached, we consider it will be re-attached to the default\n         // TaskDisplayArea because we currently only support recent overview in the default TDA.\n@@ -1903,9 +1902,6 @@ class RecentTasks {\n         rti.id = rti.isRunning ? rti.taskId : INVALID_TASK_ID;\n         rti.persistentId = rti.taskId;\n         rti.lastSnapshotData.set(tr.mLastTaskSnapshotData);\n-        if (!getTasksAllowed) {\n-            Task.trimIneffectiveInfo(tr, rti);\n-        }\n \n         // Fill in organized child task info for the task created by organizer.\n         if (tr.mCreatedByOrganizer) {\n",
    "added_lines": 2,
    "deleted_lines": 6,
    "changed_methods": "RecentTasks::createRecentTaskInfo, RecentTasks::getRecentTasksImpl, RecentTasks::createRecentTaskInfo"
   },
   {
    "filename": "RunningTasks.java",
    "diff": "@@ -150,10 +150,6 @@ class RunningTasks {\n         task.fillTaskInfo(rti, !mKeepIntentExtra);\n         // Fill in some deprecated values\n         rti.id = rti.taskId;\n-\n-        if (!mAllowed) {\n-            Task.trimIneffectiveInfo(task, rti);\n-        }\n         return rti;\n     }\n }\n",
    "added_lines": 0,
    "deleted_lines": 4,
    "changed_methods": "RunningTasks::createRunningTaskInfo"
   },
   {
    "filename": "Task.java",
    "diff": "@@ -3484,27 +3484,6 @@ class Task extends TaskFragment {\n         info.mTopActivityLocusId = topRecord != null ? topRecord.getLocusId() : null;\n     }\n \n-    /**\n-     * Removes the activity info if the activity belongs to a different uid, which is\n-     * different from the app that hosts the task.\n-     */\n-    static void trimIneffectiveInfo(Task task, TaskInfo info) {\n-        final ActivityRecord baseActivity = task.getActivity(r -> !r.finishing,\n-                false /* traverseTopToBottom */);\n-        final int baseActivityUid =\n-                baseActivity != null ? baseActivity.getUid() : task.effectiveUid;\n-\n-        if (info.topActivityInfo != null\n-                && task.effectiveUid != info.topActivityInfo.applicationInfo.uid) {\n-            info.topActivity = null;\n-            info.topActivityInfo = null;\n-        }\n-\n-        if (task.effectiveUid != baseActivityUid) {\n-            info.baseActivity = null;\n-        }\n-    }\n-\n     @Nullable PictureInPictureParams getPictureInPictureParams() {\n         return getPictureInPictureParams(getTopMostTask());\n     }\n",
    "added_lines": 0,
    "deleted_lines": 21,
    "changed_methods": "Task::trimIneffectiveInfo"
   },
   {
    "filename": "RecentTasksTest.java",
    "diff": "@@ -30,7 +30,6 @@ import static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;\n import static android.content.pm.ActivityInfo.LAUNCH_MULTIPLE;\n import static android.content.pm.ActivityInfo.LAUNCH_SINGLE_INSTANCE;\n import static android.content.res.Configuration.ORIENTATION_PORTRAIT;\n-import static android.os.Process.NOBODY_UID;\n \n import static com.android.dx.mockito.inline.extended.ExtendedMockito.doNothing;\n import static com.android.dx.mockito.inline.extended.ExtendedMockito.doReturn;\n@@ -1196,35 +1195,21 @@ public class RecentTasksTest extends WindowTestsBase {\n \n     @Test\n     public void testCreateRecentTaskInfo_detachedTask() {\n-        final Task task = createTaskBuilder(\".Task\").build();\n-        new ActivityBuilder(mSupervisor.mService)\n-                .setTask(task)\n-                .setUid(NOBODY_UID)\n-                .setComponent(new ComponentName(\"com.foo\", \".BarActivity\"))\n-                .build();\n+        final Task task = createTaskBuilder(\".Task\").setCreateActivity(true).build();\n         final TaskDisplayArea tda = task.getDisplayArea();\n \n         assertTrue(task.isAttached());\n         assertTrue(task.supportsMultiWindow());\n \n-        RecentTaskInfo info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,\n-                true /* getTasksAllowed */);\n+        RecentTaskInfo info = mRecentTasks.createRecentTaskInfo(task, true);\n \n         assertTrue(info.supportsMultiWindow);\n         assertTrue(info.supportsSplitScreenMultiWindow);\n \n-        info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,\n-                false /* getTasksAllowed */);\n-\n-        assertTrue(info.topActivity == null);\n-        assertTrue(info.topActivityInfo == null);\n-        assertTrue(info.baseActivity == null);\n-\n         // The task can be put in split screen even if it is not attached now.\n         task.removeImmediately();\n \n-        info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,\n-                true /* getTasksAllowed */);\n+        info = mRecentTasks.createRecentTaskInfo(task, true);\n \n         assertTrue(info.supportsMultiWindow);\n         assertTrue(info.supportsSplitScreenMultiWindow);\n@@ -1234,8 +1219,7 @@ public class RecentTasksTest extends WindowTestsBase {\n         doReturn(false).when(tda).supportsNonResizableMultiWindow();\n         doReturn(false).when(task).isResizeable();\n \n-        info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,\n-                true /* getTasksAllowed */);\n+        info = mRecentTasks.createRecentTaskInfo(task, true);\n \n         assertFalse(info.supportsMultiWindow);\n         assertFalse(info.supportsSplitScreenMultiWindow);\n@@ -1244,8 +1228,7 @@ public class RecentTasksTest extends WindowTestsBase {\n         // the device supports it.\n         doReturn(true).when(tda).supportsNonResizableMultiWindow();\n \n-        info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,\n-                true /* getTasksAllowed */);\n+        info = mRecentTasks.createRecentTaskInfo(task, true);\n \n         assertTrue(info.supportsMultiWindow);\n         assertTrue(info.supportsSplitScreenMultiWindow);\n",
    "added_lines": 5,
    "deleted_lines": 22,
    "changed_methods": "RecentTasksTest::testCreateRecentTaskInfo_detachedTask"
   }
  ]
 },
 {
  "hash": "39bd18cfa37bcc403288bb6c7fb2219385405312",
  "commit": "Revert \"[RESTRICT AUTOMERGE] Trim the activity info of another uid if no privilege\"\n\nThis reverts commit fa8d6362348738284b3f33a13e1fa5cdd0af67b2.\n\nReason for revert: apps crashed due to the top activity info trimmed\n\nBug: 264269392 263434196 263438172\nChange-Id: I57d37649acb31bd93bd5aa10507f548cd77fc8f2\n(cherry picked from commit b37e4e7e6f465c4b6a291be6c65587dbd75b4ae4)\nMerged-In: I57d37649acb31bd93bd5aa10507f548cd77fc8f2",
  "files": [
   {
    "filename": "AppTaskImpl.java",
    "diff": "@@ -84,7 +84,7 @@ class AppTaskImpl extends IAppTask.Stub {\n                     throw new IllegalArgumentException(\"Unable to find task ID \" + mTaskId);\n                 }\n                 return mService.getRecentTasks().createRecentTaskInfo(task,\n-                        false /* stripExtras */, true /* getTasksAllowed */);\n+                        false /* stripExtras */);\n             } finally {\n                 Binder.restoreCallingIdentity(origId);\n             }\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "AppTaskImpl::getTaskInfo"
   },
   {
    "filename": "RecentTasks.java",
    "diff": "@@ -974,7 +974,7 @@ class RecentTasks {\n                 continue;\n             }\n \n-            res.add(createRecentTaskInfo(task, true /* stripExtras */, getTasksAllowed));\n+            res.add(createRecentTaskInfo(task, true /* stripExtras */));\n         }\n         return res;\n     }\n@@ -1890,8 +1890,7 @@ class RecentTasks {\n     /**\n      * Creates a new RecentTaskInfo from a Task.\n      */\n-    ActivityManager.RecentTaskInfo createRecentTaskInfo(Task tr, boolean stripExtras,\n-            boolean getTasksAllowed) {\n+    ActivityManager.RecentTaskInfo createRecentTaskInfo(Task tr, boolean stripExtras) {\n         final ActivityManager.RecentTaskInfo rti = new ActivityManager.RecentTaskInfo();\n         // If the recent Task is detached, we consider it will be re-attached to the default\n         // TaskDisplayArea because we currently only support recent overview in the default TDA.\n@@ -1903,9 +1902,6 @@ class RecentTasks {\n         rti.id = rti.isRunning ? rti.taskId : INVALID_TASK_ID;\n         rti.persistentId = rti.taskId;\n         rti.lastSnapshotData.set(tr.mLastTaskSnapshotData);\n-        if (!getTasksAllowed) {\n-            Task.trimIneffectiveInfo(tr, rti);\n-        }\n \n         // Fill in organized child task info for the task created by organizer.\n         if (tr.mCreatedByOrganizer) {\n",
    "added_lines": 2,
    "deleted_lines": 6,
    "changed_methods": "RecentTasks::createRecentTaskInfo, RecentTasks::getRecentTasksImpl, RecentTasks::createRecentTaskInfo"
   },
   {
    "filename": "RunningTasks.java",
    "diff": "@@ -150,10 +150,6 @@ class RunningTasks {\n         task.fillTaskInfo(rti, !mKeepIntentExtra);\n         // Fill in some deprecated values\n         rti.id = rti.taskId;\n-\n-        if (!mAllowed) {\n-            Task.trimIneffectiveInfo(task, rti);\n-        }\n         return rti;\n     }\n }\n",
    "added_lines": 0,
    "deleted_lines": 4,
    "changed_methods": "RunningTasks::createRunningTaskInfo"
   },
   {
    "filename": "Task.java",
    "diff": "@@ -3484,27 +3484,6 @@ class Task extends TaskFragment {\n         info.mTopActivityLocusId = topRecord != null ? topRecord.getLocusId() : null;\n     }\n \n-    /**\n-     * Removes the activity info if the activity belongs to a different uid, which is\n-     * different from the app that hosts the task.\n-     */\n-    static void trimIneffectiveInfo(Task task, TaskInfo info) {\n-        final ActivityRecord baseActivity = task.getActivity(r -> !r.finishing,\n-                false /* traverseTopToBottom */);\n-        final int baseActivityUid =\n-                baseActivity != null ? baseActivity.getUid() : task.effectiveUid;\n-\n-        if (info.topActivityInfo != null\n-                && task.effectiveUid != info.topActivityInfo.applicationInfo.uid) {\n-            info.topActivity = null;\n-            info.topActivityInfo = null;\n-        }\n-\n-        if (task.effectiveUid != baseActivityUid) {\n-            info.baseActivity = null;\n-        }\n-    }\n-\n     @Nullable PictureInPictureParams getPictureInPictureParams() {\n         return getPictureInPictureParams(getTopMostTask());\n     }\n",
    "added_lines": 0,
    "deleted_lines": 21,
    "changed_methods": "Task::trimIneffectiveInfo"
   },
   {
    "filename": "RecentTasksTest.java",
    "diff": "@@ -30,7 +30,6 @@ import static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;\n import static android.content.pm.ActivityInfo.LAUNCH_MULTIPLE;\n import static android.content.pm.ActivityInfo.LAUNCH_SINGLE_INSTANCE;\n import static android.content.res.Configuration.ORIENTATION_PORTRAIT;\n-import static android.os.Process.NOBODY_UID;\n \n import static com.android.dx.mockito.inline.extended.ExtendedMockito.doNothing;\n import static com.android.dx.mockito.inline.extended.ExtendedMockito.doReturn;\n@@ -1196,35 +1195,21 @@ public class RecentTasksTest extends WindowTestsBase {\n \n     @Test\n     public void testCreateRecentTaskInfo_detachedTask() {\n-        final Task task = createTaskBuilder(\".Task\").build();\n-        new ActivityBuilder(mSupervisor.mService)\n-                .setTask(task)\n-                .setUid(NOBODY_UID)\n-                .setComponent(new ComponentName(\"com.foo\", \".BarActivity\"))\n-                .build();\n+        final Task task = createTaskBuilder(\".Task\").setCreateActivity(true).build();\n         final TaskDisplayArea tda = task.getDisplayArea();\n \n         assertTrue(task.isAttached());\n         assertTrue(task.supportsMultiWindow());\n \n-        RecentTaskInfo info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,\n-                true /* getTasksAllowed */);\n+        RecentTaskInfo info = mRecentTasks.createRecentTaskInfo(task, true);\n \n         assertTrue(info.supportsMultiWindow);\n         assertTrue(info.supportsSplitScreenMultiWindow);\n \n-        info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,\n-                false /* getTasksAllowed */);\n-\n-        assertTrue(info.topActivity == null);\n-        assertTrue(info.topActivityInfo == null);\n-        assertTrue(info.baseActivity == null);\n-\n         // The task can be put in split screen even if it is not attached now.\n         task.removeImmediately();\n \n-        info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,\n-                true /* getTasksAllowed */);\n+        info = mRecentTasks.createRecentTaskInfo(task, true);\n \n         assertTrue(info.supportsMultiWindow);\n         assertTrue(info.supportsSplitScreenMultiWindow);\n@@ -1234,8 +1219,7 @@ public class RecentTasksTest extends WindowTestsBase {\n         doReturn(false).when(tda).supportsNonResizableMultiWindow();\n         doReturn(false).when(task).isResizeable();\n \n-        info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,\n-                true /* getTasksAllowed */);\n+        info = mRecentTasks.createRecentTaskInfo(task, true);\n \n         assertFalse(info.supportsMultiWindow);\n         assertFalse(info.supportsSplitScreenMultiWindow);\n@@ -1244,8 +1228,7 @@ public class RecentTasksTest extends WindowTestsBase {\n         // the device supports it.\n         doReturn(true).when(tda).supportsNonResizableMultiWindow();\n \n-        info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,\n-                true /* getTasksAllowed */);\n+        info = mRecentTasks.createRecentTaskInfo(task, true);\n \n         assertTrue(info.supportsMultiWindow);\n         assertTrue(info.supportsSplitScreenMultiWindow);\n",
    "added_lines": 5,
    "deleted_lines": 22,
    "changed_methods": "RecentTasksTest::testCreateRecentTaskInfo_detachedTask"
   }
  ]
 },
 {
  "hash": "39bd18cfa37bcc403288bb6c7fb2219385405312",
  "commit": "Revert \"[RESTRICT AUTOMERGE] Trim the activity info of another uid if no privilege\"\n\nThis reverts commit fa8d6362348738284b3f33a13e1fa5cdd0af67b2.\n\nReason for revert: apps crashed due to the top activity info trimmed\n\nBug: 264269392 263434196 263438172\nChange-Id: I57d37649acb31bd93bd5aa10507f548cd77fc8f2\n(cherry picked from commit b37e4e7e6f465c4b6a291be6c65587dbd75b4ae4)\nMerged-In: I57d37649acb31bd93bd5aa10507f548cd77fc8f2",
  "files": [
   {
    "filename": "AppTaskImpl.java",
    "diff": "@@ -84,7 +84,7 @@ class AppTaskImpl extends IAppTask.Stub {\n                     throw new IllegalArgumentException(\"Unable to find task ID \" + mTaskId);\n                 }\n                 return mService.getRecentTasks().createRecentTaskInfo(task,\n-                        false /* stripExtras */, true /* getTasksAllowed */);\n+                        false /* stripExtras */);\n             } finally {\n                 Binder.restoreCallingIdentity(origId);\n             }\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "AppTaskImpl::getTaskInfo"
   },
   {
    "filename": "RecentTasks.java",
    "diff": "@@ -974,7 +974,7 @@ class RecentTasks {\n                 continue;\n             }\n \n-            res.add(createRecentTaskInfo(task, true /* stripExtras */, getTasksAllowed));\n+            res.add(createRecentTaskInfo(task, true /* stripExtras */));\n         }\n         return res;\n     }\n@@ -1890,8 +1890,7 @@ class RecentTasks {\n     /**\n      * Creates a new RecentTaskInfo from a Task.\n      */\n-    ActivityManager.RecentTaskInfo createRecentTaskInfo(Task tr, boolean stripExtras,\n-            boolean getTasksAllowed) {\n+    ActivityManager.RecentTaskInfo createRecentTaskInfo(Task tr, boolean stripExtras) {\n         final ActivityManager.RecentTaskInfo rti = new ActivityManager.RecentTaskInfo();\n         // If the recent Task is detached, we consider it will be re-attached to the default\n         // TaskDisplayArea because we currently only support recent overview in the default TDA.\n@@ -1903,9 +1902,6 @@ class RecentTasks {\n         rti.id = rti.isRunning ? rti.taskId : INVALID_TASK_ID;\n         rti.persistentId = rti.taskId;\n         rti.lastSnapshotData.set(tr.mLastTaskSnapshotData);\n-        if (!getTasksAllowed) {\n-            Task.trimIneffectiveInfo(tr, rti);\n-        }\n \n         // Fill in organized child task info for the task created by organizer.\n         if (tr.mCreatedByOrganizer) {\n",
    "added_lines": 2,
    "deleted_lines": 6,
    "changed_methods": "RecentTasks::createRecentTaskInfo, RecentTasks::getRecentTasksImpl, RecentTasks::createRecentTaskInfo"
   },
   {
    "filename": "RunningTasks.java",
    "diff": "@@ -150,10 +150,6 @@ class RunningTasks {\n         task.fillTaskInfo(rti, !mKeepIntentExtra);\n         // Fill in some deprecated values\n         rti.id = rti.taskId;\n-\n-        if (!mAllowed) {\n-            Task.trimIneffectiveInfo(task, rti);\n-        }\n         return rti;\n     }\n }\n",
    "added_lines": 0,
    "deleted_lines": 4,
    "changed_methods": "RunningTasks::createRunningTaskInfo"
   },
   {
    "filename": "Task.java",
    "diff": "@@ -3484,27 +3484,6 @@ class Task extends TaskFragment {\n         info.mTopActivityLocusId = topRecord != null ? topRecord.getLocusId() : null;\n     }\n \n-    /**\n-     * Removes the activity info if the activity belongs to a different uid, which is\n-     * different from the app that hosts the task.\n-     */\n-    static void trimIneffectiveInfo(Task task, TaskInfo info) {\n-        final ActivityRecord baseActivity = task.getActivity(r -> !r.finishing,\n-                false /* traverseTopToBottom */);\n-        final int baseActivityUid =\n-                baseActivity != null ? baseActivity.getUid() : task.effectiveUid;\n-\n-        if (info.topActivityInfo != null\n-                && task.effectiveUid != info.topActivityInfo.applicationInfo.uid) {\n-            info.topActivity = null;\n-            info.topActivityInfo = null;\n-        }\n-\n-        if (task.effectiveUid != baseActivityUid) {\n-            info.baseActivity = null;\n-        }\n-    }\n-\n     @Nullable PictureInPictureParams getPictureInPictureParams() {\n         return getPictureInPictureParams(getTopMostTask());\n     }\n",
    "added_lines": 0,
    "deleted_lines": 21,
    "changed_methods": "Task::trimIneffectiveInfo"
   },
   {
    "filename": "RecentTasksTest.java",
    "diff": "@@ -30,7 +30,6 @@ import static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;\n import static android.content.pm.ActivityInfo.LAUNCH_MULTIPLE;\n import static android.content.pm.ActivityInfo.LAUNCH_SINGLE_INSTANCE;\n import static android.content.res.Configuration.ORIENTATION_PORTRAIT;\n-import static android.os.Process.NOBODY_UID;\n \n import static com.android.dx.mockito.inline.extended.ExtendedMockito.doNothing;\n import static com.android.dx.mockito.inline.extended.ExtendedMockito.doReturn;\n@@ -1196,35 +1195,21 @@ public class RecentTasksTest extends WindowTestsBase {\n \n     @Test\n     public void testCreateRecentTaskInfo_detachedTask() {\n-        final Task task = createTaskBuilder(\".Task\").build();\n-        new ActivityBuilder(mSupervisor.mService)\n-                .setTask(task)\n-                .setUid(NOBODY_UID)\n-                .setComponent(new ComponentName(\"com.foo\", \".BarActivity\"))\n-                .build();\n+        final Task task = createTaskBuilder(\".Task\").setCreateActivity(true).build();\n         final TaskDisplayArea tda = task.getDisplayArea();\n \n         assertTrue(task.isAttached());\n         assertTrue(task.supportsMultiWindow());\n \n-        RecentTaskInfo info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,\n-                true /* getTasksAllowed */);\n+        RecentTaskInfo info = mRecentTasks.createRecentTaskInfo(task, true);\n \n         assertTrue(info.supportsMultiWindow);\n         assertTrue(info.supportsSplitScreenMultiWindow);\n \n-        info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,\n-                false /* getTasksAllowed */);\n-\n-        assertTrue(info.topActivity == null);\n-        assertTrue(info.topActivityInfo == null);\n-        assertTrue(info.baseActivity == null);\n-\n         // The task can be put in split screen even if it is not attached now.\n         task.removeImmediately();\n \n-        info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,\n-                true /* getTasksAllowed */);\n+        info = mRecentTasks.createRecentTaskInfo(task, true);\n \n         assertTrue(info.supportsMultiWindow);\n         assertTrue(info.supportsSplitScreenMultiWindow);\n@@ -1234,8 +1219,7 @@ public class RecentTasksTest extends WindowTestsBase {\n         doReturn(false).when(tda).supportsNonResizableMultiWindow();\n         doReturn(false).when(task).isResizeable();\n \n-        info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,\n-                true /* getTasksAllowed */);\n+        info = mRecentTasks.createRecentTaskInfo(task, true);\n \n         assertFalse(info.supportsMultiWindow);\n         assertFalse(info.supportsSplitScreenMultiWindow);\n@@ -1244,8 +1228,7 @@ public class RecentTasksTest extends WindowTestsBase {\n         // the device supports it.\n         doReturn(true).when(tda).supportsNonResizableMultiWindow();\n \n-        info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,\n-                true /* getTasksAllowed */);\n+        info = mRecentTasks.createRecentTaskInfo(task, true);\n \n         assertTrue(info.supportsMultiWindow);\n         assertTrue(info.supportsSplitScreenMultiWindow);\n",
    "added_lines": 5,
    "deleted_lines": 22,
    "changed_methods": "RecentTasksTest::testCreateRecentTaskInfo_detachedTask"
   }
  ]
 },
 {
  "hash": "13e194d35f19d15873aeb2551ba9186d76558b44",
  "commit": "Move service initialization\n\nOccasionally ILockSettings can fail to be initialized otherwise\nFixes: 232714129\nTest: boot (and eventually bootstress/reboot-long)\n\nChange-Id: I2f9f9bdba37f4ebfaea56c1a6662f0474ae8a002\nMerged-In: I2f9f9bdba37f4ebfaea56c1a6662f0474ae8a002\n(cherry picked from commit 8e278543bd290d4b6c417758554d6dee93a4fe74)\n(cherry picked from commit d262fa6af707a18226c5a586ae2704ab0a9907bf)\nMerged-In: I2f9f9bdba37f4ebfaea56c1a6662f0474ae8a002",
  "files": [
   {
    "filename": "NotificationManagerService.java",
    "diff": "@@ -1951,7 +1951,6 @@ public class NotificationManagerService extends SystemService {\n         }\n     }\n \n-    private LockPatternUtils mLockPatternUtils;\n     private StrongAuthTracker mStrongAuthTracker;\n \n     public NotificationManagerService(Context context) {\n@@ -2168,7 +2167,6 @@ public class NotificationManagerService extends SystemService {\n                 ServiceManager.getService(Context.PLATFORM_COMPAT_SERVICE));\n \n         mUiHandler = new Handler(UiThread.get().getLooper());\n-        mLockPatternUtils = new LockPatternUtils(getContext());\n         mStrongAuthTracker = new StrongAuthTracker(getContext());\n         String[] extractorNames;\n         try {\n@@ -2654,7 +2652,7 @@ public class NotificationManagerService extends SystemService {\n                 bubbsExtractor.setShortcutHelper(mShortcutHelper);\n             }\n             registerNotificationPreferencesPullers();\n-            mLockPatternUtils.registerStrongAuthTracker(mStrongAuthTracker);\n+            new LockPatternUtils(getContext()).registerStrongAuthTracker(mStrongAuthTracker);\n         } else if (phase == SystemService.PHASE_THIRD_PARTY_APPS_CAN_START) {\n             // This observer will force an update when observe is called, causing us to\n             // bind to listener services.\n",
    "added_lines": 1,
    "deleted_lines": 3,
    "changed_methods": "NotificationManagerService::init, NotificationManagerService::onBootPhase"
   }
  ]
 },
 {
  "hash": "5676b94f5ff807eea35ebf63b97f83c3ffb2f7a1",
  "commit": "Enable user graularity for lockdown mode\n\nThe NotificationManagerService registers a LockPatternUtils.StrongAuthTracker\nto observe the StrongAuth changes of every user.\nMore specifically, it\u2019s the STRONG_AUTH_REQUIRED_AFTER_USER_LOCKDOWN flag.\nVia this flag, NotificationManagerService can perform the following operations\nwhen the user enter or exit lockdown mode:\n\nEnter lockdown:\n1. Remove all the notifications belonging to the user.\n2. Set the local flag to indicate the lockdown is on for the user.\n   The local flag will suppress the user's notifications on the\n   post, remove and update functions.\n\nExit lockdown:\n1. Clear the local flag to indicate the lockdown is off for the user.\n2. Repost the user\u2019s notifications (suppressed during lockdown mode).\n\nThe CL also updates corresponding tests.\n\nBug: 173721373\nBug: 250743174\nTest: atest NotificationManagerServiceTest\nTest: atest NotificationListenersTest\nIgnore-AOSP-First: pending fix for a security issue.\n\nChange-Id: I4f30e56550729db7d673a92d2a1250509713f36d\nMerged-In: I4f30e56550729db7d673a92d2a1250509713f36d\n(cherry picked from commit de3b12fca23178d8c821058261572449b67d5967)\n(cherry picked from commit 0b56ec9aa245f7bbdf065a4b33b5ef00a558dbe4)\nMerged-In: I4f30e56550729db7d673a92d2a1250509713f36d",
  "files": [
   {
    "filename": "NotificationManagerService.java",
    "diff": "@@ -1919,34 +1919,39 @@ public class NotificationManagerService extends SystemService {\n             return (haystack & needle) != 0;\n         }\n \n-        public boolean isInLockDownMode() {\n-            return mIsInLockDownMode;\n+        // Return whether the user is in lockdown mode.\n+        // If the flag is not set, we assume the user is not in lockdown.\n+        public boolean isInLockDownMode(int userId) {\n+            return mUserInLockDownMode.get(userId, false);\n         }\n \n         @Override\n         public synchronized void onStrongAuthRequiredChanged(int userId) {\n             boolean userInLockDownModeNext = containsFlag(getStrongAuthForUser(userId),\n                     STRONG_AUTH_REQUIRED_AFTER_USER_LOCKDOWN);\n-            mUserInLockDownMode.put(userId, userInLockDownModeNext);\n-            boolean isInLockDownModeNext = mUserInLockDownMode.indexOfValue(true) != -1;\n \n-            if (mIsInLockDownMode == isInLockDownModeNext) {\n+            // Nothing happens if the lockdown mode of userId keeps the same.\n+            if (userInLockDownModeNext == isInLockDownMode(userId)) {\n                 return;\n             }\n \n-            if (isInLockDownModeNext) {\n-                cancelNotificationsWhenEnterLockDownMode();\n+            // When the lockdown mode is changed, we perform the following steps.\n+            // If the userInLockDownModeNext is true, all the function calls to\n+            // notifyPostedLocked and notifyRemovedLocked will not be executed.\n+            // The cancelNotificationsWhenEnterLockDownMode calls notifyRemovedLocked\n+            // and postNotificationsWhenExitLockDownMode calls notifyPostedLocked.\n+            // So we shall call cancelNotificationsWhenEnterLockDownMode before\n+            // we set mUserInLockDownMode as true.\n+            // On the other hand, if the userInLockDownModeNext is false, we shall call\n+            // postNotificationsWhenExitLockDownMode after we put false into mUserInLockDownMode\n+            if (userInLockDownModeNext) {\n+                cancelNotificationsWhenEnterLockDownMode(userId);\n             }\n \n-            // When the mIsInLockDownMode is true, both notifyPostedLocked and\n-            // notifyRemovedLocked will be dismissed. So we shall call\n-            // cancelNotificationsWhenEnterLockDownMode before we set mIsInLockDownMode\n-            // as true and call postNotificationsWhenExitLockDownMode after we set\n-            // mIsInLockDownMode as false.\n-            mIsInLockDownMode = isInLockDownModeNext;\n+            mUserInLockDownMode.put(userId, userInLockDownModeNext);\n \n-            if (!isInLockDownModeNext) {\n-                postNotificationsWhenExitLockDownMode();\n+            if (!userInLockDownModeNext) {\n+                postNotificationsWhenExitLockDownMode(userId);\n             }\n         }\n     }\n@@ -9285,11 +9290,14 @@ public class NotificationManagerService extends SystemService {\n         }\n     }\n \n-    private void cancelNotificationsWhenEnterLockDownMode() {\n+    private void cancelNotificationsWhenEnterLockDownMode(int userId) {\n         synchronized (mNotificationLock) {\n             int numNotifications = mNotificationList.size();\n             for (int i = 0; i < numNotifications; i++) {\n                 NotificationRecord rec = mNotificationList.get(i);\n+                if (rec.getUser().getIdentifier() != userId) {\n+                    continue;\n+                }\n                 mListeners.notifyRemovedLocked(rec, REASON_CANCEL_ALL,\n                         rec.getStats());\n             }\n@@ -9297,14 +9305,23 @@ public class NotificationManagerService extends SystemService {\n         }\n     }\n \n-    private void postNotificationsWhenExitLockDownMode() {\n+    private void postNotificationsWhenExitLockDownMode(int userId) {\n         synchronized (mNotificationLock) {\n             int numNotifications = mNotificationList.size();\n+            // Set the delay to spread out the burst of notifications.\n+            long delay = 0;\n             for (int i = 0; i < numNotifications; i++) {\n                 NotificationRecord rec = mNotificationList.get(i);\n-                mListeners.notifyPostedLocked(rec, rec);\n+                if (rec.getUser().getIdentifier() != userId) {\n+                    continue;\n+                }\n+                mHandler.postDelayed(() -> {\n+                    synchronized (mNotificationLock) {\n+                        mListeners.notifyPostedLocked(rec, rec);\n+                    }\n+                }, delay);\n+                delay += 20;\n             }\n-\n         }\n     }\n \n@@ -9502,12 +9519,15 @@ public class NotificationManagerService extends SystemService {\n      * notifications visible to the given listener.\n      */\n     @GuardedBy(\"mNotificationLock\")\n-    private NotificationRankingUpdate makeRankingUpdateLocked(ManagedServiceInfo info) {\n+    NotificationRankingUpdate makeRankingUpdateLocked(ManagedServiceInfo info) {\n         final int N = mNotificationList.size();\n         final ArrayList<NotificationListenerService.Ranking> rankings = new ArrayList<>();\n \n         for (int i = 0; i < N; i++) {\n             NotificationRecord record = mNotificationList.get(i);\n+            if (isInLockDownMode(record.getUser().getIdentifier())) {\n+                continue;\n+            }\n             if (!isVisibleToListener(record.getSbn(), record.getNotificationType(), info)) {\n                 continue;\n             }\n@@ -9549,8 +9569,8 @@ public class NotificationManagerService extends SystemService {\n                 rankings.toArray(new NotificationListenerService.Ranking[0]));\n     }\n \n-    boolean isInLockDownMode() {\n-        return mStrongAuthTracker.isInLockDownMode();\n+    boolean isInLockDownMode(int userId) {\n+        return mStrongAuthTracker.isInLockDownMode(userId);\n     }\n \n     boolean hasCompanionDevice(ManagedServiceInfo info) {\n@@ -10606,7 +10626,7 @@ public class NotificationManagerService extends SystemService {\n         @GuardedBy(\"mNotificationLock\")\n         void notifyPostedLocked(NotificationRecord r, NotificationRecord old,\n                 boolean notifyAllListeners) {\n-            if (isInLockDownMode()) {\n+            if (isInLockDownMode(r.getUser().getIdentifier())) {\n                 return;\n             }\n \n@@ -10707,7 +10727,7 @@ public class NotificationManagerService extends SystemService {\n         @GuardedBy(\"mNotificationLock\")\n         public void notifyRemovedLocked(NotificationRecord r, int reason,\n                 NotificationStats notificationStats) {\n-            if (isInLockDownMode()) {\n+            if (isInLockDownMode(r.getUser().getIdentifier())) {\n                 return;\n             }\n \n@@ -10756,10 +10776,6 @@ public class NotificationManagerService extends SystemService {\n          */\n         @GuardedBy(\"mNotificationLock\")\n         public void notifyRankingUpdateLocked(List<NotificationRecord> changedHiddenNotifications) {\n-            if (isInLockDownMode()) {\n-                return;\n-            }\n-\n             boolean isHiddenRankingUpdate = changedHiddenNotifications != null\n                     && changedHiddenNotifications.size() > 0;\n             // TODO (b/73052211): if the ranking update changed the notification type,\n",
    "added_lines": 44,
    "deleted_lines": 28,
    "changed_methods": "NotificationManagerService::NotificationListeners::notifyRankingUpdateLocked, NotificationManagerService::makeRankingUpdateLocked, NotificationManagerService::cancelNotificationsWhenEnterLockDownMode, NotificationManagerService::cancelNotificationsWhenEnterLockDownMode, NotificationManagerService::NotificationListeners::notifyRemovedLocked, NotificationManagerService::StrongAuthTracker::isInLockDownMode, NotificationManagerService::postNotificationsWhenExitLockDownMode, NotificationManagerService::isInLockDownMode, NotificationManagerService::StrongAuthTracker::onStrongAuthRequiredChanged, NotificationManagerService::postNotificationsWhenExitLockDownMode, NotificationManagerService::isInLockDownMode, NotificationManagerService::NotificationListeners::notifyPostedLocked, NotificationManagerService::StrongAuthTracker::isInLockDownMode"
   },
   {
    "filename": "NotificationListenersTest.java",
    "diff": "@@ -69,7 +69,6 @@ import java.io.BufferedInputStream;\n import java.io.BufferedOutputStream;\n import java.io.ByteArrayInputStream;\n import java.io.ByteArrayOutputStream;\n-import java.util.List;\n \n public class NotificationListenersTest extends UiServiceTestCase {\n \n@@ -381,63 +380,112 @@ public class NotificationListenersTest extends UiServiceTestCase {\n \n     @Test\n     public void testNotifyPostedLockedInLockdownMode() {\n-        NotificationRecord r = mock(NotificationRecord.class);\n-        NotificationRecord old = mock(NotificationRecord.class);\n-\n-        // before the lockdown mode\n-        when(mNm.isInLockDownMode()).thenReturn(false);\n-        mListeners.notifyPostedLocked(r, old, true);\n-        mListeners.notifyPostedLocked(r, old, false);\n-        verify(r, atLeast(2)).getSbn();\n-\n-        // in the lockdown mode\n-        reset(r);\n-        reset(old);\n-        when(mNm.isInLockDownMode()).thenReturn(true);\n-        mListeners.notifyPostedLocked(r, old, true);\n-        mListeners.notifyPostedLocked(r, old, false);\n-        verify(r, never()).getSbn();\n-    }\n-\n-    @Test\n-    public void testnotifyRankingUpdateLockedInLockdownMode() {\n-        List chn = mock(List.class);\n-\n-        // before the lockdown mode\n-        when(mNm.isInLockDownMode()).thenReturn(false);\n-        mListeners.notifyRankingUpdateLocked(chn);\n-        verify(chn, atLeast(1)).size();\n-\n-        // in the lockdown mode\n-        reset(chn);\n-        when(mNm.isInLockDownMode()).thenReturn(true);\n-        mListeners.notifyRankingUpdateLocked(chn);\n-        verify(chn, never()).size();\n+        NotificationRecord r0 = mock(NotificationRecord.class);\n+        NotificationRecord old0 = mock(NotificationRecord.class);\n+        UserHandle uh0 = mock(UserHandle.class);\n+\n+        NotificationRecord r1 = mock(NotificationRecord.class);\n+        NotificationRecord old1 = mock(NotificationRecord.class);\n+        UserHandle uh1 = mock(UserHandle.class);\n+\n+        // Neither user0 and user1 is in the lockdown mode\n+        when(r0.getUser()).thenReturn(uh0);\n+        when(uh0.getIdentifier()).thenReturn(0);\n+        when(mNm.isInLockDownMode(0)).thenReturn(false);\n+\n+        when(r1.getUser()).thenReturn(uh1);\n+        when(uh1.getIdentifier()).thenReturn(1);\n+        when(mNm.isInLockDownMode(1)).thenReturn(false);\n+\n+        mListeners.notifyPostedLocked(r0, old0, true);\n+        mListeners.notifyPostedLocked(r0, old0, false);\n+        verify(r0, atLeast(2)).getSbn();\n+\n+        mListeners.notifyPostedLocked(r1, old1, true);\n+        mListeners.notifyPostedLocked(r1, old1, false);\n+        verify(r1, atLeast(2)).getSbn();\n+\n+        // Reset\n+        reset(r0);\n+        reset(old0);\n+        reset(r1);\n+        reset(old1);\n+\n+        // Only user 0 is in the lockdown mode\n+        when(r0.getUser()).thenReturn(uh0);\n+        when(uh0.getIdentifier()).thenReturn(0);\n+        when(mNm.isInLockDownMode(0)).thenReturn(true);\n+\n+        when(r1.getUser()).thenReturn(uh1);\n+        when(uh1.getIdentifier()).thenReturn(1);\n+        when(mNm.isInLockDownMode(1)).thenReturn(false);\n+\n+        mListeners.notifyPostedLocked(r0, old0, true);\n+        mListeners.notifyPostedLocked(r0, old0, false);\n+        verify(r0, never()).getSbn();\n+\n+        mListeners.notifyPostedLocked(r1, old1, true);\n+        mListeners.notifyPostedLocked(r1, old1, false);\n+        verify(r1, atLeast(2)).getSbn();\n     }\n \n     @Test\n     public void testNotifyRemovedLockedInLockdownMode() throws NoSuchFieldException {\n-        NotificationRecord r = mock(NotificationRecord.class);\n-        NotificationStats rs = mock(NotificationStats.class);\n+        NotificationRecord r0 = mock(NotificationRecord.class);\n+        NotificationStats rs0 = mock(NotificationStats.class);\n+        UserHandle uh0 = mock(UserHandle.class);\n+\n+        NotificationRecord r1 = mock(NotificationRecord.class);\n+        NotificationStats rs1 = mock(NotificationStats.class);\n+        UserHandle uh1 = mock(UserHandle.class);\n+\n         StatusBarNotification sbn = mock(StatusBarNotification.class);\n         FieldSetter.setField(mNm,\n                 NotificationManagerService.class.getDeclaredField(\"mHandler\"),\n                 mock(NotificationManagerService.WorkerHandler.class));\n \n-        // before the lockdown mode\n-        when(mNm.isInLockDownMode()).thenReturn(false);\n-        when(r.getSbn()).thenReturn(sbn);\n-        mListeners.notifyRemovedLocked(r, 0, rs);\n-        mListeners.notifyRemovedLocked(r, 0, rs);\n-        verify(r, atLeast(2)).getSbn();\n-\n-        // in the lockdown mode\n-        reset(r);\n-        reset(rs);\n-        when(mNm.isInLockDownMode()).thenReturn(true);\n-        when(r.getSbn()).thenReturn(sbn);\n-        mListeners.notifyRemovedLocked(r, 0, rs);\n-        mListeners.notifyRemovedLocked(r, 0, rs);\n-        verify(r, never()).getSbn();\n+        // Neither user0 and user1 is in the lockdown mode\n+        when(r0.getUser()).thenReturn(uh0);\n+        when(uh0.getIdentifier()).thenReturn(0);\n+        when(mNm.isInLockDownMode(0)).thenReturn(false);\n+        when(r0.getSbn()).thenReturn(sbn);\n+\n+        when(r1.getUser()).thenReturn(uh1);\n+        when(uh1.getIdentifier()).thenReturn(1);\n+        when(mNm.isInLockDownMode(1)).thenReturn(false);\n+        when(r1.getSbn()).thenReturn(sbn);\n+\n+        mListeners.notifyRemovedLocked(r0, 0, rs0);\n+        mListeners.notifyRemovedLocked(r0, 0, rs0);\n+        verify(r0, atLeast(2)).getSbn();\n+\n+        mListeners.notifyRemovedLocked(r1, 0, rs1);\n+        mListeners.notifyRemovedLocked(r1, 0, rs1);\n+        verify(r1, atLeast(2)).getSbn();\n+\n+        // Reset\n+        reset(r0);\n+        reset(rs0);\n+        reset(r1);\n+        reset(rs1);\n+\n+        // Only user 0 is in the lockdown mode\n+        when(r0.getUser()).thenReturn(uh0);\n+        when(uh0.getIdentifier()).thenReturn(0);\n+        when(mNm.isInLockDownMode(0)).thenReturn(true);\n+        when(r0.getSbn()).thenReturn(sbn);\n+\n+        when(r1.getUser()).thenReturn(uh1);\n+        when(uh1.getIdentifier()).thenReturn(1);\n+        when(mNm.isInLockDownMode(1)).thenReturn(false);\n+        when(r1.getSbn()).thenReturn(sbn);\n+\n+        mListeners.notifyRemovedLocked(r0, 0, rs0);\n+        mListeners.notifyRemovedLocked(r0, 0, rs0);\n+        verify(r0, never()).getSbn();\n+\n+        mListeners.notifyRemovedLocked(r1, 0, rs1);\n+        mListeners.notifyRemovedLocked(r1, 0, rs1);\n+        verify(r1, atLeast(2)).getSbn();\n     }\n }\n",
    "added_lines": 98,
    "deleted_lines": 50,
    "changed_methods": "NotificationListenersTest::testnotifyRankingUpdateLockedInLockdownMode, NotificationListenersTest::testNotifyPostedLockedInLockdownMode, NotificationListenersTest::testNotifyRemovedLockedInLockdownMode"
   },
   {
    "filename": "NotificationManagerServiceTest.java",
    "diff": "@@ -159,6 +159,7 @@ import android.service.notification.Adjustment;\n import android.service.notification.ConversationChannelWrapper;\n import android.service.notification.NotificationListenerFilter;\n import android.service.notification.NotificationListenerService;\n+import android.service.notification.NotificationRankingUpdate;\n import android.service.notification.NotificationStats;\n import android.service.notification.StatusBarNotification;\n import android.service.notification.ZenPolicy;\n@@ -194,6 +195,7 @@ import com.android.server.SystemService.TargetUser;\n import com.android.server.UiServiceTestCase;\n import com.android.server.lights.LightsManager;\n import com.android.server.lights.LogicalLight;\n+import com.android.server.notification.ManagedServices.ManagedServiceInfo;\n import com.android.server.notification.NotificationManagerService.NotificationAssistants;\n import com.android.server.notification.NotificationManagerService.NotificationListeners;\n import com.android.server.pm.PackageManagerService;\n@@ -345,6 +347,9 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n         @Nullable\n         NotificationAssistantAccessGrantedCallback mNotificationAssistantAccessGrantedCallback;\n \n+        @Nullable\n+        Boolean mIsVisibleToListenerReturnValue = null;\n+\n         TestableNotificationManagerService(Context context, NotificationRecordLogger logger,\n                 InstanceIdSequence notificationInstanceIdSequence) {\n             super(context, logger, notificationInstanceIdSequence);\n@@ -419,6 +424,19 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n             void onGranted(ComponentName assistant, int userId, boolean granted, boolean userSet);\n         }\n \n+        protected void setIsVisibleToListenerReturnValue(boolean value) {\n+            mIsVisibleToListenerReturnValue = value;\n+        }\n+\n+        @Override\n+        boolean isVisibleToListener(StatusBarNotification sbn, int notificationType,\n+                ManagedServiceInfo listener) {\n+            if (mIsVisibleToListenerReturnValue != null) {\n+                return mIsVisibleToListenerReturnValue;\n+            }\n+            return super.isVisibleToListener(sbn, notificationType, listener);\n+        }\n+\n         class StrongAuthTrackerFake extends NotificationManagerService.StrongAuthTracker {\n             private int mGetStrongAuthForUserReturnValue = 0;\n             StrongAuthTrackerFake(Context context) {\n@@ -8514,10 +8532,10 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n         mStrongAuthTracker.setGetStrongAuthForUserReturnValue(\n                 STRONG_AUTH_REQUIRED_AFTER_USER_LOCKDOWN);\n         mStrongAuthTracker.onStrongAuthRequiredChanged(mContext.getUserId());\n-        assertTrue(mStrongAuthTracker.isInLockDownMode());\n-        mStrongAuthTracker.setGetStrongAuthForUserReturnValue(0);\n+        assertTrue(mStrongAuthTracker.isInLockDownMode(mContext.getUserId()));\n+        mStrongAuthTracker.setGetStrongAuthForUserReturnValue(mContext.getUserId());\n         mStrongAuthTracker.onStrongAuthRequiredChanged(mContext.getUserId());\n-        assertFalse(mStrongAuthTracker.isInLockDownMode());\n+        assertFalse(mStrongAuthTracker.isInLockDownMode(mContext.getUserId()));\n     }\n \n     @Test\n@@ -8533,8 +8551,8 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n         // when entering the lockdown mode, cancel the 2 notifications.\n         mStrongAuthTracker.setGetStrongAuthForUserReturnValue(\n                 STRONG_AUTH_REQUIRED_AFTER_USER_LOCKDOWN);\n-        mStrongAuthTracker.onStrongAuthRequiredChanged(mContext.getUserId());\n-        assertTrue(mStrongAuthTracker.isInLockDownMode());\n+        mStrongAuthTracker.onStrongAuthRequiredChanged(0);\n+        assertTrue(mStrongAuthTracker.isInLockDownMode(0));\n \n         // the notifyRemovedLocked function is called twice due to REASON_LOCKDOWN.\n         ArgumentCaptor<Integer> captor = ArgumentCaptor.forClass(Integer.class);\n@@ -8543,9 +8561,45 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n \n         // exit lockdown mode.\n         mStrongAuthTracker.setGetStrongAuthForUserReturnValue(0);\n-        mStrongAuthTracker.onStrongAuthRequiredChanged(mContext.getUserId());\n+        mStrongAuthTracker.onStrongAuthRequiredChanged(0);\n+        assertFalse(mStrongAuthTracker.isInLockDownMode(0));\n \n         // the notifyPostedLocked function is called twice.\n-        verify(mListeners, times(2)).notifyPostedLocked(any(), any());\n+        verify(mWorkerHandler, times(2)).postDelayed(any(Runnable.class), anyLong());\n+        //verify(mListeners, times(2)).notifyPostedLocked(any(), any());\n+    }\n+\n+    @Test\n+    public void testMakeRankingUpdateLockedInLockDownMode() {\n+        // post 2 notifications from a same package\n+        NotificationRecord pkgA = new NotificationRecord(mContext,\n+                generateSbn(\"a\", 1000, 9, 0), mTestNotificationChannel);\n+        mService.addNotification(pkgA);\n+        NotificationRecord pkgB = new NotificationRecord(mContext,\n+                generateSbn(\"a\", 1000, 9, 1), mTestNotificationChannel);\n+        mService.addNotification(pkgB);\n+\n+        mService.setIsVisibleToListenerReturnValue(true);\n+        NotificationRankingUpdate nru = mService.makeRankingUpdateLocked(null);\n+        assertEquals(2, nru.getRankingMap().getOrderedKeys().length);\n+\n+        // when only user 0 entering the lockdown mode, its notification will be suppressed.\n+        mStrongAuthTracker.setGetStrongAuthForUserReturnValue(\n+                STRONG_AUTH_REQUIRED_AFTER_USER_LOCKDOWN);\n+        mStrongAuthTracker.onStrongAuthRequiredChanged(0);\n+        assertTrue(mStrongAuthTracker.isInLockDownMode(0));\n+        assertFalse(mStrongAuthTracker.isInLockDownMode(1));\n+\n+        nru = mService.makeRankingUpdateLocked(null);\n+        assertEquals(1, nru.getRankingMap().getOrderedKeys().length);\n+\n+        // User 0 exits lockdown mode. Its notification will be resumed.\n+        mStrongAuthTracker.setGetStrongAuthForUserReturnValue(0);\n+        mStrongAuthTracker.onStrongAuthRequiredChanged(0);\n+        assertFalse(mStrongAuthTracker.isInLockDownMode(0));\n+        assertFalse(mStrongAuthTracker.isInLockDownMode(1));\n+\n+        nru = mService.makeRankingUpdateLocked(null);\n+        assertEquals(2, nru.getRankingMap().getOrderedKeys().length);\n     }\n }\n",
    "added_lines": 61,
    "deleted_lines": 7,
    "changed_methods": "NotificationManagerServiceTest::TestableNotificationManagerService::setIsVisibleToListenerReturnValue, NotificationManagerServiceTest::testMakeRankingUpdateLockedInLockDownMode, NotificationManagerServiceTest::testCancelAndPostNotificationsWhenEnterAndExitLockDownMode, NotificationManagerServiceTest::TestableNotificationManagerService::isVisibleToListener, NotificationManagerServiceTest::testStrongAuthTracker_isInLockDownMode"
   }
  ]
 },
 {
  "hash": "5676b94f5ff807eea35ebf63b97f83c3ffb2f7a1",
  "commit": "Enable user graularity for lockdown mode\n\nThe NotificationManagerService registers a LockPatternUtils.StrongAuthTracker\nto observe the StrongAuth changes of every user.\nMore specifically, it\u2019s the STRONG_AUTH_REQUIRED_AFTER_USER_LOCKDOWN flag.\nVia this flag, NotificationManagerService can perform the following operations\nwhen the user enter or exit lockdown mode:\n\nEnter lockdown:\n1. Remove all the notifications belonging to the user.\n2. Set the local flag to indicate the lockdown is on for the user.\n   The local flag will suppress the user's notifications on the\n   post, remove and update functions.\n\nExit lockdown:\n1. Clear the local flag to indicate the lockdown is off for the user.\n2. Repost the user\u2019s notifications (suppressed during lockdown mode).\n\nThe CL also updates corresponding tests.\n\nBug: 173721373\nBug: 250743174\nTest: atest NotificationManagerServiceTest\nTest: atest NotificationListenersTest\nIgnore-AOSP-First: pending fix for a security issue.\n\nChange-Id: I4f30e56550729db7d673a92d2a1250509713f36d\nMerged-In: I4f30e56550729db7d673a92d2a1250509713f36d\n(cherry picked from commit de3b12fca23178d8c821058261572449b67d5967)\n(cherry picked from commit 0b56ec9aa245f7bbdf065a4b33b5ef00a558dbe4)\nMerged-In: I4f30e56550729db7d673a92d2a1250509713f36d",
  "files": [
   {
    "filename": "NotificationManagerService.java",
    "diff": "@@ -1919,34 +1919,39 @@ public class NotificationManagerService extends SystemService {\n             return (haystack & needle) != 0;\n         }\n \n-        public boolean isInLockDownMode() {\n-            return mIsInLockDownMode;\n+        // Return whether the user is in lockdown mode.\n+        // If the flag is not set, we assume the user is not in lockdown.\n+        public boolean isInLockDownMode(int userId) {\n+            return mUserInLockDownMode.get(userId, false);\n         }\n \n         @Override\n         public synchronized void onStrongAuthRequiredChanged(int userId) {\n             boolean userInLockDownModeNext = containsFlag(getStrongAuthForUser(userId),\n                     STRONG_AUTH_REQUIRED_AFTER_USER_LOCKDOWN);\n-            mUserInLockDownMode.put(userId, userInLockDownModeNext);\n-            boolean isInLockDownModeNext = mUserInLockDownMode.indexOfValue(true) != -1;\n \n-            if (mIsInLockDownMode == isInLockDownModeNext) {\n+            // Nothing happens if the lockdown mode of userId keeps the same.\n+            if (userInLockDownModeNext == isInLockDownMode(userId)) {\n                 return;\n             }\n \n-            if (isInLockDownModeNext) {\n-                cancelNotificationsWhenEnterLockDownMode();\n+            // When the lockdown mode is changed, we perform the following steps.\n+            // If the userInLockDownModeNext is true, all the function calls to\n+            // notifyPostedLocked and notifyRemovedLocked will not be executed.\n+            // The cancelNotificationsWhenEnterLockDownMode calls notifyRemovedLocked\n+            // and postNotificationsWhenExitLockDownMode calls notifyPostedLocked.\n+            // So we shall call cancelNotificationsWhenEnterLockDownMode before\n+            // we set mUserInLockDownMode as true.\n+            // On the other hand, if the userInLockDownModeNext is false, we shall call\n+            // postNotificationsWhenExitLockDownMode after we put false into mUserInLockDownMode\n+            if (userInLockDownModeNext) {\n+                cancelNotificationsWhenEnterLockDownMode(userId);\n             }\n \n-            // When the mIsInLockDownMode is true, both notifyPostedLocked and\n-            // notifyRemovedLocked will be dismissed. So we shall call\n-            // cancelNotificationsWhenEnterLockDownMode before we set mIsInLockDownMode\n-            // as true and call postNotificationsWhenExitLockDownMode after we set\n-            // mIsInLockDownMode as false.\n-            mIsInLockDownMode = isInLockDownModeNext;\n+            mUserInLockDownMode.put(userId, userInLockDownModeNext);\n \n-            if (!isInLockDownModeNext) {\n-                postNotificationsWhenExitLockDownMode();\n+            if (!userInLockDownModeNext) {\n+                postNotificationsWhenExitLockDownMode(userId);\n             }\n         }\n     }\n@@ -9285,11 +9290,14 @@ public class NotificationManagerService extends SystemService {\n         }\n     }\n \n-    private void cancelNotificationsWhenEnterLockDownMode() {\n+    private void cancelNotificationsWhenEnterLockDownMode(int userId) {\n         synchronized (mNotificationLock) {\n             int numNotifications = mNotificationList.size();\n             for (int i = 0; i < numNotifications; i++) {\n                 NotificationRecord rec = mNotificationList.get(i);\n+                if (rec.getUser().getIdentifier() != userId) {\n+                    continue;\n+                }\n                 mListeners.notifyRemovedLocked(rec, REASON_CANCEL_ALL,\n                         rec.getStats());\n             }\n@@ -9297,14 +9305,23 @@ public class NotificationManagerService extends SystemService {\n         }\n     }\n \n-    private void postNotificationsWhenExitLockDownMode() {\n+    private void postNotificationsWhenExitLockDownMode(int userId) {\n         synchronized (mNotificationLock) {\n             int numNotifications = mNotificationList.size();\n+            // Set the delay to spread out the burst of notifications.\n+            long delay = 0;\n             for (int i = 0; i < numNotifications; i++) {\n                 NotificationRecord rec = mNotificationList.get(i);\n-                mListeners.notifyPostedLocked(rec, rec);\n+                if (rec.getUser().getIdentifier() != userId) {\n+                    continue;\n+                }\n+                mHandler.postDelayed(() -> {\n+                    synchronized (mNotificationLock) {\n+                        mListeners.notifyPostedLocked(rec, rec);\n+                    }\n+                }, delay);\n+                delay += 20;\n             }\n-\n         }\n     }\n \n@@ -9502,12 +9519,15 @@ public class NotificationManagerService extends SystemService {\n      * notifications visible to the given listener.\n      */\n     @GuardedBy(\"mNotificationLock\")\n-    private NotificationRankingUpdate makeRankingUpdateLocked(ManagedServiceInfo info) {\n+    NotificationRankingUpdate makeRankingUpdateLocked(ManagedServiceInfo info) {\n         final int N = mNotificationList.size();\n         final ArrayList<NotificationListenerService.Ranking> rankings = new ArrayList<>();\n \n         for (int i = 0; i < N; i++) {\n             NotificationRecord record = mNotificationList.get(i);\n+            if (isInLockDownMode(record.getUser().getIdentifier())) {\n+                continue;\n+            }\n             if (!isVisibleToListener(record.getSbn(), record.getNotificationType(), info)) {\n                 continue;\n             }\n@@ -9549,8 +9569,8 @@ public class NotificationManagerService extends SystemService {\n                 rankings.toArray(new NotificationListenerService.Ranking[0]));\n     }\n \n-    boolean isInLockDownMode() {\n-        return mStrongAuthTracker.isInLockDownMode();\n+    boolean isInLockDownMode(int userId) {\n+        return mStrongAuthTracker.isInLockDownMode(userId);\n     }\n \n     boolean hasCompanionDevice(ManagedServiceInfo info) {\n@@ -10606,7 +10626,7 @@ public class NotificationManagerService extends SystemService {\n         @GuardedBy(\"mNotificationLock\")\n         void notifyPostedLocked(NotificationRecord r, NotificationRecord old,\n                 boolean notifyAllListeners) {\n-            if (isInLockDownMode()) {\n+            if (isInLockDownMode(r.getUser().getIdentifier())) {\n                 return;\n             }\n \n@@ -10707,7 +10727,7 @@ public class NotificationManagerService extends SystemService {\n         @GuardedBy(\"mNotificationLock\")\n         public void notifyRemovedLocked(NotificationRecord r, int reason,\n                 NotificationStats notificationStats) {\n-            if (isInLockDownMode()) {\n+            if (isInLockDownMode(r.getUser().getIdentifier())) {\n                 return;\n             }\n \n@@ -10756,10 +10776,6 @@ public class NotificationManagerService extends SystemService {\n          */\n         @GuardedBy(\"mNotificationLock\")\n         public void notifyRankingUpdateLocked(List<NotificationRecord> changedHiddenNotifications) {\n-            if (isInLockDownMode()) {\n-                return;\n-            }\n-\n             boolean isHiddenRankingUpdate = changedHiddenNotifications != null\n                     && changedHiddenNotifications.size() > 0;\n             // TODO (b/73052211): if the ranking update changed the notification type,\n",
    "added_lines": 44,
    "deleted_lines": 28,
    "changed_methods": "NotificationManagerService::NotificationListeners::notifyRankingUpdateLocked, NotificationManagerService::makeRankingUpdateLocked, NotificationManagerService::cancelNotificationsWhenEnterLockDownMode, NotificationManagerService::cancelNotificationsWhenEnterLockDownMode, NotificationManagerService::NotificationListeners::notifyRemovedLocked, NotificationManagerService::StrongAuthTracker::isInLockDownMode, NotificationManagerService::postNotificationsWhenExitLockDownMode, NotificationManagerService::isInLockDownMode, NotificationManagerService::StrongAuthTracker::onStrongAuthRequiredChanged, NotificationManagerService::postNotificationsWhenExitLockDownMode, NotificationManagerService::isInLockDownMode, NotificationManagerService::NotificationListeners::notifyPostedLocked, NotificationManagerService::StrongAuthTracker::isInLockDownMode"
   },
   {
    "filename": "NotificationListenersTest.java",
    "diff": "@@ -69,7 +69,6 @@ import java.io.BufferedInputStream;\n import java.io.BufferedOutputStream;\n import java.io.ByteArrayInputStream;\n import java.io.ByteArrayOutputStream;\n-import java.util.List;\n \n public class NotificationListenersTest extends UiServiceTestCase {\n \n@@ -381,63 +380,112 @@ public class NotificationListenersTest extends UiServiceTestCase {\n \n     @Test\n     public void testNotifyPostedLockedInLockdownMode() {\n-        NotificationRecord r = mock(NotificationRecord.class);\n-        NotificationRecord old = mock(NotificationRecord.class);\n-\n-        // before the lockdown mode\n-        when(mNm.isInLockDownMode()).thenReturn(false);\n-        mListeners.notifyPostedLocked(r, old, true);\n-        mListeners.notifyPostedLocked(r, old, false);\n-        verify(r, atLeast(2)).getSbn();\n-\n-        // in the lockdown mode\n-        reset(r);\n-        reset(old);\n-        when(mNm.isInLockDownMode()).thenReturn(true);\n-        mListeners.notifyPostedLocked(r, old, true);\n-        mListeners.notifyPostedLocked(r, old, false);\n-        verify(r, never()).getSbn();\n-    }\n-\n-    @Test\n-    public void testnotifyRankingUpdateLockedInLockdownMode() {\n-        List chn = mock(List.class);\n-\n-        // before the lockdown mode\n-        when(mNm.isInLockDownMode()).thenReturn(false);\n-        mListeners.notifyRankingUpdateLocked(chn);\n-        verify(chn, atLeast(1)).size();\n-\n-        // in the lockdown mode\n-        reset(chn);\n-        when(mNm.isInLockDownMode()).thenReturn(true);\n-        mListeners.notifyRankingUpdateLocked(chn);\n-        verify(chn, never()).size();\n+        NotificationRecord r0 = mock(NotificationRecord.class);\n+        NotificationRecord old0 = mock(NotificationRecord.class);\n+        UserHandle uh0 = mock(UserHandle.class);\n+\n+        NotificationRecord r1 = mock(NotificationRecord.class);\n+        NotificationRecord old1 = mock(NotificationRecord.class);\n+        UserHandle uh1 = mock(UserHandle.class);\n+\n+        // Neither user0 and user1 is in the lockdown mode\n+        when(r0.getUser()).thenReturn(uh0);\n+        when(uh0.getIdentifier()).thenReturn(0);\n+        when(mNm.isInLockDownMode(0)).thenReturn(false);\n+\n+        when(r1.getUser()).thenReturn(uh1);\n+        when(uh1.getIdentifier()).thenReturn(1);\n+        when(mNm.isInLockDownMode(1)).thenReturn(false);\n+\n+        mListeners.notifyPostedLocked(r0, old0, true);\n+        mListeners.notifyPostedLocked(r0, old0, false);\n+        verify(r0, atLeast(2)).getSbn();\n+\n+        mListeners.notifyPostedLocked(r1, old1, true);\n+        mListeners.notifyPostedLocked(r1, old1, false);\n+        verify(r1, atLeast(2)).getSbn();\n+\n+        // Reset\n+        reset(r0);\n+        reset(old0);\n+        reset(r1);\n+        reset(old1);\n+\n+        // Only user 0 is in the lockdown mode\n+        when(r0.getUser()).thenReturn(uh0);\n+        when(uh0.getIdentifier()).thenReturn(0);\n+        when(mNm.isInLockDownMode(0)).thenReturn(true);\n+\n+        when(r1.getUser()).thenReturn(uh1);\n+        when(uh1.getIdentifier()).thenReturn(1);\n+        when(mNm.isInLockDownMode(1)).thenReturn(false);\n+\n+        mListeners.notifyPostedLocked(r0, old0, true);\n+        mListeners.notifyPostedLocked(r0, old0, false);\n+        verify(r0, never()).getSbn();\n+\n+        mListeners.notifyPostedLocked(r1, old1, true);\n+        mListeners.notifyPostedLocked(r1, old1, false);\n+        verify(r1, atLeast(2)).getSbn();\n     }\n \n     @Test\n     public void testNotifyRemovedLockedInLockdownMode() throws NoSuchFieldException {\n-        NotificationRecord r = mock(NotificationRecord.class);\n-        NotificationStats rs = mock(NotificationStats.class);\n+        NotificationRecord r0 = mock(NotificationRecord.class);\n+        NotificationStats rs0 = mock(NotificationStats.class);\n+        UserHandle uh0 = mock(UserHandle.class);\n+\n+        NotificationRecord r1 = mock(NotificationRecord.class);\n+        NotificationStats rs1 = mock(NotificationStats.class);\n+        UserHandle uh1 = mock(UserHandle.class);\n+\n         StatusBarNotification sbn = mock(StatusBarNotification.class);\n         FieldSetter.setField(mNm,\n                 NotificationManagerService.class.getDeclaredField(\"mHandler\"),\n                 mock(NotificationManagerService.WorkerHandler.class));\n \n-        // before the lockdown mode\n-        when(mNm.isInLockDownMode()).thenReturn(false);\n-        when(r.getSbn()).thenReturn(sbn);\n-        mListeners.notifyRemovedLocked(r, 0, rs);\n-        mListeners.notifyRemovedLocked(r, 0, rs);\n-        verify(r, atLeast(2)).getSbn();\n-\n-        // in the lockdown mode\n-        reset(r);\n-        reset(rs);\n-        when(mNm.isInLockDownMode()).thenReturn(true);\n-        when(r.getSbn()).thenReturn(sbn);\n-        mListeners.notifyRemovedLocked(r, 0, rs);\n-        mListeners.notifyRemovedLocked(r, 0, rs);\n-        verify(r, never()).getSbn();\n+        // Neither user0 and user1 is in the lockdown mode\n+        when(r0.getUser()).thenReturn(uh0);\n+        when(uh0.getIdentifier()).thenReturn(0);\n+        when(mNm.isInLockDownMode(0)).thenReturn(false);\n+        when(r0.getSbn()).thenReturn(sbn);\n+\n+        when(r1.getUser()).thenReturn(uh1);\n+        when(uh1.getIdentifier()).thenReturn(1);\n+        when(mNm.isInLockDownMode(1)).thenReturn(false);\n+        when(r1.getSbn()).thenReturn(sbn);\n+\n+        mListeners.notifyRemovedLocked(r0, 0, rs0);\n+        mListeners.notifyRemovedLocked(r0, 0, rs0);\n+        verify(r0, atLeast(2)).getSbn();\n+\n+        mListeners.notifyRemovedLocked(r1, 0, rs1);\n+        mListeners.notifyRemovedLocked(r1, 0, rs1);\n+        verify(r1, atLeast(2)).getSbn();\n+\n+        // Reset\n+        reset(r0);\n+        reset(rs0);\n+        reset(r1);\n+        reset(rs1);\n+\n+        // Only user 0 is in the lockdown mode\n+        when(r0.getUser()).thenReturn(uh0);\n+        when(uh0.getIdentifier()).thenReturn(0);\n+        when(mNm.isInLockDownMode(0)).thenReturn(true);\n+        when(r0.getSbn()).thenReturn(sbn);\n+\n+        when(r1.getUser()).thenReturn(uh1);\n+        when(uh1.getIdentifier()).thenReturn(1);\n+        when(mNm.isInLockDownMode(1)).thenReturn(false);\n+        when(r1.getSbn()).thenReturn(sbn);\n+\n+        mListeners.notifyRemovedLocked(r0, 0, rs0);\n+        mListeners.notifyRemovedLocked(r0, 0, rs0);\n+        verify(r0, never()).getSbn();\n+\n+        mListeners.notifyRemovedLocked(r1, 0, rs1);\n+        mListeners.notifyRemovedLocked(r1, 0, rs1);\n+        verify(r1, atLeast(2)).getSbn();\n     }\n }\n",
    "added_lines": 98,
    "deleted_lines": 50,
    "changed_methods": "NotificationListenersTest::testnotifyRankingUpdateLockedInLockdownMode, NotificationListenersTest::testNotifyPostedLockedInLockdownMode, NotificationListenersTest::testNotifyRemovedLockedInLockdownMode"
   },
   {
    "filename": "NotificationManagerServiceTest.java",
    "diff": "@@ -159,6 +159,7 @@ import android.service.notification.Adjustment;\n import android.service.notification.ConversationChannelWrapper;\n import android.service.notification.NotificationListenerFilter;\n import android.service.notification.NotificationListenerService;\n+import android.service.notification.NotificationRankingUpdate;\n import android.service.notification.NotificationStats;\n import android.service.notification.StatusBarNotification;\n import android.service.notification.ZenPolicy;\n@@ -194,6 +195,7 @@ import com.android.server.SystemService.TargetUser;\n import com.android.server.UiServiceTestCase;\n import com.android.server.lights.LightsManager;\n import com.android.server.lights.LogicalLight;\n+import com.android.server.notification.ManagedServices.ManagedServiceInfo;\n import com.android.server.notification.NotificationManagerService.NotificationAssistants;\n import com.android.server.notification.NotificationManagerService.NotificationListeners;\n import com.android.server.pm.PackageManagerService;\n@@ -345,6 +347,9 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n         @Nullable\n         NotificationAssistantAccessGrantedCallback mNotificationAssistantAccessGrantedCallback;\n \n+        @Nullable\n+        Boolean mIsVisibleToListenerReturnValue = null;\n+\n         TestableNotificationManagerService(Context context, NotificationRecordLogger logger,\n                 InstanceIdSequence notificationInstanceIdSequence) {\n             super(context, logger, notificationInstanceIdSequence);\n@@ -419,6 +424,19 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n             void onGranted(ComponentName assistant, int userId, boolean granted, boolean userSet);\n         }\n \n+        protected void setIsVisibleToListenerReturnValue(boolean value) {\n+            mIsVisibleToListenerReturnValue = value;\n+        }\n+\n+        @Override\n+        boolean isVisibleToListener(StatusBarNotification sbn, int notificationType,\n+                ManagedServiceInfo listener) {\n+            if (mIsVisibleToListenerReturnValue != null) {\n+                return mIsVisibleToListenerReturnValue;\n+            }\n+            return super.isVisibleToListener(sbn, notificationType, listener);\n+        }\n+\n         class StrongAuthTrackerFake extends NotificationManagerService.StrongAuthTracker {\n             private int mGetStrongAuthForUserReturnValue = 0;\n             StrongAuthTrackerFake(Context context) {\n@@ -8514,10 +8532,10 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n         mStrongAuthTracker.setGetStrongAuthForUserReturnValue(\n                 STRONG_AUTH_REQUIRED_AFTER_USER_LOCKDOWN);\n         mStrongAuthTracker.onStrongAuthRequiredChanged(mContext.getUserId());\n-        assertTrue(mStrongAuthTracker.isInLockDownMode());\n-        mStrongAuthTracker.setGetStrongAuthForUserReturnValue(0);\n+        assertTrue(mStrongAuthTracker.isInLockDownMode(mContext.getUserId()));\n+        mStrongAuthTracker.setGetStrongAuthForUserReturnValue(mContext.getUserId());\n         mStrongAuthTracker.onStrongAuthRequiredChanged(mContext.getUserId());\n-        assertFalse(mStrongAuthTracker.isInLockDownMode());\n+        assertFalse(mStrongAuthTracker.isInLockDownMode(mContext.getUserId()));\n     }\n \n     @Test\n@@ -8533,8 +8551,8 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n         // when entering the lockdown mode, cancel the 2 notifications.\n         mStrongAuthTracker.setGetStrongAuthForUserReturnValue(\n                 STRONG_AUTH_REQUIRED_AFTER_USER_LOCKDOWN);\n-        mStrongAuthTracker.onStrongAuthRequiredChanged(mContext.getUserId());\n-        assertTrue(mStrongAuthTracker.isInLockDownMode());\n+        mStrongAuthTracker.onStrongAuthRequiredChanged(0);\n+        assertTrue(mStrongAuthTracker.isInLockDownMode(0));\n \n         // the notifyRemovedLocked function is called twice due to REASON_LOCKDOWN.\n         ArgumentCaptor<Integer> captor = ArgumentCaptor.forClass(Integer.class);\n@@ -8543,9 +8561,45 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n \n         // exit lockdown mode.\n         mStrongAuthTracker.setGetStrongAuthForUserReturnValue(0);\n-        mStrongAuthTracker.onStrongAuthRequiredChanged(mContext.getUserId());\n+        mStrongAuthTracker.onStrongAuthRequiredChanged(0);\n+        assertFalse(mStrongAuthTracker.isInLockDownMode(0));\n \n         // the notifyPostedLocked function is called twice.\n-        verify(mListeners, times(2)).notifyPostedLocked(any(), any());\n+        verify(mWorkerHandler, times(2)).postDelayed(any(Runnable.class), anyLong());\n+        //verify(mListeners, times(2)).notifyPostedLocked(any(), any());\n+    }\n+\n+    @Test\n+    public void testMakeRankingUpdateLockedInLockDownMode() {\n+        // post 2 notifications from a same package\n+        NotificationRecord pkgA = new NotificationRecord(mContext,\n+                generateSbn(\"a\", 1000, 9, 0), mTestNotificationChannel);\n+        mService.addNotification(pkgA);\n+        NotificationRecord pkgB = new NotificationRecord(mContext,\n+                generateSbn(\"a\", 1000, 9, 1), mTestNotificationChannel);\n+        mService.addNotification(pkgB);\n+\n+        mService.setIsVisibleToListenerReturnValue(true);\n+        NotificationRankingUpdate nru = mService.makeRankingUpdateLocked(null);\n+        assertEquals(2, nru.getRankingMap().getOrderedKeys().length);\n+\n+        // when only user 0 entering the lockdown mode, its notification will be suppressed.\n+        mStrongAuthTracker.setGetStrongAuthForUserReturnValue(\n+                STRONG_AUTH_REQUIRED_AFTER_USER_LOCKDOWN);\n+        mStrongAuthTracker.onStrongAuthRequiredChanged(0);\n+        assertTrue(mStrongAuthTracker.isInLockDownMode(0));\n+        assertFalse(mStrongAuthTracker.isInLockDownMode(1));\n+\n+        nru = mService.makeRankingUpdateLocked(null);\n+        assertEquals(1, nru.getRankingMap().getOrderedKeys().length);\n+\n+        // User 0 exits lockdown mode. Its notification will be resumed.\n+        mStrongAuthTracker.setGetStrongAuthForUserReturnValue(0);\n+        mStrongAuthTracker.onStrongAuthRequiredChanged(0);\n+        assertFalse(mStrongAuthTracker.isInLockDownMode(0));\n+        assertFalse(mStrongAuthTracker.isInLockDownMode(1));\n+\n+        nru = mService.makeRankingUpdateLocked(null);\n+        assertEquals(2, nru.getRankingMap().getOrderedKeys().length);\n     }\n }\n",
    "added_lines": 61,
    "deleted_lines": 7,
    "changed_methods": "NotificationManagerServiceTest::TestableNotificationManagerService::setIsVisibleToListenerReturnValue, NotificationManagerServiceTest::testMakeRankingUpdateLockedInLockDownMode, NotificationManagerServiceTest::testCancelAndPostNotificationsWhenEnterAndExitLockDownMode, NotificationManagerServiceTest::TestableNotificationManagerService::isVisibleToListener, NotificationManagerServiceTest::testStrongAuthTracker_isInLockDownMode"
   }
  ]
 },
 {
  "hash": "5676b94f5ff807eea35ebf63b97f83c3ffb2f7a1",
  "commit": "Enable user graularity for lockdown mode\n\nThe NotificationManagerService registers a LockPatternUtils.StrongAuthTracker\nto observe the StrongAuth changes of every user.\nMore specifically, it\u2019s the STRONG_AUTH_REQUIRED_AFTER_USER_LOCKDOWN flag.\nVia this flag, NotificationManagerService can perform the following operations\nwhen the user enter or exit lockdown mode:\n\nEnter lockdown:\n1. Remove all the notifications belonging to the user.\n2. Set the local flag to indicate the lockdown is on for the user.\n   The local flag will suppress the user's notifications on the\n   post, remove and update functions.\n\nExit lockdown:\n1. Clear the local flag to indicate the lockdown is off for the user.\n2. Repost the user\u2019s notifications (suppressed during lockdown mode).\n\nThe CL also updates corresponding tests.\n\nBug: 173721373\nBug: 250743174\nTest: atest NotificationManagerServiceTest\nTest: atest NotificationListenersTest\nIgnore-AOSP-First: pending fix for a security issue.\n\nChange-Id: I4f30e56550729db7d673a92d2a1250509713f36d\nMerged-In: I4f30e56550729db7d673a92d2a1250509713f36d\n(cherry picked from commit de3b12fca23178d8c821058261572449b67d5967)\n(cherry picked from commit 0b56ec9aa245f7bbdf065a4b33b5ef00a558dbe4)\nMerged-In: I4f30e56550729db7d673a92d2a1250509713f36d",
  "files": [
   {
    "filename": "NotificationManagerService.java",
    "diff": "@@ -1919,34 +1919,39 @@ public class NotificationManagerService extends SystemService {\n             return (haystack & needle) != 0;\n         }\n \n-        public boolean isInLockDownMode() {\n-            return mIsInLockDownMode;\n+        // Return whether the user is in lockdown mode.\n+        // If the flag is not set, we assume the user is not in lockdown.\n+        public boolean isInLockDownMode(int userId) {\n+            return mUserInLockDownMode.get(userId, false);\n         }\n \n         @Override\n         public synchronized void onStrongAuthRequiredChanged(int userId) {\n             boolean userInLockDownModeNext = containsFlag(getStrongAuthForUser(userId),\n                     STRONG_AUTH_REQUIRED_AFTER_USER_LOCKDOWN);\n-            mUserInLockDownMode.put(userId, userInLockDownModeNext);\n-            boolean isInLockDownModeNext = mUserInLockDownMode.indexOfValue(true) != -1;\n \n-            if (mIsInLockDownMode == isInLockDownModeNext) {\n+            // Nothing happens if the lockdown mode of userId keeps the same.\n+            if (userInLockDownModeNext == isInLockDownMode(userId)) {\n                 return;\n             }\n \n-            if (isInLockDownModeNext) {\n-                cancelNotificationsWhenEnterLockDownMode();\n+            // When the lockdown mode is changed, we perform the following steps.\n+            // If the userInLockDownModeNext is true, all the function calls to\n+            // notifyPostedLocked and notifyRemovedLocked will not be executed.\n+            // The cancelNotificationsWhenEnterLockDownMode calls notifyRemovedLocked\n+            // and postNotificationsWhenExitLockDownMode calls notifyPostedLocked.\n+            // So we shall call cancelNotificationsWhenEnterLockDownMode before\n+            // we set mUserInLockDownMode as true.\n+            // On the other hand, if the userInLockDownModeNext is false, we shall call\n+            // postNotificationsWhenExitLockDownMode after we put false into mUserInLockDownMode\n+            if (userInLockDownModeNext) {\n+                cancelNotificationsWhenEnterLockDownMode(userId);\n             }\n \n-            // When the mIsInLockDownMode is true, both notifyPostedLocked and\n-            // notifyRemovedLocked will be dismissed. So we shall call\n-            // cancelNotificationsWhenEnterLockDownMode before we set mIsInLockDownMode\n-            // as true and call postNotificationsWhenExitLockDownMode after we set\n-            // mIsInLockDownMode as false.\n-            mIsInLockDownMode = isInLockDownModeNext;\n+            mUserInLockDownMode.put(userId, userInLockDownModeNext);\n \n-            if (!isInLockDownModeNext) {\n-                postNotificationsWhenExitLockDownMode();\n+            if (!userInLockDownModeNext) {\n+                postNotificationsWhenExitLockDownMode(userId);\n             }\n         }\n     }\n@@ -9285,11 +9290,14 @@ public class NotificationManagerService extends SystemService {\n         }\n     }\n \n-    private void cancelNotificationsWhenEnterLockDownMode() {\n+    private void cancelNotificationsWhenEnterLockDownMode(int userId) {\n         synchronized (mNotificationLock) {\n             int numNotifications = mNotificationList.size();\n             for (int i = 0; i < numNotifications; i++) {\n                 NotificationRecord rec = mNotificationList.get(i);\n+                if (rec.getUser().getIdentifier() != userId) {\n+                    continue;\n+                }\n                 mListeners.notifyRemovedLocked(rec, REASON_CANCEL_ALL,\n                         rec.getStats());\n             }\n@@ -9297,14 +9305,23 @@ public class NotificationManagerService extends SystemService {\n         }\n     }\n \n-    private void postNotificationsWhenExitLockDownMode() {\n+    private void postNotificationsWhenExitLockDownMode(int userId) {\n         synchronized (mNotificationLock) {\n             int numNotifications = mNotificationList.size();\n+            // Set the delay to spread out the burst of notifications.\n+            long delay = 0;\n             for (int i = 0; i < numNotifications; i++) {\n                 NotificationRecord rec = mNotificationList.get(i);\n-                mListeners.notifyPostedLocked(rec, rec);\n+                if (rec.getUser().getIdentifier() != userId) {\n+                    continue;\n+                }\n+                mHandler.postDelayed(() -> {\n+                    synchronized (mNotificationLock) {\n+                        mListeners.notifyPostedLocked(rec, rec);\n+                    }\n+                }, delay);\n+                delay += 20;\n             }\n-\n         }\n     }\n \n@@ -9502,12 +9519,15 @@ public class NotificationManagerService extends SystemService {\n      * notifications visible to the given listener.\n      */\n     @GuardedBy(\"mNotificationLock\")\n-    private NotificationRankingUpdate makeRankingUpdateLocked(ManagedServiceInfo info) {\n+    NotificationRankingUpdate makeRankingUpdateLocked(ManagedServiceInfo info) {\n         final int N = mNotificationList.size();\n         final ArrayList<NotificationListenerService.Ranking> rankings = new ArrayList<>();\n \n         for (int i = 0; i < N; i++) {\n             NotificationRecord record = mNotificationList.get(i);\n+            if (isInLockDownMode(record.getUser().getIdentifier())) {\n+                continue;\n+            }\n             if (!isVisibleToListener(record.getSbn(), record.getNotificationType(), info)) {\n                 continue;\n             }\n@@ -9549,8 +9569,8 @@ public class NotificationManagerService extends SystemService {\n                 rankings.toArray(new NotificationListenerService.Ranking[0]));\n     }\n \n-    boolean isInLockDownMode() {\n-        return mStrongAuthTracker.isInLockDownMode();\n+    boolean isInLockDownMode(int userId) {\n+        return mStrongAuthTracker.isInLockDownMode(userId);\n     }\n \n     boolean hasCompanionDevice(ManagedServiceInfo info) {\n@@ -10606,7 +10626,7 @@ public class NotificationManagerService extends SystemService {\n         @GuardedBy(\"mNotificationLock\")\n         void notifyPostedLocked(NotificationRecord r, NotificationRecord old,\n                 boolean notifyAllListeners) {\n-            if (isInLockDownMode()) {\n+            if (isInLockDownMode(r.getUser().getIdentifier())) {\n                 return;\n             }\n \n@@ -10707,7 +10727,7 @@ public class NotificationManagerService extends SystemService {\n         @GuardedBy(\"mNotificationLock\")\n         public void notifyRemovedLocked(NotificationRecord r, int reason,\n                 NotificationStats notificationStats) {\n-            if (isInLockDownMode()) {\n+            if (isInLockDownMode(r.getUser().getIdentifier())) {\n                 return;\n             }\n \n@@ -10756,10 +10776,6 @@ public class NotificationManagerService extends SystemService {\n          */\n         @GuardedBy(\"mNotificationLock\")\n         public void notifyRankingUpdateLocked(List<NotificationRecord> changedHiddenNotifications) {\n-            if (isInLockDownMode()) {\n-                return;\n-            }\n-\n             boolean isHiddenRankingUpdate = changedHiddenNotifications != null\n                     && changedHiddenNotifications.size() > 0;\n             // TODO (b/73052211): if the ranking update changed the notification type,\n",
    "added_lines": 44,
    "deleted_lines": 28,
    "changed_methods": "NotificationManagerService::NotificationListeners::notifyRankingUpdateLocked, NotificationManagerService::makeRankingUpdateLocked, NotificationManagerService::cancelNotificationsWhenEnterLockDownMode, NotificationManagerService::cancelNotificationsWhenEnterLockDownMode, NotificationManagerService::NotificationListeners::notifyRemovedLocked, NotificationManagerService::StrongAuthTracker::isInLockDownMode, NotificationManagerService::postNotificationsWhenExitLockDownMode, NotificationManagerService::isInLockDownMode, NotificationManagerService::StrongAuthTracker::onStrongAuthRequiredChanged, NotificationManagerService::postNotificationsWhenExitLockDownMode, NotificationManagerService::isInLockDownMode, NotificationManagerService::NotificationListeners::notifyPostedLocked, NotificationManagerService::StrongAuthTracker::isInLockDownMode"
   },
   {
    "filename": "NotificationListenersTest.java",
    "diff": "@@ -69,7 +69,6 @@ import java.io.BufferedInputStream;\n import java.io.BufferedOutputStream;\n import java.io.ByteArrayInputStream;\n import java.io.ByteArrayOutputStream;\n-import java.util.List;\n \n public class NotificationListenersTest extends UiServiceTestCase {\n \n@@ -381,63 +380,112 @@ public class NotificationListenersTest extends UiServiceTestCase {\n \n     @Test\n     public void testNotifyPostedLockedInLockdownMode() {\n-        NotificationRecord r = mock(NotificationRecord.class);\n-        NotificationRecord old = mock(NotificationRecord.class);\n-\n-        // before the lockdown mode\n-        when(mNm.isInLockDownMode()).thenReturn(false);\n-        mListeners.notifyPostedLocked(r, old, true);\n-        mListeners.notifyPostedLocked(r, old, false);\n-        verify(r, atLeast(2)).getSbn();\n-\n-        // in the lockdown mode\n-        reset(r);\n-        reset(old);\n-        when(mNm.isInLockDownMode()).thenReturn(true);\n-        mListeners.notifyPostedLocked(r, old, true);\n-        mListeners.notifyPostedLocked(r, old, false);\n-        verify(r, never()).getSbn();\n-    }\n-\n-    @Test\n-    public void testnotifyRankingUpdateLockedInLockdownMode() {\n-        List chn = mock(List.class);\n-\n-        // before the lockdown mode\n-        when(mNm.isInLockDownMode()).thenReturn(false);\n-        mListeners.notifyRankingUpdateLocked(chn);\n-        verify(chn, atLeast(1)).size();\n-\n-        // in the lockdown mode\n-        reset(chn);\n-        when(mNm.isInLockDownMode()).thenReturn(true);\n-        mListeners.notifyRankingUpdateLocked(chn);\n-        verify(chn, never()).size();\n+        NotificationRecord r0 = mock(NotificationRecord.class);\n+        NotificationRecord old0 = mock(NotificationRecord.class);\n+        UserHandle uh0 = mock(UserHandle.class);\n+\n+        NotificationRecord r1 = mock(NotificationRecord.class);\n+        NotificationRecord old1 = mock(NotificationRecord.class);\n+        UserHandle uh1 = mock(UserHandle.class);\n+\n+        // Neither user0 and user1 is in the lockdown mode\n+        when(r0.getUser()).thenReturn(uh0);\n+        when(uh0.getIdentifier()).thenReturn(0);\n+        when(mNm.isInLockDownMode(0)).thenReturn(false);\n+\n+        when(r1.getUser()).thenReturn(uh1);\n+        when(uh1.getIdentifier()).thenReturn(1);\n+        when(mNm.isInLockDownMode(1)).thenReturn(false);\n+\n+        mListeners.notifyPostedLocked(r0, old0, true);\n+        mListeners.notifyPostedLocked(r0, old0, false);\n+        verify(r0, atLeast(2)).getSbn();\n+\n+        mListeners.notifyPostedLocked(r1, old1, true);\n+        mListeners.notifyPostedLocked(r1, old1, false);\n+        verify(r1, atLeast(2)).getSbn();\n+\n+        // Reset\n+        reset(r0);\n+        reset(old0);\n+        reset(r1);\n+        reset(old1);\n+\n+        // Only user 0 is in the lockdown mode\n+        when(r0.getUser()).thenReturn(uh0);\n+        when(uh0.getIdentifier()).thenReturn(0);\n+        when(mNm.isInLockDownMode(0)).thenReturn(true);\n+\n+        when(r1.getUser()).thenReturn(uh1);\n+        when(uh1.getIdentifier()).thenReturn(1);\n+        when(mNm.isInLockDownMode(1)).thenReturn(false);\n+\n+        mListeners.notifyPostedLocked(r0, old0, true);\n+        mListeners.notifyPostedLocked(r0, old0, false);\n+        verify(r0, never()).getSbn();\n+\n+        mListeners.notifyPostedLocked(r1, old1, true);\n+        mListeners.notifyPostedLocked(r1, old1, false);\n+        verify(r1, atLeast(2)).getSbn();\n     }\n \n     @Test\n     public void testNotifyRemovedLockedInLockdownMode() throws NoSuchFieldException {\n-        NotificationRecord r = mock(NotificationRecord.class);\n-        NotificationStats rs = mock(NotificationStats.class);\n+        NotificationRecord r0 = mock(NotificationRecord.class);\n+        NotificationStats rs0 = mock(NotificationStats.class);\n+        UserHandle uh0 = mock(UserHandle.class);\n+\n+        NotificationRecord r1 = mock(NotificationRecord.class);\n+        NotificationStats rs1 = mock(NotificationStats.class);\n+        UserHandle uh1 = mock(UserHandle.class);\n+\n         StatusBarNotification sbn = mock(StatusBarNotification.class);\n         FieldSetter.setField(mNm,\n                 NotificationManagerService.class.getDeclaredField(\"mHandler\"),\n                 mock(NotificationManagerService.WorkerHandler.class));\n \n-        // before the lockdown mode\n-        when(mNm.isInLockDownMode()).thenReturn(false);\n-        when(r.getSbn()).thenReturn(sbn);\n-        mListeners.notifyRemovedLocked(r, 0, rs);\n-        mListeners.notifyRemovedLocked(r, 0, rs);\n-        verify(r, atLeast(2)).getSbn();\n-\n-        // in the lockdown mode\n-        reset(r);\n-        reset(rs);\n-        when(mNm.isInLockDownMode()).thenReturn(true);\n-        when(r.getSbn()).thenReturn(sbn);\n-        mListeners.notifyRemovedLocked(r, 0, rs);\n-        mListeners.notifyRemovedLocked(r, 0, rs);\n-        verify(r, never()).getSbn();\n+        // Neither user0 and user1 is in the lockdown mode\n+        when(r0.getUser()).thenReturn(uh0);\n+        when(uh0.getIdentifier()).thenReturn(0);\n+        when(mNm.isInLockDownMode(0)).thenReturn(false);\n+        when(r0.getSbn()).thenReturn(sbn);\n+\n+        when(r1.getUser()).thenReturn(uh1);\n+        when(uh1.getIdentifier()).thenReturn(1);\n+        when(mNm.isInLockDownMode(1)).thenReturn(false);\n+        when(r1.getSbn()).thenReturn(sbn);\n+\n+        mListeners.notifyRemovedLocked(r0, 0, rs0);\n+        mListeners.notifyRemovedLocked(r0, 0, rs0);\n+        verify(r0, atLeast(2)).getSbn();\n+\n+        mListeners.notifyRemovedLocked(r1, 0, rs1);\n+        mListeners.notifyRemovedLocked(r1, 0, rs1);\n+        verify(r1, atLeast(2)).getSbn();\n+\n+        // Reset\n+        reset(r0);\n+        reset(rs0);\n+        reset(r1);\n+        reset(rs1);\n+\n+        // Only user 0 is in the lockdown mode\n+        when(r0.getUser()).thenReturn(uh0);\n+        when(uh0.getIdentifier()).thenReturn(0);\n+        when(mNm.isInLockDownMode(0)).thenReturn(true);\n+        when(r0.getSbn()).thenReturn(sbn);\n+\n+        when(r1.getUser()).thenReturn(uh1);\n+        when(uh1.getIdentifier()).thenReturn(1);\n+        when(mNm.isInLockDownMode(1)).thenReturn(false);\n+        when(r1.getSbn()).thenReturn(sbn);\n+\n+        mListeners.notifyRemovedLocked(r0, 0, rs0);\n+        mListeners.notifyRemovedLocked(r0, 0, rs0);\n+        verify(r0, never()).getSbn();\n+\n+        mListeners.notifyRemovedLocked(r1, 0, rs1);\n+        mListeners.notifyRemovedLocked(r1, 0, rs1);\n+        verify(r1, atLeast(2)).getSbn();\n     }\n }\n",
    "added_lines": 98,
    "deleted_lines": 50,
    "changed_methods": "NotificationListenersTest::testnotifyRankingUpdateLockedInLockdownMode, NotificationListenersTest::testNotifyPostedLockedInLockdownMode, NotificationListenersTest::testNotifyRemovedLockedInLockdownMode"
   },
   {
    "filename": "NotificationManagerServiceTest.java",
    "diff": "@@ -159,6 +159,7 @@ import android.service.notification.Adjustment;\n import android.service.notification.ConversationChannelWrapper;\n import android.service.notification.NotificationListenerFilter;\n import android.service.notification.NotificationListenerService;\n+import android.service.notification.NotificationRankingUpdate;\n import android.service.notification.NotificationStats;\n import android.service.notification.StatusBarNotification;\n import android.service.notification.ZenPolicy;\n@@ -194,6 +195,7 @@ import com.android.server.SystemService.TargetUser;\n import com.android.server.UiServiceTestCase;\n import com.android.server.lights.LightsManager;\n import com.android.server.lights.LogicalLight;\n+import com.android.server.notification.ManagedServices.ManagedServiceInfo;\n import com.android.server.notification.NotificationManagerService.NotificationAssistants;\n import com.android.server.notification.NotificationManagerService.NotificationListeners;\n import com.android.server.pm.PackageManagerService;\n@@ -345,6 +347,9 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n         @Nullable\n         NotificationAssistantAccessGrantedCallback mNotificationAssistantAccessGrantedCallback;\n \n+        @Nullable\n+        Boolean mIsVisibleToListenerReturnValue = null;\n+\n         TestableNotificationManagerService(Context context, NotificationRecordLogger logger,\n                 InstanceIdSequence notificationInstanceIdSequence) {\n             super(context, logger, notificationInstanceIdSequence);\n@@ -419,6 +424,19 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n             void onGranted(ComponentName assistant, int userId, boolean granted, boolean userSet);\n         }\n \n+        protected void setIsVisibleToListenerReturnValue(boolean value) {\n+            mIsVisibleToListenerReturnValue = value;\n+        }\n+\n+        @Override\n+        boolean isVisibleToListener(StatusBarNotification sbn, int notificationType,\n+                ManagedServiceInfo listener) {\n+            if (mIsVisibleToListenerReturnValue != null) {\n+                return mIsVisibleToListenerReturnValue;\n+            }\n+            return super.isVisibleToListener(sbn, notificationType, listener);\n+        }\n+\n         class StrongAuthTrackerFake extends NotificationManagerService.StrongAuthTracker {\n             private int mGetStrongAuthForUserReturnValue = 0;\n             StrongAuthTrackerFake(Context context) {\n@@ -8514,10 +8532,10 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n         mStrongAuthTracker.setGetStrongAuthForUserReturnValue(\n                 STRONG_AUTH_REQUIRED_AFTER_USER_LOCKDOWN);\n         mStrongAuthTracker.onStrongAuthRequiredChanged(mContext.getUserId());\n-        assertTrue(mStrongAuthTracker.isInLockDownMode());\n-        mStrongAuthTracker.setGetStrongAuthForUserReturnValue(0);\n+        assertTrue(mStrongAuthTracker.isInLockDownMode(mContext.getUserId()));\n+        mStrongAuthTracker.setGetStrongAuthForUserReturnValue(mContext.getUserId());\n         mStrongAuthTracker.onStrongAuthRequiredChanged(mContext.getUserId());\n-        assertFalse(mStrongAuthTracker.isInLockDownMode());\n+        assertFalse(mStrongAuthTracker.isInLockDownMode(mContext.getUserId()));\n     }\n \n     @Test\n@@ -8533,8 +8551,8 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n         // when entering the lockdown mode, cancel the 2 notifications.\n         mStrongAuthTracker.setGetStrongAuthForUserReturnValue(\n                 STRONG_AUTH_REQUIRED_AFTER_USER_LOCKDOWN);\n-        mStrongAuthTracker.onStrongAuthRequiredChanged(mContext.getUserId());\n-        assertTrue(mStrongAuthTracker.isInLockDownMode());\n+        mStrongAuthTracker.onStrongAuthRequiredChanged(0);\n+        assertTrue(mStrongAuthTracker.isInLockDownMode(0));\n \n         // the notifyRemovedLocked function is called twice due to REASON_LOCKDOWN.\n         ArgumentCaptor<Integer> captor = ArgumentCaptor.forClass(Integer.class);\n@@ -8543,9 +8561,45 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n \n         // exit lockdown mode.\n         mStrongAuthTracker.setGetStrongAuthForUserReturnValue(0);\n-        mStrongAuthTracker.onStrongAuthRequiredChanged(mContext.getUserId());\n+        mStrongAuthTracker.onStrongAuthRequiredChanged(0);\n+        assertFalse(mStrongAuthTracker.isInLockDownMode(0));\n \n         // the notifyPostedLocked function is called twice.\n-        verify(mListeners, times(2)).notifyPostedLocked(any(), any());\n+        verify(mWorkerHandler, times(2)).postDelayed(any(Runnable.class), anyLong());\n+        //verify(mListeners, times(2)).notifyPostedLocked(any(), any());\n+    }\n+\n+    @Test\n+    public void testMakeRankingUpdateLockedInLockDownMode() {\n+        // post 2 notifications from a same package\n+        NotificationRecord pkgA = new NotificationRecord(mContext,\n+                generateSbn(\"a\", 1000, 9, 0), mTestNotificationChannel);\n+        mService.addNotification(pkgA);\n+        NotificationRecord pkgB = new NotificationRecord(mContext,\n+                generateSbn(\"a\", 1000, 9, 1), mTestNotificationChannel);\n+        mService.addNotification(pkgB);\n+\n+        mService.setIsVisibleToListenerReturnValue(true);\n+        NotificationRankingUpdate nru = mService.makeRankingUpdateLocked(null);\n+        assertEquals(2, nru.getRankingMap().getOrderedKeys().length);\n+\n+        // when only user 0 entering the lockdown mode, its notification will be suppressed.\n+        mStrongAuthTracker.setGetStrongAuthForUserReturnValue(\n+                STRONG_AUTH_REQUIRED_AFTER_USER_LOCKDOWN);\n+        mStrongAuthTracker.onStrongAuthRequiredChanged(0);\n+        assertTrue(mStrongAuthTracker.isInLockDownMode(0));\n+        assertFalse(mStrongAuthTracker.isInLockDownMode(1));\n+\n+        nru = mService.makeRankingUpdateLocked(null);\n+        assertEquals(1, nru.getRankingMap().getOrderedKeys().length);\n+\n+        // User 0 exits lockdown mode. Its notification will be resumed.\n+        mStrongAuthTracker.setGetStrongAuthForUserReturnValue(0);\n+        mStrongAuthTracker.onStrongAuthRequiredChanged(0);\n+        assertFalse(mStrongAuthTracker.isInLockDownMode(0));\n+        assertFalse(mStrongAuthTracker.isInLockDownMode(1));\n+\n+        nru = mService.makeRankingUpdateLocked(null);\n+        assertEquals(2, nru.getRankingMap().getOrderedKeys().length);\n     }\n }\n",
    "added_lines": 61,
    "deleted_lines": 7,
    "changed_methods": "NotificationManagerServiceTest::TestableNotificationManagerService::setIsVisibleToListenerReturnValue, NotificationManagerServiceTest::testMakeRankingUpdateLockedInLockDownMode, NotificationManagerServiceTest::testCancelAndPostNotificationsWhenEnterAndExitLockDownMode, NotificationManagerServiceTest::TestableNotificationManagerService::isVisibleToListener, NotificationManagerServiceTest::testStrongAuthTracker_isInLockDownMode"
   }
  ]
 },
 {
  "hash": "66940e260478b665f3c008dfd53d3b44cd164b89",
  "commit": "Reconcile WorkSource parcel and unparcel code.\n\nPrior to this CL, WorkSources would Parcel their list of WorkChains as\n-1 if null, or the size of the list followed by the list itself if\nnon-null. When reading it back in, on the other hand, they would check\nif the size was positive, and only then read the list from the Parcel.\nThis works for all cases except when the WorkSource has an empty but\nnon-null list of WorkChains as the list would get written to the parcel,\nbut then never read on the other side.\n\nIf parceling a list was a no-op when empty this wouldn't be an issue,\nbut it must write at least its size into the parcel to know how many\nelements to extract. In the empty list case, this single element is left\nunread as the size is not positive which essentially corrupts any future\nitems read from that same parcelable.\n\nBug: 220302519\nTest: atest android.security.cts.WorkSourceTest#testWorkChainParceling\nChange-Id: I2fec40dfced420ca38e717059b0e95ee8ef9946a\n(cherry picked from commit 266b3bddcf14d448c0972db64b42950f76c759e3)\nMerged-In: I2fec40dfced420ca38e717059b0e95ee8ef9946a",
  "files": [
   {
    "filename": "WorkSource.java",
    "diff": "@@ -128,7 +128,7 @@ public class WorkSource implements Parcelable {\n         mNames = in.createStringArray();\n \n         int numChains = in.readInt();\n-        if (numChains > 0) {\n+        if (numChains >= 0) {\n             mChains = new ArrayList<>(numChains);\n             in.readParcelableList(mChains, WorkChain.class.getClassLoader());\n         } else {\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "WorkSource::WorkSource"
   }
  ]
 },
 {
  "hash": "6c86f15ca01aa3b4c0150d6a905dcf82dfc37593",
  "commit": "Enforce MediaButtonReceiver extracted component name matches session package name\n\nThis change makes sure that the extracted component name in a\nMediaButtonReceiverHolder matches the Media Session owner's package\nname. This avoids incorrectly routing media button events and potential\nsecurity issues.\n\nBug: 244312001\nBug: 238177121\nTest: atest CtsMediaBetterTogetherTestCases\nChange-Id: Ifac9cf53889222e31d18c14c1e096ee68c0a346c\n(cherry picked from commit 185c3e252397bfa37592edbb5b2f5ae97db92eda)\nMerged-In: Ifac9cf53889222e31d18c14c1e096ee68c0a346c\n(cherry picked from commit 48c388277880e56ab5cc29e145e4d00aa383ce01)\nMerged-In: Ifac9cf53889222e31d18c14c1e096ee68c0a346c",
  "files": [
   {
    "filename": "MediaSession.java",
    "diff": "@@ -286,7 +286,7 @@ public final class MediaSession {\n     @Deprecated\n     public void setMediaButtonReceiver(@Nullable PendingIntent mbr) {\n         try {\n-            mBinder.setMediaButtonReceiver(mbr, mContext.getPackageName());\n+            mBinder.setMediaButtonReceiver(mbr);\n         } catch (RemoteException e) {\n             Log.wtf(TAG, \"Failure in setMediaButtonReceiver.\", e);\n         }\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "MediaSession::setMediaButtonReceiver"
   },
   {
    "filename": "MediaButtonReceiverHolder.java",
    "diff": "@@ -18,6 +18,7 @@ package com.android.server.media;\n \n import android.annotation.IntDef;\n import android.annotation.NonNull;\n+import android.annotation.Nullable;\n import android.app.BroadcastOptions;\n import android.app.PendingIntent;\n import android.content.ComponentName;\n@@ -37,6 +38,7 @@ import android.view.KeyEvent;\n \n import java.lang.annotation.Retention;\n import java.lang.annotation.RetentionPolicy;\n+import java.util.Collections;\n import java.util.List;\n \n /**\n@@ -102,15 +104,19 @@ final class MediaButtonReceiverHolder {\n     }\n \n     /**\n-     * Creates a new instance.\n+     * Creates a new instance from a {@link PendingIntent}.\n+     *\n+     * <p>This method assumes the session package name has been validated and effectively belongs to\n+     * the media session's owner.\n      *\n-     * @param context context\n      * @param userId userId\n-     * @param pendingIntent pending intent\n-     * @return Can be {@code null} if pending intent was null.\n+     * @param pendingIntent pending intent that will receive media button events\n+     * @param sessionPackageName package name of media session owner\n+     * @return {@link MediaButtonReceiverHolder} instance or {@code null} if pending intent was\n+     *     null.\n      */\n-    public static MediaButtonReceiverHolder create(Context context, int userId,\n-            PendingIntent pendingIntent, String sessionPackageName) {\n+    public static MediaButtonReceiverHolder create(\n+            int userId, @Nullable PendingIntent pendingIntent, String sessionPackageName) {\n         if (pendingIntent == null) {\n             return null;\n         }\n@@ -312,7 +318,7 @@ final class MediaButtonReceiverHolder {\n     }\n \n     private static ComponentName getComponentName(PendingIntent pendingIntent, int componentType) {\n-        List<ResolveInfo> resolveInfos = null;\n+        List<ResolveInfo> resolveInfos = Collections.emptyList();\n         switch (componentType) {\n             case COMPONENT_TYPE_ACTIVITY:\n                 resolveInfos = pendingIntent.queryIntentComponents(\n@@ -330,32 +336,37 @@ final class MediaButtonReceiverHolder {\n                         PACKAGE_MANAGER_COMMON_FLAGS | PackageManager.GET_RECEIVERS);\n                 break;\n         }\n-        if (resolveInfos != null && !resolveInfos.isEmpty()) {\n-            return createComponentName(resolveInfos.get(0));\n+\n+        for (ResolveInfo resolveInfo : resolveInfos) {\n+            ComponentInfo componentInfo = getComponentInfo(resolveInfo);\n+            if (componentInfo != null && TextUtils.equals(componentInfo.packageName,\n+                    pendingIntent.getCreatorPackage())\n+                    && componentInfo.packageName != null && componentInfo.name != null) {\n+                return new ComponentName(componentInfo.packageName, componentInfo.name);\n+            }\n         }\n+\n         return null;\n     }\n \n-    private static ComponentName createComponentName(ResolveInfo resolveInfo) {\n-        if (resolveInfo == null) {\n-            return null;\n-        }\n-        ComponentInfo componentInfo;\n+    /**\n+     * Retrieves the {@link ComponentInfo} from a {@link ResolveInfo} instance. Similar to {@link\n+     * ResolveInfo#getComponentInfo()}, but returns {@code null} if this {@link ResolveInfo} points\n+     * to a content provider.\n+     *\n+     * @param resolveInfo Where to extract the {@link ComponentInfo} from.\n+     * @return Either a non-null {@link ResolveInfo#activityInfo} or {@link\n+     *     ResolveInfo#serviceInfo}. Otherwise {@code null} if {@link ResolveInfo#providerInfo} is\n+     *     not {@code null}.\n+     */\n+    private static ComponentInfo getComponentInfo(@NonNull ResolveInfo resolveInfo) {\n         // Code borrowed from ResolveInfo#getComponentInfo().\n         if (resolveInfo.activityInfo != null) {\n-            componentInfo = resolveInfo.activityInfo;\n+            return resolveInfo.activityInfo;\n         } else if (resolveInfo.serviceInfo != null) {\n-            componentInfo = resolveInfo.serviceInfo;\n+            return resolveInfo.serviceInfo;\n         } else {\n-            // We're not interested in content provider.\n-            return null;\n-        }\n-        // Code borrowed from ComponentInfo#getComponentName().\n-        try {\n-            return new ComponentName(componentInfo.packageName, componentInfo.name);\n-        } catch (IllegalArgumentException | NullPointerException e) {\n-            // This may be happen if resolveActivity() end up with matching multiple activities.\n-            // see PackageManager#resolveActivity().\n+            // We're not interested in content providers.\n             return null;\n         }\n     }\n",
    "added_lines": 36,
    "deleted_lines": 25,
    "changed_methods": "MediaButtonReceiverHolder::getComponentInfo, MediaButtonReceiverHolder::createComponentName, MediaButtonReceiverHolder::create, MediaButtonReceiverHolder::getComponentName, MediaButtonReceiverHolder::create"
   },
   {
    "filename": "MediaSessionRecord.java",
    "diff": "@@ -932,8 +932,7 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR\n         }\n \n         @Override\n-        public void setMediaButtonReceiver(PendingIntent pi, String sessionPackageName)\n-                throws RemoteException {\n+        public void setMediaButtonReceiver(PendingIntent pi) throws RemoteException {\n             final long token = Binder.clearCallingIdentity();\n             try {\n                 if ((mPolicies & MediaSessionPolicyProvider.SESSION_POLICY_IGNORE_BUTTON_RECEIVER)\n@@ -941,7 +940,7 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR\n                     return;\n                 }\n                 mMediaButtonReceiverHolder =\n-                        MediaButtonReceiverHolder.create(mContext, mUserId, pi, sessionPackageName);\n+                        MediaButtonReceiverHolder.create(mUserId, pi, mPackageName);\n                 mService.onMediaButtonReceiverChanged(MediaSessionRecord.this);\n             } finally {\n                 Binder.restoreCallingIdentity(token);\n",
    "added_lines": 2,
    "deleted_lines": 3,
    "changed_methods": "MediaSessionRecord::SessionStub::setMediaButtonReceiver, MediaSessionRecord::SessionStub::setMediaButtonReceiver"
   },
   {
    "filename": "MediaSessionService.java",
    "diff": "@@ -2253,9 +2253,9 @@ public class MediaSessionService extends SystemService implements Monitor {\n                     PendingIntent pi = mCustomMediaKeyDispatcher.getMediaButtonReceiver(keyEvent,\n                             uid, asSystemService);\n                     if (pi != null) {\n-                        mediaButtonReceiverHolder = MediaButtonReceiverHolder.create(mContext,\n-                                mCurrentFullUserRecord.mFullUserId, pi,\n-                                /* sessionPackageName= */ \"\");\n+                        mediaButtonReceiverHolder =\n+                                MediaButtonReceiverHolder.create(\n+                                        mCurrentFullUserRecord.mFullUserId, pi, \"\");\n                     }\n                 }\n             }\n",
    "added_lines": 3,
    "deleted_lines": 3,
    "changed_methods": "MediaSessionService::SessionManagerImpl::dispatchMediaKeyEventLocked"
   }
  ]
 },
 {
  "hash": "6c86f15ca01aa3b4c0150d6a905dcf82dfc37593",
  "commit": "Enforce MediaButtonReceiver extracted component name matches session package name\n\nThis change makes sure that the extracted component name in a\nMediaButtonReceiverHolder matches the Media Session owner's package\nname. This avoids incorrectly routing media button events and potential\nsecurity issues.\n\nBug: 244312001\nBug: 238177121\nTest: atest CtsMediaBetterTogetherTestCases\nChange-Id: Ifac9cf53889222e31d18c14c1e096ee68c0a346c\n(cherry picked from commit 185c3e252397bfa37592edbb5b2f5ae97db92eda)\nMerged-In: Ifac9cf53889222e31d18c14c1e096ee68c0a346c\n(cherry picked from commit 48c388277880e56ab5cc29e145e4d00aa383ce01)\nMerged-In: Ifac9cf53889222e31d18c14c1e096ee68c0a346c",
  "files": [
   {
    "filename": "MediaSession.java",
    "diff": "@@ -286,7 +286,7 @@ public final class MediaSession {\n     @Deprecated\n     public void setMediaButtonReceiver(@Nullable PendingIntent mbr) {\n         try {\n-            mBinder.setMediaButtonReceiver(mbr, mContext.getPackageName());\n+            mBinder.setMediaButtonReceiver(mbr);\n         } catch (RemoteException e) {\n             Log.wtf(TAG, \"Failure in setMediaButtonReceiver.\", e);\n         }\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "MediaSession::setMediaButtonReceiver"
   },
   {
    "filename": "MediaButtonReceiverHolder.java",
    "diff": "@@ -18,6 +18,7 @@ package com.android.server.media;\n \n import android.annotation.IntDef;\n import android.annotation.NonNull;\n+import android.annotation.Nullable;\n import android.app.BroadcastOptions;\n import android.app.PendingIntent;\n import android.content.ComponentName;\n@@ -37,6 +38,7 @@ import android.view.KeyEvent;\n \n import java.lang.annotation.Retention;\n import java.lang.annotation.RetentionPolicy;\n+import java.util.Collections;\n import java.util.List;\n \n /**\n@@ -102,15 +104,19 @@ final class MediaButtonReceiverHolder {\n     }\n \n     /**\n-     * Creates a new instance.\n+     * Creates a new instance from a {@link PendingIntent}.\n+     *\n+     * <p>This method assumes the session package name has been validated and effectively belongs to\n+     * the media session's owner.\n      *\n-     * @param context context\n      * @param userId userId\n-     * @param pendingIntent pending intent\n-     * @return Can be {@code null} if pending intent was null.\n+     * @param pendingIntent pending intent that will receive media button events\n+     * @param sessionPackageName package name of media session owner\n+     * @return {@link MediaButtonReceiverHolder} instance or {@code null} if pending intent was\n+     *     null.\n      */\n-    public static MediaButtonReceiverHolder create(Context context, int userId,\n-            PendingIntent pendingIntent, String sessionPackageName) {\n+    public static MediaButtonReceiverHolder create(\n+            int userId, @Nullable PendingIntent pendingIntent, String sessionPackageName) {\n         if (pendingIntent == null) {\n             return null;\n         }\n@@ -312,7 +318,7 @@ final class MediaButtonReceiverHolder {\n     }\n \n     private static ComponentName getComponentName(PendingIntent pendingIntent, int componentType) {\n-        List<ResolveInfo> resolveInfos = null;\n+        List<ResolveInfo> resolveInfos = Collections.emptyList();\n         switch (componentType) {\n             case COMPONENT_TYPE_ACTIVITY:\n                 resolveInfos = pendingIntent.queryIntentComponents(\n@@ -330,32 +336,37 @@ final class MediaButtonReceiverHolder {\n                         PACKAGE_MANAGER_COMMON_FLAGS | PackageManager.GET_RECEIVERS);\n                 break;\n         }\n-        if (resolveInfos != null && !resolveInfos.isEmpty()) {\n-            return createComponentName(resolveInfos.get(0));\n+\n+        for (ResolveInfo resolveInfo : resolveInfos) {\n+            ComponentInfo componentInfo = getComponentInfo(resolveInfo);\n+            if (componentInfo != null && TextUtils.equals(componentInfo.packageName,\n+                    pendingIntent.getCreatorPackage())\n+                    && componentInfo.packageName != null && componentInfo.name != null) {\n+                return new ComponentName(componentInfo.packageName, componentInfo.name);\n+            }\n         }\n+\n         return null;\n     }\n \n-    private static ComponentName createComponentName(ResolveInfo resolveInfo) {\n-        if (resolveInfo == null) {\n-            return null;\n-        }\n-        ComponentInfo componentInfo;\n+    /**\n+     * Retrieves the {@link ComponentInfo} from a {@link ResolveInfo} instance. Similar to {@link\n+     * ResolveInfo#getComponentInfo()}, but returns {@code null} if this {@link ResolveInfo} points\n+     * to a content provider.\n+     *\n+     * @param resolveInfo Where to extract the {@link ComponentInfo} from.\n+     * @return Either a non-null {@link ResolveInfo#activityInfo} or {@link\n+     *     ResolveInfo#serviceInfo}. Otherwise {@code null} if {@link ResolveInfo#providerInfo} is\n+     *     not {@code null}.\n+     */\n+    private static ComponentInfo getComponentInfo(@NonNull ResolveInfo resolveInfo) {\n         // Code borrowed from ResolveInfo#getComponentInfo().\n         if (resolveInfo.activityInfo != null) {\n-            componentInfo = resolveInfo.activityInfo;\n+            return resolveInfo.activityInfo;\n         } else if (resolveInfo.serviceInfo != null) {\n-            componentInfo = resolveInfo.serviceInfo;\n+            return resolveInfo.serviceInfo;\n         } else {\n-            // We're not interested in content provider.\n-            return null;\n-        }\n-        // Code borrowed from ComponentInfo#getComponentName().\n-        try {\n-            return new ComponentName(componentInfo.packageName, componentInfo.name);\n-        } catch (IllegalArgumentException | NullPointerException e) {\n-            // This may be happen if resolveActivity() end up with matching multiple activities.\n-            // see PackageManager#resolveActivity().\n+            // We're not interested in content providers.\n             return null;\n         }\n     }\n",
    "added_lines": 36,
    "deleted_lines": 25,
    "changed_methods": "MediaButtonReceiverHolder::getComponentInfo, MediaButtonReceiverHolder::createComponentName, MediaButtonReceiverHolder::create, MediaButtonReceiverHolder::getComponentName, MediaButtonReceiverHolder::create"
   },
   {
    "filename": "MediaSessionRecord.java",
    "diff": "@@ -932,8 +932,7 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR\n         }\n \n         @Override\n-        public void setMediaButtonReceiver(PendingIntent pi, String sessionPackageName)\n-                throws RemoteException {\n+        public void setMediaButtonReceiver(PendingIntent pi) throws RemoteException {\n             final long token = Binder.clearCallingIdentity();\n             try {\n                 if ((mPolicies & MediaSessionPolicyProvider.SESSION_POLICY_IGNORE_BUTTON_RECEIVER)\n@@ -941,7 +940,7 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR\n                     return;\n                 }\n                 mMediaButtonReceiverHolder =\n-                        MediaButtonReceiverHolder.create(mContext, mUserId, pi, sessionPackageName);\n+                        MediaButtonReceiverHolder.create(mUserId, pi, mPackageName);\n                 mService.onMediaButtonReceiverChanged(MediaSessionRecord.this);\n             } finally {\n                 Binder.restoreCallingIdentity(token);\n",
    "added_lines": 2,
    "deleted_lines": 3,
    "changed_methods": "MediaSessionRecord::SessionStub::setMediaButtonReceiver, MediaSessionRecord::SessionStub::setMediaButtonReceiver"
   },
   {
    "filename": "MediaSessionService.java",
    "diff": "@@ -2253,9 +2253,9 @@ public class MediaSessionService extends SystemService implements Monitor {\n                     PendingIntent pi = mCustomMediaKeyDispatcher.getMediaButtonReceiver(keyEvent,\n                             uid, asSystemService);\n                     if (pi != null) {\n-                        mediaButtonReceiverHolder = MediaButtonReceiverHolder.create(mContext,\n-                                mCurrentFullUserRecord.mFullUserId, pi,\n-                                /* sessionPackageName= */ \"\");\n+                        mediaButtonReceiverHolder =\n+                                MediaButtonReceiverHolder.create(\n+                                        mCurrentFullUserRecord.mFullUserId, pi, \"\");\n                     }\n                 }\n             }\n",
    "added_lines": 3,
    "deleted_lines": 3,
    "changed_methods": "MediaSessionService::SessionManagerImpl::dispatchMediaKeyEventLocked"
   }
  ]
 },
 {
  "hash": "6c86f15ca01aa3b4c0150d6a905dcf82dfc37593",
  "commit": "Enforce MediaButtonReceiver extracted component name matches session package name\n\nThis change makes sure that the extracted component name in a\nMediaButtonReceiverHolder matches the Media Session owner's package\nname. This avoids incorrectly routing media button events and potential\nsecurity issues.\n\nBug: 244312001\nBug: 238177121\nTest: atest CtsMediaBetterTogetherTestCases\nChange-Id: Ifac9cf53889222e31d18c14c1e096ee68c0a346c\n(cherry picked from commit 185c3e252397bfa37592edbb5b2f5ae97db92eda)\nMerged-In: Ifac9cf53889222e31d18c14c1e096ee68c0a346c\n(cherry picked from commit 48c388277880e56ab5cc29e145e4d00aa383ce01)\nMerged-In: Ifac9cf53889222e31d18c14c1e096ee68c0a346c",
  "files": [
   {
    "filename": "MediaSession.java",
    "diff": "@@ -286,7 +286,7 @@ public final class MediaSession {\n     @Deprecated\n     public void setMediaButtonReceiver(@Nullable PendingIntent mbr) {\n         try {\n-            mBinder.setMediaButtonReceiver(mbr, mContext.getPackageName());\n+            mBinder.setMediaButtonReceiver(mbr);\n         } catch (RemoteException e) {\n             Log.wtf(TAG, \"Failure in setMediaButtonReceiver.\", e);\n         }\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "MediaSession::setMediaButtonReceiver"
   },
   {
    "filename": "MediaButtonReceiverHolder.java",
    "diff": "@@ -18,6 +18,7 @@ package com.android.server.media;\n \n import android.annotation.IntDef;\n import android.annotation.NonNull;\n+import android.annotation.Nullable;\n import android.app.BroadcastOptions;\n import android.app.PendingIntent;\n import android.content.ComponentName;\n@@ -37,6 +38,7 @@ import android.view.KeyEvent;\n \n import java.lang.annotation.Retention;\n import java.lang.annotation.RetentionPolicy;\n+import java.util.Collections;\n import java.util.List;\n \n /**\n@@ -102,15 +104,19 @@ final class MediaButtonReceiverHolder {\n     }\n \n     /**\n-     * Creates a new instance.\n+     * Creates a new instance from a {@link PendingIntent}.\n+     *\n+     * <p>This method assumes the session package name has been validated and effectively belongs to\n+     * the media session's owner.\n      *\n-     * @param context context\n      * @param userId userId\n-     * @param pendingIntent pending intent\n-     * @return Can be {@code null} if pending intent was null.\n+     * @param pendingIntent pending intent that will receive media button events\n+     * @param sessionPackageName package name of media session owner\n+     * @return {@link MediaButtonReceiverHolder} instance or {@code null} if pending intent was\n+     *     null.\n      */\n-    public static MediaButtonReceiverHolder create(Context context, int userId,\n-            PendingIntent pendingIntent, String sessionPackageName) {\n+    public static MediaButtonReceiverHolder create(\n+            int userId, @Nullable PendingIntent pendingIntent, String sessionPackageName) {\n         if (pendingIntent == null) {\n             return null;\n         }\n@@ -312,7 +318,7 @@ final class MediaButtonReceiverHolder {\n     }\n \n     private static ComponentName getComponentName(PendingIntent pendingIntent, int componentType) {\n-        List<ResolveInfo> resolveInfos = null;\n+        List<ResolveInfo> resolveInfos = Collections.emptyList();\n         switch (componentType) {\n             case COMPONENT_TYPE_ACTIVITY:\n                 resolveInfos = pendingIntent.queryIntentComponents(\n@@ -330,32 +336,37 @@ final class MediaButtonReceiverHolder {\n                         PACKAGE_MANAGER_COMMON_FLAGS | PackageManager.GET_RECEIVERS);\n                 break;\n         }\n-        if (resolveInfos != null && !resolveInfos.isEmpty()) {\n-            return createComponentName(resolveInfos.get(0));\n+\n+        for (ResolveInfo resolveInfo : resolveInfos) {\n+            ComponentInfo componentInfo = getComponentInfo(resolveInfo);\n+            if (componentInfo != null && TextUtils.equals(componentInfo.packageName,\n+                    pendingIntent.getCreatorPackage())\n+                    && componentInfo.packageName != null && componentInfo.name != null) {\n+                return new ComponentName(componentInfo.packageName, componentInfo.name);\n+            }\n         }\n+\n         return null;\n     }\n \n-    private static ComponentName createComponentName(ResolveInfo resolveInfo) {\n-        if (resolveInfo == null) {\n-            return null;\n-        }\n-        ComponentInfo componentInfo;\n+    /**\n+     * Retrieves the {@link ComponentInfo} from a {@link ResolveInfo} instance. Similar to {@link\n+     * ResolveInfo#getComponentInfo()}, but returns {@code null} if this {@link ResolveInfo} points\n+     * to a content provider.\n+     *\n+     * @param resolveInfo Where to extract the {@link ComponentInfo} from.\n+     * @return Either a non-null {@link ResolveInfo#activityInfo} or {@link\n+     *     ResolveInfo#serviceInfo}. Otherwise {@code null} if {@link ResolveInfo#providerInfo} is\n+     *     not {@code null}.\n+     */\n+    private static ComponentInfo getComponentInfo(@NonNull ResolveInfo resolveInfo) {\n         // Code borrowed from ResolveInfo#getComponentInfo().\n         if (resolveInfo.activityInfo != null) {\n-            componentInfo = resolveInfo.activityInfo;\n+            return resolveInfo.activityInfo;\n         } else if (resolveInfo.serviceInfo != null) {\n-            componentInfo = resolveInfo.serviceInfo;\n+            return resolveInfo.serviceInfo;\n         } else {\n-            // We're not interested in content provider.\n-            return null;\n-        }\n-        // Code borrowed from ComponentInfo#getComponentName().\n-        try {\n-            return new ComponentName(componentInfo.packageName, componentInfo.name);\n-        } catch (IllegalArgumentException | NullPointerException e) {\n-            // This may be happen if resolveActivity() end up with matching multiple activities.\n-            // see PackageManager#resolveActivity().\n+            // We're not interested in content providers.\n             return null;\n         }\n     }\n",
    "added_lines": 36,
    "deleted_lines": 25,
    "changed_methods": "MediaButtonReceiverHolder::getComponentInfo, MediaButtonReceiverHolder::createComponentName, MediaButtonReceiverHolder::create, MediaButtonReceiverHolder::getComponentName, MediaButtonReceiverHolder::create"
   },
   {
    "filename": "MediaSessionRecord.java",
    "diff": "@@ -932,8 +932,7 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR\n         }\n \n         @Override\n-        public void setMediaButtonReceiver(PendingIntent pi, String sessionPackageName)\n-                throws RemoteException {\n+        public void setMediaButtonReceiver(PendingIntent pi) throws RemoteException {\n             final long token = Binder.clearCallingIdentity();\n             try {\n                 if ((mPolicies & MediaSessionPolicyProvider.SESSION_POLICY_IGNORE_BUTTON_RECEIVER)\n@@ -941,7 +940,7 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR\n                     return;\n                 }\n                 mMediaButtonReceiverHolder =\n-                        MediaButtonReceiverHolder.create(mContext, mUserId, pi, sessionPackageName);\n+                        MediaButtonReceiverHolder.create(mUserId, pi, mPackageName);\n                 mService.onMediaButtonReceiverChanged(MediaSessionRecord.this);\n             } finally {\n                 Binder.restoreCallingIdentity(token);\n",
    "added_lines": 2,
    "deleted_lines": 3,
    "changed_methods": "MediaSessionRecord::SessionStub::setMediaButtonReceiver, MediaSessionRecord::SessionStub::setMediaButtonReceiver"
   },
   {
    "filename": "MediaSessionService.java",
    "diff": "@@ -2253,9 +2253,9 @@ public class MediaSessionService extends SystemService implements Monitor {\n                     PendingIntent pi = mCustomMediaKeyDispatcher.getMediaButtonReceiver(keyEvent,\n                             uid, asSystemService);\n                     if (pi != null) {\n-                        mediaButtonReceiverHolder = MediaButtonReceiverHolder.create(mContext,\n-                                mCurrentFullUserRecord.mFullUserId, pi,\n-                                /* sessionPackageName= */ \"\");\n+                        mediaButtonReceiverHolder =\n+                                MediaButtonReceiverHolder.create(\n+                                        mCurrentFullUserRecord.mFullUserId, pi, \"\");\n                     }\n                 }\n             }\n",
    "added_lines": 3,
    "deleted_lines": 3,
    "changed_methods": "MediaSessionService::SessionManagerImpl::dispatchMediaKeyEventLocked"
   }
  ]
 },
 {
  "hash": "6c86f15ca01aa3b4c0150d6a905dcf82dfc37593",
  "commit": "Enforce MediaButtonReceiver extracted component name matches session package name\n\nThis change makes sure that the extracted component name in a\nMediaButtonReceiverHolder matches the Media Session owner's package\nname. This avoids incorrectly routing media button events and potential\nsecurity issues.\n\nBug: 244312001\nBug: 238177121\nTest: atest CtsMediaBetterTogetherTestCases\nChange-Id: Ifac9cf53889222e31d18c14c1e096ee68c0a346c\n(cherry picked from commit 185c3e252397bfa37592edbb5b2f5ae97db92eda)\nMerged-In: Ifac9cf53889222e31d18c14c1e096ee68c0a346c\n(cherry picked from commit 48c388277880e56ab5cc29e145e4d00aa383ce01)\nMerged-In: Ifac9cf53889222e31d18c14c1e096ee68c0a346c",
  "files": [
   {
    "filename": "MediaSession.java",
    "diff": "@@ -286,7 +286,7 @@ public final class MediaSession {\n     @Deprecated\n     public void setMediaButtonReceiver(@Nullable PendingIntent mbr) {\n         try {\n-            mBinder.setMediaButtonReceiver(mbr, mContext.getPackageName());\n+            mBinder.setMediaButtonReceiver(mbr);\n         } catch (RemoteException e) {\n             Log.wtf(TAG, \"Failure in setMediaButtonReceiver.\", e);\n         }\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "MediaSession::setMediaButtonReceiver"
   },
   {
    "filename": "MediaButtonReceiverHolder.java",
    "diff": "@@ -18,6 +18,7 @@ package com.android.server.media;\n \n import android.annotation.IntDef;\n import android.annotation.NonNull;\n+import android.annotation.Nullable;\n import android.app.BroadcastOptions;\n import android.app.PendingIntent;\n import android.content.ComponentName;\n@@ -37,6 +38,7 @@ import android.view.KeyEvent;\n \n import java.lang.annotation.Retention;\n import java.lang.annotation.RetentionPolicy;\n+import java.util.Collections;\n import java.util.List;\n \n /**\n@@ -102,15 +104,19 @@ final class MediaButtonReceiverHolder {\n     }\n \n     /**\n-     * Creates a new instance.\n+     * Creates a new instance from a {@link PendingIntent}.\n+     *\n+     * <p>This method assumes the session package name has been validated and effectively belongs to\n+     * the media session's owner.\n      *\n-     * @param context context\n      * @param userId userId\n-     * @param pendingIntent pending intent\n-     * @return Can be {@code null} if pending intent was null.\n+     * @param pendingIntent pending intent that will receive media button events\n+     * @param sessionPackageName package name of media session owner\n+     * @return {@link MediaButtonReceiverHolder} instance or {@code null} if pending intent was\n+     *     null.\n      */\n-    public static MediaButtonReceiverHolder create(Context context, int userId,\n-            PendingIntent pendingIntent, String sessionPackageName) {\n+    public static MediaButtonReceiverHolder create(\n+            int userId, @Nullable PendingIntent pendingIntent, String sessionPackageName) {\n         if (pendingIntent == null) {\n             return null;\n         }\n@@ -312,7 +318,7 @@ final class MediaButtonReceiverHolder {\n     }\n \n     private static ComponentName getComponentName(PendingIntent pendingIntent, int componentType) {\n-        List<ResolveInfo> resolveInfos = null;\n+        List<ResolveInfo> resolveInfos = Collections.emptyList();\n         switch (componentType) {\n             case COMPONENT_TYPE_ACTIVITY:\n                 resolveInfos = pendingIntent.queryIntentComponents(\n@@ -330,32 +336,37 @@ final class MediaButtonReceiverHolder {\n                         PACKAGE_MANAGER_COMMON_FLAGS | PackageManager.GET_RECEIVERS);\n                 break;\n         }\n-        if (resolveInfos != null && !resolveInfos.isEmpty()) {\n-            return createComponentName(resolveInfos.get(0));\n+\n+        for (ResolveInfo resolveInfo : resolveInfos) {\n+            ComponentInfo componentInfo = getComponentInfo(resolveInfo);\n+            if (componentInfo != null && TextUtils.equals(componentInfo.packageName,\n+                    pendingIntent.getCreatorPackage())\n+                    && componentInfo.packageName != null && componentInfo.name != null) {\n+                return new ComponentName(componentInfo.packageName, componentInfo.name);\n+            }\n         }\n+\n         return null;\n     }\n \n-    private static ComponentName createComponentName(ResolveInfo resolveInfo) {\n-        if (resolveInfo == null) {\n-            return null;\n-        }\n-        ComponentInfo componentInfo;\n+    /**\n+     * Retrieves the {@link ComponentInfo} from a {@link ResolveInfo} instance. Similar to {@link\n+     * ResolveInfo#getComponentInfo()}, but returns {@code null} if this {@link ResolveInfo} points\n+     * to a content provider.\n+     *\n+     * @param resolveInfo Where to extract the {@link ComponentInfo} from.\n+     * @return Either a non-null {@link ResolveInfo#activityInfo} or {@link\n+     *     ResolveInfo#serviceInfo}. Otherwise {@code null} if {@link ResolveInfo#providerInfo} is\n+     *     not {@code null}.\n+     */\n+    private static ComponentInfo getComponentInfo(@NonNull ResolveInfo resolveInfo) {\n         // Code borrowed from ResolveInfo#getComponentInfo().\n         if (resolveInfo.activityInfo != null) {\n-            componentInfo = resolveInfo.activityInfo;\n+            return resolveInfo.activityInfo;\n         } else if (resolveInfo.serviceInfo != null) {\n-            componentInfo = resolveInfo.serviceInfo;\n+            return resolveInfo.serviceInfo;\n         } else {\n-            // We're not interested in content provider.\n-            return null;\n-        }\n-        // Code borrowed from ComponentInfo#getComponentName().\n-        try {\n-            return new ComponentName(componentInfo.packageName, componentInfo.name);\n-        } catch (IllegalArgumentException | NullPointerException e) {\n-            // This may be happen if resolveActivity() end up with matching multiple activities.\n-            // see PackageManager#resolveActivity().\n+            // We're not interested in content providers.\n             return null;\n         }\n     }\n",
    "added_lines": 36,
    "deleted_lines": 25,
    "changed_methods": "MediaButtonReceiverHolder::getComponentInfo, MediaButtonReceiverHolder::createComponentName, MediaButtonReceiverHolder::create, MediaButtonReceiverHolder::getComponentName, MediaButtonReceiverHolder::create"
   },
   {
    "filename": "MediaSessionRecord.java",
    "diff": "@@ -932,8 +932,7 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR\n         }\n \n         @Override\n-        public void setMediaButtonReceiver(PendingIntent pi, String sessionPackageName)\n-                throws RemoteException {\n+        public void setMediaButtonReceiver(PendingIntent pi) throws RemoteException {\n             final long token = Binder.clearCallingIdentity();\n             try {\n                 if ((mPolicies & MediaSessionPolicyProvider.SESSION_POLICY_IGNORE_BUTTON_RECEIVER)\n@@ -941,7 +940,7 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR\n                     return;\n                 }\n                 mMediaButtonReceiverHolder =\n-                        MediaButtonReceiverHolder.create(mContext, mUserId, pi, sessionPackageName);\n+                        MediaButtonReceiverHolder.create(mUserId, pi, mPackageName);\n                 mService.onMediaButtonReceiverChanged(MediaSessionRecord.this);\n             } finally {\n                 Binder.restoreCallingIdentity(token);\n",
    "added_lines": 2,
    "deleted_lines": 3,
    "changed_methods": "MediaSessionRecord::SessionStub::setMediaButtonReceiver, MediaSessionRecord::SessionStub::setMediaButtonReceiver"
   },
   {
    "filename": "MediaSessionService.java",
    "diff": "@@ -2253,9 +2253,9 @@ public class MediaSessionService extends SystemService implements Monitor {\n                     PendingIntent pi = mCustomMediaKeyDispatcher.getMediaButtonReceiver(keyEvent,\n                             uid, asSystemService);\n                     if (pi != null) {\n-                        mediaButtonReceiverHolder = MediaButtonReceiverHolder.create(mContext,\n-                                mCurrentFullUserRecord.mFullUserId, pi,\n-                                /* sessionPackageName= */ \"\");\n+                        mediaButtonReceiverHolder =\n+                                MediaButtonReceiverHolder.create(\n+                                        mCurrentFullUserRecord.mFullUserId, pi, \"\");\n                     }\n                 }\n             }\n",
    "added_lines": 3,
    "deleted_lines": 3,
    "changed_methods": "MediaSessionService::SessionManagerImpl::dispatchMediaKeyEventLocked"
   }
  ]
 },
 {
  "hash": "c4ab6858af6c7c0b2d186c3032b1ec2bf0dc4815",
  "commit": "Enforce MediaButtonReceiver ComponentName belongs to app\n\nAdds check that enforces ComponentName's package belongs to calling app.\nThis avoids privileged execution of arbitrary code through media button\nevents.\n\nThis is a partial revert revert of ag/19338169.\n\nBug: 238177121\nTest: atest CtsMediaBetterTogetherTestCases\nChange-Id: I4aba866a9758366175ea4af0d434729ad98fa48d\n(cherry picked from commit 1b2fa2486cc97fd9515300f858d4da2af8d8908c)\nMerged-In: I4aba866a9758366175ea4af0d434729ad98fa48d\n(cherry picked from commit 863d396f4ccabee91d51b04f72f44c34ffe351f0)\n(cherry picked from commit 833af484ecbe732ec086ee08a068c6010cd070c9)\nMerged-In: I4aba866a9758366175ea4af0d434729ad98fa48d",
  "files": [
   {
    "filename": "MediaSessionRecord.java",
    "diff": "@@ -53,6 +53,7 @@ import android.os.RemoteException;\n import android.os.ResultReceiver;\n import android.os.SystemClock;\n import android.text.TextUtils;\n+import android.util.EventLog;\n import android.util.Log;\n import android.view.KeyEvent;\n \n@@ -951,6 +952,14 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR\n         public void setMediaButtonBroadcastReceiver(ComponentName receiver) throws RemoteException {\n             final long token = Binder.clearCallingIdentity();\n             try {\n+                //mPackageName has been verified in MediaSessionService.enforcePackageName().\n+                if (receiver != null && !TextUtils.equals(\n+                        mPackageName, receiver.getPackageName())) {\n+                    EventLog.writeEvent(0x534e4554, \"238177121\", -1, \"\"); // SafetyNet logging.\n+                    throw new IllegalArgumentException(\"receiver does not belong to \"\n+                            + \"package name provided to MediaSessionRecord. Pkg = \" + mPackageName\n+                            + \", Receiver Pkg = \" + receiver.getPackageName());\n+                }\n                 if ((mPolicies & MediaSessionPolicyProvider.SESSION_POLICY_IGNORE_BUTTON_RECEIVER)\n                         != 0) {\n                     return;\n",
    "added_lines": 9,
    "deleted_lines": 0,
    "changed_methods": "MediaSessionRecord::SessionStub::setMediaButtonBroadcastReceiver"
   }
  ]
 },
 {
  "hash": "68ef7c5a725d4f6f4387fde049d7d4ec447f996e",
  "commit": "Revert \"Ensure that only SysUI can override pending intent launch flags\"\n\nThis reverts commit c4d3106e347922610f8c554de3ae238175ed393e.\n\nReason for revert: b/264884187, b/264885689 \n\nChange-Id: I9fb0d66327f3f872a92e6b9d682d58489e81e6ba\n(cherry picked from commit 7bb933f48ff15d8f08d2185005b7b3e212915276)\nMerged-In: I9fb0d66327f3f872a92e6b9d682d58489e81e6ba",
  "files": [
   {
    "filename": "PendingIntentRecord.java",
    "diff": "@@ -350,16 +350,11 @@ public final class PendingIntentRecord extends IIntentSender.Stub {\n                 resolvedType = key.requestResolvedType;\n             }\n \n-            // Apply any launch flags from the ActivityOptions. This is used only by SystemUI\n-            // to ensure that we can launch the pending intent with a consistent launch mode even\n-            // if the provided PendingIntent is immutable (ie. to force an activity to launch into\n-            // a new task, or to launch multiple instances if supported by the app)\n+            // Apply any launch flags from the ActivityOptions. This is to ensure that the caller\n+            // can specify a consistent launch mode even if the PendingIntent is immutable\n             final ActivityOptions opts = ActivityOptions.fromBundle(options);\n             if (opts != null) {\n-                // TODO(b/254490217): Move this check into SafeActivityOptions\n-                if (controller.mAtmInternal.isCallerRecents(Binder.getCallingUid())) {\n-                    finalIntent.addFlags(opts.getPendingIntentLaunchFlags());\n-                }\n+                finalIntent.addFlags(opts.getPendingIntentLaunchFlags());\n             }\n \n             // Extract options before clearing calling identity\n",
    "added_lines": 3,
    "deleted_lines": 8,
    "changed_methods": "PendingIntentRecord::sendInner"
   }
  ]
 },
 {
  "hash": "da40a046caf74dfb789bb5cdd3b7d2847f9c956a",
  "commit": "Skip permission check for system ui.\n\nThis is a workaround for a race condition between system ui and role\nservice's role based grants on boot.\n\nThe config value used is the same that the role service uses to give\nsystem ui its role.\n\nTest: Verify check is bypassed\nBug: 221782106\nChange-Id: Ia44abeefbec1b27df6bf802d7493c03381518e96",
  "files": [
   {
    "filename": "SensorPrivacyService.java",
    "diff": "@@ -29,6 +29,7 @@ import static android.app.AppOpsManager.OP_RECORD_AUDIO;\n import static android.content.Intent.EXTRA_PACKAGE_NAME;\n import static android.content.Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS;\n import static android.content.Intent.FLAG_ACTIVITY_NO_USER_ACTION;\n+import static android.content.pm.PackageManager.MATCH_SYSTEM_ONLY;\n import static android.content.pm.PackageManager.PERMISSION_GRANTED;\n import static android.hardware.SensorPrivacyManager.EXTRA_ALL_SENSORS;\n import static android.hardware.SensorPrivacyManager.EXTRA_SENSOR;\n@@ -75,6 +76,7 @@ import android.content.Context;\n import android.content.Intent;\n import android.content.IntentFilter;\n import android.content.pm.PackageManager;\n+import android.content.pm.PackageManagerInternal;\n import android.content.res.Configuration;\n import android.graphics.drawable.Icon;\n import android.hardware.ISensorPrivacyListener;\n@@ -188,6 +190,7 @@ public final class SensorPrivacyService extends SystemService {\n     private final AppOpsManager mAppOpsManager;\n     private final AppOpsManagerInternal mAppOpsManagerInternal;\n     private final TelephonyManager mTelephonyManager;\n+    private final PackageManagerInternal mPackageManagerInternal;\n \n     private final IBinder mAppOpsRestrictionToken = new Binder();\n \n@@ -208,6 +211,7 @@ public final class SensorPrivacyService extends SystemService {\n         mActivityManagerInternal = getLocalService(ActivityManagerInternal.class);\n         mActivityTaskManager = context.getSystemService(ActivityTaskManager.class);\n         mTelephonyManager = context.getSystemService(TelephonyManager.class);\n+        mPackageManagerInternal = getLocalService(PackageManagerInternal.class);\n         mSensorPrivacyServiceImpl = new SensorPrivacyServiceImpl();\n     }\n \n@@ -877,6 +881,12 @@ public final class SensorPrivacyService extends SystemService {\n          * sensor privacy.\n          */\n         private void enforceObserveSensorPrivacyPermission() {\n+            String systemUIPackage = mContext.getString(R.string.config_systemUi);\n+            if (Binder.getCallingUid() == mPackageManagerInternal\n+                    .getPackageUid(systemUIPackage, MATCH_SYSTEM_ONLY, UserHandle.USER_SYSTEM)) {\n+                // b/221782106, possible race condition with role grant might bootloop device.\n+                return;\n+            }\n             enforcePermission(android.Manifest.permission.OBSERVE_SENSOR_PRIVACY,\n                     \"Observing sensor privacy changes requires the following permission: \"\n                             + android.Manifest.permission.OBSERVE_SENSOR_PRIVACY);\n",
    "added_lines": 10,
    "deleted_lines": 0,
    "changed_methods": "SensorPrivacyService::SensorPrivacyService, SensorPrivacyService::SensorPrivacyServiceImpl::enforceObserveSensorPrivacyPermission"
   }
  ]
 },
 {
  "hash": "1645ad8ce3f70201f3e8315bbc329b1e09ff2b49",
  "commit": "DO NOT MERGE: Context#startInstrumentation could be started from SHELL only now.\n\nOr, if an instrumentation starts another instrumentation and so on,\nand the original instrumentation is started from SHELL, allow all\nContext#startInstrumentation calls in this chain.\n\nOtherwise, it'll throw a SecurityException.\n\nBug: 237766679\nTest: atest CtsAppTestCases:InstrumentationTest\nMerged-In: Ia08f225c21a3933067d066a578ea4af9c23e7d4c\nMerged-In: I1b76f61c5fd6c9f7e738978592260945a606f40c\nMerged-In: I3ea7aa27bd776fec546908a37f667f680da9c892\nChange-Id: I7ca7345b064e8e74f7037b8fa3ed45bb6423e406\n(cherry picked from commit 5985225e777cdb96b738aeda859dff49f6c6f853)\nMerged-In: I7ca7345b064e8e74f7037b8fa3ed45bb6423e406",
  "files": [
   {
    "filename": "ActivityManagerService.java",
    "diff": "@@ -13849,6 +13849,17 @@ public class ActivityManagerService extends IActivityManager.Stub\n                     throw new SecurityException(msg);\n                 }\n             }\n+            if (!Build.IS_DEBUGGABLE && callingUid != ROOT_UID && callingUid != SHELL_UID\n+                    && callingUid != SYSTEM_UID && !hasActiveInstrumentationLocked(callingPid)) {\n+                // If it's not debug build and not called from root/shell/system uid, reject it.\n+                final String msg = \"Permission Denial: instrumentation test \"\n+                        + className + \" from pid=\" + callingPid + \", uid=\" + callingUid\n+                        + \", pkgName=\" + getPackageNameByPid(callingPid)\n+                        + \" not allowed because it's not started from SHELL\";\n+                Slog.wtfQuiet(TAG, msg);\n+                reportStartInstrumentationFailureLocked(watcher, className, msg);\n+                throw new SecurityException(msg);\n+            }\n \n             ActiveInstrumentation activeInstr = new ActiveInstrumentation(this);\n             activeInstr.mClass = className;\n@@ -13947,6 +13958,29 @@ public class ActivityManagerService extends IActivityManager.Stub\n         }\n     }\n \n+    @GuardedBy(\"this\")\n+    private boolean hasActiveInstrumentationLocked(int pid) {\n+        if (pid == 0) {\n+            return false;\n+        }\n+        synchronized (mPidsSelfLocked) {\n+            ProcessRecord process = mPidsSelfLocked.get(pid);\n+            return process != null && process.getActiveInstrumentation() != null;\n+        }\n+    }\n+\n+    private String getPackageNameByPid(int pid) {\n+        synchronized (mPidsSelfLocked) {\n+            final ProcessRecord app = mPidsSelfLocked.get(pid);\n+\n+            if (app != null && app.info != null) {\n+                return app.info.packageName;\n+            }\n+\n+            return null;\n+        }\n+    }\n+\n     private boolean isCallerShell() {\n         final int callingUid = Binder.getCallingUid();\n         return callingUid == SHELL_UID || callingUid == ROOT_UID;\n",
    "added_lines": 34,
    "deleted_lines": 0,
    "changed_methods": "ActivityManagerService::hasActiveInstrumentationLocked, ActivityManagerService::startInstrumentation, ActivityManagerService::getPackageNameByPid"
   }
  ]
 },
 {
  "hash": "2e7af97f081b0985e14d63df2c50f948b6f9075d",
  "commit": "Fix checkKeyIntentParceledCorrectly's bypass\n\nThe checkKeyIntentParceledCorrectly method was added in checkKeyIntent, which was originaly  only invoked when AccountManagerService deserializes the KEY_INTENT value as not NULL. However, due to the self-changing bundle technique in Parcel mismatch problems, the Intent value can change after reparceling; hence would bypass the added checkKeyIntentParceledCorrectly call.\n\nThis CL did the following:\n\n- Ensure the checkKeyIntent method is also called when result.getParcelable(AccountManager.KEY_INTENT) == null.\n\nBug: 260567867\nBug: 262230405\nTest: local test, see b/262230405\nTest: atest CtsAccountManagerTestCases\nMerged-In: I7b528f52c41767ae12731838fdd36aa26a8f3477\nChange-Id: I7b528f52c41767ae12731838fdd36aa26a8f3477\n(cherry picked from commit 9f623983a8d4ec48d58b0eda56fa461fc6748981)\nMerged-In: I7b528f52c41767ae12731838fdd36aa26a8f3477",
  "files": [
   {
    "filename": "AccountManagerService.java",
    "diff": "@@ -3513,8 +3513,7 @@ public class AccountManagerService\n             Bundle.setDefusable(result, true);\n             mNumResults++;\n             Intent intent = null;\n-            if (result != null\n-                    && (intent = result.getParcelable(AccountManager.KEY_INTENT)) != null) {\n+            if (result != null) {\n                 if (!checkKeyIntent(\n                         Binder.getCallingUid(),\n                         result)) {\n@@ -4873,8 +4872,10 @@ public class AccountManagerService\n             \tEventLog.writeEvent(0x534e4554, \"250588548\", authUid, \"\");\n                 return false;\n             }\n-\n             Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT);\n+            if (intent == null) {\n+                return true;\n+            }\n             // Explicitly set an empty ClipData to ensure that we don't offer to\n             // promote any Uris contained inside for granting purposes\n             if (intent.getClipData() == null) {\n@@ -4927,7 +4928,10 @@ public class AccountManagerService\n             p.recycle();\n             Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT);\n             Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT);\n-            return (intent.filterEquals(simulateIntent));\n+            if (intent == null) {\n+                return (simulateIntent == null);\n+            }\n+            return intent.filterEquals(simulateIntent);\n         }\n \n         private boolean isExportedSystemActivity(ActivityInfo activityInfo) {\n@@ -5072,8 +5076,7 @@ public class AccountManagerService\n                     }\n                 }\n             }\n-            if (result != null\n-                    && (intent = result.getParcelable(AccountManager.KEY_INTENT)) != null) {\n+            if (result != null) {\n                 if (!checkKeyIntent(\n                         Binder.getCallingUid(),\n                         result)) {\n",
    "added_lines": 9,
    "deleted_lines": 6,
    "changed_methods": "AccountManagerService::Session::checkKeyIntent, AccountManagerService::Session::checkKeyIntentParceledCorrectly, AccountManagerService::StartAccountSession::onResult, AccountManagerService::Session::onResult"
   }
  ]
 },
 {
  "hash": "54a73e2f6ca472fe66039ab2823fdc2a5ba26cf2",
  "commit": "Checking if package belongs to UID before registering broadcast receiver\n\nTest: manual testing done on device by installing test APK and checking if receiver can register\nBug: 242040055\nChange-Id: Ia525f218a46f8bf7fff660cec0d6432f09fdf24d\nMerged-In: Ia525f218a46f8bf7fff660cec0d6432f09fdf24d\n(cherry picked from commit 790a8d0dd329460bc60456681cb446accf2a27e0)\n(cherry picked from commit 8460609f01147d2a7e849eca1ca895211530b589)\nMerged-In: Ia525f218a46f8bf7fff660cec0d6432f09fdf24d",
  "files": [
   {
    "filename": "ActiveServices.java",
    "diff": "@@ -3201,6 +3201,11 @@ public final class ActiveServices {\n                             throw new SecurityException(\"BIND_EXTERNAL_SERVICE failed, \"\n                                     + className + \" is not an isolatedProcess\");\n                         }\n+                        if (AppGlobals.getPackageManager().getPackageUid(callingPackage,\n+                                0, userId) != callingUid) {\n+                            throw new SecurityException(\"BIND_EXTERNAL_SERVICE failed, \"\n+                                    + \"calling package not owned by calling UID \");\n+                        }\n                         // Run the service under the calling package's application.\n                         ApplicationInfo aInfo = AppGlobals.getPackageManager().getApplicationInfo(\n                                 callingPackage, ActivityManagerService.STOCK_PM_FLAGS, userId);\n",
    "added_lines": 5,
    "deleted_lines": 0,
    "changed_methods": "ActiveServices::retrieveServiceLocked"
   }
  ]
 },
 {
  "hash": "299efd901061ccc2a243df9d9b8059dffa9861ea",
  "commit": "Encode Intent scheme when serializing to URI string RESTRICT AUTOMERGE\n\nAvoids deserialization error when the scheme contains a\nreserved character.\n\nBug: 261858325\n\nTest: atest android.content.cts.IntentTest#testEncoding\n\nMerged-In: Ic34b3f796b762763db5aa7b5d7c109ae70607470\nChange-Id: Ic34b3f796b762763db5aa7b5d7c109ae70607470\n(cherry picked from commit bfe7e8bab48caff53dbcf2913f724de2e4f5aa81)\nMerged-In: Ic34b3f796b762763db5aa7b5d7c109ae70607470",
  "files": [
   {
    "filename": "Intent.java",
    "diff": "@@ -11011,7 +11011,7 @@ public class Intent implements Parcelable, Cloneable {\n     private void toUriInner(StringBuilder uri, String scheme, String defAction,\n             String defPackage, int flags) {\n         if (scheme != null) {\n-            uri.append(\"scheme=\").append(scheme).append(';');\n+            uri.append(\"scheme=\").append(Uri.encode(scheme)).append(';');\n         }\n         if (mAction != null && !mAction.equals(defAction)) {\n             uri.append(\"action=\").append(Uri.encode(mAction)).append(';');\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "Intent::toUriInner"
   }
  ]
 },
 {
  "hash": "af52e36a81099ffc43e898f74f1e8f70ec1de2e3",
  "commit": "[DO NOT MERGE] Backport BAL restrictions from T to S, this blocks apps from using Alarm\nManager to bypass BAL restrictions.\n\nTest: atest-src BackgroundActivityLaunchTest\nBug: 195756028\nChange-Id: I33112ff59d913d8a7244289fe1a43512844e902a\n(cherry picked from commit 7a41e2fbc983ce0083b288e9489288de60dc8d8b)\nMerged-In: I33112ff59d913d8a7244289fe1a43512844e902a",
  "files": [
   {
    "filename": "AlarmManagerService.java",
    "diff": "@@ -56,6 +56,7 @@ import android.annotation.NonNull;\n import android.annotation.UserIdInt;\n import android.app.Activity;\n import android.app.ActivityManagerInternal;\n+import android.app.ActivityOptions;\n import android.app.AlarmManager;\n import android.app.AppOpsManager;\n import android.app.BroadcastOptions;\n@@ -317,6 +318,8 @@ public class AlarmManagerService extends SystemService {\n     private final SparseBooleanArray mPendingSendNextAlarmClockChangedForUser =\n             new SparseBooleanArray();\n     private boolean mNextAlarmClockMayChange;\n+    ActivityOptions mActivityOptsRestrictBal = ActivityOptions.makeBasic();\n+    BroadcastOptions mBroadcastOptsRestrictBal = BroadcastOptions.makeBasic();\n \n     @GuardedBy(\"mLock\")\n     private final Runnable mAlarmClockUpdater = () -> mNextAlarmClockMayChange = true;\n@@ -1611,6 +1614,11 @@ public class AlarmManagerService extends SystemService {\n     @Override\n     public void onStart() {\n         mInjector.init();\n+        mOptsWithFgs.setPendingIntentBackgroundActivityLaunchAllowed(false);\n+        mOptsWithoutFgs.setPendingIntentBackgroundActivityLaunchAllowed(false);\n+        mOptsTimeBroadcast.setPendingIntentBackgroundActivityLaunchAllowed(false);\n+        mActivityOptsRestrictBal.setPendingIntentBackgroundActivityLaunchAllowed(false);\n+        mBroadcastOptsRestrictBal.setPendingIntentBackgroundActivityLaunchAllowed(false);\n         mMetricsHelper = new MetricsHelper(getContext(), mLock);\n \n         mListenerDeathRecipient = new IBinder.DeathRecipient() {\n@@ -4306,6 +4314,14 @@ public class AlarmManagerService extends SystemService {\n         return alarm.creatorUid;\n     }\n \n+    private Bundle getAlarmOperationBundle(Alarm alarm) {\n+        if (alarm.mIdleOptions != null) {\n+            return alarm.mIdleOptions;\n+        } else if (alarm.operation.isActivity()) {\n+            return mActivityOptsRestrictBal.toBundle();\n+        }\n+        return mBroadcastOptsRestrictBal.toBundle();\n+    }\n \n     @VisibleForTesting\n     class AlarmHandler extends Handler {\n@@ -4344,7 +4360,11 @@ public class AlarmManagerService extends SystemService {\n                     for (int i = 0; i < triggerList.size(); i++) {\n                         Alarm alarm = triggerList.get(i);\n                         try {\n-                            alarm.operation.send();\n+                            // Disallow AlarmManager to start random background activity.\n+                            final Bundle bundle = getAlarmOperationBundle(alarm);\n+                            alarm.operation.send(/* context */ null, /* code */0, /* intent */\n+                                    null, /* onFinished */null, /* handler */\n+                                    null, /* requiredPermission */ null, bundle);\n                         } catch (PendingIntent.CanceledException e) {\n                             if (alarm.repeatInterval > 0) {\n                                 // This IntentSender is no longer valid, but this\n@@ -4908,9 +4928,10 @@ public class AlarmManagerService extends SystemService {\n                     mSendCount++;\n \n                     try {\n+                        final Bundle bundle = getAlarmOperationBundle(alarm);\n                         alarm.operation.send(getContext(), 0,\n                                 mBackgroundIntent.putExtra(Intent.EXTRA_ALARM_COUNT, alarm.count),\n-                                mDeliveryTracker, mHandler, null, alarm.mIdleOptions);\n+                                mDeliveryTracker, mHandler, null, bundle);\n                     } catch (PendingIntent.CanceledException e) {\n                         if (alarm.repeatInterval > 0) {\n                             // This IntentSender is no longer valid, but this\n",
    "added_lines": 23,
    "deleted_lines": 2,
    "changed_methods": "AlarmManagerService::getAlarmOperationBundle, AlarmManagerService::DeliveryTracker::deliverLocked, AlarmManagerService::onStart, AlarmManagerService::AlarmHandler::handleMessage"
   },
   {
    "filename": "ActivityOptions.java",
    "diff": "@@ -69,7 +69,7 @@ import java.util.ArrayList;\n  * {@link android.content.Context#startActivity(android.content.Intent, android.os.Bundle)\n  * Context.startActivity(Intent, Bundle)} and related methods.\n  */\n-public class ActivityOptions {\n+public class ActivityOptions extends ComponentOptions {\n     private static final String TAG = \"ActivityOptions\";\n \n     /**\n@@ -1081,13 +1081,12 @@ public class ActivityOptions {\n     }\n \n     private ActivityOptions() {\n+        super();\n     }\n \n     /** @hide */\n     public ActivityOptions(Bundle opts) {\n-        // If the remote side sent us bad parcelables, they won't get the\n-        // results they want, which is their loss.\n-        opts.setDefusable(true);\n+        super(opts);\n \n         mPackageName = opts.getString(KEY_PACKAGE_NAME);\n         try {\n@@ -1832,8 +1831,9 @@ public class ActivityOptions {\n      * object; you must not modify it, but can supply it to the startActivity\n      * methods that take an options Bundle.\n      */\n+    @Override\n     public Bundle toBundle() {\n-        Bundle b = new Bundle();\n+        Bundle b = super.toBundle();\n         if (mPackageName != null) {\n             b.putString(KEY_PACKAGE_NAME, mPackageName);\n         }\n",
    "added_lines": 5,
    "deleted_lines": 5,
    "changed_methods": "ActivityOptions::ActivityOptions, ActivityOptions::ActivityOptions, ActivityOptions::toBundle"
   },
   {
    "filename": "BroadcastOptions.java",
    "diff": "@@ -34,7 +34,7 @@ import android.os.PowerExemptionManager.TempAllowListType;\n  * {@hide}\n  */\n @SystemApi\n-public class BroadcastOptions {\n+public class BroadcastOptions extends ComponentOptions {\n     private long mTemporaryAppAllowlistDuration;\n     private @TempAllowListType int mTemporaryAppAllowlistType;\n     private @ReasonCode int mTemporaryAppAllowlistReasonCode;\n@@ -108,12 +108,14 @@ public class BroadcastOptions {\n     }\n \n     private BroadcastOptions() {\n+        super();\n         resetTemporaryAppAllowlist();\n     }\n \n     /** @hide */\n     @TestApi\n     public BroadcastOptions(@NonNull Bundle opts) {\n+        super(opts);\n         // Match the logic in toBundle().\n         if (opts.containsKey(KEY_TEMPORARY_APP_ALLOWLIST_DURATION)) {\n             mTemporaryAppAllowlistDuration = opts.getLong(KEY_TEMPORARY_APP_ALLOWLIST_DURATION);\n@@ -190,6 +192,24 @@ public class BroadcastOptions {\n         mTemporaryAppAllowlistReason = null;\n     }\n \n+    /**\n+     * Set PendingIntent activity is allowed to be started in the background if the caller\n+     * can start background activities.\n+     * @hide\n+     */\n+    public void setPendingIntentBackgroundActivityLaunchAllowed(boolean allowed) {\n+        super.setPendingIntentBackgroundActivityLaunchAllowed(allowed);\n+    }\n+\n+    /**\n+     * Get PendingIntent activity is allowed to be started in the background if the caller\n+     * can start background activities.\n+     * @hide\n+     */\n+    public boolean isPendingIntentBackgroundActivityLaunchAllowed() {\n+        return super.isPendingIntentBackgroundActivityLaunchAllowed();\n+    }\n+\n     /**\n      * Return {@link #setTemporaryAppAllowlist}.\n      * @hide\n@@ -308,8 +328,9 @@ public class BroadcastOptions {\n      * object; you must not modify it, but can supply it to the sendBroadcast\n      * methods that take an options Bundle.\n      */\n+    @Override\n     public Bundle toBundle() {\n-        Bundle b = new Bundle();\n+        Bundle b = super.toBundle();\n         if (isTemporaryAppAllowlistSet()) {\n             b.putLong(KEY_TEMPORARY_APP_ALLOWLIST_DURATION, mTemporaryAppAllowlistDuration);\n             b.putInt(KEY_TEMPORARY_APP_ALLOWLIST_TYPE, mTemporaryAppAllowlistType);\n",
    "added_lines": 23,
    "deleted_lines": 2,
    "changed_methods": "BroadcastOptions::toBundle, BroadcastOptions::BroadcastOptions, BroadcastOptions::setPendingIntentBackgroundActivityLaunchAllowed, BroadcastOptions::isPendingIntentBackgroundActivityLaunchAllowed, BroadcastOptions::BroadcastOptions"
   },
   {
    "filename": "ComponentOptions.java",
    "diff": "@@ -0,0 +1,83 @@\n+/*\n+ * Copyright (C) 2021 The Android Open Source Project\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package android.app;\n+\n+import android.os.Bundle;\n+\n+/**\n+ * @hide\n+ */\n+public class ComponentOptions {\n+\n+    /**\n+     * Default value for KEY_PENDING_INTENT_BACKGROUND_ACTIVITY_ALLOWED.\n+     * @hide\n+     **/\n+    public static final boolean PENDING_INTENT_BAL_ALLOWED_DEFAULT = true;\n+\n+    /**\n+     * PendingIntent caller allows activity start even if PendingIntent creator is in background.\n+     * This only works if the PendingIntent caller is allowed to start background activities,\n+     * for example if it's in the foreground, or has BAL permission.\n+     * @hide\n+     */\n+    public static final String KEY_PENDING_INTENT_BACKGROUND_ACTIVITY_ALLOWED =\n+            \"android.pendingIntent.backgroundActivityAllowed\";\n+\n+    private boolean mPendingIntentBalAllowed = PENDING_INTENT_BAL_ALLOWED_DEFAULT;\n+\n+    ComponentOptions() {\n+    }\n+\n+    ComponentOptions(Bundle opts) {\n+        // If the remote side sent us bad parcelables, they won't get the\n+        // results they want, which is their loss.\n+        opts.setDefusable(true);\n+        setPendingIntentBackgroundActivityLaunchAllowed(\n+                opts.getBoolean(KEY_PENDING_INTENT_BACKGROUND_ACTIVITY_ALLOWED,\n+                        PENDING_INTENT_BAL_ALLOWED_DEFAULT));\n+    }\n+\n+    /**\n+     * Set PendingIntent activity is allowed to be started in the background if the caller\n+     * can start background activities.\n+     *\n+     * @hide\n+     */\n+    public void setPendingIntentBackgroundActivityLaunchAllowed(boolean allowed) {\n+        mPendingIntentBalAllowed = allowed;\n+    }\n+\n+    /**\n+     * Get PendingIntent activity is allowed to be started in the background if the caller\n+     * can start background activities.\n+     *\n+     * @hide\n+     */\n+    public boolean isPendingIntentBackgroundActivityLaunchAllowed() {\n+        return mPendingIntentBalAllowed;\n+    }\n+\n+    /**\n+     * @hide\n+     */\n+    public Bundle toBundle() {\n+        Bundle bundle = new Bundle();\n+        bundle.putBoolean(KEY_PENDING_INTENT_BACKGROUND_ACTIVITY_ALLOWED, mPendingIntentBalAllowed);\n+        return bundle;\n+    }\n+}\n",
    "added_lines": 83,
    "deleted_lines": 0,
    "changed_methods": "ComponentOptions::toBundle, ComponentOptions::ComponentOptions, ComponentOptions::ComponentOptions, ComponentOptions::isPendingIntentBackgroundActivityLaunchAllowed, ComponentOptions::setPendingIntentBackgroundActivityLaunchAllowed"
   },
   {
    "filename": "PendingIntentRecord.java",
    "diff": "@@ -310,6 +310,25 @@ public final class PendingIntentRecord extends IIntentSender.Stub {\n                 requiredPermission, null, null, 0, 0, 0, options);\n     }\n \n+    /**\n+     * Return true if the activity options allows PendingIntent to use caller's BAL permission.\n+     */\n+    public static boolean isPendingIntentBalAllowedByCaller(\n+            @Nullable ActivityOptions activityOptions) {\n+        if (activityOptions == null) {\n+            return ActivityOptions.PENDING_INTENT_BAL_ALLOWED_DEFAULT;\n+        }\n+        return isPendingIntentBalAllowedByCaller(activityOptions.toBundle());\n+    }\n+\n+    private static boolean isPendingIntentBalAllowedByCaller(@Nullable Bundle options) {\n+        if (options == null) {\n+            return ActivityOptions.PENDING_INTENT_BAL_ALLOWED_DEFAULT;\n+        }\n+        return options.getBoolean(ActivityOptions.KEY_PENDING_INTENT_BACKGROUND_ACTIVITY_ALLOWED,\n+                ActivityOptions.PENDING_INTENT_BAL_ALLOWED_DEFAULT);\n+    }\n+\n     public int sendInner(int code, Intent intent, String resolvedType, IBinder allowlistToken,\n             IIntentReceiver finishedReceiver, String requiredPermission, IBinder resultTo,\n             String resultWho, int requestCode, int flagsMask, int flagsValues, Bundle options) {\n@@ -431,7 +450,8 @@ public final class PendingIntentRecord extends IIntentSender.Stub {\n             // temporarily allow receivers and services to open activities from background if the\n             // PendingIntent.send() caller was foreground at the time of sendInner() call\n             final boolean allowTrampoline = uid != callingUid\n-                    && controller.mAtmInternal.isUidForeground(callingUid);\n+                    && controller.mAtmInternal.isUidForeground(callingUid)\n+                    && isPendingIntentBalAllowedByCaller(options);\n \n             // note: we on purpose don't pass in the information about the PendingIntent's creator,\n             // like pid or ProcessRecord, to the ActivityTaskManagerInternal calls below, because\n",
    "added_lines": 21,
    "deleted_lines": 1,
    "changed_methods": "PendingIntentRecord::isPendingIntentBalAllowedByCaller, PendingIntentRecord::sendInner, PendingIntentRecord::isPendingIntentBalAllowedByCaller"
   },
   {
    "filename": "ActivityStarter.java",
    "diff": "@@ -989,6 +989,10 @@ class ActivityStarter {\n         abort |= !mService.getPermissionPolicyInternal().checkStartActivity(intent, callingUid,\n                 callingPackage);\n \n+        // Merge the two options bundles, while realCallerOptions takes precedence.\n+        ActivityOptions checkedOptions = options != null\n+                ? options.getOptions(intent, aInfo, callerApp, mSupervisor) : null;\n+\n         boolean restrictedBgActivity = false;\n         if (!abort) {\n             try {\n@@ -997,15 +1001,12 @@ class ActivityStarter {\n                 restrictedBgActivity = shouldAbortBackgroundActivityStart(callingUid,\n                         callingPid, callingPackage, realCallingUid, realCallingPid, callerApp,\n                         request.originatingPendingIntent, request.allowBackgroundActivityStart,\n-                        intent);\n+                        intent, checkedOptions);\n             } finally {\n                 Trace.traceEnd(Trace.TRACE_TAG_WINDOW_MANAGER);\n             }\n         }\n \n-        // Merge the two options bundles, while realCallerOptions takes precedence.\n-        ActivityOptions checkedOptions = options != null\n-                ? options.getOptions(intent, aInfo, callerApp, mSupervisor) : null;\n         if (request.allowPendingRemoteAnimationRegistryLookup) {\n             checkedOptions = mService.getActivityStartController()\n                     .getPendingRemoteAnimationRegistry()\n@@ -1247,7 +1248,7 @@ class ActivityStarter {\n     boolean shouldAbortBackgroundActivityStart(int callingUid, int callingPid,\n             final String callingPackage, int realCallingUid, int realCallingPid,\n             WindowProcessController callerApp, PendingIntentRecord originatingPendingIntent,\n-            boolean allowBackgroundActivityStart, Intent intent) {\n+            boolean allowBackgroundActivityStart, Intent intent, ActivityOptions checkedOptions) {\n         // don't abort for the most important UIDs\n         final int callingAppId = UserHandle.getAppId(callingUid);\n         if (callingUid == Process.ROOT_UID || callingAppId == Process.SYSTEM_UID\n@@ -1318,9 +1319,12 @@ class ActivityStarter {\n                 ? isCallingUidPersistentSystemProcess\n                 : (realCallingAppId == Process.SYSTEM_UID)\n                         || realCallingUidProcState <= ActivityManager.PROCESS_STATE_PERSISTENT_UI;\n-        if (realCallingUid != callingUid) {\n-            // don't abort if the realCallingUid has a visible window\n-            // TODO(b/171459802): We should check appSwitchAllowed also\n+\n+        // Legacy behavior allows to use caller foreground state to bypass BAL restriction.\n+        final boolean balAllowedByPiSender =\n+                PendingIntentRecord.isPendingIntentBalAllowedByCaller(checkedOptions);\n+\n+        if (balAllowedByPiSender && realCallingUid != callingUid) {\n             if (realCallingUidHasAnyVisibleWindow) {\n                 if (DEBUG_ACTIVITY_STARTS) {\n                     Slog.d(TAG, \"Activity start allowed: realCallingUid (\" + realCallingUid\n@@ -1393,9 +1397,9 @@ class ActivityStarter {\n         // If we don't have callerApp at this point, no caller was provided to startActivity().\n         // That's the case for PendingIntent-based starts, since the creator's process might not be\n         // up and alive. If that's the case, we retrieve the WindowProcessController for the send()\n-        // caller, so that we can make the decision based on its state.\n+        // caller if caller allows, so that we can make the decision based on its state.\n         int callerAppUid = callingUid;\n-        if (callerApp == null) {\n+        if (callerApp == null && balAllowedByPiSender) {\n             callerApp = mService.getProcessController(realCallingPid, realCallingUid);\n             callerAppUid = realCallingUid;\n         }\n",
    "added_lines": 14,
    "deleted_lines": 10,
    "changed_methods": "ActivityStarter::shouldAbortBackgroundActivityStart, ActivityStarter::shouldAbortBackgroundActivityStart, ActivityStarter::executeRequest"
   },
   {
    "filename": "ActivityTaskManagerService.java",
    "diff": "@@ -2114,7 +2114,7 @@ public class ActivityTaskManagerService extends IActivityTaskManager.Stub {\n         final ActivityStarter starter = getActivityStartController().obtainStarter(\n                 null /* intent */, \"moveTaskToFront\");\n         if (starter.shouldAbortBackgroundActivityStart(callingUid, callingPid, callingPackage, -1,\n-                -1, callerApp, null, false, null)) {\n+                -1, callerApp, null, false, null, null)) {\n             if (!isBackgroundActivityStartsEnabled()) {\n                 return;\n             }\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "ActivityTaskManagerService::moveTaskToFrontLocked"
   },
   {
    "filename": "AppTaskImpl.java",
    "diff": "@@ -108,7 +108,7 @@ class AppTaskImpl extends IAppTask.Stub {\n                 final ActivityStarter starter = mService.getActivityStartController().obtainStarter(\n                         null /* intent */, \"moveToFront\");\n                 if (starter.shouldAbortBackgroundActivityStart(callingUid, callingPid,\n-                        callingPackage, -1, -1, callerApp, null, false, null)) {\n+                        callingPackage, -1, -1, callerApp, null, false, null, null)) {\n                     if (!mService.isBackgroundActivityStartsEnabled()) {\n                         return;\n                     }\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "AppTaskImpl::moveToFront"
   },
   {
    "filename": "AlarmManagerServiceTest.java",
    "diff": "@@ -109,6 +109,7 @@ import static org.mockito.Mockito.times;\n \n import android.app.ActivityManager;\n import android.app.ActivityManagerInternal;\n+import android.app.ActivityOptions;\n import android.app.AlarmManager;\n import android.app.AppOpsManager;\n import android.app.BroadcastOptions;\n@@ -552,13 +553,23 @@ public class AlarmManagerServiceTest {\n \n \n     private PendingIntent getNewMockPendingIntent() {\n-        return getNewMockPendingIntent(TEST_CALLING_UID, TEST_CALLING_PACKAGE);\n+        return getNewMockPendingIntent(false);\n+    }\n+\n+    private PendingIntent getNewMockPendingIntent(boolean isActivity) {\n+        return getNewMockPendingIntent(TEST_CALLING_UID, TEST_CALLING_PACKAGE, isActivity);\n     }\n \n     private PendingIntent getNewMockPendingIntent(int creatorUid, String creatorPackage) {\n+        return getNewMockPendingIntent(creatorUid, creatorPackage, false);\n+    }\n+\n+    private PendingIntent getNewMockPendingIntent(int creatorUid, String creatorPackage,\n+            boolean isActivity) {\n         final PendingIntent mockPi = mock(PendingIntent.class, Answers.RETURNS_DEEP_STUBS);\n         when(mockPi.getCreatorUid()).thenReturn(creatorUid);\n         when(mockPi.getCreatorPackage()).thenReturn(creatorPackage);\n+        when(mockPi.isActivity()).thenReturn(isActivity);\n         return mockPi;\n     }\n \n@@ -2801,21 +2812,53 @@ public class AlarmManagerServiceTest {\n                 anyString()));\n     }\n \n-    @Test\n-    public void idleOptionsSentOnExpiration() throws Exception {\n+    private void optionsSentOnExpiration(boolean isActivity, Bundle idleOptions)\n+            throws Exception {\n         final long triggerTime = mNowElapsedTest + 5000;\n-        final PendingIntent alarmPi = getNewMockPendingIntent();\n-        final Bundle idleOptions = new Bundle();\n-        idleOptions.putChar(\"TEST_CHAR_KEY\", 'x');\n-        idleOptions.putInt(\"TEST_INT_KEY\", 53);\n+        final PendingIntent alarmPi = getNewMockPendingIntent(isActivity);\n         setTestAlarm(ELAPSED_REALTIME_WAKEUP, triggerTime, 0, alarmPi, 0, 0, TEST_CALLING_UID,\n                 idleOptions);\n \n         mNowElapsedTest = mTestTimer.getElapsed();\n         mTestTimer.expire();\n \n+        ArgumentCaptor<Bundle> bundleCaptor = ArgumentCaptor.forClass(Bundle.class);\n         verify(alarmPi).send(eq(mMockContext), eq(0), any(Intent.class),\n-                any(), any(Handler.class), isNull(), eq(idleOptions));\n+                any(), any(Handler.class), isNull(), bundleCaptor.capture());\n+        if (idleOptions != null) {\n+            assertEquals(idleOptions, bundleCaptor.getValue());\n+        } else {\n+            assertFalse(\"BAL flag needs to be false in alarm manager\",\n+                    bundleCaptor.getValue().getBoolean(\n+                            ActivityOptions.KEY_PENDING_INTENT_BACKGROUND_ACTIVITY_ALLOWED,\n+                            true));\n+        }\n+    }\n+\n+    @Test\n+    public void activityIdleOptionsSentOnExpiration() throws Exception {\n+        final Bundle idleOptions = new Bundle();\n+        idleOptions.putChar(\"TEST_CHAR_KEY\", 'x');\n+        idleOptions.putInt(\"TEST_INT_KEY\", 53);\n+        optionsSentOnExpiration(true, idleOptions);\n+    }\n+\n+    @Test\n+    public void broadcastIdleOptionsSentOnExpiration() throws Exception {\n+        final Bundle idleOptions = new Bundle();\n+        idleOptions.putChar(\"TEST_CHAR_KEY\", 'x');\n+        idleOptions.putInt(\"TEST_INT_KEY\", 53);\n+        optionsSentOnExpiration(false, idleOptions);\n+    }\n+\n+    @Test\n+    public void emptyActivityOptionsSentOnExpiration() throws Exception {\n+        optionsSentOnExpiration(true, null);\n+    }\n+\n+    @Test\n+    public void emptyBroadcastOptionsSentOnExpiration() throws Exception {\n+        optionsSentOnExpiration(false, null);\n     }\n \n     @Test\n",
    "added_lines": 51,
    "deleted_lines": 8,
    "changed_methods": "AlarmManagerServiceTest::getNewMockPendingIntent, AlarmManagerServiceTest::activityIdleOptionsSentOnExpiration, AlarmManagerServiceTest::emptyActivityOptionsSentOnExpiration, AlarmManagerServiceTest::getNewMockPendingIntent, AlarmManagerServiceTest::emptyBroadcastOptionsSentOnExpiration, AlarmManagerServiceTest::idleOptionsSentOnExpiration, AlarmManagerServiceTest::broadcastIdleOptionsSentOnExpiration, AlarmManagerServiceTest::getNewMockPendingIntent, AlarmManagerServiceTest::getNewMockPendingIntent, AlarmManagerServiceTest::optionsSentOnExpiration"
   }
  ]
 },
 {
  "hash": "af52e36a81099ffc43e898f74f1e8f70ec1de2e3",
  "commit": "[DO NOT MERGE] Backport BAL restrictions from T to S, this blocks apps from using Alarm\nManager to bypass BAL restrictions.\n\nTest: atest-src BackgroundActivityLaunchTest\nBug: 195756028\nChange-Id: I33112ff59d913d8a7244289fe1a43512844e902a\n(cherry picked from commit 7a41e2fbc983ce0083b288e9489288de60dc8d8b)\nMerged-In: I33112ff59d913d8a7244289fe1a43512844e902a",
  "files": [
   {
    "filename": "AlarmManagerService.java",
    "diff": "@@ -56,6 +56,7 @@ import android.annotation.NonNull;\n import android.annotation.UserIdInt;\n import android.app.Activity;\n import android.app.ActivityManagerInternal;\n+import android.app.ActivityOptions;\n import android.app.AlarmManager;\n import android.app.AppOpsManager;\n import android.app.BroadcastOptions;\n@@ -317,6 +318,8 @@ public class AlarmManagerService extends SystemService {\n     private final SparseBooleanArray mPendingSendNextAlarmClockChangedForUser =\n             new SparseBooleanArray();\n     private boolean mNextAlarmClockMayChange;\n+    ActivityOptions mActivityOptsRestrictBal = ActivityOptions.makeBasic();\n+    BroadcastOptions mBroadcastOptsRestrictBal = BroadcastOptions.makeBasic();\n \n     @GuardedBy(\"mLock\")\n     private final Runnable mAlarmClockUpdater = () -> mNextAlarmClockMayChange = true;\n@@ -1611,6 +1614,11 @@ public class AlarmManagerService extends SystemService {\n     @Override\n     public void onStart() {\n         mInjector.init();\n+        mOptsWithFgs.setPendingIntentBackgroundActivityLaunchAllowed(false);\n+        mOptsWithoutFgs.setPendingIntentBackgroundActivityLaunchAllowed(false);\n+        mOptsTimeBroadcast.setPendingIntentBackgroundActivityLaunchAllowed(false);\n+        mActivityOptsRestrictBal.setPendingIntentBackgroundActivityLaunchAllowed(false);\n+        mBroadcastOptsRestrictBal.setPendingIntentBackgroundActivityLaunchAllowed(false);\n         mMetricsHelper = new MetricsHelper(getContext(), mLock);\n \n         mListenerDeathRecipient = new IBinder.DeathRecipient() {\n@@ -4306,6 +4314,14 @@ public class AlarmManagerService extends SystemService {\n         return alarm.creatorUid;\n     }\n \n+    private Bundle getAlarmOperationBundle(Alarm alarm) {\n+        if (alarm.mIdleOptions != null) {\n+            return alarm.mIdleOptions;\n+        } else if (alarm.operation.isActivity()) {\n+            return mActivityOptsRestrictBal.toBundle();\n+        }\n+        return mBroadcastOptsRestrictBal.toBundle();\n+    }\n \n     @VisibleForTesting\n     class AlarmHandler extends Handler {\n@@ -4344,7 +4360,11 @@ public class AlarmManagerService extends SystemService {\n                     for (int i = 0; i < triggerList.size(); i++) {\n                         Alarm alarm = triggerList.get(i);\n                         try {\n-                            alarm.operation.send();\n+                            // Disallow AlarmManager to start random background activity.\n+                            final Bundle bundle = getAlarmOperationBundle(alarm);\n+                            alarm.operation.send(/* context */ null, /* code */0, /* intent */\n+                                    null, /* onFinished */null, /* handler */\n+                                    null, /* requiredPermission */ null, bundle);\n                         } catch (PendingIntent.CanceledException e) {\n                             if (alarm.repeatInterval > 0) {\n                                 // This IntentSender is no longer valid, but this\n@@ -4908,9 +4928,10 @@ public class AlarmManagerService extends SystemService {\n                     mSendCount++;\n \n                     try {\n+                        final Bundle bundle = getAlarmOperationBundle(alarm);\n                         alarm.operation.send(getContext(), 0,\n                                 mBackgroundIntent.putExtra(Intent.EXTRA_ALARM_COUNT, alarm.count),\n-                                mDeliveryTracker, mHandler, null, alarm.mIdleOptions);\n+                                mDeliveryTracker, mHandler, null, bundle);\n                     } catch (PendingIntent.CanceledException e) {\n                         if (alarm.repeatInterval > 0) {\n                             // This IntentSender is no longer valid, but this\n",
    "added_lines": 23,
    "deleted_lines": 2,
    "changed_methods": "AlarmManagerService::getAlarmOperationBundle, AlarmManagerService::DeliveryTracker::deliverLocked, AlarmManagerService::onStart, AlarmManagerService::AlarmHandler::handleMessage"
   },
   {
    "filename": "ActivityOptions.java",
    "diff": "@@ -69,7 +69,7 @@ import java.util.ArrayList;\n  * {@link android.content.Context#startActivity(android.content.Intent, android.os.Bundle)\n  * Context.startActivity(Intent, Bundle)} and related methods.\n  */\n-public class ActivityOptions {\n+public class ActivityOptions extends ComponentOptions {\n     private static final String TAG = \"ActivityOptions\";\n \n     /**\n@@ -1081,13 +1081,12 @@ public class ActivityOptions {\n     }\n \n     private ActivityOptions() {\n+        super();\n     }\n \n     /** @hide */\n     public ActivityOptions(Bundle opts) {\n-        // If the remote side sent us bad parcelables, they won't get the\n-        // results they want, which is their loss.\n-        opts.setDefusable(true);\n+        super(opts);\n \n         mPackageName = opts.getString(KEY_PACKAGE_NAME);\n         try {\n@@ -1832,8 +1831,9 @@ public class ActivityOptions {\n      * object; you must not modify it, but can supply it to the startActivity\n      * methods that take an options Bundle.\n      */\n+    @Override\n     public Bundle toBundle() {\n-        Bundle b = new Bundle();\n+        Bundle b = super.toBundle();\n         if (mPackageName != null) {\n             b.putString(KEY_PACKAGE_NAME, mPackageName);\n         }\n",
    "added_lines": 5,
    "deleted_lines": 5,
    "changed_methods": "ActivityOptions::ActivityOptions, ActivityOptions::ActivityOptions, ActivityOptions::toBundle"
   },
   {
    "filename": "BroadcastOptions.java",
    "diff": "@@ -34,7 +34,7 @@ import android.os.PowerExemptionManager.TempAllowListType;\n  * {@hide}\n  */\n @SystemApi\n-public class BroadcastOptions {\n+public class BroadcastOptions extends ComponentOptions {\n     private long mTemporaryAppAllowlistDuration;\n     private @TempAllowListType int mTemporaryAppAllowlistType;\n     private @ReasonCode int mTemporaryAppAllowlistReasonCode;\n@@ -108,12 +108,14 @@ public class BroadcastOptions {\n     }\n \n     private BroadcastOptions() {\n+        super();\n         resetTemporaryAppAllowlist();\n     }\n \n     /** @hide */\n     @TestApi\n     public BroadcastOptions(@NonNull Bundle opts) {\n+        super(opts);\n         // Match the logic in toBundle().\n         if (opts.containsKey(KEY_TEMPORARY_APP_ALLOWLIST_DURATION)) {\n             mTemporaryAppAllowlistDuration = opts.getLong(KEY_TEMPORARY_APP_ALLOWLIST_DURATION);\n@@ -190,6 +192,24 @@ public class BroadcastOptions {\n         mTemporaryAppAllowlistReason = null;\n     }\n \n+    /**\n+     * Set PendingIntent activity is allowed to be started in the background if the caller\n+     * can start background activities.\n+     * @hide\n+     */\n+    public void setPendingIntentBackgroundActivityLaunchAllowed(boolean allowed) {\n+        super.setPendingIntentBackgroundActivityLaunchAllowed(allowed);\n+    }\n+\n+    /**\n+     * Get PendingIntent activity is allowed to be started in the background if the caller\n+     * can start background activities.\n+     * @hide\n+     */\n+    public boolean isPendingIntentBackgroundActivityLaunchAllowed() {\n+        return super.isPendingIntentBackgroundActivityLaunchAllowed();\n+    }\n+\n     /**\n      * Return {@link #setTemporaryAppAllowlist}.\n      * @hide\n@@ -308,8 +328,9 @@ public class BroadcastOptions {\n      * object; you must not modify it, but can supply it to the sendBroadcast\n      * methods that take an options Bundle.\n      */\n+    @Override\n     public Bundle toBundle() {\n-        Bundle b = new Bundle();\n+        Bundle b = super.toBundle();\n         if (isTemporaryAppAllowlistSet()) {\n             b.putLong(KEY_TEMPORARY_APP_ALLOWLIST_DURATION, mTemporaryAppAllowlistDuration);\n             b.putInt(KEY_TEMPORARY_APP_ALLOWLIST_TYPE, mTemporaryAppAllowlistType);\n",
    "added_lines": 23,
    "deleted_lines": 2,
    "changed_methods": "BroadcastOptions::toBundle, BroadcastOptions::BroadcastOptions, BroadcastOptions::setPendingIntentBackgroundActivityLaunchAllowed, BroadcastOptions::isPendingIntentBackgroundActivityLaunchAllowed, BroadcastOptions::BroadcastOptions"
   },
   {
    "filename": "ComponentOptions.java",
    "diff": "@@ -0,0 +1,83 @@\n+/*\n+ * Copyright (C) 2021 The Android Open Source Project\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package android.app;\n+\n+import android.os.Bundle;\n+\n+/**\n+ * @hide\n+ */\n+public class ComponentOptions {\n+\n+    /**\n+     * Default value for KEY_PENDING_INTENT_BACKGROUND_ACTIVITY_ALLOWED.\n+     * @hide\n+     **/\n+    public static final boolean PENDING_INTENT_BAL_ALLOWED_DEFAULT = true;\n+\n+    /**\n+     * PendingIntent caller allows activity start even if PendingIntent creator is in background.\n+     * This only works if the PendingIntent caller is allowed to start background activities,\n+     * for example if it's in the foreground, or has BAL permission.\n+     * @hide\n+     */\n+    public static final String KEY_PENDING_INTENT_BACKGROUND_ACTIVITY_ALLOWED =\n+            \"android.pendingIntent.backgroundActivityAllowed\";\n+\n+    private boolean mPendingIntentBalAllowed = PENDING_INTENT_BAL_ALLOWED_DEFAULT;\n+\n+    ComponentOptions() {\n+    }\n+\n+    ComponentOptions(Bundle opts) {\n+        // If the remote side sent us bad parcelables, they won't get the\n+        // results they want, which is their loss.\n+        opts.setDefusable(true);\n+        setPendingIntentBackgroundActivityLaunchAllowed(\n+                opts.getBoolean(KEY_PENDING_INTENT_BACKGROUND_ACTIVITY_ALLOWED,\n+                        PENDING_INTENT_BAL_ALLOWED_DEFAULT));\n+    }\n+\n+    /**\n+     * Set PendingIntent activity is allowed to be started in the background if the caller\n+     * can start background activities.\n+     *\n+     * @hide\n+     */\n+    public void setPendingIntentBackgroundActivityLaunchAllowed(boolean allowed) {\n+        mPendingIntentBalAllowed = allowed;\n+    }\n+\n+    /**\n+     * Get PendingIntent activity is allowed to be started in the background if the caller\n+     * can start background activities.\n+     *\n+     * @hide\n+     */\n+    public boolean isPendingIntentBackgroundActivityLaunchAllowed() {\n+        return mPendingIntentBalAllowed;\n+    }\n+\n+    /**\n+     * @hide\n+     */\n+    public Bundle toBundle() {\n+        Bundle bundle = new Bundle();\n+        bundle.putBoolean(KEY_PENDING_INTENT_BACKGROUND_ACTIVITY_ALLOWED, mPendingIntentBalAllowed);\n+        return bundle;\n+    }\n+}\n",
    "added_lines": 83,
    "deleted_lines": 0,
    "changed_methods": "ComponentOptions::toBundle, ComponentOptions::ComponentOptions, ComponentOptions::ComponentOptions, ComponentOptions::isPendingIntentBackgroundActivityLaunchAllowed, ComponentOptions::setPendingIntentBackgroundActivityLaunchAllowed"
   },
   {
    "filename": "PendingIntentRecord.java",
    "diff": "@@ -310,6 +310,25 @@ public final class PendingIntentRecord extends IIntentSender.Stub {\n                 requiredPermission, null, null, 0, 0, 0, options);\n     }\n \n+    /**\n+     * Return true if the activity options allows PendingIntent to use caller's BAL permission.\n+     */\n+    public static boolean isPendingIntentBalAllowedByCaller(\n+            @Nullable ActivityOptions activityOptions) {\n+        if (activityOptions == null) {\n+            return ActivityOptions.PENDING_INTENT_BAL_ALLOWED_DEFAULT;\n+        }\n+        return isPendingIntentBalAllowedByCaller(activityOptions.toBundle());\n+    }\n+\n+    private static boolean isPendingIntentBalAllowedByCaller(@Nullable Bundle options) {\n+        if (options == null) {\n+            return ActivityOptions.PENDING_INTENT_BAL_ALLOWED_DEFAULT;\n+        }\n+        return options.getBoolean(ActivityOptions.KEY_PENDING_INTENT_BACKGROUND_ACTIVITY_ALLOWED,\n+                ActivityOptions.PENDING_INTENT_BAL_ALLOWED_DEFAULT);\n+    }\n+\n     public int sendInner(int code, Intent intent, String resolvedType, IBinder allowlistToken,\n             IIntentReceiver finishedReceiver, String requiredPermission, IBinder resultTo,\n             String resultWho, int requestCode, int flagsMask, int flagsValues, Bundle options) {\n@@ -431,7 +450,8 @@ public final class PendingIntentRecord extends IIntentSender.Stub {\n             // temporarily allow receivers and services to open activities from background if the\n             // PendingIntent.send() caller was foreground at the time of sendInner() call\n             final boolean allowTrampoline = uid != callingUid\n-                    && controller.mAtmInternal.isUidForeground(callingUid);\n+                    && controller.mAtmInternal.isUidForeground(callingUid)\n+                    && isPendingIntentBalAllowedByCaller(options);\n \n             // note: we on purpose don't pass in the information about the PendingIntent's creator,\n             // like pid or ProcessRecord, to the ActivityTaskManagerInternal calls below, because\n",
    "added_lines": 21,
    "deleted_lines": 1,
    "changed_methods": "PendingIntentRecord::isPendingIntentBalAllowedByCaller, PendingIntentRecord::sendInner, PendingIntentRecord::isPendingIntentBalAllowedByCaller"
   },
   {
    "filename": "ActivityStarter.java",
    "diff": "@@ -989,6 +989,10 @@ class ActivityStarter {\n         abort |= !mService.getPermissionPolicyInternal().checkStartActivity(intent, callingUid,\n                 callingPackage);\n \n+        // Merge the two options bundles, while realCallerOptions takes precedence.\n+        ActivityOptions checkedOptions = options != null\n+                ? options.getOptions(intent, aInfo, callerApp, mSupervisor) : null;\n+\n         boolean restrictedBgActivity = false;\n         if (!abort) {\n             try {\n@@ -997,15 +1001,12 @@ class ActivityStarter {\n                 restrictedBgActivity = shouldAbortBackgroundActivityStart(callingUid,\n                         callingPid, callingPackage, realCallingUid, realCallingPid, callerApp,\n                         request.originatingPendingIntent, request.allowBackgroundActivityStart,\n-                        intent);\n+                        intent, checkedOptions);\n             } finally {\n                 Trace.traceEnd(Trace.TRACE_TAG_WINDOW_MANAGER);\n             }\n         }\n \n-        // Merge the two options bundles, while realCallerOptions takes precedence.\n-        ActivityOptions checkedOptions = options != null\n-                ? options.getOptions(intent, aInfo, callerApp, mSupervisor) : null;\n         if (request.allowPendingRemoteAnimationRegistryLookup) {\n             checkedOptions = mService.getActivityStartController()\n                     .getPendingRemoteAnimationRegistry()\n@@ -1247,7 +1248,7 @@ class ActivityStarter {\n     boolean shouldAbortBackgroundActivityStart(int callingUid, int callingPid,\n             final String callingPackage, int realCallingUid, int realCallingPid,\n             WindowProcessController callerApp, PendingIntentRecord originatingPendingIntent,\n-            boolean allowBackgroundActivityStart, Intent intent) {\n+            boolean allowBackgroundActivityStart, Intent intent, ActivityOptions checkedOptions) {\n         // don't abort for the most important UIDs\n         final int callingAppId = UserHandle.getAppId(callingUid);\n         if (callingUid == Process.ROOT_UID || callingAppId == Process.SYSTEM_UID\n@@ -1318,9 +1319,12 @@ class ActivityStarter {\n                 ? isCallingUidPersistentSystemProcess\n                 : (realCallingAppId == Process.SYSTEM_UID)\n                         || realCallingUidProcState <= ActivityManager.PROCESS_STATE_PERSISTENT_UI;\n-        if (realCallingUid != callingUid) {\n-            // don't abort if the realCallingUid has a visible window\n-            // TODO(b/171459802): We should check appSwitchAllowed also\n+\n+        // Legacy behavior allows to use caller foreground state to bypass BAL restriction.\n+        final boolean balAllowedByPiSender =\n+                PendingIntentRecord.isPendingIntentBalAllowedByCaller(checkedOptions);\n+\n+        if (balAllowedByPiSender && realCallingUid != callingUid) {\n             if (realCallingUidHasAnyVisibleWindow) {\n                 if (DEBUG_ACTIVITY_STARTS) {\n                     Slog.d(TAG, \"Activity start allowed: realCallingUid (\" + realCallingUid\n@@ -1393,9 +1397,9 @@ class ActivityStarter {\n         // If we don't have callerApp at this point, no caller was provided to startActivity().\n         // That's the case for PendingIntent-based starts, since the creator's process might not be\n         // up and alive. If that's the case, we retrieve the WindowProcessController for the send()\n-        // caller, so that we can make the decision based on its state.\n+        // caller if caller allows, so that we can make the decision based on its state.\n         int callerAppUid = callingUid;\n-        if (callerApp == null) {\n+        if (callerApp == null && balAllowedByPiSender) {\n             callerApp = mService.getProcessController(realCallingPid, realCallingUid);\n             callerAppUid = realCallingUid;\n         }\n",
    "added_lines": 14,
    "deleted_lines": 10,
    "changed_methods": "ActivityStarter::shouldAbortBackgroundActivityStart, ActivityStarter::shouldAbortBackgroundActivityStart, ActivityStarter::executeRequest"
   },
   {
    "filename": "ActivityTaskManagerService.java",
    "diff": "@@ -2114,7 +2114,7 @@ public class ActivityTaskManagerService extends IActivityTaskManager.Stub {\n         final ActivityStarter starter = getActivityStartController().obtainStarter(\n                 null /* intent */, \"moveTaskToFront\");\n         if (starter.shouldAbortBackgroundActivityStart(callingUid, callingPid, callingPackage, -1,\n-                -1, callerApp, null, false, null)) {\n+                -1, callerApp, null, false, null, null)) {\n             if (!isBackgroundActivityStartsEnabled()) {\n                 return;\n             }\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "ActivityTaskManagerService::moveTaskToFrontLocked"
   },
   {
    "filename": "AppTaskImpl.java",
    "diff": "@@ -108,7 +108,7 @@ class AppTaskImpl extends IAppTask.Stub {\n                 final ActivityStarter starter = mService.getActivityStartController().obtainStarter(\n                         null /* intent */, \"moveToFront\");\n                 if (starter.shouldAbortBackgroundActivityStart(callingUid, callingPid,\n-                        callingPackage, -1, -1, callerApp, null, false, null)) {\n+                        callingPackage, -1, -1, callerApp, null, false, null, null)) {\n                     if (!mService.isBackgroundActivityStartsEnabled()) {\n                         return;\n                     }\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "AppTaskImpl::moveToFront"
   },
   {
    "filename": "AlarmManagerServiceTest.java",
    "diff": "@@ -109,6 +109,7 @@ import static org.mockito.Mockito.times;\n \n import android.app.ActivityManager;\n import android.app.ActivityManagerInternal;\n+import android.app.ActivityOptions;\n import android.app.AlarmManager;\n import android.app.AppOpsManager;\n import android.app.BroadcastOptions;\n@@ -552,13 +553,23 @@ public class AlarmManagerServiceTest {\n \n \n     private PendingIntent getNewMockPendingIntent() {\n-        return getNewMockPendingIntent(TEST_CALLING_UID, TEST_CALLING_PACKAGE);\n+        return getNewMockPendingIntent(false);\n+    }\n+\n+    private PendingIntent getNewMockPendingIntent(boolean isActivity) {\n+        return getNewMockPendingIntent(TEST_CALLING_UID, TEST_CALLING_PACKAGE, isActivity);\n     }\n \n     private PendingIntent getNewMockPendingIntent(int creatorUid, String creatorPackage) {\n+        return getNewMockPendingIntent(creatorUid, creatorPackage, false);\n+    }\n+\n+    private PendingIntent getNewMockPendingIntent(int creatorUid, String creatorPackage,\n+            boolean isActivity) {\n         final PendingIntent mockPi = mock(PendingIntent.class, Answers.RETURNS_DEEP_STUBS);\n         when(mockPi.getCreatorUid()).thenReturn(creatorUid);\n         when(mockPi.getCreatorPackage()).thenReturn(creatorPackage);\n+        when(mockPi.isActivity()).thenReturn(isActivity);\n         return mockPi;\n     }\n \n@@ -2801,21 +2812,53 @@ public class AlarmManagerServiceTest {\n                 anyString()));\n     }\n \n-    @Test\n-    public void idleOptionsSentOnExpiration() throws Exception {\n+    private void optionsSentOnExpiration(boolean isActivity, Bundle idleOptions)\n+            throws Exception {\n         final long triggerTime = mNowElapsedTest + 5000;\n-        final PendingIntent alarmPi = getNewMockPendingIntent();\n-        final Bundle idleOptions = new Bundle();\n-        idleOptions.putChar(\"TEST_CHAR_KEY\", 'x');\n-        idleOptions.putInt(\"TEST_INT_KEY\", 53);\n+        final PendingIntent alarmPi = getNewMockPendingIntent(isActivity);\n         setTestAlarm(ELAPSED_REALTIME_WAKEUP, triggerTime, 0, alarmPi, 0, 0, TEST_CALLING_UID,\n                 idleOptions);\n \n         mNowElapsedTest = mTestTimer.getElapsed();\n         mTestTimer.expire();\n \n+        ArgumentCaptor<Bundle> bundleCaptor = ArgumentCaptor.forClass(Bundle.class);\n         verify(alarmPi).send(eq(mMockContext), eq(0), any(Intent.class),\n-                any(), any(Handler.class), isNull(), eq(idleOptions));\n+                any(), any(Handler.class), isNull(), bundleCaptor.capture());\n+        if (idleOptions != null) {\n+            assertEquals(idleOptions, bundleCaptor.getValue());\n+        } else {\n+            assertFalse(\"BAL flag needs to be false in alarm manager\",\n+                    bundleCaptor.getValue().getBoolean(\n+                            ActivityOptions.KEY_PENDING_INTENT_BACKGROUND_ACTIVITY_ALLOWED,\n+                            true));\n+        }\n+    }\n+\n+    @Test\n+    public void activityIdleOptionsSentOnExpiration() throws Exception {\n+        final Bundle idleOptions = new Bundle();\n+        idleOptions.putChar(\"TEST_CHAR_KEY\", 'x');\n+        idleOptions.putInt(\"TEST_INT_KEY\", 53);\n+        optionsSentOnExpiration(true, idleOptions);\n+    }\n+\n+    @Test\n+    public void broadcastIdleOptionsSentOnExpiration() throws Exception {\n+        final Bundle idleOptions = new Bundle();\n+        idleOptions.putChar(\"TEST_CHAR_KEY\", 'x');\n+        idleOptions.putInt(\"TEST_INT_KEY\", 53);\n+        optionsSentOnExpiration(false, idleOptions);\n+    }\n+\n+    @Test\n+    public void emptyActivityOptionsSentOnExpiration() throws Exception {\n+        optionsSentOnExpiration(true, null);\n+    }\n+\n+    @Test\n+    public void emptyBroadcastOptionsSentOnExpiration() throws Exception {\n+        optionsSentOnExpiration(false, null);\n     }\n \n     @Test\n",
    "added_lines": 51,
    "deleted_lines": 8,
    "changed_methods": "AlarmManagerServiceTest::getNewMockPendingIntent, AlarmManagerServiceTest::activityIdleOptionsSentOnExpiration, AlarmManagerServiceTest::emptyActivityOptionsSentOnExpiration, AlarmManagerServiceTest::getNewMockPendingIntent, AlarmManagerServiceTest::emptyBroadcastOptionsSentOnExpiration, AlarmManagerServiceTest::idleOptionsSentOnExpiration, AlarmManagerServiceTest::broadcastIdleOptionsSentOnExpiration, AlarmManagerServiceTest::getNewMockPendingIntent, AlarmManagerServiceTest::getNewMockPendingIntent, AlarmManagerServiceTest::optionsSentOnExpiration"
   }
  ]
 },
 {
  "hash": "af52e36a81099ffc43e898f74f1e8f70ec1de2e3",
  "commit": "[DO NOT MERGE] Backport BAL restrictions from T to S, this blocks apps from using Alarm\nManager to bypass BAL restrictions.\n\nTest: atest-src BackgroundActivityLaunchTest\nBug: 195756028\nChange-Id: I33112ff59d913d8a7244289fe1a43512844e902a\n(cherry picked from commit 7a41e2fbc983ce0083b288e9489288de60dc8d8b)\nMerged-In: I33112ff59d913d8a7244289fe1a43512844e902a",
  "files": [
   {
    "filename": "AlarmManagerService.java",
    "diff": "@@ -56,6 +56,7 @@ import android.annotation.NonNull;\n import android.annotation.UserIdInt;\n import android.app.Activity;\n import android.app.ActivityManagerInternal;\n+import android.app.ActivityOptions;\n import android.app.AlarmManager;\n import android.app.AppOpsManager;\n import android.app.BroadcastOptions;\n@@ -317,6 +318,8 @@ public class AlarmManagerService extends SystemService {\n     private final SparseBooleanArray mPendingSendNextAlarmClockChangedForUser =\n             new SparseBooleanArray();\n     private boolean mNextAlarmClockMayChange;\n+    ActivityOptions mActivityOptsRestrictBal = ActivityOptions.makeBasic();\n+    BroadcastOptions mBroadcastOptsRestrictBal = BroadcastOptions.makeBasic();\n \n     @GuardedBy(\"mLock\")\n     private final Runnable mAlarmClockUpdater = () -> mNextAlarmClockMayChange = true;\n@@ -1611,6 +1614,11 @@ public class AlarmManagerService extends SystemService {\n     @Override\n     public void onStart() {\n         mInjector.init();\n+        mOptsWithFgs.setPendingIntentBackgroundActivityLaunchAllowed(false);\n+        mOptsWithoutFgs.setPendingIntentBackgroundActivityLaunchAllowed(false);\n+        mOptsTimeBroadcast.setPendingIntentBackgroundActivityLaunchAllowed(false);\n+        mActivityOptsRestrictBal.setPendingIntentBackgroundActivityLaunchAllowed(false);\n+        mBroadcastOptsRestrictBal.setPendingIntentBackgroundActivityLaunchAllowed(false);\n         mMetricsHelper = new MetricsHelper(getContext(), mLock);\n \n         mListenerDeathRecipient = new IBinder.DeathRecipient() {\n@@ -4306,6 +4314,14 @@ public class AlarmManagerService extends SystemService {\n         return alarm.creatorUid;\n     }\n \n+    private Bundle getAlarmOperationBundle(Alarm alarm) {\n+        if (alarm.mIdleOptions != null) {\n+            return alarm.mIdleOptions;\n+        } else if (alarm.operation.isActivity()) {\n+            return mActivityOptsRestrictBal.toBundle();\n+        }\n+        return mBroadcastOptsRestrictBal.toBundle();\n+    }\n \n     @VisibleForTesting\n     class AlarmHandler extends Handler {\n@@ -4344,7 +4360,11 @@ public class AlarmManagerService extends SystemService {\n                     for (int i = 0; i < triggerList.size(); i++) {\n                         Alarm alarm = triggerList.get(i);\n                         try {\n-                            alarm.operation.send();\n+                            // Disallow AlarmManager to start random background activity.\n+                            final Bundle bundle = getAlarmOperationBundle(alarm);\n+                            alarm.operation.send(/* context */ null, /* code */0, /* intent */\n+                                    null, /* onFinished */null, /* handler */\n+                                    null, /* requiredPermission */ null, bundle);\n                         } catch (PendingIntent.CanceledException e) {\n                             if (alarm.repeatInterval > 0) {\n                                 // This IntentSender is no longer valid, but this\n@@ -4908,9 +4928,10 @@ public class AlarmManagerService extends SystemService {\n                     mSendCount++;\n \n                     try {\n+                        final Bundle bundle = getAlarmOperationBundle(alarm);\n                         alarm.operation.send(getContext(), 0,\n                                 mBackgroundIntent.putExtra(Intent.EXTRA_ALARM_COUNT, alarm.count),\n-                                mDeliveryTracker, mHandler, null, alarm.mIdleOptions);\n+                                mDeliveryTracker, mHandler, null, bundle);\n                     } catch (PendingIntent.CanceledException e) {\n                         if (alarm.repeatInterval > 0) {\n                             // This IntentSender is no longer valid, but this\n",
    "added_lines": 23,
    "deleted_lines": 2,
    "changed_methods": "AlarmManagerService::getAlarmOperationBundle, AlarmManagerService::DeliveryTracker::deliverLocked, AlarmManagerService::onStart, AlarmManagerService::AlarmHandler::handleMessage"
   },
   {
    "filename": "ActivityOptions.java",
    "diff": "@@ -69,7 +69,7 @@ import java.util.ArrayList;\n  * {@link android.content.Context#startActivity(android.content.Intent, android.os.Bundle)\n  * Context.startActivity(Intent, Bundle)} and related methods.\n  */\n-public class ActivityOptions {\n+public class ActivityOptions extends ComponentOptions {\n     private static final String TAG = \"ActivityOptions\";\n \n     /**\n@@ -1081,13 +1081,12 @@ public class ActivityOptions {\n     }\n \n     private ActivityOptions() {\n+        super();\n     }\n \n     /** @hide */\n     public ActivityOptions(Bundle opts) {\n-        // If the remote side sent us bad parcelables, they won't get the\n-        // results they want, which is their loss.\n-        opts.setDefusable(true);\n+        super(opts);\n \n         mPackageName = opts.getString(KEY_PACKAGE_NAME);\n         try {\n@@ -1832,8 +1831,9 @@ public class ActivityOptions {\n      * object; you must not modify it, but can supply it to the startActivity\n      * methods that take an options Bundle.\n      */\n+    @Override\n     public Bundle toBundle() {\n-        Bundle b = new Bundle();\n+        Bundle b = super.toBundle();\n         if (mPackageName != null) {\n             b.putString(KEY_PACKAGE_NAME, mPackageName);\n         }\n",
    "added_lines": 5,
    "deleted_lines": 5,
    "changed_methods": "ActivityOptions::ActivityOptions, ActivityOptions::ActivityOptions, ActivityOptions::toBundle"
   },
   {
    "filename": "BroadcastOptions.java",
    "diff": "@@ -34,7 +34,7 @@ import android.os.PowerExemptionManager.TempAllowListType;\n  * {@hide}\n  */\n @SystemApi\n-public class BroadcastOptions {\n+public class BroadcastOptions extends ComponentOptions {\n     private long mTemporaryAppAllowlistDuration;\n     private @TempAllowListType int mTemporaryAppAllowlistType;\n     private @ReasonCode int mTemporaryAppAllowlistReasonCode;\n@@ -108,12 +108,14 @@ public class BroadcastOptions {\n     }\n \n     private BroadcastOptions() {\n+        super();\n         resetTemporaryAppAllowlist();\n     }\n \n     /** @hide */\n     @TestApi\n     public BroadcastOptions(@NonNull Bundle opts) {\n+        super(opts);\n         // Match the logic in toBundle().\n         if (opts.containsKey(KEY_TEMPORARY_APP_ALLOWLIST_DURATION)) {\n             mTemporaryAppAllowlistDuration = opts.getLong(KEY_TEMPORARY_APP_ALLOWLIST_DURATION);\n@@ -190,6 +192,24 @@ public class BroadcastOptions {\n         mTemporaryAppAllowlistReason = null;\n     }\n \n+    /**\n+     * Set PendingIntent activity is allowed to be started in the background if the caller\n+     * can start background activities.\n+     * @hide\n+     */\n+    public void setPendingIntentBackgroundActivityLaunchAllowed(boolean allowed) {\n+        super.setPendingIntentBackgroundActivityLaunchAllowed(allowed);\n+    }\n+\n+    /**\n+     * Get PendingIntent activity is allowed to be started in the background if the caller\n+     * can start background activities.\n+     * @hide\n+     */\n+    public boolean isPendingIntentBackgroundActivityLaunchAllowed() {\n+        return super.isPendingIntentBackgroundActivityLaunchAllowed();\n+    }\n+\n     /**\n      * Return {@link #setTemporaryAppAllowlist}.\n      * @hide\n@@ -308,8 +328,9 @@ public class BroadcastOptions {\n      * object; you must not modify it, but can supply it to the sendBroadcast\n      * methods that take an options Bundle.\n      */\n+    @Override\n     public Bundle toBundle() {\n-        Bundle b = new Bundle();\n+        Bundle b = super.toBundle();\n         if (isTemporaryAppAllowlistSet()) {\n             b.putLong(KEY_TEMPORARY_APP_ALLOWLIST_DURATION, mTemporaryAppAllowlistDuration);\n             b.putInt(KEY_TEMPORARY_APP_ALLOWLIST_TYPE, mTemporaryAppAllowlistType);\n",
    "added_lines": 23,
    "deleted_lines": 2,
    "changed_methods": "BroadcastOptions::toBundle, BroadcastOptions::BroadcastOptions, BroadcastOptions::setPendingIntentBackgroundActivityLaunchAllowed, BroadcastOptions::isPendingIntentBackgroundActivityLaunchAllowed, BroadcastOptions::BroadcastOptions"
   },
   {
    "filename": "ComponentOptions.java",
    "diff": "@@ -0,0 +1,83 @@\n+/*\n+ * Copyright (C) 2021 The Android Open Source Project\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package android.app;\n+\n+import android.os.Bundle;\n+\n+/**\n+ * @hide\n+ */\n+public class ComponentOptions {\n+\n+    /**\n+     * Default value for KEY_PENDING_INTENT_BACKGROUND_ACTIVITY_ALLOWED.\n+     * @hide\n+     **/\n+    public static final boolean PENDING_INTENT_BAL_ALLOWED_DEFAULT = true;\n+\n+    /**\n+     * PendingIntent caller allows activity start even if PendingIntent creator is in background.\n+     * This only works if the PendingIntent caller is allowed to start background activities,\n+     * for example if it's in the foreground, or has BAL permission.\n+     * @hide\n+     */\n+    public static final String KEY_PENDING_INTENT_BACKGROUND_ACTIVITY_ALLOWED =\n+            \"android.pendingIntent.backgroundActivityAllowed\";\n+\n+    private boolean mPendingIntentBalAllowed = PENDING_INTENT_BAL_ALLOWED_DEFAULT;\n+\n+    ComponentOptions() {\n+    }\n+\n+    ComponentOptions(Bundle opts) {\n+        // If the remote side sent us bad parcelables, they won't get the\n+        // results they want, which is their loss.\n+        opts.setDefusable(true);\n+        setPendingIntentBackgroundActivityLaunchAllowed(\n+                opts.getBoolean(KEY_PENDING_INTENT_BACKGROUND_ACTIVITY_ALLOWED,\n+                        PENDING_INTENT_BAL_ALLOWED_DEFAULT));\n+    }\n+\n+    /**\n+     * Set PendingIntent activity is allowed to be started in the background if the caller\n+     * can start background activities.\n+     *\n+     * @hide\n+     */\n+    public void setPendingIntentBackgroundActivityLaunchAllowed(boolean allowed) {\n+        mPendingIntentBalAllowed = allowed;\n+    }\n+\n+    /**\n+     * Get PendingIntent activity is allowed to be started in the background if the caller\n+     * can start background activities.\n+     *\n+     * @hide\n+     */\n+    public boolean isPendingIntentBackgroundActivityLaunchAllowed() {\n+        return mPendingIntentBalAllowed;\n+    }\n+\n+    /**\n+     * @hide\n+     */\n+    public Bundle toBundle() {\n+        Bundle bundle = new Bundle();\n+        bundle.putBoolean(KEY_PENDING_INTENT_BACKGROUND_ACTIVITY_ALLOWED, mPendingIntentBalAllowed);\n+        return bundle;\n+    }\n+}\n",
    "added_lines": 83,
    "deleted_lines": 0,
    "changed_methods": "ComponentOptions::toBundle, ComponentOptions::ComponentOptions, ComponentOptions::ComponentOptions, ComponentOptions::isPendingIntentBackgroundActivityLaunchAllowed, ComponentOptions::setPendingIntentBackgroundActivityLaunchAllowed"
   },
   {
    "filename": "PendingIntentRecord.java",
    "diff": "@@ -310,6 +310,25 @@ public final class PendingIntentRecord extends IIntentSender.Stub {\n                 requiredPermission, null, null, 0, 0, 0, options);\n     }\n \n+    /**\n+     * Return true if the activity options allows PendingIntent to use caller's BAL permission.\n+     */\n+    public static boolean isPendingIntentBalAllowedByCaller(\n+            @Nullable ActivityOptions activityOptions) {\n+        if (activityOptions == null) {\n+            return ActivityOptions.PENDING_INTENT_BAL_ALLOWED_DEFAULT;\n+        }\n+        return isPendingIntentBalAllowedByCaller(activityOptions.toBundle());\n+    }\n+\n+    private static boolean isPendingIntentBalAllowedByCaller(@Nullable Bundle options) {\n+        if (options == null) {\n+            return ActivityOptions.PENDING_INTENT_BAL_ALLOWED_DEFAULT;\n+        }\n+        return options.getBoolean(ActivityOptions.KEY_PENDING_INTENT_BACKGROUND_ACTIVITY_ALLOWED,\n+                ActivityOptions.PENDING_INTENT_BAL_ALLOWED_DEFAULT);\n+    }\n+\n     public int sendInner(int code, Intent intent, String resolvedType, IBinder allowlistToken,\n             IIntentReceiver finishedReceiver, String requiredPermission, IBinder resultTo,\n             String resultWho, int requestCode, int flagsMask, int flagsValues, Bundle options) {\n@@ -431,7 +450,8 @@ public final class PendingIntentRecord extends IIntentSender.Stub {\n             // temporarily allow receivers and services to open activities from background if the\n             // PendingIntent.send() caller was foreground at the time of sendInner() call\n             final boolean allowTrampoline = uid != callingUid\n-                    && controller.mAtmInternal.isUidForeground(callingUid);\n+                    && controller.mAtmInternal.isUidForeground(callingUid)\n+                    && isPendingIntentBalAllowedByCaller(options);\n \n             // note: we on purpose don't pass in the information about the PendingIntent's creator,\n             // like pid or ProcessRecord, to the ActivityTaskManagerInternal calls below, because\n",
    "added_lines": 21,
    "deleted_lines": 1,
    "changed_methods": "PendingIntentRecord::isPendingIntentBalAllowedByCaller, PendingIntentRecord::sendInner, PendingIntentRecord::isPendingIntentBalAllowedByCaller"
   },
   {
    "filename": "ActivityStarter.java",
    "diff": "@@ -989,6 +989,10 @@ class ActivityStarter {\n         abort |= !mService.getPermissionPolicyInternal().checkStartActivity(intent, callingUid,\n                 callingPackage);\n \n+        // Merge the two options bundles, while realCallerOptions takes precedence.\n+        ActivityOptions checkedOptions = options != null\n+                ? options.getOptions(intent, aInfo, callerApp, mSupervisor) : null;\n+\n         boolean restrictedBgActivity = false;\n         if (!abort) {\n             try {\n@@ -997,15 +1001,12 @@ class ActivityStarter {\n                 restrictedBgActivity = shouldAbortBackgroundActivityStart(callingUid,\n                         callingPid, callingPackage, realCallingUid, realCallingPid, callerApp,\n                         request.originatingPendingIntent, request.allowBackgroundActivityStart,\n-                        intent);\n+                        intent, checkedOptions);\n             } finally {\n                 Trace.traceEnd(Trace.TRACE_TAG_WINDOW_MANAGER);\n             }\n         }\n \n-        // Merge the two options bundles, while realCallerOptions takes precedence.\n-        ActivityOptions checkedOptions = options != null\n-                ? options.getOptions(intent, aInfo, callerApp, mSupervisor) : null;\n         if (request.allowPendingRemoteAnimationRegistryLookup) {\n             checkedOptions = mService.getActivityStartController()\n                     .getPendingRemoteAnimationRegistry()\n@@ -1247,7 +1248,7 @@ class ActivityStarter {\n     boolean shouldAbortBackgroundActivityStart(int callingUid, int callingPid,\n             final String callingPackage, int realCallingUid, int realCallingPid,\n             WindowProcessController callerApp, PendingIntentRecord originatingPendingIntent,\n-            boolean allowBackgroundActivityStart, Intent intent) {\n+            boolean allowBackgroundActivityStart, Intent intent, ActivityOptions checkedOptions) {\n         // don't abort for the most important UIDs\n         final int callingAppId = UserHandle.getAppId(callingUid);\n         if (callingUid == Process.ROOT_UID || callingAppId == Process.SYSTEM_UID\n@@ -1318,9 +1319,12 @@ class ActivityStarter {\n                 ? isCallingUidPersistentSystemProcess\n                 : (realCallingAppId == Process.SYSTEM_UID)\n                         || realCallingUidProcState <= ActivityManager.PROCESS_STATE_PERSISTENT_UI;\n-        if (realCallingUid != callingUid) {\n-            // don't abort if the realCallingUid has a visible window\n-            // TODO(b/171459802): We should check appSwitchAllowed also\n+\n+        // Legacy behavior allows to use caller foreground state to bypass BAL restriction.\n+        final boolean balAllowedByPiSender =\n+                PendingIntentRecord.isPendingIntentBalAllowedByCaller(checkedOptions);\n+\n+        if (balAllowedByPiSender && realCallingUid != callingUid) {\n             if (realCallingUidHasAnyVisibleWindow) {\n                 if (DEBUG_ACTIVITY_STARTS) {\n                     Slog.d(TAG, \"Activity start allowed: realCallingUid (\" + realCallingUid\n@@ -1393,9 +1397,9 @@ class ActivityStarter {\n         // If we don't have callerApp at this point, no caller was provided to startActivity().\n         // That's the case for PendingIntent-based starts, since the creator's process might not be\n         // up and alive. If that's the case, we retrieve the WindowProcessController for the send()\n-        // caller, so that we can make the decision based on its state.\n+        // caller if caller allows, so that we can make the decision based on its state.\n         int callerAppUid = callingUid;\n-        if (callerApp == null) {\n+        if (callerApp == null && balAllowedByPiSender) {\n             callerApp = mService.getProcessController(realCallingPid, realCallingUid);\n             callerAppUid = realCallingUid;\n         }\n",
    "added_lines": 14,
    "deleted_lines": 10,
    "changed_methods": "ActivityStarter::shouldAbortBackgroundActivityStart, ActivityStarter::shouldAbortBackgroundActivityStart, ActivityStarter::executeRequest"
   },
   {
    "filename": "ActivityTaskManagerService.java",
    "diff": "@@ -2114,7 +2114,7 @@ public class ActivityTaskManagerService extends IActivityTaskManager.Stub {\n         final ActivityStarter starter = getActivityStartController().obtainStarter(\n                 null /* intent */, \"moveTaskToFront\");\n         if (starter.shouldAbortBackgroundActivityStart(callingUid, callingPid, callingPackage, -1,\n-                -1, callerApp, null, false, null)) {\n+                -1, callerApp, null, false, null, null)) {\n             if (!isBackgroundActivityStartsEnabled()) {\n                 return;\n             }\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "ActivityTaskManagerService::moveTaskToFrontLocked"
   },
   {
    "filename": "AppTaskImpl.java",
    "diff": "@@ -108,7 +108,7 @@ class AppTaskImpl extends IAppTask.Stub {\n                 final ActivityStarter starter = mService.getActivityStartController().obtainStarter(\n                         null /* intent */, \"moveToFront\");\n                 if (starter.shouldAbortBackgroundActivityStart(callingUid, callingPid,\n-                        callingPackage, -1, -1, callerApp, null, false, null)) {\n+                        callingPackage, -1, -1, callerApp, null, false, null, null)) {\n                     if (!mService.isBackgroundActivityStartsEnabled()) {\n                         return;\n                     }\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "AppTaskImpl::moveToFront"
   },
   {
    "filename": "AlarmManagerServiceTest.java",
    "diff": "@@ -109,6 +109,7 @@ import static org.mockito.Mockito.times;\n \n import android.app.ActivityManager;\n import android.app.ActivityManagerInternal;\n+import android.app.ActivityOptions;\n import android.app.AlarmManager;\n import android.app.AppOpsManager;\n import android.app.BroadcastOptions;\n@@ -552,13 +553,23 @@ public class AlarmManagerServiceTest {\n \n \n     private PendingIntent getNewMockPendingIntent() {\n-        return getNewMockPendingIntent(TEST_CALLING_UID, TEST_CALLING_PACKAGE);\n+        return getNewMockPendingIntent(false);\n+    }\n+\n+    private PendingIntent getNewMockPendingIntent(boolean isActivity) {\n+        return getNewMockPendingIntent(TEST_CALLING_UID, TEST_CALLING_PACKAGE, isActivity);\n     }\n \n     private PendingIntent getNewMockPendingIntent(int creatorUid, String creatorPackage) {\n+        return getNewMockPendingIntent(creatorUid, creatorPackage, false);\n+    }\n+\n+    private PendingIntent getNewMockPendingIntent(int creatorUid, String creatorPackage,\n+            boolean isActivity) {\n         final PendingIntent mockPi = mock(PendingIntent.class, Answers.RETURNS_DEEP_STUBS);\n         when(mockPi.getCreatorUid()).thenReturn(creatorUid);\n         when(mockPi.getCreatorPackage()).thenReturn(creatorPackage);\n+        when(mockPi.isActivity()).thenReturn(isActivity);\n         return mockPi;\n     }\n \n@@ -2801,21 +2812,53 @@ public class AlarmManagerServiceTest {\n                 anyString()));\n     }\n \n-    @Test\n-    public void idleOptionsSentOnExpiration() throws Exception {\n+    private void optionsSentOnExpiration(boolean isActivity, Bundle idleOptions)\n+            throws Exception {\n         final long triggerTime = mNowElapsedTest + 5000;\n-        final PendingIntent alarmPi = getNewMockPendingIntent();\n-        final Bundle idleOptions = new Bundle();\n-        idleOptions.putChar(\"TEST_CHAR_KEY\", 'x');\n-        idleOptions.putInt(\"TEST_INT_KEY\", 53);\n+        final PendingIntent alarmPi = getNewMockPendingIntent(isActivity);\n         setTestAlarm(ELAPSED_REALTIME_WAKEUP, triggerTime, 0, alarmPi, 0, 0, TEST_CALLING_UID,\n                 idleOptions);\n \n         mNowElapsedTest = mTestTimer.getElapsed();\n         mTestTimer.expire();\n \n+        ArgumentCaptor<Bundle> bundleCaptor = ArgumentCaptor.forClass(Bundle.class);\n         verify(alarmPi).send(eq(mMockContext), eq(0), any(Intent.class),\n-                any(), any(Handler.class), isNull(), eq(idleOptions));\n+                any(), any(Handler.class), isNull(), bundleCaptor.capture());\n+        if (idleOptions != null) {\n+            assertEquals(idleOptions, bundleCaptor.getValue());\n+        } else {\n+            assertFalse(\"BAL flag needs to be false in alarm manager\",\n+                    bundleCaptor.getValue().getBoolean(\n+                            ActivityOptions.KEY_PENDING_INTENT_BACKGROUND_ACTIVITY_ALLOWED,\n+                            true));\n+        }\n+    }\n+\n+    @Test\n+    public void activityIdleOptionsSentOnExpiration() throws Exception {\n+        final Bundle idleOptions = new Bundle();\n+        idleOptions.putChar(\"TEST_CHAR_KEY\", 'x');\n+        idleOptions.putInt(\"TEST_INT_KEY\", 53);\n+        optionsSentOnExpiration(true, idleOptions);\n+    }\n+\n+    @Test\n+    public void broadcastIdleOptionsSentOnExpiration() throws Exception {\n+        final Bundle idleOptions = new Bundle();\n+        idleOptions.putChar(\"TEST_CHAR_KEY\", 'x');\n+        idleOptions.putInt(\"TEST_INT_KEY\", 53);\n+        optionsSentOnExpiration(false, idleOptions);\n+    }\n+\n+    @Test\n+    public void emptyActivityOptionsSentOnExpiration() throws Exception {\n+        optionsSentOnExpiration(true, null);\n+    }\n+\n+    @Test\n+    public void emptyBroadcastOptionsSentOnExpiration() throws Exception {\n+        optionsSentOnExpiration(false, null);\n     }\n \n     @Test\n",
    "added_lines": 51,
    "deleted_lines": 8,
    "changed_methods": "AlarmManagerServiceTest::getNewMockPendingIntent, AlarmManagerServiceTest::activityIdleOptionsSentOnExpiration, AlarmManagerServiceTest::emptyActivityOptionsSentOnExpiration, AlarmManagerServiceTest::getNewMockPendingIntent, AlarmManagerServiceTest::emptyBroadcastOptionsSentOnExpiration, AlarmManagerServiceTest::idleOptionsSentOnExpiration, AlarmManagerServiceTest::broadcastIdleOptionsSentOnExpiration, AlarmManagerServiceTest::getNewMockPendingIntent, AlarmManagerServiceTest::getNewMockPendingIntent, AlarmManagerServiceTest::optionsSentOnExpiration"
   }
  ]
 },
 {
  "hash": "af52e36a81099ffc43e898f74f1e8f70ec1de2e3",
  "commit": "[DO NOT MERGE] Backport BAL restrictions from T to S, this blocks apps from using Alarm\nManager to bypass BAL restrictions.\n\nTest: atest-src BackgroundActivityLaunchTest\nBug: 195756028\nChange-Id: I33112ff59d913d8a7244289fe1a43512844e902a\n(cherry picked from commit 7a41e2fbc983ce0083b288e9489288de60dc8d8b)\nMerged-In: I33112ff59d913d8a7244289fe1a43512844e902a",
  "files": [
   {
    "filename": "AlarmManagerService.java",
    "diff": "@@ -56,6 +56,7 @@ import android.annotation.NonNull;\n import android.annotation.UserIdInt;\n import android.app.Activity;\n import android.app.ActivityManagerInternal;\n+import android.app.ActivityOptions;\n import android.app.AlarmManager;\n import android.app.AppOpsManager;\n import android.app.BroadcastOptions;\n@@ -317,6 +318,8 @@ public class AlarmManagerService extends SystemService {\n     private final SparseBooleanArray mPendingSendNextAlarmClockChangedForUser =\n             new SparseBooleanArray();\n     private boolean mNextAlarmClockMayChange;\n+    ActivityOptions mActivityOptsRestrictBal = ActivityOptions.makeBasic();\n+    BroadcastOptions mBroadcastOptsRestrictBal = BroadcastOptions.makeBasic();\n \n     @GuardedBy(\"mLock\")\n     private final Runnable mAlarmClockUpdater = () -> mNextAlarmClockMayChange = true;\n@@ -1611,6 +1614,11 @@ public class AlarmManagerService extends SystemService {\n     @Override\n     public void onStart() {\n         mInjector.init();\n+        mOptsWithFgs.setPendingIntentBackgroundActivityLaunchAllowed(false);\n+        mOptsWithoutFgs.setPendingIntentBackgroundActivityLaunchAllowed(false);\n+        mOptsTimeBroadcast.setPendingIntentBackgroundActivityLaunchAllowed(false);\n+        mActivityOptsRestrictBal.setPendingIntentBackgroundActivityLaunchAllowed(false);\n+        mBroadcastOptsRestrictBal.setPendingIntentBackgroundActivityLaunchAllowed(false);\n         mMetricsHelper = new MetricsHelper(getContext(), mLock);\n \n         mListenerDeathRecipient = new IBinder.DeathRecipient() {\n@@ -4306,6 +4314,14 @@ public class AlarmManagerService extends SystemService {\n         return alarm.creatorUid;\n     }\n \n+    private Bundle getAlarmOperationBundle(Alarm alarm) {\n+        if (alarm.mIdleOptions != null) {\n+            return alarm.mIdleOptions;\n+        } else if (alarm.operation.isActivity()) {\n+            return mActivityOptsRestrictBal.toBundle();\n+        }\n+        return mBroadcastOptsRestrictBal.toBundle();\n+    }\n \n     @VisibleForTesting\n     class AlarmHandler extends Handler {\n@@ -4344,7 +4360,11 @@ public class AlarmManagerService extends SystemService {\n                     for (int i = 0; i < triggerList.size(); i++) {\n                         Alarm alarm = triggerList.get(i);\n                         try {\n-                            alarm.operation.send();\n+                            // Disallow AlarmManager to start random background activity.\n+                            final Bundle bundle = getAlarmOperationBundle(alarm);\n+                            alarm.operation.send(/* context */ null, /* code */0, /* intent */\n+                                    null, /* onFinished */null, /* handler */\n+                                    null, /* requiredPermission */ null, bundle);\n                         } catch (PendingIntent.CanceledException e) {\n                             if (alarm.repeatInterval > 0) {\n                                 // This IntentSender is no longer valid, but this\n@@ -4908,9 +4928,10 @@ public class AlarmManagerService extends SystemService {\n                     mSendCount++;\n \n                     try {\n+                        final Bundle bundle = getAlarmOperationBundle(alarm);\n                         alarm.operation.send(getContext(), 0,\n                                 mBackgroundIntent.putExtra(Intent.EXTRA_ALARM_COUNT, alarm.count),\n-                                mDeliveryTracker, mHandler, null, alarm.mIdleOptions);\n+                                mDeliveryTracker, mHandler, null, bundle);\n                     } catch (PendingIntent.CanceledException e) {\n                         if (alarm.repeatInterval > 0) {\n                             // This IntentSender is no longer valid, but this\n",
    "added_lines": 23,
    "deleted_lines": 2,
    "changed_methods": "AlarmManagerService::getAlarmOperationBundle, AlarmManagerService::DeliveryTracker::deliverLocked, AlarmManagerService::onStart, AlarmManagerService::AlarmHandler::handleMessage"
   },
   {
    "filename": "ActivityOptions.java",
    "diff": "@@ -69,7 +69,7 @@ import java.util.ArrayList;\n  * {@link android.content.Context#startActivity(android.content.Intent, android.os.Bundle)\n  * Context.startActivity(Intent, Bundle)} and related methods.\n  */\n-public class ActivityOptions {\n+public class ActivityOptions extends ComponentOptions {\n     private static final String TAG = \"ActivityOptions\";\n \n     /**\n@@ -1081,13 +1081,12 @@ public class ActivityOptions {\n     }\n \n     private ActivityOptions() {\n+        super();\n     }\n \n     /** @hide */\n     public ActivityOptions(Bundle opts) {\n-        // If the remote side sent us bad parcelables, they won't get the\n-        // results they want, which is their loss.\n-        opts.setDefusable(true);\n+        super(opts);\n \n         mPackageName = opts.getString(KEY_PACKAGE_NAME);\n         try {\n@@ -1832,8 +1831,9 @@ public class ActivityOptions {\n      * object; you must not modify it, but can supply it to the startActivity\n      * methods that take an options Bundle.\n      */\n+    @Override\n     public Bundle toBundle() {\n-        Bundle b = new Bundle();\n+        Bundle b = super.toBundle();\n         if (mPackageName != null) {\n             b.putString(KEY_PACKAGE_NAME, mPackageName);\n         }\n",
    "added_lines": 5,
    "deleted_lines": 5,
    "changed_methods": "ActivityOptions::ActivityOptions, ActivityOptions::ActivityOptions, ActivityOptions::toBundle"
   },
   {
    "filename": "BroadcastOptions.java",
    "diff": "@@ -34,7 +34,7 @@ import android.os.PowerExemptionManager.TempAllowListType;\n  * {@hide}\n  */\n @SystemApi\n-public class BroadcastOptions {\n+public class BroadcastOptions extends ComponentOptions {\n     private long mTemporaryAppAllowlistDuration;\n     private @TempAllowListType int mTemporaryAppAllowlistType;\n     private @ReasonCode int mTemporaryAppAllowlistReasonCode;\n@@ -108,12 +108,14 @@ public class BroadcastOptions {\n     }\n \n     private BroadcastOptions() {\n+        super();\n         resetTemporaryAppAllowlist();\n     }\n \n     /** @hide */\n     @TestApi\n     public BroadcastOptions(@NonNull Bundle opts) {\n+        super(opts);\n         // Match the logic in toBundle().\n         if (opts.containsKey(KEY_TEMPORARY_APP_ALLOWLIST_DURATION)) {\n             mTemporaryAppAllowlistDuration = opts.getLong(KEY_TEMPORARY_APP_ALLOWLIST_DURATION);\n@@ -190,6 +192,24 @@ public class BroadcastOptions {\n         mTemporaryAppAllowlistReason = null;\n     }\n \n+    /**\n+     * Set PendingIntent activity is allowed to be started in the background if the caller\n+     * can start background activities.\n+     * @hide\n+     */\n+    public void setPendingIntentBackgroundActivityLaunchAllowed(boolean allowed) {\n+        super.setPendingIntentBackgroundActivityLaunchAllowed(allowed);\n+    }\n+\n+    /**\n+     * Get PendingIntent activity is allowed to be started in the background if the caller\n+     * can start background activities.\n+     * @hide\n+     */\n+    public boolean isPendingIntentBackgroundActivityLaunchAllowed() {\n+        return super.isPendingIntentBackgroundActivityLaunchAllowed();\n+    }\n+\n     /**\n      * Return {@link #setTemporaryAppAllowlist}.\n      * @hide\n@@ -308,8 +328,9 @@ public class BroadcastOptions {\n      * object; you must not modify it, but can supply it to the sendBroadcast\n      * methods that take an options Bundle.\n      */\n+    @Override\n     public Bundle toBundle() {\n-        Bundle b = new Bundle();\n+        Bundle b = super.toBundle();\n         if (isTemporaryAppAllowlistSet()) {\n             b.putLong(KEY_TEMPORARY_APP_ALLOWLIST_DURATION, mTemporaryAppAllowlistDuration);\n             b.putInt(KEY_TEMPORARY_APP_ALLOWLIST_TYPE, mTemporaryAppAllowlistType);\n",
    "added_lines": 23,
    "deleted_lines": 2,
    "changed_methods": "BroadcastOptions::toBundle, BroadcastOptions::BroadcastOptions, BroadcastOptions::setPendingIntentBackgroundActivityLaunchAllowed, BroadcastOptions::isPendingIntentBackgroundActivityLaunchAllowed, BroadcastOptions::BroadcastOptions"
   },
   {
    "filename": "ComponentOptions.java",
    "diff": "@@ -0,0 +1,83 @@\n+/*\n+ * Copyright (C) 2021 The Android Open Source Project\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package android.app;\n+\n+import android.os.Bundle;\n+\n+/**\n+ * @hide\n+ */\n+public class ComponentOptions {\n+\n+    /**\n+     * Default value for KEY_PENDING_INTENT_BACKGROUND_ACTIVITY_ALLOWED.\n+     * @hide\n+     **/\n+    public static final boolean PENDING_INTENT_BAL_ALLOWED_DEFAULT = true;\n+\n+    /**\n+     * PendingIntent caller allows activity start even if PendingIntent creator is in background.\n+     * This only works if the PendingIntent caller is allowed to start background activities,\n+     * for example if it's in the foreground, or has BAL permission.\n+     * @hide\n+     */\n+    public static final String KEY_PENDING_INTENT_BACKGROUND_ACTIVITY_ALLOWED =\n+            \"android.pendingIntent.backgroundActivityAllowed\";\n+\n+    private boolean mPendingIntentBalAllowed = PENDING_INTENT_BAL_ALLOWED_DEFAULT;\n+\n+    ComponentOptions() {\n+    }\n+\n+    ComponentOptions(Bundle opts) {\n+        // If the remote side sent us bad parcelables, they won't get the\n+        // results they want, which is their loss.\n+        opts.setDefusable(true);\n+        setPendingIntentBackgroundActivityLaunchAllowed(\n+                opts.getBoolean(KEY_PENDING_INTENT_BACKGROUND_ACTIVITY_ALLOWED,\n+                        PENDING_INTENT_BAL_ALLOWED_DEFAULT));\n+    }\n+\n+    /**\n+     * Set PendingIntent activity is allowed to be started in the background if the caller\n+     * can start background activities.\n+     *\n+     * @hide\n+     */\n+    public void setPendingIntentBackgroundActivityLaunchAllowed(boolean allowed) {\n+        mPendingIntentBalAllowed = allowed;\n+    }\n+\n+    /**\n+     * Get PendingIntent activity is allowed to be started in the background if the caller\n+     * can start background activities.\n+     *\n+     * @hide\n+     */\n+    public boolean isPendingIntentBackgroundActivityLaunchAllowed() {\n+        return mPendingIntentBalAllowed;\n+    }\n+\n+    /**\n+     * @hide\n+     */\n+    public Bundle toBundle() {\n+        Bundle bundle = new Bundle();\n+        bundle.putBoolean(KEY_PENDING_INTENT_BACKGROUND_ACTIVITY_ALLOWED, mPendingIntentBalAllowed);\n+        return bundle;\n+    }\n+}\n",
    "added_lines": 83,
    "deleted_lines": 0,
    "changed_methods": "ComponentOptions::toBundle, ComponentOptions::ComponentOptions, ComponentOptions::ComponentOptions, ComponentOptions::isPendingIntentBackgroundActivityLaunchAllowed, ComponentOptions::setPendingIntentBackgroundActivityLaunchAllowed"
   },
   {
    "filename": "PendingIntentRecord.java",
    "diff": "@@ -310,6 +310,25 @@ public final class PendingIntentRecord extends IIntentSender.Stub {\n                 requiredPermission, null, null, 0, 0, 0, options);\n     }\n \n+    /**\n+     * Return true if the activity options allows PendingIntent to use caller's BAL permission.\n+     */\n+    public static boolean isPendingIntentBalAllowedByCaller(\n+            @Nullable ActivityOptions activityOptions) {\n+        if (activityOptions == null) {\n+            return ActivityOptions.PENDING_INTENT_BAL_ALLOWED_DEFAULT;\n+        }\n+        return isPendingIntentBalAllowedByCaller(activityOptions.toBundle());\n+    }\n+\n+    private static boolean isPendingIntentBalAllowedByCaller(@Nullable Bundle options) {\n+        if (options == null) {\n+            return ActivityOptions.PENDING_INTENT_BAL_ALLOWED_DEFAULT;\n+        }\n+        return options.getBoolean(ActivityOptions.KEY_PENDING_INTENT_BACKGROUND_ACTIVITY_ALLOWED,\n+                ActivityOptions.PENDING_INTENT_BAL_ALLOWED_DEFAULT);\n+    }\n+\n     public int sendInner(int code, Intent intent, String resolvedType, IBinder allowlistToken,\n             IIntentReceiver finishedReceiver, String requiredPermission, IBinder resultTo,\n             String resultWho, int requestCode, int flagsMask, int flagsValues, Bundle options) {\n@@ -431,7 +450,8 @@ public final class PendingIntentRecord extends IIntentSender.Stub {\n             // temporarily allow receivers and services to open activities from background if the\n             // PendingIntent.send() caller was foreground at the time of sendInner() call\n             final boolean allowTrampoline = uid != callingUid\n-                    && controller.mAtmInternal.isUidForeground(callingUid);\n+                    && controller.mAtmInternal.isUidForeground(callingUid)\n+                    && isPendingIntentBalAllowedByCaller(options);\n \n             // note: we on purpose don't pass in the information about the PendingIntent's creator,\n             // like pid or ProcessRecord, to the ActivityTaskManagerInternal calls below, because\n",
    "added_lines": 21,
    "deleted_lines": 1,
    "changed_methods": "PendingIntentRecord::isPendingIntentBalAllowedByCaller, PendingIntentRecord::sendInner, PendingIntentRecord::isPendingIntentBalAllowedByCaller"
   },
   {
    "filename": "ActivityStarter.java",
    "diff": "@@ -989,6 +989,10 @@ class ActivityStarter {\n         abort |= !mService.getPermissionPolicyInternal().checkStartActivity(intent, callingUid,\n                 callingPackage);\n \n+        // Merge the two options bundles, while realCallerOptions takes precedence.\n+        ActivityOptions checkedOptions = options != null\n+                ? options.getOptions(intent, aInfo, callerApp, mSupervisor) : null;\n+\n         boolean restrictedBgActivity = false;\n         if (!abort) {\n             try {\n@@ -997,15 +1001,12 @@ class ActivityStarter {\n                 restrictedBgActivity = shouldAbortBackgroundActivityStart(callingUid,\n                         callingPid, callingPackage, realCallingUid, realCallingPid, callerApp,\n                         request.originatingPendingIntent, request.allowBackgroundActivityStart,\n-                        intent);\n+                        intent, checkedOptions);\n             } finally {\n                 Trace.traceEnd(Trace.TRACE_TAG_WINDOW_MANAGER);\n             }\n         }\n \n-        // Merge the two options bundles, while realCallerOptions takes precedence.\n-        ActivityOptions checkedOptions = options != null\n-                ? options.getOptions(intent, aInfo, callerApp, mSupervisor) : null;\n         if (request.allowPendingRemoteAnimationRegistryLookup) {\n             checkedOptions = mService.getActivityStartController()\n                     .getPendingRemoteAnimationRegistry()\n@@ -1247,7 +1248,7 @@ class ActivityStarter {\n     boolean shouldAbortBackgroundActivityStart(int callingUid, int callingPid,\n             final String callingPackage, int realCallingUid, int realCallingPid,\n             WindowProcessController callerApp, PendingIntentRecord originatingPendingIntent,\n-            boolean allowBackgroundActivityStart, Intent intent) {\n+            boolean allowBackgroundActivityStart, Intent intent, ActivityOptions checkedOptions) {\n         // don't abort for the most important UIDs\n         final int callingAppId = UserHandle.getAppId(callingUid);\n         if (callingUid == Process.ROOT_UID || callingAppId == Process.SYSTEM_UID\n@@ -1318,9 +1319,12 @@ class ActivityStarter {\n                 ? isCallingUidPersistentSystemProcess\n                 : (realCallingAppId == Process.SYSTEM_UID)\n                         || realCallingUidProcState <= ActivityManager.PROCESS_STATE_PERSISTENT_UI;\n-        if (realCallingUid != callingUid) {\n-            // don't abort if the realCallingUid has a visible window\n-            // TODO(b/171459802): We should check appSwitchAllowed also\n+\n+        // Legacy behavior allows to use caller foreground state to bypass BAL restriction.\n+        final boolean balAllowedByPiSender =\n+                PendingIntentRecord.isPendingIntentBalAllowedByCaller(checkedOptions);\n+\n+        if (balAllowedByPiSender && realCallingUid != callingUid) {\n             if (realCallingUidHasAnyVisibleWindow) {\n                 if (DEBUG_ACTIVITY_STARTS) {\n                     Slog.d(TAG, \"Activity start allowed: realCallingUid (\" + realCallingUid\n@@ -1393,9 +1397,9 @@ class ActivityStarter {\n         // If we don't have callerApp at this point, no caller was provided to startActivity().\n         // That's the case for PendingIntent-based starts, since the creator's process might not be\n         // up and alive. If that's the case, we retrieve the WindowProcessController for the send()\n-        // caller, so that we can make the decision based on its state.\n+        // caller if caller allows, so that we can make the decision based on its state.\n         int callerAppUid = callingUid;\n-        if (callerApp == null) {\n+        if (callerApp == null && balAllowedByPiSender) {\n             callerApp = mService.getProcessController(realCallingPid, realCallingUid);\n             callerAppUid = realCallingUid;\n         }\n",
    "added_lines": 14,
    "deleted_lines": 10,
    "changed_methods": "ActivityStarter::shouldAbortBackgroundActivityStart, ActivityStarter::shouldAbortBackgroundActivityStart, ActivityStarter::executeRequest"
   },
   {
    "filename": "ActivityTaskManagerService.java",
    "diff": "@@ -2114,7 +2114,7 @@ public class ActivityTaskManagerService extends IActivityTaskManager.Stub {\n         final ActivityStarter starter = getActivityStartController().obtainStarter(\n                 null /* intent */, \"moveTaskToFront\");\n         if (starter.shouldAbortBackgroundActivityStart(callingUid, callingPid, callingPackage, -1,\n-                -1, callerApp, null, false, null)) {\n+                -1, callerApp, null, false, null, null)) {\n             if (!isBackgroundActivityStartsEnabled()) {\n                 return;\n             }\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "ActivityTaskManagerService::moveTaskToFrontLocked"
   },
   {
    "filename": "AppTaskImpl.java",
    "diff": "@@ -108,7 +108,7 @@ class AppTaskImpl extends IAppTask.Stub {\n                 final ActivityStarter starter = mService.getActivityStartController().obtainStarter(\n                         null /* intent */, \"moveToFront\");\n                 if (starter.shouldAbortBackgroundActivityStart(callingUid, callingPid,\n-                        callingPackage, -1, -1, callerApp, null, false, null)) {\n+                        callingPackage, -1, -1, callerApp, null, false, null, null)) {\n                     if (!mService.isBackgroundActivityStartsEnabled()) {\n                         return;\n                     }\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "AppTaskImpl::moveToFront"
   },
   {
    "filename": "AlarmManagerServiceTest.java",
    "diff": "@@ -109,6 +109,7 @@ import static org.mockito.Mockito.times;\n \n import android.app.ActivityManager;\n import android.app.ActivityManagerInternal;\n+import android.app.ActivityOptions;\n import android.app.AlarmManager;\n import android.app.AppOpsManager;\n import android.app.BroadcastOptions;\n@@ -552,13 +553,23 @@ public class AlarmManagerServiceTest {\n \n \n     private PendingIntent getNewMockPendingIntent() {\n-        return getNewMockPendingIntent(TEST_CALLING_UID, TEST_CALLING_PACKAGE);\n+        return getNewMockPendingIntent(false);\n+    }\n+\n+    private PendingIntent getNewMockPendingIntent(boolean isActivity) {\n+        return getNewMockPendingIntent(TEST_CALLING_UID, TEST_CALLING_PACKAGE, isActivity);\n     }\n \n     private PendingIntent getNewMockPendingIntent(int creatorUid, String creatorPackage) {\n+        return getNewMockPendingIntent(creatorUid, creatorPackage, false);\n+    }\n+\n+    private PendingIntent getNewMockPendingIntent(int creatorUid, String creatorPackage,\n+            boolean isActivity) {\n         final PendingIntent mockPi = mock(PendingIntent.class, Answers.RETURNS_DEEP_STUBS);\n         when(mockPi.getCreatorUid()).thenReturn(creatorUid);\n         when(mockPi.getCreatorPackage()).thenReturn(creatorPackage);\n+        when(mockPi.isActivity()).thenReturn(isActivity);\n         return mockPi;\n     }\n \n@@ -2801,21 +2812,53 @@ public class AlarmManagerServiceTest {\n                 anyString()));\n     }\n \n-    @Test\n-    public void idleOptionsSentOnExpiration() throws Exception {\n+    private void optionsSentOnExpiration(boolean isActivity, Bundle idleOptions)\n+            throws Exception {\n         final long triggerTime = mNowElapsedTest + 5000;\n-        final PendingIntent alarmPi = getNewMockPendingIntent();\n-        final Bundle idleOptions = new Bundle();\n-        idleOptions.putChar(\"TEST_CHAR_KEY\", 'x');\n-        idleOptions.putInt(\"TEST_INT_KEY\", 53);\n+        final PendingIntent alarmPi = getNewMockPendingIntent(isActivity);\n         setTestAlarm(ELAPSED_REALTIME_WAKEUP, triggerTime, 0, alarmPi, 0, 0, TEST_CALLING_UID,\n                 idleOptions);\n \n         mNowElapsedTest = mTestTimer.getElapsed();\n         mTestTimer.expire();\n \n+        ArgumentCaptor<Bundle> bundleCaptor = ArgumentCaptor.forClass(Bundle.class);\n         verify(alarmPi).send(eq(mMockContext), eq(0), any(Intent.class),\n-                any(), any(Handler.class), isNull(), eq(idleOptions));\n+                any(), any(Handler.class), isNull(), bundleCaptor.capture());\n+        if (idleOptions != null) {\n+            assertEquals(idleOptions, bundleCaptor.getValue());\n+        } else {\n+            assertFalse(\"BAL flag needs to be false in alarm manager\",\n+                    bundleCaptor.getValue().getBoolean(\n+                            ActivityOptions.KEY_PENDING_INTENT_BACKGROUND_ACTIVITY_ALLOWED,\n+                            true));\n+        }\n+    }\n+\n+    @Test\n+    public void activityIdleOptionsSentOnExpiration() throws Exception {\n+        final Bundle idleOptions = new Bundle();\n+        idleOptions.putChar(\"TEST_CHAR_KEY\", 'x');\n+        idleOptions.putInt(\"TEST_INT_KEY\", 53);\n+        optionsSentOnExpiration(true, idleOptions);\n+    }\n+\n+    @Test\n+    public void broadcastIdleOptionsSentOnExpiration() throws Exception {\n+        final Bundle idleOptions = new Bundle();\n+        idleOptions.putChar(\"TEST_CHAR_KEY\", 'x');\n+        idleOptions.putInt(\"TEST_INT_KEY\", 53);\n+        optionsSentOnExpiration(false, idleOptions);\n+    }\n+\n+    @Test\n+    public void emptyActivityOptionsSentOnExpiration() throws Exception {\n+        optionsSentOnExpiration(true, null);\n+    }\n+\n+    @Test\n+    public void emptyBroadcastOptionsSentOnExpiration() throws Exception {\n+        optionsSentOnExpiration(false, null);\n     }\n \n     @Test\n",
    "added_lines": 51,
    "deleted_lines": 8,
    "changed_methods": "AlarmManagerServiceTest::getNewMockPendingIntent, AlarmManagerServiceTest::activityIdleOptionsSentOnExpiration, AlarmManagerServiceTest::emptyActivityOptionsSentOnExpiration, AlarmManagerServiceTest::getNewMockPendingIntent, AlarmManagerServiceTest::emptyBroadcastOptionsSentOnExpiration, AlarmManagerServiceTest::idleOptionsSentOnExpiration, AlarmManagerServiceTest::broadcastIdleOptionsSentOnExpiration, AlarmManagerServiceTest::getNewMockPendingIntent, AlarmManagerServiceTest::getNewMockPendingIntent, AlarmManagerServiceTest::optionsSentOnExpiration"
   }
  ]
 },
 {
  "hash": "af52e36a81099ffc43e898f74f1e8f70ec1de2e3",
  "commit": "[DO NOT MERGE] Backport BAL restrictions from T to S, this blocks apps from using Alarm\nManager to bypass BAL restrictions.\n\nTest: atest-src BackgroundActivityLaunchTest\nBug: 195756028\nChange-Id: I33112ff59d913d8a7244289fe1a43512844e902a\n(cherry picked from commit 7a41e2fbc983ce0083b288e9489288de60dc8d8b)\nMerged-In: I33112ff59d913d8a7244289fe1a43512844e902a",
  "files": [
   {
    "filename": "AlarmManagerService.java",
    "diff": "@@ -56,6 +56,7 @@ import android.annotation.NonNull;\n import android.annotation.UserIdInt;\n import android.app.Activity;\n import android.app.ActivityManagerInternal;\n+import android.app.ActivityOptions;\n import android.app.AlarmManager;\n import android.app.AppOpsManager;\n import android.app.BroadcastOptions;\n@@ -317,6 +318,8 @@ public class AlarmManagerService extends SystemService {\n     private final SparseBooleanArray mPendingSendNextAlarmClockChangedForUser =\n             new SparseBooleanArray();\n     private boolean mNextAlarmClockMayChange;\n+    ActivityOptions mActivityOptsRestrictBal = ActivityOptions.makeBasic();\n+    BroadcastOptions mBroadcastOptsRestrictBal = BroadcastOptions.makeBasic();\n \n     @GuardedBy(\"mLock\")\n     private final Runnable mAlarmClockUpdater = () -> mNextAlarmClockMayChange = true;\n@@ -1611,6 +1614,11 @@ public class AlarmManagerService extends SystemService {\n     @Override\n     public void onStart() {\n         mInjector.init();\n+        mOptsWithFgs.setPendingIntentBackgroundActivityLaunchAllowed(false);\n+        mOptsWithoutFgs.setPendingIntentBackgroundActivityLaunchAllowed(false);\n+        mOptsTimeBroadcast.setPendingIntentBackgroundActivityLaunchAllowed(false);\n+        mActivityOptsRestrictBal.setPendingIntentBackgroundActivityLaunchAllowed(false);\n+        mBroadcastOptsRestrictBal.setPendingIntentBackgroundActivityLaunchAllowed(false);\n         mMetricsHelper = new MetricsHelper(getContext(), mLock);\n \n         mListenerDeathRecipient = new IBinder.DeathRecipient() {\n@@ -4306,6 +4314,14 @@ public class AlarmManagerService extends SystemService {\n         return alarm.creatorUid;\n     }\n \n+    private Bundle getAlarmOperationBundle(Alarm alarm) {\n+        if (alarm.mIdleOptions != null) {\n+            return alarm.mIdleOptions;\n+        } else if (alarm.operation.isActivity()) {\n+            return mActivityOptsRestrictBal.toBundle();\n+        }\n+        return mBroadcastOptsRestrictBal.toBundle();\n+    }\n \n     @VisibleForTesting\n     class AlarmHandler extends Handler {\n@@ -4344,7 +4360,11 @@ public class AlarmManagerService extends SystemService {\n                     for (int i = 0; i < triggerList.size(); i++) {\n                         Alarm alarm = triggerList.get(i);\n                         try {\n-                            alarm.operation.send();\n+                            // Disallow AlarmManager to start random background activity.\n+                            final Bundle bundle = getAlarmOperationBundle(alarm);\n+                            alarm.operation.send(/* context */ null, /* code */0, /* intent */\n+                                    null, /* onFinished */null, /* handler */\n+                                    null, /* requiredPermission */ null, bundle);\n                         } catch (PendingIntent.CanceledException e) {\n                             if (alarm.repeatInterval > 0) {\n                                 // This IntentSender is no longer valid, but this\n@@ -4908,9 +4928,10 @@ public class AlarmManagerService extends SystemService {\n                     mSendCount++;\n \n                     try {\n+                        final Bundle bundle = getAlarmOperationBundle(alarm);\n                         alarm.operation.send(getContext(), 0,\n                                 mBackgroundIntent.putExtra(Intent.EXTRA_ALARM_COUNT, alarm.count),\n-                                mDeliveryTracker, mHandler, null, alarm.mIdleOptions);\n+                                mDeliveryTracker, mHandler, null, bundle);\n                     } catch (PendingIntent.CanceledException e) {\n                         if (alarm.repeatInterval > 0) {\n                             // This IntentSender is no longer valid, but this\n",
    "added_lines": 23,
    "deleted_lines": 2,
    "changed_methods": "AlarmManagerService::getAlarmOperationBundle, AlarmManagerService::DeliveryTracker::deliverLocked, AlarmManagerService::onStart, AlarmManagerService::AlarmHandler::handleMessage"
   },
   {
    "filename": "ActivityOptions.java",
    "diff": "@@ -69,7 +69,7 @@ import java.util.ArrayList;\n  * {@link android.content.Context#startActivity(android.content.Intent, android.os.Bundle)\n  * Context.startActivity(Intent, Bundle)} and related methods.\n  */\n-public class ActivityOptions {\n+public class ActivityOptions extends ComponentOptions {\n     private static final String TAG = \"ActivityOptions\";\n \n     /**\n@@ -1081,13 +1081,12 @@ public class ActivityOptions {\n     }\n \n     private ActivityOptions() {\n+        super();\n     }\n \n     /** @hide */\n     public ActivityOptions(Bundle opts) {\n-        // If the remote side sent us bad parcelables, they won't get the\n-        // results they want, which is their loss.\n-        opts.setDefusable(true);\n+        super(opts);\n \n         mPackageName = opts.getString(KEY_PACKAGE_NAME);\n         try {\n@@ -1832,8 +1831,9 @@ public class ActivityOptions {\n      * object; you must not modify it, but can supply it to the startActivity\n      * methods that take an options Bundle.\n      */\n+    @Override\n     public Bundle toBundle() {\n-        Bundle b = new Bundle();\n+        Bundle b = super.toBundle();\n         if (mPackageName != null) {\n             b.putString(KEY_PACKAGE_NAME, mPackageName);\n         }\n",
    "added_lines": 5,
    "deleted_lines": 5,
    "changed_methods": "ActivityOptions::ActivityOptions, ActivityOptions::ActivityOptions, ActivityOptions::toBundle"
   },
   {
    "filename": "BroadcastOptions.java",
    "diff": "@@ -34,7 +34,7 @@ import android.os.PowerExemptionManager.TempAllowListType;\n  * {@hide}\n  */\n @SystemApi\n-public class BroadcastOptions {\n+public class BroadcastOptions extends ComponentOptions {\n     private long mTemporaryAppAllowlistDuration;\n     private @TempAllowListType int mTemporaryAppAllowlistType;\n     private @ReasonCode int mTemporaryAppAllowlistReasonCode;\n@@ -108,12 +108,14 @@ public class BroadcastOptions {\n     }\n \n     private BroadcastOptions() {\n+        super();\n         resetTemporaryAppAllowlist();\n     }\n \n     /** @hide */\n     @TestApi\n     public BroadcastOptions(@NonNull Bundle opts) {\n+        super(opts);\n         // Match the logic in toBundle().\n         if (opts.containsKey(KEY_TEMPORARY_APP_ALLOWLIST_DURATION)) {\n             mTemporaryAppAllowlistDuration = opts.getLong(KEY_TEMPORARY_APP_ALLOWLIST_DURATION);\n@@ -190,6 +192,24 @@ public class BroadcastOptions {\n         mTemporaryAppAllowlistReason = null;\n     }\n \n+    /**\n+     * Set PendingIntent activity is allowed to be started in the background if the caller\n+     * can start background activities.\n+     * @hide\n+     */\n+    public void setPendingIntentBackgroundActivityLaunchAllowed(boolean allowed) {\n+        super.setPendingIntentBackgroundActivityLaunchAllowed(allowed);\n+    }\n+\n+    /**\n+     * Get PendingIntent activity is allowed to be started in the background if the caller\n+     * can start background activities.\n+     * @hide\n+     */\n+    public boolean isPendingIntentBackgroundActivityLaunchAllowed() {\n+        return super.isPendingIntentBackgroundActivityLaunchAllowed();\n+    }\n+\n     /**\n      * Return {@link #setTemporaryAppAllowlist}.\n      * @hide\n@@ -308,8 +328,9 @@ public class BroadcastOptions {\n      * object; you must not modify it, but can supply it to the sendBroadcast\n      * methods that take an options Bundle.\n      */\n+    @Override\n     public Bundle toBundle() {\n-        Bundle b = new Bundle();\n+        Bundle b = super.toBundle();\n         if (isTemporaryAppAllowlistSet()) {\n             b.putLong(KEY_TEMPORARY_APP_ALLOWLIST_DURATION, mTemporaryAppAllowlistDuration);\n             b.putInt(KEY_TEMPORARY_APP_ALLOWLIST_TYPE, mTemporaryAppAllowlistType);\n",
    "added_lines": 23,
    "deleted_lines": 2,
    "changed_methods": "BroadcastOptions::toBundle, BroadcastOptions::BroadcastOptions, BroadcastOptions::setPendingIntentBackgroundActivityLaunchAllowed, BroadcastOptions::isPendingIntentBackgroundActivityLaunchAllowed, BroadcastOptions::BroadcastOptions"
   },
   {
    "filename": "ComponentOptions.java",
    "diff": "@@ -0,0 +1,83 @@\n+/*\n+ * Copyright (C) 2021 The Android Open Source Project\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package android.app;\n+\n+import android.os.Bundle;\n+\n+/**\n+ * @hide\n+ */\n+public class ComponentOptions {\n+\n+    /**\n+     * Default value for KEY_PENDING_INTENT_BACKGROUND_ACTIVITY_ALLOWED.\n+     * @hide\n+     **/\n+    public static final boolean PENDING_INTENT_BAL_ALLOWED_DEFAULT = true;\n+\n+    /**\n+     * PendingIntent caller allows activity start even if PendingIntent creator is in background.\n+     * This only works if the PendingIntent caller is allowed to start background activities,\n+     * for example if it's in the foreground, or has BAL permission.\n+     * @hide\n+     */\n+    public static final String KEY_PENDING_INTENT_BACKGROUND_ACTIVITY_ALLOWED =\n+            \"android.pendingIntent.backgroundActivityAllowed\";\n+\n+    private boolean mPendingIntentBalAllowed = PENDING_INTENT_BAL_ALLOWED_DEFAULT;\n+\n+    ComponentOptions() {\n+    }\n+\n+    ComponentOptions(Bundle opts) {\n+        // If the remote side sent us bad parcelables, they won't get the\n+        // results they want, which is their loss.\n+        opts.setDefusable(true);\n+        setPendingIntentBackgroundActivityLaunchAllowed(\n+                opts.getBoolean(KEY_PENDING_INTENT_BACKGROUND_ACTIVITY_ALLOWED,\n+                        PENDING_INTENT_BAL_ALLOWED_DEFAULT));\n+    }\n+\n+    /**\n+     * Set PendingIntent activity is allowed to be started in the background if the caller\n+     * can start background activities.\n+     *\n+     * @hide\n+     */\n+    public void setPendingIntentBackgroundActivityLaunchAllowed(boolean allowed) {\n+        mPendingIntentBalAllowed = allowed;\n+    }\n+\n+    /**\n+     * Get PendingIntent activity is allowed to be started in the background if the caller\n+     * can start background activities.\n+     *\n+     * @hide\n+     */\n+    public boolean isPendingIntentBackgroundActivityLaunchAllowed() {\n+        return mPendingIntentBalAllowed;\n+    }\n+\n+    /**\n+     * @hide\n+     */\n+    public Bundle toBundle() {\n+        Bundle bundle = new Bundle();\n+        bundle.putBoolean(KEY_PENDING_INTENT_BACKGROUND_ACTIVITY_ALLOWED, mPendingIntentBalAllowed);\n+        return bundle;\n+    }\n+}\n",
    "added_lines": 83,
    "deleted_lines": 0,
    "changed_methods": "ComponentOptions::toBundle, ComponentOptions::ComponentOptions, ComponentOptions::ComponentOptions, ComponentOptions::isPendingIntentBackgroundActivityLaunchAllowed, ComponentOptions::setPendingIntentBackgroundActivityLaunchAllowed"
   },
   {
    "filename": "PendingIntentRecord.java",
    "diff": "@@ -310,6 +310,25 @@ public final class PendingIntentRecord extends IIntentSender.Stub {\n                 requiredPermission, null, null, 0, 0, 0, options);\n     }\n \n+    /**\n+     * Return true if the activity options allows PendingIntent to use caller's BAL permission.\n+     */\n+    public static boolean isPendingIntentBalAllowedByCaller(\n+            @Nullable ActivityOptions activityOptions) {\n+        if (activityOptions == null) {\n+            return ActivityOptions.PENDING_INTENT_BAL_ALLOWED_DEFAULT;\n+        }\n+        return isPendingIntentBalAllowedByCaller(activityOptions.toBundle());\n+    }\n+\n+    private static boolean isPendingIntentBalAllowedByCaller(@Nullable Bundle options) {\n+        if (options == null) {\n+            return ActivityOptions.PENDING_INTENT_BAL_ALLOWED_DEFAULT;\n+        }\n+        return options.getBoolean(ActivityOptions.KEY_PENDING_INTENT_BACKGROUND_ACTIVITY_ALLOWED,\n+                ActivityOptions.PENDING_INTENT_BAL_ALLOWED_DEFAULT);\n+    }\n+\n     public int sendInner(int code, Intent intent, String resolvedType, IBinder allowlistToken,\n             IIntentReceiver finishedReceiver, String requiredPermission, IBinder resultTo,\n             String resultWho, int requestCode, int flagsMask, int flagsValues, Bundle options) {\n@@ -431,7 +450,8 @@ public final class PendingIntentRecord extends IIntentSender.Stub {\n             // temporarily allow receivers and services to open activities from background if the\n             // PendingIntent.send() caller was foreground at the time of sendInner() call\n             final boolean allowTrampoline = uid != callingUid\n-                    && controller.mAtmInternal.isUidForeground(callingUid);\n+                    && controller.mAtmInternal.isUidForeground(callingUid)\n+                    && isPendingIntentBalAllowedByCaller(options);\n \n             // note: we on purpose don't pass in the information about the PendingIntent's creator,\n             // like pid or ProcessRecord, to the ActivityTaskManagerInternal calls below, because\n",
    "added_lines": 21,
    "deleted_lines": 1,
    "changed_methods": "PendingIntentRecord::isPendingIntentBalAllowedByCaller, PendingIntentRecord::sendInner, PendingIntentRecord::isPendingIntentBalAllowedByCaller"
   },
   {
    "filename": "ActivityStarter.java",
    "diff": "@@ -989,6 +989,10 @@ class ActivityStarter {\n         abort |= !mService.getPermissionPolicyInternal().checkStartActivity(intent, callingUid,\n                 callingPackage);\n \n+        // Merge the two options bundles, while realCallerOptions takes precedence.\n+        ActivityOptions checkedOptions = options != null\n+                ? options.getOptions(intent, aInfo, callerApp, mSupervisor) : null;\n+\n         boolean restrictedBgActivity = false;\n         if (!abort) {\n             try {\n@@ -997,15 +1001,12 @@ class ActivityStarter {\n                 restrictedBgActivity = shouldAbortBackgroundActivityStart(callingUid,\n                         callingPid, callingPackage, realCallingUid, realCallingPid, callerApp,\n                         request.originatingPendingIntent, request.allowBackgroundActivityStart,\n-                        intent);\n+                        intent, checkedOptions);\n             } finally {\n                 Trace.traceEnd(Trace.TRACE_TAG_WINDOW_MANAGER);\n             }\n         }\n \n-        // Merge the two options bundles, while realCallerOptions takes precedence.\n-        ActivityOptions checkedOptions = options != null\n-                ? options.getOptions(intent, aInfo, callerApp, mSupervisor) : null;\n         if (request.allowPendingRemoteAnimationRegistryLookup) {\n             checkedOptions = mService.getActivityStartController()\n                     .getPendingRemoteAnimationRegistry()\n@@ -1247,7 +1248,7 @@ class ActivityStarter {\n     boolean shouldAbortBackgroundActivityStart(int callingUid, int callingPid,\n             final String callingPackage, int realCallingUid, int realCallingPid,\n             WindowProcessController callerApp, PendingIntentRecord originatingPendingIntent,\n-            boolean allowBackgroundActivityStart, Intent intent) {\n+            boolean allowBackgroundActivityStart, Intent intent, ActivityOptions checkedOptions) {\n         // don't abort for the most important UIDs\n         final int callingAppId = UserHandle.getAppId(callingUid);\n         if (callingUid == Process.ROOT_UID || callingAppId == Process.SYSTEM_UID\n@@ -1318,9 +1319,12 @@ class ActivityStarter {\n                 ? isCallingUidPersistentSystemProcess\n                 : (realCallingAppId == Process.SYSTEM_UID)\n                         || realCallingUidProcState <= ActivityManager.PROCESS_STATE_PERSISTENT_UI;\n-        if (realCallingUid != callingUid) {\n-            // don't abort if the realCallingUid has a visible window\n-            // TODO(b/171459802): We should check appSwitchAllowed also\n+\n+        // Legacy behavior allows to use caller foreground state to bypass BAL restriction.\n+        final boolean balAllowedByPiSender =\n+                PendingIntentRecord.isPendingIntentBalAllowedByCaller(checkedOptions);\n+\n+        if (balAllowedByPiSender && realCallingUid != callingUid) {\n             if (realCallingUidHasAnyVisibleWindow) {\n                 if (DEBUG_ACTIVITY_STARTS) {\n                     Slog.d(TAG, \"Activity start allowed: realCallingUid (\" + realCallingUid\n@@ -1393,9 +1397,9 @@ class ActivityStarter {\n         // If we don't have callerApp at this point, no caller was provided to startActivity().\n         // That's the case for PendingIntent-based starts, since the creator's process might not be\n         // up and alive. If that's the case, we retrieve the WindowProcessController for the send()\n-        // caller, so that we can make the decision based on its state.\n+        // caller if caller allows, so that we can make the decision based on its state.\n         int callerAppUid = callingUid;\n-        if (callerApp == null) {\n+        if (callerApp == null && balAllowedByPiSender) {\n             callerApp = mService.getProcessController(realCallingPid, realCallingUid);\n             callerAppUid = realCallingUid;\n         }\n",
    "added_lines": 14,
    "deleted_lines": 10,
    "changed_methods": "ActivityStarter::shouldAbortBackgroundActivityStart, ActivityStarter::shouldAbortBackgroundActivityStart, ActivityStarter::executeRequest"
   },
   {
    "filename": "ActivityTaskManagerService.java",
    "diff": "@@ -2114,7 +2114,7 @@ public class ActivityTaskManagerService extends IActivityTaskManager.Stub {\n         final ActivityStarter starter = getActivityStartController().obtainStarter(\n                 null /* intent */, \"moveTaskToFront\");\n         if (starter.shouldAbortBackgroundActivityStart(callingUid, callingPid, callingPackage, -1,\n-                -1, callerApp, null, false, null)) {\n+                -1, callerApp, null, false, null, null)) {\n             if (!isBackgroundActivityStartsEnabled()) {\n                 return;\n             }\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "ActivityTaskManagerService::moveTaskToFrontLocked"
   },
   {
    "filename": "AppTaskImpl.java",
    "diff": "@@ -108,7 +108,7 @@ class AppTaskImpl extends IAppTask.Stub {\n                 final ActivityStarter starter = mService.getActivityStartController().obtainStarter(\n                         null /* intent */, \"moveToFront\");\n                 if (starter.shouldAbortBackgroundActivityStart(callingUid, callingPid,\n-                        callingPackage, -1, -1, callerApp, null, false, null)) {\n+                        callingPackage, -1, -1, callerApp, null, false, null, null)) {\n                     if (!mService.isBackgroundActivityStartsEnabled()) {\n                         return;\n                     }\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "AppTaskImpl::moveToFront"
   },
   {
    "filename": "AlarmManagerServiceTest.java",
    "diff": "@@ -109,6 +109,7 @@ import static org.mockito.Mockito.times;\n \n import android.app.ActivityManager;\n import android.app.ActivityManagerInternal;\n+import android.app.ActivityOptions;\n import android.app.AlarmManager;\n import android.app.AppOpsManager;\n import android.app.BroadcastOptions;\n@@ -552,13 +553,23 @@ public class AlarmManagerServiceTest {\n \n \n     private PendingIntent getNewMockPendingIntent() {\n-        return getNewMockPendingIntent(TEST_CALLING_UID, TEST_CALLING_PACKAGE);\n+        return getNewMockPendingIntent(false);\n+    }\n+\n+    private PendingIntent getNewMockPendingIntent(boolean isActivity) {\n+        return getNewMockPendingIntent(TEST_CALLING_UID, TEST_CALLING_PACKAGE, isActivity);\n     }\n \n     private PendingIntent getNewMockPendingIntent(int creatorUid, String creatorPackage) {\n+        return getNewMockPendingIntent(creatorUid, creatorPackage, false);\n+    }\n+\n+    private PendingIntent getNewMockPendingIntent(int creatorUid, String creatorPackage,\n+            boolean isActivity) {\n         final PendingIntent mockPi = mock(PendingIntent.class, Answers.RETURNS_DEEP_STUBS);\n         when(mockPi.getCreatorUid()).thenReturn(creatorUid);\n         when(mockPi.getCreatorPackage()).thenReturn(creatorPackage);\n+        when(mockPi.isActivity()).thenReturn(isActivity);\n         return mockPi;\n     }\n \n@@ -2801,21 +2812,53 @@ public class AlarmManagerServiceTest {\n                 anyString()));\n     }\n \n-    @Test\n-    public void idleOptionsSentOnExpiration() throws Exception {\n+    private void optionsSentOnExpiration(boolean isActivity, Bundle idleOptions)\n+            throws Exception {\n         final long triggerTime = mNowElapsedTest + 5000;\n-        final PendingIntent alarmPi = getNewMockPendingIntent();\n-        final Bundle idleOptions = new Bundle();\n-        idleOptions.putChar(\"TEST_CHAR_KEY\", 'x');\n-        idleOptions.putInt(\"TEST_INT_KEY\", 53);\n+        final PendingIntent alarmPi = getNewMockPendingIntent(isActivity);\n         setTestAlarm(ELAPSED_REALTIME_WAKEUP, triggerTime, 0, alarmPi, 0, 0, TEST_CALLING_UID,\n                 idleOptions);\n \n         mNowElapsedTest = mTestTimer.getElapsed();\n         mTestTimer.expire();\n \n+        ArgumentCaptor<Bundle> bundleCaptor = ArgumentCaptor.forClass(Bundle.class);\n         verify(alarmPi).send(eq(mMockContext), eq(0), any(Intent.class),\n-                any(), any(Handler.class), isNull(), eq(idleOptions));\n+                any(), any(Handler.class), isNull(), bundleCaptor.capture());\n+        if (idleOptions != null) {\n+            assertEquals(idleOptions, bundleCaptor.getValue());\n+        } else {\n+            assertFalse(\"BAL flag needs to be false in alarm manager\",\n+                    bundleCaptor.getValue().getBoolean(\n+                            ActivityOptions.KEY_PENDING_INTENT_BACKGROUND_ACTIVITY_ALLOWED,\n+                            true));\n+        }\n+    }\n+\n+    @Test\n+    public void activityIdleOptionsSentOnExpiration() throws Exception {\n+        final Bundle idleOptions = new Bundle();\n+        idleOptions.putChar(\"TEST_CHAR_KEY\", 'x');\n+        idleOptions.putInt(\"TEST_INT_KEY\", 53);\n+        optionsSentOnExpiration(true, idleOptions);\n+    }\n+\n+    @Test\n+    public void broadcastIdleOptionsSentOnExpiration() throws Exception {\n+        final Bundle idleOptions = new Bundle();\n+        idleOptions.putChar(\"TEST_CHAR_KEY\", 'x');\n+        idleOptions.putInt(\"TEST_INT_KEY\", 53);\n+        optionsSentOnExpiration(false, idleOptions);\n+    }\n+\n+    @Test\n+    public void emptyActivityOptionsSentOnExpiration() throws Exception {\n+        optionsSentOnExpiration(true, null);\n+    }\n+\n+    @Test\n+    public void emptyBroadcastOptionsSentOnExpiration() throws Exception {\n+        optionsSentOnExpiration(false, null);\n     }\n \n     @Test\n",
    "added_lines": 51,
    "deleted_lines": 8,
    "changed_methods": "AlarmManagerServiceTest::getNewMockPendingIntent, AlarmManagerServiceTest::activityIdleOptionsSentOnExpiration, AlarmManagerServiceTest::emptyActivityOptionsSentOnExpiration, AlarmManagerServiceTest::getNewMockPendingIntent, AlarmManagerServiceTest::emptyBroadcastOptionsSentOnExpiration, AlarmManagerServiceTest::idleOptionsSentOnExpiration, AlarmManagerServiceTest::broadcastIdleOptionsSentOnExpiration, AlarmManagerServiceTest::getNewMockPendingIntent, AlarmManagerServiceTest::getNewMockPendingIntent, AlarmManagerServiceTest::optionsSentOnExpiration"
   }
  ]
 },
 {
  "hash": "af52e36a81099ffc43e898f74f1e8f70ec1de2e3",
  "commit": "[DO NOT MERGE] Backport BAL restrictions from T to S, this blocks apps from using Alarm\nManager to bypass BAL restrictions.\n\nTest: atest-src BackgroundActivityLaunchTest\nBug: 195756028\nChange-Id: I33112ff59d913d8a7244289fe1a43512844e902a\n(cherry picked from commit 7a41e2fbc983ce0083b288e9489288de60dc8d8b)\nMerged-In: I33112ff59d913d8a7244289fe1a43512844e902a",
  "files": [
   {
    "filename": "AlarmManagerService.java",
    "diff": "@@ -56,6 +56,7 @@ import android.annotation.NonNull;\n import android.annotation.UserIdInt;\n import android.app.Activity;\n import android.app.ActivityManagerInternal;\n+import android.app.ActivityOptions;\n import android.app.AlarmManager;\n import android.app.AppOpsManager;\n import android.app.BroadcastOptions;\n@@ -317,6 +318,8 @@ public class AlarmManagerService extends SystemService {\n     private final SparseBooleanArray mPendingSendNextAlarmClockChangedForUser =\n             new SparseBooleanArray();\n     private boolean mNextAlarmClockMayChange;\n+    ActivityOptions mActivityOptsRestrictBal = ActivityOptions.makeBasic();\n+    BroadcastOptions mBroadcastOptsRestrictBal = BroadcastOptions.makeBasic();\n \n     @GuardedBy(\"mLock\")\n     private final Runnable mAlarmClockUpdater = () -> mNextAlarmClockMayChange = true;\n@@ -1611,6 +1614,11 @@ public class AlarmManagerService extends SystemService {\n     @Override\n     public void onStart() {\n         mInjector.init();\n+        mOptsWithFgs.setPendingIntentBackgroundActivityLaunchAllowed(false);\n+        mOptsWithoutFgs.setPendingIntentBackgroundActivityLaunchAllowed(false);\n+        mOptsTimeBroadcast.setPendingIntentBackgroundActivityLaunchAllowed(false);\n+        mActivityOptsRestrictBal.setPendingIntentBackgroundActivityLaunchAllowed(false);\n+        mBroadcastOptsRestrictBal.setPendingIntentBackgroundActivityLaunchAllowed(false);\n         mMetricsHelper = new MetricsHelper(getContext(), mLock);\n \n         mListenerDeathRecipient = new IBinder.DeathRecipient() {\n@@ -4306,6 +4314,14 @@ public class AlarmManagerService extends SystemService {\n         return alarm.creatorUid;\n     }\n \n+    private Bundle getAlarmOperationBundle(Alarm alarm) {\n+        if (alarm.mIdleOptions != null) {\n+            return alarm.mIdleOptions;\n+        } else if (alarm.operation.isActivity()) {\n+            return mActivityOptsRestrictBal.toBundle();\n+        }\n+        return mBroadcastOptsRestrictBal.toBundle();\n+    }\n \n     @VisibleForTesting\n     class AlarmHandler extends Handler {\n@@ -4344,7 +4360,11 @@ public class AlarmManagerService extends SystemService {\n                     for (int i = 0; i < triggerList.size(); i++) {\n                         Alarm alarm = triggerList.get(i);\n                         try {\n-                            alarm.operation.send();\n+                            // Disallow AlarmManager to start random background activity.\n+                            final Bundle bundle = getAlarmOperationBundle(alarm);\n+                            alarm.operation.send(/* context */ null, /* code */0, /* intent */\n+                                    null, /* onFinished */null, /* handler */\n+                                    null, /* requiredPermission */ null, bundle);\n                         } catch (PendingIntent.CanceledException e) {\n                             if (alarm.repeatInterval > 0) {\n                                 // This IntentSender is no longer valid, but this\n@@ -4908,9 +4928,10 @@ public class AlarmManagerService extends SystemService {\n                     mSendCount++;\n \n                     try {\n+                        final Bundle bundle = getAlarmOperationBundle(alarm);\n                         alarm.operation.send(getContext(), 0,\n                                 mBackgroundIntent.putExtra(Intent.EXTRA_ALARM_COUNT, alarm.count),\n-                                mDeliveryTracker, mHandler, null, alarm.mIdleOptions);\n+                                mDeliveryTracker, mHandler, null, bundle);\n                     } catch (PendingIntent.CanceledException e) {\n                         if (alarm.repeatInterval > 0) {\n                             // This IntentSender is no longer valid, but this\n",
    "added_lines": 23,
    "deleted_lines": 2,
    "changed_methods": "AlarmManagerService::getAlarmOperationBundle, AlarmManagerService::DeliveryTracker::deliverLocked, AlarmManagerService::onStart, AlarmManagerService::AlarmHandler::handleMessage"
   },
   {
    "filename": "ActivityOptions.java",
    "diff": "@@ -69,7 +69,7 @@ import java.util.ArrayList;\n  * {@link android.content.Context#startActivity(android.content.Intent, android.os.Bundle)\n  * Context.startActivity(Intent, Bundle)} and related methods.\n  */\n-public class ActivityOptions {\n+public class ActivityOptions extends ComponentOptions {\n     private static final String TAG = \"ActivityOptions\";\n \n     /**\n@@ -1081,13 +1081,12 @@ public class ActivityOptions {\n     }\n \n     private ActivityOptions() {\n+        super();\n     }\n \n     /** @hide */\n     public ActivityOptions(Bundle opts) {\n-        // If the remote side sent us bad parcelables, they won't get the\n-        // results they want, which is their loss.\n-        opts.setDefusable(true);\n+        super(opts);\n \n         mPackageName = opts.getString(KEY_PACKAGE_NAME);\n         try {\n@@ -1832,8 +1831,9 @@ public class ActivityOptions {\n      * object; you must not modify it, but can supply it to the startActivity\n      * methods that take an options Bundle.\n      */\n+    @Override\n     public Bundle toBundle() {\n-        Bundle b = new Bundle();\n+        Bundle b = super.toBundle();\n         if (mPackageName != null) {\n             b.putString(KEY_PACKAGE_NAME, mPackageName);\n         }\n",
    "added_lines": 5,
    "deleted_lines": 5,
    "changed_methods": "ActivityOptions::ActivityOptions, ActivityOptions::ActivityOptions, ActivityOptions::toBundle"
   },
   {
    "filename": "BroadcastOptions.java",
    "diff": "@@ -34,7 +34,7 @@ import android.os.PowerExemptionManager.TempAllowListType;\n  * {@hide}\n  */\n @SystemApi\n-public class BroadcastOptions {\n+public class BroadcastOptions extends ComponentOptions {\n     private long mTemporaryAppAllowlistDuration;\n     private @TempAllowListType int mTemporaryAppAllowlistType;\n     private @ReasonCode int mTemporaryAppAllowlistReasonCode;\n@@ -108,12 +108,14 @@ public class BroadcastOptions {\n     }\n \n     private BroadcastOptions() {\n+        super();\n         resetTemporaryAppAllowlist();\n     }\n \n     /** @hide */\n     @TestApi\n     public BroadcastOptions(@NonNull Bundle opts) {\n+        super(opts);\n         // Match the logic in toBundle().\n         if (opts.containsKey(KEY_TEMPORARY_APP_ALLOWLIST_DURATION)) {\n             mTemporaryAppAllowlistDuration = opts.getLong(KEY_TEMPORARY_APP_ALLOWLIST_DURATION);\n@@ -190,6 +192,24 @@ public class BroadcastOptions {\n         mTemporaryAppAllowlistReason = null;\n     }\n \n+    /**\n+     * Set PendingIntent activity is allowed to be started in the background if the caller\n+     * can start background activities.\n+     * @hide\n+     */\n+    public void setPendingIntentBackgroundActivityLaunchAllowed(boolean allowed) {\n+        super.setPendingIntentBackgroundActivityLaunchAllowed(allowed);\n+    }\n+\n+    /**\n+     * Get PendingIntent activity is allowed to be started in the background if the caller\n+     * can start background activities.\n+     * @hide\n+     */\n+    public boolean isPendingIntentBackgroundActivityLaunchAllowed() {\n+        return super.isPendingIntentBackgroundActivityLaunchAllowed();\n+    }\n+\n     /**\n      * Return {@link #setTemporaryAppAllowlist}.\n      * @hide\n@@ -308,8 +328,9 @@ public class BroadcastOptions {\n      * object; you must not modify it, but can supply it to the sendBroadcast\n      * methods that take an options Bundle.\n      */\n+    @Override\n     public Bundle toBundle() {\n-        Bundle b = new Bundle();\n+        Bundle b = super.toBundle();\n         if (isTemporaryAppAllowlistSet()) {\n             b.putLong(KEY_TEMPORARY_APP_ALLOWLIST_DURATION, mTemporaryAppAllowlistDuration);\n             b.putInt(KEY_TEMPORARY_APP_ALLOWLIST_TYPE, mTemporaryAppAllowlistType);\n",
    "added_lines": 23,
    "deleted_lines": 2,
    "changed_methods": "BroadcastOptions::toBundle, BroadcastOptions::BroadcastOptions, BroadcastOptions::setPendingIntentBackgroundActivityLaunchAllowed, BroadcastOptions::isPendingIntentBackgroundActivityLaunchAllowed, BroadcastOptions::BroadcastOptions"
   },
   {
    "filename": "ComponentOptions.java",
    "diff": "@@ -0,0 +1,83 @@\n+/*\n+ * Copyright (C) 2021 The Android Open Source Project\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package android.app;\n+\n+import android.os.Bundle;\n+\n+/**\n+ * @hide\n+ */\n+public class ComponentOptions {\n+\n+    /**\n+     * Default value for KEY_PENDING_INTENT_BACKGROUND_ACTIVITY_ALLOWED.\n+     * @hide\n+     **/\n+    public static final boolean PENDING_INTENT_BAL_ALLOWED_DEFAULT = true;\n+\n+    /**\n+     * PendingIntent caller allows activity start even if PendingIntent creator is in background.\n+     * This only works if the PendingIntent caller is allowed to start background activities,\n+     * for example if it's in the foreground, or has BAL permission.\n+     * @hide\n+     */\n+    public static final String KEY_PENDING_INTENT_BACKGROUND_ACTIVITY_ALLOWED =\n+            \"android.pendingIntent.backgroundActivityAllowed\";\n+\n+    private boolean mPendingIntentBalAllowed = PENDING_INTENT_BAL_ALLOWED_DEFAULT;\n+\n+    ComponentOptions() {\n+    }\n+\n+    ComponentOptions(Bundle opts) {\n+        // If the remote side sent us bad parcelables, they won't get the\n+        // results they want, which is their loss.\n+        opts.setDefusable(true);\n+        setPendingIntentBackgroundActivityLaunchAllowed(\n+                opts.getBoolean(KEY_PENDING_INTENT_BACKGROUND_ACTIVITY_ALLOWED,\n+                        PENDING_INTENT_BAL_ALLOWED_DEFAULT));\n+    }\n+\n+    /**\n+     * Set PendingIntent activity is allowed to be started in the background if the caller\n+     * can start background activities.\n+     *\n+     * @hide\n+     */\n+    public void setPendingIntentBackgroundActivityLaunchAllowed(boolean allowed) {\n+        mPendingIntentBalAllowed = allowed;\n+    }\n+\n+    /**\n+     * Get PendingIntent activity is allowed to be started in the background if the caller\n+     * can start background activities.\n+     *\n+     * @hide\n+     */\n+    public boolean isPendingIntentBackgroundActivityLaunchAllowed() {\n+        return mPendingIntentBalAllowed;\n+    }\n+\n+    /**\n+     * @hide\n+     */\n+    public Bundle toBundle() {\n+        Bundle bundle = new Bundle();\n+        bundle.putBoolean(KEY_PENDING_INTENT_BACKGROUND_ACTIVITY_ALLOWED, mPendingIntentBalAllowed);\n+        return bundle;\n+    }\n+}\n",
    "added_lines": 83,
    "deleted_lines": 0,
    "changed_methods": "ComponentOptions::toBundle, ComponentOptions::ComponentOptions, ComponentOptions::ComponentOptions, ComponentOptions::isPendingIntentBackgroundActivityLaunchAllowed, ComponentOptions::setPendingIntentBackgroundActivityLaunchAllowed"
   },
   {
    "filename": "PendingIntentRecord.java",
    "diff": "@@ -310,6 +310,25 @@ public final class PendingIntentRecord extends IIntentSender.Stub {\n                 requiredPermission, null, null, 0, 0, 0, options);\n     }\n \n+    /**\n+     * Return true if the activity options allows PendingIntent to use caller's BAL permission.\n+     */\n+    public static boolean isPendingIntentBalAllowedByCaller(\n+            @Nullable ActivityOptions activityOptions) {\n+        if (activityOptions == null) {\n+            return ActivityOptions.PENDING_INTENT_BAL_ALLOWED_DEFAULT;\n+        }\n+        return isPendingIntentBalAllowedByCaller(activityOptions.toBundle());\n+    }\n+\n+    private static boolean isPendingIntentBalAllowedByCaller(@Nullable Bundle options) {\n+        if (options == null) {\n+            return ActivityOptions.PENDING_INTENT_BAL_ALLOWED_DEFAULT;\n+        }\n+        return options.getBoolean(ActivityOptions.KEY_PENDING_INTENT_BACKGROUND_ACTIVITY_ALLOWED,\n+                ActivityOptions.PENDING_INTENT_BAL_ALLOWED_DEFAULT);\n+    }\n+\n     public int sendInner(int code, Intent intent, String resolvedType, IBinder allowlistToken,\n             IIntentReceiver finishedReceiver, String requiredPermission, IBinder resultTo,\n             String resultWho, int requestCode, int flagsMask, int flagsValues, Bundle options) {\n@@ -431,7 +450,8 @@ public final class PendingIntentRecord extends IIntentSender.Stub {\n             // temporarily allow receivers and services to open activities from background if the\n             // PendingIntent.send() caller was foreground at the time of sendInner() call\n             final boolean allowTrampoline = uid != callingUid\n-                    && controller.mAtmInternal.isUidForeground(callingUid);\n+                    && controller.mAtmInternal.isUidForeground(callingUid)\n+                    && isPendingIntentBalAllowedByCaller(options);\n \n             // note: we on purpose don't pass in the information about the PendingIntent's creator,\n             // like pid or ProcessRecord, to the ActivityTaskManagerInternal calls below, because\n",
    "added_lines": 21,
    "deleted_lines": 1,
    "changed_methods": "PendingIntentRecord::isPendingIntentBalAllowedByCaller, PendingIntentRecord::sendInner, PendingIntentRecord::isPendingIntentBalAllowedByCaller"
   },
   {
    "filename": "ActivityStarter.java",
    "diff": "@@ -989,6 +989,10 @@ class ActivityStarter {\n         abort |= !mService.getPermissionPolicyInternal().checkStartActivity(intent, callingUid,\n                 callingPackage);\n \n+        // Merge the two options bundles, while realCallerOptions takes precedence.\n+        ActivityOptions checkedOptions = options != null\n+                ? options.getOptions(intent, aInfo, callerApp, mSupervisor) : null;\n+\n         boolean restrictedBgActivity = false;\n         if (!abort) {\n             try {\n@@ -997,15 +1001,12 @@ class ActivityStarter {\n                 restrictedBgActivity = shouldAbortBackgroundActivityStart(callingUid,\n                         callingPid, callingPackage, realCallingUid, realCallingPid, callerApp,\n                         request.originatingPendingIntent, request.allowBackgroundActivityStart,\n-                        intent);\n+                        intent, checkedOptions);\n             } finally {\n                 Trace.traceEnd(Trace.TRACE_TAG_WINDOW_MANAGER);\n             }\n         }\n \n-        // Merge the two options bundles, while realCallerOptions takes precedence.\n-        ActivityOptions checkedOptions = options != null\n-                ? options.getOptions(intent, aInfo, callerApp, mSupervisor) : null;\n         if (request.allowPendingRemoteAnimationRegistryLookup) {\n             checkedOptions = mService.getActivityStartController()\n                     .getPendingRemoteAnimationRegistry()\n@@ -1247,7 +1248,7 @@ class ActivityStarter {\n     boolean shouldAbortBackgroundActivityStart(int callingUid, int callingPid,\n             final String callingPackage, int realCallingUid, int realCallingPid,\n             WindowProcessController callerApp, PendingIntentRecord originatingPendingIntent,\n-            boolean allowBackgroundActivityStart, Intent intent) {\n+            boolean allowBackgroundActivityStart, Intent intent, ActivityOptions checkedOptions) {\n         // don't abort for the most important UIDs\n         final int callingAppId = UserHandle.getAppId(callingUid);\n         if (callingUid == Process.ROOT_UID || callingAppId == Process.SYSTEM_UID\n@@ -1318,9 +1319,12 @@ class ActivityStarter {\n                 ? isCallingUidPersistentSystemProcess\n                 : (realCallingAppId == Process.SYSTEM_UID)\n                         || realCallingUidProcState <= ActivityManager.PROCESS_STATE_PERSISTENT_UI;\n-        if (realCallingUid != callingUid) {\n-            // don't abort if the realCallingUid has a visible window\n-            // TODO(b/171459802): We should check appSwitchAllowed also\n+\n+        // Legacy behavior allows to use caller foreground state to bypass BAL restriction.\n+        final boolean balAllowedByPiSender =\n+                PendingIntentRecord.isPendingIntentBalAllowedByCaller(checkedOptions);\n+\n+        if (balAllowedByPiSender && realCallingUid != callingUid) {\n             if (realCallingUidHasAnyVisibleWindow) {\n                 if (DEBUG_ACTIVITY_STARTS) {\n                     Slog.d(TAG, \"Activity start allowed: realCallingUid (\" + realCallingUid\n@@ -1393,9 +1397,9 @@ class ActivityStarter {\n         // If we don't have callerApp at this point, no caller was provided to startActivity().\n         // That's the case for PendingIntent-based starts, since the creator's process might not be\n         // up and alive. If that's the case, we retrieve the WindowProcessController for the send()\n-        // caller, so that we can make the decision based on its state.\n+        // caller if caller allows, so that we can make the decision based on its state.\n         int callerAppUid = callingUid;\n-        if (callerApp == null) {\n+        if (callerApp == null && balAllowedByPiSender) {\n             callerApp = mService.getProcessController(realCallingPid, realCallingUid);\n             callerAppUid = realCallingUid;\n         }\n",
    "added_lines": 14,
    "deleted_lines": 10,
    "changed_methods": "ActivityStarter::shouldAbortBackgroundActivityStart, ActivityStarter::shouldAbortBackgroundActivityStart, ActivityStarter::executeRequest"
   },
   {
    "filename": "ActivityTaskManagerService.java",
    "diff": "@@ -2114,7 +2114,7 @@ public class ActivityTaskManagerService extends IActivityTaskManager.Stub {\n         final ActivityStarter starter = getActivityStartController().obtainStarter(\n                 null /* intent */, \"moveTaskToFront\");\n         if (starter.shouldAbortBackgroundActivityStart(callingUid, callingPid, callingPackage, -1,\n-                -1, callerApp, null, false, null)) {\n+                -1, callerApp, null, false, null, null)) {\n             if (!isBackgroundActivityStartsEnabled()) {\n                 return;\n             }\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "ActivityTaskManagerService::moveTaskToFrontLocked"
   },
   {
    "filename": "AppTaskImpl.java",
    "diff": "@@ -108,7 +108,7 @@ class AppTaskImpl extends IAppTask.Stub {\n                 final ActivityStarter starter = mService.getActivityStartController().obtainStarter(\n                         null /* intent */, \"moveToFront\");\n                 if (starter.shouldAbortBackgroundActivityStart(callingUid, callingPid,\n-                        callingPackage, -1, -1, callerApp, null, false, null)) {\n+                        callingPackage, -1, -1, callerApp, null, false, null, null)) {\n                     if (!mService.isBackgroundActivityStartsEnabled()) {\n                         return;\n                     }\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "AppTaskImpl::moveToFront"
   },
   {
    "filename": "AlarmManagerServiceTest.java",
    "diff": "@@ -109,6 +109,7 @@ import static org.mockito.Mockito.times;\n \n import android.app.ActivityManager;\n import android.app.ActivityManagerInternal;\n+import android.app.ActivityOptions;\n import android.app.AlarmManager;\n import android.app.AppOpsManager;\n import android.app.BroadcastOptions;\n@@ -552,13 +553,23 @@ public class AlarmManagerServiceTest {\n \n \n     private PendingIntent getNewMockPendingIntent() {\n-        return getNewMockPendingIntent(TEST_CALLING_UID, TEST_CALLING_PACKAGE);\n+        return getNewMockPendingIntent(false);\n+    }\n+\n+    private PendingIntent getNewMockPendingIntent(boolean isActivity) {\n+        return getNewMockPendingIntent(TEST_CALLING_UID, TEST_CALLING_PACKAGE, isActivity);\n     }\n \n     private PendingIntent getNewMockPendingIntent(int creatorUid, String creatorPackage) {\n+        return getNewMockPendingIntent(creatorUid, creatorPackage, false);\n+    }\n+\n+    private PendingIntent getNewMockPendingIntent(int creatorUid, String creatorPackage,\n+            boolean isActivity) {\n         final PendingIntent mockPi = mock(PendingIntent.class, Answers.RETURNS_DEEP_STUBS);\n         when(mockPi.getCreatorUid()).thenReturn(creatorUid);\n         when(mockPi.getCreatorPackage()).thenReturn(creatorPackage);\n+        when(mockPi.isActivity()).thenReturn(isActivity);\n         return mockPi;\n     }\n \n@@ -2801,21 +2812,53 @@ public class AlarmManagerServiceTest {\n                 anyString()));\n     }\n \n-    @Test\n-    public void idleOptionsSentOnExpiration() throws Exception {\n+    private void optionsSentOnExpiration(boolean isActivity, Bundle idleOptions)\n+            throws Exception {\n         final long triggerTime = mNowElapsedTest + 5000;\n-        final PendingIntent alarmPi = getNewMockPendingIntent();\n-        final Bundle idleOptions = new Bundle();\n-        idleOptions.putChar(\"TEST_CHAR_KEY\", 'x');\n-        idleOptions.putInt(\"TEST_INT_KEY\", 53);\n+        final PendingIntent alarmPi = getNewMockPendingIntent(isActivity);\n         setTestAlarm(ELAPSED_REALTIME_WAKEUP, triggerTime, 0, alarmPi, 0, 0, TEST_CALLING_UID,\n                 idleOptions);\n \n         mNowElapsedTest = mTestTimer.getElapsed();\n         mTestTimer.expire();\n \n+        ArgumentCaptor<Bundle> bundleCaptor = ArgumentCaptor.forClass(Bundle.class);\n         verify(alarmPi).send(eq(mMockContext), eq(0), any(Intent.class),\n-                any(), any(Handler.class), isNull(), eq(idleOptions));\n+                any(), any(Handler.class), isNull(), bundleCaptor.capture());\n+        if (idleOptions != null) {\n+            assertEquals(idleOptions, bundleCaptor.getValue());\n+        } else {\n+            assertFalse(\"BAL flag needs to be false in alarm manager\",\n+                    bundleCaptor.getValue().getBoolean(\n+                            ActivityOptions.KEY_PENDING_INTENT_BACKGROUND_ACTIVITY_ALLOWED,\n+                            true));\n+        }\n+    }\n+\n+    @Test\n+    public void activityIdleOptionsSentOnExpiration() throws Exception {\n+        final Bundle idleOptions = new Bundle();\n+        idleOptions.putChar(\"TEST_CHAR_KEY\", 'x');\n+        idleOptions.putInt(\"TEST_INT_KEY\", 53);\n+        optionsSentOnExpiration(true, idleOptions);\n+    }\n+\n+    @Test\n+    public void broadcastIdleOptionsSentOnExpiration() throws Exception {\n+        final Bundle idleOptions = new Bundle();\n+        idleOptions.putChar(\"TEST_CHAR_KEY\", 'x');\n+        idleOptions.putInt(\"TEST_INT_KEY\", 53);\n+        optionsSentOnExpiration(false, idleOptions);\n+    }\n+\n+    @Test\n+    public void emptyActivityOptionsSentOnExpiration() throws Exception {\n+        optionsSentOnExpiration(true, null);\n+    }\n+\n+    @Test\n+    public void emptyBroadcastOptionsSentOnExpiration() throws Exception {\n+        optionsSentOnExpiration(false, null);\n     }\n \n     @Test\n",
    "added_lines": 51,
    "deleted_lines": 8,
    "changed_methods": "AlarmManagerServiceTest::getNewMockPendingIntent, AlarmManagerServiceTest::activityIdleOptionsSentOnExpiration, AlarmManagerServiceTest::emptyActivityOptionsSentOnExpiration, AlarmManagerServiceTest::getNewMockPendingIntent, AlarmManagerServiceTest::emptyBroadcastOptionsSentOnExpiration, AlarmManagerServiceTest::idleOptionsSentOnExpiration, AlarmManagerServiceTest::broadcastIdleOptionsSentOnExpiration, AlarmManagerServiceTest::getNewMockPendingIntent, AlarmManagerServiceTest::getNewMockPendingIntent, AlarmManagerServiceTest::optionsSentOnExpiration"
   }
  ]
 },
 {
  "hash": "af52e36a81099ffc43e898f74f1e8f70ec1de2e3",
  "commit": "[DO NOT MERGE] Backport BAL restrictions from T to S, this blocks apps from using Alarm\nManager to bypass BAL restrictions.\n\nTest: atest-src BackgroundActivityLaunchTest\nBug: 195756028\nChange-Id: I33112ff59d913d8a7244289fe1a43512844e902a\n(cherry picked from commit 7a41e2fbc983ce0083b288e9489288de60dc8d8b)\nMerged-In: I33112ff59d913d8a7244289fe1a43512844e902a",
  "files": [
   {
    "filename": "AlarmManagerService.java",
    "diff": "@@ -56,6 +56,7 @@ import android.annotation.NonNull;\n import android.annotation.UserIdInt;\n import android.app.Activity;\n import android.app.ActivityManagerInternal;\n+import android.app.ActivityOptions;\n import android.app.AlarmManager;\n import android.app.AppOpsManager;\n import android.app.BroadcastOptions;\n@@ -317,6 +318,8 @@ public class AlarmManagerService extends SystemService {\n     private final SparseBooleanArray mPendingSendNextAlarmClockChangedForUser =\n             new SparseBooleanArray();\n     private boolean mNextAlarmClockMayChange;\n+    ActivityOptions mActivityOptsRestrictBal = ActivityOptions.makeBasic();\n+    BroadcastOptions mBroadcastOptsRestrictBal = BroadcastOptions.makeBasic();\n \n     @GuardedBy(\"mLock\")\n     private final Runnable mAlarmClockUpdater = () -> mNextAlarmClockMayChange = true;\n@@ -1611,6 +1614,11 @@ public class AlarmManagerService extends SystemService {\n     @Override\n     public void onStart() {\n         mInjector.init();\n+        mOptsWithFgs.setPendingIntentBackgroundActivityLaunchAllowed(false);\n+        mOptsWithoutFgs.setPendingIntentBackgroundActivityLaunchAllowed(false);\n+        mOptsTimeBroadcast.setPendingIntentBackgroundActivityLaunchAllowed(false);\n+        mActivityOptsRestrictBal.setPendingIntentBackgroundActivityLaunchAllowed(false);\n+        mBroadcastOptsRestrictBal.setPendingIntentBackgroundActivityLaunchAllowed(false);\n         mMetricsHelper = new MetricsHelper(getContext(), mLock);\n \n         mListenerDeathRecipient = new IBinder.DeathRecipient() {\n@@ -4306,6 +4314,14 @@ public class AlarmManagerService extends SystemService {\n         return alarm.creatorUid;\n     }\n \n+    private Bundle getAlarmOperationBundle(Alarm alarm) {\n+        if (alarm.mIdleOptions != null) {\n+            return alarm.mIdleOptions;\n+        } else if (alarm.operation.isActivity()) {\n+            return mActivityOptsRestrictBal.toBundle();\n+        }\n+        return mBroadcastOptsRestrictBal.toBundle();\n+    }\n \n     @VisibleForTesting\n     class AlarmHandler extends Handler {\n@@ -4344,7 +4360,11 @@ public class AlarmManagerService extends SystemService {\n                     for (int i = 0; i < triggerList.size(); i++) {\n                         Alarm alarm = triggerList.get(i);\n                         try {\n-                            alarm.operation.send();\n+                            // Disallow AlarmManager to start random background activity.\n+                            final Bundle bundle = getAlarmOperationBundle(alarm);\n+                            alarm.operation.send(/* context */ null, /* code */0, /* intent */\n+                                    null, /* onFinished */null, /* handler */\n+                                    null, /* requiredPermission */ null, bundle);\n                         } catch (PendingIntent.CanceledException e) {\n                             if (alarm.repeatInterval > 0) {\n                                 // This IntentSender is no longer valid, but this\n@@ -4908,9 +4928,10 @@ public class AlarmManagerService extends SystemService {\n                     mSendCount++;\n \n                     try {\n+                        final Bundle bundle = getAlarmOperationBundle(alarm);\n                         alarm.operation.send(getContext(), 0,\n                                 mBackgroundIntent.putExtra(Intent.EXTRA_ALARM_COUNT, alarm.count),\n-                                mDeliveryTracker, mHandler, null, alarm.mIdleOptions);\n+                                mDeliveryTracker, mHandler, null, bundle);\n                     } catch (PendingIntent.CanceledException e) {\n                         if (alarm.repeatInterval > 0) {\n                             // This IntentSender is no longer valid, but this\n",
    "added_lines": 23,
    "deleted_lines": 2,
    "changed_methods": "AlarmManagerService::getAlarmOperationBundle, AlarmManagerService::DeliveryTracker::deliverLocked, AlarmManagerService::onStart, AlarmManagerService::AlarmHandler::handleMessage"
   },
   {
    "filename": "ActivityOptions.java",
    "diff": "@@ -69,7 +69,7 @@ import java.util.ArrayList;\n  * {@link android.content.Context#startActivity(android.content.Intent, android.os.Bundle)\n  * Context.startActivity(Intent, Bundle)} and related methods.\n  */\n-public class ActivityOptions {\n+public class ActivityOptions extends ComponentOptions {\n     private static final String TAG = \"ActivityOptions\";\n \n     /**\n@@ -1081,13 +1081,12 @@ public class ActivityOptions {\n     }\n \n     private ActivityOptions() {\n+        super();\n     }\n \n     /** @hide */\n     public ActivityOptions(Bundle opts) {\n-        // If the remote side sent us bad parcelables, they won't get the\n-        // results they want, which is their loss.\n-        opts.setDefusable(true);\n+        super(opts);\n \n         mPackageName = opts.getString(KEY_PACKAGE_NAME);\n         try {\n@@ -1832,8 +1831,9 @@ public class ActivityOptions {\n      * object; you must not modify it, but can supply it to the startActivity\n      * methods that take an options Bundle.\n      */\n+    @Override\n     public Bundle toBundle() {\n-        Bundle b = new Bundle();\n+        Bundle b = super.toBundle();\n         if (mPackageName != null) {\n             b.putString(KEY_PACKAGE_NAME, mPackageName);\n         }\n",
    "added_lines": 5,
    "deleted_lines": 5,
    "changed_methods": "ActivityOptions::ActivityOptions, ActivityOptions::ActivityOptions, ActivityOptions::toBundle"
   },
   {
    "filename": "BroadcastOptions.java",
    "diff": "@@ -34,7 +34,7 @@ import android.os.PowerExemptionManager.TempAllowListType;\n  * {@hide}\n  */\n @SystemApi\n-public class BroadcastOptions {\n+public class BroadcastOptions extends ComponentOptions {\n     private long mTemporaryAppAllowlistDuration;\n     private @TempAllowListType int mTemporaryAppAllowlistType;\n     private @ReasonCode int mTemporaryAppAllowlistReasonCode;\n@@ -108,12 +108,14 @@ public class BroadcastOptions {\n     }\n \n     private BroadcastOptions() {\n+        super();\n         resetTemporaryAppAllowlist();\n     }\n \n     /** @hide */\n     @TestApi\n     public BroadcastOptions(@NonNull Bundle opts) {\n+        super(opts);\n         // Match the logic in toBundle().\n         if (opts.containsKey(KEY_TEMPORARY_APP_ALLOWLIST_DURATION)) {\n             mTemporaryAppAllowlistDuration = opts.getLong(KEY_TEMPORARY_APP_ALLOWLIST_DURATION);\n@@ -190,6 +192,24 @@ public class BroadcastOptions {\n         mTemporaryAppAllowlistReason = null;\n     }\n \n+    /**\n+     * Set PendingIntent activity is allowed to be started in the background if the caller\n+     * can start background activities.\n+     * @hide\n+     */\n+    public void setPendingIntentBackgroundActivityLaunchAllowed(boolean allowed) {\n+        super.setPendingIntentBackgroundActivityLaunchAllowed(allowed);\n+    }\n+\n+    /**\n+     * Get PendingIntent activity is allowed to be started in the background if the caller\n+     * can start background activities.\n+     * @hide\n+     */\n+    public boolean isPendingIntentBackgroundActivityLaunchAllowed() {\n+        return super.isPendingIntentBackgroundActivityLaunchAllowed();\n+    }\n+\n     /**\n      * Return {@link #setTemporaryAppAllowlist}.\n      * @hide\n@@ -308,8 +328,9 @@ public class BroadcastOptions {\n      * object; you must not modify it, but can supply it to the sendBroadcast\n      * methods that take an options Bundle.\n      */\n+    @Override\n     public Bundle toBundle() {\n-        Bundle b = new Bundle();\n+        Bundle b = super.toBundle();\n         if (isTemporaryAppAllowlistSet()) {\n             b.putLong(KEY_TEMPORARY_APP_ALLOWLIST_DURATION, mTemporaryAppAllowlistDuration);\n             b.putInt(KEY_TEMPORARY_APP_ALLOWLIST_TYPE, mTemporaryAppAllowlistType);\n",
    "added_lines": 23,
    "deleted_lines": 2,
    "changed_methods": "BroadcastOptions::toBundle, BroadcastOptions::BroadcastOptions, BroadcastOptions::setPendingIntentBackgroundActivityLaunchAllowed, BroadcastOptions::isPendingIntentBackgroundActivityLaunchAllowed, BroadcastOptions::BroadcastOptions"
   },
   {
    "filename": "ComponentOptions.java",
    "diff": "@@ -0,0 +1,83 @@\n+/*\n+ * Copyright (C) 2021 The Android Open Source Project\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package android.app;\n+\n+import android.os.Bundle;\n+\n+/**\n+ * @hide\n+ */\n+public class ComponentOptions {\n+\n+    /**\n+     * Default value for KEY_PENDING_INTENT_BACKGROUND_ACTIVITY_ALLOWED.\n+     * @hide\n+     **/\n+    public static final boolean PENDING_INTENT_BAL_ALLOWED_DEFAULT = true;\n+\n+    /**\n+     * PendingIntent caller allows activity start even if PendingIntent creator is in background.\n+     * This only works if the PendingIntent caller is allowed to start background activities,\n+     * for example if it's in the foreground, or has BAL permission.\n+     * @hide\n+     */\n+    public static final String KEY_PENDING_INTENT_BACKGROUND_ACTIVITY_ALLOWED =\n+            \"android.pendingIntent.backgroundActivityAllowed\";\n+\n+    private boolean mPendingIntentBalAllowed = PENDING_INTENT_BAL_ALLOWED_DEFAULT;\n+\n+    ComponentOptions() {\n+    }\n+\n+    ComponentOptions(Bundle opts) {\n+        // If the remote side sent us bad parcelables, they won't get the\n+        // results they want, which is their loss.\n+        opts.setDefusable(true);\n+        setPendingIntentBackgroundActivityLaunchAllowed(\n+                opts.getBoolean(KEY_PENDING_INTENT_BACKGROUND_ACTIVITY_ALLOWED,\n+                        PENDING_INTENT_BAL_ALLOWED_DEFAULT));\n+    }\n+\n+    /**\n+     * Set PendingIntent activity is allowed to be started in the background if the caller\n+     * can start background activities.\n+     *\n+     * @hide\n+     */\n+    public void setPendingIntentBackgroundActivityLaunchAllowed(boolean allowed) {\n+        mPendingIntentBalAllowed = allowed;\n+    }\n+\n+    /**\n+     * Get PendingIntent activity is allowed to be started in the background if the caller\n+     * can start background activities.\n+     *\n+     * @hide\n+     */\n+    public boolean isPendingIntentBackgroundActivityLaunchAllowed() {\n+        return mPendingIntentBalAllowed;\n+    }\n+\n+    /**\n+     * @hide\n+     */\n+    public Bundle toBundle() {\n+        Bundle bundle = new Bundle();\n+        bundle.putBoolean(KEY_PENDING_INTENT_BACKGROUND_ACTIVITY_ALLOWED, mPendingIntentBalAllowed);\n+        return bundle;\n+    }\n+}\n",
    "added_lines": 83,
    "deleted_lines": 0,
    "changed_methods": "ComponentOptions::toBundle, ComponentOptions::ComponentOptions, ComponentOptions::ComponentOptions, ComponentOptions::isPendingIntentBackgroundActivityLaunchAllowed, ComponentOptions::setPendingIntentBackgroundActivityLaunchAllowed"
   },
   {
    "filename": "PendingIntentRecord.java",
    "diff": "@@ -310,6 +310,25 @@ public final class PendingIntentRecord extends IIntentSender.Stub {\n                 requiredPermission, null, null, 0, 0, 0, options);\n     }\n \n+    /**\n+     * Return true if the activity options allows PendingIntent to use caller's BAL permission.\n+     */\n+    public static boolean isPendingIntentBalAllowedByCaller(\n+            @Nullable ActivityOptions activityOptions) {\n+        if (activityOptions == null) {\n+            return ActivityOptions.PENDING_INTENT_BAL_ALLOWED_DEFAULT;\n+        }\n+        return isPendingIntentBalAllowedByCaller(activityOptions.toBundle());\n+    }\n+\n+    private static boolean isPendingIntentBalAllowedByCaller(@Nullable Bundle options) {\n+        if (options == null) {\n+            return ActivityOptions.PENDING_INTENT_BAL_ALLOWED_DEFAULT;\n+        }\n+        return options.getBoolean(ActivityOptions.KEY_PENDING_INTENT_BACKGROUND_ACTIVITY_ALLOWED,\n+                ActivityOptions.PENDING_INTENT_BAL_ALLOWED_DEFAULT);\n+    }\n+\n     public int sendInner(int code, Intent intent, String resolvedType, IBinder allowlistToken,\n             IIntentReceiver finishedReceiver, String requiredPermission, IBinder resultTo,\n             String resultWho, int requestCode, int flagsMask, int flagsValues, Bundle options) {\n@@ -431,7 +450,8 @@ public final class PendingIntentRecord extends IIntentSender.Stub {\n             // temporarily allow receivers and services to open activities from background if the\n             // PendingIntent.send() caller was foreground at the time of sendInner() call\n             final boolean allowTrampoline = uid != callingUid\n-                    && controller.mAtmInternal.isUidForeground(callingUid);\n+                    && controller.mAtmInternal.isUidForeground(callingUid)\n+                    && isPendingIntentBalAllowedByCaller(options);\n \n             // note: we on purpose don't pass in the information about the PendingIntent's creator,\n             // like pid or ProcessRecord, to the ActivityTaskManagerInternal calls below, because\n",
    "added_lines": 21,
    "deleted_lines": 1,
    "changed_methods": "PendingIntentRecord::isPendingIntentBalAllowedByCaller, PendingIntentRecord::sendInner, PendingIntentRecord::isPendingIntentBalAllowedByCaller"
   },
   {
    "filename": "ActivityStarter.java",
    "diff": "@@ -989,6 +989,10 @@ class ActivityStarter {\n         abort |= !mService.getPermissionPolicyInternal().checkStartActivity(intent, callingUid,\n                 callingPackage);\n \n+        // Merge the two options bundles, while realCallerOptions takes precedence.\n+        ActivityOptions checkedOptions = options != null\n+                ? options.getOptions(intent, aInfo, callerApp, mSupervisor) : null;\n+\n         boolean restrictedBgActivity = false;\n         if (!abort) {\n             try {\n@@ -997,15 +1001,12 @@ class ActivityStarter {\n                 restrictedBgActivity = shouldAbortBackgroundActivityStart(callingUid,\n                         callingPid, callingPackage, realCallingUid, realCallingPid, callerApp,\n                         request.originatingPendingIntent, request.allowBackgroundActivityStart,\n-                        intent);\n+                        intent, checkedOptions);\n             } finally {\n                 Trace.traceEnd(Trace.TRACE_TAG_WINDOW_MANAGER);\n             }\n         }\n \n-        // Merge the two options bundles, while realCallerOptions takes precedence.\n-        ActivityOptions checkedOptions = options != null\n-                ? options.getOptions(intent, aInfo, callerApp, mSupervisor) : null;\n         if (request.allowPendingRemoteAnimationRegistryLookup) {\n             checkedOptions = mService.getActivityStartController()\n                     .getPendingRemoteAnimationRegistry()\n@@ -1247,7 +1248,7 @@ class ActivityStarter {\n     boolean shouldAbortBackgroundActivityStart(int callingUid, int callingPid,\n             final String callingPackage, int realCallingUid, int realCallingPid,\n             WindowProcessController callerApp, PendingIntentRecord originatingPendingIntent,\n-            boolean allowBackgroundActivityStart, Intent intent) {\n+            boolean allowBackgroundActivityStart, Intent intent, ActivityOptions checkedOptions) {\n         // don't abort for the most important UIDs\n         final int callingAppId = UserHandle.getAppId(callingUid);\n         if (callingUid == Process.ROOT_UID || callingAppId == Process.SYSTEM_UID\n@@ -1318,9 +1319,12 @@ class ActivityStarter {\n                 ? isCallingUidPersistentSystemProcess\n                 : (realCallingAppId == Process.SYSTEM_UID)\n                         || realCallingUidProcState <= ActivityManager.PROCESS_STATE_PERSISTENT_UI;\n-        if (realCallingUid != callingUid) {\n-            // don't abort if the realCallingUid has a visible window\n-            // TODO(b/171459802): We should check appSwitchAllowed also\n+\n+        // Legacy behavior allows to use caller foreground state to bypass BAL restriction.\n+        final boolean balAllowedByPiSender =\n+                PendingIntentRecord.isPendingIntentBalAllowedByCaller(checkedOptions);\n+\n+        if (balAllowedByPiSender && realCallingUid != callingUid) {\n             if (realCallingUidHasAnyVisibleWindow) {\n                 if (DEBUG_ACTIVITY_STARTS) {\n                     Slog.d(TAG, \"Activity start allowed: realCallingUid (\" + realCallingUid\n@@ -1393,9 +1397,9 @@ class ActivityStarter {\n         // If we don't have callerApp at this point, no caller was provided to startActivity().\n         // That's the case for PendingIntent-based starts, since the creator's process might not be\n         // up and alive. If that's the case, we retrieve the WindowProcessController for the send()\n-        // caller, so that we can make the decision based on its state.\n+        // caller if caller allows, so that we can make the decision based on its state.\n         int callerAppUid = callingUid;\n-        if (callerApp == null) {\n+        if (callerApp == null && balAllowedByPiSender) {\n             callerApp = mService.getProcessController(realCallingPid, realCallingUid);\n             callerAppUid = realCallingUid;\n         }\n",
    "added_lines": 14,
    "deleted_lines": 10,
    "changed_methods": "ActivityStarter::shouldAbortBackgroundActivityStart, ActivityStarter::shouldAbortBackgroundActivityStart, ActivityStarter::executeRequest"
   },
   {
    "filename": "ActivityTaskManagerService.java",
    "diff": "@@ -2114,7 +2114,7 @@ public class ActivityTaskManagerService extends IActivityTaskManager.Stub {\n         final ActivityStarter starter = getActivityStartController().obtainStarter(\n                 null /* intent */, \"moveTaskToFront\");\n         if (starter.shouldAbortBackgroundActivityStart(callingUid, callingPid, callingPackage, -1,\n-                -1, callerApp, null, false, null)) {\n+                -1, callerApp, null, false, null, null)) {\n             if (!isBackgroundActivityStartsEnabled()) {\n                 return;\n             }\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "ActivityTaskManagerService::moveTaskToFrontLocked"
   },
   {
    "filename": "AppTaskImpl.java",
    "diff": "@@ -108,7 +108,7 @@ class AppTaskImpl extends IAppTask.Stub {\n                 final ActivityStarter starter = mService.getActivityStartController().obtainStarter(\n                         null /* intent */, \"moveToFront\");\n                 if (starter.shouldAbortBackgroundActivityStart(callingUid, callingPid,\n-                        callingPackage, -1, -1, callerApp, null, false, null)) {\n+                        callingPackage, -1, -1, callerApp, null, false, null, null)) {\n                     if (!mService.isBackgroundActivityStartsEnabled()) {\n                         return;\n                     }\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "AppTaskImpl::moveToFront"
   },
   {
    "filename": "AlarmManagerServiceTest.java",
    "diff": "@@ -109,6 +109,7 @@ import static org.mockito.Mockito.times;\n \n import android.app.ActivityManager;\n import android.app.ActivityManagerInternal;\n+import android.app.ActivityOptions;\n import android.app.AlarmManager;\n import android.app.AppOpsManager;\n import android.app.BroadcastOptions;\n@@ -552,13 +553,23 @@ public class AlarmManagerServiceTest {\n \n \n     private PendingIntent getNewMockPendingIntent() {\n-        return getNewMockPendingIntent(TEST_CALLING_UID, TEST_CALLING_PACKAGE);\n+        return getNewMockPendingIntent(false);\n+    }\n+\n+    private PendingIntent getNewMockPendingIntent(boolean isActivity) {\n+        return getNewMockPendingIntent(TEST_CALLING_UID, TEST_CALLING_PACKAGE, isActivity);\n     }\n \n     private PendingIntent getNewMockPendingIntent(int creatorUid, String creatorPackage) {\n+        return getNewMockPendingIntent(creatorUid, creatorPackage, false);\n+    }\n+\n+    private PendingIntent getNewMockPendingIntent(int creatorUid, String creatorPackage,\n+            boolean isActivity) {\n         final PendingIntent mockPi = mock(PendingIntent.class, Answers.RETURNS_DEEP_STUBS);\n         when(mockPi.getCreatorUid()).thenReturn(creatorUid);\n         when(mockPi.getCreatorPackage()).thenReturn(creatorPackage);\n+        when(mockPi.isActivity()).thenReturn(isActivity);\n         return mockPi;\n     }\n \n@@ -2801,21 +2812,53 @@ public class AlarmManagerServiceTest {\n                 anyString()));\n     }\n \n-    @Test\n-    public void idleOptionsSentOnExpiration() throws Exception {\n+    private void optionsSentOnExpiration(boolean isActivity, Bundle idleOptions)\n+            throws Exception {\n         final long triggerTime = mNowElapsedTest + 5000;\n-        final PendingIntent alarmPi = getNewMockPendingIntent();\n-        final Bundle idleOptions = new Bundle();\n-        idleOptions.putChar(\"TEST_CHAR_KEY\", 'x');\n-        idleOptions.putInt(\"TEST_INT_KEY\", 53);\n+        final PendingIntent alarmPi = getNewMockPendingIntent(isActivity);\n         setTestAlarm(ELAPSED_REALTIME_WAKEUP, triggerTime, 0, alarmPi, 0, 0, TEST_CALLING_UID,\n                 idleOptions);\n \n         mNowElapsedTest = mTestTimer.getElapsed();\n         mTestTimer.expire();\n \n+        ArgumentCaptor<Bundle> bundleCaptor = ArgumentCaptor.forClass(Bundle.class);\n         verify(alarmPi).send(eq(mMockContext), eq(0), any(Intent.class),\n-                any(), any(Handler.class), isNull(), eq(idleOptions));\n+                any(), any(Handler.class), isNull(), bundleCaptor.capture());\n+        if (idleOptions != null) {\n+            assertEquals(idleOptions, bundleCaptor.getValue());\n+        } else {\n+            assertFalse(\"BAL flag needs to be false in alarm manager\",\n+                    bundleCaptor.getValue().getBoolean(\n+                            ActivityOptions.KEY_PENDING_INTENT_BACKGROUND_ACTIVITY_ALLOWED,\n+                            true));\n+        }\n+    }\n+\n+    @Test\n+    public void activityIdleOptionsSentOnExpiration() throws Exception {\n+        final Bundle idleOptions = new Bundle();\n+        idleOptions.putChar(\"TEST_CHAR_KEY\", 'x');\n+        idleOptions.putInt(\"TEST_INT_KEY\", 53);\n+        optionsSentOnExpiration(true, idleOptions);\n+    }\n+\n+    @Test\n+    public void broadcastIdleOptionsSentOnExpiration() throws Exception {\n+        final Bundle idleOptions = new Bundle();\n+        idleOptions.putChar(\"TEST_CHAR_KEY\", 'x');\n+        idleOptions.putInt(\"TEST_INT_KEY\", 53);\n+        optionsSentOnExpiration(false, idleOptions);\n+    }\n+\n+    @Test\n+    public void emptyActivityOptionsSentOnExpiration() throws Exception {\n+        optionsSentOnExpiration(true, null);\n+    }\n+\n+    @Test\n+    public void emptyBroadcastOptionsSentOnExpiration() throws Exception {\n+        optionsSentOnExpiration(false, null);\n     }\n \n     @Test\n",
    "added_lines": 51,
    "deleted_lines": 8,
    "changed_methods": "AlarmManagerServiceTest::getNewMockPendingIntent, AlarmManagerServiceTest::activityIdleOptionsSentOnExpiration, AlarmManagerServiceTest::emptyActivityOptionsSentOnExpiration, AlarmManagerServiceTest::getNewMockPendingIntent, AlarmManagerServiceTest::emptyBroadcastOptionsSentOnExpiration, AlarmManagerServiceTest::idleOptionsSentOnExpiration, AlarmManagerServiceTest::broadcastIdleOptionsSentOnExpiration, AlarmManagerServiceTest::getNewMockPendingIntent, AlarmManagerServiceTest::getNewMockPendingIntent, AlarmManagerServiceTest::optionsSentOnExpiration"
   }
  ]
 },
 {
  "hash": "af52e36a81099ffc43e898f74f1e8f70ec1de2e3",
  "commit": "[DO NOT MERGE] Backport BAL restrictions from T to S, this blocks apps from using Alarm\nManager to bypass BAL restrictions.\n\nTest: atest-src BackgroundActivityLaunchTest\nBug: 195756028\nChange-Id: I33112ff59d913d8a7244289fe1a43512844e902a\n(cherry picked from commit 7a41e2fbc983ce0083b288e9489288de60dc8d8b)\nMerged-In: I33112ff59d913d8a7244289fe1a43512844e902a",
  "files": [
   {
    "filename": "AlarmManagerService.java",
    "diff": "@@ -56,6 +56,7 @@ import android.annotation.NonNull;\n import android.annotation.UserIdInt;\n import android.app.Activity;\n import android.app.ActivityManagerInternal;\n+import android.app.ActivityOptions;\n import android.app.AlarmManager;\n import android.app.AppOpsManager;\n import android.app.BroadcastOptions;\n@@ -317,6 +318,8 @@ public class AlarmManagerService extends SystemService {\n     private final SparseBooleanArray mPendingSendNextAlarmClockChangedForUser =\n             new SparseBooleanArray();\n     private boolean mNextAlarmClockMayChange;\n+    ActivityOptions mActivityOptsRestrictBal = ActivityOptions.makeBasic();\n+    BroadcastOptions mBroadcastOptsRestrictBal = BroadcastOptions.makeBasic();\n \n     @GuardedBy(\"mLock\")\n     private final Runnable mAlarmClockUpdater = () -> mNextAlarmClockMayChange = true;\n@@ -1611,6 +1614,11 @@ public class AlarmManagerService extends SystemService {\n     @Override\n     public void onStart() {\n         mInjector.init();\n+        mOptsWithFgs.setPendingIntentBackgroundActivityLaunchAllowed(false);\n+        mOptsWithoutFgs.setPendingIntentBackgroundActivityLaunchAllowed(false);\n+        mOptsTimeBroadcast.setPendingIntentBackgroundActivityLaunchAllowed(false);\n+        mActivityOptsRestrictBal.setPendingIntentBackgroundActivityLaunchAllowed(false);\n+        mBroadcastOptsRestrictBal.setPendingIntentBackgroundActivityLaunchAllowed(false);\n         mMetricsHelper = new MetricsHelper(getContext(), mLock);\n \n         mListenerDeathRecipient = new IBinder.DeathRecipient() {\n@@ -4306,6 +4314,14 @@ public class AlarmManagerService extends SystemService {\n         return alarm.creatorUid;\n     }\n \n+    private Bundle getAlarmOperationBundle(Alarm alarm) {\n+        if (alarm.mIdleOptions != null) {\n+            return alarm.mIdleOptions;\n+        } else if (alarm.operation.isActivity()) {\n+            return mActivityOptsRestrictBal.toBundle();\n+        }\n+        return mBroadcastOptsRestrictBal.toBundle();\n+    }\n \n     @VisibleForTesting\n     class AlarmHandler extends Handler {\n@@ -4344,7 +4360,11 @@ public class AlarmManagerService extends SystemService {\n                     for (int i = 0; i < triggerList.size(); i++) {\n                         Alarm alarm = triggerList.get(i);\n                         try {\n-                            alarm.operation.send();\n+                            // Disallow AlarmManager to start random background activity.\n+                            final Bundle bundle = getAlarmOperationBundle(alarm);\n+                            alarm.operation.send(/* context */ null, /* code */0, /* intent */\n+                                    null, /* onFinished */null, /* handler */\n+                                    null, /* requiredPermission */ null, bundle);\n                         } catch (PendingIntent.CanceledException e) {\n                             if (alarm.repeatInterval > 0) {\n                                 // This IntentSender is no longer valid, but this\n@@ -4908,9 +4928,10 @@ public class AlarmManagerService extends SystemService {\n                     mSendCount++;\n \n                     try {\n+                        final Bundle bundle = getAlarmOperationBundle(alarm);\n                         alarm.operation.send(getContext(), 0,\n                                 mBackgroundIntent.putExtra(Intent.EXTRA_ALARM_COUNT, alarm.count),\n-                                mDeliveryTracker, mHandler, null, alarm.mIdleOptions);\n+                                mDeliveryTracker, mHandler, null, bundle);\n                     } catch (PendingIntent.CanceledException e) {\n                         if (alarm.repeatInterval > 0) {\n                             // This IntentSender is no longer valid, but this\n",
    "added_lines": 23,
    "deleted_lines": 2,
    "changed_methods": "AlarmManagerService::getAlarmOperationBundle, AlarmManagerService::DeliveryTracker::deliverLocked, AlarmManagerService::onStart, AlarmManagerService::AlarmHandler::handleMessage"
   },
   {
    "filename": "ActivityOptions.java",
    "diff": "@@ -69,7 +69,7 @@ import java.util.ArrayList;\n  * {@link android.content.Context#startActivity(android.content.Intent, android.os.Bundle)\n  * Context.startActivity(Intent, Bundle)} and related methods.\n  */\n-public class ActivityOptions {\n+public class ActivityOptions extends ComponentOptions {\n     private static final String TAG = \"ActivityOptions\";\n \n     /**\n@@ -1081,13 +1081,12 @@ public class ActivityOptions {\n     }\n \n     private ActivityOptions() {\n+        super();\n     }\n \n     /** @hide */\n     public ActivityOptions(Bundle opts) {\n-        // If the remote side sent us bad parcelables, they won't get the\n-        // results they want, which is their loss.\n-        opts.setDefusable(true);\n+        super(opts);\n \n         mPackageName = opts.getString(KEY_PACKAGE_NAME);\n         try {\n@@ -1832,8 +1831,9 @@ public class ActivityOptions {\n      * object; you must not modify it, but can supply it to the startActivity\n      * methods that take an options Bundle.\n      */\n+    @Override\n     public Bundle toBundle() {\n-        Bundle b = new Bundle();\n+        Bundle b = super.toBundle();\n         if (mPackageName != null) {\n             b.putString(KEY_PACKAGE_NAME, mPackageName);\n         }\n",
    "added_lines": 5,
    "deleted_lines": 5,
    "changed_methods": "ActivityOptions::ActivityOptions, ActivityOptions::ActivityOptions, ActivityOptions::toBundle"
   },
   {
    "filename": "BroadcastOptions.java",
    "diff": "@@ -34,7 +34,7 @@ import android.os.PowerExemptionManager.TempAllowListType;\n  * {@hide}\n  */\n @SystemApi\n-public class BroadcastOptions {\n+public class BroadcastOptions extends ComponentOptions {\n     private long mTemporaryAppAllowlistDuration;\n     private @TempAllowListType int mTemporaryAppAllowlistType;\n     private @ReasonCode int mTemporaryAppAllowlistReasonCode;\n@@ -108,12 +108,14 @@ public class BroadcastOptions {\n     }\n \n     private BroadcastOptions() {\n+        super();\n         resetTemporaryAppAllowlist();\n     }\n \n     /** @hide */\n     @TestApi\n     public BroadcastOptions(@NonNull Bundle opts) {\n+        super(opts);\n         // Match the logic in toBundle().\n         if (opts.containsKey(KEY_TEMPORARY_APP_ALLOWLIST_DURATION)) {\n             mTemporaryAppAllowlistDuration = opts.getLong(KEY_TEMPORARY_APP_ALLOWLIST_DURATION);\n@@ -190,6 +192,24 @@ public class BroadcastOptions {\n         mTemporaryAppAllowlistReason = null;\n     }\n \n+    /**\n+     * Set PendingIntent activity is allowed to be started in the background if the caller\n+     * can start background activities.\n+     * @hide\n+     */\n+    public void setPendingIntentBackgroundActivityLaunchAllowed(boolean allowed) {\n+        super.setPendingIntentBackgroundActivityLaunchAllowed(allowed);\n+    }\n+\n+    /**\n+     * Get PendingIntent activity is allowed to be started in the background if the caller\n+     * can start background activities.\n+     * @hide\n+     */\n+    public boolean isPendingIntentBackgroundActivityLaunchAllowed() {\n+        return super.isPendingIntentBackgroundActivityLaunchAllowed();\n+    }\n+\n     /**\n      * Return {@link #setTemporaryAppAllowlist}.\n      * @hide\n@@ -308,8 +328,9 @@ public class BroadcastOptions {\n      * object; you must not modify it, but can supply it to the sendBroadcast\n      * methods that take an options Bundle.\n      */\n+    @Override\n     public Bundle toBundle() {\n-        Bundle b = new Bundle();\n+        Bundle b = super.toBundle();\n         if (isTemporaryAppAllowlistSet()) {\n             b.putLong(KEY_TEMPORARY_APP_ALLOWLIST_DURATION, mTemporaryAppAllowlistDuration);\n             b.putInt(KEY_TEMPORARY_APP_ALLOWLIST_TYPE, mTemporaryAppAllowlistType);\n",
    "added_lines": 23,
    "deleted_lines": 2,
    "changed_methods": "BroadcastOptions::toBundle, BroadcastOptions::BroadcastOptions, BroadcastOptions::setPendingIntentBackgroundActivityLaunchAllowed, BroadcastOptions::isPendingIntentBackgroundActivityLaunchAllowed, BroadcastOptions::BroadcastOptions"
   },
   {
    "filename": "ComponentOptions.java",
    "diff": "@@ -0,0 +1,83 @@\n+/*\n+ * Copyright (C) 2021 The Android Open Source Project\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package android.app;\n+\n+import android.os.Bundle;\n+\n+/**\n+ * @hide\n+ */\n+public class ComponentOptions {\n+\n+    /**\n+     * Default value for KEY_PENDING_INTENT_BACKGROUND_ACTIVITY_ALLOWED.\n+     * @hide\n+     **/\n+    public static final boolean PENDING_INTENT_BAL_ALLOWED_DEFAULT = true;\n+\n+    /**\n+     * PendingIntent caller allows activity start even if PendingIntent creator is in background.\n+     * This only works if the PendingIntent caller is allowed to start background activities,\n+     * for example if it's in the foreground, or has BAL permission.\n+     * @hide\n+     */\n+    public static final String KEY_PENDING_INTENT_BACKGROUND_ACTIVITY_ALLOWED =\n+            \"android.pendingIntent.backgroundActivityAllowed\";\n+\n+    private boolean mPendingIntentBalAllowed = PENDING_INTENT_BAL_ALLOWED_DEFAULT;\n+\n+    ComponentOptions() {\n+    }\n+\n+    ComponentOptions(Bundle opts) {\n+        // If the remote side sent us bad parcelables, they won't get the\n+        // results they want, which is their loss.\n+        opts.setDefusable(true);\n+        setPendingIntentBackgroundActivityLaunchAllowed(\n+                opts.getBoolean(KEY_PENDING_INTENT_BACKGROUND_ACTIVITY_ALLOWED,\n+                        PENDING_INTENT_BAL_ALLOWED_DEFAULT));\n+    }\n+\n+    /**\n+     * Set PendingIntent activity is allowed to be started in the background if the caller\n+     * can start background activities.\n+     *\n+     * @hide\n+     */\n+    public void setPendingIntentBackgroundActivityLaunchAllowed(boolean allowed) {\n+        mPendingIntentBalAllowed = allowed;\n+    }\n+\n+    /**\n+     * Get PendingIntent activity is allowed to be started in the background if the caller\n+     * can start background activities.\n+     *\n+     * @hide\n+     */\n+    public boolean isPendingIntentBackgroundActivityLaunchAllowed() {\n+        return mPendingIntentBalAllowed;\n+    }\n+\n+    /**\n+     * @hide\n+     */\n+    public Bundle toBundle() {\n+        Bundle bundle = new Bundle();\n+        bundle.putBoolean(KEY_PENDING_INTENT_BACKGROUND_ACTIVITY_ALLOWED, mPendingIntentBalAllowed);\n+        return bundle;\n+    }\n+}\n",
    "added_lines": 83,
    "deleted_lines": 0,
    "changed_methods": "ComponentOptions::toBundle, ComponentOptions::ComponentOptions, ComponentOptions::ComponentOptions, ComponentOptions::isPendingIntentBackgroundActivityLaunchAllowed, ComponentOptions::setPendingIntentBackgroundActivityLaunchAllowed"
   },
   {
    "filename": "PendingIntentRecord.java",
    "diff": "@@ -310,6 +310,25 @@ public final class PendingIntentRecord extends IIntentSender.Stub {\n                 requiredPermission, null, null, 0, 0, 0, options);\n     }\n \n+    /**\n+     * Return true if the activity options allows PendingIntent to use caller's BAL permission.\n+     */\n+    public static boolean isPendingIntentBalAllowedByCaller(\n+            @Nullable ActivityOptions activityOptions) {\n+        if (activityOptions == null) {\n+            return ActivityOptions.PENDING_INTENT_BAL_ALLOWED_DEFAULT;\n+        }\n+        return isPendingIntentBalAllowedByCaller(activityOptions.toBundle());\n+    }\n+\n+    private static boolean isPendingIntentBalAllowedByCaller(@Nullable Bundle options) {\n+        if (options == null) {\n+            return ActivityOptions.PENDING_INTENT_BAL_ALLOWED_DEFAULT;\n+        }\n+        return options.getBoolean(ActivityOptions.KEY_PENDING_INTENT_BACKGROUND_ACTIVITY_ALLOWED,\n+                ActivityOptions.PENDING_INTENT_BAL_ALLOWED_DEFAULT);\n+    }\n+\n     public int sendInner(int code, Intent intent, String resolvedType, IBinder allowlistToken,\n             IIntentReceiver finishedReceiver, String requiredPermission, IBinder resultTo,\n             String resultWho, int requestCode, int flagsMask, int flagsValues, Bundle options) {\n@@ -431,7 +450,8 @@ public final class PendingIntentRecord extends IIntentSender.Stub {\n             // temporarily allow receivers and services to open activities from background if the\n             // PendingIntent.send() caller was foreground at the time of sendInner() call\n             final boolean allowTrampoline = uid != callingUid\n-                    && controller.mAtmInternal.isUidForeground(callingUid);\n+                    && controller.mAtmInternal.isUidForeground(callingUid)\n+                    && isPendingIntentBalAllowedByCaller(options);\n \n             // note: we on purpose don't pass in the information about the PendingIntent's creator,\n             // like pid or ProcessRecord, to the ActivityTaskManagerInternal calls below, because\n",
    "added_lines": 21,
    "deleted_lines": 1,
    "changed_methods": "PendingIntentRecord::isPendingIntentBalAllowedByCaller, PendingIntentRecord::sendInner, PendingIntentRecord::isPendingIntentBalAllowedByCaller"
   },
   {
    "filename": "ActivityStarter.java",
    "diff": "@@ -989,6 +989,10 @@ class ActivityStarter {\n         abort |= !mService.getPermissionPolicyInternal().checkStartActivity(intent, callingUid,\n                 callingPackage);\n \n+        // Merge the two options bundles, while realCallerOptions takes precedence.\n+        ActivityOptions checkedOptions = options != null\n+                ? options.getOptions(intent, aInfo, callerApp, mSupervisor) : null;\n+\n         boolean restrictedBgActivity = false;\n         if (!abort) {\n             try {\n@@ -997,15 +1001,12 @@ class ActivityStarter {\n                 restrictedBgActivity = shouldAbortBackgroundActivityStart(callingUid,\n                         callingPid, callingPackage, realCallingUid, realCallingPid, callerApp,\n                         request.originatingPendingIntent, request.allowBackgroundActivityStart,\n-                        intent);\n+                        intent, checkedOptions);\n             } finally {\n                 Trace.traceEnd(Trace.TRACE_TAG_WINDOW_MANAGER);\n             }\n         }\n \n-        // Merge the two options bundles, while realCallerOptions takes precedence.\n-        ActivityOptions checkedOptions = options != null\n-                ? options.getOptions(intent, aInfo, callerApp, mSupervisor) : null;\n         if (request.allowPendingRemoteAnimationRegistryLookup) {\n             checkedOptions = mService.getActivityStartController()\n                     .getPendingRemoteAnimationRegistry()\n@@ -1247,7 +1248,7 @@ class ActivityStarter {\n     boolean shouldAbortBackgroundActivityStart(int callingUid, int callingPid,\n             final String callingPackage, int realCallingUid, int realCallingPid,\n             WindowProcessController callerApp, PendingIntentRecord originatingPendingIntent,\n-            boolean allowBackgroundActivityStart, Intent intent) {\n+            boolean allowBackgroundActivityStart, Intent intent, ActivityOptions checkedOptions) {\n         // don't abort for the most important UIDs\n         final int callingAppId = UserHandle.getAppId(callingUid);\n         if (callingUid == Process.ROOT_UID || callingAppId == Process.SYSTEM_UID\n@@ -1318,9 +1319,12 @@ class ActivityStarter {\n                 ? isCallingUidPersistentSystemProcess\n                 : (realCallingAppId == Process.SYSTEM_UID)\n                         || realCallingUidProcState <= ActivityManager.PROCESS_STATE_PERSISTENT_UI;\n-        if (realCallingUid != callingUid) {\n-            // don't abort if the realCallingUid has a visible window\n-            // TODO(b/171459802): We should check appSwitchAllowed also\n+\n+        // Legacy behavior allows to use caller foreground state to bypass BAL restriction.\n+        final boolean balAllowedByPiSender =\n+                PendingIntentRecord.isPendingIntentBalAllowedByCaller(checkedOptions);\n+\n+        if (balAllowedByPiSender && realCallingUid != callingUid) {\n             if (realCallingUidHasAnyVisibleWindow) {\n                 if (DEBUG_ACTIVITY_STARTS) {\n                     Slog.d(TAG, \"Activity start allowed: realCallingUid (\" + realCallingUid\n@@ -1393,9 +1397,9 @@ class ActivityStarter {\n         // If we don't have callerApp at this point, no caller was provided to startActivity().\n         // That's the case for PendingIntent-based starts, since the creator's process might not be\n         // up and alive. If that's the case, we retrieve the WindowProcessController for the send()\n-        // caller, so that we can make the decision based on its state.\n+        // caller if caller allows, so that we can make the decision based on its state.\n         int callerAppUid = callingUid;\n-        if (callerApp == null) {\n+        if (callerApp == null && balAllowedByPiSender) {\n             callerApp = mService.getProcessController(realCallingPid, realCallingUid);\n             callerAppUid = realCallingUid;\n         }\n",
    "added_lines": 14,
    "deleted_lines": 10,
    "changed_methods": "ActivityStarter::shouldAbortBackgroundActivityStart, ActivityStarter::shouldAbortBackgroundActivityStart, ActivityStarter::executeRequest"
   },
   {
    "filename": "ActivityTaskManagerService.java",
    "diff": "@@ -2114,7 +2114,7 @@ public class ActivityTaskManagerService extends IActivityTaskManager.Stub {\n         final ActivityStarter starter = getActivityStartController().obtainStarter(\n                 null /* intent */, \"moveTaskToFront\");\n         if (starter.shouldAbortBackgroundActivityStart(callingUid, callingPid, callingPackage, -1,\n-                -1, callerApp, null, false, null)) {\n+                -1, callerApp, null, false, null, null)) {\n             if (!isBackgroundActivityStartsEnabled()) {\n                 return;\n             }\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "ActivityTaskManagerService::moveTaskToFrontLocked"
   },
   {
    "filename": "AppTaskImpl.java",
    "diff": "@@ -108,7 +108,7 @@ class AppTaskImpl extends IAppTask.Stub {\n                 final ActivityStarter starter = mService.getActivityStartController().obtainStarter(\n                         null /* intent */, \"moveToFront\");\n                 if (starter.shouldAbortBackgroundActivityStart(callingUid, callingPid,\n-                        callingPackage, -1, -1, callerApp, null, false, null)) {\n+                        callingPackage, -1, -1, callerApp, null, false, null, null)) {\n                     if (!mService.isBackgroundActivityStartsEnabled()) {\n                         return;\n                     }\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "AppTaskImpl::moveToFront"
   },
   {
    "filename": "AlarmManagerServiceTest.java",
    "diff": "@@ -109,6 +109,7 @@ import static org.mockito.Mockito.times;\n \n import android.app.ActivityManager;\n import android.app.ActivityManagerInternal;\n+import android.app.ActivityOptions;\n import android.app.AlarmManager;\n import android.app.AppOpsManager;\n import android.app.BroadcastOptions;\n@@ -552,13 +553,23 @@ public class AlarmManagerServiceTest {\n \n \n     private PendingIntent getNewMockPendingIntent() {\n-        return getNewMockPendingIntent(TEST_CALLING_UID, TEST_CALLING_PACKAGE);\n+        return getNewMockPendingIntent(false);\n+    }\n+\n+    private PendingIntent getNewMockPendingIntent(boolean isActivity) {\n+        return getNewMockPendingIntent(TEST_CALLING_UID, TEST_CALLING_PACKAGE, isActivity);\n     }\n \n     private PendingIntent getNewMockPendingIntent(int creatorUid, String creatorPackage) {\n+        return getNewMockPendingIntent(creatorUid, creatorPackage, false);\n+    }\n+\n+    private PendingIntent getNewMockPendingIntent(int creatorUid, String creatorPackage,\n+            boolean isActivity) {\n         final PendingIntent mockPi = mock(PendingIntent.class, Answers.RETURNS_DEEP_STUBS);\n         when(mockPi.getCreatorUid()).thenReturn(creatorUid);\n         when(mockPi.getCreatorPackage()).thenReturn(creatorPackage);\n+        when(mockPi.isActivity()).thenReturn(isActivity);\n         return mockPi;\n     }\n \n@@ -2801,21 +2812,53 @@ public class AlarmManagerServiceTest {\n                 anyString()));\n     }\n \n-    @Test\n-    public void idleOptionsSentOnExpiration() throws Exception {\n+    private void optionsSentOnExpiration(boolean isActivity, Bundle idleOptions)\n+            throws Exception {\n         final long triggerTime = mNowElapsedTest + 5000;\n-        final PendingIntent alarmPi = getNewMockPendingIntent();\n-        final Bundle idleOptions = new Bundle();\n-        idleOptions.putChar(\"TEST_CHAR_KEY\", 'x');\n-        idleOptions.putInt(\"TEST_INT_KEY\", 53);\n+        final PendingIntent alarmPi = getNewMockPendingIntent(isActivity);\n         setTestAlarm(ELAPSED_REALTIME_WAKEUP, triggerTime, 0, alarmPi, 0, 0, TEST_CALLING_UID,\n                 idleOptions);\n \n         mNowElapsedTest = mTestTimer.getElapsed();\n         mTestTimer.expire();\n \n+        ArgumentCaptor<Bundle> bundleCaptor = ArgumentCaptor.forClass(Bundle.class);\n         verify(alarmPi).send(eq(mMockContext), eq(0), any(Intent.class),\n-                any(), any(Handler.class), isNull(), eq(idleOptions));\n+                any(), any(Handler.class), isNull(), bundleCaptor.capture());\n+        if (idleOptions != null) {\n+            assertEquals(idleOptions, bundleCaptor.getValue());\n+        } else {\n+            assertFalse(\"BAL flag needs to be false in alarm manager\",\n+                    bundleCaptor.getValue().getBoolean(\n+                            ActivityOptions.KEY_PENDING_INTENT_BACKGROUND_ACTIVITY_ALLOWED,\n+                            true));\n+        }\n+    }\n+\n+    @Test\n+    public void activityIdleOptionsSentOnExpiration() throws Exception {\n+        final Bundle idleOptions = new Bundle();\n+        idleOptions.putChar(\"TEST_CHAR_KEY\", 'x');\n+        idleOptions.putInt(\"TEST_INT_KEY\", 53);\n+        optionsSentOnExpiration(true, idleOptions);\n+    }\n+\n+    @Test\n+    public void broadcastIdleOptionsSentOnExpiration() throws Exception {\n+        final Bundle idleOptions = new Bundle();\n+        idleOptions.putChar(\"TEST_CHAR_KEY\", 'x');\n+        idleOptions.putInt(\"TEST_INT_KEY\", 53);\n+        optionsSentOnExpiration(false, idleOptions);\n+    }\n+\n+    @Test\n+    public void emptyActivityOptionsSentOnExpiration() throws Exception {\n+        optionsSentOnExpiration(true, null);\n+    }\n+\n+    @Test\n+    public void emptyBroadcastOptionsSentOnExpiration() throws Exception {\n+        optionsSentOnExpiration(false, null);\n     }\n \n     @Test\n",
    "added_lines": 51,
    "deleted_lines": 8,
    "changed_methods": "AlarmManagerServiceTest::getNewMockPendingIntent, AlarmManagerServiceTest::activityIdleOptionsSentOnExpiration, AlarmManagerServiceTest::emptyActivityOptionsSentOnExpiration, AlarmManagerServiceTest::getNewMockPendingIntent, AlarmManagerServiceTest::emptyBroadcastOptionsSentOnExpiration, AlarmManagerServiceTest::idleOptionsSentOnExpiration, AlarmManagerServiceTest::broadcastIdleOptionsSentOnExpiration, AlarmManagerServiceTest::getNewMockPendingIntent, AlarmManagerServiceTest::getNewMockPendingIntent, AlarmManagerServiceTest::optionsSentOnExpiration"
   }
  ]
 },
 {
  "hash": "af52e36a81099ffc43e898f74f1e8f70ec1de2e3",
  "commit": "[DO NOT MERGE] Backport BAL restrictions from T to S, this blocks apps from using Alarm\nManager to bypass BAL restrictions.\n\nTest: atest-src BackgroundActivityLaunchTest\nBug: 195756028\nChange-Id: I33112ff59d913d8a7244289fe1a43512844e902a\n(cherry picked from commit 7a41e2fbc983ce0083b288e9489288de60dc8d8b)\nMerged-In: I33112ff59d913d8a7244289fe1a43512844e902a",
  "files": [
   {
    "filename": "AlarmManagerService.java",
    "diff": "@@ -56,6 +56,7 @@ import android.annotation.NonNull;\n import android.annotation.UserIdInt;\n import android.app.Activity;\n import android.app.ActivityManagerInternal;\n+import android.app.ActivityOptions;\n import android.app.AlarmManager;\n import android.app.AppOpsManager;\n import android.app.BroadcastOptions;\n@@ -317,6 +318,8 @@ public class AlarmManagerService extends SystemService {\n     private final SparseBooleanArray mPendingSendNextAlarmClockChangedForUser =\n             new SparseBooleanArray();\n     private boolean mNextAlarmClockMayChange;\n+    ActivityOptions mActivityOptsRestrictBal = ActivityOptions.makeBasic();\n+    BroadcastOptions mBroadcastOptsRestrictBal = BroadcastOptions.makeBasic();\n \n     @GuardedBy(\"mLock\")\n     private final Runnable mAlarmClockUpdater = () -> mNextAlarmClockMayChange = true;\n@@ -1611,6 +1614,11 @@ public class AlarmManagerService extends SystemService {\n     @Override\n     public void onStart() {\n         mInjector.init();\n+        mOptsWithFgs.setPendingIntentBackgroundActivityLaunchAllowed(false);\n+        mOptsWithoutFgs.setPendingIntentBackgroundActivityLaunchAllowed(false);\n+        mOptsTimeBroadcast.setPendingIntentBackgroundActivityLaunchAllowed(false);\n+        mActivityOptsRestrictBal.setPendingIntentBackgroundActivityLaunchAllowed(false);\n+        mBroadcastOptsRestrictBal.setPendingIntentBackgroundActivityLaunchAllowed(false);\n         mMetricsHelper = new MetricsHelper(getContext(), mLock);\n \n         mListenerDeathRecipient = new IBinder.DeathRecipient() {\n@@ -4306,6 +4314,14 @@ public class AlarmManagerService extends SystemService {\n         return alarm.creatorUid;\n     }\n \n+    private Bundle getAlarmOperationBundle(Alarm alarm) {\n+        if (alarm.mIdleOptions != null) {\n+            return alarm.mIdleOptions;\n+        } else if (alarm.operation.isActivity()) {\n+            return mActivityOptsRestrictBal.toBundle();\n+        }\n+        return mBroadcastOptsRestrictBal.toBundle();\n+    }\n \n     @VisibleForTesting\n     class AlarmHandler extends Handler {\n@@ -4344,7 +4360,11 @@ public class AlarmManagerService extends SystemService {\n                     for (int i = 0; i < triggerList.size(); i++) {\n                         Alarm alarm = triggerList.get(i);\n                         try {\n-                            alarm.operation.send();\n+                            // Disallow AlarmManager to start random background activity.\n+                            final Bundle bundle = getAlarmOperationBundle(alarm);\n+                            alarm.operation.send(/* context */ null, /* code */0, /* intent */\n+                                    null, /* onFinished */null, /* handler */\n+                                    null, /* requiredPermission */ null, bundle);\n                         } catch (PendingIntent.CanceledException e) {\n                             if (alarm.repeatInterval > 0) {\n                                 // This IntentSender is no longer valid, but this\n@@ -4908,9 +4928,10 @@ public class AlarmManagerService extends SystemService {\n                     mSendCount++;\n \n                     try {\n+                        final Bundle bundle = getAlarmOperationBundle(alarm);\n                         alarm.operation.send(getContext(), 0,\n                                 mBackgroundIntent.putExtra(Intent.EXTRA_ALARM_COUNT, alarm.count),\n-                                mDeliveryTracker, mHandler, null, alarm.mIdleOptions);\n+                                mDeliveryTracker, mHandler, null, bundle);\n                     } catch (PendingIntent.CanceledException e) {\n                         if (alarm.repeatInterval > 0) {\n                             // This IntentSender is no longer valid, but this\n",
    "added_lines": 23,
    "deleted_lines": 2,
    "changed_methods": "AlarmManagerService::getAlarmOperationBundle, AlarmManagerService::DeliveryTracker::deliverLocked, AlarmManagerService::onStart, AlarmManagerService::AlarmHandler::handleMessage"
   },
   {
    "filename": "ActivityOptions.java",
    "diff": "@@ -69,7 +69,7 @@ import java.util.ArrayList;\n  * {@link android.content.Context#startActivity(android.content.Intent, android.os.Bundle)\n  * Context.startActivity(Intent, Bundle)} and related methods.\n  */\n-public class ActivityOptions {\n+public class ActivityOptions extends ComponentOptions {\n     private static final String TAG = \"ActivityOptions\";\n \n     /**\n@@ -1081,13 +1081,12 @@ public class ActivityOptions {\n     }\n \n     private ActivityOptions() {\n+        super();\n     }\n \n     /** @hide */\n     public ActivityOptions(Bundle opts) {\n-        // If the remote side sent us bad parcelables, they won't get the\n-        // results they want, which is their loss.\n-        opts.setDefusable(true);\n+        super(opts);\n \n         mPackageName = opts.getString(KEY_PACKAGE_NAME);\n         try {\n@@ -1832,8 +1831,9 @@ public class ActivityOptions {\n      * object; you must not modify it, but can supply it to the startActivity\n      * methods that take an options Bundle.\n      */\n+    @Override\n     public Bundle toBundle() {\n-        Bundle b = new Bundle();\n+        Bundle b = super.toBundle();\n         if (mPackageName != null) {\n             b.putString(KEY_PACKAGE_NAME, mPackageName);\n         }\n",
    "added_lines": 5,
    "deleted_lines": 5,
    "changed_methods": "ActivityOptions::ActivityOptions, ActivityOptions::ActivityOptions, ActivityOptions::toBundle"
   },
   {
    "filename": "BroadcastOptions.java",
    "diff": "@@ -34,7 +34,7 @@ import android.os.PowerExemptionManager.TempAllowListType;\n  * {@hide}\n  */\n @SystemApi\n-public class BroadcastOptions {\n+public class BroadcastOptions extends ComponentOptions {\n     private long mTemporaryAppAllowlistDuration;\n     private @TempAllowListType int mTemporaryAppAllowlistType;\n     private @ReasonCode int mTemporaryAppAllowlistReasonCode;\n@@ -108,12 +108,14 @@ public class BroadcastOptions {\n     }\n \n     private BroadcastOptions() {\n+        super();\n         resetTemporaryAppAllowlist();\n     }\n \n     /** @hide */\n     @TestApi\n     public BroadcastOptions(@NonNull Bundle opts) {\n+        super(opts);\n         // Match the logic in toBundle().\n         if (opts.containsKey(KEY_TEMPORARY_APP_ALLOWLIST_DURATION)) {\n             mTemporaryAppAllowlistDuration = opts.getLong(KEY_TEMPORARY_APP_ALLOWLIST_DURATION);\n@@ -190,6 +192,24 @@ public class BroadcastOptions {\n         mTemporaryAppAllowlistReason = null;\n     }\n \n+    /**\n+     * Set PendingIntent activity is allowed to be started in the background if the caller\n+     * can start background activities.\n+     * @hide\n+     */\n+    public void setPendingIntentBackgroundActivityLaunchAllowed(boolean allowed) {\n+        super.setPendingIntentBackgroundActivityLaunchAllowed(allowed);\n+    }\n+\n+    /**\n+     * Get PendingIntent activity is allowed to be started in the background if the caller\n+     * can start background activities.\n+     * @hide\n+     */\n+    public boolean isPendingIntentBackgroundActivityLaunchAllowed() {\n+        return super.isPendingIntentBackgroundActivityLaunchAllowed();\n+    }\n+\n     /**\n      * Return {@link #setTemporaryAppAllowlist}.\n      * @hide\n@@ -308,8 +328,9 @@ public class BroadcastOptions {\n      * object; you must not modify it, but can supply it to the sendBroadcast\n      * methods that take an options Bundle.\n      */\n+    @Override\n     public Bundle toBundle() {\n-        Bundle b = new Bundle();\n+        Bundle b = super.toBundle();\n         if (isTemporaryAppAllowlistSet()) {\n             b.putLong(KEY_TEMPORARY_APP_ALLOWLIST_DURATION, mTemporaryAppAllowlistDuration);\n             b.putInt(KEY_TEMPORARY_APP_ALLOWLIST_TYPE, mTemporaryAppAllowlistType);\n",
    "added_lines": 23,
    "deleted_lines": 2,
    "changed_methods": "BroadcastOptions::toBundle, BroadcastOptions::BroadcastOptions, BroadcastOptions::setPendingIntentBackgroundActivityLaunchAllowed, BroadcastOptions::isPendingIntentBackgroundActivityLaunchAllowed, BroadcastOptions::BroadcastOptions"
   },
   {
    "filename": "ComponentOptions.java",
    "diff": "@@ -0,0 +1,83 @@\n+/*\n+ * Copyright (C) 2021 The Android Open Source Project\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package android.app;\n+\n+import android.os.Bundle;\n+\n+/**\n+ * @hide\n+ */\n+public class ComponentOptions {\n+\n+    /**\n+     * Default value for KEY_PENDING_INTENT_BACKGROUND_ACTIVITY_ALLOWED.\n+     * @hide\n+     **/\n+    public static final boolean PENDING_INTENT_BAL_ALLOWED_DEFAULT = true;\n+\n+    /**\n+     * PendingIntent caller allows activity start even if PendingIntent creator is in background.\n+     * This only works if the PendingIntent caller is allowed to start background activities,\n+     * for example if it's in the foreground, or has BAL permission.\n+     * @hide\n+     */\n+    public static final String KEY_PENDING_INTENT_BACKGROUND_ACTIVITY_ALLOWED =\n+            \"android.pendingIntent.backgroundActivityAllowed\";\n+\n+    private boolean mPendingIntentBalAllowed = PENDING_INTENT_BAL_ALLOWED_DEFAULT;\n+\n+    ComponentOptions() {\n+    }\n+\n+    ComponentOptions(Bundle opts) {\n+        // If the remote side sent us bad parcelables, they won't get the\n+        // results they want, which is their loss.\n+        opts.setDefusable(true);\n+        setPendingIntentBackgroundActivityLaunchAllowed(\n+                opts.getBoolean(KEY_PENDING_INTENT_BACKGROUND_ACTIVITY_ALLOWED,\n+                        PENDING_INTENT_BAL_ALLOWED_DEFAULT));\n+    }\n+\n+    /**\n+     * Set PendingIntent activity is allowed to be started in the background if the caller\n+     * can start background activities.\n+     *\n+     * @hide\n+     */\n+    public void setPendingIntentBackgroundActivityLaunchAllowed(boolean allowed) {\n+        mPendingIntentBalAllowed = allowed;\n+    }\n+\n+    /**\n+     * Get PendingIntent activity is allowed to be started in the background if the caller\n+     * can start background activities.\n+     *\n+     * @hide\n+     */\n+    public boolean isPendingIntentBackgroundActivityLaunchAllowed() {\n+        return mPendingIntentBalAllowed;\n+    }\n+\n+    /**\n+     * @hide\n+     */\n+    public Bundle toBundle() {\n+        Bundle bundle = new Bundle();\n+        bundle.putBoolean(KEY_PENDING_INTENT_BACKGROUND_ACTIVITY_ALLOWED, mPendingIntentBalAllowed);\n+        return bundle;\n+    }\n+}\n",
    "added_lines": 83,
    "deleted_lines": 0,
    "changed_methods": "ComponentOptions::toBundle, ComponentOptions::ComponentOptions, ComponentOptions::ComponentOptions, ComponentOptions::isPendingIntentBackgroundActivityLaunchAllowed, ComponentOptions::setPendingIntentBackgroundActivityLaunchAllowed"
   },
   {
    "filename": "PendingIntentRecord.java",
    "diff": "@@ -310,6 +310,25 @@ public final class PendingIntentRecord extends IIntentSender.Stub {\n                 requiredPermission, null, null, 0, 0, 0, options);\n     }\n \n+    /**\n+     * Return true if the activity options allows PendingIntent to use caller's BAL permission.\n+     */\n+    public static boolean isPendingIntentBalAllowedByCaller(\n+            @Nullable ActivityOptions activityOptions) {\n+        if (activityOptions == null) {\n+            return ActivityOptions.PENDING_INTENT_BAL_ALLOWED_DEFAULT;\n+        }\n+        return isPendingIntentBalAllowedByCaller(activityOptions.toBundle());\n+    }\n+\n+    private static boolean isPendingIntentBalAllowedByCaller(@Nullable Bundle options) {\n+        if (options == null) {\n+            return ActivityOptions.PENDING_INTENT_BAL_ALLOWED_DEFAULT;\n+        }\n+        return options.getBoolean(ActivityOptions.KEY_PENDING_INTENT_BACKGROUND_ACTIVITY_ALLOWED,\n+                ActivityOptions.PENDING_INTENT_BAL_ALLOWED_DEFAULT);\n+    }\n+\n     public int sendInner(int code, Intent intent, String resolvedType, IBinder allowlistToken,\n             IIntentReceiver finishedReceiver, String requiredPermission, IBinder resultTo,\n             String resultWho, int requestCode, int flagsMask, int flagsValues, Bundle options) {\n@@ -431,7 +450,8 @@ public final class PendingIntentRecord extends IIntentSender.Stub {\n             // temporarily allow receivers and services to open activities from background if the\n             // PendingIntent.send() caller was foreground at the time of sendInner() call\n             final boolean allowTrampoline = uid != callingUid\n-                    && controller.mAtmInternal.isUidForeground(callingUid);\n+                    && controller.mAtmInternal.isUidForeground(callingUid)\n+                    && isPendingIntentBalAllowedByCaller(options);\n \n             // note: we on purpose don't pass in the information about the PendingIntent's creator,\n             // like pid or ProcessRecord, to the ActivityTaskManagerInternal calls below, because\n",
    "added_lines": 21,
    "deleted_lines": 1,
    "changed_methods": "PendingIntentRecord::isPendingIntentBalAllowedByCaller, PendingIntentRecord::sendInner, PendingIntentRecord::isPendingIntentBalAllowedByCaller"
   },
   {
    "filename": "ActivityStarter.java",
    "diff": "@@ -989,6 +989,10 @@ class ActivityStarter {\n         abort |= !mService.getPermissionPolicyInternal().checkStartActivity(intent, callingUid,\n                 callingPackage);\n \n+        // Merge the two options bundles, while realCallerOptions takes precedence.\n+        ActivityOptions checkedOptions = options != null\n+                ? options.getOptions(intent, aInfo, callerApp, mSupervisor) : null;\n+\n         boolean restrictedBgActivity = false;\n         if (!abort) {\n             try {\n@@ -997,15 +1001,12 @@ class ActivityStarter {\n                 restrictedBgActivity = shouldAbortBackgroundActivityStart(callingUid,\n                         callingPid, callingPackage, realCallingUid, realCallingPid, callerApp,\n                         request.originatingPendingIntent, request.allowBackgroundActivityStart,\n-                        intent);\n+                        intent, checkedOptions);\n             } finally {\n                 Trace.traceEnd(Trace.TRACE_TAG_WINDOW_MANAGER);\n             }\n         }\n \n-        // Merge the two options bundles, while realCallerOptions takes precedence.\n-        ActivityOptions checkedOptions = options != null\n-                ? options.getOptions(intent, aInfo, callerApp, mSupervisor) : null;\n         if (request.allowPendingRemoteAnimationRegistryLookup) {\n             checkedOptions = mService.getActivityStartController()\n                     .getPendingRemoteAnimationRegistry()\n@@ -1247,7 +1248,7 @@ class ActivityStarter {\n     boolean shouldAbortBackgroundActivityStart(int callingUid, int callingPid,\n             final String callingPackage, int realCallingUid, int realCallingPid,\n             WindowProcessController callerApp, PendingIntentRecord originatingPendingIntent,\n-            boolean allowBackgroundActivityStart, Intent intent) {\n+            boolean allowBackgroundActivityStart, Intent intent, ActivityOptions checkedOptions) {\n         // don't abort for the most important UIDs\n         final int callingAppId = UserHandle.getAppId(callingUid);\n         if (callingUid == Process.ROOT_UID || callingAppId == Process.SYSTEM_UID\n@@ -1318,9 +1319,12 @@ class ActivityStarter {\n                 ? isCallingUidPersistentSystemProcess\n                 : (realCallingAppId == Process.SYSTEM_UID)\n                         || realCallingUidProcState <= ActivityManager.PROCESS_STATE_PERSISTENT_UI;\n-        if (realCallingUid != callingUid) {\n-            // don't abort if the realCallingUid has a visible window\n-            // TODO(b/171459802): We should check appSwitchAllowed also\n+\n+        // Legacy behavior allows to use caller foreground state to bypass BAL restriction.\n+        final boolean balAllowedByPiSender =\n+                PendingIntentRecord.isPendingIntentBalAllowedByCaller(checkedOptions);\n+\n+        if (balAllowedByPiSender && realCallingUid != callingUid) {\n             if (realCallingUidHasAnyVisibleWindow) {\n                 if (DEBUG_ACTIVITY_STARTS) {\n                     Slog.d(TAG, \"Activity start allowed: realCallingUid (\" + realCallingUid\n@@ -1393,9 +1397,9 @@ class ActivityStarter {\n         // If we don't have callerApp at this point, no caller was provided to startActivity().\n         // That's the case for PendingIntent-based starts, since the creator's process might not be\n         // up and alive. If that's the case, we retrieve the WindowProcessController for the send()\n-        // caller, so that we can make the decision based on its state.\n+        // caller if caller allows, so that we can make the decision based on its state.\n         int callerAppUid = callingUid;\n-        if (callerApp == null) {\n+        if (callerApp == null && balAllowedByPiSender) {\n             callerApp = mService.getProcessController(realCallingPid, realCallingUid);\n             callerAppUid = realCallingUid;\n         }\n",
    "added_lines": 14,
    "deleted_lines": 10,
    "changed_methods": "ActivityStarter::shouldAbortBackgroundActivityStart, ActivityStarter::shouldAbortBackgroundActivityStart, ActivityStarter::executeRequest"
   },
   {
    "filename": "ActivityTaskManagerService.java",
    "diff": "@@ -2114,7 +2114,7 @@ public class ActivityTaskManagerService extends IActivityTaskManager.Stub {\n         final ActivityStarter starter = getActivityStartController().obtainStarter(\n                 null /* intent */, \"moveTaskToFront\");\n         if (starter.shouldAbortBackgroundActivityStart(callingUid, callingPid, callingPackage, -1,\n-                -1, callerApp, null, false, null)) {\n+                -1, callerApp, null, false, null, null)) {\n             if (!isBackgroundActivityStartsEnabled()) {\n                 return;\n             }\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "ActivityTaskManagerService::moveTaskToFrontLocked"
   },
   {
    "filename": "AppTaskImpl.java",
    "diff": "@@ -108,7 +108,7 @@ class AppTaskImpl extends IAppTask.Stub {\n                 final ActivityStarter starter = mService.getActivityStartController().obtainStarter(\n                         null /* intent */, \"moveToFront\");\n                 if (starter.shouldAbortBackgroundActivityStart(callingUid, callingPid,\n-                        callingPackage, -1, -1, callerApp, null, false, null)) {\n+                        callingPackage, -1, -1, callerApp, null, false, null, null)) {\n                     if (!mService.isBackgroundActivityStartsEnabled()) {\n                         return;\n                     }\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "AppTaskImpl::moveToFront"
   },
   {
    "filename": "AlarmManagerServiceTest.java",
    "diff": "@@ -109,6 +109,7 @@ import static org.mockito.Mockito.times;\n \n import android.app.ActivityManager;\n import android.app.ActivityManagerInternal;\n+import android.app.ActivityOptions;\n import android.app.AlarmManager;\n import android.app.AppOpsManager;\n import android.app.BroadcastOptions;\n@@ -552,13 +553,23 @@ public class AlarmManagerServiceTest {\n \n \n     private PendingIntent getNewMockPendingIntent() {\n-        return getNewMockPendingIntent(TEST_CALLING_UID, TEST_CALLING_PACKAGE);\n+        return getNewMockPendingIntent(false);\n+    }\n+\n+    private PendingIntent getNewMockPendingIntent(boolean isActivity) {\n+        return getNewMockPendingIntent(TEST_CALLING_UID, TEST_CALLING_PACKAGE, isActivity);\n     }\n \n     private PendingIntent getNewMockPendingIntent(int creatorUid, String creatorPackage) {\n+        return getNewMockPendingIntent(creatorUid, creatorPackage, false);\n+    }\n+\n+    private PendingIntent getNewMockPendingIntent(int creatorUid, String creatorPackage,\n+            boolean isActivity) {\n         final PendingIntent mockPi = mock(PendingIntent.class, Answers.RETURNS_DEEP_STUBS);\n         when(mockPi.getCreatorUid()).thenReturn(creatorUid);\n         when(mockPi.getCreatorPackage()).thenReturn(creatorPackage);\n+        when(mockPi.isActivity()).thenReturn(isActivity);\n         return mockPi;\n     }\n \n@@ -2801,21 +2812,53 @@ public class AlarmManagerServiceTest {\n                 anyString()));\n     }\n \n-    @Test\n-    public void idleOptionsSentOnExpiration() throws Exception {\n+    private void optionsSentOnExpiration(boolean isActivity, Bundle idleOptions)\n+            throws Exception {\n         final long triggerTime = mNowElapsedTest + 5000;\n-        final PendingIntent alarmPi = getNewMockPendingIntent();\n-        final Bundle idleOptions = new Bundle();\n-        idleOptions.putChar(\"TEST_CHAR_KEY\", 'x');\n-        idleOptions.putInt(\"TEST_INT_KEY\", 53);\n+        final PendingIntent alarmPi = getNewMockPendingIntent(isActivity);\n         setTestAlarm(ELAPSED_REALTIME_WAKEUP, triggerTime, 0, alarmPi, 0, 0, TEST_CALLING_UID,\n                 idleOptions);\n \n         mNowElapsedTest = mTestTimer.getElapsed();\n         mTestTimer.expire();\n \n+        ArgumentCaptor<Bundle> bundleCaptor = ArgumentCaptor.forClass(Bundle.class);\n         verify(alarmPi).send(eq(mMockContext), eq(0), any(Intent.class),\n-                any(), any(Handler.class), isNull(), eq(idleOptions));\n+                any(), any(Handler.class), isNull(), bundleCaptor.capture());\n+        if (idleOptions != null) {\n+            assertEquals(idleOptions, bundleCaptor.getValue());\n+        } else {\n+            assertFalse(\"BAL flag needs to be false in alarm manager\",\n+                    bundleCaptor.getValue().getBoolean(\n+                            ActivityOptions.KEY_PENDING_INTENT_BACKGROUND_ACTIVITY_ALLOWED,\n+                            true));\n+        }\n+    }\n+\n+    @Test\n+    public void activityIdleOptionsSentOnExpiration() throws Exception {\n+        final Bundle idleOptions = new Bundle();\n+        idleOptions.putChar(\"TEST_CHAR_KEY\", 'x');\n+        idleOptions.putInt(\"TEST_INT_KEY\", 53);\n+        optionsSentOnExpiration(true, idleOptions);\n+    }\n+\n+    @Test\n+    public void broadcastIdleOptionsSentOnExpiration() throws Exception {\n+        final Bundle idleOptions = new Bundle();\n+        idleOptions.putChar(\"TEST_CHAR_KEY\", 'x');\n+        idleOptions.putInt(\"TEST_INT_KEY\", 53);\n+        optionsSentOnExpiration(false, idleOptions);\n+    }\n+\n+    @Test\n+    public void emptyActivityOptionsSentOnExpiration() throws Exception {\n+        optionsSentOnExpiration(true, null);\n+    }\n+\n+    @Test\n+    public void emptyBroadcastOptionsSentOnExpiration() throws Exception {\n+        optionsSentOnExpiration(false, null);\n     }\n \n     @Test\n",
    "added_lines": 51,
    "deleted_lines": 8,
    "changed_methods": "AlarmManagerServiceTest::getNewMockPendingIntent, AlarmManagerServiceTest::activityIdleOptionsSentOnExpiration, AlarmManagerServiceTest::emptyActivityOptionsSentOnExpiration, AlarmManagerServiceTest::getNewMockPendingIntent, AlarmManagerServiceTest::emptyBroadcastOptionsSentOnExpiration, AlarmManagerServiceTest::idleOptionsSentOnExpiration, AlarmManagerServiceTest::broadcastIdleOptionsSentOnExpiration, AlarmManagerServiceTest::getNewMockPendingIntent, AlarmManagerServiceTest::getNewMockPendingIntent, AlarmManagerServiceTest::optionsSentOnExpiration"
   }
  ]
 },
 {
  "hash": "6d2f7829dd6e3fdcc6ebff0c2d9e16c3a069ad9d",
  "commit": "[RESTRICT AUTOMERGE] Strip part of the activity info of another uid if no privilege\n\nThe activity info could be from another uid which is different\nfrom the app that hosts the task. The information should be\ntrimmed if the caller app doesn't have the privilege.\n\nHowever, removing the entire info may result in app compatibility\nissues. So, only swiping the info that are sensitive to empty\nstring.\n\nBug: 243130512\nTest: verified market app locally\nTest: atest RecentTasksTest\nChange-Id: I5b6775dd3c4e2ccdacd30741884d336b2eaa70da\nMerged-In: I5b6775dd3c4e2ccdacd30741884d336b2eaa70da\n(cherry picked from commit 5ba72200f6a66b5da48c9c3abd103a73aea1ef95)\n(cherry picked from commit 7be9e6efb63884f8f4bb647e537a29746bbeb9fa)\nMerged-In: I5b6775dd3c4e2ccdacd30741884d336b2eaa70da",
  "files": [
   {
    "filename": "AppTaskImpl.java",
    "diff": "@@ -84,7 +84,7 @@ class AppTaskImpl extends IAppTask.Stub {\n                     throw new IllegalArgumentException(\"Unable to find task ID \" + mTaskId);\n                 }\n                 return mService.getRecentTasks().createRecentTaskInfo(task,\n-                        false /* stripExtras */);\n+                        false /* stripExtras */, true /* getTasksAllowed */);\n             } finally {\n                 Binder.restoreCallingIdentity(origId);\n             }\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "AppTaskImpl::getTaskInfo"
   },
   {
    "filename": "RecentTasks.java",
    "diff": "@@ -974,7 +974,7 @@ class RecentTasks {\n                 continue;\n             }\n \n-            res.add(createRecentTaskInfo(task, true /* stripExtras */));\n+            res.add(createRecentTaskInfo(task, true /* stripExtras */, getTasksAllowed));\n         }\n         return res;\n     }\n@@ -1890,7 +1890,8 @@ class RecentTasks {\n     /**\n      * Creates a new RecentTaskInfo from a Task.\n      */\n-    ActivityManager.RecentTaskInfo createRecentTaskInfo(Task tr, boolean stripExtras) {\n+    ActivityManager.RecentTaskInfo createRecentTaskInfo(Task tr, boolean stripExtras,\n+            boolean getTasksAllowed) {\n         final ActivityManager.RecentTaskInfo rti = new ActivityManager.RecentTaskInfo();\n         // If the recent Task is detached, we consider it will be re-attached to the default\n         // TaskDisplayArea because we currently only support recent overview in the default TDA.\n@@ -1902,6 +1903,9 @@ class RecentTasks {\n         rti.id = rti.isRunning ? rti.taskId : INVALID_TASK_ID;\n         rti.persistentId = rti.taskId;\n         rti.lastSnapshotData.set(tr.mLastTaskSnapshotData);\n+        if (!getTasksAllowed) {\n+            Task.trimIneffectiveInfo(tr, rti);\n+        }\n \n         // Fill in organized child task info for the task created by organizer.\n         if (tr.mCreatedByOrganizer) {\n",
    "added_lines": 6,
    "deleted_lines": 2,
    "changed_methods": "RecentTasks::createRecentTaskInfo, RecentTasks::getRecentTasksImpl, RecentTasks::createRecentTaskInfo"
   },
   {
    "filename": "RunningTasks.java",
    "diff": "@@ -150,6 +150,10 @@ class RunningTasks {\n         task.fillTaskInfo(rti, !mKeepIntentExtra);\n         // Fill in some deprecated values\n         rti.id = rti.taskId;\n+\n+        if (!mAllowed) {\n+            Task.trimIneffectiveInfo(task, rti);\n+        }\n         return rti;\n     }\n }\n",
    "added_lines": 4,
    "deleted_lines": 0,
    "changed_methods": "RunningTasks::createRunningTaskInfo"
   },
   {
    "filename": "Task.java",
    "diff": "@@ -3484,6 +3484,54 @@ class Task extends TaskFragment {\n         info.mTopActivityLocusId = topRecord != null ? topRecord.getLocusId() : null;\n     }\n \n+    /**\n+     * Removes the activity info if the activity belongs to a different uid, which is\n+     * different from the app that hosts the task.\n+     */\n+    static void trimIneffectiveInfo(Task task, TaskInfo info) {\n+        final ActivityRecord baseActivity = task.getActivity(r -> !r.finishing,\n+                false /* traverseTopToBottom */);\n+        final int baseActivityUid =\n+                baseActivity != null ? baseActivity.getUid() : task.effectiveUid;\n+\n+        if (info.topActivityInfo != null\n+                && task.effectiveUid != info.topActivityInfo.applicationInfo.uid) {\n+            // Making a copy to prevent eliminating the info in the original ActivityRecord.\n+            info.topActivityInfo = new ActivityInfo(info.topActivityInfo);\n+            info.topActivityInfo.applicationInfo =\n+                    new ApplicationInfo(info.topActivityInfo.applicationInfo);\n+\n+            // Strip the sensitive info.\n+            info.topActivity = new ComponentName(\"\", \"\");\n+            info.topActivityInfo.packageName = \"\";\n+            info.topActivityInfo.taskAffinity = \"\";\n+            info.topActivityInfo.processName = \"\";\n+            info.topActivityInfo.name = \"\";\n+            info.topActivityInfo.parentActivityName = \"\";\n+            info.topActivityInfo.targetActivity = \"\";\n+            info.topActivityInfo.splitName = \"\";\n+            info.topActivityInfo.applicationInfo.className = \"\";\n+            info.topActivityInfo.applicationInfo.credentialProtectedDataDir = \"\";\n+            info.topActivityInfo.applicationInfo.dataDir = \"\";\n+            info.topActivityInfo.applicationInfo.deviceProtectedDataDir = \"\";\n+            info.topActivityInfo.applicationInfo.manageSpaceActivityName = \"\";\n+            info.topActivityInfo.applicationInfo.nativeLibraryDir = \"\";\n+            info.topActivityInfo.applicationInfo.nativeLibraryRootDir = \"\";\n+            info.topActivityInfo.applicationInfo.processName = \"\";\n+            info.topActivityInfo.applicationInfo.publicSourceDir = \"\";\n+            info.topActivityInfo.applicationInfo.scanPublicSourceDir = \"\";\n+            info.topActivityInfo.applicationInfo.scanSourceDir = \"\";\n+            info.topActivityInfo.applicationInfo.sourceDir = \"\";\n+            info.topActivityInfo.applicationInfo.taskAffinity = \"\";\n+            info.topActivityInfo.applicationInfo.name = \"\";\n+            info.topActivityInfo.applicationInfo.packageName = \"\";\n+        }\n+\n+        if (task.effectiveUid != baseActivityUid) {\n+            info.baseActivity = new ComponentName(\"\", \"\");\n+        }\n+    }\n+\n     @Nullable PictureInPictureParams getPictureInPictureParams() {\n         return getPictureInPictureParams(getTopMostTask());\n     }\n",
    "added_lines": 48,
    "deleted_lines": 0,
    "changed_methods": "Task::trimIneffectiveInfo"
   },
   {
    "filename": "RecentTasksTest.java",
    "diff": "@@ -30,6 +30,7 @@ import static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;\n import static android.content.pm.ActivityInfo.LAUNCH_MULTIPLE;\n import static android.content.pm.ActivityInfo.LAUNCH_SINGLE_INSTANCE;\n import static android.content.res.Configuration.ORIENTATION_PORTRAIT;\n+import static android.os.Process.NOBODY_UID;\n \n import static com.android.dx.mockito.inline.extended.ExtendedMockito.doNothing;\n import static com.android.dx.mockito.inline.extended.ExtendedMockito.doReturn;\n@@ -1195,21 +1196,36 @@ public class RecentTasksTest extends WindowTestsBase {\n \n     @Test\n     public void testCreateRecentTaskInfo_detachedTask() {\n-        final Task task = createTaskBuilder(\".Task\").setCreateActivity(true).build();\n+        final Task task = createTaskBuilder(\".Task\").build();\n+        final ComponentName componentName = new ComponentName(\"com.foo\", \".BarActivity\");\n+        new ActivityBuilder(mSupervisor.mService)\n+                .setTask(task)\n+                .setUid(NOBODY_UID)\n+                .setComponent(componentName)\n+                .build();\n         final TaskDisplayArea tda = task.getDisplayArea();\n \n         assertTrue(task.isAttached());\n         assertTrue(task.supportsMultiWindow());\n \n-        RecentTaskInfo info = mRecentTasks.createRecentTaskInfo(task, true);\n+        RecentTaskInfo info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,\n+                true /* getTasksAllowed */);\n \n         assertTrue(info.supportsMultiWindow);\n         assertTrue(info.supportsSplitScreenMultiWindow);\n \n+        info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,\n+                false /* getTasksAllowed */);\n+\n+        assertFalse(info.topActivity.equals(componentName));\n+        assertFalse(info.topActivityInfo.packageName.equals(componentName.getPackageName()));\n+        assertFalse(info.baseActivity.equals(componentName));\n+\n         // The task can be put in split screen even if it is not attached now.\n         task.removeImmediately();\n \n-        info = mRecentTasks.createRecentTaskInfo(task, true);\n+        info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,\n+                true /* getTasksAllowed */);\n \n         assertTrue(info.supportsMultiWindow);\n         assertTrue(info.supportsSplitScreenMultiWindow);\n@@ -1219,7 +1235,8 @@ public class RecentTasksTest extends WindowTestsBase {\n         doReturn(false).when(tda).supportsNonResizableMultiWindow();\n         doReturn(false).when(task).isResizeable();\n \n-        info = mRecentTasks.createRecentTaskInfo(task, true);\n+        info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,\n+                true /* getTasksAllowed */);\n \n         assertFalse(info.supportsMultiWindow);\n         assertFalse(info.supportsSplitScreenMultiWindow);\n@@ -1228,7 +1245,8 @@ public class RecentTasksTest extends WindowTestsBase {\n         // the device supports it.\n         doReturn(true).when(tda).supportsNonResizableMultiWindow();\n \n-        info = mRecentTasks.createRecentTaskInfo(task, true);\n+        info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,\n+                true /* getTasksAllowed */);\n \n         assertTrue(info.supportsMultiWindow);\n         assertTrue(info.supportsSplitScreenMultiWindow);\n",
    "added_lines": 23,
    "deleted_lines": 5,
    "changed_methods": "RecentTasksTest::testCreateRecentTaskInfo_detachedTask"
   }
  ]
 },
 {
  "hash": "6d2f7829dd6e3fdcc6ebff0c2d9e16c3a069ad9d",
  "commit": "[RESTRICT AUTOMERGE] Strip part of the activity info of another uid if no privilege\n\nThe activity info could be from another uid which is different\nfrom the app that hosts the task. The information should be\ntrimmed if the caller app doesn't have the privilege.\n\nHowever, removing the entire info may result in app compatibility\nissues. So, only swiping the info that are sensitive to empty\nstring.\n\nBug: 243130512\nTest: verified market app locally\nTest: atest RecentTasksTest\nChange-Id: I5b6775dd3c4e2ccdacd30741884d336b2eaa70da\nMerged-In: I5b6775dd3c4e2ccdacd30741884d336b2eaa70da\n(cherry picked from commit 5ba72200f6a66b5da48c9c3abd103a73aea1ef95)\n(cherry picked from commit 7be9e6efb63884f8f4bb647e537a29746bbeb9fa)\nMerged-In: I5b6775dd3c4e2ccdacd30741884d336b2eaa70da",
  "files": [
   {
    "filename": "AppTaskImpl.java",
    "diff": "@@ -84,7 +84,7 @@ class AppTaskImpl extends IAppTask.Stub {\n                     throw new IllegalArgumentException(\"Unable to find task ID \" + mTaskId);\n                 }\n                 return mService.getRecentTasks().createRecentTaskInfo(task,\n-                        false /* stripExtras */);\n+                        false /* stripExtras */, true /* getTasksAllowed */);\n             } finally {\n                 Binder.restoreCallingIdentity(origId);\n             }\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "AppTaskImpl::getTaskInfo"
   },
   {
    "filename": "RecentTasks.java",
    "diff": "@@ -974,7 +974,7 @@ class RecentTasks {\n                 continue;\n             }\n \n-            res.add(createRecentTaskInfo(task, true /* stripExtras */));\n+            res.add(createRecentTaskInfo(task, true /* stripExtras */, getTasksAllowed));\n         }\n         return res;\n     }\n@@ -1890,7 +1890,8 @@ class RecentTasks {\n     /**\n      * Creates a new RecentTaskInfo from a Task.\n      */\n-    ActivityManager.RecentTaskInfo createRecentTaskInfo(Task tr, boolean stripExtras) {\n+    ActivityManager.RecentTaskInfo createRecentTaskInfo(Task tr, boolean stripExtras,\n+            boolean getTasksAllowed) {\n         final ActivityManager.RecentTaskInfo rti = new ActivityManager.RecentTaskInfo();\n         // If the recent Task is detached, we consider it will be re-attached to the default\n         // TaskDisplayArea because we currently only support recent overview in the default TDA.\n@@ -1902,6 +1903,9 @@ class RecentTasks {\n         rti.id = rti.isRunning ? rti.taskId : INVALID_TASK_ID;\n         rti.persistentId = rti.taskId;\n         rti.lastSnapshotData.set(tr.mLastTaskSnapshotData);\n+        if (!getTasksAllowed) {\n+            Task.trimIneffectiveInfo(tr, rti);\n+        }\n \n         // Fill in organized child task info for the task created by organizer.\n         if (tr.mCreatedByOrganizer) {\n",
    "added_lines": 6,
    "deleted_lines": 2,
    "changed_methods": "RecentTasks::createRecentTaskInfo, RecentTasks::getRecentTasksImpl, RecentTasks::createRecentTaskInfo"
   },
   {
    "filename": "RunningTasks.java",
    "diff": "@@ -150,6 +150,10 @@ class RunningTasks {\n         task.fillTaskInfo(rti, !mKeepIntentExtra);\n         // Fill in some deprecated values\n         rti.id = rti.taskId;\n+\n+        if (!mAllowed) {\n+            Task.trimIneffectiveInfo(task, rti);\n+        }\n         return rti;\n     }\n }\n",
    "added_lines": 4,
    "deleted_lines": 0,
    "changed_methods": "RunningTasks::createRunningTaskInfo"
   },
   {
    "filename": "Task.java",
    "diff": "@@ -3484,6 +3484,54 @@ class Task extends TaskFragment {\n         info.mTopActivityLocusId = topRecord != null ? topRecord.getLocusId() : null;\n     }\n \n+    /**\n+     * Removes the activity info if the activity belongs to a different uid, which is\n+     * different from the app that hosts the task.\n+     */\n+    static void trimIneffectiveInfo(Task task, TaskInfo info) {\n+        final ActivityRecord baseActivity = task.getActivity(r -> !r.finishing,\n+                false /* traverseTopToBottom */);\n+        final int baseActivityUid =\n+                baseActivity != null ? baseActivity.getUid() : task.effectiveUid;\n+\n+        if (info.topActivityInfo != null\n+                && task.effectiveUid != info.topActivityInfo.applicationInfo.uid) {\n+            // Making a copy to prevent eliminating the info in the original ActivityRecord.\n+            info.topActivityInfo = new ActivityInfo(info.topActivityInfo);\n+            info.topActivityInfo.applicationInfo =\n+                    new ApplicationInfo(info.topActivityInfo.applicationInfo);\n+\n+            // Strip the sensitive info.\n+            info.topActivity = new ComponentName(\"\", \"\");\n+            info.topActivityInfo.packageName = \"\";\n+            info.topActivityInfo.taskAffinity = \"\";\n+            info.topActivityInfo.processName = \"\";\n+            info.topActivityInfo.name = \"\";\n+            info.topActivityInfo.parentActivityName = \"\";\n+            info.topActivityInfo.targetActivity = \"\";\n+            info.topActivityInfo.splitName = \"\";\n+            info.topActivityInfo.applicationInfo.className = \"\";\n+            info.topActivityInfo.applicationInfo.credentialProtectedDataDir = \"\";\n+            info.topActivityInfo.applicationInfo.dataDir = \"\";\n+            info.topActivityInfo.applicationInfo.deviceProtectedDataDir = \"\";\n+            info.topActivityInfo.applicationInfo.manageSpaceActivityName = \"\";\n+            info.topActivityInfo.applicationInfo.nativeLibraryDir = \"\";\n+            info.topActivityInfo.applicationInfo.nativeLibraryRootDir = \"\";\n+            info.topActivityInfo.applicationInfo.processName = \"\";\n+            info.topActivityInfo.applicationInfo.publicSourceDir = \"\";\n+            info.topActivityInfo.applicationInfo.scanPublicSourceDir = \"\";\n+            info.topActivityInfo.applicationInfo.scanSourceDir = \"\";\n+            info.topActivityInfo.applicationInfo.sourceDir = \"\";\n+            info.topActivityInfo.applicationInfo.taskAffinity = \"\";\n+            info.topActivityInfo.applicationInfo.name = \"\";\n+            info.topActivityInfo.applicationInfo.packageName = \"\";\n+        }\n+\n+        if (task.effectiveUid != baseActivityUid) {\n+            info.baseActivity = new ComponentName(\"\", \"\");\n+        }\n+    }\n+\n     @Nullable PictureInPictureParams getPictureInPictureParams() {\n         return getPictureInPictureParams(getTopMostTask());\n     }\n",
    "added_lines": 48,
    "deleted_lines": 0,
    "changed_methods": "Task::trimIneffectiveInfo"
   },
   {
    "filename": "RecentTasksTest.java",
    "diff": "@@ -30,6 +30,7 @@ import static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;\n import static android.content.pm.ActivityInfo.LAUNCH_MULTIPLE;\n import static android.content.pm.ActivityInfo.LAUNCH_SINGLE_INSTANCE;\n import static android.content.res.Configuration.ORIENTATION_PORTRAIT;\n+import static android.os.Process.NOBODY_UID;\n \n import static com.android.dx.mockito.inline.extended.ExtendedMockito.doNothing;\n import static com.android.dx.mockito.inline.extended.ExtendedMockito.doReturn;\n@@ -1195,21 +1196,36 @@ public class RecentTasksTest extends WindowTestsBase {\n \n     @Test\n     public void testCreateRecentTaskInfo_detachedTask() {\n-        final Task task = createTaskBuilder(\".Task\").setCreateActivity(true).build();\n+        final Task task = createTaskBuilder(\".Task\").build();\n+        final ComponentName componentName = new ComponentName(\"com.foo\", \".BarActivity\");\n+        new ActivityBuilder(mSupervisor.mService)\n+                .setTask(task)\n+                .setUid(NOBODY_UID)\n+                .setComponent(componentName)\n+                .build();\n         final TaskDisplayArea tda = task.getDisplayArea();\n \n         assertTrue(task.isAttached());\n         assertTrue(task.supportsMultiWindow());\n \n-        RecentTaskInfo info = mRecentTasks.createRecentTaskInfo(task, true);\n+        RecentTaskInfo info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,\n+                true /* getTasksAllowed */);\n \n         assertTrue(info.supportsMultiWindow);\n         assertTrue(info.supportsSplitScreenMultiWindow);\n \n+        info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,\n+                false /* getTasksAllowed */);\n+\n+        assertFalse(info.topActivity.equals(componentName));\n+        assertFalse(info.topActivityInfo.packageName.equals(componentName.getPackageName()));\n+        assertFalse(info.baseActivity.equals(componentName));\n+\n         // The task can be put in split screen even if it is not attached now.\n         task.removeImmediately();\n \n-        info = mRecentTasks.createRecentTaskInfo(task, true);\n+        info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,\n+                true /* getTasksAllowed */);\n \n         assertTrue(info.supportsMultiWindow);\n         assertTrue(info.supportsSplitScreenMultiWindow);\n@@ -1219,7 +1235,8 @@ public class RecentTasksTest extends WindowTestsBase {\n         doReturn(false).when(tda).supportsNonResizableMultiWindow();\n         doReturn(false).when(task).isResizeable();\n \n-        info = mRecentTasks.createRecentTaskInfo(task, true);\n+        info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,\n+                true /* getTasksAllowed */);\n \n         assertFalse(info.supportsMultiWindow);\n         assertFalse(info.supportsSplitScreenMultiWindow);\n@@ -1228,7 +1245,8 @@ public class RecentTasksTest extends WindowTestsBase {\n         // the device supports it.\n         doReturn(true).when(tda).supportsNonResizableMultiWindow();\n \n-        info = mRecentTasks.createRecentTaskInfo(task, true);\n+        info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,\n+                true /* getTasksAllowed */);\n \n         assertTrue(info.supportsMultiWindow);\n         assertTrue(info.supportsSplitScreenMultiWindow);\n",
    "added_lines": 23,
    "deleted_lines": 5,
    "changed_methods": "RecentTasksTest::testCreateRecentTaskInfo_detachedTask"
   }
  ]
 },
 {
  "hash": "6d2f7829dd6e3fdcc6ebff0c2d9e16c3a069ad9d",
  "commit": "[RESTRICT AUTOMERGE] Strip part of the activity info of another uid if no privilege\n\nThe activity info could be from another uid which is different\nfrom the app that hosts the task. The information should be\ntrimmed if the caller app doesn't have the privilege.\n\nHowever, removing the entire info may result in app compatibility\nissues. So, only swiping the info that are sensitive to empty\nstring.\n\nBug: 243130512\nTest: verified market app locally\nTest: atest RecentTasksTest\nChange-Id: I5b6775dd3c4e2ccdacd30741884d336b2eaa70da\nMerged-In: I5b6775dd3c4e2ccdacd30741884d336b2eaa70da\n(cherry picked from commit 5ba72200f6a66b5da48c9c3abd103a73aea1ef95)\n(cherry picked from commit 7be9e6efb63884f8f4bb647e537a29746bbeb9fa)\nMerged-In: I5b6775dd3c4e2ccdacd30741884d336b2eaa70da",
  "files": [
   {
    "filename": "AppTaskImpl.java",
    "diff": "@@ -84,7 +84,7 @@ class AppTaskImpl extends IAppTask.Stub {\n                     throw new IllegalArgumentException(\"Unable to find task ID \" + mTaskId);\n                 }\n                 return mService.getRecentTasks().createRecentTaskInfo(task,\n-                        false /* stripExtras */);\n+                        false /* stripExtras */, true /* getTasksAllowed */);\n             } finally {\n                 Binder.restoreCallingIdentity(origId);\n             }\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "AppTaskImpl::getTaskInfo"
   },
   {
    "filename": "RecentTasks.java",
    "diff": "@@ -974,7 +974,7 @@ class RecentTasks {\n                 continue;\n             }\n \n-            res.add(createRecentTaskInfo(task, true /* stripExtras */));\n+            res.add(createRecentTaskInfo(task, true /* stripExtras */, getTasksAllowed));\n         }\n         return res;\n     }\n@@ -1890,7 +1890,8 @@ class RecentTasks {\n     /**\n      * Creates a new RecentTaskInfo from a Task.\n      */\n-    ActivityManager.RecentTaskInfo createRecentTaskInfo(Task tr, boolean stripExtras) {\n+    ActivityManager.RecentTaskInfo createRecentTaskInfo(Task tr, boolean stripExtras,\n+            boolean getTasksAllowed) {\n         final ActivityManager.RecentTaskInfo rti = new ActivityManager.RecentTaskInfo();\n         // If the recent Task is detached, we consider it will be re-attached to the default\n         // TaskDisplayArea because we currently only support recent overview in the default TDA.\n@@ -1902,6 +1903,9 @@ class RecentTasks {\n         rti.id = rti.isRunning ? rti.taskId : INVALID_TASK_ID;\n         rti.persistentId = rti.taskId;\n         rti.lastSnapshotData.set(tr.mLastTaskSnapshotData);\n+        if (!getTasksAllowed) {\n+            Task.trimIneffectiveInfo(tr, rti);\n+        }\n \n         // Fill in organized child task info for the task created by organizer.\n         if (tr.mCreatedByOrganizer) {\n",
    "added_lines": 6,
    "deleted_lines": 2,
    "changed_methods": "RecentTasks::createRecentTaskInfo, RecentTasks::getRecentTasksImpl, RecentTasks::createRecentTaskInfo"
   },
   {
    "filename": "RunningTasks.java",
    "diff": "@@ -150,6 +150,10 @@ class RunningTasks {\n         task.fillTaskInfo(rti, !mKeepIntentExtra);\n         // Fill in some deprecated values\n         rti.id = rti.taskId;\n+\n+        if (!mAllowed) {\n+            Task.trimIneffectiveInfo(task, rti);\n+        }\n         return rti;\n     }\n }\n",
    "added_lines": 4,
    "deleted_lines": 0,
    "changed_methods": "RunningTasks::createRunningTaskInfo"
   },
   {
    "filename": "Task.java",
    "diff": "@@ -3484,6 +3484,54 @@ class Task extends TaskFragment {\n         info.mTopActivityLocusId = topRecord != null ? topRecord.getLocusId() : null;\n     }\n \n+    /**\n+     * Removes the activity info if the activity belongs to a different uid, which is\n+     * different from the app that hosts the task.\n+     */\n+    static void trimIneffectiveInfo(Task task, TaskInfo info) {\n+        final ActivityRecord baseActivity = task.getActivity(r -> !r.finishing,\n+                false /* traverseTopToBottom */);\n+        final int baseActivityUid =\n+                baseActivity != null ? baseActivity.getUid() : task.effectiveUid;\n+\n+        if (info.topActivityInfo != null\n+                && task.effectiveUid != info.topActivityInfo.applicationInfo.uid) {\n+            // Making a copy to prevent eliminating the info in the original ActivityRecord.\n+            info.topActivityInfo = new ActivityInfo(info.topActivityInfo);\n+            info.topActivityInfo.applicationInfo =\n+                    new ApplicationInfo(info.topActivityInfo.applicationInfo);\n+\n+            // Strip the sensitive info.\n+            info.topActivity = new ComponentName(\"\", \"\");\n+            info.topActivityInfo.packageName = \"\";\n+            info.topActivityInfo.taskAffinity = \"\";\n+            info.topActivityInfo.processName = \"\";\n+            info.topActivityInfo.name = \"\";\n+            info.topActivityInfo.parentActivityName = \"\";\n+            info.topActivityInfo.targetActivity = \"\";\n+            info.topActivityInfo.splitName = \"\";\n+            info.topActivityInfo.applicationInfo.className = \"\";\n+            info.topActivityInfo.applicationInfo.credentialProtectedDataDir = \"\";\n+            info.topActivityInfo.applicationInfo.dataDir = \"\";\n+            info.topActivityInfo.applicationInfo.deviceProtectedDataDir = \"\";\n+            info.topActivityInfo.applicationInfo.manageSpaceActivityName = \"\";\n+            info.topActivityInfo.applicationInfo.nativeLibraryDir = \"\";\n+            info.topActivityInfo.applicationInfo.nativeLibraryRootDir = \"\";\n+            info.topActivityInfo.applicationInfo.processName = \"\";\n+            info.topActivityInfo.applicationInfo.publicSourceDir = \"\";\n+            info.topActivityInfo.applicationInfo.scanPublicSourceDir = \"\";\n+            info.topActivityInfo.applicationInfo.scanSourceDir = \"\";\n+            info.topActivityInfo.applicationInfo.sourceDir = \"\";\n+            info.topActivityInfo.applicationInfo.taskAffinity = \"\";\n+            info.topActivityInfo.applicationInfo.name = \"\";\n+            info.topActivityInfo.applicationInfo.packageName = \"\";\n+        }\n+\n+        if (task.effectiveUid != baseActivityUid) {\n+            info.baseActivity = new ComponentName(\"\", \"\");\n+        }\n+    }\n+\n     @Nullable PictureInPictureParams getPictureInPictureParams() {\n         return getPictureInPictureParams(getTopMostTask());\n     }\n",
    "added_lines": 48,
    "deleted_lines": 0,
    "changed_methods": "Task::trimIneffectiveInfo"
   },
   {
    "filename": "RecentTasksTest.java",
    "diff": "@@ -30,6 +30,7 @@ import static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;\n import static android.content.pm.ActivityInfo.LAUNCH_MULTIPLE;\n import static android.content.pm.ActivityInfo.LAUNCH_SINGLE_INSTANCE;\n import static android.content.res.Configuration.ORIENTATION_PORTRAIT;\n+import static android.os.Process.NOBODY_UID;\n \n import static com.android.dx.mockito.inline.extended.ExtendedMockito.doNothing;\n import static com.android.dx.mockito.inline.extended.ExtendedMockito.doReturn;\n@@ -1195,21 +1196,36 @@ public class RecentTasksTest extends WindowTestsBase {\n \n     @Test\n     public void testCreateRecentTaskInfo_detachedTask() {\n-        final Task task = createTaskBuilder(\".Task\").setCreateActivity(true).build();\n+        final Task task = createTaskBuilder(\".Task\").build();\n+        final ComponentName componentName = new ComponentName(\"com.foo\", \".BarActivity\");\n+        new ActivityBuilder(mSupervisor.mService)\n+                .setTask(task)\n+                .setUid(NOBODY_UID)\n+                .setComponent(componentName)\n+                .build();\n         final TaskDisplayArea tda = task.getDisplayArea();\n \n         assertTrue(task.isAttached());\n         assertTrue(task.supportsMultiWindow());\n \n-        RecentTaskInfo info = mRecentTasks.createRecentTaskInfo(task, true);\n+        RecentTaskInfo info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,\n+                true /* getTasksAllowed */);\n \n         assertTrue(info.supportsMultiWindow);\n         assertTrue(info.supportsSplitScreenMultiWindow);\n \n+        info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,\n+                false /* getTasksAllowed */);\n+\n+        assertFalse(info.topActivity.equals(componentName));\n+        assertFalse(info.topActivityInfo.packageName.equals(componentName.getPackageName()));\n+        assertFalse(info.baseActivity.equals(componentName));\n+\n         // The task can be put in split screen even if it is not attached now.\n         task.removeImmediately();\n \n-        info = mRecentTasks.createRecentTaskInfo(task, true);\n+        info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,\n+                true /* getTasksAllowed */);\n \n         assertTrue(info.supportsMultiWindow);\n         assertTrue(info.supportsSplitScreenMultiWindow);\n@@ -1219,7 +1235,8 @@ public class RecentTasksTest extends WindowTestsBase {\n         doReturn(false).when(tda).supportsNonResizableMultiWindow();\n         doReturn(false).when(task).isResizeable();\n \n-        info = mRecentTasks.createRecentTaskInfo(task, true);\n+        info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,\n+                true /* getTasksAllowed */);\n \n         assertFalse(info.supportsMultiWindow);\n         assertFalse(info.supportsSplitScreenMultiWindow);\n@@ -1228,7 +1245,8 @@ public class RecentTasksTest extends WindowTestsBase {\n         // the device supports it.\n         doReturn(true).when(tda).supportsNonResizableMultiWindow();\n \n-        info = mRecentTasks.createRecentTaskInfo(task, true);\n+        info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,\n+                true /* getTasksAllowed */);\n \n         assertTrue(info.supportsMultiWindow);\n         assertTrue(info.supportsSplitScreenMultiWindow);\n",
    "added_lines": 23,
    "deleted_lines": 5,
    "changed_methods": "RecentTasksTest::testCreateRecentTaskInfo_detachedTask"
   }
  ]
 },
 {
  "hash": "6d2f7829dd6e3fdcc6ebff0c2d9e16c3a069ad9d",
  "commit": "[RESTRICT AUTOMERGE] Strip part of the activity info of another uid if no privilege\n\nThe activity info could be from another uid which is different\nfrom the app that hosts the task. The information should be\ntrimmed if the caller app doesn't have the privilege.\n\nHowever, removing the entire info may result in app compatibility\nissues. So, only swiping the info that are sensitive to empty\nstring.\n\nBug: 243130512\nTest: verified market app locally\nTest: atest RecentTasksTest\nChange-Id: I5b6775dd3c4e2ccdacd30741884d336b2eaa70da\nMerged-In: I5b6775dd3c4e2ccdacd30741884d336b2eaa70da\n(cherry picked from commit 5ba72200f6a66b5da48c9c3abd103a73aea1ef95)\n(cherry picked from commit 7be9e6efb63884f8f4bb647e537a29746bbeb9fa)\nMerged-In: I5b6775dd3c4e2ccdacd30741884d336b2eaa70da",
  "files": [
   {
    "filename": "AppTaskImpl.java",
    "diff": "@@ -84,7 +84,7 @@ class AppTaskImpl extends IAppTask.Stub {\n                     throw new IllegalArgumentException(\"Unable to find task ID \" + mTaskId);\n                 }\n                 return mService.getRecentTasks().createRecentTaskInfo(task,\n-                        false /* stripExtras */);\n+                        false /* stripExtras */, true /* getTasksAllowed */);\n             } finally {\n                 Binder.restoreCallingIdentity(origId);\n             }\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "AppTaskImpl::getTaskInfo"
   },
   {
    "filename": "RecentTasks.java",
    "diff": "@@ -974,7 +974,7 @@ class RecentTasks {\n                 continue;\n             }\n \n-            res.add(createRecentTaskInfo(task, true /* stripExtras */));\n+            res.add(createRecentTaskInfo(task, true /* stripExtras */, getTasksAllowed));\n         }\n         return res;\n     }\n@@ -1890,7 +1890,8 @@ class RecentTasks {\n     /**\n      * Creates a new RecentTaskInfo from a Task.\n      */\n-    ActivityManager.RecentTaskInfo createRecentTaskInfo(Task tr, boolean stripExtras) {\n+    ActivityManager.RecentTaskInfo createRecentTaskInfo(Task tr, boolean stripExtras,\n+            boolean getTasksAllowed) {\n         final ActivityManager.RecentTaskInfo rti = new ActivityManager.RecentTaskInfo();\n         // If the recent Task is detached, we consider it will be re-attached to the default\n         // TaskDisplayArea because we currently only support recent overview in the default TDA.\n@@ -1902,6 +1903,9 @@ class RecentTasks {\n         rti.id = rti.isRunning ? rti.taskId : INVALID_TASK_ID;\n         rti.persistentId = rti.taskId;\n         rti.lastSnapshotData.set(tr.mLastTaskSnapshotData);\n+        if (!getTasksAllowed) {\n+            Task.trimIneffectiveInfo(tr, rti);\n+        }\n \n         // Fill in organized child task info for the task created by organizer.\n         if (tr.mCreatedByOrganizer) {\n",
    "added_lines": 6,
    "deleted_lines": 2,
    "changed_methods": "RecentTasks::createRecentTaskInfo, RecentTasks::getRecentTasksImpl, RecentTasks::createRecentTaskInfo"
   },
   {
    "filename": "RunningTasks.java",
    "diff": "@@ -150,6 +150,10 @@ class RunningTasks {\n         task.fillTaskInfo(rti, !mKeepIntentExtra);\n         // Fill in some deprecated values\n         rti.id = rti.taskId;\n+\n+        if (!mAllowed) {\n+            Task.trimIneffectiveInfo(task, rti);\n+        }\n         return rti;\n     }\n }\n",
    "added_lines": 4,
    "deleted_lines": 0,
    "changed_methods": "RunningTasks::createRunningTaskInfo"
   },
   {
    "filename": "Task.java",
    "diff": "@@ -3484,6 +3484,54 @@ class Task extends TaskFragment {\n         info.mTopActivityLocusId = topRecord != null ? topRecord.getLocusId() : null;\n     }\n \n+    /**\n+     * Removes the activity info if the activity belongs to a different uid, which is\n+     * different from the app that hosts the task.\n+     */\n+    static void trimIneffectiveInfo(Task task, TaskInfo info) {\n+        final ActivityRecord baseActivity = task.getActivity(r -> !r.finishing,\n+                false /* traverseTopToBottom */);\n+        final int baseActivityUid =\n+                baseActivity != null ? baseActivity.getUid() : task.effectiveUid;\n+\n+        if (info.topActivityInfo != null\n+                && task.effectiveUid != info.topActivityInfo.applicationInfo.uid) {\n+            // Making a copy to prevent eliminating the info in the original ActivityRecord.\n+            info.topActivityInfo = new ActivityInfo(info.topActivityInfo);\n+            info.topActivityInfo.applicationInfo =\n+                    new ApplicationInfo(info.topActivityInfo.applicationInfo);\n+\n+            // Strip the sensitive info.\n+            info.topActivity = new ComponentName(\"\", \"\");\n+            info.topActivityInfo.packageName = \"\";\n+            info.topActivityInfo.taskAffinity = \"\";\n+            info.topActivityInfo.processName = \"\";\n+            info.topActivityInfo.name = \"\";\n+            info.topActivityInfo.parentActivityName = \"\";\n+            info.topActivityInfo.targetActivity = \"\";\n+            info.topActivityInfo.splitName = \"\";\n+            info.topActivityInfo.applicationInfo.className = \"\";\n+            info.topActivityInfo.applicationInfo.credentialProtectedDataDir = \"\";\n+            info.topActivityInfo.applicationInfo.dataDir = \"\";\n+            info.topActivityInfo.applicationInfo.deviceProtectedDataDir = \"\";\n+            info.topActivityInfo.applicationInfo.manageSpaceActivityName = \"\";\n+            info.topActivityInfo.applicationInfo.nativeLibraryDir = \"\";\n+            info.topActivityInfo.applicationInfo.nativeLibraryRootDir = \"\";\n+            info.topActivityInfo.applicationInfo.processName = \"\";\n+            info.topActivityInfo.applicationInfo.publicSourceDir = \"\";\n+            info.topActivityInfo.applicationInfo.scanPublicSourceDir = \"\";\n+            info.topActivityInfo.applicationInfo.scanSourceDir = \"\";\n+            info.topActivityInfo.applicationInfo.sourceDir = \"\";\n+            info.topActivityInfo.applicationInfo.taskAffinity = \"\";\n+            info.topActivityInfo.applicationInfo.name = \"\";\n+            info.topActivityInfo.applicationInfo.packageName = \"\";\n+        }\n+\n+        if (task.effectiveUid != baseActivityUid) {\n+            info.baseActivity = new ComponentName(\"\", \"\");\n+        }\n+    }\n+\n     @Nullable PictureInPictureParams getPictureInPictureParams() {\n         return getPictureInPictureParams(getTopMostTask());\n     }\n",
    "added_lines": 48,
    "deleted_lines": 0,
    "changed_methods": "Task::trimIneffectiveInfo"
   },
   {
    "filename": "RecentTasksTest.java",
    "diff": "@@ -30,6 +30,7 @@ import static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;\n import static android.content.pm.ActivityInfo.LAUNCH_MULTIPLE;\n import static android.content.pm.ActivityInfo.LAUNCH_SINGLE_INSTANCE;\n import static android.content.res.Configuration.ORIENTATION_PORTRAIT;\n+import static android.os.Process.NOBODY_UID;\n \n import static com.android.dx.mockito.inline.extended.ExtendedMockito.doNothing;\n import static com.android.dx.mockito.inline.extended.ExtendedMockito.doReturn;\n@@ -1195,21 +1196,36 @@ public class RecentTasksTest extends WindowTestsBase {\n \n     @Test\n     public void testCreateRecentTaskInfo_detachedTask() {\n-        final Task task = createTaskBuilder(\".Task\").setCreateActivity(true).build();\n+        final Task task = createTaskBuilder(\".Task\").build();\n+        final ComponentName componentName = new ComponentName(\"com.foo\", \".BarActivity\");\n+        new ActivityBuilder(mSupervisor.mService)\n+                .setTask(task)\n+                .setUid(NOBODY_UID)\n+                .setComponent(componentName)\n+                .build();\n         final TaskDisplayArea tda = task.getDisplayArea();\n \n         assertTrue(task.isAttached());\n         assertTrue(task.supportsMultiWindow());\n \n-        RecentTaskInfo info = mRecentTasks.createRecentTaskInfo(task, true);\n+        RecentTaskInfo info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,\n+                true /* getTasksAllowed */);\n \n         assertTrue(info.supportsMultiWindow);\n         assertTrue(info.supportsSplitScreenMultiWindow);\n \n+        info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,\n+                false /* getTasksAllowed */);\n+\n+        assertFalse(info.topActivity.equals(componentName));\n+        assertFalse(info.topActivityInfo.packageName.equals(componentName.getPackageName()));\n+        assertFalse(info.baseActivity.equals(componentName));\n+\n         // The task can be put in split screen even if it is not attached now.\n         task.removeImmediately();\n \n-        info = mRecentTasks.createRecentTaskInfo(task, true);\n+        info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,\n+                true /* getTasksAllowed */);\n \n         assertTrue(info.supportsMultiWindow);\n         assertTrue(info.supportsSplitScreenMultiWindow);\n@@ -1219,7 +1235,8 @@ public class RecentTasksTest extends WindowTestsBase {\n         doReturn(false).when(tda).supportsNonResizableMultiWindow();\n         doReturn(false).when(task).isResizeable();\n \n-        info = mRecentTasks.createRecentTaskInfo(task, true);\n+        info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,\n+                true /* getTasksAllowed */);\n \n         assertFalse(info.supportsMultiWindow);\n         assertFalse(info.supportsSplitScreenMultiWindow);\n@@ -1228,7 +1245,8 @@ public class RecentTasksTest extends WindowTestsBase {\n         // the device supports it.\n         doReturn(true).when(tda).supportsNonResizableMultiWindow();\n \n-        info = mRecentTasks.createRecentTaskInfo(task, true);\n+        info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,\n+                true /* getTasksAllowed */);\n \n         assertTrue(info.supportsMultiWindow);\n         assertTrue(info.supportsSplitScreenMultiWindow);\n",
    "added_lines": 23,
    "deleted_lines": 5,
    "changed_methods": "RecentTasksTest::testCreateRecentTaskInfo_detachedTask"
   }
  ]
 },
 {
  "hash": "6d2f7829dd6e3fdcc6ebff0c2d9e16c3a069ad9d",
  "commit": "[RESTRICT AUTOMERGE] Strip part of the activity info of another uid if no privilege\n\nThe activity info could be from another uid which is different\nfrom the app that hosts the task. The information should be\ntrimmed if the caller app doesn't have the privilege.\n\nHowever, removing the entire info may result in app compatibility\nissues. So, only swiping the info that are sensitive to empty\nstring.\n\nBug: 243130512\nTest: verified market app locally\nTest: atest RecentTasksTest\nChange-Id: I5b6775dd3c4e2ccdacd30741884d336b2eaa70da\nMerged-In: I5b6775dd3c4e2ccdacd30741884d336b2eaa70da\n(cherry picked from commit 5ba72200f6a66b5da48c9c3abd103a73aea1ef95)\n(cherry picked from commit 7be9e6efb63884f8f4bb647e537a29746bbeb9fa)\nMerged-In: I5b6775dd3c4e2ccdacd30741884d336b2eaa70da",
  "files": [
   {
    "filename": "AppTaskImpl.java",
    "diff": "@@ -84,7 +84,7 @@ class AppTaskImpl extends IAppTask.Stub {\n                     throw new IllegalArgumentException(\"Unable to find task ID \" + mTaskId);\n                 }\n                 return mService.getRecentTasks().createRecentTaskInfo(task,\n-                        false /* stripExtras */);\n+                        false /* stripExtras */, true /* getTasksAllowed */);\n             } finally {\n                 Binder.restoreCallingIdentity(origId);\n             }\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "AppTaskImpl::getTaskInfo"
   },
   {
    "filename": "RecentTasks.java",
    "diff": "@@ -974,7 +974,7 @@ class RecentTasks {\n                 continue;\n             }\n \n-            res.add(createRecentTaskInfo(task, true /* stripExtras */));\n+            res.add(createRecentTaskInfo(task, true /* stripExtras */, getTasksAllowed));\n         }\n         return res;\n     }\n@@ -1890,7 +1890,8 @@ class RecentTasks {\n     /**\n      * Creates a new RecentTaskInfo from a Task.\n      */\n-    ActivityManager.RecentTaskInfo createRecentTaskInfo(Task tr, boolean stripExtras) {\n+    ActivityManager.RecentTaskInfo createRecentTaskInfo(Task tr, boolean stripExtras,\n+            boolean getTasksAllowed) {\n         final ActivityManager.RecentTaskInfo rti = new ActivityManager.RecentTaskInfo();\n         // If the recent Task is detached, we consider it will be re-attached to the default\n         // TaskDisplayArea because we currently only support recent overview in the default TDA.\n@@ -1902,6 +1903,9 @@ class RecentTasks {\n         rti.id = rti.isRunning ? rti.taskId : INVALID_TASK_ID;\n         rti.persistentId = rti.taskId;\n         rti.lastSnapshotData.set(tr.mLastTaskSnapshotData);\n+        if (!getTasksAllowed) {\n+            Task.trimIneffectiveInfo(tr, rti);\n+        }\n \n         // Fill in organized child task info for the task created by organizer.\n         if (tr.mCreatedByOrganizer) {\n",
    "added_lines": 6,
    "deleted_lines": 2,
    "changed_methods": "RecentTasks::createRecentTaskInfo, RecentTasks::getRecentTasksImpl, RecentTasks::createRecentTaskInfo"
   },
   {
    "filename": "RunningTasks.java",
    "diff": "@@ -150,6 +150,10 @@ class RunningTasks {\n         task.fillTaskInfo(rti, !mKeepIntentExtra);\n         // Fill in some deprecated values\n         rti.id = rti.taskId;\n+\n+        if (!mAllowed) {\n+            Task.trimIneffectiveInfo(task, rti);\n+        }\n         return rti;\n     }\n }\n",
    "added_lines": 4,
    "deleted_lines": 0,
    "changed_methods": "RunningTasks::createRunningTaskInfo"
   },
   {
    "filename": "Task.java",
    "diff": "@@ -3484,6 +3484,54 @@ class Task extends TaskFragment {\n         info.mTopActivityLocusId = topRecord != null ? topRecord.getLocusId() : null;\n     }\n \n+    /**\n+     * Removes the activity info if the activity belongs to a different uid, which is\n+     * different from the app that hosts the task.\n+     */\n+    static void trimIneffectiveInfo(Task task, TaskInfo info) {\n+        final ActivityRecord baseActivity = task.getActivity(r -> !r.finishing,\n+                false /* traverseTopToBottom */);\n+        final int baseActivityUid =\n+                baseActivity != null ? baseActivity.getUid() : task.effectiveUid;\n+\n+        if (info.topActivityInfo != null\n+                && task.effectiveUid != info.topActivityInfo.applicationInfo.uid) {\n+            // Making a copy to prevent eliminating the info in the original ActivityRecord.\n+            info.topActivityInfo = new ActivityInfo(info.topActivityInfo);\n+            info.topActivityInfo.applicationInfo =\n+                    new ApplicationInfo(info.topActivityInfo.applicationInfo);\n+\n+            // Strip the sensitive info.\n+            info.topActivity = new ComponentName(\"\", \"\");\n+            info.topActivityInfo.packageName = \"\";\n+            info.topActivityInfo.taskAffinity = \"\";\n+            info.topActivityInfo.processName = \"\";\n+            info.topActivityInfo.name = \"\";\n+            info.topActivityInfo.parentActivityName = \"\";\n+            info.topActivityInfo.targetActivity = \"\";\n+            info.topActivityInfo.splitName = \"\";\n+            info.topActivityInfo.applicationInfo.className = \"\";\n+            info.topActivityInfo.applicationInfo.credentialProtectedDataDir = \"\";\n+            info.topActivityInfo.applicationInfo.dataDir = \"\";\n+            info.topActivityInfo.applicationInfo.deviceProtectedDataDir = \"\";\n+            info.topActivityInfo.applicationInfo.manageSpaceActivityName = \"\";\n+            info.topActivityInfo.applicationInfo.nativeLibraryDir = \"\";\n+            info.topActivityInfo.applicationInfo.nativeLibraryRootDir = \"\";\n+            info.topActivityInfo.applicationInfo.processName = \"\";\n+            info.topActivityInfo.applicationInfo.publicSourceDir = \"\";\n+            info.topActivityInfo.applicationInfo.scanPublicSourceDir = \"\";\n+            info.topActivityInfo.applicationInfo.scanSourceDir = \"\";\n+            info.topActivityInfo.applicationInfo.sourceDir = \"\";\n+            info.topActivityInfo.applicationInfo.taskAffinity = \"\";\n+            info.topActivityInfo.applicationInfo.name = \"\";\n+            info.topActivityInfo.applicationInfo.packageName = \"\";\n+        }\n+\n+        if (task.effectiveUid != baseActivityUid) {\n+            info.baseActivity = new ComponentName(\"\", \"\");\n+        }\n+    }\n+\n     @Nullable PictureInPictureParams getPictureInPictureParams() {\n         return getPictureInPictureParams(getTopMostTask());\n     }\n",
    "added_lines": 48,
    "deleted_lines": 0,
    "changed_methods": "Task::trimIneffectiveInfo"
   },
   {
    "filename": "RecentTasksTest.java",
    "diff": "@@ -30,6 +30,7 @@ import static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;\n import static android.content.pm.ActivityInfo.LAUNCH_MULTIPLE;\n import static android.content.pm.ActivityInfo.LAUNCH_SINGLE_INSTANCE;\n import static android.content.res.Configuration.ORIENTATION_PORTRAIT;\n+import static android.os.Process.NOBODY_UID;\n \n import static com.android.dx.mockito.inline.extended.ExtendedMockito.doNothing;\n import static com.android.dx.mockito.inline.extended.ExtendedMockito.doReturn;\n@@ -1195,21 +1196,36 @@ public class RecentTasksTest extends WindowTestsBase {\n \n     @Test\n     public void testCreateRecentTaskInfo_detachedTask() {\n-        final Task task = createTaskBuilder(\".Task\").setCreateActivity(true).build();\n+        final Task task = createTaskBuilder(\".Task\").build();\n+        final ComponentName componentName = new ComponentName(\"com.foo\", \".BarActivity\");\n+        new ActivityBuilder(mSupervisor.mService)\n+                .setTask(task)\n+                .setUid(NOBODY_UID)\n+                .setComponent(componentName)\n+                .build();\n         final TaskDisplayArea tda = task.getDisplayArea();\n \n         assertTrue(task.isAttached());\n         assertTrue(task.supportsMultiWindow());\n \n-        RecentTaskInfo info = mRecentTasks.createRecentTaskInfo(task, true);\n+        RecentTaskInfo info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,\n+                true /* getTasksAllowed */);\n \n         assertTrue(info.supportsMultiWindow);\n         assertTrue(info.supportsSplitScreenMultiWindow);\n \n+        info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,\n+                false /* getTasksAllowed */);\n+\n+        assertFalse(info.topActivity.equals(componentName));\n+        assertFalse(info.topActivityInfo.packageName.equals(componentName.getPackageName()));\n+        assertFalse(info.baseActivity.equals(componentName));\n+\n         // The task can be put in split screen even if it is not attached now.\n         task.removeImmediately();\n \n-        info = mRecentTasks.createRecentTaskInfo(task, true);\n+        info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,\n+                true /* getTasksAllowed */);\n \n         assertTrue(info.supportsMultiWindow);\n         assertTrue(info.supportsSplitScreenMultiWindow);\n@@ -1219,7 +1235,8 @@ public class RecentTasksTest extends WindowTestsBase {\n         doReturn(false).when(tda).supportsNonResizableMultiWindow();\n         doReturn(false).when(task).isResizeable();\n \n-        info = mRecentTasks.createRecentTaskInfo(task, true);\n+        info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,\n+                true /* getTasksAllowed */);\n \n         assertFalse(info.supportsMultiWindow);\n         assertFalse(info.supportsSplitScreenMultiWindow);\n@@ -1228,7 +1245,8 @@ public class RecentTasksTest extends WindowTestsBase {\n         // the device supports it.\n         doReturn(true).when(tda).supportsNonResizableMultiWindow();\n \n-        info = mRecentTasks.createRecentTaskInfo(task, true);\n+        info = mRecentTasks.createRecentTaskInfo(task, true /* stripExtras */,\n+                true /* getTasksAllowed */);\n \n         assertTrue(info.supportsMultiWindow);\n         assertTrue(info.supportsSplitScreenMultiWindow);\n",
    "added_lines": 23,
    "deleted_lines": 5,
    "changed_methods": "RecentTasksTest::testCreateRecentTaskInfo_detachedTask"
   }
  ]
 },
 {
  "hash": "f64311b32d86df04746b885d4ed0111d588fd48b",
  "commit": "Add a limit on channel group creation\n\nSame as exists for channels\n\nThis is a backport of the fix in ag/16659457, including the adjustment from ag/20920023 (changed the max value from 50000 to 6000).\n\nTest: PreferencesHelperTest\nBug: 210114537\nBug: 261723753\nChange-Id: Ic27efba4c54e22eebca16fc948879e652df4467b\n(cherry picked from commit 37b3549807d15452ac334fae316e615c3b9b8e8b & I3f3a99765c161369e1b026686a0e5f0c83ed839e)\nMerged-In: I3f3a99765c161369e1b026686a0e5f0c83ed839e\n(cherry picked from commit 38257af19e18d19075483dfa351c7e5cbb9cbf75)\nMerged-In: Ic27efba4c54e22eebca16fc948879e652df4467b",
  "files": [
   {
    "filename": "PreferencesHelper.java",
    "diff": "@@ -98,6 +98,8 @@ public class PreferencesHelper implements RankingConfig {\n \n     @VisibleForTesting\n     static final int NOTIFICATION_CHANNEL_COUNT_LIMIT = 5000;\n+    @VisibleForTesting\n+    static final int NOTIFICATION_CHANNEL_GROUP_COUNT_LIMIT = 6000;\n \n     private static final int NOTIFICATION_PREFERENCES_PULL_LIMIT = 1000;\n     private static final int NOTIFICATION_CHANNEL_PULL_LIMIT = 2000;\n@@ -242,6 +244,7 @@ public class PreferencesHelper implements RankingConfig {\n                                 }\n                             }\n                             boolean skipWarningLogged = false;\n+                            boolean skipGroupWarningLogged = false;\n                             boolean hasSAWPermission = false;\n                             if (upgradeForBubbles && uid != UNKNOWN_UID) {\n                                 hasSAWPermission = mAppOps.noteOpNoThrow(\n@@ -294,6 +297,14 @@ public class PreferencesHelper implements RankingConfig {\n                                 String tagName = parser.getName();\n                                 // Channel groups\n                                 if (TAG_GROUP.equals(tagName)) {\n+                                    if (r.groups.size() >= NOTIFICATION_CHANNEL_GROUP_COUNT_LIMIT) {\n+                                        if (!skipGroupWarningLogged) {\n+                                            Slog.w(TAG, \"Skipping further groups for \" + r.pkg\n+                                                    + \"; app has too many\");\n+                                            skipGroupWarningLogged = true;\n+                                        }\n+                                        continue;\n+                                    }\n                                     String id = parser.getAttributeValue(null, ATT_ID);\n                                     CharSequence groupName = parser.getAttributeValue(null,\n                                             ATT_NAME);\n@@ -807,6 +818,9 @@ public class PreferencesHelper implements RankingConfig {\n             }\n             if (fromTargetApp) {\n                 group.setBlocked(false);\n+                if (r.groups.size() >= NOTIFICATION_CHANNEL_GROUP_COUNT_LIMIT) {\n+                    throw new IllegalStateException(\"Limit exceed; cannot create more groups\");\n+                }\n             }\n             final NotificationChannelGroup oldGroup = r.groups.get(group.getId());\n             if (oldGroup != null) {\n",
    "added_lines": 14,
    "deleted_lines": 0,
    "changed_methods": "PreferencesHelper::readXml, PreferencesHelper::createNotificationChannelGroup"
   },
   {
    "filename": "PreferencesHelperTest.java",
    "diff": "@@ -42,6 +42,7 @@ import static com.android.os.AtomsProto.PackageNotificationChannelPreferences.IS\n import static com.android.os.AtomsProto.PackageNotificationChannelPreferences.UID_FIELD_NUMBER;\n import static com.android.server.notification.PreferencesHelper.DEFAULT_BUBBLE_PREFERENCE;\n import static com.android.server.notification.PreferencesHelper.NOTIFICATION_CHANNEL_COUNT_LIMIT;\n+import static com.android.server.notification.PreferencesHelper.NOTIFICATION_CHANNEL_GROUP_COUNT_LIMIT;\n import static com.android.server.notification.PreferencesHelper.UNKNOWN_UID;\n \n import static com.google.common.truth.Truth.assertThat;\n@@ -3165,6 +3166,52 @@ public class PreferencesHelperTest extends UiServiceTestCase {\n         assertNull(mHelper.getNotificationChannel(PKG_O, UID_O, extraChannel1, true));\n     }\n \n+    @Test\n+    public void testTooManyGroups() {\n+        for (int i = 0; i < NOTIFICATION_CHANNEL_GROUP_COUNT_LIMIT; i++) {\n+            NotificationChannelGroup group = new NotificationChannelGroup(String.valueOf(i),\n+                    String.valueOf(i));\n+            mHelper.createNotificationChannelGroup(PKG_O, UID_O, group, true);\n+        }\n+        try {\n+            NotificationChannelGroup group = new NotificationChannelGroup(\n+                    String.valueOf(NOTIFICATION_CHANNEL_GROUP_COUNT_LIMIT),\n+                    String.valueOf(NOTIFICATION_CHANNEL_GROUP_COUNT_LIMIT));\n+            mHelper.createNotificationChannelGroup(PKG_O, UID_O, group, true);\n+            fail(\"Allowed to create too many notification channel groups\");\n+        } catch (IllegalStateException e) {\n+            // great\n+        }\n+    }\n+\n+    @Test\n+    public void testTooManyGroups_xml() throws Exception {\n+        String extraGroup = \"EXTRA\";\n+        String extraGroup1 = \"EXTRA1\";\n+\n+        // create first... many... directly so we don't need a big xml blob in this test\n+        for (int i = 0; i < NOTIFICATION_CHANNEL_GROUP_COUNT_LIMIT; i++) {\n+            NotificationChannelGroup group = new NotificationChannelGroup(String.valueOf(i),\n+                    String.valueOf(i));\n+            mHelper.createNotificationChannelGroup(PKG_O, UID_O, group, true);\n+        }\n+\n+        final String xml = \"<ranking version=\\\"1\\\">\\n\"\n+                + \"<package name=\\\"\" + PKG_O + \"\\\" uid=\\\"\" + UID_O + \"\\\" >\\n\"\n+                + \"<channelGroup id=\\\"\" + extraGroup + \"\\\" name=\\\"hi\\\"/>\"\n+                + \"<channelGroup id=\\\"\" + extraGroup1 + \"\\\" name=\\\"hi2\\\"/>\"\n+                + \"</package>\"\n+                + \"</ranking>\";\n+        TypedXmlPullParser parser = Xml.newFastPullParser();\n+        parser.setInput(new BufferedInputStream(new ByteArrayInputStream(xml.getBytes())),\n+                null);\n+        parser.nextTag();\n+        mHelper.readXml(parser, false, UserHandle.USER_ALL);\n+\n+        assertNull(mHelper.getNotificationChannelGroup(extraGroup, PKG_O, UID_O));\n+        assertNull(mHelper.getNotificationChannelGroup(extraGroup1, PKG_O, UID_O));\n+    }\n+\n     @Test\n     public void testRestoreMultiUser() throws Exception {\n         String pkg = \"restore_pkg\";\n",
    "added_lines": 47,
    "deleted_lines": 0,
    "changed_methods": "PreferencesHelperTest::testTooManyGroups_xml, PreferencesHelperTest::testTooManyGroups"
   }
  ]
 },
 {
  "hash": "f64311b32d86df04746b885d4ed0111d588fd48b",
  "commit": "Add a limit on channel group creation\n\nSame as exists for channels\n\nThis is a backport of the fix in ag/16659457, including the adjustment from ag/20920023 (changed the max value from 50000 to 6000).\n\nTest: PreferencesHelperTest\nBug: 210114537\nBug: 261723753\nChange-Id: Ic27efba4c54e22eebca16fc948879e652df4467b\n(cherry picked from commit 37b3549807d15452ac334fae316e615c3b9b8e8b & I3f3a99765c161369e1b026686a0e5f0c83ed839e)\nMerged-In: I3f3a99765c161369e1b026686a0e5f0c83ed839e\n(cherry picked from commit 38257af19e18d19075483dfa351c7e5cbb9cbf75)\nMerged-In: Ic27efba4c54e22eebca16fc948879e652df4467b",
  "files": [
   {
    "filename": "PreferencesHelper.java",
    "diff": "@@ -98,6 +98,8 @@ public class PreferencesHelper implements RankingConfig {\n \n     @VisibleForTesting\n     static final int NOTIFICATION_CHANNEL_COUNT_LIMIT = 5000;\n+    @VisibleForTesting\n+    static final int NOTIFICATION_CHANNEL_GROUP_COUNT_LIMIT = 6000;\n \n     private static final int NOTIFICATION_PREFERENCES_PULL_LIMIT = 1000;\n     private static final int NOTIFICATION_CHANNEL_PULL_LIMIT = 2000;\n@@ -242,6 +244,7 @@ public class PreferencesHelper implements RankingConfig {\n                                 }\n                             }\n                             boolean skipWarningLogged = false;\n+                            boolean skipGroupWarningLogged = false;\n                             boolean hasSAWPermission = false;\n                             if (upgradeForBubbles && uid != UNKNOWN_UID) {\n                                 hasSAWPermission = mAppOps.noteOpNoThrow(\n@@ -294,6 +297,14 @@ public class PreferencesHelper implements RankingConfig {\n                                 String tagName = parser.getName();\n                                 // Channel groups\n                                 if (TAG_GROUP.equals(tagName)) {\n+                                    if (r.groups.size() >= NOTIFICATION_CHANNEL_GROUP_COUNT_LIMIT) {\n+                                        if (!skipGroupWarningLogged) {\n+                                            Slog.w(TAG, \"Skipping further groups for \" + r.pkg\n+                                                    + \"; app has too many\");\n+                                            skipGroupWarningLogged = true;\n+                                        }\n+                                        continue;\n+                                    }\n                                     String id = parser.getAttributeValue(null, ATT_ID);\n                                     CharSequence groupName = parser.getAttributeValue(null,\n                                             ATT_NAME);\n@@ -807,6 +818,9 @@ public class PreferencesHelper implements RankingConfig {\n             }\n             if (fromTargetApp) {\n                 group.setBlocked(false);\n+                if (r.groups.size() >= NOTIFICATION_CHANNEL_GROUP_COUNT_LIMIT) {\n+                    throw new IllegalStateException(\"Limit exceed; cannot create more groups\");\n+                }\n             }\n             final NotificationChannelGroup oldGroup = r.groups.get(group.getId());\n             if (oldGroup != null) {\n",
    "added_lines": 14,
    "deleted_lines": 0,
    "changed_methods": "PreferencesHelper::readXml, PreferencesHelper::createNotificationChannelGroup"
   },
   {
    "filename": "PreferencesHelperTest.java",
    "diff": "@@ -42,6 +42,7 @@ import static com.android.os.AtomsProto.PackageNotificationChannelPreferences.IS\n import static com.android.os.AtomsProto.PackageNotificationChannelPreferences.UID_FIELD_NUMBER;\n import static com.android.server.notification.PreferencesHelper.DEFAULT_BUBBLE_PREFERENCE;\n import static com.android.server.notification.PreferencesHelper.NOTIFICATION_CHANNEL_COUNT_LIMIT;\n+import static com.android.server.notification.PreferencesHelper.NOTIFICATION_CHANNEL_GROUP_COUNT_LIMIT;\n import static com.android.server.notification.PreferencesHelper.UNKNOWN_UID;\n \n import static com.google.common.truth.Truth.assertThat;\n@@ -3165,6 +3166,52 @@ public class PreferencesHelperTest extends UiServiceTestCase {\n         assertNull(mHelper.getNotificationChannel(PKG_O, UID_O, extraChannel1, true));\n     }\n \n+    @Test\n+    public void testTooManyGroups() {\n+        for (int i = 0; i < NOTIFICATION_CHANNEL_GROUP_COUNT_LIMIT; i++) {\n+            NotificationChannelGroup group = new NotificationChannelGroup(String.valueOf(i),\n+                    String.valueOf(i));\n+            mHelper.createNotificationChannelGroup(PKG_O, UID_O, group, true);\n+        }\n+        try {\n+            NotificationChannelGroup group = new NotificationChannelGroup(\n+                    String.valueOf(NOTIFICATION_CHANNEL_GROUP_COUNT_LIMIT),\n+                    String.valueOf(NOTIFICATION_CHANNEL_GROUP_COUNT_LIMIT));\n+            mHelper.createNotificationChannelGroup(PKG_O, UID_O, group, true);\n+            fail(\"Allowed to create too many notification channel groups\");\n+        } catch (IllegalStateException e) {\n+            // great\n+        }\n+    }\n+\n+    @Test\n+    public void testTooManyGroups_xml() throws Exception {\n+        String extraGroup = \"EXTRA\";\n+        String extraGroup1 = \"EXTRA1\";\n+\n+        // create first... many... directly so we don't need a big xml blob in this test\n+        for (int i = 0; i < NOTIFICATION_CHANNEL_GROUP_COUNT_LIMIT; i++) {\n+            NotificationChannelGroup group = new NotificationChannelGroup(String.valueOf(i),\n+                    String.valueOf(i));\n+            mHelper.createNotificationChannelGroup(PKG_O, UID_O, group, true);\n+        }\n+\n+        final String xml = \"<ranking version=\\\"1\\\">\\n\"\n+                + \"<package name=\\\"\" + PKG_O + \"\\\" uid=\\\"\" + UID_O + \"\\\" >\\n\"\n+                + \"<channelGroup id=\\\"\" + extraGroup + \"\\\" name=\\\"hi\\\"/>\"\n+                + \"<channelGroup id=\\\"\" + extraGroup1 + \"\\\" name=\\\"hi2\\\"/>\"\n+                + \"</package>\"\n+                + \"</ranking>\";\n+        TypedXmlPullParser parser = Xml.newFastPullParser();\n+        parser.setInput(new BufferedInputStream(new ByteArrayInputStream(xml.getBytes())),\n+                null);\n+        parser.nextTag();\n+        mHelper.readXml(parser, false, UserHandle.USER_ALL);\n+\n+        assertNull(mHelper.getNotificationChannelGroup(extraGroup, PKG_O, UID_O));\n+        assertNull(mHelper.getNotificationChannelGroup(extraGroup1, PKG_O, UID_O));\n+    }\n+\n     @Test\n     public void testRestoreMultiUser() throws Exception {\n         String pkg = \"restore_pkg\";\n",
    "added_lines": 47,
    "deleted_lines": 0,
    "changed_methods": "PreferencesHelperTest::testTooManyGroups_xml, PreferencesHelperTest::testTooManyGroups"
   }
  ]
 },
 {
  "hash": "2552ea758a9eb3c0b7f12426214a3c4c7fad0bca",
  "commit": "Fix bypass BAL via LocationManager.requestFlush\n\nBug: 235823542\nTest: atest LocationProviderManagerTest and manual tests\nChange-Id: I2a0fa7b99c3ad5ae839d8018ec70cb5c26e33240\n(cherry picked from commit 750af79d5ccb282bb79ef40932858fbae801a48b)\nMerged-In: I2a0fa7b99c3ad5ae839d8018ec70cb5c26e33240",
  "files": [
   {
    "filename": "LocationProviderManager.java",
    "diff": "@@ -281,6 +281,7 @@ public class LocationProviderManager extends\n         public void deliverOnFlushComplete(int requestCode) throws PendingIntent.CanceledException {\n             BroadcastOptions options = BroadcastOptions.makeBasic();\n             options.setDontSendToRestrictedApps(true);\n+            options.setPendingIntentBackgroundActivityLaunchAllowed(false);\n \n             mPendingIntent.send(mContext, 0, new Intent().putExtra(KEY_FLUSH_COMPLETE, requestCode),\n                     null, null, null, options.toBundle());\n",
    "added_lines": 1,
    "deleted_lines": 0,
    "changed_methods": "LocationProviderManager::LocationPendingIntentTransport::deliverOnFlushComplete"
   }
  ]
 },
 {
  "hash": "8ef7fac04f4331e2c029002d8d99eb2246d74625",
  "commit": "[RESTRICT AUTOMERGE] Fix bypass BG-FGS and BAL via package manager APIs\n\nOpt-in for BAL of PendingIntent for following APIs:\n\n* PackageInstaller.uninstall()\n* PackageInstaller.installExistingPackage()\n* PackageInstaller.uninstallExistingPackage()\n* PackageInstaller.Session.commit()\n* PackageInstaller.Session.commitTransferred()\n* PackageManager.freeStorage()\n\nBug: 230492955\nBug: 243377226\nTest: atest android.security.cts.PackageInstallerTest\nTest: atest CtsStagedInstallHostTestCases\nChange-Id: I9b6f801d69ea6d2244a38dbe689e81afa4e798bf\n(cherry picked from commit 5f00e89989392c9ae00b360e1388d0179dfb36d7)\nMerged-In: I9b6f801d69ea6d2244a38dbe689e81afa4e798bf",
  "files": [
   {
    "filename": "IntentSender.java",
    "diff": "@@ -19,6 +19,7 @@ package android.content;\n import android.annotation.Nullable;\n import android.app.ActivityManager;\n import android.app.ActivityManager.PendingIntentInfo;\n+import android.app.ActivityOptions;\n import android.compat.annotation.UnsupportedAppUsage;\n import android.os.Bundle;\n import android.os.Handler;\n@@ -158,7 +159,7 @@ public class IntentSender implements Parcelable {\n      */\n     public void sendIntent(Context context, int code, Intent intent,\n             OnFinished onFinished, Handler handler) throws SendIntentException {\n-        sendIntent(context, code, intent, onFinished, handler, null);\n+        sendIntent(context, code, intent, onFinished, handler, null, null /* options */);\n     }\n \n     /**\n@@ -190,6 +191,42 @@ public class IntentSender implements Parcelable {\n     public void sendIntent(Context context, int code, Intent intent,\n             OnFinished onFinished, Handler handler, String requiredPermission)\n             throws SendIntentException {\n+        sendIntent(context, code, intent, onFinished, handler, requiredPermission,\n+                null /* options */);\n+    }\n+\n+    /**\n+     * Perform the operation associated with this IntentSender, allowing the\n+     * caller to specify information about the Intent to use and be notified\n+     * when the send has completed.\n+     *\n+     * @param context The Context of the caller.  This may be null if\n+     * <var>intent</var> is also null.\n+     * @param code Result code to supply back to the IntentSender's target.\n+     * @param intent Additional Intent data.  See {@link Intent#fillIn\n+     * Intent.fillIn()} for information on how this is applied to the\n+     * original Intent.  Use null to not modify the original Intent.\n+     * @param onFinished The object to call back on when the send has\n+     * completed, or null for no callback.\n+     * @param handler Handler identifying the thread on which the callback\n+     * should happen.  If null, the callback will happen from the thread\n+     * pool of the process.\n+     * @param requiredPermission Name of permission that a recipient of the PendingIntent\n+     * is required to hold.  This is only valid for broadcast intents, and\n+     * corresponds to the permission argument in\n+     * {@link Context#sendBroadcast(Intent, String) Context.sendOrderedBroadcast(Intent, String)}.\n+     * If null, no permission is required.\n+     * @param options Additional options the caller would like to provide to modify the sending\n+     * behavior.  May be built from an {@link ActivityOptions} to apply to an activity start.\n+     *\n+     * @throws SendIntentException Throws CanceledIntentException if the IntentSender\n+     * is no longer allowing more intents to be sent through it.\n+     * @hide\n+     */\n+    public void sendIntent(Context context, int code, Intent intent,\n+            OnFinished onFinished, Handler handler, String requiredPermission,\n+            @Nullable Bundle options)\n+            throws SendIntentException {\n         try {\n             String resolvedType = intent != null ?\n                     intent.resolveTypeIfNeeded(context.getContentResolver())\n@@ -199,7 +236,7 @@ public class IntentSender implements Parcelable {\n                     onFinished != null\n                             ? new FinishedDispatcher(this, onFinished, handler)\n                             : null,\n-                    requiredPermission, null);\n+                    requiredPermission, options);\n             if (res < 0) {\n                 throw new SendIntentException();\n             }\n",
    "added_lines": 39,
    "deleted_lines": 2,
    "changed_methods": "IntentSender::sendIntent, IntentSender::sendIntent, IntentSender::sendIntent"
   },
   {
    "filename": "PackageInstallerService.java",
    "diff": "@@ -25,6 +25,7 @@ import android.annotation.Nullable;\n import android.app.ActivityManager;\n import android.app.AppGlobals;\n import android.app.AppOpsManager;\n+import android.app.BroadcastOptions;\n import android.app.Notification;\n import android.app.NotificationManager;\n import android.app.PackageDeleteObserver;\n@@ -1243,7 +1244,10 @@ public class PackageInstallerService extends IPackageInstaller.Stub implements\n                     PackageInstaller.STATUS_PENDING_USER_ACTION);\n             fillIn.putExtra(Intent.EXTRA_INTENT, intent);\n             try {\n-                mTarget.sendIntent(mContext, 0, fillIn, null, null);\n+                final BroadcastOptions options = BroadcastOptions.makeBasic();\n+                options.setPendingIntentBackgroundActivityLaunchAllowed(false);\n+                mTarget.sendIntent(mContext, 0, fillIn, null /* onFinished*/,\n+                        null /* handler */, null /* requiredPermission */, options.toBundle());\n             } catch (SendIntentException ignored) {\n             }\n         }\n@@ -1268,7 +1272,10 @@ public class PackageInstallerService extends IPackageInstaller.Stub implements\n                     PackageManager.deleteStatusToString(returnCode, msg));\n             fillIn.putExtra(PackageInstaller.EXTRA_LEGACY_STATUS, returnCode);\n             try {\n-                mTarget.sendIntent(mContext, 0, fillIn, null, null);\n+                final BroadcastOptions options = BroadcastOptions.makeBasic();\n+                options.setPendingIntentBackgroundActivityLaunchAllowed(false);\n+                mTarget.sendIntent(mContext, 0, fillIn, null /* onFinished*/,\n+                        null /* handler */, null /* requiredPermission */, options.toBundle());\n             } catch (SendIntentException ignored) {\n             }\n         }\n",
    "added_lines": 9,
    "deleted_lines": 2,
    "changed_methods": "PackageInstallerService::PackageDeleteObserverAdapter::onPackageDeleted, PackageInstallerService::PackageDeleteObserverAdapter::onUserActionRequired"
   },
   {
    "filename": "PackageInstallerSession.java",
    "diff": "@@ -50,6 +50,7 @@ import android.annotation.IntDef;\n import android.annotation.NonNull;\n import android.annotation.Nullable;\n import android.app.AppOpsManager;\n+import android.app.BroadcastOptions;\n import android.app.Notification;\n import android.app.NotificationManager;\n import android.app.admin.DevicePolicyEventLogger;\n@@ -1872,7 +1873,11 @@ public class PackageInstallerSession extends IPackageInstallerSession.Stub {\n                     }\n                 } else if (PackageInstaller.STATUS_PENDING_USER_ACTION == status) {\n                     try {\n-                        mStatusReceiver.sendIntent(mContext, 0, intent, null, null);\n+                        final BroadcastOptions options = BroadcastOptions.makeBasic();\n+                        options.setPendingIntentBackgroundActivityLaunchAllowed(false);\n+                        mStatusReceiver.sendIntent(mContext, 0, intent,\n+                                null /* onFinished*/, null /* handler */,\n+                                null /* requiredPermission */, options.toBundle());\n                     } catch (IntentSender.SendIntentException ignore) {\n                     }\n                 } else { // failure, let's forward and clean up this session.\n@@ -4375,7 +4380,10 @@ public class PackageInstallerSession extends IPackageInstallerSession.Stub {\n         fillIn.putExtra(PackageInstaller.EXTRA_STATUS, PackageInstaller.STATUS_PENDING_USER_ACTION);\n         fillIn.putExtra(Intent.EXTRA_INTENT, intent);\n         try {\n-            target.sendIntent(context, 0, fillIn, null, null);\n+            final BroadcastOptions options = BroadcastOptions.makeBasic();\n+            options.setPendingIntentBackgroundActivityLaunchAllowed(false);\n+            target.sendIntent(context, 0, fillIn, null /* onFinished */,\n+                    null /* handler */, null /* requiredPermission */, options.toBundle());\n         } catch (IntentSender.SendIntentException ignored) {\n         }\n     }\n@@ -4418,7 +4426,10 @@ public class PackageInstallerSession extends IPackageInstallerSession.Stub {\n             }\n         }\n         try {\n-            target.sendIntent(context, 0, fillIn, null, null);\n+            final BroadcastOptions options = BroadcastOptions.makeBasic();\n+            options.setPendingIntentBackgroundActivityLaunchAllowed(false);\n+            target.sendIntent(context, 0, fillIn, null /* onFinished */,\n+                    null /* handler */, null /* requiredPermission */, options.toBundle());\n         } catch (IntentSender.SendIntentException ignored) {\n         }\n     }\n@@ -4443,7 +4454,10 @@ public class PackageInstallerSession extends IPackageInstallerSession.Stub {\n             intent.putExtra(PackageInstaller.EXTRA_STATUS_MESSAGE, \"Staging Image Not Ready\");\n         }\n         try {\n-            target.sendIntent(context, 0, intent, null, null);\n+            final BroadcastOptions options = BroadcastOptions.makeBasic();\n+            options.setPendingIntentBackgroundActivityLaunchAllowed(false);\n+            target.sendIntent(context, 0, intent, null /* onFinished */,\n+                    null /* handler */, null /* requiredPermission */, options.toBundle());\n         } catch (IntentSender.SendIntentException ignored) {\n         }\n     }\n",
    "added_lines": 18,
    "deleted_lines": 4,
    "changed_methods": "PackageInstallerSession::sendOnUserActionRequired, PackageInstallerSession::sendOnPackageInstalled, PackageInstallerSession::sendPendingStreaming, PackageInstallerSession::ChildStatusIntentReceiver::statusUpdate"
   },
   {
    "filename": "PackageManagerService.java",
    "diff": "@@ -9268,7 +9268,10 @@ public class PackageManagerService extends IPackageManager.Stub\n             }\n             if (pi != null) {\n                 try {\n-                    pi.sendIntent(null, success ? 1 : 0, null, null, null);\n+                    final BroadcastOptions options = BroadcastOptions.makeBasic();\n+                    options.setPendingIntentBackgroundActivityLaunchAllowed(false);\n+                    pi.sendIntent(null, success ? 1 : 0, null /* intent */, null /* onFinished*/,\n+                            null /* handler */, null /* requiredPermission */, options.toBundle());\n                 } catch (SendIntentException e) {\n                     Slog.w(TAG, e);\n                 }\n@@ -16451,7 +16454,10 @@ public class PackageManagerService extends IPackageManager.Stub\n         fillIn.putExtra(PackageInstaller.EXTRA_STATUS,\n                 PackageManager.installStatusToPublicStatus(returnCode));\n         try {\n-            target.sendIntent(context, 0, fillIn, null, null);\n+            final BroadcastOptions options = BroadcastOptions.makeBasic();\n+            options.setPendingIntentBackgroundActivityLaunchAllowed(false);\n+            target.sendIntent(context, 0, fillIn, null /* onFinished*/,\n+                    null /* handler */, null /* requiredPermission */, options.toBundle());\n         } catch (SendIntentException ignored) {\n         }\n     }\n",
    "added_lines": 8,
    "deleted_lines": 2,
    "changed_methods": "PackageManagerService::onRestoreComplete, PackageManagerService::freeStorage"
   }
  ]
 },
 {
  "hash": "8ef7fac04f4331e2c029002d8d99eb2246d74625",
  "commit": "[RESTRICT AUTOMERGE] Fix bypass BG-FGS and BAL via package manager APIs\n\nOpt-in for BAL of PendingIntent for following APIs:\n\n* PackageInstaller.uninstall()\n* PackageInstaller.installExistingPackage()\n* PackageInstaller.uninstallExistingPackage()\n* PackageInstaller.Session.commit()\n* PackageInstaller.Session.commitTransferred()\n* PackageManager.freeStorage()\n\nBug: 230492955\nBug: 243377226\nTest: atest android.security.cts.PackageInstallerTest\nTest: atest CtsStagedInstallHostTestCases\nChange-Id: I9b6f801d69ea6d2244a38dbe689e81afa4e798bf\n(cherry picked from commit 5f00e89989392c9ae00b360e1388d0179dfb36d7)\nMerged-In: I9b6f801d69ea6d2244a38dbe689e81afa4e798bf",
  "files": [
   {
    "filename": "IntentSender.java",
    "diff": "@@ -19,6 +19,7 @@ package android.content;\n import android.annotation.Nullable;\n import android.app.ActivityManager;\n import android.app.ActivityManager.PendingIntentInfo;\n+import android.app.ActivityOptions;\n import android.compat.annotation.UnsupportedAppUsage;\n import android.os.Bundle;\n import android.os.Handler;\n@@ -158,7 +159,7 @@ public class IntentSender implements Parcelable {\n      */\n     public void sendIntent(Context context, int code, Intent intent,\n             OnFinished onFinished, Handler handler) throws SendIntentException {\n-        sendIntent(context, code, intent, onFinished, handler, null);\n+        sendIntent(context, code, intent, onFinished, handler, null, null /* options */);\n     }\n \n     /**\n@@ -190,6 +191,42 @@ public class IntentSender implements Parcelable {\n     public void sendIntent(Context context, int code, Intent intent,\n             OnFinished onFinished, Handler handler, String requiredPermission)\n             throws SendIntentException {\n+        sendIntent(context, code, intent, onFinished, handler, requiredPermission,\n+                null /* options */);\n+    }\n+\n+    /**\n+     * Perform the operation associated with this IntentSender, allowing the\n+     * caller to specify information about the Intent to use and be notified\n+     * when the send has completed.\n+     *\n+     * @param context The Context of the caller.  This may be null if\n+     * <var>intent</var> is also null.\n+     * @param code Result code to supply back to the IntentSender's target.\n+     * @param intent Additional Intent data.  See {@link Intent#fillIn\n+     * Intent.fillIn()} for information on how this is applied to the\n+     * original Intent.  Use null to not modify the original Intent.\n+     * @param onFinished The object to call back on when the send has\n+     * completed, or null for no callback.\n+     * @param handler Handler identifying the thread on which the callback\n+     * should happen.  If null, the callback will happen from the thread\n+     * pool of the process.\n+     * @param requiredPermission Name of permission that a recipient of the PendingIntent\n+     * is required to hold.  This is only valid for broadcast intents, and\n+     * corresponds to the permission argument in\n+     * {@link Context#sendBroadcast(Intent, String) Context.sendOrderedBroadcast(Intent, String)}.\n+     * If null, no permission is required.\n+     * @param options Additional options the caller would like to provide to modify the sending\n+     * behavior.  May be built from an {@link ActivityOptions} to apply to an activity start.\n+     *\n+     * @throws SendIntentException Throws CanceledIntentException if the IntentSender\n+     * is no longer allowing more intents to be sent through it.\n+     * @hide\n+     */\n+    public void sendIntent(Context context, int code, Intent intent,\n+            OnFinished onFinished, Handler handler, String requiredPermission,\n+            @Nullable Bundle options)\n+            throws SendIntentException {\n         try {\n             String resolvedType = intent != null ?\n                     intent.resolveTypeIfNeeded(context.getContentResolver())\n@@ -199,7 +236,7 @@ public class IntentSender implements Parcelable {\n                     onFinished != null\n                             ? new FinishedDispatcher(this, onFinished, handler)\n                             : null,\n-                    requiredPermission, null);\n+                    requiredPermission, options);\n             if (res < 0) {\n                 throw new SendIntentException();\n             }\n",
    "added_lines": 39,
    "deleted_lines": 2,
    "changed_methods": "IntentSender::sendIntent, IntentSender::sendIntent, IntentSender::sendIntent"
   },
   {
    "filename": "PackageInstallerService.java",
    "diff": "@@ -25,6 +25,7 @@ import android.annotation.Nullable;\n import android.app.ActivityManager;\n import android.app.AppGlobals;\n import android.app.AppOpsManager;\n+import android.app.BroadcastOptions;\n import android.app.Notification;\n import android.app.NotificationManager;\n import android.app.PackageDeleteObserver;\n@@ -1243,7 +1244,10 @@ public class PackageInstallerService extends IPackageInstaller.Stub implements\n                     PackageInstaller.STATUS_PENDING_USER_ACTION);\n             fillIn.putExtra(Intent.EXTRA_INTENT, intent);\n             try {\n-                mTarget.sendIntent(mContext, 0, fillIn, null, null);\n+                final BroadcastOptions options = BroadcastOptions.makeBasic();\n+                options.setPendingIntentBackgroundActivityLaunchAllowed(false);\n+                mTarget.sendIntent(mContext, 0, fillIn, null /* onFinished*/,\n+                        null /* handler */, null /* requiredPermission */, options.toBundle());\n             } catch (SendIntentException ignored) {\n             }\n         }\n@@ -1268,7 +1272,10 @@ public class PackageInstallerService extends IPackageInstaller.Stub implements\n                     PackageManager.deleteStatusToString(returnCode, msg));\n             fillIn.putExtra(PackageInstaller.EXTRA_LEGACY_STATUS, returnCode);\n             try {\n-                mTarget.sendIntent(mContext, 0, fillIn, null, null);\n+                final BroadcastOptions options = BroadcastOptions.makeBasic();\n+                options.setPendingIntentBackgroundActivityLaunchAllowed(false);\n+                mTarget.sendIntent(mContext, 0, fillIn, null /* onFinished*/,\n+                        null /* handler */, null /* requiredPermission */, options.toBundle());\n             } catch (SendIntentException ignored) {\n             }\n         }\n",
    "added_lines": 9,
    "deleted_lines": 2,
    "changed_methods": "PackageInstallerService::PackageDeleteObserverAdapter::onPackageDeleted, PackageInstallerService::PackageDeleteObserverAdapter::onUserActionRequired"
   },
   {
    "filename": "PackageInstallerSession.java",
    "diff": "@@ -50,6 +50,7 @@ import android.annotation.IntDef;\n import android.annotation.NonNull;\n import android.annotation.Nullable;\n import android.app.AppOpsManager;\n+import android.app.BroadcastOptions;\n import android.app.Notification;\n import android.app.NotificationManager;\n import android.app.admin.DevicePolicyEventLogger;\n@@ -1872,7 +1873,11 @@ public class PackageInstallerSession extends IPackageInstallerSession.Stub {\n                     }\n                 } else if (PackageInstaller.STATUS_PENDING_USER_ACTION == status) {\n                     try {\n-                        mStatusReceiver.sendIntent(mContext, 0, intent, null, null);\n+                        final BroadcastOptions options = BroadcastOptions.makeBasic();\n+                        options.setPendingIntentBackgroundActivityLaunchAllowed(false);\n+                        mStatusReceiver.sendIntent(mContext, 0, intent,\n+                                null /* onFinished*/, null /* handler */,\n+                                null /* requiredPermission */, options.toBundle());\n                     } catch (IntentSender.SendIntentException ignore) {\n                     }\n                 } else { // failure, let's forward and clean up this session.\n@@ -4375,7 +4380,10 @@ public class PackageInstallerSession extends IPackageInstallerSession.Stub {\n         fillIn.putExtra(PackageInstaller.EXTRA_STATUS, PackageInstaller.STATUS_PENDING_USER_ACTION);\n         fillIn.putExtra(Intent.EXTRA_INTENT, intent);\n         try {\n-            target.sendIntent(context, 0, fillIn, null, null);\n+            final BroadcastOptions options = BroadcastOptions.makeBasic();\n+            options.setPendingIntentBackgroundActivityLaunchAllowed(false);\n+            target.sendIntent(context, 0, fillIn, null /* onFinished */,\n+                    null /* handler */, null /* requiredPermission */, options.toBundle());\n         } catch (IntentSender.SendIntentException ignored) {\n         }\n     }\n@@ -4418,7 +4426,10 @@ public class PackageInstallerSession extends IPackageInstallerSession.Stub {\n             }\n         }\n         try {\n-            target.sendIntent(context, 0, fillIn, null, null);\n+            final BroadcastOptions options = BroadcastOptions.makeBasic();\n+            options.setPendingIntentBackgroundActivityLaunchAllowed(false);\n+            target.sendIntent(context, 0, fillIn, null /* onFinished */,\n+                    null /* handler */, null /* requiredPermission */, options.toBundle());\n         } catch (IntentSender.SendIntentException ignored) {\n         }\n     }\n@@ -4443,7 +4454,10 @@ public class PackageInstallerSession extends IPackageInstallerSession.Stub {\n             intent.putExtra(PackageInstaller.EXTRA_STATUS_MESSAGE, \"Staging Image Not Ready\");\n         }\n         try {\n-            target.sendIntent(context, 0, intent, null, null);\n+            final BroadcastOptions options = BroadcastOptions.makeBasic();\n+            options.setPendingIntentBackgroundActivityLaunchAllowed(false);\n+            target.sendIntent(context, 0, intent, null /* onFinished */,\n+                    null /* handler */, null /* requiredPermission */, options.toBundle());\n         } catch (IntentSender.SendIntentException ignored) {\n         }\n     }\n",
    "added_lines": 18,
    "deleted_lines": 4,
    "changed_methods": "PackageInstallerSession::sendOnUserActionRequired, PackageInstallerSession::sendOnPackageInstalled, PackageInstallerSession::sendPendingStreaming, PackageInstallerSession::ChildStatusIntentReceiver::statusUpdate"
   },
   {
    "filename": "PackageManagerService.java",
    "diff": "@@ -9268,7 +9268,10 @@ public class PackageManagerService extends IPackageManager.Stub\n             }\n             if (pi != null) {\n                 try {\n-                    pi.sendIntent(null, success ? 1 : 0, null, null, null);\n+                    final BroadcastOptions options = BroadcastOptions.makeBasic();\n+                    options.setPendingIntentBackgroundActivityLaunchAllowed(false);\n+                    pi.sendIntent(null, success ? 1 : 0, null /* intent */, null /* onFinished*/,\n+                            null /* handler */, null /* requiredPermission */, options.toBundle());\n                 } catch (SendIntentException e) {\n                     Slog.w(TAG, e);\n                 }\n@@ -16451,7 +16454,10 @@ public class PackageManagerService extends IPackageManager.Stub\n         fillIn.putExtra(PackageInstaller.EXTRA_STATUS,\n                 PackageManager.installStatusToPublicStatus(returnCode));\n         try {\n-            target.sendIntent(context, 0, fillIn, null, null);\n+            final BroadcastOptions options = BroadcastOptions.makeBasic();\n+            options.setPendingIntentBackgroundActivityLaunchAllowed(false);\n+            target.sendIntent(context, 0, fillIn, null /* onFinished*/,\n+                    null /* handler */, null /* requiredPermission */, options.toBundle());\n         } catch (SendIntentException ignored) {\n         }\n     }\n",
    "added_lines": 8,
    "deleted_lines": 2,
    "changed_methods": "PackageManagerService::onRestoreComplete, PackageManagerService::freeStorage"
   }
  ]
 },
 {
  "hash": "8ef7fac04f4331e2c029002d8d99eb2246d74625",
  "commit": "[RESTRICT AUTOMERGE] Fix bypass BG-FGS and BAL via package manager APIs\n\nOpt-in for BAL of PendingIntent for following APIs:\n\n* PackageInstaller.uninstall()\n* PackageInstaller.installExistingPackage()\n* PackageInstaller.uninstallExistingPackage()\n* PackageInstaller.Session.commit()\n* PackageInstaller.Session.commitTransferred()\n* PackageManager.freeStorage()\n\nBug: 230492955\nBug: 243377226\nTest: atest android.security.cts.PackageInstallerTest\nTest: atest CtsStagedInstallHostTestCases\nChange-Id: I9b6f801d69ea6d2244a38dbe689e81afa4e798bf\n(cherry picked from commit 5f00e89989392c9ae00b360e1388d0179dfb36d7)\nMerged-In: I9b6f801d69ea6d2244a38dbe689e81afa4e798bf",
  "files": [
   {
    "filename": "IntentSender.java",
    "diff": "@@ -19,6 +19,7 @@ package android.content;\n import android.annotation.Nullable;\n import android.app.ActivityManager;\n import android.app.ActivityManager.PendingIntentInfo;\n+import android.app.ActivityOptions;\n import android.compat.annotation.UnsupportedAppUsage;\n import android.os.Bundle;\n import android.os.Handler;\n@@ -158,7 +159,7 @@ public class IntentSender implements Parcelable {\n      */\n     public void sendIntent(Context context, int code, Intent intent,\n             OnFinished onFinished, Handler handler) throws SendIntentException {\n-        sendIntent(context, code, intent, onFinished, handler, null);\n+        sendIntent(context, code, intent, onFinished, handler, null, null /* options */);\n     }\n \n     /**\n@@ -190,6 +191,42 @@ public class IntentSender implements Parcelable {\n     public void sendIntent(Context context, int code, Intent intent,\n             OnFinished onFinished, Handler handler, String requiredPermission)\n             throws SendIntentException {\n+        sendIntent(context, code, intent, onFinished, handler, requiredPermission,\n+                null /* options */);\n+    }\n+\n+    /**\n+     * Perform the operation associated with this IntentSender, allowing the\n+     * caller to specify information about the Intent to use and be notified\n+     * when the send has completed.\n+     *\n+     * @param context The Context of the caller.  This may be null if\n+     * <var>intent</var> is also null.\n+     * @param code Result code to supply back to the IntentSender's target.\n+     * @param intent Additional Intent data.  See {@link Intent#fillIn\n+     * Intent.fillIn()} for information on how this is applied to the\n+     * original Intent.  Use null to not modify the original Intent.\n+     * @param onFinished The object to call back on when the send has\n+     * completed, or null for no callback.\n+     * @param handler Handler identifying the thread on which the callback\n+     * should happen.  If null, the callback will happen from the thread\n+     * pool of the process.\n+     * @param requiredPermission Name of permission that a recipient of the PendingIntent\n+     * is required to hold.  This is only valid for broadcast intents, and\n+     * corresponds to the permission argument in\n+     * {@link Context#sendBroadcast(Intent, String) Context.sendOrderedBroadcast(Intent, String)}.\n+     * If null, no permission is required.\n+     * @param options Additional options the caller would like to provide to modify the sending\n+     * behavior.  May be built from an {@link ActivityOptions} to apply to an activity start.\n+     *\n+     * @throws SendIntentException Throws CanceledIntentException if the IntentSender\n+     * is no longer allowing more intents to be sent through it.\n+     * @hide\n+     */\n+    public void sendIntent(Context context, int code, Intent intent,\n+            OnFinished onFinished, Handler handler, String requiredPermission,\n+            @Nullable Bundle options)\n+            throws SendIntentException {\n         try {\n             String resolvedType = intent != null ?\n                     intent.resolveTypeIfNeeded(context.getContentResolver())\n@@ -199,7 +236,7 @@ public class IntentSender implements Parcelable {\n                     onFinished != null\n                             ? new FinishedDispatcher(this, onFinished, handler)\n                             : null,\n-                    requiredPermission, null);\n+                    requiredPermission, options);\n             if (res < 0) {\n                 throw new SendIntentException();\n             }\n",
    "added_lines": 39,
    "deleted_lines": 2,
    "changed_methods": "IntentSender::sendIntent, IntentSender::sendIntent, IntentSender::sendIntent"
   },
   {
    "filename": "PackageInstallerService.java",
    "diff": "@@ -25,6 +25,7 @@ import android.annotation.Nullable;\n import android.app.ActivityManager;\n import android.app.AppGlobals;\n import android.app.AppOpsManager;\n+import android.app.BroadcastOptions;\n import android.app.Notification;\n import android.app.NotificationManager;\n import android.app.PackageDeleteObserver;\n@@ -1243,7 +1244,10 @@ public class PackageInstallerService extends IPackageInstaller.Stub implements\n                     PackageInstaller.STATUS_PENDING_USER_ACTION);\n             fillIn.putExtra(Intent.EXTRA_INTENT, intent);\n             try {\n-                mTarget.sendIntent(mContext, 0, fillIn, null, null);\n+                final BroadcastOptions options = BroadcastOptions.makeBasic();\n+                options.setPendingIntentBackgroundActivityLaunchAllowed(false);\n+                mTarget.sendIntent(mContext, 0, fillIn, null /* onFinished*/,\n+                        null /* handler */, null /* requiredPermission */, options.toBundle());\n             } catch (SendIntentException ignored) {\n             }\n         }\n@@ -1268,7 +1272,10 @@ public class PackageInstallerService extends IPackageInstaller.Stub implements\n                     PackageManager.deleteStatusToString(returnCode, msg));\n             fillIn.putExtra(PackageInstaller.EXTRA_LEGACY_STATUS, returnCode);\n             try {\n-                mTarget.sendIntent(mContext, 0, fillIn, null, null);\n+                final BroadcastOptions options = BroadcastOptions.makeBasic();\n+                options.setPendingIntentBackgroundActivityLaunchAllowed(false);\n+                mTarget.sendIntent(mContext, 0, fillIn, null /* onFinished*/,\n+                        null /* handler */, null /* requiredPermission */, options.toBundle());\n             } catch (SendIntentException ignored) {\n             }\n         }\n",
    "added_lines": 9,
    "deleted_lines": 2,
    "changed_methods": "PackageInstallerService::PackageDeleteObserverAdapter::onPackageDeleted, PackageInstallerService::PackageDeleteObserverAdapter::onUserActionRequired"
   },
   {
    "filename": "PackageInstallerSession.java",
    "diff": "@@ -50,6 +50,7 @@ import android.annotation.IntDef;\n import android.annotation.NonNull;\n import android.annotation.Nullable;\n import android.app.AppOpsManager;\n+import android.app.BroadcastOptions;\n import android.app.Notification;\n import android.app.NotificationManager;\n import android.app.admin.DevicePolicyEventLogger;\n@@ -1872,7 +1873,11 @@ public class PackageInstallerSession extends IPackageInstallerSession.Stub {\n                     }\n                 } else if (PackageInstaller.STATUS_PENDING_USER_ACTION == status) {\n                     try {\n-                        mStatusReceiver.sendIntent(mContext, 0, intent, null, null);\n+                        final BroadcastOptions options = BroadcastOptions.makeBasic();\n+                        options.setPendingIntentBackgroundActivityLaunchAllowed(false);\n+                        mStatusReceiver.sendIntent(mContext, 0, intent,\n+                                null /* onFinished*/, null /* handler */,\n+                                null /* requiredPermission */, options.toBundle());\n                     } catch (IntentSender.SendIntentException ignore) {\n                     }\n                 } else { // failure, let's forward and clean up this session.\n@@ -4375,7 +4380,10 @@ public class PackageInstallerSession extends IPackageInstallerSession.Stub {\n         fillIn.putExtra(PackageInstaller.EXTRA_STATUS, PackageInstaller.STATUS_PENDING_USER_ACTION);\n         fillIn.putExtra(Intent.EXTRA_INTENT, intent);\n         try {\n-            target.sendIntent(context, 0, fillIn, null, null);\n+            final BroadcastOptions options = BroadcastOptions.makeBasic();\n+            options.setPendingIntentBackgroundActivityLaunchAllowed(false);\n+            target.sendIntent(context, 0, fillIn, null /* onFinished */,\n+                    null /* handler */, null /* requiredPermission */, options.toBundle());\n         } catch (IntentSender.SendIntentException ignored) {\n         }\n     }\n@@ -4418,7 +4426,10 @@ public class PackageInstallerSession extends IPackageInstallerSession.Stub {\n             }\n         }\n         try {\n-            target.sendIntent(context, 0, fillIn, null, null);\n+            final BroadcastOptions options = BroadcastOptions.makeBasic();\n+            options.setPendingIntentBackgroundActivityLaunchAllowed(false);\n+            target.sendIntent(context, 0, fillIn, null /* onFinished */,\n+                    null /* handler */, null /* requiredPermission */, options.toBundle());\n         } catch (IntentSender.SendIntentException ignored) {\n         }\n     }\n@@ -4443,7 +4454,10 @@ public class PackageInstallerSession extends IPackageInstallerSession.Stub {\n             intent.putExtra(PackageInstaller.EXTRA_STATUS_MESSAGE, \"Staging Image Not Ready\");\n         }\n         try {\n-            target.sendIntent(context, 0, intent, null, null);\n+            final BroadcastOptions options = BroadcastOptions.makeBasic();\n+            options.setPendingIntentBackgroundActivityLaunchAllowed(false);\n+            target.sendIntent(context, 0, intent, null /* onFinished */,\n+                    null /* handler */, null /* requiredPermission */, options.toBundle());\n         } catch (IntentSender.SendIntentException ignored) {\n         }\n     }\n",
    "added_lines": 18,
    "deleted_lines": 4,
    "changed_methods": "PackageInstallerSession::sendOnUserActionRequired, PackageInstallerSession::sendOnPackageInstalled, PackageInstallerSession::sendPendingStreaming, PackageInstallerSession::ChildStatusIntentReceiver::statusUpdate"
   },
   {
    "filename": "PackageManagerService.java",
    "diff": "@@ -9268,7 +9268,10 @@ public class PackageManagerService extends IPackageManager.Stub\n             }\n             if (pi != null) {\n                 try {\n-                    pi.sendIntent(null, success ? 1 : 0, null, null, null);\n+                    final BroadcastOptions options = BroadcastOptions.makeBasic();\n+                    options.setPendingIntentBackgroundActivityLaunchAllowed(false);\n+                    pi.sendIntent(null, success ? 1 : 0, null /* intent */, null /* onFinished*/,\n+                            null /* handler */, null /* requiredPermission */, options.toBundle());\n                 } catch (SendIntentException e) {\n                     Slog.w(TAG, e);\n                 }\n@@ -16451,7 +16454,10 @@ public class PackageManagerService extends IPackageManager.Stub\n         fillIn.putExtra(PackageInstaller.EXTRA_STATUS,\n                 PackageManager.installStatusToPublicStatus(returnCode));\n         try {\n-            target.sendIntent(context, 0, fillIn, null, null);\n+            final BroadcastOptions options = BroadcastOptions.makeBasic();\n+            options.setPendingIntentBackgroundActivityLaunchAllowed(false);\n+            target.sendIntent(context, 0, fillIn, null /* onFinished*/,\n+                    null /* handler */, null /* requiredPermission */, options.toBundle());\n         } catch (SendIntentException ignored) {\n         }\n     }\n",
    "added_lines": 8,
    "deleted_lines": 2,
    "changed_methods": "PackageManagerService::onRestoreComplete, PackageManagerService::freeStorage"
   }
  ]
 },
 {
  "hash": "8ef7fac04f4331e2c029002d8d99eb2246d74625",
  "commit": "[RESTRICT AUTOMERGE] Fix bypass BG-FGS and BAL via package manager APIs\n\nOpt-in for BAL of PendingIntent for following APIs:\n\n* PackageInstaller.uninstall()\n* PackageInstaller.installExistingPackage()\n* PackageInstaller.uninstallExistingPackage()\n* PackageInstaller.Session.commit()\n* PackageInstaller.Session.commitTransferred()\n* PackageManager.freeStorage()\n\nBug: 230492955\nBug: 243377226\nTest: atest android.security.cts.PackageInstallerTest\nTest: atest CtsStagedInstallHostTestCases\nChange-Id: I9b6f801d69ea6d2244a38dbe689e81afa4e798bf\n(cherry picked from commit 5f00e89989392c9ae00b360e1388d0179dfb36d7)\nMerged-In: I9b6f801d69ea6d2244a38dbe689e81afa4e798bf",
  "files": [
   {
    "filename": "IntentSender.java",
    "diff": "@@ -19,6 +19,7 @@ package android.content;\n import android.annotation.Nullable;\n import android.app.ActivityManager;\n import android.app.ActivityManager.PendingIntentInfo;\n+import android.app.ActivityOptions;\n import android.compat.annotation.UnsupportedAppUsage;\n import android.os.Bundle;\n import android.os.Handler;\n@@ -158,7 +159,7 @@ public class IntentSender implements Parcelable {\n      */\n     public void sendIntent(Context context, int code, Intent intent,\n             OnFinished onFinished, Handler handler) throws SendIntentException {\n-        sendIntent(context, code, intent, onFinished, handler, null);\n+        sendIntent(context, code, intent, onFinished, handler, null, null /* options */);\n     }\n \n     /**\n@@ -190,6 +191,42 @@ public class IntentSender implements Parcelable {\n     public void sendIntent(Context context, int code, Intent intent,\n             OnFinished onFinished, Handler handler, String requiredPermission)\n             throws SendIntentException {\n+        sendIntent(context, code, intent, onFinished, handler, requiredPermission,\n+                null /* options */);\n+    }\n+\n+    /**\n+     * Perform the operation associated with this IntentSender, allowing the\n+     * caller to specify information about the Intent to use and be notified\n+     * when the send has completed.\n+     *\n+     * @param context The Context of the caller.  This may be null if\n+     * <var>intent</var> is also null.\n+     * @param code Result code to supply back to the IntentSender's target.\n+     * @param intent Additional Intent data.  See {@link Intent#fillIn\n+     * Intent.fillIn()} for information on how this is applied to the\n+     * original Intent.  Use null to not modify the original Intent.\n+     * @param onFinished The object to call back on when the send has\n+     * completed, or null for no callback.\n+     * @param handler Handler identifying the thread on which the callback\n+     * should happen.  If null, the callback will happen from the thread\n+     * pool of the process.\n+     * @param requiredPermission Name of permission that a recipient of the PendingIntent\n+     * is required to hold.  This is only valid for broadcast intents, and\n+     * corresponds to the permission argument in\n+     * {@link Context#sendBroadcast(Intent, String) Context.sendOrderedBroadcast(Intent, String)}.\n+     * If null, no permission is required.\n+     * @param options Additional options the caller would like to provide to modify the sending\n+     * behavior.  May be built from an {@link ActivityOptions} to apply to an activity start.\n+     *\n+     * @throws SendIntentException Throws CanceledIntentException if the IntentSender\n+     * is no longer allowing more intents to be sent through it.\n+     * @hide\n+     */\n+    public void sendIntent(Context context, int code, Intent intent,\n+            OnFinished onFinished, Handler handler, String requiredPermission,\n+            @Nullable Bundle options)\n+            throws SendIntentException {\n         try {\n             String resolvedType = intent != null ?\n                     intent.resolveTypeIfNeeded(context.getContentResolver())\n@@ -199,7 +236,7 @@ public class IntentSender implements Parcelable {\n                     onFinished != null\n                             ? new FinishedDispatcher(this, onFinished, handler)\n                             : null,\n-                    requiredPermission, null);\n+                    requiredPermission, options);\n             if (res < 0) {\n                 throw new SendIntentException();\n             }\n",
    "added_lines": 39,
    "deleted_lines": 2,
    "changed_methods": "IntentSender::sendIntent, IntentSender::sendIntent, IntentSender::sendIntent"
   },
   {
    "filename": "PackageInstallerService.java",
    "diff": "@@ -25,6 +25,7 @@ import android.annotation.Nullable;\n import android.app.ActivityManager;\n import android.app.AppGlobals;\n import android.app.AppOpsManager;\n+import android.app.BroadcastOptions;\n import android.app.Notification;\n import android.app.NotificationManager;\n import android.app.PackageDeleteObserver;\n@@ -1243,7 +1244,10 @@ public class PackageInstallerService extends IPackageInstaller.Stub implements\n                     PackageInstaller.STATUS_PENDING_USER_ACTION);\n             fillIn.putExtra(Intent.EXTRA_INTENT, intent);\n             try {\n-                mTarget.sendIntent(mContext, 0, fillIn, null, null);\n+                final BroadcastOptions options = BroadcastOptions.makeBasic();\n+                options.setPendingIntentBackgroundActivityLaunchAllowed(false);\n+                mTarget.sendIntent(mContext, 0, fillIn, null /* onFinished*/,\n+                        null /* handler */, null /* requiredPermission */, options.toBundle());\n             } catch (SendIntentException ignored) {\n             }\n         }\n@@ -1268,7 +1272,10 @@ public class PackageInstallerService extends IPackageInstaller.Stub implements\n                     PackageManager.deleteStatusToString(returnCode, msg));\n             fillIn.putExtra(PackageInstaller.EXTRA_LEGACY_STATUS, returnCode);\n             try {\n-                mTarget.sendIntent(mContext, 0, fillIn, null, null);\n+                final BroadcastOptions options = BroadcastOptions.makeBasic();\n+                options.setPendingIntentBackgroundActivityLaunchAllowed(false);\n+                mTarget.sendIntent(mContext, 0, fillIn, null /* onFinished*/,\n+                        null /* handler */, null /* requiredPermission */, options.toBundle());\n             } catch (SendIntentException ignored) {\n             }\n         }\n",
    "added_lines": 9,
    "deleted_lines": 2,
    "changed_methods": "PackageInstallerService::PackageDeleteObserverAdapter::onPackageDeleted, PackageInstallerService::PackageDeleteObserverAdapter::onUserActionRequired"
   },
   {
    "filename": "PackageInstallerSession.java",
    "diff": "@@ -50,6 +50,7 @@ import android.annotation.IntDef;\n import android.annotation.NonNull;\n import android.annotation.Nullable;\n import android.app.AppOpsManager;\n+import android.app.BroadcastOptions;\n import android.app.Notification;\n import android.app.NotificationManager;\n import android.app.admin.DevicePolicyEventLogger;\n@@ -1872,7 +1873,11 @@ public class PackageInstallerSession extends IPackageInstallerSession.Stub {\n                     }\n                 } else if (PackageInstaller.STATUS_PENDING_USER_ACTION == status) {\n                     try {\n-                        mStatusReceiver.sendIntent(mContext, 0, intent, null, null);\n+                        final BroadcastOptions options = BroadcastOptions.makeBasic();\n+                        options.setPendingIntentBackgroundActivityLaunchAllowed(false);\n+                        mStatusReceiver.sendIntent(mContext, 0, intent,\n+                                null /* onFinished*/, null /* handler */,\n+                                null /* requiredPermission */, options.toBundle());\n                     } catch (IntentSender.SendIntentException ignore) {\n                     }\n                 } else { // failure, let's forward and clean up this session.\n@@ -4375,7 +4380,10 @@ public class PackageInstallerSession extends IPackageInstallerSession.Stub {\n         fillIn.putExtra(PackageInstaller.EXTRA_STATUS, PackageInstaller.STATUS_PENDING_USER_ACTION);\n         fillIn.putExtra(Intent.EXTRA_INTENT, intent);\n         try {\n-            target.sendIntent(context, 0, fillIn, null, null);\n+            final BroadcastOptions options = BroadcastOptions.makeBasic();\n+            options.setPendingIntentBackgroundActivityLaunchAllowed(false);\n+            target.sendIntent(context, 0, fillIn, null /* onFinished */,\n+                    null /* handler */, null /* requiredPermission */, options.toBundle());\n         } catch (IntentSender.SendIntentException ignored) {\n         }\n     }\n@@ -4418,7 +4426,10 @@ public class PackageInstallerSession extends IPackageInstallerSession.Stub {\n             }\n         }\n         try {\n-            target.sendIntent(context, 0, fillIn, null, null);\n+            final BroadcastOptions options = BroadcastOptions.makeBasic();\n+            options.setPendingIntentBackgroundActivityLaunchAllowed(false);\n+            target.sendIntent(context, 0, fillIn, null /* onFinished */,\n+                    null /* handler */, null /* requiredPermission */, options.toBundle());\n         } catch (IntentSender.SendIntentException ignored) {\n         }\n     }\n@@ -4443,7 +4454,10 @@ public class PackageInstallerSession extends IPackageInstallerSession.Stub {\n             intent.putExtra(PackageInstaller.EXTRA_STATUS_MESSAGE, \"Staging Image Not Ready\");\n         }\n         try {\n-            target.sendIntent(context, 0, intent, null, null);\n+            final BroadcastOptions options = BroadcastOptions.makeBasic();\n+            options.setPendingIntentBackgroundActivityLaunchAllowed(false);\n+            target.sendIntent(context, 0, intent, null /* onFinished */,\n+                    null /* handler */, null /* requiredPermission */, options.toBundle());\n         } catch (IntentSender.SendIntentException ignored) {\n         }\n     }\n",
    "added_lines": 18,
    "deleted_lines": 4,
    "changed_methods": "PackageInstallerSession::sendOnUserActionRequired, PackageInstallerSession::sendOnPackageInstalled, PackageInstallerSession::sendPendingStreaming, PackageInstallerSession::ChildStatusIntentReceiver::statusUpdate"
   },
   {
    "filename": "PackageManagerService.java",
    "diff": "@@ -9268,7 +9268,10 @@ public class PackageManagerService extends IPackageManager.Stub\n             }\n             if (pi != null) {\n                 try {\n-                    pi.sendIntent(null, success ? 1 : 0, null, null, null);\n+                    final BroadcastOptions options = BroadcastOptions.makeBasic();\n+                    options.setPendingIntentBackgroundActivityLaunchAllowed(false);\n+                    pi.sendIntent(null, success ? 1 : 0, null /* intent */, null /* onFinished*/,\n+                            null /* handler */, null /* requiredPermission */, options.toBundle());\n                 } catch (SendIntentException e) {\n                     Slog.w(TAG, e);\n                 }\n@@ -16451,7 +16454,10 @@ public class PackageManagerService extends IPackageManager.Stub\n         fillIn.putExtra(PackageInstaller.EXTRA_STATUS,\n                 PackageManager.installStatusToPublicStatus(returnCode));\n         try {\n-            target.sendIntent(context, 0, fillIn, null, null);\n+            final BroadcastOptions options = BroadcastOptions.makeBasic();\n+            options.setPendingIntentBackgroundActivityLaunchAllowed(false);\n+            target.sendIntent(context, 0, fillIn, null /* onFinished*/,\n+                    null /* handler */, null /* requiredPermission */, options.toBundle());\n         } catch (SendIntentException ignored) {\n         }\n     }\n",
    "added_lines": 8,
    "deleted_lines": 2,
    "changed_methods": "PackageManagerService::onRestoreComplete, PackageManagerService::freeStorage"
   }
  ]
 },
 {
  "hash": "e026818a26445b2a67b55108e1e3e05ca01ccb7b",
  "commit": "Revert \"Make Activites touch opaque - DO NOT MERGE\"\n\nThis reverts commit 22261fa6649f6ec6441646743ad98132fcf47fe0.\n\nReason for revert: Re-release due to functional regression\n\nChange-Id: I9ca1fa2f140d640159fabec1424c52867cf01a60\n(cherry picked from commit 23bf0bda7d9b97a82ea04257318bb90677561476)\nMerged-In: I9ca1fa2f140d640159fabec1424c52867cf01a60",
  "files": [
   {
    "filename": "ActivityRecord.java",
    "diff": "@@ -804,13 +804,6 @@ final class ActivityRecord extends WindowToken implements WindowManagerService.A\n \n     private AppSaturationInfo mLastAppSaturationInfo;\n \n-    private final ActivityRecordInputSink mActivityRecordInputSink;\n-\n-    // Activities with this uid are allowed to not create an input sink while being in the same\n-    // task and directly above this ActivityRecord. This field is updated whenever a new activity\n-    // is launched from this ActivityRecord. Touches are always allowed within the same uid.\n-    int mAllowedTouchUid;\n-\n     private final ColorDisplayService.ColorTransformController mColorTransformController =\n             (matrix, translation) -> mWmService.mH.post(() -> {\n                 synchronized (mWmService.mGlobalLock) {\n@@ -1848,8 +1841,6 @@ final class ActivityRecord extends WindowToken implements WindowManagerService.A\n             createTime = _createTime;\n         }\n         mAtmService.mPackageConfigPersister.updateConfigIfNeeded(this, mUserId, packageName);\n-\n-        mActivityRecordInputSink = new ActivityRecordInputSink(this, sourceRecord);\n     }\n \n     /**\n@@ -3776,7 +3767,6 @@ final class ActivityRecord extends WindowToken implements WindowManagerService.A\n         } else {\n             onRemovedFromDisplay();\n         }\n-        mActivityRecordInputSink.releaseSurfaceControl();\n         super.removeImmediately();\n     }\n \n@@ -6936,9 +6926,6 @@ final class ActivityRecord extends WindowToken implements WindowManagerService.A\n             } else if (!show && mLastSurfaceShowing) {\n                 getSyncTransaction().hide(mSurfaceControl);\n             }\n-            if (show) {\n-                mActivityRecordInputSink.applyChangesToSurfaceIfChanged(getSyncTransaction());\n-            }\n         }\n         if (mThumbnail != null) {\n             mThumbnail.setShowing(getPendingTransaction(), show);\n",
    "added_lines": 0,
    "deleted_lines": 13,
    "changed_methods": "ActivityRecord::ActivityRecord, ActivityRecord::prepareSurfaces, ActivityRecord::removeImmediately"
   },
   {
    "filename": "ActivityRecordInputSink.java",
    "diff": "@@ -1,113 +0,0 @@\n-/*\n- * Copyright (C) 2022 The Android Open Source Project\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.android.server.wm;\n-\n-import android.os.Process;\n-import android.view.InputWindowHandle;\n-import android.view.SurfaceControl;\n-import android.view.WindowManager;\n-\n-/**\n- * Creates a InputWindowHandle that catches all touches that would otherwise pass through an\n- * Activity.\n- */\n-class ActivityRecordInputSink {\n-\n-    private final ActivityRecord mActivityRecord;\n-    private final String mName;\n-\n-    private InputWindowHandle mInputWindowHandle;\n-    private SurfaceControl mSurfaceControl;\n-\n-    ActivityRecordInputSink(ActivityRecord activityRecord, ActivityRecord sourceRecord) {\n-        mActivityRecord = activityRecord;\n-        mName = Integer.toHexString(System.identityHashCode(this)) + \" ActivityRecordInputSink \"\n-                + mActivityRecord.mActivityComponent.flattenToShortString();\n-        if (sourceRecord != null) {\n-            sourceRecord.mAllowedTouchUid = mActivityRecord.getUid();\n-        }\n-    }\n-\n-    public void applyChangesToSurfaceIfChanged(SurfaceControl.Transaction transaction) {\n-        boolean windowHandleChanged = updateInputWindowHandle();\n-        if (mSurfaceControl == null) {\n-            mSurfaceControl = createSurface(transaction);\n-        }\n-        if (windowHandleChanged) {\n-            transaction.setInputWindowInfo(mSurfaceControl, mInputWindowHandle);\n-        }\n-    }\n-\n-    private SurfaceControl createSurface(SurfaceControl.Transaction t) {\n-        SurfaceControl surfaceControl = mActivityRecord.makeChildSurface(null)\n-                .setName(mName)\n-                .setHidden(false)\n-                .setCallsite(\"ActivityRecordInputSink.createSurface\")\n-                .build();\n-        // Put layer below all siblings (and the parent surface too)\n-        t.setLayer(surfaceControl, Integer.MIN_VALUE);\n-        return surfaceControl;\n-    }\n-\n-    private boolean updateInputWindowHandle() {\n-        boolean changed = false;\n-        if (mInputWindowHandle == null) {\n-            mInputWindowHandle = createInputWindowHandle();\n-            changed = true;\n-        }\n-        // Don't block touches from passing through to an activity below us in the same task, if\n-        // that activity is either from the same uid or if that activity has launched an activity\n-        // in our uid.\n-        final ActivityRecord activityBelowInTask =\n-                mActivityRecord.getTask().getActivityBelow(mActivityRecord);\n-        final boolean allowPassthrough = activityBelowInTask != null && (\n-                activityBelowInTask.mAllowedTouchUid == mActivityRecord.getUid()\n-                        || activityBelowInTask.isUid(mActivityRecord.getUid()));\n-        boolean notTouchable = (mInputWindowHandle.layoutParamsFlags\n-                & WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE) != 0;\n-        if (allowPassthrough || mActivityRecord.isAppTransitioning()) {\n-            mInputWindowHandle.layoutParamsFlags |= WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;\n-            changed |= !notTouchable;\n-        } else {\n-            mInputWindowHandle.layoutParamsFlags &= ~WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;\n-            changed |= notTouchable;\n-        }\n-        return changed;\n-    }\n-\n-    private InputWindowHandle createInputWindowHandle() {\n-        InputWindowHandle inputWindowHandle = new InputWindowHandle(null,\n-                mActivityRecord.getDisplayId());\n-        inputWindowHandle.replaceTouchableRegionWithCrop = true;\n-        inputWindowHandle.name = mName;\n-        inputWindowHandle.layoutParamsType = WindowManager.LayoutParams.TYPE_INPUT_CONSUMER;\n-        inputWindowHandle.ownerUid = Process.myUid();\n-        inputWindowHandle.ownerPid = Process.myPid();\n-        inputWindowHandle.layoutParamsFlags = WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;\n-        inputWindowHandle.inputFeatures =\n-                WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL;\n-        return inputWindowHandle;\n-    }\n-\n-    void releaseSurfaceControl() {\n-        if (mSurfaceControl != null) {\n-            mSurfaceControl.release();\n-            mSurfaceControl = null;\n-        }\n-    }\n-\n-}\n",
    "added_lines": 0,
    "deleted_lines": 113,
    "changed_methods": "ActivityRecordInputSink::releaseSurfaceControl, ActivityRecordInputSink::applyChangesToSurfaceIfChanged, ActivityRecordInputSink::ActivityRecordInputSink, ActivityRecordInputSink::updateInputWindowHandle, ActivityRecordInputSink::createSurface, ActivityRecordInputSink::createInputWindowHandle"
   }
  ]
 },
 {
  "hash": "e026818a26445b2a67b55108e1e3e05ca01ccb7b",
  "commit": "Revert \"Make Activites touch opaque - DO NOT MERGE\"\n\nThis reverts commit 22261fa6649f6ec6441646743ad98132fcf47fe0.\n\nReason for revert: Re-release due to functional regression\n\nChange-Id: I9ca1fa2f140d640159fabec1424c52867cf01a60\n(cherry picked from commit 23bf0bda7d9b97a82ea04257318bb90677561476)\nMerged-In: I9ca1fa2f140d640159fabec1424c52867cf01a60",
  "files": [
   {
    "filename": "ActivityRecord.java",
    "diff": "@@ -804,13 +804,6 @@ final class ActivityRecord extends WindowToken implements WindowManagerService.A\n \n     private AppSaturationInfo mLastAppSaturationInfo;\n \n-    private final ActivityRecordInputSink mActivityRecordInputSink;\n-\n-    // Activities with this uid are allowed to not create an input sink while being in the same\n-    // task and directly above this ActivityRecord. This field is updated whenever a new activity\n-    // is launched from this ActivityRecord. Touches are always allowed within the same uid.\n-    int mAllowedTouchUid;\n-\n     private final ColorDisplayService.ColorTransformController mColorTransformController =\n             (matrix, translation) -> mWmService.mH.post(() -> {\n                 synchronized (mWmService.mGlobalLock) {\n@@ -1848,8 +1841,6 @@ final class ActivityRecord extends WindowToken implements WindowManagerService.A\n             createTime = _createTime;\n         }\n         mAtmService.mPackageConfigPersister.updateConfigIfNeeded(this, mUserId, packageName);\n-\n-        mActivityRecordInputSink = new ActivityRecordInputSink(this, sourceRecord);\n     }\n \n     /**\n@@ -3776,7 +3767,6 @@ final class ActivityRecord extends WindowToken implements WindowManagerService.A\n         } else {\n             onRemovedFromDisplay();\n         }\n-        mActivityRecordInputSink.releaseSurfaceControl();\n         super.removeImmediately();\n     }\n \n@@ -6936,9 +6926,6 @@ final class ActivityRecord extends WindowToken implements WindowManagerService.A\n             } else if (!show && mLastSurfaceShowing) {\n                 getSyncTransaction().hide(mSurfaceControl);\n             }\n-            if (show) {\n-                mActivityRecordInputSink.applyChangesToSurfaceIfChanged(getSyncTransaction());\n-            }\n         }\n         if (mThumbnail != null) {\n             mThumbnail.setShowing(getPendingTransaction(), show);\n",
    "added_lines": 0,
    "deleted_lines": 13,
    "changed_methods": "ActivityRecord::ActivityRecord, ActivityRecord::prepareSurfaces, ActivityRecord::removeImmediately"
   },
   {
    "filename": "ActivityRecordInputSink.java",
    "diff": "@@ -1,113 +0,0 @@\n-/*\n- * Copyright (C) 2022 The Android Open Source Project\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.android.server.wm;\n-\n-import android.os.Process;\n-import android.view.InputWindowHandle;\n-import android.view.SurfaceControl;\n-import android.view.WindowManager;\n-\n-/**\n- * Creates a InputWindowHandle that catches all touches that would otherwise pass through an\n- * Activity.\n- */\n-class ActivityRecordInputSink {\n-\n-    private final ActivityRecord mActivityRecord;\n-    private final String mName;\n-\n-    private InputWindowHandle mInputWindowHandle;\n-    private SurfaceControl mSurfaceControl;\n-\n-    ActivityRecordInputSink(ActivityRecord activityRecord, ActivityRecord sourceRecord) {\n-        mActivityRecord = activityRecord;\n-        mName = Integer.toHexString(System.identityHashCode(this)) + \" ActivityRecordInputSink \"\n-                + mActivityRecord.mActivityComponent.flattenToShortString();\n-        if (sourceRecord != null) {\n-            sourceRecord.mAllowedTouchUid = mActivityRecord.getUid();\n-        }\n-    }\n-\n-    public void applyChangesToSurfaceIfChanged(SurfaceControl.Transaction transaction) {\n-        boolean windowHandleChanged = updateInputWindowHandle();\n-        if (mSurfaceControl == null) {\n-            mSurfaceControl = createSurface(transaction);\n-        }\n-        if (windowHandleChanged) {\n-            transaction.setInputWindowInfo(mSurfaceControl, mInputWindowHandle);\n-        }\n-    }\n-\n-    private SurfaceControl createSurface(SurfaceControl.Transaction t) {\n-        SurfaceControl surfaceControl = mActivityRecord.makeChildSurface(null)\n-                .setName(mName)\n-                .setHidden(false)\n-                .setCallsite(\"ActivityRecordInputSink.createSurface\")\n-                .build();\n-        // Put layer below all siblings (and the parent surface too)\n-        t.setLayer(surfaceControl, Integer.MIN_VALUE);\n-        return surfaceControl;\n-    }\n-\n-    private boolean updateInputWindowHandle() {\n-        boolean changed = false;\n-        if (mInputWindowHandle == null) {\n-            mInputWindowHandle = createInputWindowHandle();\n-            changed = true;\n-        }\n-        // Don't block touches from passing through to an activity below us in the same task, if\n-        // that activity is either from the same uid or if that activity has launched an activity\n-        // in our uid.\n-        final ActivityRecord activityBelowInTask =\n-                mActivityRecord.getTask().getActivityBelow(mActivityRecord);\n-        final boolean allowPassthrough = activityBelowInTask != null && (\n-                activityBelowInTask.mAllowedTouchUid == mActivityRecord.getUid()\n-                        || activityBelowInTask.isUid(mActivityRecord.getUid()));\n-        boolean notTouchable = (mInputWindowHandle.layoutParamsFlags\n-                & WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE) != 0;\n-        if (allowPassthrough || mActivityRecord.isAppTransitioning()) {\n-            mInputWindowHandle.layoutParamsFlags |= WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;\n-            changed |= !notTouchable;\n-        } else {\n-            mInputWindowHandle.layoutParamsFlags &= ~WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;\n-            changed |= notTouchable;\n-        }\n-        return changed;\n-    }\n-\n-    private InputWindowHandle createInputWindowHandle() {\n-        InputWindowHandle inputWindowHandle = new InputWindowHandle(null,\n-                mActivityRecord.getDisplayId());\n-        inputWindowHandle.replaceTouchableRegionWithCrop = true;\n-        inputWindowHandle.name = mName;\n-        inputWindowHandle.layoutParamsType = WindowManager.LayoutParams.TYPE_INPUT_CONSUMER;\n-        inputWindowHandle.ownerUid = Process.myUid();\n-        inputWindowHandle.ownerPid = Process.myPid();\n-        inputWindowHandle.layoutParamsFlags = WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;\n-        inputWindowHandle.inputFeatures =\n-                WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL;\n-        return inputWindowHandle;\n-    }\n-\n-    void releaseSurfaceControl() {\n-        if (mSurfaceControl != null) {\n-            mSurfaceControl.release();\n-            mSurfaceControl = null;\n-        }\n-    }\n-\n-}\n",
    "added_lines": 0,
    "deleted_lines": 113,
    "changed_methods": "ActivityRecordInputSink::releaseSurfaceControl, ActivityRecordInputSink::applyChangesToSurfaceIfChanged, ActivityRecordInputSink::ActivityRecordInputSink, ActivityRecordInputSink::updateInputWindowHandle, ActivityRecordInputSink::createSurface, ActivityRecordInputSink::createInputWindowHandle"
   }
  ]
 },
 {
  "hash": "a0f0bd03a63c7a982209c0997637eb4797d0b3d9",
  "commit": "[RESTRICT AUTOMERGE][pm] prevent system app downgrades of versions lower than preload\n\nAlso remove misleading commandline output.\n\nBUG: 256202273\n\nTest: manual\n1. Install preload system app v90, reboot\n2. (W/O data, W/ Flag, 90->80 NOK) adb install -d ~/Downloads/PrivApplication_80.apk\nPerforming Streamed Install\nadb: failed to install /usr/local/google/home/schfan/Downloads/PrivApplication_80.apk: Failure [INSTALL_FAILED_VERSION_DOWNGRADE: System app: com.example.privapplication cannot be downgraded to older than its preloaded version on the system image. Update version code 80 is older than current 90]\n3. (90->100) Install data app v100\n4. (W/ data, W/O Flag, 100->90 NOK) adb install ~/Downloads/PrivApplication_90.apk\nPerforming Streamed Install\nadb: failed to install /usr/local/google/home/schfan/Downloads/PrivApplication_90.apk: Failure [INSTALL_FAILED_VERSION_DOWNGRADE: Downgrade detected: Update version code 90 is older than current 100]\n5. (W/ data, W/ Flag, 100->90 downgrade OK) adb install -d ~/Downloads/PrivApplication_90.apk\nPerforming Streamed Install\nSuccess\n6. (90->100) Install v100\n6. (W/data, W/ Flag, 100->80 NOK) adb install -d ~/Downloads/PrivApplication_80.apk\nPerforming Streamed Install\nadb: failed to install /usr/local/google/home/schfan/Downloads/PrivApplication_80.apk: Failure [INSTALL_FAILED_VERSION_DOWNGRADE: System app: com.example.privapplication cannot be downgraded to older than its preloaded version on the system image. Update version code 80 is older than current 90]\n\nChange-Id: I5a8ee9e29a3a58f6e3fd188e0122355744b8b0ce\n(cherry picked from commit a4484d7f1be1fa413258fe18644d61f85611f586)\n(cherry picked from commit on googleplex-android-review.googlesource.com host: cc9d3867082ac1518b7264c3752442f5ca112aa1)\nMerged-In: I5a8ee9e29a3a58f6e3fd188e0122355744b8b0ce",
  "files": [
   {
    "filename": "PackageManagerService.java",
    "diff": "@@ -26939,10 +26939,10 @@ public class PackageManagerService extends IPackageManager.Stub\n             // will be null whereas dataOwnerPkg will contain information about the package\n             // which was uninstalled while keeping its data.\n             AndroidPackage dataOwnerPkg = mPackages.get(packageName);\n+            PackageSetting dataOwnerPs = mSettings.getPackageLPr(packageName);\n             if (dataOwnerPkg  == null) {\n-                PackageSetting ps = mSettings.getPackageLPr(packageName);\n-                if (ps != null) {\n-                    dataOwnerPkg = ps.pkg;\n+                if (dataOwnerPs != null) {\n+                    dataOwnerPkg = dataOwnerPs.getPkg();\n                 }\n             }\n \n@@ -26966,12 +26966,30 @@ public class PackageManagerService extends IPackageManager.Stub\n             if (dataOwnerPkg != null) {\n                 if (!PackageManagerServiceUtils.isDowngradePermitted(installFlags,\n                         dataOwnerPkg.isDebuggable())) {\n+                    // Downgrade is not permitted; a lower version of the app will not be allowed\n                     try {\n                         checkDowngrade(dataOwnerPkg, pkgLite);\n                     } catch (PackageManagerException e) {\n                         Slog.w(TAG, \"Downgrade detected: \" + e.getMessage());\n                         return PackageManager.INSTALL_FAILED_VERSION_DOWNGRADE;\n                     }\n+                } else if (dataOwnerPs.isSystem()) {\n+                    // Downgrade is permitted, but system apps can't be downgraded below\n+                    // the version preloaded onto the system image\n+                    final PackageSetting disabledPs = mSettings.getDisabledSystemPkgLPr(\n+                            dataOwnerPs);\n+                    if (disabledPs != null) {\n+                        dataOwnerPkg = disabledPs.getPkg();\n+                    }\n+                    try {\n+                        checkDowngrade(dataOwnerPkg, pkgLite);\n+                    } catch (PackageManagerException e) {\n+                        String errorMsg = \"System app: \" + packageName + \" cannot be downgraded to\"\n+                                + \" older than its preloaded version on the system image. \"\n+                                + e.getMessage();\n+                        Slog.w(TAG, errorMsg);\n+                        return PackageManager.INSTALL_FAILED_VERSION_DOWNGRADE;\n+                    }\n                 }\n             }\n         }\n",
    "added_lines": 21,
    "deleted_lines": 3,
    "changed_methods": "PackageManagerService::verifyReplacingVersionCode"
   }
  ]
 },
 {
  "hash": "84a1cc875280fd7a2b60642303a1755f5edcdfaa",
  "commit": "[RESTRICT AUTOMERGE][pm] still allow debuggable for system app downgrades\n\nTurns out we do have internal tests that downgrades system apps, so adding this exception to allow for that.\n\nBUG: 267232653\nBUG: 256202273\n\nTest: manual\nChange-Id: Ie281bbdc8788ee64ff99a7c5150da7ce7926235e\n(cherry picked from commit ceeca68b8c3f0ed8427b0212f63defe2f075146e)\n(cherry picked from commit on googleplex-android-review.googlesource.com host: 636cdf22b90ccb4866f380c307b7e1b92da03ed9)\nMerged-In: Ie281bbdc8788ee64ff99a7c5150da7ce7926235e",
  "files": [
   {
    "filename": "PackageManagerService.java",
    "diff": "@@ -26981,14 +26981,18 @@ public class PackageManagerService extends IPackageManager.Stub\n                     if (disabledPs != null) {\n                         dataOwnerPkg = disabledPs.getPkg();\n                     }\n-                    try {\n-                        checkDowngrade(dataOwnerPkg, pkgLite);\n-                    } catch (PackageManagerException e) {\n-                        String errorMsg = \"System app: \" + packageName + \" cannot be downgraded to\"\n-                                + \" older than its preloaded version on the system image. \"\n-                                + e.getMessage();\n-                        Slog.w(TAG, errorMsg);\n-                        return PackageManager.INSTALL_FAILED_VERSION_DOWNGRADE;\n+                    if (!Build.IS_DEBUGGABLE && !dataOwnerPkg.isDebuggable()) {\n+                        // Only restrict non-debuggable builds and non-debuggable version of the app\n+                        try {\n+                            checkDowngrade(dataOwnerPkg, pkgLite);\n+                        } catch (PackageManagerException e) {\n+                            String errorMsg = \"System app: \" + packageName\n+                                    + \" cannot be downgraded to\"\n+                                    + \" older than its preloaded version on the system image. \"\n+                                    + e.getMessage();\n+                            Slog.w(TAG, errorMsg);\n+                            return PackageManager.INSTALL_FAILED_VERSION_DOWNGRADE;\n+                        }\n                     }\n                 }\n             }\n",
    "added_lines": 12,
    "deleted_lines": 8,
    "changed_methods": "PackageManagerService::verifyReplacingVersionCode"
   }
  ]
 },
 {
  "hash": "79d93158979161d6d3a842ec9400a03c5074e06f",
  "commit": "Checks if AccessibilityServiceInfo is within parcelable size.\n\n- If too large when parsing service XMLs then skip this service.\n- If too large when a service attempts to update its own info\n  then throw an error.\n\nBug: 261589597\nTest: atest AccessibilityServiceInfoTest\nChange-Id: Iffc0cd48cc713f7904d68059e141cb7de5a4b906\nMerged-In: Iffc0cd48cc713f7904d68059e141cb7de5a4b906\n(cherry picked from commit on googleplex-android-review.googlesource.com host: 553232c29079fbeab28f95307d025c1426aa7142)\nMerged-In: Iffc0cd48cc713f7904d68059e141cb7de5a4b906",
  "files": [
   {
    "filename": "AccessibilityService.java",
    "diff": "@@ -2054,6 +2054,10 @@ public abstract class AccessibilityService extends Service {\n         IAccessibilityServiceConnection connection =\n                 AccessibilityInteractionClient.getInstance(this).getConnection(mConnectionId);\n         if (mInfo != null && connection != null) {\n+            if (!mInfo.isWithinParcelableSize()) {\n+                throw new IllegalStateException(\n+                        \"Cannot update service info: size is larger than safe parcelable limits.\");\n+            }\n             try {\n                 connection.setServiceInfo(mInfo);\n                 mInfo = null;\n",
    "added_lines": 4,
    "deleted_lines": 0,
    "changed_methods": "AccessibilityService::sendServiceInfo"
   },
   {
    "filename": "AccessibilityServiceInfo.java",
    "diff": "@@ -40,6 +40,7 @@ import android.content.res.XmlResourceParser;\n import android.graphics.drawable.Drawable;\n import android.hardware.fingerprint.FingerprintManager;\n import android.os.Build;\n+import android.os.IBinder;\n import android.os.Parcel;\n import android.os.Parcelable;\n import android.os.RemoteException;\n@@ -1063,6 +1064,15 @@ public class AccessibilityServiceInfo implements Parcelable {\n         return 0;\n     }\n \n+    /** @hide */\n+    public final boolean isWithinParcelableSize() {\n+        final Parcel parcel = Parcel.obtain();\n+        writeToParcel(parcel, 0);\n+        final boolean result = parcel.dataSize() <= IBinder.MAX_IPC_SIZE;\n+        parcel.recycle();\n+        return result;\n+    }\n+\n     public void writeToParcel(Parcel parcel, int flagz) {\n         parcel.writeInt(eventTypes);\n         parcel.writeStringArray(packageNames);\n",
    "added_lines": 10,
    "deleted_lines": 0,
    "changed_methods": "AccessibilityServiceInfo::isWithinParcelableSize"
   },
   {
    "filename": "AccessibilityManagerService.java",
    "diff": "@@ -1610,6 +1610,12 @@ public class AccessibilityManagerService extends IAccessibilityManager.Stub\n             AccessibilityServiceInfo accessibilityServiceInfo;\n             try {\n                 accessibilityServiceInfo = new AccessibilityServiceInfo(resolveInfo, mContext);\n+                if (!accessibilityServiceInfo.isWithinParcelableSize()) {\n+                    Slog.e(LOG_TAG, \"Skipping service \"\n+                            + accessibilityServiceInfo.getResolveInfo().getComponentInfo()\n+                            + \" because service info size is larger than safe parcelable limits.\");\n+                    continue;\n+                }\n                 if (userState.mCrashedServices.contains(serviceInfo.getComponentName())) {\n                     // Restore the crashed attribute.\n                     accessibilityServiceInfo.crashed = true;\n",
    "added_lines": 6,
    "deleted_lines": 0,
    "changed_methods": "AccessibilityManagerService::readInstalledAccessibilityServiceLocked"
   }
  ]
 },
 {
  "hash": "79d93158979161d6d3a842ec9400a03c5074e06f",
  "commit": "Checks if AccessibilityServiceInfo is within parcelable size.\n\n- If too large when parsing service XMLs then skip this service.\n- If too large when a service attempts to update its own info\n  then throw an error.\n\nBug: 261589597\nTest: atest AccessibilityServiceInfoTest\nChange-Id: Iffc0cd48cc713f7904d68059e141cb7de5a4b906\nMerged-In: Iffc0cd48cc713f7904d68059e141cb7de5a4b906\n(cherry picked from commit on googleplex-android-review.googlesource.com host: 553232c29079fbeab28f95307d025c1426aa7142)\nMerged-In: Iffc0cd48cc713f7904d68059e141cb7de5a4b906",
  "files": [
   {
    "filename": "AccessibilityService.java",
    "diff": "@@ -2054,6 +2054,10 @@ public abstract class AccessibilityService extends Service {\n         IAccessibilityServiceConnection connection =\n                 AccessibilityInteractionClient.getInstance(this).getConnection(mConnectionId);\n         if (mInfo != null && connection != null) {\n+            if (!mInfo.isWithinParcelableSize()) {\n+                throw new IllegalStateException(\n+                        \"Cannot update service info: size is larger than safe parcelable limits.\");\n+            }\n             try {\n                 connection.setServiceInfo(mInfo);\n                 mInfo = null;\n",
    "added_lines": 4,
    "deleted_lines": 0,
    "changed_methods": "AccessibilityService::sendServiceInfo"
   },
   {
    "filename": "AccessibilityServiceInfo.java",
    "diff": "@@ -40,6 +40,7 @@ import android.content.res.XmlResourceParser;\n import android.graphics.drawable.Drawable;\n import android.hardware.fingerprint.FingerprintManager;\n import android.os.Build;\n+import android.os.IBinder;\n import android.os.Parcel;\n import android.os.Parcelable;\n import android.os.RemoteException;\n@@ -1063,6 +1064,15 @@ public class AccessibilityServiceInfo implements Parcelable {\n         return 0;\n     }\n \n+    /** @hide */\n+    public final boolean isWithinParcelableSize() {\n+        final Parcel parcel = Parcel.obtain();\n+        writeToParcel(parcel, 0);\n+        final boolean result = parcel.dataSize() <= IBinder.MAX_IPC_SIZE;\n+        parcel.recycle();\n+        return result;\n+    }\n+\n     public void writeToParcel(Parcel parcel, int flagz) {\n         parcel.writeInt(eventTypes);\n         parcel.writeStringArray(packageNames);\n",
    "added_lines": 10,
    "deleted_lines": 0,
    "changed_methods": "AccessibilityServiceInfo::isWithinParcelableSize"
   },
   {
    "filename": "AccessibilityManagerService.java",
    "diff": "@@ -1610,6 +1610,12 @@ public class AccessibilityManagerService extends IAccessibilityManager.Stub\n             AccessibilityServiceInfo accessibilityServiceInfo;\n             try {\n                 accessibilityServiceInfo = new AccessibilityServiceInfo(resolveInfo, mContext);\n+                if (!accessibilityServiceInfo.isWithinParcelableSize()) {\n+                    Slog.e(LOG_TAG, \"Skipping service \"\n+                            + accessibilityServiceInfo.getResolveInfo().getComponentInfo()\n+                            + \" because service info size is larger than safe parcelable limits.\");\n+                    continue;\n+                }\n                 if (userState.mCrashedServices.contains(serviceInfo.getComponentName())) {\n                     // Restore the crashed attribute.\n                     accessibilityServiceInfo.crashed = true;\n",
    "added_lines": 6,
    "deleted_lines": 0,
    "changed_methods": "AccessibilityManagerService::readInstalledAccessibilityServiceLocked"
   }
  ]
 },
 {
  "hash": "79d93158979161d6d3a842ec9400a03c5074e06f",
  "commit": "Checks if AccessibilityServiceInfo is within parcelable size.\n\n- If too large when parsing service XMLs then skip this service.\n- If too large when a service attempts to update its own info\n  then throw an error.\n\nBug: 261589597\nTest: atest AccessibilityServiceInfoTest\nChange-Id: Iffc0cd48cc713f7904d68059e141cb7de5a4b906\nMerged-In: Iffc0cd48cc713f7904d68059e141cb7de5a4b906\n(cherry picked from commit on googleplex-android-review.googlesource.com host: 553232c29079fbeab28f95307d025c1426aa7142)\nMerged-In: Iffc0cd48cc713f7904d68059e141cb7de5a4b906",
  "files": [
   {
    "filename": "AccessibilityService.java",
    "diff": "@@ -2054,6 +2054,10 @@ public abstract class AccessibilityService extends Service {\n         IAccessibilityServiceConnection connection =\n                 AccessibilityInteractionClient.getInstance(this).getConnection(mConnectionId);\n         if (mInfo != null && connection != null) {\n+            if (!mInfo.isWithinParcelableSize()) {\n+                throw new IllegalStateException(\n+                        \"Cannot update service info: size is larger than safe parcelable limits.\");\n+            }\n             try {\n                 connection.setServiceInfo(mInfo);\n                 mInfo = null;\n",
    "added_lines": 4,
    "deleted_lines": 0,
    "changed_methods": "AccessibilityService::sendServiceInfo"
   },
   {
    "filename": "AccessibilityServiceInfo.java",
    "diff": "@@ -40,6 +40,7 @@ import android.content.res.XmlResourceParser;\n import android.graphics.drawable.Drawable;\n import android.hardware.fingerprint.FingerprintManager;\n import android.os.Build;\n+import android.os.IBinder;\n import android.os.Parcel;\n import android.os.Parcelable;\n import android.os.RemoteException;\n@@ -1063,6 +1064,15 @@ public class AccessibilityServiceInfo implements Parcelable {\n         return 0;\n     }\n \n+    /** @hide */\n+    public final boolean isWithinParcelableSize() {\n+        final Parcel parcel = Parcel.obtain();\n+        writeToParcel(parcel, 0);\n+        final boolean result = parcel.dataSize() <= IBinder.MAX_IPC_SIZE;\n+        parcel.recycle();\n+        return result;\n+    }\n+\n     public void writeToParcel(Parcel parcel, int flagz) {\n         parcel.writeInt(eventTypes);\n         parcel.writeStringArray(packageNames);\n",
    "added_lines": 10,
    "deleted_lines": 0,
    "changed_methods": "AccessibilityServiceInfo::isWithinParcelableSize"
   },
   {
    "filename": "AccessibilityManagerService.java",
    "diff": "@@ -1610,6 +1610,12 @@ public class AccessibilityManagerService extends IAccessibilityManager.Stub\n             AccessibilityServiceInfo accessibilityServiceInfo;\n             try {\n                 accessibilityServiceInfo = new AccessibilityServiceInfo(resolveInfo, mContext);\n+                if (!accessibilityServiceInfo.isWithinParcelableSize()) {\n+                    Slog.e(LOG_TAG, \"Skipping service \"\n+                            + accessibilityServiceInfo.getResolveInfo().getComponentInfo()\n+                            + \" because service info size is larger than safe parcelable limits.\");\n+                    continue;\n+                }\n                 if (userState.mCrashedServices.contains(serviceInfo.getComponentName())) {\n                     // Restore the crashed attribute.\n                     accessibilityServiceInfo.crashed = true;\n",
    "added_lines": 6,
    "deleted_lines": 0,
    "changed_methods": "AccessibilityManagerService::readInstalledAccessibilityServiceLocked"
   }
  ]
 },
 {
  "hash": "250579138c44374e207d60a71637490e797ef540",
  "commit": "Uri: check authority and scheme as part of determining URI path\n\nThe interpretation of the path depends on whether the scheme or\nauthority are specified and should be observed when unparcelling\nURIs.\n\nBug: 171966843\nTest: atest FrameworksCoreTests:android.net.UriTest\nTest: atest com.android.devicehealthchecks.SystemAppCheck\nChange-Id: I06981d1c6e387b16df792494523994518848db37\n(cherry picked from commit f37a94ae920fa5879c557603fc285942ec4b84b1)\n(cherry picked from commit on googleplex-android-review.googlesource.com host: d83281c73070f2428754912ede95ecb0e3d69cd5)\nMerged-In: I06981d1c6e387b16df792494523994518848db37",
  "files": [
   {
    "filename": "Uri.java",
    "diff": "@@ -1205,13 +1205,16 @@ public abstract class Uri implements Parcelable, Comparable<Uri> {\n         }\n \n         static Uri readFrom(Parcel parcel) {\n-            return new HierarchicalUri(\n-                parcel.readString8(),\n-                Part.readFrom(parcel),\n-                PathPart.readFrom(parcel),\n-                Part.readFrom(parcel),\n-                Part.readFrom(parcel)\n-            );\n+            final String scheme = parcel.readString8();\n+            final Part authority = Part.readFrom(parcel);\n+            // In RFC3986 the path should be determined based on whether there is a scheme or\n+            // authority present (https://www.rfc-editor.org/rfc/rfc3986.html#section-3.3).\n+            final boolean hasSchemeOrAuthority =\n+                    (scheme != null && scheme.length() > 0) || !authority.isEmpty();\n+            final PathPart path = PathPart.readFrom(hasSchemeOrAuthority, parcel);\n+            final Part query = Part.readFrom(parcel);\n+            final Part fragment = Part.readFrom(parcel);\n+            return new HierarchicalUri(scheme, authority, path, query, fragment);\n         }\n \n         public int describeContents() {\n@@ -2270,6 +2273,11 @@ public abstract class Uri implements Parcelable, Comparable<Uri> {\n             }\n         }\n \n+        static PathPart readFrom(boolean hasSchemeOrAuthority, Parcel parcel) {\n+            final PathPart path = readFrom(parcel);\n+            return hasSchemeOrAuthority ? makeAbsolute(path) : path;\n+        }\n+\n         /**\n          * Creates a path from the encoded string.\n          *\n",
    "added_lines": 15,
    "deleted_lines": 7,
    "changed_methods": "Uri::HierarchicalUri::readFrom, Uri::PathPart::readFrom"
   },
   {
    "filename": "UriTest.java",
    "diff": "@@ -48,6 +48,7 @@ public class UriTest extends TestCase {\n     public void testParcelling() {\n         parcelAndUnparcel(Uri.parse(\"foo:bob%20lee\"));\n         parcelAndUnparcel(Uri.fromParts(\"foo\", \"bob lee\", \"fragment\"));\n+        parcelAndUnparcel(Uri.fromParts(\"https\", \"www.google.com\", null));\n         parcelAndUnparcel(new Uri.Builder()\n             .scheme(\"http\")\n             .authority(\"crazybob.org\")\n@@ -890,9 +891,62 @@ public class UriTest extends TestCase {\n             Throwable targetException = expected.getTargetException();\n             // Check that the exception was thrown for the correct reason.\n             assertEquals(\"Unknown representation: 0\", targetException.getMessage());\n+        } finally {\n+            parcel.recycle();\n         }\n     }\n \n+    private Uri buildUriFromRawParcel(boolean argumentsEncoded,\n+                                      String scheme,\n+                                      String authority,\n+                                      String path,\n+                                      String query,\n+                                      String fragment) {\n+        // Representation value (from AbstractPart.REPRESENTATION_{ENCODED,DECODED}).\n+        final int representation = argumentsEncoded ? 1 : 2;\n+        Parcel parcel = Parcel.obtain();\n+        try {\n+            parcel.writeInt(3);  // hierarchical\n+            parcel.writeString8(scheme);\n+            parcel.writeInt(representation);\n+            parcel.writeString8(authority);\n+            parcel.writeInt(representation);\n+            parcel.writeString8(path);\n+            parcel.writeInt(representation);\n+            parcel.writeString8(query);\n+            parcel.writeInt(representation);\n+            parcel.writeString8(fragment);\n+            parcel.setDataPosition(0);\n+            return Uri.CREATOR.createFromParcel(parcel);\n+        } finally {\n+            parcel.recycle();\n+        }\n+    }\n+\n+    public void testUnparcelMalformedPath() {\n+        // Regression tests for b/171966843.\n+\n+        // Test cases with arguments encoded (covering testing `scheme` * `authority` options).\n+        Uri uri0 = buildUriFromRawParcel(true, \"https\", \"google.com\", \"@evil.com\", null, null);\n+        assertEquals(\"https://google.com/@evil.com\", uri0.toString());\n+        Uri uri1 = buildUriFromRawParcel(true, null, \"google.com\", \"@evil.com\", \"name=spark\", \"x\");\n+        assertEquals(\"//google.com/@evil.com?name=spark#x\", uri1.toString());\n+        Uri uri2 = buildUriFromRawParcel(true, \"http:\", null, \"@evil.com\", null, null);\n+        assertEquals(\"http::/@evil.com\", uri2.toString());\n+        Uri uri3 = buildUriFromRawParcel(true, null, null, \"@evil.com\", null, null);\n+        assertEquals(\"@evil.com\", uri3.toString());\n+\n+        // Test cases with arguments not encoded (covering testing `scheme` * `authority` options).\n+        Uri uriA = buildUriFromRawParcel(false, \"https\", \"google.com\", \"@evil.com\", null, null);\n+        assertEquals(\"https://google.com/%40evil.com\", uriA.toString());\n+        Uri uriB = buildUriFromRawParcel(false, null, \"google.com\", \"@evil.com\", null, null);\n+        assertEquals(\"//google.com/%40evil.com\", uriB.toString());\n+        Uri uriC = buildUriFromRawParcel(false, \"http:\", null, \"@evil.com\", null, null);\n+        assertEquals(\"http::/%40evil.com\", uriC.toString());\n+        Uri uriD = buildUriFromRawParcel(false, null, null, \"@evil.com\", \"name=spark\", \"y\");\n+        assertEquals(\"%40evil.com?name%3Dspark#y\", uriD.toString());\n+    }\n+\n     public void testToSafeString() {\n         checkToSafeString(\"tel:xxxxxx\", \"tel:Google\");\n         checkToSafeString(\"tel:xxxxxxxxxx\", \"tel:1234567890\");\n",
    "added_lines": 54,
    "deleted_lines": 0,
    "changed_methods": "UriTest::assertUnparcelLegacyPart_fails, UriTest::testUnparcelMalformedPath, UriTest::buildUriFromRawParcel, UriTest::testParcelling"
   }
  ]
 },
 {
  "hash": "250579138c44374e207d60a71637490e797ef540",
  "commit": "Uri: check authority and scheme as part of determining URI path\n\nThe interpretation of the path depends on whether the scheme or\nauthority are specified and should be observed when unparcelling\nURIs.\n\nBug: 171966843\nTest: atest FrameworksCoreTests:android.net.UriTest\nTest: atest com.android.devicehealthchecks.SystemAppCheck\nChange-Id: I06981d1c6e387b16df792494523994518848db37\n(cherry picked from commit f37a94ae920fa5879c557603fc285942ec4b84b1)\n(cherry picked from commit on googleplex-android-review.googlesource.com host: d83281c73070f2428754912ede95ecb0e3d69cd5)\nMerged-In: I06981d1c6e387b16df792494523994518848db37",
  "files": [
   {
    "filename": "Uri.java",
    "diff": "@@ -1205,13 +1205,16 @@ public abstract class Uri implements Parcelable, Comparable<Uri> {\n         }\n \n         static Uri readFrom(Parcel parcel) {\n-            return new HierarchicalUri(\n-                parcel.readString8(),\n-                Part.readFrom(parcel),\n-                PathPart.readFrom(parcel),\n-                Part.readFrom(parcel),\n-                Part.readFrom(parcel)\n-            );\n+            final String scheme = parcel.readString8();\n+            final Part authority = Part.readFrom(parcel);\n+            // In RFC3986 the path should be determined based on whether there is a scheme or\n+            // authority present (https://www.rfc-editor.org/rfc/rfc3986.html#section-3.3).\n+            final boolean hasSchemeOrAuthority =\n+                    (scheme != null && scheme.length() > 0) || !authority.isEmpty();\n+            final PathPart path = PathPart.readFrom(hasSchemeOrAuthority, parcel);\n+            final Part query = Part.readFrom(parcel);\n+            final Part fragment = Part.readFrom(parcel);\n+            return new HierarchicalUri(scheme, authority, path, query, fragment);\n         }\n \n         public int describeContents() {\n@@ -2270,6 +2273,11 @@ public abstract class Uri implements Parcelable, Comparable<Uri> {\n             }\n         }\n \n+        static PathPart readFrom(boolean hasSchemeOrAuthority, Parcel parcel) {\n+            final PathPart path = readFrom(parcel);\n+            return hasSchemeOrAuthority ? makeAbsolute(path) : path;\n+        }\n+\n         /**\n          * Creates a path from the encoded string.\n          *\n",
    "added_lines": 15,
    "deleted_lines": 7,
    "changed_methods": "Uri::HierarchicalUri::readFrom, Uri::PathPart::readFrom"
   },
   {
    "filename": "UriTest.java",
    "diff": "@@ -48,6 +48,7 @@ public class UriTest extends TestCase {\n     public void testParcelling() {\n         parcelAndUnparcel(Uri.parse(\"foo:bob%20lee\"));\n         parcelAndUnparcel(Uri.fromParts(\"foo\", \"bob lee\", \"fragment\"));\n+        parcelAndUnparcel(Uri.fromParts(\"https\", \"www.google.com\", null));\n         parcelAndUnparcel(new Uri.Builder()\n             .scheme(\"http\")\n             .authority(\"crazybob.org\")\n@@ -890,9 +891,62 @@ public class UriTest extends TestCase {\n             Throwable targetException = expected.getTargetException();\n             // Check that the exception was thrown for the correct reason.\n             assertEquals(\"Unknown representation: 0\", targetException.getMessage());\n+        } finally {\n+            parcel.recycle();\n         }\n     }\n \n+    private Uri buildUriFromRawParcel(boolean argumentsEncoded,\n+                                      String scheme,\n+                                      String authority,\n+                                      String path,\n+                                      String query,\n+                                      String fragment) {\n+        // Representation value (from AbstractPart.REPRESENTATION_{ENCODED,DECODED}).\n+        final int representation = argumentsEncoded ? 1 : 2;\n+        Parcel parcel = Parcel.obtain();\n+        try {\n+            parcel.writeInt(3);  // hierarchical\n+            parcel.writeString8(scheme);\n+            parcel.writeInt(representation);\n+            parcel.writeString8(authority);\n+            parcel.writeInt(representation);\n+            parcel.writeString8(path);\n+            parcel.writeInt(representation);\n+            parcel.writeString8(query);\n+            parcel.writeInt(representation);\n+            parcel.writeString8(fragment);\n+            parcel.setDataPosition(0);\n+            return Uri.CREATOR.createFromParcel(parcel);\n+        } finally {\n+            parcel.recycle();\n+        }\n+    }\n+\n+    public void testUnparcelMalformedPath() {\n+        // Regression tests for b/171966843.\n+\n+        // Test cases with arguments encoded (covering testing `scheme` * `authority` options).\n+        Uri uri0 = buildUriFromRawParcel(true, \"https\", \"google.com\", \"@evil.com\", null, null);\n+        assertEquals(\"https://google.com/@evil.com\", uri0.toString());\n+        Uri uri1 = buildUriFromRawParcel(true, null, \"google.com\", \"@evil.com\", \"name=spark\", \"x\");\n+        assertEquals(\"//google.com/@evil.com?name=spark#x\", uri1.toString());\n+        Uri uri2 = buildUriFromRawParcel(true, \"http:\", null, \"@evil.com\", null, null);\n+        assertEquals(\"http::/@evil.com\", uri2.toString());\n+        Uri uri3 = buildUriFromRawParcel(true, null, null, \"@evil.com\", null, null);\n+        assertEquals(\"@evil.com\", uri3.toString());\n+\n+        // Test cases with arguments not encoded (covering testing `scheme` * `authority` options).\n+        Uri uriA = buildUriFromRawParcel(false, \"https\", \"google.com\", \"@evil.com\", null, null);\n+        assertEquals(\"https://google.com/%40evil.com\", uriA.toString());\n+        Uri uriB = buildUriFromRawParcel(false, null, \"google.com\", \"@evil.com\", null, null);\n+        assertEquals(\"//google.com/%40evil.com\", uriB.toString());\n+        Uri uriC = buildUriFromRawParcel(false, \"http:\", null, \"@evil.com\", null, null);\n+        assertEquals(\"http::/%40evil.com\", uriC.toString());\n+        Uri uriD = buildUriFromRawParcel(false, null, null, \"@evil.com\", \"name=spark\", \"y\");\n+        assertEquals(\"%40evil.com?name%3Dspark#y\", uriD.toString());\n+    }\n+\n     public void testToSafeString() {\n         checkToSafeString(\"tel:xxxxxx\", \"tel:Google\");\n         checkToSafeString(\"tel:xxxxxxxxxx\", \"tel:1234567890\");\n",
    "added_lines": 54,
    "deleted_lines": 0,
    "changed_methods": "UriTest::assertUnparcelLegacyPart_fails, UriTest::testUnparcelMalformedPath, UriTest::buildUriFromRawParcel, UriTest::testParcelling"
   }
  ]
 },
 {
  "hash": "e82446502de5989274829c70b84bf43b2d217001",
  "commit": "enforce stricter rules when registering phoneAccounts\n\n- include disable accounts when looking up accounts for a package to\n  check if the limit is reached (10)\n- put a new limit of 10 supported schemes\n- put a new limit of 256 characters per scheme\n- put a new limit of 256 characters per address\n- ensure the Icon can write to memory w/o throwing an exception\n\nbug: 259064622\nbug: 256819769\nTest: cts + unit\nChange-Id: Ia7d8d00d9de0fb6694ded6a80c40bd55d7fdf7a7\nMerged-In: Ia7d8d00d9de0fb6694ded6a80c40bd55d7fdf7a7\n(cherry picked from commit on googleplex-android-review.googlesource.com host: 6a02885f90fa64d88bac31efbcdbc2bfe0a9328f)\nMerged-In: Ia7d8d00d9de0fb6694ded6a80c40bd55d7fdf7a7",
  "files": [
   {
    "filename": "PhoneAccount.java",
    "diff": "@@ -517,6 +517,11 @@ public final class PhoneAccount implements Parcelable {\n \n         /**\n          * Sets the address. See {@link PhoneAccount#getAddress}.\n+         * <p>\n+         * Note: The entire URI value is limited to 256 characters. This check is\n+         * enforced when registering the PhoneAccount via\n+         * {@link TelecomManager#registerPhoneAccount(PhoneAccount)} and will cause an\n+         * {@link IllegalArgumentException} to be thrown if URI is over 256.\n          *\n          * @param value The address of the phone account.\n          * @return The builder.\n@@ -550,6 +555,10 @@ public final class PhoneAccount implements Parcelable {\n \n         /**\n          * Sets the icon. See {@link PhoneAccount#getIcon}.\n+         * <p>\n+         * Note: An {@link IllegalArgumentException} if the Icon cannot be written to memory.\n+         * This check is enforced when registering the PhoneAccount via\n+         * {@link TelecomManager#registerPhoneAccount(PhoneAccount)}\n          *\n          * @param icon The icon to set.\n          */\n@@ -583,6 +592,10 @@ public final class PhoneAccount implements Parcelable {\n         /**\n          * Specifies an additional URI scheme supported by the {@link PhoneAccount}.\n          *\n+         * <p>\n+         * Each URI scheme is limited to 256 characters.  Adding a scheme over 256 characters will\n+         * cause an {@link IllegalArgumentException} to be thrown when the account is registered.\n+         *\n          * @param uriScheme The URI scheme.\n          * @return The builder.\n          */\n@@ -596,6 +609,12 @@ public final class PhoneAccount implements Parcelable {\n         /**\n          * Specifies the URI schemes supported by the {@link PhoneAccount}.\n          *\n+         * <p>\n+         * A max of 10 URI schemes can be added per account.  Additionally, each URI scheme is\n+         * limited to 256 characters. Adding more than 10 URI schemes or 256 characters on any\n+         * scheme will cause an {@link IllegalArgumentException} to be thrown when the account\n+         * is registered.\n+         *\n          * @param uriSchemes The URI schemes.\n          * @return The builder.\n          */\n",
    "added_lines": 19,
    "deleted_lines": 0,
    "changed_methods": ""
   }
  ]
 },
 {
  "hash": "802dbc02ee70de1385060424e42497a22a6a0484",
  "commit": "Make Activites touch opaque - DO NOT MERGE\n\nBlock touches from passing through activities by adding a dedicated\nsurface that consumes all touches that would otherwise pass through the\nbounds availble to the Activity.\n\n+ Keep displayId in sync for ActivityRecord\n\nBug: 194480991\nTest: atest CtsWindowManagerDeviceTestCases:ActivityRecordInputSinkTests\nTest: atest CtsWindowManagerDeviceTestCases:CrossAppDragAndDropTests\nTest: atest CtsWindowManagerDeviceTestCases:PinnedStackTests\nTest: Used \"System > Developer Options > Simulate secondary display\" to\ntest that moving activites between displays work as intended.\n\nChange-Id: Ie74674c87c81c571089463349ac6233717ed9f33\n(cherry picked from commit on googleplex-android-review.googlesource.com host: a418847bb8de788905aced4f59437de7cbfc5360)\nMerged-In: Ie74674c87c81c571089463349ac6233717ed9f33",
  "files": [
   {
    "filename": "ActivityRecord.java",
    "diff": "@@ -804,6 +804,13 @@ final class ActivityRecord extends WindowToken implements WindowManagerService.A\n \n     private AppSaturationInfo mLastAppSaturationInfo;\n \n+    private final ActivityRecordInputSink mActivityRecordInputSink;\n+\n+    // Activities with this uid are allowed to not create an input sink while being in the same\n+    // task and directly above this ActivityRecord. This field is updated whenever a new activity\n+    // is launched from this ActivityRecord. Touches are always allowed within the same uid.\n+    int mAllowedTouchUid;\n+\n     private final ColorDisplayService.ColorTransformController mColorTransformController =\n             (matrix, translation) -> mWmService.mH.post(() -> {\n                 synchronized (mWmService.mGlobalLock) {\n@@ -1841,6 +1848,8 @@ final class ActivityRecord extends WindowToken implements WindowManagerService.A\n             createTime = _createTime;\n         }\n         mAtmService.mPackageConfigPersister.updateConfigIfNeeded(this, mUserId, packageName);\n+\n+        mActivityRecordInputSink = new ActivityRecordInputSink(this, sourceRecord);\n     }\n \n     /**\n@@ -3767,6 +3776,7 @@ final class ActivityRecord extends WindowToken implements WindowManagerService.A\n         } else {\n             onRemovedFromDisplay();\n         }\n+        mActivityRecordInputSink.releaseSurfaceControl();\n         super.removeImmediately();\n     }\n \n@@ -6926,6 +6936,9 @@ final class ActivityRecord extends WindowToken implements WindowManagerService.A\n             } else if (!show && mLastSurfaceShowing) {\n                 getSyncTransaction().hide(mSurfaceControl);\n             }\n+            if (show) {\n+                mActivityRecordInputSink.applyChangesToSurfaceIfChanged(getSyncTransaction());\n+            }\n         }\n         if (mThumbnail != null) {\n             mThumbnail.setShowing(getPendingTransaction(), show);\n",
    "added_lines": 13,
    "deleted_lines": 0,
    "changed_methods": "ActivityRecord::ActivityRecord, ActivityRecord::prepareSurfaces, ActivityRecord::removeImmediately"
   },
   {
    "filename": "ActivityRecordInputSink.java",
    "diff": "@@ -0,0 +1,117 @@\n+/*\n+ * Copyright (C) 2022 The Android Open Source Project\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.android.server.wm;\n+\n+import android.os.Process;\n+import android.view.InputWindowHandle;\n+import android.view.SurfaceControl;\n+import android.view.WindowManager;\n+\n+/**\n+ * Creates a InputWindowHandle that catches all touches that would otherwise pass through an\n+ * Activity.\n+ */\n+class ActivityRecordInputSink {\n+\n+    private final ActivityRecord mActivityRecord;\n+    private final String mName;\n+\n+    private InputWindowHandle mInputWindowHandle;\n+    private SurfaceControl mSurfaceControl;\n+\n+    ActivityRecordInputSink(ActivityRecord activityRecord, ActivityRecord sourceRecord) {\n+        mActivityRecord = activityRecord;\n+        mName = Integer.toHexString(System.identityHashCode(this)) + \" ActivityRecordInputSink \"\n+                + mActivityRecord.mActivityComponent.flattenToShortString();\n+        if (sourceRecord != null) {\n+            sourceRecord.mAllowedTouchUid = mActivityRecord.getUid();\n+        }\n+    }\n+\n+    public void applyChangesToSurfaceIfChanged(SurfaceControl.Transaction transaction) {\n+        boolean windowHandleChanged = updateInputWindowHandle();\n+        if (mSurfaceControl == null) {\n+            mSurfaceControl = createSurface(transaction);\n+        }\n+        if (windowHandleChanged) {\n+            transaction.setInputWindowInfo(mSurfaceControl, mInputWindowHandle);\n+        }\n+    }\n+\n+    private SurfaceControl createSurface(SurfaceControl.Transaction t) {\n+        SurfaceControl surfaceControl = mActivityRecord.makeChildSurface(null)\n+                .setName(mName)\n+                .setHidden(false)\n+                .setCallsite(\"ActivityRecordInputSink.createSurface\")\n+                .build();\n+        // Put layer below all siblings (and the parent surface too)\n+        t.setLayer(surfaceControl, Integer.MIN_VALUE);\n+        return surfaceControl;\n+    }\n+\n+    private boolean updateInputWindowHandle() {\n+        boolean changed = false;\n+        if (mInputWindowHandle == null) {\n+            mInputWindowHandle = createInputWindowHandle();\n+            changed = true;\n+        }\n+        // Don't block touches from passing through to an activity below us in the same task, if\n+        // that activity is either from the same uid or if that activity has launched an activity\n+        // in our uid.\n+        final ActivityRecord activityBelowInTask =\n+                mActivityRecord.getTask().getActivityBelow(mActivityRecord);\n+        final boolean allowPassthrough = activityBelowInTask != null && (\n+                activityBelowInTask.mAllowedTouchUid == mActivityRecord.getUid()\n+                        || activityBelowInTask.isUid(mActivityRecord.getUid()));\n+        boolean notTouchable = (mInputWindowHandle.layoutParamsFlags\n+                & WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE) != 0;\n+        if (allowPassthrough || mActivityRecord.isAppTransitioning()) {\n+            mInputWindowHandle.layoutParamsFlags |= WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;\n+            changed |= !notTouchable;\n+        } else {\n+            mInputWindowHandle.layoutParamsFlags &= ~WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;\n+            changed |= notTouchable;\n+        }\n+        if (mInputWindowHandle.displayId != mActivityRecord.getDisplayId()) {\n+            mInputWindowHandle.displayId = mActivityRecord.getDisplayId();\n+            changed = true;\n+        }\n+        return changed;\n+    }\n+\n+    private InputWindowHandle createInputWindowHandle() {\n+        InputWindowHandle inputWindowHandle = new InputWindowHandle(null,\n+                mActivityRecord.getDisplayId());\n+        inputWindowHandle.replaceTouchableRegionWithCrop = true;\n+        inputWindowHandle.name = mName;\n+        inputWindowHandle.layoutParamsType = WindowManager.LayoutParams.TYPE_INPUT_CONSUMER;\n+        inputWindowHandle.ownerUid = Process.myUid();\n+        inputWindowHandle.ownerPid = Process.myPid();\n+        inputWindowHandle.layoutParamsFlags = WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;\n+        inputWindowHandle.inputFeatures =\n+                WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL;\n+        return inputWindowHandle;\n+    }\n+\n+    void releaseSurfaceControl() {\n+        if (mSurfaceControl != null) {\n+            mSurfaceControl.release();\n+            mSurfaceControl = null;\n+        }\n+    }\n+\n+}\n",
    "added_lines": 117,
    "deleted_lines": 0,
    "changed_methods": "ActivityRecordInputSink::releaseSurfaceControl, ActivityRecordInputSink::applyChangesToSurfaceIfChanged, ActivityRecordInputSink::ActivityRecordInputSink, ActivityRecordInputSink::updateInputWindowHandle, ActivityRecordInputSink::createSurface, ActivityRecordInputSink::createInputWindowHandle"
   }
  ]
 },
 {
  "hash": "802dbc02ee70de1385060424e42497a22a6a0484",
  "commit": "Make Activites touch opaque - DO NOT MERGE\n\nBlock touches from passing through activities by adding a dedicated\nsurface that consumes all touches that would otherwise pass through the\nbounds availble to the Activity.\n\n+ Keep displayId in sync for ActivityRecord\n\nBug: 194480991\nTest: atest CtsWindowManagerDeviceTestCases:ActivityRecordInputSinkTests\nTest: atest CtsWindowManagerDeviceTestCases:CrossAppDragAndDropTests\nTest: atest CtsWindowManagerDeviceTestCases:PinnedStackTests\nTest: Used \"System > Developer Options > Simulate secondary display\" to\ntest that moving activites between displays work as intended.\n\nChange-Id: Ie74674c87c81c571089463349ac6233717ed9f33\n(cherry picked from commit on googleplex-android-review.googlesource.com host: a418847bb8de788905aced4f59437de7cbfc5360)\nMerged-In: Ie74674c87c81c571089463349ac6233717ed9f33",
  "files": [
   {
    "filename": "ActivityRecord.java",
    "diff": "@@ -804,6 +804,13 @@ final class ActivityRecord extends WindowToken implements WindowManagerService.A\n \n     private AppSaturationInfo mLastAppSaturationInfo;\n \n+    private final ActivityRecordInputSink mActivityRecordInputSink;\n+\n+    // Activities with this uid are allowed to not create an input sink while being in the same\n+    // task and directly above this ActivityRecord. This field is updated whenever a new activity\n+    // is launched from this ActivityRecord. Touches are always allowed within the same uid.\n+    int mAllowedTouchUid;\n+\n     private final ColorDisplayService.ColorTransformController mColorTransformController =\n             (matrix, translation) -> mWmService.mH.post(() -> {\n                 synchronized (mWmService.mGlobalLock) {\n@@ -1841,6 +1848,8 @@ final class ActivityRecord extends WindowToken implements WindowManagerService.A\n             createTime = _createTime;\n         }\n         mAtmService.mPackageConfigPersister.updateConfigIfNeeded(this, mUserId, packageName);\n+\n+        mActivityRecordInputSink = new ActivityRecordInputSink(this, sourceRecord);\n     }\n \n     /**\n@@ -3767,6 +3776,7 @@ final class ActivityRecord extends WindowToken implements WindowManagerService.A\n         } else {\n             onRemovedFromDisplay();\n         }\n+        mActivityRecordInputSink.releaseSurfaceControl();\n         super.removeImmediately();\n     }\n \n@@ -6926,6 +6936,9 @@ final class ActivityRecord extends WindowToken implements WindowManagerService.A\n             } else if (!show && mLastSurfaceShowing) {\n                 getSyncTransaction().hide(mSurfaceControl);\n             }\n+            if (show) {\n+                mActivityRecordInputSink.applyChangesToSurfaceIfChanged(getSyncTransaction());\n+            }\n         }\n         if (mThumbnail != null) {\n             mThumbnail.setShowing(getPendingTransaction(), show);\n",
    "added_lines": 13,
    "deleted_lines": 0,
    "changed_methods": "ActivityRecord::ActivityRecord, ActivityRecord::prepareSurfaces, ActivityRecord::removeImmediately"
   },
   {
    "filename": "ActivityRecordInputSink.java",
    "diff": "@@ -0,0 +1,117 @@\n+/*\n+ * Copyright (C) 2022 The Android Open Source Project\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.android.server.wm;\n+\n+import android.os.Process;\n+import android.view.InputWindowHandle;\n+import android.view.SurfaceControl;\n+import android.view.WindowManager;\n+\n+/**\n+ * Creates a InputWindowHandle that catches all touches that would otherwise pass through an\n+ * Activity.\n+ */\n+class ActivityRecordInputSink {\n+\n+    private final ActivityRecord mActivityRecord;\n+    private final String mName;\n+\n+    private InputWindowHandle mInputWindowHandle;\n+    private SurfaceControl mSurfaceControl;\n+\n+    ActivityRecordInputSink(ActivityRecord activityRecord, ActivityRecord sourceRecord) {\n+        mActivityRecord = activityRecord;\n+        mName = Integer.toHexString(System.identityHashCode(this)) + \" ActivityRecordInputSink \"\n+                + mActivityRecord.mActivityComponent.flattenToShortString();\n+        if (sourceRecord != null) {\n+            sourceRecord.mAllowedTouchUid = mActivityRecord.getUid();\n+        }\n+    }\n+\n+    public void applyChangesToSurfaceIfChanged(SurfaceControl.Transaction transaction) {\n+        boolean windowHandleChanged = updateInputWindowHandle();\n+        if (mSurfaceControl == null) {\n+            mSurfaceControl = createSurface(transaction);\n+        }\n+        if (windowHandleChanged) {\n+            transaction.setInputWindowInfo(mSurfaceControl, mInputWindowHandle);\n+        }\n+    }\n+\n+    private SurfaceControl createSurface(SurfaceControl.Transaction t) {\n+        SurfaceControl surfaceControl = mActivityRecord.makeChildSurface(null)\n+                .setName(mName)\n+                .setHidden(false)\n+                .setCallsite(\"ActivityRecordInputSink.createSurface\")\n+                .build();\n+        // Put layer below all siblings (and the parent surface too)\n+        t.setLayer(surfaceControl, Integer.MIN_VALUE);\n+        return surfaceControl;\n+    }\n+\n+    private boolean updateInputWindowHandle() {\n+        boolean changed = false;\n+        if (mInputWindowHandle == null) {\n+            mInputWindowHandle = createInputWindowHandle();\n+            changed = true;\n+        }\n+        // Don't block touches from passing through to an activity below us in the same task, if\n+        // that activity is either from the same uid or if that activity has launched an activity\n+        // in our uid.\n+        final ActivityRecord activityBelowInTask =\n+                mActivityRecord.getTask().getActivityBelow(mActivityRecord);\n+        final boolean allowPassthrough = activityBelowInTask != null && (\n+                activityBelowInTask.mAllowedTouchUid == mActivityRecord.getUid()\n+                        || activityBelowInTask.isUid(mActivityRecord.getUid()));\n+        boolean notTouchable = (mInputWindowHandle.layoutParamsFlags\n+                & WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE) != 0;\n+        if (allowPassthrough || mActivityRecord.isAppTransitioning()) {\n+            mInputWindowHandle.layoutParamsFlags |= WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;\n+            changed |= !notTouchable;\n+        } else {\n+            mInputWindowHandle.layoutParamsFlags &= ~WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;\n+            changed |= notTouchable;\n+        }\n+        if (mInputWindowHandle.displayId != mActivityRecord.getDisplayId()) {\n+            mInputWindowHandle.displayId = mActivityRecord.getDisplayId();\n+            changed = true;\n+        }\n+        return changed;\n+    }\n+\n+    private InputWindowHandle createInputWindowHandle() {\n+        InputWindowHandle inputWindowHandle = new InputWindowHandle(null,\n+                mActivityRecord.getDisplayId());\n+        inputWindowHandle.replaceTouchableRegionWithCrop = true;\n+        inputWindowHandle.name = mName;\n+        inputWindowHandle.layoutParamsType = WindowManager.LayoutParams.TYPE_INPUT_CONSUMER;\n+        inputWindowHandle.ownerUid = Process.myUid();\n+        inputWindowHandle.ownerPid = Process.myPid();\n+        inputWindowHandle.layoutParamsFlags = WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;\n+        inputWindowHandle.inputFeatures =\n+                WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL;\n+        return inputWindowHandle;\n+    }\n+\n+    void releaseSurfaceControl() {\n+        if (mSurfaceControl != null) {\n+            mSurfaceControl.release();\n+            mSurfaceControl = null;\n+        }\n+    }\n+\n+}\n",
    "added_lines": 117,
    "deleted_lines": 0,
    "changed_methods": "ActivityRecordInputSink::releaseSurfaceControl, ActivityRecordInputSink::applyChangesToSurfaceIfChanged, ActivityRecordInputSink::ActivityRecordInputSink, ActivityRecordInputSink::updateInputWindowHandle, ActivityRecordInputSink::createSurface, ActivityRecordInputSink::createInputWindowHandle"
   }
  ]
 },
 {
  "hash": "6f4c85a9fe2bd0f8f9408df001ea7651e9706dda",
  "commit": "Trim strings added to persistent snoozed notification storage.\n\nThis is a backport of ag/20581190 and includes the fix in ag/20778075.\nNote that on this branch, clearData doesn't seem to actually clear persistent storage.\n\nBug: 258422365\nTest: atest NotificationManagerServiceTest SnoozeHelperTest\nChange-Id: If7c7db6694330ffbac551d044efadb26219fe17f\nMerged-In: I5a2823f10053ea8c83c612a567d6d4f1b6af23e7\nMerged-In: Ie809cb4d648a40622618e0fb374f36b6d8dc972a\n(cherry picked from commit on googleplex-android-review.googlesource.com host: b8a07871459ed895fc814730e198df4a0b5860dc)\nMerged-In: If7c7db6694330ffbac551d044efadb26219fe17f",
  "files": [
   {
    "filename": "SnoozeHelper.java",
    "diff": "@@ -64,6 +64,9 @@ public class SnoozeHelper {\n \n     static final int CONCURRENT_SNOOZE_LIMIT = 500;\n \n+    // A safe size for strings to be put in persistent storage, to avoid breaking the XML write.\n+    static final int MAX_STRING_LENGTH = 1000;\n+\n     protected static final String XML_TAG_NAME = \"snoozed-notifications\";\n \n     private static final String XML_SNOOZED_NOTIFICATION = \"notification\";\n@@ -152,7 +155,7 @@ public class SnoozeHelper {\n            ArrayMap<String, Long> snoozed =\n                    mPersistedSnoozedNotifications.get(getPkgKey(userId, pkg));\n            if (snoozed != null) {\n-               time = snoozed.get(key);\n+               time = snoozed.get(getTrimmedString(key));\n            }\n         }\n         if (time == null) {\n@@ -166,7 +169,7 @@ public class SnoozeHelper {\n             ArrayMap<String, String> snoozed =\n                     mPersistedSnoozedNotificationsWithContext.get(getPkgKey(userId, pkg));\n             if (snoozed != null) {\n-                return snoozed.get(key);\n+                return snoozed.get(getTrimmedString(key));\n             }\n         }\n         return null;\n@@ -251,7 +254,8 @@ public class SnoozeHelper {\n         scheduleRepost(pkg, key, userId, duration);\n         Long activateAt = System.currentTimeMillis() + duration;\n         synchronized (mLock) {\n-            storeRecordLocked(pkg, key, userId, mPersistedSnoozedNotifications, activateAt);\n+            storeRecordLocked(pkg, getTrimmedString(key), userId, mPersistedSnoozedNotifications,\n+                    activateAt);\n         }\n     }\n \n@@ -262,8 +266,10 @@ public class SnoozeHelper {\n         int userId = record.getUser().getIdentifier();\n         if (contextId != null) {\n             synchronized (mLock) {\n-                storeRecordLocked(record.getSbn().getPackageName(), record.getKey(),\n-                        userId, mPersistedSnoozedNotificationsWithContext, contextId);\n+                storeRecordLocked(record.getSbn().getPackageName(),\n+                        getTrimmedString(record.getKey()),\n+                        userId, mPersistedSnoozedNotificationsWithContext,\n+                        getTrimmedString(contextId));\n             }\n         }\n         snooze(record);\n@@ -280,6 +286,13 @@ public class SnoozeHelper {\n         }\n     }\n \n+    private String getTrimmedString(String key) {\n+        if (key != null && key.length() > MAX_STRING_LENGTH) {\n+            return key.substring(0, MAX_STRING_LENGTH);\n+        }\n+        return key;\n+    }\n+\n     private <T> void storeRecordLocked(String pkg, String key, Integer userId,\n             ArrayMap<String, ArrayMap<String, T>> targets, T object) {\n \n@@ -384,12 +397,14 @@ public class SnoozeHelper {\n     }\n \n     protected void repost(String key, int userId, boolean muteOnReturn) {\n+        final String trimmedKey = getTrimmedString(key);\n+\n         NotificationRecord record;\n         synchronized (mLock) {\n             final String pkg = mPackages.remove(key);\n             mUsers.remove(key);\n-            removeRecordLocked(pkg, key, userId, mPersistedSnoozedNotifications);\n-            removeRecordLocked(pkg, key, userId, mPersistedSnoozedNotificationsWithContext);\n+            removeRecordLocked(pkg, trimmedKey, userId, mPersistedSnoozedNotifications);\n+            removeRecordLocked(pkg, trimmedKey, userId, mPersistedSnoozedNotificationsWithContext);\n             ArrayMap<String, NotificationRecord> records =\n                     mSnoozedNotifications.get(getPkgKey(userId, pkg));\n             if (records == null) {\n",
    "added_lines": 22,
    "deleted_lines": 7,
    "changed_methods": "SnoozeHelper::snooze, SnoozeHelper::snooze, SnoozeHelper::getTrimmedString, SnoozeHelper::repost, SnoozeHelper::getSnoozeContextForUnpostedNotification, SnoozeHelper::getSnoozeTimeForUnpostedNotification"
   },
   {
    "filename": "SnoozeHelperTest.java",
    "diff": "@@ -69,6 +69,7 @@ import java.io.BufferedOutputStream;\n import java.io.ByteArrayInputStream;\n import java.io.ByteArrayOutputStream;\n import java.io.IOException;\n+import java.util.Collections;\n \n @SmallTest\n @RunWith(AndroidJUnit4.class)\n@@ -247,6 +248,37 @@ public class SnoozeHelperTest extends UiServiceTestCase {\n         assertEquals(\"key2\", captor2.getValue().getIntent().getStringExtra(EXTRA_KEY));\n     }\n \n+    @Test\n+    public void testLongTagPersistedNotification() throws Exception {\n+        String longTag = String.join(\"\", Collections.nCopies(66000, \"A\"));\n+        NotificationRecord r = getNotificationRecord(\"pkg\", 1, longTag, UserHandle.SYSTEM);\n+        mSnoozeHelper.snooze(r, 0);\n+\n+        // We store the full key in temp storage.\n+        ArgumentCaptor<PendingIntent> captor = ArgumentCaptor.forClass(PendingIntent.class);\n+        verify(mAm).setExactAndAllowWhileIdle(anyInt(), anyLong(), captor.capture());\n+        assertEquals(66010, captor.getValue().getIntent().getStringExtra(EXTRA_KEY).length());\n+\n+        TypedXmlSerializer serializer = Xml.newFastSerializer();\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        serializer.setOutput(new BufferedOutputStream(baos), \"utf-8\");\n+        serializer.startDocument(null, true);\n+        mSnoozeHelper.writeXml(serializer);\n+        serializer.endDocument();\n+        serializer.flush();\n+\n+        TypedXmlPullParser parser = Xml.newFastPullParser();\n+        parser.setInput(new BufferedInputStream(\n+                new ByteArrayInputStream(baos.toByteArray())), \"utf-8\");\n+        mSnoozeHelper.readXml(parser, 4);\n+\n+        mSnoozeHelper.scheduleRepostsForPersistedNotifications(5);\n+\n+        // We trim the key in persistent storage.\n+        verify(mAm, times(2)).setExactAndAllowWhileIdle(anyInt(), anyLong(), captor.capture());\n+        assertEquals(1000, captor.getValue().getIntent().getStringExtra(EXTRA_KEY).length());\n+    }\n+\n     @Test\n     public void testSnoozeForTime() throws Exception {\n         NotificationRecord r = getNotificationRecord(\"pkg\", 1, \"one\", UserHandle.SYSTEM);\n@@ -595,13 +627,20 @@ public class SnoozeHelperTest extends UiServiceTestCase {\n     public void testClearData() {\n         // snooze 2 from same package\n         NotificationRecord r = getNotificationRecord(\"pkg\", 1, \"one\", UserHandle.SYSTEM);\n-        NotificationRecord r2 = getNotificationRecord(\"pkg\", 2, \"two\", UserHandle.SYSTEM);\n+        NotificationRecord r2 = getNotificationRecord(\"pkg\", 2,\n+                \"two\" + String.join(\"\", Collections.nCopies(66000, \"2\")), UserHandle.SYSTEM);\n         mSnoozeHelper.snooze(r, 1000);\n         mSnoozeHelper.snooze(r2, 1000);\n         assertTrue(mSnoozeHelper.isSnoozed(\n                 UserHandle.USER_SYSTEM, r.getSbn().getPackageName(), r.getKey()));\n         assertTrue(mSnoozeHelper.isSnoozed(\n                 UserHandle.USER_SYSTEM, r2.getSbn().getPackageName(), r2.getKey()));\n+        assertFalse(0L == mSnoozeHelper.getSnoozeTimeForUnpostedNotification(\n+                r.getUser().getIdentifier(), r.getSbn().getPackageName(),\n+                r.getSbn().getKey()));\n+        assertFalse(0L == mSnoozeHelper.getSnoozeTimeForUnpostedNotification(\n+                r2.getUser().getIdentifier(), r2.getSbn().getPackageName(),\n+                r2.getSbn().getKey()));\n \n         // clear data\n         mSnoozeHelper.clearData(UserHandle.USER_SYSTEM, \"pkg\");\n",
    "added_lines": 40,
    "deleted_lines": 1,
    "changed_methods": "SnoozeHelperTest::testLongTagPersistedNotification, SnoozeHelperTest::testClearData"
   }
  ]
 },
 {
  "hash": "6f4c85a9fe2bd0f8f9408df001ea7651e9706dda",
  "commit": "Trim strings added to persistent snoozed notification storage.\n\nThis is a backport of ag/20581190 and includes the fix in ag/20778075.\nNote that on this branch, clearData doesn't seem to actually clear persistent storage.\n\nBug: 258422365\nTest: atest NotificationManagerServiceTest SnoozeHelperTest\nChange-Id: If7c7db6694330ffbac551d044efadb26219fe17f\nMerged-In: I5a2823f10053ea8c83c612a567d6d4f1b6af23e7\nMerged-In: Ie809cb4d648a40622618e0fb374f36b6d8dc972a\n(cherry picked from commit on googleplex-android-review.googlesource.com host: b8a07871459ed895fc814730e198df4a0b5860dc)\nMerged-In: If7c7db6694330ffbac551d044efadb26219fe17f",
  "files": [
   {
    "filename": "SnoozeHelper.java",
    "diff": "@@ -64,6 +64,9 @@ public class SnoozeHelper {\n \n     static final int CONCURRENT_SNOOZE_LIMIT = 500;\n \n+    // A safe size for strings to be put in persistent storage, to avoid breaking the XML write.\n+    static final int MAX_STRING_LENGTH = 1000;\n+\n     protected static final String XML_TAG_NAME = \"snoozed-notifications\";\n \n     private static final String XML_SNOOZED_NOTIFICATION = \"notification\";\n@@ -152,7 +155,7 @@ public class SnoozeHelper {\n            ArrayMap<String, Long> snoozed =\n                    mPersistedSnoozedNotifications.get(getPkgKey(userId, pkg));\n            if (snoozed != null) {\n-               time = snoozed.get(key);\n+               time = snoozed.get(getTrimmedString(key));\n            }\n         }\n         if (time == null) {\n@@ -166,7 +169,7 @@ public class SnoozeHelper {\n             ArrayMap<String, String> snoozed =\n                     mPersistedSnoozedNotificationsWithContext.get(getPkgKey(userId, pkg));\n             if (snoozed != null) {\n-                return snoozed.get(key);\n+                return snoozed.get(getTrimmedString(key));\n             }\n         }\n         return null;\n@@ -251,7 +254,8 @@ public class SnoozeHelper {\n         scheduleRepost(pkg, key, userId, duration);\n         Long activateAt = System.currentTimeMillis() + duration;\n         synchronized (mLock) {\n-            storeRecordLocked(pkg, key, userId, mPersistedSnoozedNotifications, activateAt);\n+            storeRecordLocked(pkg, getTrimmedString(key), userId, mPersistedSnoozedNotifications,\n+                    activateAt);\n         }\n     }\n \n@@ -262,8 +266,10 @@ public class SnoozeHelper {\n         int userId = record.getUser().getIdentifier();\n         if (contextId != null) {\n             synchronized (mLock) {\n-                storeRecordLocked(record.getSbn().getPackageName(), record.getKey(),\n-                        userId, mPersistedSnoozedNotificationsWithContext, contextId);\n+                storeRecordLocked(record.getSbn().getPackageName(),\n+                        getTrimmedString(record.getKey()),\n+                        userId, mPersistedSnoozedNotificationsWithContext,\n+                        getTrimmedString(contextId));\n             }\n         }\n         snooze(record);\n@@ -280,6 +286,13 @@ public class SnoozeHelper {\n         }\n     }\n \n+    private String getTrimmedString(String key) {\n+        if (key != null && key.length() > MAX_STRING_LENGTH) {\n+            return key.substring(0, MAX_STRING_LENGTH);\n+        }\n+        return key;\n+    }\n+\n     private <T> void storeRecordLocked(String pkg, String key, Integer userId,\n             ArrayMap<String, ArrayMap<String, T>> targets, T object) {\n \n@@ -384,12 +397,14 @@ public class SnoozeHelper {\n     }\n \n     protected void repost(String key, int userId, boolean muteOnReturn) {\n+        final String trimmedKey = getTrimmedString(key);\n+\n         NotificationRecord record;\n         synchronized (mLock) {\n             final String pkg = mPackages.remove(key);\n             mUsers.remove(key);\n-            removeRecordLocked(pkg, key, userId, mPersistedSnoozedNotifications);\n-            removeRecordLocked(pkg, key, userId, mPersistedSnoozedNotificationsWithContext);\n+            removeRecordLocked(pkg, trimmedKey, userId, mPersistedSnoozedNotifications);\n+            removeRecordLocked(pkg, trimmedKey, userId, mPersistedSnoozedNotificationsWithContext);\n             ArrayMap<String, NotificationRecord> records =\n                     mSnoozedNotifications.get(getPkgKey(userId, pkg));\n             if (records == null) {\n",
    "added_lines": 22,
    "deleted_lines": 7,
    "changed_methods": "SnoozeHelper::snooze, SnoozeHelper::snooze, SnoozeHelper::getTrimmedString, SnoozeHelper::repost, SnoozeHelper::getSnoozeContextForUnpostedNotification, SnoozeHelper::getSnoozeTimeForUnpostedNotification"
   },
   {
    "filename": "SnoozeHelperTest.java",
    "diff": "@@ -69,6 +69,7 @@ import java.io.BufferedOutputStream;\n import java.io.ByteArrayInputStream;\n import java.io.ByteArrayOutputStream;\n import java.io.IOException;\n+import java.util.Collections;\n \n @SmallTest\n @RunWith(AndroidJUnit4.class)\n@@ -247,6 +248,37 @@ public class SnoozeHelperTest extends UiServiceTestCase {\n         assertEquals(\"key2\", captor2.getValue().getIntent().getStringExtra(EXTRA_KEY));\n     }\n \n+    @Test\n+    public void testLongTagPersistedNotification() throws Exception {\n+        String longTag = String.join(\"\", Collections.nCopies(66000, \"A\"));\n+        NotificationRecord r = getNotificationRecord(\"pkg\", 1, longTag, UserHandle.SYSTEM);\n+        mSnoozeHelper.snooze(r, 0);\n+\n+        // We store the full key in temp storage.\n+        ArgumentCaptor<PendingIntent> captor = ArgumentCaptor.forClass(PendingIntent.class);\n+        verify(mAm).setExactAndAllowWhileIdle(anyInt(), anyLong(), captor.capture());\n+        assertEquals(66010, captor.getValue().getIntent().getStringExtra(EXTRA_KEY).length());\n+\n+        TypedXmlSerializer serializer = Xml.newFastSerializer();\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        serializer.setOutput(new BufferedOutputStream(baos), \"utf-8\");\n+        serializer.startDocument(null, true);\n+        mSnoozeHelper.writeXml(serializer);\n+        serializer.endDocument();\n+        serializer.flush();\n+\n+        TypedXmlPullParser parser = Xml.newFastPullParser();\n+        parser.setInput(new BufferedInputStream(\n+                new ByteArrayInputStream(baos.toByteArray())), \"utf-8\");\n+        mSnoozeHelper.readXml(parser, 4);\n+\n+        mSnoozeHelper.scheduleRepostsForPersistedNotifications(5);\n+\n+        // We trim the key in persistent storage.\n+        verify(mAm, times(2)).setExactAndAllowWhileIdle(anyInt(), anyLong(), captor.capture());\n+        assertEquals(1000, captor.getValue().getIntent().getStringExtra(EXTRA_KEY).length());\n+    }\n+\n     @Test\n     public void testSnoozeForTime() throws Exception {\n         NotificationRecord r = getNotificationRecord(\"pkg\", 1, \"one\", UserHandle.SYSTEM);\n@@ -595,13 +627,20 @@ public class SnoozeHelperTest extends UiServiceTestCase {\n     public void testClearData() {\n         // snooze 2 from same package\n         NotificationRecord r = getNotificationRecord(\"pkg\", 1, \"one\", UserHandle.SYSTEM);\n-        NotificationRecord r2 = getNotificationRecord(\"pkg\", 2, \"two\", UserHandle.SYSTEM);\n+        NotificationRecord r2 = getNotificationRecord(\"pkg\", 2,\n+                \"two\" + String.join(\"\", Collections.nCopies(66000, \"2\")), UserHandle.SYSTEM);\n         mSnoozeHelper.snooze(r, 1000);\n         mSnoozeHelper.snooze(r2, 1000);\n         assertTrue(mSnoozeHelper.isSnoozed(\n                 UserHandle.USER_SYSTEM, r.getSbn().getPackageName(), r.getKey()));\n         assertTrue(mSnoozeHelper.isSnoozed(\n                 UserHandle.USER_SYSTEM, r2.getSbn().getPackageName(), r2.getKey()));\n+        assertFalse(0L == mSnoozeHelper.getSnoozeTimeForUnpostedNotification(\n+                r.getUser().getIdentifier(), r.getSbn().getPackageName(),\n+                r.getSbn().getKey()));\n+        assertFalse(0L == mSnoozeHelper.getSnoozeTimeForUnpostedNotification(\n+                r2.getUser().getIdentifier(), r2.getSbn().getPackageName(),\n+                r2.getSbn().getKey()));\n \n         // clear data\n         mSnoozeHelper.clearData(UserHandle.USER_SYSTEM, \"pkg\");\n",
    "added_lines": 40,
    "deleted_lines": 1,
    "changed_methods": "SnoozeHelperTest::testLongTagPersistedNotification, SnoozeHelperTest::testClearData"
   }
  ]
 },
 {
  "hash": "a71883f3081348371482d96d71dc119ef2f7d463",
  "commit": "Limit the number of shortcuts per app that can be retained by system\n\nThis is a second attempt at fixing the issue, the previous CL\nag/20642213 was reverted because it simply throws an exception when the\nlimit is reached, which causes apps to crash since chat apps tends to be\nsending large amount of conversation shortcuts and they have no way to\nknow how many of these shortcuts are still cached by the system.\n\nInstead of throwing an exception, this CL simply removes excessive\nshortcuts to avoid crashes. Currently there is a limit on the number\nof shortcuts an app can publish in respect to each launcher activity.\nThis CL further implements a global maximum of total number of shortcuts\nthat can be retained for an app to mitigate from any potential system\nhealth issue.\n\nWhen the global maximum is reached, ShortcutService will proactively\nremoves shortcuts from system memory. Cached shortcuts are removed\nfirst, followed by dynamic shortcuts, using last updated time as\ntie-breaker.\n\nThis CL additionally addresses an unexpected flow where re-publishing\npreviously removed shortcuts that are still retained by the system could\ncause the total number of shortcuts to exceed previously set limit.\n\nBug: 250576066 233155034\nTest: manual\nChange-Id: I001c7a87b62aefa9487bf8efaf3cd02d7cb21521\nMerged-In: I001c7a87b62aefa9487bf8efaf3cd02d7cb21521\n(cherry picked from commit on googleplex-android-review.googlesource.com host: 94437e989c0391b2dbf28d33120fdc28a4ce8d4d)\nMerged-In: I001c7a87b62aefa9487bf8efaf3cd02d7cb21521",
  "files": [
   {
    "filename": "ShortcutPackage.java",
    "diff": "@@ -405,6 +405,7 @@ class ShortcutPackage extends ShortcutPackageItem {\n             @NonNull List<ShortcutInfo> changedShortcuts) {\n         Preconditions.checkArgument(newShortcut.isEnabled(),\n                 \"pushDynamicShortcuts() cannot publish disabled shortcuts\");\n+        ensureShortcutCountBeforePush();\n \n         newShortcut.addFlags(ShortcutInfo.FLAG_DYNAMIC);\n \n@@ -412,7 +413,7 @@ class ShortcutPackage extends ShortcutPackageItem {\n         final ShortcutInfo oldShortcut = findShortcutById(newShortcut.getId());\n         boolean deleted = false;\n \n-        if (oldShortcut == null) {\n+        if (oldShortcut == null || !oldShortcut.isDynamic()) {\n             final ShortcutService service = mShortcutUser.mService;\n             final int maxShortcuts = service.getMaxActivityShortcuts();\n \n@@ -422,7 +423,6 @@ class ShortcutPackage extends ShortcutPackageItem {\n \n             if (activityShortcuts != null && activityShortcuts.size() == maxShortcuts) {\n                 // Max has reached. Delete the shortcut with lowest rank.\n-\n                 // Sort by isManifestShortcut() and getRank().\n                 Collections.sort(activityShortcuts, mShortcutTypeAndRankComparator);\n \n@@ -437,7 +437,8 @@ class ShortcutPackage extends ShortcutPackageItem {\n                 changedShortcuts.add(shortcut);\n                 deleted = deleteDynamicWithId(shortcut.getId(), /*ignoreInvisible=*/ true) != null;\n             }\n-        } else {\n+        }\n+        if (oldShortcut != null) {\n             // It's an update case.\n             // Make sure the target is updatable. (i.e. should be mutable.)\n             oldShortcut.ensureUpdatableWith(newShortcut, /*isUpdating=*/ false);\n@@ -463,6 +464,32 @@ class ShortcutPackage extends ShortcutPackageItem {\n         return deleted;\n     }\n \n+    private void ensureShortcutCountBeforePush() {\n+        final ShortcutService service = mShortcutUser.mService;\n+        // Ensure the total number of shortcuts doesn't exceed the hard limit per app.\n+        final int maxShortcutPerApp = service.getMaxAppShortcuts();\n+        synchronized (mLock) {\n+            final List<ShortcutInfo> appShortcuts = mShortcuts.values().stream().filter(si ->\n+                    !si.isPinned()).collect(Collectors.toList());\n+            if (appShortcuts.size() >= maxShortcutPerApp) {\n+                // Max has reached. Removes shortcuts until they fall within the hard cap.\n+                // Sort by isManifestShortcut(), isDynamic() and getLastChangedTimestamp().\n+                Collections.sort(appShortcuts, mShortcutTypeRankAndTimeComparator);\n+\n+                while (appShortcuts.size() >= maxShortcutPerApp) {\n+                    final ShortcutInfo shortcut = appShortcuts.remove(appShortcuts.size() - 1);\n+                    if (shortcut.isDeclaredInManifest()) {\n+                        // All shortcuts are manifest shortcuts and cannot be removed.\n+                        throw new IllegalArgumentException(getPackageName() + \" has published \"\n+                                + appShortcuts.size() + \" manifest shortcuts across different\"\n+                                + \" activities.\");\n+                    }\n+                    forceDeleteShortcutInner(shortcut.getId());\n+                }\n+            }\n+        }\n+    }\n+\n     /**\n      * Remove all shortcuts that aren't pinned, cached nor dynamic.\n      *\n@@ -1368,6 +1395,61 @@ class ShortcutPackage extends ShortcutPackageItem {\n         return Integer.compare(a.getRank(), b.getRank());\n     };\n \n+    /**\n+     * To sort by isManifestShortcut(), isDynamic(), getRank() and\n+     * getLastChangedTimestamp(). i.e. manifest shortcuts come before non-manifest shortcuts,\n+     * dynamic shortcuts come before floating shortcuts, then sort by last changed timestamp.\n+     *\n+     * This is used to decide which shortcuts to remove when the total number of shortcuts retained\n+     * for the app exceeds the limit defined in {@link ShortcutService#getMaxAppShortcuts()}.\n+     *\n+     * (Note the number of manifest shortcuts is always <= the max number, because if there are\n+     * more, ShortcutParser would ignore the rest.)\n+     */\n+    final Comparator<ShortcutInfo> mShortcutTypeRankAndTimeComparator = (ShortcutInfo a,\n+            ShortcutInfo b) -> {\n+        if (a.isDeclaredInManifest() && !b.isDeclaredInManifest()) {\n+            return -1;\n+        }\n+        if (!a.isDeclaredInManifest() && b.isDeclaredInManifest()) {\n+            return 1;\n+        }\n+        if (a.isDynamic() && b.isDynamic()) {\n+            return Integer.compare(a.getRank(), b.getRank());\n+        }\n+        if (a.isDynamic()) {\n+            return -1;\n+        }\n+        if (b.isDynamic()) {\n+            return 1;\n+        }\n+        if (a.isCached() && b.isCached()) {\n+            // if both shortcuts are cached, prioritize shortcuts cached by people tile,\n+            if (a.hasFlags(ShortcutInfo.FLAG_CACHED_PEOPLE_TILE)\n+                    && !b.hasFlags(ShortcutInfo.FLAG_CACHED_PEOPLE_TILE)) {\n+                return -1;\n+            } else if (!a.hasFlags(ShortcutInfo.FLAG_CACHED_PEOPLE_TILE)\n+                    && b.hasFlags(ShortcutInfo.FLAG_CACHED_PEOPLE_TILE)) {\n+                return 1;\n+            }\n+            // followed by bubbles.\n+            if (a.hasFlags(ShortcutInfo.FLAG_CACHED_BUBBLES)\n+                    && !b.hasFlags(ShortcutInfo.FLAG_CACHED_BUBBLES)) {\n+                return -1;\n+            } else if (!a.hasFlags(ShortcutInfo.FLAG_CACHED_BUBBLES)\n+                    && b.hasFlags(ShortcutInfo.FLAG_CACHED_BUBBLES)) {\n+                return 1;\n+            }\n+        }\n+        if (a.isCached()) {\n+            return -1;\n+        }\n+        if (b.isCached()) {\n+            return 1;\n+        }\n+        return Long.compare(b.getLastChangedTimestamp(), a.getLastChangedTimestamp());\n+    };\n+\n     /**\n      * Build a list of shortcuts for each target activity and return as a map. The result won't\n      * contain \"floating\" shortcuts because they don't belong on any activities.\n",
    "added_lines": 85,
    "deleted_lines": 3,
    "changed_methods": "ShortcutPackage::pushDynamicShortcut, ShortcutPackage::if, ShortcutPackage::if, ShortcutPackage::if, ShortcutPackage::if, ShortcutPackage::if, ShortcutPackage::if, ShortcutPackage::if, ShortcutPackage::ensureShortcutCountBeforePush, ShortcutPackage::if"
   },
   {
    "filename": "ShortcutService.java",
    "diff": "@@ -179,6 +179,9 @@ public class ShortcutService extends IShortcutService.Stub {\n     @VisibleForTesting\n     static final int DEFAULT_MAX_SHORTCUTS_PER_ACTIVITY = 15;\n \n+    @VisibleForTesting\n+    static final int DEFAULT_MAX_SHORTCUTS_PER_APP = 100;\n+\n     @VisibleForTesting\n     static final int DEFAULT_MAX_ICON_DIMENSION_DP = 96;\n \n@@ -253,6 +256,11 @@ public class ShortcutService extends IShortcutService.Stub {\n          */\n         String KEY_MAX_SHORTCUTS = \"max_shortcuts\";\n \n+        /**\n+         * Key name for the max shortcuts can be retained in system ram per app. (int)\n+         */\n+        String KEY_MAX_SHORTCUTS_PER_APP = \"max_shortcuts_per_app\";\n+\n         /**\n          * Key name for icon compression quality, 0-100.\n          */\n@@ -325,10 +333,15 @@ public class ShortcutService extends IShortcutService.Stub {\n             new SparseArray<>();\n \n     /**\n-     * Max number of dynamic + manifest shortcuts that each application can have at a time.\n+     * Max number of dynamic + manifest shortcuts that each activity can have at a time.\n      */\n     private int mMaxShortcuts;\n \n+    /**\n+     * Max number of shortcuts that can exists in system ram for each application.\n+     */\n+    private int mMaxShortcutsPerApp;\n+\n     /**\n      * Max number of updating API calls that each application can make during the interval.\n      */\n@@ -790,6 +803,9 @@ public class ShortcutService extends IShortcutService.Stub {\n         mMaxShortcuts = Math.max(0, (int) parser.getLong(\n                 ConfigConstants.KEY_MAX_SHORTCUTS, DEFAULT_MAX_SHORTCUTS_PER_ACTIVITY));\n \n+        mMaxShortcutsPerApp = Math.max(0, (int) parser.getLong(\n+                ConfigConstants.KEY_MAX_SHORTCUTS_PER_APP, DEFAULT_MAX_SHORTCUTS_PER_APP));\n+\n         final int iconDimensionDp = Math.max(1, injectIsLowRamDevice()\n                 ? (int) parser.getLong(\n                 ConfigConstants.KEY_MAX_ICON_DIMENSION_DP_LOWRAM,\n@@ -1757,6 +1773,13 @@ public class ShortcutService extends IShortcutService.Stub {\n         return mMaxShortcuts;\n     }\n \n+    /**\n+     * Return the max number of shortcuts can be retaiend in system ram for each application.\n+     */\n+    int getMaxAppShortcuts() {\n+        return mMaxShortcutsPerApp;\n+    }\n+\n     /**\n      * - Sends a notification to LauncherApps\n      * - Write to file\n",
    "added_lines": 24,
    "deleted_lines": 1,
    "changed_methods": "ShortcutService::updateConfigurationLocked, ShortcutService::getMaxAppShortcuts"
   }
  ]
 },
 {
  "hash": "a71883f3081348371482d96d71dc119ef2f7d463",
  "commit": "Limit the number of shortcuts per app that can be retained by system\n\nThis is a second attempt at fixing the issue, the previous CL\nag/20642213 was reverted because it simply throws an exception when the\nlimit is reached, which causes apps to crash since chat apps tends to be\nsending large amount of conversation shortcuts and they have no way to\nknow how many of these shortcuts are still cached by the system.\n\nInstead of throwing an exception, this CL simply removes excessive\nshortcuts to avoid crashes. Currently there is a limit on the number\nof shortcuts an app can publish in respect to each launcher activity.\nThis CL further implements a global maximum of total number of shortcuts\nthat can be retained for an app to mitigate from any potential system\nhealth issue.\n\nWhen the global maximum is reached, ShortcutService will proactively\nremoves shortcuts from system memory. Cached shortcuts are removed\nfirst, followed by dynamic shortcuts, using last updated time as\ntie-breaker.\n\nThis CL additionally addresses an unexpected flow where re-publishing\npreviously removed shortcuts that are still retained by the system could\ncause the total number of shortcuts to exceed previously set limit.\n\nBug: 250576066 233155034\nTest: manual\nChange-Id: I001c7a87b62aefa9487bf8efaf3cd02d7cb21521\nMerged-In: I001c7a87b62aefa9487bf8efaf3cd02d7cb21521\n(cherry picked from commit on googleplex-android-review.googlesource.com host: 94437e989c0391b2dbf28d33120fdc28a4ce8d4d)\nMerged-In: I001c7a87b62aefa9487bf8efaf3cd02d7cb21521",
  "files": [
   {
    "filename": "ShortcutPackage.java",
    "diff": "@@ -405,6 +405,7 @@ class ShortcutPackage extends ShortcutPackageItem {\n             @NonNull List<ShortcutInfo> changedShortcuts) {\n         Preconditions.checkArgument(newShortcut.isEnabled(),\n                 \"pushDynamicShortcuts() cannot publish disabled shortcuts\");\n+        ensureShortcutCountBeforePush();\n \n         newShortcut.addFlags(ShortcutInfo.FLAG_DYNAMIC);\n \n@@ -412,7 +413,7 @@ class ShortcutPackage extends ShortcutPackageItem {\n         final ShortcutInfo oldShortcut = findShortcutById(newShortcut.getId());\n         boolean deleted = false;\n \n-        if (oldShortcut == null) {\n+        if (oldShortcut == null || !oldShortcut.isDynamic()) {\n             final ShortcutService service = mShortcutUser.mService;\n             final int maxShortcuts = service.getMaxActivityShortcuts();\n \n@@ -422,7 +423,6 @@ class ShortcutPackage extends ShortcutPackageItem {\n \n             if (activityShortcuts != null && activityShortcuts.size() == maxShortcuts) {\n                 // Max has reached. Delete the shortcut with lowest rank.\n-\n                 // Sort by isManifestShortcut() and getRank().\n                 Collections.sort(activityShortcuts, mShortcutTypeAndRankComparator);\n \n@@ -437,7 +437,8 @@ class ShortcutPackage extends ShortcutPackageItem {\n                 changedShortcuts.add(shortcut);\n                 deleted = deleteDynamicWithId(shortcut.getId(), /*ignoreInvisible=*/ true) != null;\n             }\n-        } else {\n+        }\n+        if (oldShortcut != null) {\n             // It's an update case.\n             // Make sure the target is updatable. (i.e. should be mutable.)\n             oldShortcut.ensureUpdatableWith(newShortcut, /*isUpdating=*/ false);\n@@ -463,6 +464,32 @@ class ShortcutPackage extends ShortcutPackageItem {\n         return deleted;\n     }\n \n+    private void ensureShortcutCountBeforePush() {\n+        final ShortcutService service = mShortcutUser.mService;\n+        // Ensure the total number of shortcuts doesn't exceed the hard limit per app.\n+        final int maxShortcutPerApp = service.getMaxAppShortcuts();\n+        synchronized (mLock) {\n+            final List<ShortcutInfo> appShortcuts = mShortcuts.values().stream().filter(si ->\n+                    !si.isPinned()).collect(Collectors.toList());\n+            if (appShortcuts.size() >= maxShortcutPerApp) {\n+                // Max has reached. Removes shortcuts until they fall within the hard cap.\n+                // Sort by isManifestShortcut(), isDynamic() and getLastChangedTimestamp().\n+                Collections.sort(appShortcuts, mShortcutTypeRankAndTimeComparator);\n+\n+                while (appShortcuts.size() >= maxShortcutPerApp) {\n+                    final ShortcutInfo shortcut = appShortcuts.remove(appShortcuts.size() - 1);\n+                    if (shortcut.isDeclaredInManifest()) {\n+                        // All shortcuts are manifest shortcuts and cannot be removed.\n+                        throw new IllegalArgumentException(getPackageName() + \" has published \"\n+                                + appShortcuts.size() + \" manifest shortcuts across different\"\n+                                + \" activities.\");\n+                    }\n+                    forceDeleteShortcutInner(shortcut.getId());\n+                }\n+            }\n+        }\n+    }\n+\n     /**\n      * Remove all shortcuts that aren't pinned, cached nor dynamic.\n      *\n@@ -1368,6 +1395,61 @@ class ShortcutPackage extends ShortcutPackageItem {\n         return Integer.compare(a.getRank(), b.getRank());\n     };\n \n+    /**\n+     * To sort by isManifestShortcut(), isDynamic(), getRank() and\n+     * getLastChangedTimestamp(). i.e. manifest shortcuts come before non-manifest shortcuts,\n+     * dynamic shortcuts come before floating shortcuts, then sort by last changed timestamp.\n+     *\n+     * This is used to decide which shortcuts to remove when the total number of shortcuts retained\n+     * for the app exceeds the limit defined in {@link ShortcutService#getMaxAppShortcuts()}.\n+     *\n+     * (Note the number of manifest shortcuts is always <= the max number, because if there are\n+     * more, ShortcutParser would ignore the rest.)\n+     */\n+    final Comparator<ShortcutInfo> mShortcutTypeRankAndTimeComparator = (ShortcutInfo a,\n+            ShortcutInfo b) -> {\n+        if (a.isDeclaredInManifest() && !b.isDeclaredInManifest()) {\n+            return -1;\n+        }\n+        if (!a.isDeclaredInManifest() && b.isDeclaredInManifest()) {\n+            return 1;\n+        }\n+        if (a.isDynamic() && b.isDynamic()) {\n+            return Integer.compare(a.getRank(), b.getRank());\n+        }\n+        if (a.isDynamic()) {\n+            return -1;\n+        }\n+        if (b.isDynamic()) {\n+            return 1;\n+        }\n+        if (a.isCached() && b.isCached()) {\n+            // if both shortcuts are cached, prioritize shortcuts cached by people tile,\n+            if (a.hasFlags(ShortcutInfo.FLAG_CACHED_PEOPLE_TILE)\n+                    && !b.hasFlags(ShortcutInfo.FLAG_CACHED_PEOPLE_TILE)) {\n+                return -1;\n+            } else if (!a.hasFlags(ShortcutInfo.FLAG_CACHED_PEOPLE_TILE)\n+                    && b.hasFlags(ShortcutInfo.FLAG_CACHED_PEOPLE_TILE)) {\n+                return 1;\n+            }\n+            // followed by bubbles.\n+            if (a.hasFlags(ShortcutInfo.FLAG_CACHED_BUBBLES)\n+                    && !b.hasFlags(ShortcutInfo.FLAG_CACHED_BUBBLES)) {\n+                return -1;\n+            } else if (!a.hasFlags(ShortcutInfo.FLAG_CACHED_BUBBLES)\n+                    && b.hasFlags(ShortcutInfo.FLAG_CACHED_BUBBLES)) {\n+                return 1;\n+            }\n+        }\n+        if (a.isCached()) {\n+            return -1;\n+        }\n+        if (b.isCached()) {\n+            return 1;\n+        }\n+        return Long.compare(b.getLastChangedTimestamp(), a.getLastChangedTimestamp());\n+    };\n+\n     /**\n      * Build a list of shortcuts for each target activity and return as a map. The result won't\n      * contain \"floating\" shortcuts because they don't belong on any activities.\n",
    "added_lines": 85,
    "deleted_lines": 3,
    "changed_methods": "ShortcutPackage::pushDynamicShortcut, ShortcutPackage::if, ShortcutPackage::if, ShortcutPackage::if, ShortcutPackage::if, ShortcutPackage::if, ShortcutPackage::if, ShortcutPackage::if, ShortcutPackage::ensureShortcutCountBeforePush, ShortcutPackage::if"
   },
   {
    "filename": "ShortcutService.java",
    "diff": "@@ -179,6 +179,9 @@ public class ShortcutService extends IShortcutService.Stub {\n     @VisibleForTesting\n     static final int DEFAULT_MAX_SHORTCUTS_PER_ACTIVITY = 15;\n \n+    @VisibleForTesting\n+    static final int DEFAULT_MAX_SHORTCUTS_PER_APP = 100;\n+\n     @VisibleForTesting\n     static final int DEFAULT_MAX_ICON_DIMENSION_DP = 96;\n \n@@ -253,6 +256,11 @@ public class ShortcutService extends IShortcutService.Stub {\n          */\n         String KEY_MAX_SHORTCUTS = \"max_shortcuts\";\n \n+        /**\n+         * Key name for the max shortcuts can be retained in system ram per app. (int)\n+         */\n+        String KEY_MAX_SHORTCUTS_PER_APP = \"max_shortcuts_per_app\";\n+\n         /**\n          * Key name for icon compression quality, 0-100.\n          */\n@@ -325,10 +333,15 @@ public class ShortcutService extends IShortcutService.Stub {\n             new SparseArray<>();\n \n     /**\n-     * Max number of dynamic + manifest shortcuts that each application can have at a time.\n+     * Max number of dynamic + manifest shortcuts that each activity can have at a time.\n      */\n     private int mMaxShortcuts;\n \n+    /**\n+     * Max number of shortcuts that can exists in system ram for each application.\n+     */\n+    private int mMaxShortcutsPerApp;\n+\n     /**\n      * Max number of updating API calls that each application can make during the interval.\n      */\n@@ -790,6 +803,9 @@ public class ShortcutService extends IShortcutService.Stub {\n         mMaxShortcuts = Math.max(0, (int) parser.getLong(\n                 ConfigConstants.KEY_MAX_SHORTCUTS, DEFAULT_MAX_SHORTCUTS_PER_ACTIVITY));\n \n+        mMaxShortcutsPerApp = Math.max(0, (int) parser.getLong(\n+                ConfigConstants.KEY_MAX_SHORTCUTS_PER_APP, DEFAULT_MAX_SHORTCUTS_PER_APP));\n+\n         final int iconDimensionDp = Math.max(1, injectIsLowRamDevice()\n                 ? (int) parser.getLong(\n                 ConfigConstants.KEY_MAX_ICON_DIMENSION_DP_LOWRAM,\n@@ -1757,6 +1773,13 @@ public class ShortcutService extends IShortcutService.Stub {\n         return mMaxShortcuts;\n     }\n \n+    /**\n+     * Return the max number of shortcuts can be retaiend in system ram for each application.\n+     */\n+    int getMaxAppShortcuts() {\n+        return mMaxShortcutsPerApp;\n+    }\n+\n     /**\n      * - Sends a notification to LauncherApps\n      * - Write to file\n",
    "added_lines": 24,
    "deleted_lines": 1,
    "changed_methods": "ShortcutService::updateConfigurationLocked, ShortcutService::getMaxAppShortcuts"
   }
  ]
 },
 {
  "hash": "0b338a6b51eb75b6673db99e7aa7a037bfcf6cc8",
  "commit": "Re-enforce MANAGE_ACTIVITY_TASKS for applySyncTransaction\n\nThe conditional permission was introduced for TaskFragmentOrganizer, but\nnot really needed. Remove the conditional check.\n\nBug: 259938771\nTest: pass existing tests\nMerged-In: I666b9ee6b6076766513b97e675fdbaa002428601\nChange-Id: I666b9ee6b6076766513b97e675fdbaa002428601\n(cherry picked from commit on googleplex-android-review.googlesource.com host: 6d848929eab6249b0ba1b8bd6d454744850b1718)\nMerged-In: I666b9ee6b6076766513b97e675fdbaa002428601",
  "files": [
   {
    "filename": "TaskFragmentOrganizer.java",
    "diff": "@@ -157,15 +157,6 @@ public class TaskFragmentOrganizer extends WindowOrganizer {\n         super.applyTransaction(t);\n     }\n \n-    // Suppress the lint because it is not a registration method.\n-    @SuppressWarnings(\"ExecutorRegistration\")\n-    @Override\n-    public int applySyncTransaction(@NonNull WindowContainerTransaction t,\n-            @NonNull WindowContainerTransactionCallback callback) {\n-        t.setTaskFragmentOrganizer(mInterface);\n-        return super.applySyncTransaction(t, callback);\n-    }\n-\n     private final ITaskFragmentOrganizer mInterface = new ITaskFragmentOrganizer.Stub() {\n         @Override\n         public void onTaskFragmentAppeared(@NonNull TaskFragmentInfo taskFragmentInfo) {\n",
    "added_lines": 0,
    "deleted_lines": 9,
    "changed_methods": "TaskFragmentOrganizer::applySyncTransaction"
   },
   {
    "filename": "WindowOrganizer.java",
    "diff": "@@ -61,9 +61,7 @@ public class WindowOrganizer {\n      * Apply multiple WindowContainer operations at once.\n      *\n      * Note that using this API requires the caller to hold\n-     * {@link android.Manifest.permission#MANAGE_ACTIVITY_TASKS}, unless the caller is using\n-     * {@link TaskFragmentOrganizer}, in which case it is allowed to change TaskFragment that is\n-     * created by itself.\n+     * {@link android.Manifest.permission#MANAGE_ACTIVITY_TASKS}.\n      *\n      * @param t The transaction to apply.\n      * @param callback This transaction will use the synchronization scheme described in\n@@ -72,8 +70,7 @@ public class WindowOrganizer {\n      * @return An ID for the sync operation which will later be passed to transactionReady callback.\n      *         This lets the caller differentiate overlapping sync operations.\n      */\n-    @RequiresPermission(value = android.Manifest.permission.MANAGE_ACTIVITY_TASKS,\n-            conditional = true)\n+    @RequiresPermission(value = android.Manifest.permission.MANAGE_ACTIVITY_TASKS)\n     public int applySyncTransaction(@NonNull WindowContainerTransaction t,\n             @NonNull WindowContainerTransactionCallback callback) {\n         try {\n",
    "added_lines": 2,
    "deleted_lines": 5,
    "changed_methods": ""
   },
   {
    "filename": "WindowOrganizerController.java",
    "diff": "@@ -177,7 +177,7 @@ class WindowOrganizerController extends IWindowOrganizerController.Stub\n         if (t == null) {\n             throw new IllegalArgumentException(\"Null transaction passed to applySyncTransaction\");\n         }\n-        enforceTaskPermission(\"applySyncTransaction()\", t);\n+        enforceTaskPermission(\"applySyncTransaction()\");\n         final CallerInfo caller = new CallerInfo();\n         final long ident = Binder.clearCallingIdentity();\n         try {\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "WindowOrganizerController::applySyncTransaction"
   },
   {
    "filename": "TaskFragmentOrganizerControllerTest.java",
    "diff": "@@ -50,7 +50,6 @@ import android.window.TaskFragmentOrganizer;\n import android.window.TaskFragmentOrganizerToken;\n import android.window.WindowContainerToken;\n import android.window.WindowContainerTransaction;\n-import android.window.WindowContainerTransactionCallback;\n \n import androidx.test.filters.SmallTest;\n \n@@ -227,19 +226,6 @@ public class TaskFragmentOrganizerControllerTest extends WindowTestsBase {\n         assertNull(mController.getRemoteAnimationDefinition(mIOrganizer));\n     }\n \n-    @Test\n-    public void testWindowContainerTransaction_setTaskFragmentOrganizer() {\n-        mOrganizer.applyTransaction(mTransaction);\n-\n-        assertEquals(mIOrganizer, mTransaction.getTaskFragmentOrganizer());\n-\n-        mTransaction = new WindowContainerTransaction();\n-        mOrganizer.applySyncTransaction(\n-                mTransaction, mock(WindowContainerTransactionCallback.class));\n-\n-        assertEquals(mIOrganizer, mTransaction.getTaskFragmentOrganizer());\n-    }\n-\n     @Test\n     public void testApplyTransaction_enforceConfigurationChangeOnOrganizedTaskFragment()\n             throws RemoteException {\n",
    "added_lines": 0,
    "deleted_lines": 14,
    "changed_methods": "TaskFragmentOrganizerControllerTest::testWindowContainerTransaction_setTaskFragmentOrganizer"
   }
  ]
 },
 {
  "hash": "0b338a6b51eb75b6673db99e7aa7a037bfcf6cc8",
  "commit": "Re-enforce MANAGE_ACTIVITY_TASKS for applySyncTransaction\n\nThe conditional permission was introduced for TaskFragmentOrganizer, but\nnot really needed. Remove the conditional check.\n\nBug: 259938771\nTest: pass existing tests\nMerged-In: I666b9ee6b6076766513b97e675fdbaa002428601\nChange-Id: I666b9ee6b6076766513b97e675fdbaa002428601\n(cherry picked from commit on googleplex-android-review.googlesource.com host: 6d848929eab6249b0ba1b8bd6d454744850b1718)\nMerged-In: I666b9ee6b6076766513b97e675fdbaa002428601",
  "files": [
   {
    "filename": "TaskFragmentOrganizer.java",
    "diff": "@@ -157,15 +157,6 @@ public class TaskFragmentOrganizer extends WindowOrganizer {\n         super.applyTransaction(t);\n     }\n \n-    // Suppress the lint because it is not a registration method.\n-    @SuppressWarnings(\"ExecutorRegistration\")\n-    @Override\n-    public int applySyncTransaction(@NonNull WindowContainerTransaction t,\n-            @NonNull WindowContainerTransactionCallback callback) {\n-        t.setTaskFragmentOrganizer(mInterface);\n-        return super.applySyncTransaction(t, callback);\n-    }\n-\n     private final ITaskFragmentOrganizer mInterface = new ITaskFragmentOrganizer.Stub() {\n         @Override\n         public void onTaskFragmentAppeared(@NonNull TaskFragmentInfo taskFragmentInfo) {\n",
    "added_lines": 0,
    "deleted_lines": 9,
    "changed_methods": "TaskFragmentOrganizer::applySyncTransaction"
   },
   {
    "filename": "WindowOrganizer.java",
    "diff": "@@ -61,9 +61,7 @@ public class WindowOrganizer {\n      * Apply multiple WindowContainer operations at once.\n      *\n      * Note that using this API requires the caller to hold\n-     * {@link android.Manifest.permission#MANAGE_ACTIVITY_TASKS}, unless the caller is using\n-     * {@link TaskFragmentOrganizer}, in which case it is allowed to change TaskFragment that is\n-     * created by itself.\n+     * {@link android.Manifest.permission#MANAGE_ACTIVITY_TASKS}.\n      *\n      * @param t The transaction to apply.\n      * @param callback This transaction will use the synchronization scheme described in\n@@ -72,8 +70,7 @@ public class WindowOrganizer {\n      * @return An ID for the sync operation which will later be passed to transactionReady callback.\n      *         This lets the caller differentiate overlapping sync operations.\n      */\n-    @RequiresPermission(value = android.Manifest.permission.MANAGE_ACTIVITY_TASKS,\n-            conditional = true)\n+    @RequiresPermission(value = android.Manifest.permission.MANAGE_ACTIVITY_TASKS)\n     public int applySyncTransaction(@NonNull WindowContainerTransaction t,\n             @NonNull WindowContainerTransactionCallback callback) {\n         try {\n",
    "added_lines": 2,
    "deleted_lines": 5,
    "changed_methods": ""
   },
   {
    "filename": "WindowOrganizerController.java",
    "diff": "@@ -177,7 +177,7 @@ class WindowOrganizerController extends IWindowOrganizerController.Stub\n         if (t == null) {\n             throw new IllegalArgumentException(\"Null transaction passed to applySyncTransaction\");\n         }\n-        enforceTaskPermission(\"applySyncTransaction()\", t);\n+        enforceTaskPermission(\"applySyncTransaction()\");\n         final CallerInfo caller = new CallerInfo();\n         final long ident = Binder.clearCallingIdentity();\n         try {\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "WindowOrganizerController::applySyncTransaction"
   },
   {
    "filename": "TaskFragmentOrganizerControllerTest.java",
    "diff": "@@ -50,7 +50,6 @@ import android.window.TaskFragmentOrganizer;\n import android.window.TaskFragmentOrganizerToken;\n import android.window.WindowContainerToken;\n import android.window.WindowContainerTransaction;\n-import android.window.WindowContainerTransactionCallback;\n \n import androidx.test.filters.SmallTest;\n \n@@ -227,19 +226,6 @@ public class TaskFragmentOrganizerControllerTest extends WindowTestsBase {\n         assertNull(mController.getRemoteAnimationDefinition(mIOrganizer));\n     }\n \n-    @Test\n-    public void testWindowContainerTransaction_setTaskFragmentOrganizer() {\n-        mOrganizer.applyTransaction(mTransaction);\n-\n-        assertEquals(mIOrganizer, mTransaction.getTaskFragmentOrganizer());\n-\n-        mTransaction = new WindowContainerTransaction();\n-        mOrganizer.applySyncTransaction(\n-                mTransaction, mock(WindowContainerTransactionCallback.class));\n-\n-        assertEquals(mIOrganizer, mTransaction.getTaskFragmentOrganizer());\n-    }\n-\n     @Test\n     public void testApplyTransaction_enforceConfigurationChangeOnOrganizedTaskFragment()\n             throws RemoteException {\n",
    "added_lines": 0,
    "deleted_lines": 14,
    "changed_methods": "TaskFragmentOrganizerControllerTest::testWindowContainerTransaction_setTaskFragmentOrganizer"
   }
  ]
 },
 {
  "hash": "0b338a6b51eb75b6673db99e7aa7a037bfcf6cc8",
  "commit": "Re-enforce MANAGE_ACTIVITY_TASKS for applySyncTransaction\n\nThe conditional permission was introduced for TaskFragmentOrganizer, but\nnot really needed. Remove the conditional check.\n\nBug: 259938771\nTest: pass existing tests\nMerged-In: I666b9ee6b6076766513b97e675fdbaa002428601\nChange-Id: I666b9ee6b6076766513b97e675fdbaa002428601\n(cherry picked from commit on googleplex-android-review.googlesource.com host: 6d848929eab6249b0ba1b8bd6d454744850b1718)\nMerged-In: I666b9ee6b6076766513b97e675fdbaa002428601",
  "files": [
   {
    "filename": "TaskFragmentOrganizer.java",
    "diff": "@@ -157,15 +157,6 @@ public class TaskFragmentOrganizer extends WindowOrganizer {\n         super.applyTransaction(t);\n     }\n \n-    // Suppress the lint because it is not a registration method.\n-    @SuppressWarnings(\"ExecutorRegistration\")\n-    @Override\n-    public int applySyncTransaction(@NonNull WindowContainerTransaction t,\n-            @NonNull WindowContainerTransactionCallback callback) {\n-        t.setTaskFragmentOrganizer(mInterface);\n-        return super.applySyncTransaction(t, callback);\n-    }\n-\n     private final ITaskFragmentOrganizer mInterface = new ITaskFragmentOrganizer.Stub() {\n         @Override\n         public void onTaskFragmentAppeared(@NonNull TaskFragmentInfo taskFragmentInfo) {\n",
    "added_lines": 0,
    "deleted_lines": 9,
    "changed_methods": "TaskFragmentOrganizer::applySyncTransaction"
   },
   {
    "filename": "WindowOrganizer.java",
    "diff": "@@ -61,9 +61,7 @@ public class WindowOrganizer {\n      * Apply multiple WindowContainer operations at once.\n      *\n      * Note that using this API requires the caller to hold\n-     * {@link android.Manifest.permission#MANAGE_ACTIVITY_TASKS}, unless the caller is using\n-     * {@link TaskFragmentOrganizer}, in which case it is allowed to change TaskFragment that is\n-     * created by itself.\n+     * {@link android.Manifest.permission#MANAGE_ACTIVITY_TASKS}.\n      *\n      * @param t The transaction to apply.\n      * @param callback This transaction will use the synchronization scheme described in\n@@ -72,8 +70,7 @@ public class WindowOrganizer {\n      * @return An ID for the sync operation which will later be passed to transactionReady callback.\n      *         This lets the caller differentiate overlapping sync operations.\n      */\n-    @RequiresPermission(value = android.Manifest.permission.MANAGE_ACTIVITY_TASKS,\n-            conditional = true)\n+    @RequiresPermission(value = android.Manifest.permission.MANAGE_ACTIVITY_TASKS)\n     public int applySyncTransaction(@NonNull WindowContainerTransaction t,\n             @NonNull WindowContainerTransactionCallback callback) {\n         try {\n",
    "added_lines": 2,
    "deleted_lines": 5,
    "changed_methods": ""
   },
   {
    "filename": "WindowOrganizerController.java",
    "diff": "@@ -177,7 +177,7 @@ class WindowOrganizerController extends IWindowOrganizerController.Stub\n         if (t == null) {\n             throw new IllegalArgumentException(\"Null transaction passed to applySyncTransaction\");\n         }\n-        enforceTaskPermission(\"applySyncTransaction()\", t);\n+        enforceTaskPermission(\"applySyncTransaction()\");\n         final CallerInfo caller = new CallerInfo();\n         final long ident = Binder.clearCallingIdentity();\n         try {\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "WindowOrganizerController::applySyncTransaction"
   },
   {
    "filename": "TaskFragmentOrganizerControllerTest.java",
    "diff": "@@ -50,7 +50,6 @@ import android.window.TaskFragmentOrganizer;\n import android.window.TaskFragmentOrganizerToken;\n import android.window.WindowContainerToken;\n import android.window.WindowContainerTransaction;\n-import android.window.WindowContainerTransactionCallback;\n \n import androidx.test.filters.SmallTest;\n \n@@ -227,19 +226,6 @@ public class TaskFragmentOrganizerControllerTest extends WindowTestsBase {\n         assertNull(mController.getRemoteAnimationDefinition(mIOrganizer));\n     }\n \n-    @Test\n-    public void testWindowContainerTransaction_setTaskFragmentOrganizer() {\n-        mOrganizer.applyTransaction(mTransaction);\n-\n-        assertEquals(mIOrganizer, mTransaction.getTaskFragmentOrganizer());\n-\n-        mTransaction = new WindowContainerTransaction();\n-        mOrganizer.applySyncTransaction(\n-                mTransaction, mock(WindowContainerTransactionCallback.class));\n-\n-        assertEquals(mIOrganizer, mTransaction.getTaskFragmentOrganizer());\n-    }\n-\n     @Test\n     public void testApplyTransaction_enforceConfigurationChangeOnOrganizedTaskFragment()\n             throws RemoteException {\n",
    "added_lines": 0,
    "deleted_lines": 14,
    "changed_methods": "TaskFragmentOrganizerControllerTest::testWindowContainerTransaction_setTaskFragmentOrganizer"
   }
  ]
 },
 {
  "hash": "0b338a6b51eb75b6673db99e7aa7a037bfcf6cc8",
  "commit": "Re-enforce MANAGE_ACTIVITY_TASKS for applySyncTransaction\n\nThe conditional permission was introduced for TaskFragmentOrganizer, but\nnot really needed. Remove the conditional check.\n\nBug: 259938771\nTest: pass existing tests\nMerged-In: I666b9ee6b6076766513b97e675fdbaa002428601\nChange-Id: I666b9ee6b6076766513b97e675fdbaa002428601\n(cherry picked from commit on googleplex-android-review.googlesource.com host: 6d848929eab6249b0ba1b8bd6d454744850b1718)\nMerged-In: I666b9ee6b6076766513b97e675fdbaa002428601",
  "files": [
   {
    "filename": "TaskFragmentOrganizer.java",
    "diff": "@@ -157,15 +157,6 @@ public class TaskFragmentOrganizer extends WindowOrganizer {\n         super.applyTransaction(t);\n     }\n \n-    // Suppress the lint because it is not a registration method.\n-    @SuppressWarnings(\"ExecutorRegistration\")\n-    @Override\n-    public int applySyncTransaction(@NonNull WindowContainerTransaction t,\n-            @NonNull WindowContainerTransactionCallback callback) {\n-        t.setTaskFragmentOrganizer(mInterface);\n-        return super.applySyncTransaction(t, callback);\n-    }\n-\n     private final ITaskFragmentOrganizer mInterface = new ITaskFragmentOrganizer.Stub() {\n         @Override\n         public void onTaskFragmentAppeared(@NonNull TaskFragmentInfo taskFragmentInfo) {\n",
    "added_lines": 0,
    "deleted_lines": 9,
    "changed_methods": "TaskFragmentOrganizer::applySyncTransaction"
   },
   {
    "filename": "WindowOrganizer.java",
    "diff": "@@ -61,9 +61,7 @@ public class WindowOrganizer {\n      * Apply multiple WindowContainer operations at once.\n      *\n      * Note that using this API requires the caller to hold\n-     * {@link android.Manifest.permission#MANAGE_ACTIVITY_TASKS}, unless the caller is using\n-     * {@link TaskFragmentOrganizer}, in which case it is allowed to change TaskFragment that is\n-     * created by itself.\n+     * {@link android.Manifest.permission#MANAGE_ACTIVITY_TASKS}.\n      *\n      * @param t The transaction to apply.\n      * @param callback This transaction will use the synchronization scheme described in\n@@ -72,8 +70,7 @@ public class WindowOrganizer {\n      * @return An ID for the sync operation which will later be passed to transactionReady callback.\n      *         This lets the caller differentiate overlapping sync operations.\n      */\n-    @RequiresPermission(value = android.Manifest.permission.MANAGE_ACTIVITY_TASKS,\n-            conditional = true)\n+    @RequiresPermission(value = android.Manifest.permission.MANAGE_ACTIVITY_TASKS)\n     public int applySyncTransaction(@NonNull WindowContainerTransaction t,\n             @NonNull WindowContainerTransactionCallback callback) {\n         try {\n",
    "added_lines": 2,
    "deleted_lines": 5,
    "changed_methods": ""
   },
   {
    "filename": "WindowOrganizerController.java",
    "diff": "@@ -177,7 +177,7 @@ class WindowOrganizerController extends IWindowOrganizerController.Stub\n         if (t == null) {\n             throw new IllegalArgumentException(\"Null transaction passed to applySyncTransaction\");\n         }\n-        enforceTaskPermission(\"applySyncTransaction()\", t);\n+        enforceTaskPermission(\"applySyncTransaction()\");\n         final CallerInfo caller = new CallerInfo();\n         final long ident = Binder.clearCallingIdentity();\n         try {\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "WindowOrganizerController::applySyncTransaction"
   },
   {
    "filename": "TaskFragmentOrganizerControllerTest.java",
    "diff": "@@ -50,7 +50,6 @@ import android.window.TaskFragmentOrganizer;\n import android.window.TaskFragmentOrganizerToken;\n import android.window.WindowContainerToken;\n import android.window.WindowContainerTransaction;\n-import android.window.WindowContainerTransactionCallback;\n \n import androidx.test.filters.SmallTest;\n \n@@ -227,19 +226,6 @@ public class TaskFragmentOrganizerControllerTest extends WindowTestsBase {\n         assertNull(mController.getRemoteAnimationDefinition(mIOrganizer));\n     }\n \n-    @Test\n-    public void testWindowContainerTransaction_setTaskFragmentOrganizer() {\n-        mOrganizer.applyTransaction(mTransaction);\n-\n-        assertEquals(mIOrganizer, mTransaction.getTaskFragmentOrganizer());\n-\n-        mTransaction = new WindowContainerTransaction();\n-        mOrganizer.applySyncTransaction(\n-                mTransaction, mock(WindowContainerTransactionCallback.class));\n-\n-        assertEquals(mIOrganizer, mTransaction.getTaskFragmentOrganizer());\n-    }\n-\n     @Test\n     public void testApplyTransaction_enforceConfigurationChangeOnOrganizedTaskFragment()\n             throws RemoteException {\n",
    "added_lines": 0,
    "deleted_lines": 14,
    "changed_methods": "TaskFragmentOrganizerControllerTest::testWindowContainerTransaction_setTaskFragmentOrganizer"
   }
  ]
 },
 {
  "hash": "268ad14fea89283f8f1b66902f874d3c1c95fe5b",
  "commit": "Remove Activity if it enters PiP without window\n\nThis is to prevent malicious app entering PiP without being visible\nfirst, like blocking onResume from completion. Which in turn\nleaves the PiP window in limbo and non-interactable.\n\nBug: 265293293\nTest: atest PinnedStackTests\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:4fad1456409b79d6e649a29d5116a4fe3160bd21)\nMerged-In: I458a9508662e72a1adb9d9818105f2e9d7096d44\nChange-Id: I458a9508662e72a1adb9d9818105f2e9d7096d44",
  "files": [
   {
    "filename": "ActivityRecord.java",
    "diff": "@@ -1386,6 +1386,12 @@ final class ActivityRecord extends WindowToken implements WindowManagerService.A\n             mLastReportedMultiWindowMode = inPictureInPictureMode;\n             ensureActivityConfiguration(0 /* globalChanges */, PRESERVE_WINDOWS,\n                     true /* ignoreVisibility */);\n+            if (inPictureInPictureMode && findMainWindow() == null) {\n+                // Prevent malicious app entering PiP without valid WindowState, which can in turn\n+                // result a non-touchable PiP window since the InputConsumer for PiP requires it.\n+                EventLog.writeEvent(0x534e4554, \"265293293\", -1, \"\");\n+                removeImmediately();\n+            }\n         }\n     }\n \n",
    "added_lines": 6,
    "deleted_lines": 0,
    "changed_methods": "ActivityRecord::updatePictureInPictureMode"
   }
  ]
 },
 {
  "hash": "b6d4b096665d9d356cadb12f16767d64945ee6e8",
  "commit": "[DO NOT MERGE] Wait for preloading images to complete before inflating notifications\n\n NotificationContentInflater waits on SysUiBg thread for images to load, with a timeout\n of 1000ms.\n\nTest: 1. Build a test app that posts MessagingStyle notifications with a huge image (8k+) set as data Uri.\n 2. SystemUi should not ANR\n 3. adb logcat | grep NotificationInlineImageCache  - shows timeout/cancellation logs\n\nBug: 252766417\nBug: 223859644\n\n(cherry picked from commit 195043f40e46ddcd2fe534a9dac344792d39d91c)\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:b9cd15ad8a2f87893164ad2ab518039bb0b61424)\nMerged-In: I341db60223214cf2282b5c0270e343e1ce95fa01\nChange-Id: I341db60223214cf2282b5c0270e343e1ce95fa01",
  "files": [
   {
    "filename": "NotificationContentInflater.java",
    "diff": "@@ -439,6 +439,7 @@ public class NotificationContentInflater implements NotificationRowContentBinder\n         CancellationSignal cancellationSignal = new CancellationSignal();\n         cancellationSignal.setOnCancelListener(\n                 () -> runningInflations.values().forEach(CancellationSignal::cancel));\n+\n         return cancellationSignal;\n     }\n \n@@ -711,6 +712,7 @@ public class NotificationContentInflater implements NotificationRowContentBinder\n     public static class AsyncInflationTask extends AsyncTask<Void, Void, InflationProgress>\n             implements InflationCallback, InflationTask {\n \n+        private static final long IMG_PRELOAD_TIMEOUT_MS = 1000L;\n         private final NotificationEntry mEntry;\n         private final Context mContext;\n         private final boolean mInflateSynchronously;\n@@ -804,7 +806,7 @@ public class NotificationContentInflater implements NotificationRowContentBinder\n                         recoveredBuilder, mIsLowPriority, mUsesIncreasedHeight,\n                         mUsesIncreasedHeadsUpHeight, packageContext);\n                 InflatedSmartReplyState previousSmartReplyState = mRow.getExistingSmartReplyState();\n-                return inflateSmartReplyViews(\n+                InflationProgress result = inflateSmartReplyViews(\n                         inflationProgress,\n                         mReInflateFlags,\n                         mEntry,\n@@ -812,6 +814,11 @@ public class NotificationContentInflater implements NotificationRowContentBinder\n                         packageContext,\n                         previousSmartReplyState,\n                         mSmartRepliesInflater);\n+\n+                // wait for image resolver to finish preloading\n+                mRow.getImageResolver().waitForPreloadedImages(IMG_PRELOAD_TIMEOUT_MS);\n+\n+                return result;\n             } catch (Exception e) {\n                 mError = e;\n                 return null;\n@@ -846,6 +853,9 @@ public class NotificationContentInflater implements NotificationRowContentBinder\n                 mCallback.handleInflationException(mRow.getEntry(),\n                         new InflationException(\"Couldn't inflate contentViews\" + e));\n             }\n+\n+            // Cancel any image loading tasks, not useful any more\n+            mRow.getImageResolver().cancelRunningTasks();\n         }\n \n         @Override\n@@ -872,6 +882,9 @@ public class NotificationContentInflater implements NotificationRowContentBinder\n             // Notify the resolver that the inflation task has finished,\n             // try to purge unnecessary cached entries.\n             mRow.getImageResolver().purgeCache();\n+\n+            // Cancel any image loading tasks that have not completed at this point\n+            mRow.getImageResolver().cancelRunningTasks();\n         }\n \n         private static class RtlEnabledContext extends ContextWrapper {\n",
    "added_lines": 14,
    "deleted_lines": 1,
    "changed_methods": "NotificationContentInflater::AsyncInflationTask::onAsyncInflationFinished, NotificationContentInflater::AsyncInflationTask::doInBackground, NotificationContentInflater::AsyncInflationTask::handleError, NotificationContentInflater::apply"
   },
   {
    "filename": "NotificationInlineImageCache.java",
    "diff": "@@ -23,8 +23,11 @@ import android.util.Log;\n \n import java.io.IOException;\n import java.util.Set;\n+import java.util.concurrent.CancellationException;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n \n /**\n  * A cache for inline images of image messages.\n@@ -57,12 +60,13 @@ public class NotificationInlineImageCache implements NotificationInlineImageReso\n     }\n \n     @Override\n-    public Drawable get(Uri uri) {\n+    public Drawable get(Uri uri, long timeoutMs) {\n         Drawable result = null;\n         try {\n-            result = mCache.get(uri).get();\n-        } catch (InterruptedException | ExecutionException ex) {\n-            Log.d(TAG, \"get: Failed get image from \" + uri);\n+            result = mCache.get(uri).get(timeoutMs, TimeUnit.MILLISECONDS);\n+        } catch (InterruptedException | ExecutionException\n+                | TimeoutException | CancellationException ex) {\n+            Log.d(TAG, \"get: Failed get image from \" + uri + \" \" + ex);\n         }\n         return result;\n     }\n@@ -73,6 +77,15 @@ public class NotificationInlineImageCache implements NotificationInlineImageReso\n         mCache.entrySet().removeIf(entry -> !wantedSet.contains(entry.getKey()));\n     }\n \n+    @Override\n+    public void cancelRunningTasks() {\n+        mCache.forEach((key, value) -> {\n+            if (value.getStatus() != AsyncTask.Status.FINISHED) {\n+                value.cancel(true);\n+            }\n+        });\n+    }\n+\n     private static class PreloadImageTask extends AsyncTask<Uri, Void, Drawable> {\n         private final NotificationInlineImageResolver mResolver;\n \n@@ -87,7 +100,7 @@ public class NotificationInlineImageCache implements NotificationInlineImageReso\n \n             try {\n                 drawable = mResolver.resolveImage(target);\n-            } catch (IOException | SecurityException ex) {\n+            } catch (Exception ex) {\n                 Log.d(TAG, \"PreloadImageTask: Resolve failed from \" + target, ex);\n             }\n \n",
    "added_lines": 18,
    "deleted_lines": 5,
    "changed_methods": "NotificationInlineImageCache::cancelRunningTasks, NotificationInlineImageCache::PreloadImageTask::doInBackground, NotificationInlineImageCache::get, NotificationInlineImageCache::get"
   },
   {
    "filename": "NotificationInlineImageResolver.java",
    "diff": "@@ -23,6 +23,7 @@ import android.graphics.drawable.Drawable;\n import android.net.Uri;\n import android.os.Bundle;\n import android.os.Parcelable;\n+import android.os.SystemClock;\n import android.util.Log;\n \n import com.android.internal.R;\n@@ -46,6 +47,9 @@ import java.util.Set;\n public class NotificationInlineImageResolver implements ImageResolver {\n     private static final String TAG = NotificationInlineImageResolver.class.getSimpleName();\n \n+    // Timeout for loading images from ImageCache when calling from UI thread\n+    private static final long MAX_UI_THREAD_TIMEOUT_MS = 100L;\n+\n     private final Context mContext;\n     private final ImageCache mImageCache;\n     private Set<Uri> mWantedUriSet;\n@@ -111,30 +115,38 @@ public class NotificationInlineImageResolver implements ImageResolver {\n      * To resolve image from specified uri directly. If the resulting image is larger than the\n      * maximum allowed size, scale it down.\n      * @param uri Uri of the image.\n-     * @return Drawable of the image.\n-     * @throws IOException Throws if failed at resolving the image.\n+     * @return Drawable of the image, or null if unable to load.\n      */\n-    Drawable resolveImage(Uri uri) throws IOException {\n-        return LocalImageResolver.resolveImage(uri, mContext, mMaxImageWidth, mMaxImageHeight);\n+    Drawable resolveImage(Uri uri) {\n+        try {\n+            return LocalImageResolver.resolveImage(uri, mContext, mMaxImageWidth, mMaxImageHeight);\n+        } catch (Exception ex) {\n+            // Catch general Exception because ContentResolver can re-throw arbitrary Exception\n+            // from remote process as a RuntimeException. See: Parcel#readException\n+            Log.d(TAG, \"resolveImage: Can't load image from \" + uri, ex);\n+        }\n+        return null;\n     }\n \n+    /**\n+     * Loads an image from the Uri.\n+     * This method is synchronous and is usually called from the Main thread.\n+     * It will time-out after MAX_UI_THREAD_TIMEOUT_MS.\n+     *\n+     * @param uri Uri of the target image.\n+     * @return drawable of the image, null if loading failed/timeout\n+     */\n     @Override\n     public Drawable loadImage(Uri uri) {\n-        Drawable result = null;\n-        try {\n-            if (hasCache()) {\n-                // if the uri isn't currently cached, try caching it first\n-                if (!mImageCache.hasEntry(uri)) {\n-                    mImageCache.preload((uri));\n-                }\n-                result = mImageCache.get(uri);\n-            } else {\n-                result = resolveImage(uri);\n-            }\n-        } catch (IOException | SecurityException ex) {\n-            Log.d(TAG, \"loadImage: Can't load image from \" + uri, ex);\n+        return hasCache() ? loadImageFromCache(uri, MAX_UI_THREAD_TIMEOUT_MS) : resolveImage(uri);\n+    }\n+\n+    private Drawable loadImageFromCache(Uri uri, long timeoutMs) {\n+        // if the uri isn't currently cached, try caching it first\n+        if (!mImageCache.hasEntry(uri)) {\n+            mImageCache.preload((uri));\n         }\n-        return result;\n+        return mImageCache.get(uri, timeoutMs);\n     }\n \n     /**\n@@ -208,6 +220,30 @@ public class NotificationInlineImageResolver implements ImageResolver {\n         return mWantedUriSet;\n     }\n \n+    /**\n+     * Wait for a maximum timeout for images to finish preloading\n+     * @param timeoutMs total timeout time\n+     */\n+    void waitForPreloadedImages(long timeoutMs) {\n+        if (!hasCache()) {\n+            return;\n+        }\n+        Set<Uri> preloadedUris = getWantedUriSet();\n+        if (preloadedUris != null) {\n+            // Decrement remaining timeout after each image check\n+            long endTimeMs = SystemClock.elapsedRealtime() + timeoutMs;\n+            preloadedUris.forEach(\n+                    uri -> loadImageFromCache(uri, endTimeMs - SystemClock.elapsedRealtime()));\n+        }\n+    }\n+\n+    void cancelRunningTasks() {\n+        if (!hasCache()) {\n+            return;\n+        }\n+        mImageCache.cancelRunningTasks();\n+    }\n+\n     /**\n      * A interface for internal cache implementation of this resolver.\n      */\n@@ -217,7 +253,7 @@ public class NotificationInlineImageResolver implements ImageResolver {\n          * @param uri The uri of the image.\n          * @return Drawable of the image.\n          */\n-        Drawable get(Uri uri);\n+        Drawable get(Uri uri, long timeoutMs);\n \n         /**\n          * Set the image resolver that actually resolves image from specified uri.\n@@ -242,6 +278,11 @@ public class NotificationInlineImageResolver implements ImageResolver {\n          * Purge unnecessary entries in the cache.\n          */\n         void purge();\n+\n+        /**\n+         * Cancel all unfinished image loading tasks\n+         */\n+        void cancelRunningTasks();\n     }\n \n }\n",
    "added_lines": 60,
    "deleted_lines": 19,
    "changed_methods": "NotificationInlineImageResolver::resolveImage, NotificationInlineImageResolver::loadImage, NotificationInlineImageResolver::waitForPreloadedImages, NotificationInlineImageResolver::loadImageFromCache, NotificationInlineImageResolver::cancelRunningTasks"
   }
  ]
 },
 {
  "hash": "b6d4b096665d9d356cadb12f16767d64945ee6e8",
  "commit": "[DO NOT MERGE] Wait for preloading images to complete before inflating notifications\n\n NotificationContentInflater waits on SysUiBg thread for images to load, with a timeout\n of 1000ms.\n\nTest: 1. Build a test app that posts MessagingStyle notifications with a huge image (8k+) set as data Uri.\n 2. SystemUi should not ANR\n 3. adb logcat | grep NotificationInlineImageCache  - shows timeout/cancellation logs\n\nBug: 252766417\nBug: 223859644\n\n(cherry picked from commit 195043f40e46ddcd2fe534a9dac344792d39d91c)\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:b9cd15ad8a2f87893164ad2ab518039bb0b61424)\nMerged-In: I341db60223214cf2282b5c0270e343e1ce95fa01\nChange-Id: I341db60223214cf2282b5c0270e343e1ce95fa01",
  "files": [
   {
    "filename": "NotificationContentInflater.java",
    "diff": "@@ -439,6 +439,7 @@ public class NotificationContentInflater implements NotificationRowContentBinder\n         CancellationSignal cancellationSignal = new CancellationSignal();\n         cancellationSignal.setOnCancelListener(\n                 () -> runningInflations.values().forEach(CancellationSignal::cancel));\n+\n         return cancellationSignal;\n     }\n \n@@ -711,6 +712,7 @@ public class NotificationContentInflater implements NotificationRowContentBinder\n     public static class AsyncInflationTask extends AsyncTask<Void, Void, InflationProgress>\n             implements InflationCallback, InflationTask {\n \n+        private static final long IMG_PRELOAD_TIMEOUT_MS = 1000L;\n         private final NotificationEntry mEntry;\n         private final Context mContext;\n         private final boolean mInflateSynchronously;\n@@ -804,7 +806,7 @@ public class NotificationContentInflater implements NotificationRowContentBinder\n                         recoveredBuilder, mIsLowPriority, mUsesIncreasedHeight,\n                         mUsesIncreasedHeadsUpHeight, packageContext);\n                 InflatedSmartReplyState previousSmartReplyState = mRow.getExistingSmartReplyState();\n-                return inflateSmartReplyViews(\n+                InflationProgress result = inflateSmartReplyViews(\n                         inflationProgress,\n                         mReInflateFlags,\n                         mEntry,\n@@ -812,6 +814,11 @@ public class NotificationContentInflater implements NotificationRowContentBinder\n                         packageContext,\n                         previousSmartReplyState,\n                         mSmartRepliesInflater);\n+\n+                // wait for image resolver to finish preloading\n+                mRow.getImageResolver().waitForPreloadedImages(IMG_PRELOAD_TIMEOUT_MS);\n+\n+                return result;\n             } catch (Exception e) {\n                 mError = e;\n                 return null;\n@@ -846,6 +853,9 @@ public class NotificationContentInflater implements NotificationRowContentBinder\n                 mCallback.handleInflationException(mRow.getEntry(),\n                         new InflationException(\"Couldn't inflate contentViews\" + e));\n             }\n+\n+            // Cancel any image loading tasks, not useful any more\n+            mRow.getImageResolver().cancelRunningTasks();\n         }\n \n         @Override\n@@ -872,6 +882,9 @@ public class NotificationContentInflater implements NotificationRowContentBinder\n             // Notify the resolver that the inflation task has finished,\n             // try to purge unnecessary cached entries.\n             mRow.getImageResolver().purgeCache();\n+\n+            // Cancel any image loading tasks that have not completed at this point\n+            mRow.getImageResolver().cancelRunningTasks();\n         }\n \n         private static class RtlEnabledContext extends ContextWrapper {\n",
    "added_lines": 14,
    "deleted_lines": 1,
    "changed_methods": "NotificationContentInflater::AsyncInflationTask::onAsyncInflationFinished, NotificationContentInflater::AsyncInflationTask::doInBackground, NotificationContentInflater::AsyncInflationTask::handleError, NotificationContentInflater::apply"
   },
   {
    "filename": "NotificationInlineImageCache.java",
    "diff": "@@ -23,8 +23,11 @@ import android.util.Log;\n \n import java.io.IOException;\n import java.util.Set;\n+import java.util.concurrent.CancellationException;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n \n /**\n  * A cache for inline images of image messages.\n@@ -57,12 +60,13 @@ public class NotificationInlineImageCache implements NotificationInlineImageReso\n     }\n \n     @Override\n-    public Drawable get(Uri uri) {\n+    public Drawable get(Uri uri, long timeoutMs) {\n         Drawable result = null;\n         try {\n-            result = mCache.get(uri).get();\n-        } catch (InterruptedException | ExecutionException ex) {\n-            Log.d(TAG, \"get: Failed get image from \" + uri);\n+            result = mCache.get(uri).get(timeoutMs, TimeUnit.MILLISECONDS);\n+        } catch (InterruptedException | ExecutionException\n+                | TimeoutException | CancellationException ex) {\n+            Log.d(TAG, \"get: Failed get image from \" + uri + \" \" + ex);\n         }\n         return result;\n     }\n@@ -73,6 +77,15 @@ public class NotificationInlineImageCache implements NotificationInlineImageReso\n         mCache.entrySet().removeIf(entry -> !wantedSet.contains(entry.getKey()));\n     }\n \n+    @Override\n+    public void cancelRunningTasks() {\n+        mCache.forEach((key, value) -> {\n+            if (value.getStatus() != AsyncTask.Status.FINISHED) {\n+                value.cancel(true);\n+            }\n+        });\n+    }\n+\n     private static class PreloadImageTask extends AsyncTask<Uri, Void, Drawable> {\n         private final NotificationInlineImageResolver mResolver;\n \n@@ -87,7 +100,7 @@ public class NotificationInlineImageCache implements NotificationInlineImageReso\n \n             try {\n                 drawable = mResolver.resolveImage(target);\n-            } catch (IOException | SecurityException ex) {\n+            } catch (Exception ex) {\n                 Log.d(TAG, \"PreloadImageTask: Resolve failed from \" + target, ex);\n             }\n \n",
    "added_lines": 18,
    "deleted_lines": 5,
    "changed_methods": "NotificationInlineImageCache::cancelRunningTasks, NotificationInlineImageCache::PreloadImageTask::doInBackground, NotificationInlineImageCache::get, NotificationInlineImageCache::get"
   },
   {
    "filename": "NotificationInlineImageResolver.java",
    "diff": "@@ -23,6 +23,7 @@ import android.graphics.drawable.Drawable;\n import android.net.Uri;\n import android.os.Bundle;\n import android.os.Parcelable;\n+import android.os.SystemClock;\n import android.util.Log;\n \n import com.android.internal.R;\n@@ -46,6 +47,9 @@ import java.util.Set;\n public class NotificationInlineImageResolver implements ImageResolver {\n     private static final String TAG = NotificationInlineImageResolver.class.getSimpleName();\n \n+    // Timeout for loading images from ImageCache when calling from UI thread\n+    private static final long MAX_UI_THREAD_TIMEOUT_MS = 100L;\n+\n     private final Context mContext;\n     private final ImageCache mImageCache;\n     private Set<Uri> mWantedUriSet;\n@@ -111,30 +115,38 @@ public class NotificationInlineImageResolver implements ImageResolver {\n      * To resolve image from specified uri directly. If the resulting image is larger than the\n      * maximum allowed size, scale it down.\n      * @param uri Uri of the image.\n-     * @return Drawable of the image.\n-     * @throws IOException Throws if failed at resolving the image.\n+     * @return Drawable of the image, or null if unable to load.\n      */\n-    Drawable resolveImage(Uri uri) throws IOException {\n-        return LocalImageResolver.resolveImage(uri, mContext, mMaxImageWidth, mMaxImageHeight);\n+    Drawable resolveImage(Uri uri) {\n+        try {\n+            return LocalImageResolver.resolveImage(uri, mContext, mMaxImageWidth, mMaxImageHeight);\n+        } catch (Exception ex) {\n+            // Catch general Exception because ContentResolver can re-throw arbitrary Exception\n+            // from remote process as a RuntimeException. See: Parcel#readException\n+            Log.d(TAG, \"resolveImage: Can't load image from \" + uri, ex);\n+        }\n+        return null;\n     }\n \n+    /**\n+     * Loads an image from the Uri.\n+     * This method is synchronous and is usually called from the Main thread.\n+     * It will time-out after MAX_UI_THREAD_TIMEOUT_MS.\n+     *\n+     * @param uri Uri of the target image.\n+     * @return drawable of the image, null if loading failed/timeout\n+     */\n     @Override\n     public Drawable loadImage(Uri uri) {\n-        Drawable result = null;\n-        try {\n-            if (hasCache()) {\n-                // if the uri isn't currently cached, try caching it first\n-                if (!mImageCache.hasEntry(uri)) {\n-                    mImageCache.preload((uri));\n-                }\n-                result = mImageCache.get(uri);\n-            } else {\n-                result = resolveImage(uri);\n-            }\n-        } catch (IOException | SecurityException ex) {\n-            Log.d(TAG, \"loadImage: Can't load image from \" + uri, ex);\n+        return hasCache() ? loadImageFromCache(uri, MAX_UI_THREAD_TIMEOUT_MS) : resolveImage(uri);\n+    }\n+\n+    private Drawable loadImageFromCache(Uri uri, long timeoutMs) {\n+        // if the uri isn't currently cached, try caching it first\n+        if (!mImageCache.hasEntry(uri)) {\n+            mImageCache.preload((uri));\n         }\n-        return result;\n+        return mImageCache.get(uri, timeoutMs);\n     }\n \n     /**\n@@ -208,6 +220,30 @@ public class NotificationInlineImageResolver implements ImageResolver {\n         return mWantedUriSet;\n     }\n \n+    /**\n+     * Wait for a maximum timeout for images to finish preloading\n+     * @param timeoutMs total timeout time\n+     */\n+    void waitForPreloadedImages(long timeoutMs) {\n+        if (!hasCache()) {\n+            return;\n+        }\n+        Set<Uri> preloadedUris = getWantedUriSet();\n+        if (preloadedUris != null) {\n+            // Decrement remaining timeout after each image check\n+            long endTimeMs = SystemClock.elapsedRealtime() + timeoutMs;\n+            preloadedUris.forEach(\n+                    uri -> loadImageFromCache(uri, endTimeMs - SystemClock.elapsedRealtime()));\n+        }\n+    }\n+\n+    void cancelRunningTasks() {\n+        if (!hasCache()) {\n+            return;\n+        }\n+        mImageCache.cancelRunningTasks();\n+    }\n+\n     /**\n      * A interface for internal cache implementation of this resolver.\n      */\n@@ -217,7 +253,7 @@ public class NotificationInlineImageResolver implements ImageResolver {\n          * @param uri The uri of the image.\n          * @return Drawable of the image.\n          */\n-        Drawable get(Uri uri);\n+        Drawable get(Uri uri, long timeoutMs);\n \n         /**\n          * Set the image resolver that actually resolves image from specified uri.\n@@ -242,6 +278,11 @@ public class NotificationInlineImageResolver implements ImageResolver {\n          * Purge unnecessary entries in the cache.\n          */\n         void purge();\n+\n+        /**\n+         * Cancel all unfinished image loading tasks\n+         */\n+        void cancelRunningTasks();\n     }\n \n }\n",
    "added_lines": 60,
    "deleted_lines": 19,
    "changed_methods": "NotificationInlineImageResolver::resolveImage, NotificationInlineImageResolver::loadImage, NotificationInlineImageResolver::waitForPreloadedImages, NotificationInlineImageResolver::loadImageFromCache, NotificationInlineImageResolver::cancelRunningTasks"
   }
  ]
 },
 {
  "hash": "b6d4b096665d9d356cadb12f16767d64945ee6e8",
  "commit": "[DO NOT MERGE] Wait for preloading images to complete before inflating notifications\n\n NotificationContentInflater waits on SysUiBg thread for images to load, with a timeout\n of 1000ms.\n\nTest: 1. Build a test app that posts MessagingStyle notifications with a huge image (8k+) set as data Uri.\n 2. SystemUi should not ANR\n 3. adb logcat | grep NotificationInlineImageCache  - shows timeout/cancellation logs\n\nBug: 252766417\nBug: 223859644\n\n(cherry picked from commit 195043f40e46ddcd2fe534a9dac344792d39d91c)\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:b9cd15ad8a2f87893164ad2ab518039bb0b61424)\nMerged-In: I341db60223214cf2282b5c0270e343e1ce95fa01\nChange-Id: I341db60223214cf2282b5c0270e343e1ce95fa01",
  "files": [
   {
    "filename": "NotificationContentInflater.java",
    "diff": "@@ -439,6 +439,7 @@ public class NotificationContentInflater implements NotificationRowContentBinder\n         CancellationSignal cancellationSignal = new CancellationSignal();\n         cancellationSignal.setOnCancelListener(\n                 () -> runningInflations.values().forEach(CancellationSignal::cancel));\n+\n         return cancellationSignal;\n     }\n \n@@ -711,6 +712,7 @@ public class NotificationContentInflater implements NotificationRowContentBinder\n     public static class AsyncInflationTask extends AsyncTask<Void, Void, InflationProgress>\n             implements InflationCallback, InflationTask {\n \n+        private static final long IMG_PRELOAD_TIMEOUT_MS = 1000L;\n         private final NotificationEntry mEntry;\n         private final Context mContext;\n         private final boolean mInflateSynchronously;\n@@ -804,7 +806,7 @@ public class NotificationContentInflater implements NotificationRowContentBinder\n                         recoveredBuilder, mIsLowPriority, mUsesIncreasedHeight,\n                         mUsesIncreasedHeadsUpHeight, packageContext);\n                 InflatedSmartReplyState previousSmartReplyState = mRow.getExistingSmartReplyState();\n-                return inflateSmartReplyViews(\n+                InflationProgress result = inflateSmartReplyViews(\n                         inflationProgress,\n                         mReInflateFlags,\n                         mEntry,\n@@ -812,6 +814,11 @@ public class NotificationContentInflater implements NotificationRowContentBinder\n                         packageContext,\n                         previousSmartReplyState,\n                         mSmartRepliesInflater);\n+\n+                // wait for image resolver to finish preloading\n+                mRow.getImageResolver().waitForPreloadedImages(IMG_PRELOAD_TIMEOUT_MS);\n+\n+                return result;\n             } catch (Exception e) {\n                 mError = e;\n                 return null;\n@@ -846,6 +853,9 @@ public class NotificationContentInflater implements NotificationRowContentBinder\n                 mCallback.handleInflationException(mRow.getEntry(),\n                         new InflationException(\"Couldn't inflate contentViews\" + e));\n             }\n+\n+            // Cancel any image loading tasks, not useful any more\n+            mRow.getImageResolver().cancelRunningTasks();\n         }\n \n         @Override\n@@ -872,6 +882,9 @@ public class NotificationContentInflater implements NotificationRowContentBinder\n             // Notify the resolver that the inflation task has finished,\n             // try to purge unnecessary cached entries.\n             mRow.getImageResolver().purgeCache();\n+\n+            // Cancel any image loading tasks that have not completed at this point\n+            mRow.getImageResolver().cancelRunningTasks();\n         }\n \n         private static class RtlEnabledContext extends ContextWrapper {\n",
    "added_lines": 14,
    "deleted_lines": 1,
    "changed_methods": "NotificationContentInflater::AsyncInflationTask::onAsyncInflationFinished, NotificationContentInflater::AsyncInflationTask::doInBackground, NotificationContentInflater::AsyncInflationTask::handleError, NotificationContentInflater::apply"
   },
   {
    "filename": "NotificationInlineImageCache.java",
    "diff": "@@ -23,8 +23,11 @@ import android.util.Log;\n \n import java.io.IOException;\n import java.util.Set;\n+import java.util.concurrent.CancellationException;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n \n /**\n  * A cache for inline images of image messages.\n@@ -57,12 +60,13 @@ public class NotificationInlineImageCache implements NotificationInlineImageReso\n     }\n \n     @Override\n-    public Drawable get(Uri uri) {\n+    public Drawable get(Uri uri, long timeoutMs) {\n         Drawable result = null;\n         try {\n-            result = mCache.get(uri).get();\n-        } catch (InterruptedException | ExecutionException ex) {\n-            Log.d(TAG, \"get: Failed get image from \" + uri);\n+            result = mCache.get(uri).get(timeoutMs, TimeUnit.MILLISECONDS);\n+        } catch (InterruptedException | ExecutionException\n+                | TimeoutException | CancellationException ex) {\n+            Log.d(TAG, \"get: Failed get image from \" + uri + \" \" + ex);\n         }\n         return result;\n     }\n@@ -73,6 +77,15 @@ public class NotificationInlineImageCache implements NotificationInlineImageReso\n         mCache.entrySet().removeIf(entry -> !wantedSet.contains(entry.getKey()));\n     }\n \n+    @Override\n+    public void cancelRunningTasks() {\n+        mCache.forEach((key, value) -> {\n+            if (value.getStatus() != AsyncTask.Status.FINISHED) {\n+                value.cancel(true);\n+            }\n+        });\n+    }\n+\n     private static class PreloadImageTask extends AsyncTask<Uri, Void, Drawable> {\n         private final NotificationInlineImageResolver mResolver;\n \n@@ -87,7 +100,7 @@ public class NotificationInlineImageCache implements NotificationInlineImageReso\n \n             try {\n                 drawable = mResolver.resolveImage(target);\n-            } catch (IOException | SecurityException ex) {\n+            } catch (Exception ex) {\n                 Log.d(TAG, \"PreloadImageTask: Resolve failed from \" + target, ex);\n             }\n \n",
    "added_lines": 18,
    "deleted_lines": 5,
    "changed_methods": "NotificationInlineImageCache::cancelRunningTasks, NotificationInlineImageCache::PreloadImageTask::doInBackground, NotificationInlineImageCache::get, NotificationInlineImageCache::get"
   },
   {
    "filename": "NotificationInlineImageResolver.java",
    "diff": "@@ -23,6 +23,7 @@ import android.graphics.drawable.Drawable;\n import android.net.Uri;\n import android.os.Bundle;\n import android.os.Parcelable;\n+import android.os.SystemClock;\n import android.util.Log;\n \n import com.android.internal.R;\n@@ -46,6 +47,9 @@ import java.util.Set;\n public class NotificationInlineImageResolver implements ImageResolver {\n     private static final String TAG = NotificationInlineImageResolver.class.getSimpleName();\n \n+    // Timeout for loading images from ImageCache when calling from UI thread\n+    private static final long MAX_UI_THREAD_TIMEOUT_MS = 100L;\n+\n     private final Context mContext;\n     private final ImageCache mImageCache;\n     private Set<Uri> mWantedUriSet;\n@@ -111,30 +115,38 @@ public class NotificationInlineImageResolver implements ImageResolver {\n      * To resolve image from specified uri directly. If the resulting image is larger than the\n      * maximum allowed size, scale it down.\n      * @param uri Uri of the image.\n-     * @return Drawable of the image.\n-     * @throws IOException Throws if failed at resolving the image.\n+     * @return Drawable of the image, or null if unable to load.\n      */\n-    Drawable resolveImage(Uri uri) throws IOException {\n-        return LocalImageResolver.resolveImage(uri, mContext, mMaxImageWidth, mMaxImageHeight);\n+    Drawable resolveImage(Uri uri) {\n+        try {\n+            return LocalImageResolver.resolveImage(uri, mContext, mMaxImageWidth, mMaxImageHeight);\n+        } catch (Exception ex) {\n+            // Catch general Exception because ContentResolver can re-throw arbitrary Exception\n+            // from remote process as a RuntimeException. See: Parcel#readException\n+            Log.d(TAG, \"resolveImage: Can't load image from \" + uri, ex);\n+        }\n+        return null;\n     }\n \n+    /**\n+     * Loads an image from the Uri.\n+     * This method is synchronous and is usually called from the Main thread.\n+     * It will time-out after MAX_UI_THREAD_TIMEOUT_MS.\n+     *\n+     * @param uri Uri of the target image.\n+     * @return drawable of the image, null if loading failed/timeout\n+     */\n     @Override\n     public Drawable loadImage(Uri uri) {\n-        Drawable result = null;\n-        try {\n-            if (hasCache()) {\n-                // if the uri isn't currently cached, try caching it first\n-                if (!mImageCache.hasEntry(uri)) {\n-                    mImageCache.preload((uri));\n-                }\n-                result = mImageCache.get(uri);\n-            } else {\n-                result = resolveImage(uri);\n-            }\n-        } catch (IOException | SecurityException ex) {\n-            Log.d(TAG, \"loadImage: Can't load image from \" + uri, ex);\n+        return hasCache() ? loadImageFromCache(uri, MAX_UI_THREAD_TIMEOUT_MS) : resolveImage(uri);\n+    }\n+\n+    private Drawable loadImageFromCache(Uri uri, long timeoutMs) {\n+        // if the uri isn't currently cached, try caching it first\n+        if (!mImageCache.hasEntry(uri)) {\n+            mImageCache.preload((uri));\n         }\n-        return result;\n+        return mImageCache.get(uri, timeoutMs);\n     }\n \n     /**\n@@ -208,6 +220,30 @@ public class NotificationInlineImageResolver implements ImageResolver {\n         return mWantedUriSet;\n     }\n \n+    /**\n+     * Wait for a maximum timeout for images to finish preloading\n+     * @param timeoutMs total timeout time\n+     */\n+    void waitForPreloadedImages(long timeoutMs) {\n+        if (!hasCache()) {\n+            return;\n+        }\n+        Set<Uri> preloadedUris = getWantedUriSet();\n+        if (preloadedUris != null) {\n+            // Decrement remaining timeout after each image check\n+            long endTimeMs = SystemClock.elapsedRealtime() + timeoutMs;\n+            preloadedUris.forEach(\n+                    uri -> loadImageFromCache(uri, endTimeMs - SystemClock.elapsedRealtime()));\n+        }\n+    }\n+\n+    void cancelRunningTasks() {\n+        if (!hasCache()) {\n+            return;\n+        }\n+        mImageCache.cancelRunningTasks();\n+    }\n+\n     /**\n      * A interface for internal cache implementation of this resolver.\n      */\n@@ -217,7 +253,7 @@ public class NotificationInlineImageResolver implements ImageResolver {\n          * @param uri The uri of the image.\n          * @return Drawable of the image.\n          */\n-        Drawable get(Uri uri);\n+        Drawable get(Uri uri, long timeoutMs);\n \n         /**\n          * Set the image resolver that actually resolves image from specified uri.\n@@ -242,6 +278,11 @@ public class NotificationInlineImageResolver implements ImageResolver {\n          * Purge unnecessary entries in the cache.\n          */\n         void purge();\n+\n+        /**\n+         * Cancel all unfinished image loading tasks\n+         */\n+        void cancelRunningTasks();\n     }\n \n }\n",
    "added_lines": 60,
    "deleted_lines": 19,
    "changed_methods": "NotificationInlineImageResolver::resolveImage, NotificationInlineImageResolver::loadImage, NotificationInlineImageResolver::waitForPreloadedImages, NotificationInlineImageResolver::loadImageFromCache, NotificationInlineImageResolver::cancelRunningTasks"
   }
  ]
 },
 {
  "hash": "9d3642cadf39793a856274d7f4edeb98151366a6",
  "commit": "[DO NOT MERGE] Prevent RemoteViews crashing SystemUi\n\n  Catch canvas drawing exceptions caused  by unsuported image sizes.\n\nTest: 1. Post a custom view notification with a layout\n\tcontaining an ImageView that references a 5k x 5k image\n2. Add an App Widget to the home screen with that has the\n\tlayout mentioned above as preview/initial layout.\n\nBug: 268193777\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:c3db1e4451490ddc7f6033a6ab7d54e71ebda9d8)\nMerged-In: Ib3bda769c499b4069b49c566b1b227f98f707a8a\nChange-Id: Ib3bda769c499b4069b49c566b1b227f98f707a8a\n\nChange-Id: Ibbaa234b663bc8e40d2a0a0f076a8676b6b1bc16",
  "files": [
   {
    "filename": "AppWidgetHostView.java",
    "diff": "@@ -31,6 +31,7 @@ import android.content.pm.LauncherActivityInfo;\n import android.content.pm.LauncherApps;\n import android.content.pm.PackageManager.NameNotFoundException;\n import android.content.res.Resources;\n+import android.graphics.Canvas;\n import android.graphics.Color;\n import android.graphics.PointF;\n import android.graphics.Rect;\n@@ -312,19 +313,26 @@ public class AppWidgetHostView extends FrameLayout {\n             super.onLayout(changed, left, top, right, bottom);\n         } catch (final RuntimeException e) {\n             Log.e(TAG, \"Remote provider threw runtime exception, using error view instead.\", e);\n-            removeViewInLayout(mView);\n-            View child = getErrorView();\n-            prepareView(child);\n-            addViewInLayout(child, 0, child.getLayoutParams());\n-            measureChild(child, MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.EXACTLY),\n-                    MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.EXACTLY));\n-            child.layout(0, 0, child.getMeasuredWidth() + mPaddingLeft + mPaddingRight,\n-                    child.getMeasuredHeight() + mPaddingTop + mPaddingBottom);\n-            mView = child;\n-            mViewMode = VIEW_MODE_ERROR;\n+            handleViewError();\n         }\n     }\n \n+    /**\n+     * Remove bad view and replace with error message view\n+     */\n+    private void handleViewError() {\n+        removeViewInLayout(mView);\n+        View child = getErrorView();\n+        prepareView(child);\n+        addViewInLayout(child, 0, child.getLayoutParams());\n+        measureChild(child, MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.EXACTLY),\n+                MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.EXACTLY));\n+        child.layout(0, 0, child.getMeasuredWidth() + mPaddingLeft + mPaddingRight,\n+                child.getMeasuredHeight() + mPaddingTop + mPaddingBottom);\n+        mView = child;\n+        mViewMode = VIEW_MODE_ERROR;\n+    }\n+\n     /**\n      * Provide guidance about the size of this widget to the AppWidgetManager. The widths and\n      * heights should correspond to the full area the AppWidgetHostView is given. Padding added by\n@@ -940,4 +948,15 @@ public class AppWidgetHostView extends FrameLayout {\n             reapplyLastRemoteViews();\n         }\n     }\n+\n+    @Override\n+    protected void dispatchDraw(@NonNull Canvas canvas) {\n+        try {\n+            super.dispatchDraw(canvas);\n+        } catch (Exception e) {\n+            // Catch draw exceptions that may be caused by RemoteViews\n+            Log.e(TAG, \"Drawing view failed: \" + e);\n+            post(this::handleViewError);\n+        }\n+    }\n }\n",
    "added_lines": 29,
    "deleted_lines": 10,
    "changed_methods": "AppWidgetHostView::dispatchDraw, AppWidgetHostView::handleViewError, AppWidgetHostView::onLayout"
   },
   {
    "filename": "ExpandableNotificationRow.java",
    "diff": "@@ -70,6 +70,7 @@ import android.widget.ImageView;\n import com.android.internal.annotations.VisibleForTesting;\n import com.android.internal.logging.MetricsLogger;\n import com.android.internal.logging.nano.MetricsProto.MetricsEvent;\n+import com.android.internal.statusbar.IStatusBarService;\n import com.android.internal.util.ContrastColorUtil;\n import com.android.internal.widget.CachingIconView;\n import com.android.internal.widget.CallLayout;\n@@ -1568,7 +1569,8 @@ public class ExpandableNotificationRow extends ActivatableNotificationView\n             PeopleNotificationIdentifier peopleNotificationIdentifier,\n             OnUserInteractionCallback onUserInteractionCallback,\n             Optional<BubblesManager> bubblesManagerOptional,\n-            NotificationGutsManager gutsManager) {\n+            NotificationGutsManager gutsManager,\n+            IStatusBarService statusBarService) {\n         mEntry = entry;\n         mAppName = appName;\n         if (mMenuRow == null) {\n",
    "added_lines": 3,
    "deleted_lines": 1,
    "changed_methods": "ExpandableNotificationRow::initialize, ExpandableNotificationRow::initialize"
   },
   {
    "filename": "ExpandableNotificationRowController.java",
    "diff": "@@ -25,6 +25,7 @@ import android.view.ViewGroup;\n \n import androidx.annotation.NonNull;\n \n+import com.android.internal.statusbar.IStatusBarService;\n import com.android.systemui.R;\n import com.android.systemui.classifier.FalsingCollector;\n import com.android.systemui.plugins.FalsingManager;\n@@ -85,6 +86,7 @@ public class ExpandableNotificationRowController implements NodeController {\n     private final boolean mAllowLongPress;\n     private final PeopleNotificationIdentifier mPeopleNotificationIdentifier;\n     private final Optional<BubblesManager> mBubblesManagerOptional;\n+    private final IStatusBarService mStatusBarService;\n \n     private final ExpandableNotificationRowDragController mDragController;\n \n@@ -113,7 +115,8 @@ public class ExpandableNotificationRowController implements NodeController {\n             FalsingCollector falsingCollector,\n             PeopleNotificationIdentifier peopleNotificationIdentifier,\n             Optional<BubblesManager> bubblesManagerOptional,\n-            ExpandableNotificationRowDragController dragController) {\n+            ExpandableNotificationRowDragController dragController,\n+            IStatusBarService statusBarService) {\n         mView = view;\n         mListContainer = listContainer;\n         mActivatableNotificationViewController = activatableNotificationViewController;\n@@ -139,6 +142,7 @@ public class ExpandableNotificationRowController implements NodeController {\n         mPeopleNotificationIdentifier = peopleNotificationIdentifier;\n         mBubblesManagerOptional = bubblesManagerOptional;\n         mDragController = dragController;\n+        mStatusBarService = statusBarService;\n     }\n \n     /**\n@@ -165,7 +169,8 @@ public class ExpandableNotificationRowController implements NodeController {\n                 mPeopleNotificationIdentifier,\n                 mOnUserInteractionCallback,\n                 mBubblesManagerOptional,\n-                mNotificationGutsManager\n+                mNotificationGutsManager,\n+                mStatusBarService\n         );\n         mView.setDescendantFocusability(ViewGroup.FOCUS_BLOCK_DESCENDANTS);\n         if (mAllowLongPress) {\n",
    "added_lines": 7,
    "deleted_lines": 2,
    "changed_methods": "ExpandableNotificationRowController::init, ExpandableNotificationRowController::ExpandableNotificationRowController, ExpandableNotificationRowController::ExpandableNotificationRowController"
   },
   {
    "filename": "NotificationContentView.java",
    "diff": "@@ -21,10 +21,13 @@ import android.annotation.Nullable;\n import android.app.Notification;\n import android.app.PendingIntent;\n import android.content.Context;\n+import android.graphics.Canvas;\n import android.graphics.Rect;\n import android.graphics.drawable.Drawable;\n import android.os.Build;\n+import android.os.RemoteException;\n import android.provider.Settings;\n+import android.service.notification.StatusBarNotification;\n import android.util.ArrayMap;\n import android.util.AttributeSet;\n import android.util.IndentingPrintWriter;\n@@ -41,6 +44,7 @@ import android.widget.LinearLayout;\n \n import com.android.internal.annotations.VisibleForTesting;\n import com.android.systemui.Dependency;\n+import com.android.internal.statusbar.IStatusBarService;\n import com.android.systemui.R;\n import com.android.systemui.plugins.statusbar.NotificationMenuRowPlugin;\n import com.android.systemui.statusbar.RemoteInputController;\n@@ -127,6 +131,8 @@ public class NotificationContentView extends FrameLayout implements Notification\n     private RemoteInputController mRemoteInputController;\n     private Runnable mExpandedVisibleListener;\n     private PeopleNotificationIdentifier mPeopleIdentifier;\n+    private IStatusBarService mStatusBarService;\n+\n     /**\n      * List of listeners for when content views become inactive (i.e. not the showing view).\n      */\n@@ -180,6 +186,7 @@ public class NotificationContentView extends FrameLayout implements Notification\n         mHybridGroupManager = new HybridGroupManager(getContext());\n         mSmartReplyConstants = Dependency.get(SmartReplyConstants.class);\n         mSmartReplyController = Dependency.get(SmartReplyController.class);\n+        mStatusBarService = Dependency.get(IStatusBarService.class);\n         initView();\n     }\n \n@@ -2030,4 +2037,36 @@ public class NotificationContentView extends FrameLayout implements Notification\n         }\n         return false;\n     }\n+\n+    @Override\n+    protected void dispatchDraw(Canvas canvas) {\n+        try {\n+            super.dispatchDraw(canvas);\n+        } catch (Exception e) {\n+            // Catch draw exceptions that may be caused by RemoteViews\n+            Log.e(TAG, \"Drawing view failed: \" + e);\n+            cancelNotification(e);\n+        }\n+    }\n+\n+    private void cancelNotification(Exception exception) {\n+        try {\n+            setVisibility(GONE);\n+            final StatusBarNotification sbn = mNotificationEntry.getSbn();\n+            if (mStatusBarService != null) {\n+                // report notification inflation errors back up\n+                // to notification delegates\n+                mStatusBarService.onNotificationError(\n+                        sbn.getPackageName(),\n+                        sbn.getTag(),\n+                        sbn.getId(),\n+                        sbn.getUid(),\n+                        sbn.getInitialPid(),\n+                        exception.getMessage(),\n+                        sbn.getUser().getIdentifier());\n+            }\n+        } catch (RemoteException ex) {\n+            Log.e(TAG, \"cancelNotification failed: \" + ex);\n+        }\n+    }\n }\n",
    "added_lines": 39,
    "deleted_lines": 0,
    "changed_methods": "NotificationContentView::cancelNotification, NotificationContentView::NotificationContentView, NotificationContentView::dispatchDraw"
   },
   {
    "filename": "NotificationEntryManagerInflationTest.java",
    "diff": "@@ -271,7 +271,8 @@ public class NotificationEntryManagerInflationTest extends SysuiTestCase {\n                                 new FalsingCollectorFake(),\n                                 mPeopleNotificationIdentifier,\n                                 Optional.of(mock(BubblesManager.class)),\n-                                mock(ExpandableNotificationRowDragController.class)\n+                                mock(ExpandableNotificationRowDragController.class),\n+                                mock(IStatusBarService.class)\n                         ));\n \n         when(mNotificationRowComponentBuilder.activatableNotificationView(any()))\n",
    "added_lines": 2,
    "deleted_lines": 1,
    "changed_methods": "NotificationEntryManagerInflationTest::setUp"
   },
   {
    "filename": "NotificationTestHelper.java",
    "diff": "@@ -43,6 +43,7 @@ import android.text.TextUtils;\n import android.view.LayoutInflater;\n import android.widget.RemoteViews;\n \n+import com.android.internal.statusbar.IStatusBarService;\n import com.android.systemui.TestableDependency;\n import com.android.systemui.classifier.FalsingCollectorFake;\n import com.android.systemui.classifier.FalsingManagerFake;\n@@ -490,7 +491,8 @@ public class NotificationTestHelper {\n                 mPeopleNotificationIdentifier,\n                 mock(OnUserInteractionCallback.class),\n                 Optional.of(mock(BubblesManager.class)),\n-                mock(NotificationGutsManager.class));\n+                mock(NotificationGutsManager.class),\n+                mock(IStatusBarService.class));\n \n         row.setAboveShelfChangedListener(aboveShelf -> { });\n         mBindStage.getStageParams(entry).requireContentViews(extraInflationFlags);\n",
    "added_lines": 3,
    "deleted_lines": 1,
    "changed_methods": "NotificationTestHelper::generateRow"
   }
  ]
 },
 {
  "hash": "9d3642cadf39793a856274d7f4edeb98151366a6",
  "commit": "[DO NOT MERGE] Prevent RemoteViews crashing SystemUi\n\n  Catch canvas drawing exceptions caused  by unsuported image sizes.\n\nTest: 1. Post a custom view notification with a layout\n\tcontaining an ImageView that references a 5k x 5k image\n2. Add an App Widget to the home screen with that has the\n\tlayout mentioned above as preview/initial layout.\n\nBug: 268193777\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:c3db1e4451490ddc7f6033a6ab7d54e71ebda9d8)\nMerged-In: Ib3bda769c499b4069b49c566b1b227f98f707a8a\nChange-Id: Ib3bda769c499b4069b49c566b1b227f98f707a8a\n\nChange-Id: Ibbaa234b663bc8e40d2a0a0f076a8676b6b1bc16",
  "files": [
   {
    "filename": "AppWidgetHostView.java",
    "diff": "@@ -31,6 +31,7 @@ import android.content.pm.LauncherActivityInfo;\n import android.content.pm.LauncherApps;\n import android.content.pm.PackageManager.NameNotFoundException;\n import android.content.res.Resources;\n+import android.graphics.Canvas;\n import android.graphics.Color;\n import android.graphics.PointF;\n import android.graphics.Rect;\n@@ -312,19 +313,26 @@ public class AppWidgetHostView extends FrameLayout {\n             super.onLayout(changed, left, top, right, bottom);\n         } catch (final RuntimeException e) {\n             Log.e(TAG, \"Remote provider threw runtime exception, using error view instead.\", e);\n-            removeViewInLayout(mView);\n-            View child = getErrorView();\n-            prepareView(child);\n-            addViewInLayout(child, 0, child.getLayoutParams());\n-            measureChild(child, MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.EXACTLY),\n-                    MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.EXACTLY));\n-            child.layout(0, 0, child.getMeasuredWidth() + mPaddingLeft + mPaddingRight,\n-                    child.getMeasuredHeight() + mPaddingTop + mPaddingBottom);\n-            mView = child;\n-            mViewMode = VIEW_MODE_ERROR;\n+            handleViewError();\n         }\n     }\n \n+    /**\n+     * Remove bad view and replace with error message view\n+     */\n+    private void handleViewError() {\n+        removeViewInLayout(mView);\n+        View child = getErrorView();\n+        prepareView(child);\n+        addViewInLayout(child, 0, child.getLayoutParams());\n+        measureChild(child, MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.EXACTLY),\n+                MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.EXACTLY));\n+        child.layout(0, 0, child.getMeasuredWidth() + mPaddingLeft + mPaddingRight,\n+                child.getMeasuredHeight() + mPaddingTop + mPaddingBottom);\n+        mView = child;\n+        mViewMode = VIEW_MODE_ERROR;\n+    }\n+\n     /**\n      * Provide guidance about the size of this widget to the AppWidgetManager. The widths and\n      * heights should correspond to the full area the AppWidgetHostView is given. Padding added by\n@@ -940,4 +948,15 @@ public class AppWidgetHostView extends FrameLayout {\n             reapplyLastRemoteViews();\n         }\n     }\n+\n+    @Override\n+    protected void dispatchDraw(@NonNull Canvas canvas) {\n+        try {\n+            super.dispatchDraw(canvas);\n+        } catch (Exception e) {\n+            // Catch draw exceptions that may be caused by RemoteViews\n+            Log.e(TAG, \"Drawing view failed: \" + e);\n+            post(this::handleViewError);\n+        }\n+    }\n }\n",
    "added_lines": 29,
    "deleted_lines": 10,
    "changed_methods": "AppWidgetHostView::dispatchDraw, AppWidgetHostView::handleViewError, AppWidgetHostView::onLayout"
   },
   {
    "filename": "ExpandableNotificationRow.java",
    "diff": "@@ -70,6 +70,7 @@ import android.widget.ImageView;\n import com.android.internal.annotations.VisibleForTesting;\n import com.android.internal.logging.MetricsLogger;\n import com.android.internal.logging.nano.MetricsProto.MetricsEvent;\n+import com.android.internal.statusbar.IStatusBarService;\n import com.android.internal.util.ContrastColorUtil;\n import com.android.internal.widget.CachingIconView;\n import com.android.internal.widget.CallLayout;\n@@ -1568,7 +1569,8 @@ public class ExpandableNotificationRow extends ActivatableNotificationView\n             PeopleNotificationIdentifier peopleNotificationIdentifier,\n             OnUserInteractionCallback onUserInteractionCallback,\n             Optional<BubblesManager> bubblesManagerOptional,\n-            NotificationGutsManager gutsManager) {\n+            NotificationGutsManager gutsManager,\n+            IStatusBarService statusBarService) {\n         mEntry = entry;\n         mAppName = appName;\n         if (mMenuRow == null) {\n",
    "added_lines": 3,
    "deleted_lines": 1,
    "changed_methods": "ExpandableNotificationRow::initialize, ExpandableNotificationRow::initialize"
   },
   {
    "filename": "ExpandableNotificationRowController.java",
    "diff": "@@ -25,6 +25,7 @@ import android.view.ViewGroup;\n \n import androidx.annotation.NonNull;\n \n+import com.android.internal.statusbar.IStatusBarService;\n import com.android.systemui.R;\n import com.android.systemui.classifier.FalsingCollector;\n import com.android.systemui.plugins.FalsingManager;\n@@ -85,6 +86,7 @@ public class ExpandableNotificationRowController implements NodeController {\n     private final boolean mAllowLongPress;\n     private final PeopleNotificationIdentifier mPeopleNotificationIdentifier;\n     private final Optional<BubblesManager> mBubblesManagerOptional;\n+    private final IStatusBarService mStatusBarService;\n \n     private final ExpandableNotificationRowDragController mDragController;\n \n@@ -113,7 +115,8 @@ public class ExpandableNotificationRowController implements NodeController {\n             FalsingCollector falsingCollector,\n             PeopleNotificationIdentifier peopleNotificationIdentifier,\n             Optional<BubblesManager> bubblesManagerOptional,\n-            ExpandableNotificationRowDragController dragController) {\n+            ExpandableNotificationRowDragController dragController,\n+            IStatusBarService statusBarService) {\n         mView = view;\n         mListContainer = listContainer;\n         mActivatableNotificationViewController = activatableNotificationViewController;\n@@ -139,6 +142,7 @@ public class ExpandableNotificationRowController implements NodeController {\n         mPeopleNotificationIdentifier = peopleNotificationIdentifier;\n         mBubblesManagerOptional = bubblesManagerOptional;\n         mDragController = dragController;\n+        mStatusBarService = statusBarService;\n     }\n \n     /**\n@@ -165,7 +169,8 @@ public class ExpandableNotificationRowController implements NodeController {\n                 mPeopleNotificationIdentifier,\n                 mOnUserInteractionCallback,\n                 mBubblesManagerOptional,\n-                mNotificationGutsManager\n+                mNotificationGutsManager,\n+                mStatusBarService\n         );\n         mView.setDescendantFocusability(ViewGroup.FOCUS_BLOCK_DESCENDANTS);\n         if (mAllowLongPress) {\n",
    "added_lines": 7,
    "deleted_lines": 2,
    "changed_methods": "ExpandableNotificationRowController::init, ExpandableNotificationRowController::ExpandableNotificationRowController, ExpandableNotificationRowController::ExpandableNotificationRowController"
   },
   {
    "filename": "NotificationContentView.java",
    "diff": "@@ -21,10 +21,13 @@ import android.annotation.Nullable;\n import android.app.Notification;\n import android.app.PendingIntent;\n import android.content.Context;\n+import android.graphics.Canvas;\n import android.graphics.Rect;\n import android.graphics.drawable.Drawable;\n import android.os.Build;\n+import android.os.RemoteException;\n import android.provider.Settings;\n+import android.service.notification.StatusBarNotification;\n import android.util.ArrayMap;\n import android.util.AttributeSet;\n import android.util.IndentingPrintWriter;\n@@ -41,6 +44,7 @@ import android.widget.LinearLayout;\n \n import com.android.internal.annotations.VisibleForTesting;\n import com.android.systemui.Dependency;\n+import com.android.internal.statusbar.IStatusBarService;\n import com.android.systemui.R;\n import com.android.systemui.plugins.statusbar.NotificationMenuRowPlugin;\n import com.android.systemui.statusbar.RemoteInputController;\n@@ -127,6 +131,8 @@ public class NotificationContentView extends FrameLayout implements Notification\n     private RemoteInputController mRemoteInputController;\n     private Runnable mExpandedVisibleListener;\n     private PeopleNotificationIdentifier mPeopleIdentifier;\n+    private IStatusBarService mStatusBarService;\n+\n     /**\n      * List of listeners for when content views become inactive (i.e. not the showing view).\n      */\n@@ -180,6 +186,7 @@ public class NotificationContentView extends FrameLayout implements Notification\n         mHybridGroupManager = new HybridGroupManager(getContext());\n         mSmartReplyConstants = Dependency.get(SmartReplyConstants.class);\n         mSmartReplyController = Dependency.get(SmartReplyController.class);\n+        mStatusBarService = Dependency.get(IStatusBarService.class);\n         initView();\n     }\n \n@@ -2030,4 +2037,36 @@ public class NotificationContentView extends FrameLayout implements Notification\n         }\n         return false;\n     }\n+\n+    @Override\n+    protected void dispatchDraw(Canvas canvas) {\n+        try {\n+            super.dispatchDraw(canvas);\n+        } catch (Exception e) {\n+            // Catch draw exceptions that may be caused by RemoteViews\n+            Log.e(TAG, \"Drawing view failed: \" + e);\n+            cancelNotification(e);\n+        }\n+    }\n+\n+    private void cancelNotification(Exception exception) {\n+        try {\n+            setVisibility(GONE);\n+            final StatusBarNotification sbn = mNotificationEntry.getSbn();\n+            if (mStatusBarService != null) {\n+                // report notification inflation errors back up\n+                // to notification delegates\n+                mStatusBarService.onNotificationError(\n+                        sbn.getPackageName(),\n+                        sbn.getTag(),\n+                        sbn.getId(),\n+                        sbn.getUid(),\n+                        sbn.getInitialPid(),\n+                        exception.getMessage(),\n+                        sbn.getUser().getIdentifier());\n+            }\n+        } catch (RemoteException ex) {\n+            Log.e(TAG, \"cancelNotification failed: \" + ex);\n+        }\n+    }\n }\n",
    "added_lines": 39,
    "deleted_lines": 0,
    "changed_methods": "NotificationContentView::cancelNotification, NotificationContentView::NotificationContentView, NotificationContentView::dispatchDraw"
   },
   {
    "filename": "NotificationEntryManagerInflationTest.java",
    "diff": "@@ -271,7 +271,8 @@ public class NotificationEntryManagerInflationTest extends SysuiTestCase {\n                                 new FalsingCollectorFake(),\n                                 mPeopleNotificationIdentifier,\n                                 Optional.of(mock(BubblesManager.class)),\n-                                mock(ExpandableNotificationRowDragController.class)\n+                                mock(ExpandableNotificationRowDragController.class),\n+                                mock(IStatusBarService.class)\n                         ));\n \n         when(mNotificationRowComponentBuilder.activatableNotificationView(any()))\n",
    "added_lines": 2,
    "deleted_lines": 1,
    "changed_methods": "NotificationEntryManagerInflationTest::setUp"
   },
   {
    "filename": "NotificationTestHelper.java",
    "diff": "@@ -43,6 +43,7 @@ import android.text.TextUtils;\n import android.view.LayoutInflater;\n import android.widget.RemoteViews;\n \n+import com.android.internal.statusbar.IStatusBarService;\n import com.android.systemui.TestableDependency;\n import com.android.systemui.classifier.FalsingCollectorFake;\n import com.android.systemui.classifier.FalsingManagerFake;\n@@ -490,7 +491,8 @@ public class NotificationTestHelper {\n                 mPeopleNotificationIdentifier,\n                 mock(OnUserInteractionCallback.class),\n                 Optional.of(mock(BubblesManager.class)),\n-                mock(NotificationGutsManager.class));\n+                mock(NotificationGutsManager.class),\n+                mock(IStatusBarService.class));\n \n         row.setAboveShelfChangedListener(aboveShelf -> { });\n         mBindStage.getStageParams(entry).requireContentViews(extraInflationFlags);\n",
    "added_lines": 3,
    "deleted_lines": 1,
    "changed_methods": "NotificationTestHelper::generateRow"
   }
  ]
 },
 {
  "hash": "9d3642cadf39793a856274d7f4edeb98151366a6",
  "commit": "[DO NOT MERGE] Prevent RemoteViews crashing SystemUi\n\n  Catch canvas drawing exceptions caused  by unsuported image sizes.\n\nTest: 1. Post a custom view notification with a layout\n\tcontaining an ImageView that references a 5k x 5k image\n2. Add an App Widget to the home screen with that has the\n\tlayout mentioned above as preview/initial layout.\n\nBug: 268193777\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:c3db1e4451490ddc7f6033a6ab7d54e71ebda9d8)\nMerged-In: Ib3bda769c499b4069b49c566b1b227f98f707a8a\nChange-Id: Ib3bda769c499b4069b49c566b1b227f98f707a8a\n\nChange-Id: Ibbaa234b663bc8e40d2a0a0f076a8676b6b1bc16",
  "files": [
   {
    "filename": "AppWidgetHostView.java",
    "diff": "@@ -31,6 +31,7 @@ import android.content.pm.LauncherActivityInfo;\n import android.content.pm.LauncherApps;\n import android.content.pm.PackageManager.NameNotFoundException;\n import android.content.res.Resources;\n+import android.graphics.Canvas;\n import android.graphics.Color;\n import android.graphics.PointF;\n import android.graphics.Rect;\n@@ -312,19 +313,26 @@ public class AppWidgetHostView extends FrameLayout {\n             super.onLayout(changed, left, top, right, bottom);\n         } catch (final RuntimeException e) {\n             Log.e(TAG, \"Remote provider threw runtime exception, using error view instead.\", e);\n-            removeViewInLayout(mView);\n-            View child = getErrorView();\n-            prepareView(child);\n-            addViewInLayout(child, 0, child.getLayoutParams());\n-            measureChild(child, MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.EXACTLY),\n-                    MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.EXACTLY));\n-            child.layout(0, 0, child.getMeasuredWidth() + mPaddingLeft + mPaddingRight,\n-                    child.getMeasuredHeight() + mPaddingTop + mPaddingBottom);\n-            mView = child;\n-            mViewMode = VIEW_MODE_ERROR;\n+            handleViewError();\n         }\n     }\n \n+    /**\n+     * Remove bad view and replace with error message view\n+     */\n+    private void handleViewError() {\n+        removeViewInLayout(mView);\n+        View child = getErrorView();\n+        prepareView(child);\n+        addViewInLayout(child, 0, child.getLayoutParams());\n+        measureChild(child, MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.EXACTLY),\n+                MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.EXACTLY));\n+        child.layout(0, 0, child.getMeasuredWidth() + mPaddingLeft + mPaddingRight,\n+                child.getMeasuredHeight() + mPaddingTop + mPaddingBottom);\n+        mView = child;\n+        mViewMode = VIEW_MODE_ERROR;\n+    }\n+\n     /**\n      * Provide guidance about the size of this widget to the AppWidgetManager. The widths and\n      * heights should correspond to the full area the AppWidgetHostView is given. Padding added by\n@@ -940,4 +948,15 @@ public class AppWidgetHostView extends FrameLayout {\n             reapplyLastRemoteViews();\n         }\n     }\n+\n+    @Override\n+    protected void dispatchDraw(@NonNull Canvas canvas) {\n+        try {\n+            super.dispatchDraw(canvas);\n+        } catch (Exception e) {\n+            // Catch draw exceptions that may be caused by RemoteViews\n+            Log.e(TAG, \"Drawing view failed: \" + e);\n+            post(this::handleViewError);\n+        }\n+    }\n }\n",
    "added_lines": 29,
    "deleted_lines": 10,
    "changed_methods": "AppWidgetHostView::dispatchDraw, AppWidgetHostView::handleViewError, AppWidgetHostView::onLayout"
   },
   {
    "filename": "ExpandableNotificationRow.java",
    "diff": "@@ -70,6 +70,7 @@ import android.widget.ImageView;\n import com.android.internal.annotations.VisibleForTesting;\n import com.android.internal.logging.MetricsLogger;\n import com.android.internal.logging.nano.MetricsProto.MetricsEvent;\n+import com.android.internal.statusbar.IStatusBarService;\n import com.android.internal.util.ContrastColorUtil;\n import com.android.internal.widget.CachingIconView;\n import com.android.internal.widget.CallLayout;\n@@ -1568,7 +1569,8 @@ public class ExpandableNotificationRow extends ActivatableNotificationView\n             PeopleNotificationIdentifier peopleNotificationIdentifier,\n             OnUserInteractionCallback onUserInteractionCallback,\n             Optional<BubblesManager> bubblesManagerOptional,\n-            NotificationGutsManager gutsManager) {\n+            NotificationGutsManager gutsManager,\n+            IStatusBarService statusBarService) {\n         mEntry = entry;\n         mAppName = appName;\n         if (mMenuRow == null) {\n",
    "added_lines": 3,
    "deleted_lines": 1,
    "changed_methods": "ExpandableNotificationRow::initialize, ExpandableNotificationRow::initialize"
   },
   {
    "filename": "ExpandableNotificationRowController.java",
    "diff": "@@ -25,6 +25,7 @@ import android.view.ViewGroup;\n \n import androidx.annotation.NonNull;\n \n+import com.android.internal.statusbar.IStatusBarService;\n import com.android.systemui.R;\n import com.android.systemui.classifier.FalsingCollector;\n import com.android.systemui.plugins.FalsingManager;\n@@ -85,6 +86,7 @@ public class ExpandableNotificationRowController implements NodeController {\n     private final boolean mAllowLongPress;\n     private final PeopleNotificationIdentifier mPeopleNotificationIdentifier;\n     private final Optional<BubblesManager> mBubblesManagerOptional;\n+    private final IStatusBarService mStatusBarService;\n \n     private final ExpandableNotificationRowDragController mDragController;\n \n@@ -113,7 +115,8 @@ public class ExpandableNotificationRowController implements NodeController {\n             FalsingCollector falsingCollector,\n             PeopleNotificationIdentifier peopleNotificationIdentifier,\n             Optional<BubblesManager> bubblesManagerOptional,\n-            ExpandableNotificationRowDragController dragController) {\n+            ExpandableNotificationRowDragController dragController,\n+            IStatusBarService statusBarService) {\n         mView = view;\n         mListContainer = listContainer;\n         mActivatableNotificationViewController = activatableNotificationViewController;\n@@ -139,6 +142,7 @@ public class ExpandableNotificationRowController implements NodeController {\n         mPeopleNotificationIdentifier = peopleNotificationIdentifier;\n         mBubblesManagerOptional = bubblesManagerOptional;\n         mDragController = dragController;\n+        mStatusBarService = statusBarService;\n     }\n \n     /**\n@@ -165,7 +169,8 @@ public class ExpandableNotificationRowController implements NodeController {\n                 mPeopleNotificationIdentifier,\n                 mOnUserInteractionCallback,\n                 mBubblesManagerOptional,\n-                mNotificationGutsManager\n+                mNotificationGutsManager,\n+                mStatusBarService\n         );\n         mView.setDescendantFocusability(ViewGroup.FOCUS_BLOCK_DESCENDANTS);\n         if (mAllowLongPress) {\n",
    "added_lines": 7,
    "deleted_lines": 2,
    "changed_methods": "ExpandableNotificationRowController::init, ExpandableNotificationRowController::ExpandableNotificationRowController, ExpandableNotificationRowController::ExpandableNotificationRowController"
   },
   {
    "filename": "NotificationContentView.java",
    "diff": "@@ -21,10 +21,13 @@ import android.annotation.Nullable;\n import android.app.Notification;\n import android.app.PendingIntent;\n import android.content.Context;\n+import android.graphics.Canvas;\n import android.graphics.Rect;\n import android.graphics.drawable.Drawable;\n import android.os.Build;\n+import android.os.RemoteException;\n import android.provider.Settings;\n+import android.service.notification.StatusBarNotification;\n import android.util.ArrayMap;\n import android.util.AttributeSet;\n import android.util.IndentingPrintWriter;\n@@ -41,6 +44,7 @@ import android.widget.LinearLayout;\n \n import com.android.internal.annotations.VisibleForTesting;\n import com.android.systemui.Dependency;\n+import com.android.internal.statusbar.IStatusBarService;\n import com.android.systemui.R;\n import com.android.systemui.plugins.statusbar.NotificationMenuRowPlugin;\n import com.android.systemui.statusbar.RemoteInputController;\n@@ -127,6 +131,8 @@ public class NotificationContentView extends FrameLayout implements Notification\n     private RemoteInputController mRemoteInputController;\n     private Runnable mExpandedVisibleListener;\n     private PeopleNotificationIdentifier mPeopleIdentifier;\n+    private IStatusBarService mStatusBarService;\n+\n     /**\n      * List of listeners for when content views become inactive (i.e. not the showing view).\n      */\n@@ -180,6 +186,7 @@ public class NotificationContentView extends FrameLayout implements Notification\n         mHybridGroupManager = new HybridGroupManager(getContext());\n         mSmartReplyConstants = Dependency.get(SmartReplyConstants.class);\n         mSmartReplyController = Dependency.get(SmartReplyController.class);\n+        mStatusBarService = Dependency.get(IStatusBarService.class);\n         initView();\n     }\n \n@@ -2030,4 +2037,36 @@ public class NotificationContentView extends FrameLayout implements Notification\n         }\n         return false;\n     }\n+\n+    @Override\n+    protected void dispatchDraw(Canvas canvas) {\n+        try {\n+            super.dispatchDraw(canvas);\n+        } catch (Exception e) {\n+            // Catch draw exceptions that may be caused by RemoteViews\n+            Log.e(TAG, \"Drawing view failed: \" + e);\n+            cancelNotification(e);\n+        }\n+    }\n+\n+    private void cancelNotification(Exception exception) {\n+        try {\n+            setVisibility(GONE);\n+            final StatusBarNotification sbn = mNotificationEntry.getSbn();\n+            if (mStatusBarService != null) {\n+                // report notification inflation errors back up\n+                // to notification delegates\n+                mStatusBarService.onNotificationError(\n+                        sbn.getPackageName(),\n+                        sbn.getTag(),\n+                        sbn.getId(),\n+                        sbn.getUid(),\n+                        sbn.getInitialPid(),\n+                        exception.getMessage(),\n+                        sbn.getUser().getIdentifier());\n+            }\n+        } catch (RemoteException ex) {\n+            Log.e(TAG, \"cancelNotification failed: \" + ex);\n+        }\n+    }\n }\n",
    "added_lines": 39,
    "deleted_lines": 0,
    "changed_methods": "NotificationContentView::cancelNotification, NotificationContentView::NotificationContentView, NotificationContentView::dispatchDraw"
   },
   {
    "filename": "NotificationEntryManagerInflationTest.java",
    "diff": "@@ -271,7 +271,8 @@ public class NotificationEntryManagerInflationTest extends SysuiTestCase {\n                                 new FalsingCollectorFake(),\n                                 mPeopleNotificationIdentifier,\n                                 Optional.of(mock(BubblesManager.class)),\n-                                mock(ExpandableNotificationRowDragController.class)\n+                                mock(ExpandableNotificationRowDragController.class),\n+                                mock(IStatusBarService.class)\n                         ));\n \n         when(mNotificationRowComponentBuilder.activatableNotificationView(any()))\n",
    "added_lines": 2,
    "deleted_lines": 1,
    "changed_methods": "NotificationEntryManagerInflationTest::setUp"
   },
   {
    "filename": "NotificationTestHelper.java",
    "diff": "@@ -43,6 +43,7 @@ import android.text.TextUtils;\n import android.view.LayoutInflater;\n import android.widget.RemoteViews;\n \n+import com.android.internal.statusbar.IStatusBarService;\n import com.android.systemui.TestableDependency;\n import com.android.systemui.classifier.FalsingCollectorFake;\n import com.android.systemui.classifier.FalsingManagerFake;\n@@ -490,7 +491,8 @@ public class NotificationTestHelper {\n                 mPeopleNotificationIdentifier,\n                 mock(OnUserInteractionCallback.class),\n                 Optional.of(mock(BubblesManager.class)),\n-                mock(NotificationGutsManager.class));\n+                mock(NotificationGutsManager.class),\n+                mock(IStatusBarService.class));\n \n         row.setAboveShelfChangedListener(aboveShelf -> { });\n         mBindStage.getStageParams(entry).requireContentViews(extraInflationFlags);\n",
    "added_lines": 3,
    "deleted_lines": 1,
    "changed_methods": "NotificationTestHelper::generateRow"
   }
  ]
 },
 {
  "hash": "9d3642cadf39793a856274d7f4edeb98151366a6",
  "commit": "[DO NOT MERGE] Prevent RemoteViews crashing SystemUi\n\n  Catch canvas drawing exceptions caused  by unsuported image sizes.\n\nTest: 1. Post a custom view notification with a layout\n\tcontaining an ImageView that references a 5k x 5k image\n2. Add an App Widget to the home screen with that has the\n\tlayout mentioned above as preview/initial layout.\n\nBug: 268193777\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:c3db1e4451490ddc7f6033a6ab7d54e71ebda9d8)\nMerged-In: Ib3bda769c499b4069b49c566b1b227f98f707a8a\nChange-Id: Ib3bda769c499b4069b49c566b1b227f98f707a8a\n\nChange-Id: Ibbaa234b663bc8e40d2a0a0f076a8676b6b1bc16",
  "files": [
   {
    "filename": "AppWidgetHostView.java",
    "diff": "@@ -31,6 +31,7 @@ import android.content.pm.LauncherActivityInfo;\n import android.content.pm.LauncherApps;\n import android.content.pm.PackageManager.NameNotFoundException;\n import android.content.res.Resources;\n+import android.graphics.Canvas;\n import android.graphics.Color;\n import android.graphics.PointF;\n import android.graphics.Rect;\n@@ -312,19 +313,26 @@ public class AppWidgetHostView extends FrameLayout {\n             super.onLayout(changed, left, top, right, bottom);\n         } catch (final RuntimeException e) {\n             Log.e(TAG, \"Remote provider threw runtime exception, using error view instead.\", e);\n-            removeViewInLayout(mView);\n-            View child = getErrorView();\n-            prepareView(child);\n-            addViewInLayout(child, 0, child.getLayoutParams());\n-            measureChild(child, MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.EXACTLY),\n-                    MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.EXACTLY));\n-            child.layout(0, 0, child.getMeasuredWidth() + mPaddingLeft + mPaddingRight,\n-                    child.getMeasuredHeight() + mPaddingTop + mPaddingBottom);\n-            mView = child;\n-            mViewMode = VIEW_MODE_ERROR;\n+            handleViewError();\n         }\n     }\n \n+    /**\n+     * Remove bad view and replace with error message view\n+     */\n+    private void handleViewError() {\n+        removeViewInLayout(mView);\n+        View child = getErrorView();\n+        prepareView(child);\n+        addViewInLayout(child, 0, child.getLayoutParams());\n+        measureChild(child, MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.EXACTLY),\n+                MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.EXACTLY));\n+        child.layout(0, 0, child.getMeasuredWidth() + mPaddingLeft + mPaddingRight,\n+                child.getMeasuredHeight() + mPaddingTop + mPaddingBottom);\n+        mView = child;\n+        mViewMode = VIEW_MODE_ERROR;\n+    }\n+\n     /**\n      * Provide guidance about the size of this widget to the AppWidgetManager. The widths and\n      * heights should correspond to the full area the AppWidgetHostView is given. Padding added by\n@@ -940,4 +948,15 @@ public class AppWidgetHostView extends FrameLayout {\n             reapplyLastRemoteViews();\n         }\n     }\n+\n+    @Override\n+    protected void dispatchDraw(@NonNull Canvas canvas) {\n+        try {\n+            super.dispatchDraw(canvas);\n+        } catch (Exception e) {\n+            // Catch draw exceptions that may be caused by RemoteViews\n+            Log.e(TAG, \"Drawing view failed: \" + e);\n+            post(this::handleViewError);\n+        }\n+    }\n }\n",
    "added_lines": 29,
    "deleted_lines": 10,
    "changed_methods": "AppWidgetHostView::dispatchDraw, AppWidgetHostView::handleViewError, AppWidgetHostView::onLayout"
   },
   {
    "filename": "ExpandableNotificationRow.java",
    "diff": "@@ -70,6 +70,7 @@ import android.widget.ImageView;\n import com.android.internal.annotations.VisibleForTesting;\n import com.android.internal.logging.MetricsLogger;\n import com.android.internal.logging.nano.MetricsProto.MetricsEvent;\n+import com.android.internal.statusbar.IStatusBarService;\n import com.android.internal.util.ContrastColorUtil;\n import com.android.internal.widget.CachingIconView;\n import com.android.internal.widget.CallLayout;\n@@ -1568,7 +1569,8 @@ public class ExpandableNotificationRow extends ActivatableNotificationView\n             PeopleNotificationIdentifier peopleNotificationIdentifier,\n             OnUserInteractionCallback onUserInteractionCallback,\n             Optional<BubblesManager> bubblesManagerOptional,\n-            NotificationGutsManager gutsManager) {\n+            NotificationGutsManager gutsManager,\n+            IStatusBarService statusBarService) {\n         mEntry = entry;\n         mAppName = appName;\n         if (mMenuRow == null) {\n",
    "added_lines": 3,
    "deleted_lines": 1,
    "changed_methods": "ExpandableNotificationRow::initialize, ExpandableNotificationRow::initialize"
   },
   {
    "filename": "ExpandableNotificationRowController.java",
    "diff": "@@ -25,6 +25,7 @@ import android.view.ViewGroup;\n \n import androidx.annotation.NonNull;\n \n+import com.android.internal.statusbar.IStatusBarService;\n import com.android.systemui.R;\n import com.android.systemui.classifier.FalsingCollector;\n import com.android.systemui.plugins.FalsingManager;\n@@ -85,6 +86,7 @@ public class ExpandableNotificationRowController implements NodeController {\n     private final boolean mAllowLongPress;\n     private final PeopleNotificationIdentifier mPeopleNotificationIdentifier;\n     private final Optional<BubblesManager> mBubblesManagerOptional;\n+    private final IStatusBarService mStatusBarService;\n \n     private final ExpandableNotificationRowDragController mDragController;\n \n@@ -113,7 +115,8 @@ public class ExpandableNotificationRowController implements NodeController {\n             FalsingCollector falsingCollector,\n             PeopleNotificationIdentifier peopleNotificationIdentifier,\n             Optional<BubblesManager> bubblesManagerOptional,\n-            ExpandableNotificationRowDragController dragController) {\n+            ExpandableNotificationRowDragController dragController,\n+            IStatusBarService statusBarService) {\n         mView = view;\n         mListContainer = listContainer;\n         mActivatableNotificationViewController = activatableNotificationViewController;\n@@ -139,6 +142,7 @@ public class ExpandableNotificationRowController implements NodeController {\n         mPeopleNotificationIdentifier = peopleNotificationIdentifier;\n         mBubblesManagerOptional = bubblesManagerOptional;\n         mDragController = dragController;\n+        mStatusBarService = statusBarService;\n     }\n \n     /**\n@@ -165,7 +169,8 @@ public class ExpandableNotificationRowController implements NodeController {\n                 mPeopleNotificationIdentifier,\n                 mOnUserInteractionCallback,\n                 mBubblesManagerOptional,\n-                mNotificationGutsManager\n+                mNotificationGutsManager,\n+                mStatusBarService\n         );\n         mView.setDescendantFocusability(ViewGroup.FOCUS_BLOCK_DESCENDANTS);\n         if (mAllowLongPress) {\n",
    "added_lines": 7,
    "deleted_lines": 2,
    "changed_methods": "ExpandableNotificationRowController::init, ExpandableNotificationRowController::ExpandableNotificationRowController, ExpandableNotificationRowController::ExpandableNotificationRowController"
   },
   {
    "filename": "NotificationContentView.java",
    "diff": "@@ -21,10 +21,13 @@ import android.annotation.Nullable;\n import android.app.Notification;\n import android.app.PendingIntent;\n import android.content.Context;\n+import android.graphics.Canvas;\n import android.graphics.Rect;\n import android.graphics.drawable.Drawable;\n import android.os.Build;\n+import android.os.RemoteException;\n import android.provider.Settings;\n+import android.service.notification.StatusBarNotification;\n import android.util.ArrayMap;\n import android.util.AttributeSet;\n import android.util.IndentingPrintWriter;\n@@ -41,6 +44,7 @@ import android.widget.LinearLayout;\n \n import com.android.internal.annotations.VisibleForTesting;\n import com.android.systemui.Dependency;\n+import com.android.internal.statusbar.IStatusBarService;\n import com.android.systemui.R;\n import com.android.systemui.plugins.statusbar.NotificationMenuRowPlugin;\n import com.android.systemui.statusbar.RemoteInputController;\n@@ -127,6 +131,8 @@ public class NotificationContentView extends FrameLayout implements Notification\n     private RemoteInputController mRemoteInputController;\n     private Runnable mExpandedVisibleListener;\n     private PeopleNotificationIdentifier mPeopleIdentifier;\n+    private IStatusBarService mStatusBarService;\n+\n     /**\n      * List of listeners for when content views become inactive (i.e. not the showing view).\n      */\n@@ -180,6 +186,7 @@ public class NotificationContentView extends FrameLayout implements Notification\n         mHybridGroupManager = new HybridGroupManager(getContext());\n         mSmartReplyConstants = Dependency.get(SmartReplyConstants.class);\n         mSmartReplyController = Dependency.get(SmartReplyController.class);\n+        mStatusBarService = Dependency.get(IStatusBarService.class);\n         initView();\n     }\n \n@@ -2030,4 +2037,36 @@ public class NotificationContentView extends FrameLayout implements Notification\n         }\n         return false;\n     }\n+\n+    @Override\n+    protected void dispatchDraw(Canvas canvas) {\n+        try {\n+            super.dispatchDraw(canvas);\n+        } catch (Exception e) {\n+            // Catch draw exceptions that may be caused by RemoteViews\n+            Log.e(TAG, \"Drawing view failed: \" + e);\n+            cancelNotification(e);\n+        }\n+    }\n+\n+    private void cancelNotification(Exception exception) {\n+        try {\n+            setVisibility(GONE);\n+            final StatusBarNotification sbn = mNotificationEntry.getSbn();\n+            if (mStatusBarService != null) {\n+                // report notification inflation errors back up\n+                // to notification delegates\n+                mStatusBarService.onNotificationError(\n+                        sbn.getPackageName(),\n+                        sbn.getTag(),\n+                        sbn.getId(),\n+                        sbn.getUid(),\n+                        sbn.getInitialPid(),\n+                        exception.getMessage(),\n+                        sbn.getUser().getIdentifier());\n+            }\n+        } catch (RemoteException ex) {\n+            Log.e(TAG, \"cancelNotification failed: \" + ex);\n+        }\n+    }\n }\n",
    "added_lines": 39,
    "deleted_lines": 0,
    "changed_methods": "NotificationContentView::cancelNotification, NotificationContentView::NotificationContentView, NotificationContentView::dispatchDraw"
   },
   {
    "filename": "NotificationEntryManagerInflationTest.java",
    "diff": "@@ -271,7 +271,8 @@ public class NotificationEntryManagerInflationTest extends SysuiTestCase {\n                                 new FalsingCollectorFake(),\n                                 mPeopleNotificationIdentifier,\n                                 Optional.of(mock(BubblesManager.class)),\n-                                mock(ExpandableNotificationRowDragController.class)\n+                                mock(ExpandableNotificationRowDragController.class),\n+                                mock(IStatusBarService.class)\n                         ));\n \n         when(mNotificationRowComponentBuilder.activatableNotificationView(any()))\n",
    "added_lines": 2,
    "deleted_lines": 1,
    "changed_methods": "NotificationEntryManagerInflationTest::setUp"
   },
   {
    "filename": "NotificationTestHelper.java",
    "diff": "@@ -43,6 +43,7 @@ import android.text.TextUtils;\n import android.view.LayoutInflater;\n import android.widget.RemoteViews;\n \n+import com.android.internal.statusbar.IStatusBarService;\n import com.android.systemui.TestableDependency;\n import com.android.systemui.classifier.FalsingCollectorFake;\n import com.android.systemui.classifier.FalsingManagerFake;\n@@ -490,7 +491,8 @@ public class NotificationTestHelper {\n                 mPeopleNotificationIdentifier,\n                 mock(OnUserInteractionCallback.class),\n                 Optional.of(mock(BubblesManager.class)),\n-                mock(NotificationGutsManager.class));\n+                mock(NotificationGutsManager.class),\n+                mock(IStatusBarService.class));\n \n         row.setAboveShelfChangedListener(aboveShelf -> { });\n         mBindStage.getStageParams(entry).requireContentViews(extraInflationFlags);\n",
    "added_lines": 3,
    "deleted_lines": 1,
    "changed_methods": "NotificationTestHelper::generateRow"
   }
  ]
 },
 {
  "hash": "9d3642cadf39793a856274d7f4edeb98151366a6",
  "commit": "[DO NOT MERGE] Prevent RemoteViews crashing SystemUi\n\n  Catch canvas drawing exceptions caused  by unsuported image sizes.\n\nTest: 1. Post a custom view notification with a layout\n\tcontaining an ImageView that references a 5k x 5k image\n2. Add an App Widget to the home screen with that has the\n\tlayout mentioned above as preview/initial layout.\n\nBug: 268193777\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:c3db1e4451490ddc7f6033a6ab7d54e71ebda9d8)\nMerged-In: Ib3bda769c499b4069b49c566b1b227f98f707a8a\nChange-Id: Ib3bda769c499b4069b49c566b1b227f98f707a8a\n\nChange-Id: Ibbaa234b663bc8e40d2a0a0f076a8676b6b1bc16",
  "files": [
   {
    "filename": "AppWidgetHostView.java",
    "diff": "@@ -31,6 +31,7 @@ import android.content.pm.LauncherActivityInfo;\n import android.content.pm.LauncherApps;\n import android.content.pm.PackageManager.NameNotFoundException;\n import android.content.res.Resources;\n+import android.graphics.Canvas;\n import android.graphics.Color;\n import android.graphics.PointF;\n import android.graphics.Rect;\n@@ -312,19 +313,26 @@ public class AppWidgetHostView extends FrameLayout {\n             super.onLayout(changed, left, top, right, bottom);\n         } catch (final RuntimeException e) {\n             Log.e(TAG, \"Remote provider threw runtime exception, using error view instead.\", e);\n-            removeViewInLayout(mView);\n-            View child = getErrorView();\n-            prepareView(child);\n-            addViewInLayout(child, 0, child.getLayoutParams());\n-            measureChild(child, MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.EXACTLY),\n-                    MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.EXACTLY));\n-            child.layout(0, 0, child.getMeasuredWidth() + mPaddingLeft + mPaddingRight,\n-                    child.getMeasuredHeight() + mPaddingTop + mPaddingBottom);\n-            mView = child;\n-            mViewMode = VIEW_MODE_ERROR;\n+            handleViewError();\n         }\n     }\n \n+    /**\n+     * Remove bad view and replace with error message view\n+     */\n+    private void handleViewError() {\n+        removeViewInLayout(mView);\n+        View child = getErrorView();\n+        prepareView(child);\n+        addViewInLayout(child, 0, child.getLayoutParams());\n+        measureChild(child, MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.EXACTLY),\n+                MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.EXACTLY));\n+        child.layout(0, 0, child.getMeasuredWidth() + mPaddingLeft + mPaddingRight,\n+                child.getMeasuredHeight() + mPaddingTop + mPaddingBottom);\n+        mView = child;\n+        mViewMode = VIEW_MODE_ERROR;\n+    }\n+\n     /**\n      * Provide guidance about the size of this widget to the AppWidgetManager. The widths and\n      * heights should correspond to the full area the AppWidgetHostView is given. Padding added by\n@@ -940,4 +948,15 @@ public class AppWidgetHostView extends FrameLayout {\n             reapplyLastRemoteViews();\n         }\n     }\n+\n+    @Override\n+    protected void dispatchDraw(@NonNull Canvas canvas) {\n+        try {\n+            super.dispatchDraw(canvas);\n+        } catch (Exception e) {\n+            // Catch draw exceptions that may be caused by RemoteViews\n+            Log.e(TAG, \"Drawing view failed: \" + e);\n+            post(this::handleViewError);\n+        }\n+    }\n }\n",
    "added_lines": 29,
    "deleted_lines": 10,
    "changed_methods": "AppWidgetHostView::dispatchDraw, AppWidgetHostView::handleViewError, AppWidgetHostView::onLayout"
   },
   {
    "filename": "ExpandableNotificationRow.java",
    "diff": "@@ -70,6 +70,7 @@ import android.widget.ImageView;\n import com.android.internal.annotations.VisibleForTesting;\n import com.android.internal.logging.MetricsLogger;\n import com.android.internal.logging.nano.MetricsProto.MetricsEvent;\n+import com.android.internal.statusbar.IStatusBarService;\n import com.android.internal.util.ContrastColorUtil;\n import com.android.internal.widget.CachingIconView;\n import com.android.internal.widget.CallLayout;\n@@ -1568,7 +1569,8 @@ public class ExpandableNotificationRow extends ActivatableNotificationView\n             PeopleNotificationIdentifier peopleNotificationIdentifier,\n             OnUserInteractionCallback onUserInteractionCallback,\n             Optional<BubblesManager> bubblesManagerOptional,\n-            NotificationGutsManager gutsManager) {\n+            NotificationGutsManager gutsManager,\n+            IStatusBarService statusBarService) {\n         mEntry = entry;\n         mAppName = appName;\n         if (mMenuRow == null) {\n",
    "added_lines": 3,
    "deleted_lines": 1,
    "changed_methods": "ExpandableNotificationRow::initialize, ExpandableNotificationRow::initialize"
   },
   {
    "filename": "ExpandableNotificationRowController.java",
    "diff": "@@ -25,6 +25,7 @@ import android.view.ViewGroup;\n \n import androidx.annotation.NonNull;\n \n+import com.android.internal.statusbar.IStatusBarService;\n import com.android.systemui.R;\n import com.android.systemui.classifier.FalsingCollector;\n import com.android.systemui.plugins.FalsingManager;\n@@ -85,6 +86,7 @@ public class ExpandableNotificationRowController implements NodeController {\n     private final boolean mAllowLongPress;\n     private final PeopleNotificationIdentifier mPeopleNotificationIdentifier;\n     private final Optional<BubblesManager> mBubblesManagerOptional;\n+    private final IStatusBarService mStatusBarService;\n \n     private final ExpandableNotificationRowDragController mDragController;\n \n@@ -113,7 +115,8 @@ public class ExpandableNotificationRowController implements NodeController {\n             FalsingCollector falsingCollector,\n             PeopleNotificationIdentifier peopleNotificationIdentifier,\n             Optional<BubblesManager> bubblesManagerOptional,\n-            ExpandableNotificationRowDragController dragController) {\n+            ExpandableNotificationRowDragController dragController,\n+            IStatusBarService statusBarService) {\n         mView = view;\n         mListContainer = listContainer;\n         mActivatableNotificationViewController = activatableNotificationViewController;\n@@ -139,6 +142,7 @@ public class ExpandableNotificationRowController implements NodeController {\n         mPeopleNotificationIdentifier = peopleNotificationIdentifier;\n         mBubblesManagerOptional = bubblesManagerOptional;\n         mDragController = dragController;\n+        mStatusBarService = statusBarService;\n     }\n \n     /**\n@@ -165,7 +169,8 @@ public class ExpandableNotificationRowController implements NodeController {\n                 mPeopleNotificationIdentifier,\n                 mOnUserInteractionCallback,\n                 mBubblesManagerOptional,\n-                mNotificationGutsManager\n+                mNotificationGutsManager,\n+                mStatusBarService\n         );\n         mView.setDescendantFocusability(ViewGroup.FOCUS_BLOCK_DESCENDANTS);\n         if (mAllowLongPress) {\n",
    "added_lines": 7,
    "deleted_lines": 2,
    "changed_methods": "ExpandableNotificationRowController::init, ExpandableNotificationRowController::ExpandableNotificationRowController, ExpandableNotificationRowController::ExpandableNotificationRowController"
   },
   {
    "filename": "NotificationContentView.java",
    "diff": "@@ -21,10 +21,13 @@ import android.annotation.Nullable;\n import android.app.Notification;\n import android.app.PendingIntent;\n import android.content.Context;\n+import android.graphics.Canvas;\n import android.graphics.Rect;\n import android.graphics.drawable.Drawable;\n import android.os.Build;\n+import android.os.RemoteException;\n import android.provider.Settings;\n+import android.service.notification.StatusBarNotification;\n import android.util.ArrayMap;\n import android.util.AttributeSet;\n import android.util.IndentingPrintWriter;\n@@ -41,6 +44,7 @@ import android.widget.LinearLayout;\n \n import com.android.internal.annotations.VisibleForTesting;\n import com.android.systemui.Dependency;\n+import com.android.internal.statusbar.IStatusBarService;\n import com.android.systemui.R;\n import com.android.systemui.plugins.statusbar.NotificationMenuRowPlugin;\n import com.android.systemui.statusbar.RemoteInputController;\n@@ -127,6 +131,8 @@ public class NotificationContentView extends FrameLayout implements Notification\n     private RemoteInputController mRemoteInputController;\n     private Runnable mExpandedVisibleListener;\n     private PeopleNotificationIdentifier mPeopleIdentifier;\n+    private IStatusBarService mStatusBarService;\n+\n     /**\n      * List of listeners for when content views become inactive (i.e. not the showing view).\n      */\n@@ -180,6 +186,7 @@ public class NotificationContentView extends FrameLayout implements Notification\n         mHybridGroupManager = new HybridGroupManager(getContext());\n         mSmartReplyConstants = Dependency.get(SmartReplyConstants.class);\n         mSmartReplyController = Dependency.get(SmartReplyController.class);\n+        mStatusBarService = Dependency.get(IStatusBarService.class);\n         initView();\n     }\n \n@@ -2030,4 +2037,36 @@ public class NotificationContentView extends FrameLayout implements Notification\n         }\n         return false;\n     }\n+\n+    @Override\n+    protected void dispatchDraw(Canvas canvas) {\n+        try {\n+            super.dispatchDraw(canvas);\n+        } catch (Exception e) {\n+            // Catch draw exceptions that may be caused by RemoteViews\n+            Log.e(TAG, \"Drawing view failed: \" + e);\n+            cancelNotification(e);\n+        }\n+    }\n+\n+    private void cancelNotification(Exception exception) {\n+        try {\n+            setVisibility(GONE);\n+            final StatusBarNotification sbn = mNotificationEntry.getSbn();\n+            if (mStatusBarService != null) {\n+                // report notification inflation errors back up\n+                // to notification delegates\n+                mStatusBarService.onNotificationError(\n+                        sbn.getPackageName(),\n+                        sbn.getTag(),\n+                        sbn.getId(),\n+                        sbn.getUid(),\n+                        sbn.getInitialPid(),\n+                        exception.getMessage(),\n+                        sbn.getUser().getIdentifier());\n+            }\n+        } catch (RemoteException ex) {\n+            Log.e(TAG, \"cancelNotification failed: \" + ex);\n+        }\n+    }\n }\n",
    "added_lines": 39,
    "deleted_lines": 0,
    "changed_methods": "NotificationContentView::cancelNotification, NotificationContentView::NotificationContentView, NotificationContentView::dispatchDraw"
   },
   {
    "filename": "NotificationEntryManagerInflationTest.java",
    "diff": "@@ -271,7 +271,8 @@ public class NotificationEntryManagerInflationTest extends SysuiTestCase {\n                                 new FalsingCollectorFake(),\n                                 mPeopleNotificationIdentifier,\n                                 Optional.of(mock(BubblesManager.class)),\n-                                mock(ExpandableNotificationRowDragController.class)\n+                                mock(ExpandableNotificationRowDragController.class),\n+                                mock(IStatusBarService.class)\n                         ));\n \n         when(mNotificationRowComponentBuilder.activatableNotificationView(any()))\n",
    "added_lines": 2,
    "deleted_lines": 1,
    "changed_methods": "NotificationEntryManagerInflationTest::setUp"
   },
   {
    "filename": "NotificationTestHelper.java",
    "diff": "@@ -43,6 +43,7 @@ import android.text.TextUtils;\n import android.view.LayoutInflater;\n import android.widget.RemoteViews;\n \n+import com.android.internal.statusbar.IStatusBarService;\n import com.android.systemui.TestableDependency;\n import com.android.systemui.classifier.FalsingCollectorFake;\n import com.android.systemui.classifier.FalsingManagerFake;\n@@ -490,7 +491,8 @@ public class NotificationTestHelper {\n                 mPeopleNotificationIdentifier,\n                 mock(OnUserInteractionCallback.class),\n                 Optional.of(mock(BubblesManager.class)),\n-                mock(NotificationGutsManager.class));\n+                mock(NotificationGutsManager.class),\n+                mock(IStatusBarService.class));\n \n         row.setAboveShelfChangedListener(aboveShelf -> { });\n         mBindStage.getStageParams(entry).requireContentViews(extraInflationFlags);\n",
    "added_lines": 3,
    "deleted_lines": 1,
    "changed_methods": "NotificationTestHelper::generateRow"
   }
  ]
 },
 {
  "hash": "9d3642cadf39793a856274d7f4edeb98151366a6",
  "commit": "[DO NOT MERGE] Prevent RemoteViews crashing SystemUi\n\n  Catch canvas drawing exceptions caused  by unsuported image sizes.\n\nTest: 1. Post a custom view notification with a layout\n\tcontaining an ImageView that references a 5k x 5k image\n2. Add an App Widget to the home screen with that has the\n\tlayout mentioned above as preview/initial layout.\n\nBug: 268193777\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:c3db1e4451490ddc7f6033a6ab7d54e71ebda9d8)\nMerged-In: Ib3bda769c499b4069b49c566b1b227f98f707a8a\nChange-Id: Ib3bda769c499b4069b49c566b1b227f98f707a8a\n\nChange-Id: Ibbaa234b663bc8e40d2a0a0f076a8676b6b1bc16",
  "files": [
   {
    "filename": "AppWidgetHostView.java",
    "diff": "@@ -31,6 +31,7 @@ import android.content.pm.LauncherActivityInfo;\n import android.content.pm.LauncherApps;\n import android.content.pm.PackageManager.NameNotFoundException;\n import android.content.res.Resources;\n+import android.graphics.Canvas;\n import android.graphics.Color;\n import android.graphics.PointF;\n import android.graphics.Rect;\n@@ -312,19 +313,26 @@ public class AppWidgetHostView extends FrameLayout {\n             super.onLayout(changed, left, top, right, bottom);\n         } catch (final RuntimeException e) {\n             Log.e(TAG, \"Remote provider threw runtime exception, using error view instead.\", e);\n-            removeViewInLayout(mView);\n-            View child = getErrorView();\n-            prepareView(child);\n-            addViewInLayout(child, 0, child.getLayoutParams());\n-            measureChild(child, MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.EXACTLY),\n-                    MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.EXACTLY));\n-            child.layout(0, 0, child.getMeasuredWidth() + mPaddingLeft + mPaddingRight,\n-                    child.getMeasuredHeight() + mPaddingTop + mPaddingBottom);\n-            mView = child;\n-            mViewMode = VIEW_MODE_ERROR;\n+            handleViewError();\n         }\n     }\n \n+    /**\n+     * Remove bad view and replace with error message view\n+     */\n+    private void handleViewError() {\n+        removeViewInLayout(mView);\n+        View child = getErrorView();\n+        prepareView(child);\n+        addViewInLayout(child, 0, child.getLayoutParams());\n+        measureChild(child, MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.EXACTLY),\n+                MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.EXACTLY));\n+        child.layout(0, 0, child.getMeasuredWidth() + mPaddingLeft + mPaddingRight,\n+                child.getMeasuredHeight() + mPaddingTop + mPaddingBottom);\n+        mView = child;\n+        mViewMode = VIEW_MODE_ERROR;\n+    }\n+\n     /**\n      * Provide guidance about the size of this widget to the AppWidgetManager. The widths and\n      * heights should correspond to the full area the AppWidgetHostView is given. Padding added by\n@@ -940,4 +948,15 @@ public class AppWidgetHostView extends FrameLayout {\n             reapplyLastRemoteViews();\n         }\n     }\n+\n+    @Override\n+    protected void dispatchDraw(@NonNull Canvas canvas) {\n+        try {\n+            super.dispatchDraw(canvas);\n+        } catch (Exception e) {\n+            // Catch draw exceptions that may be caused by RemoteViews\n+            Log.e(TAG, \"Drawing view failed: \" + e);\n+            post(this::handleViewError);\n+        }\n+    }\n }\n",
    "added_lines": 29,
    "deleted_lines": 10,
    "changed_methods": "AppWidgetHostView::dispatchDraw, AppWidgetHostView::handleViewError, AppWidgetHostView::onLayout"
   },
   {
    "filename": "ExpandableNotificationRow.java",
    "diff": "@@ -70,6 +70,7 @@ import android.widget.ImageView;\n import com.android.internal.annotations.VisibleForTesting;\n import com.android.internal.logging.MetricsLogger;\n import com.android.internal.logging.nano.MetricsProto.MetricsEvent;\n+import com.android.internal.statusbar.IStatusBarService;\n import com.android.internal.util.ContrastColorUtil;\n import com.android.internal.widget.CachingIconView;\n import com.android.internal.widget.CallLayout;\n@@ -1568,7 +1569,8 @@ public class ExpandableNotificationRow extends ActivatableNotificationView\n             PeopleNotificationIdentifier peopleNotificationIdentifier,\n             OnUserInteractionCallback onUserInteractionCallback,\n             Optional<BubblesManager> bubblesManagerOptional,\n-            NotificationGutsManager gutsManager) {\n+            NotificationGutsManager gutsManager,\n+            IStatusBarService statusBarService) {\n         mEntry = entry;\n         mAppName = appName;\n         if (mMenuRow == null) {\n",
    "added_lines": 3,
    "deleted_lines": 1,
    "changed_methods": "ExpandableNotificationRow::initialize, ExpandableNotificationRow::initialize"
   },
   {
    "filename": "ExpandableNotificationRowController.java",
    "diff": "@@ -25,6 +25,7 @@ import android.view.ViewGroup;\n \n import androidx.annotation.NonNull;\n \n+import com.android.internal.statusbar.IStatusBarService;\n import com.android.systemui.R;\n import com.android.systemui.classifier.FalsingCollector;\n import com.android.systemui.plugins.FalsingManager;\n@@ -85,6 +86,7 @@ public class ExpandableNotificationRowController implements NodeController {\n     private final boolean mAllowLongPress;\n     private final PeopleNotificationIdentifier mPeopleNotificationIdentifier;\n     private final Optional<BubblesManager> mBubblesManagerOptional;\n+    private final IStatusBarService mStatusBarService;\n \n     private final ExpandableNotificationRowDragController mDragController;\n \n@@ -113,7 +115,8 @@ public class ExpandableNotificationRowController implements NodeController {\n             FalsingCollector falsingCollector,\n             PeopleNotificationIdentifier peopleNotificationIdentifier,\n             Optional<BubblesManager> bubblesManagerOptional,\n-            ExpandableNotificationRowDragController dragController) {\n+            ExpandableNotificationRowDragController dragController,\n+            IStatusBarService statusBarService) {\n         mView = view;\n         mListContainer = listContainer;\n         mActivatableNotificationViewController = activatableNotificationViewController;\n@@ -139,6 +142,7 @@ public class ExpandableNotificationRowController implements NodeController {\n         mPeopleNotificationIdentifier = peopleNotificationIdentifier;\n         mBubblesManagerOptional = bubblesManagerOptional;\n         mDragController = dragController;\n+        mStatusBarService = statusBarService;\n     }\n \n     /**\n@@ -165,7 +169,8 @@ public class ExpandableNotificationRowController implements NodeController {\n                 mPeopleNotificationIdentifier,\n                 mOnUserInteractionCallback,\n                 mBubblesManagerOptional,\n-                mNotificationGutsManager\n+                mNotificationGutsManager,\n+                mStatusBarService\n         );\n         mView.setDescendantFocusability(ViewGroup.FOCUS_BLOCK_DESCENDANTS);\n         if (mAllowLongPress) {\n",
    "added_lines": 7,
    "deleted_lines": 2,
    "changed_methods": "ExpandableNotificationRowController::init, ExpandableNotificationRowController::ExpandableNotificationRowController, ExpandableNotificationRowController::ExpandableNotificationRowController"
   },
   {
    "filename": "NotificationContentView.java",
    "diff": "@@ -21,10 +21,13 @@ import android.annotation.Nullable;\n import android.app.Notification;\n import android.app.PendingIntent;\n import android.content.Context;\n+import android.graphics.Canvas;\n import android.graphics.Rect;\n import android.graphics.drawable.Drawable;\n import android.os.Build;\n+import android.os.RemoteException;\n import android.provider.Settings;\n+import android.service.notification.StatusBarNotification;\n import android.util.ArrayMap;\n import android.util.AttributeSet;\n import android.util.IndentingPrintWriter;\n@@ -41,6 +44,7 @@ import android.widget.LinearLayout;\n \n import com.android.internal.annotations.VisibleForTesting;\n import com.android.systemui.Dependency;\n+import com.android.internal.statusbar.IStatusBarService;\n import com.android.systemui.R;\n import com.android.systemui.plugins.statusbar.NotificationMenuRowPlugin;\n import com.android.systemui.statusbar.RemoteInputController;\n@@ -127,6 +131,8 @@ public class NotificationContentView extends FrameLayout implements Notification\n     private RemoteInputController mRemoteInputController;\n     private Runnable mExpandedVisibleListener;\n     private PeopleNotificationIdentifier mPeopleIdentifier;\n+    private IStatusBarService mStatusBarService;\n+\n     /**\n      * List of listeners for when content views become inactive (i.e. not the showing view).\n      */\n@@ -180,6 +186,7 @@ public class NotificationContentView extends FrameLayout implements Notification\n         mHybridGroupManager = new HybridGroupManager(getContext());\n         mSmartReplyConstants = Dependency.get(SmartReplyConstants.class);\n         mSmartReplyController = Dependency.get(SmartReplyController.class);\n+        mStatusBarService = Dependency.get(IStatusBarService.class);\n         initView();\n     }\n \n@@ -2030,4 +2037,36 @@ public class NotificationContentView extends FrameLayout implements Notification\n         }\n         return false;\n     }\n+\n+    @Override\n+    protected void dispatchDraw(Canvas canvas) {\n+        try {\n+            super.dispatchDraw(canvas);\n+        } catch (Exception e) {\n+            // Catch draw exceptions that may be caused by RemoteViews\n+            Log.e(TAG, \"Drawing view failed: \" + e);\n+            cancelNotification(e);\n+        }\n+    }\n+\n+    private void cancelNotification(Exception exception) {\n+        try {\n+            setVisibility(GONE);\n+            final StatusBarNotification sbn = mNotificationEntry.getSbn();\n+            if (mStatusBarService != null) {\n+                // report notification inflation errors back up\n+                // to notification delegates\n+                mStatusBarService.onNotificationError(\n+                        sbn.getPackageName(),\n+                        sbn.getTag(),\n+                        sbn.getId(),\n+                        sbn.getUid(),\n+                        sbn.getInitialPid(),\n+                        exception.getMessage(),\n+                        sbn.getUser().getIdentifier());\n+            }\n+        } catch (RemoteException ex) {\n+            Log.e(TAG, \"cancelNotification failed: \" + ex);\n+        }\n+    }\n }\n",
    "added_lines": 39,
    "deleted_lines": 0,
    "changed_methods": "NotificationContentView::cancelNotification, NotificationContentView::NotificationContentView, NotificationContentView::dispatchDraw"
   },
   {
    "filename": "NotificationEntryManagerInflationTest.java",
    "diff": "@@ -271,7 +271,8 @@ public class NotificationEntryManagerInflationTest extends SysuiTestCase {\n                                 new FalsingCollectorFake(),\n                                 mPeopleNotificationIdentifier,\n                                 Optional.of(mock(BubblesManager.class)),\n-                                mock(ExpandableNotificationRowDragController.class)\n+                                mock(ExpandableNotificationRowDragController.class),\n+                                mock(IStatusBarService.class)\n                         ));\n \n         when(mNotificationRowComponentBuilder.activatableNotificationView(any()))\n",
    "added_lines": 2,
    "deleted_lines": 1,
    "changed_methods": "NotificationEntryManagerInflationTest::setUp"
   },
   {
    "filename": "NotificationTestHelper.java",
    "diff": "@@ -43,6 +43,7 @@ import android.text.TextUtils;\n import android.view.LayoutInflater;\n import android.widget.RemoteViews;\n \n+import com.android.internal.statusbar.IStatusBarService;\n import com.android.systemui.TestableDependency;\n import com.android.systemui.classifier.FalsingCollectorFake;\n import com.android.systemui.classifier.FalsingManagerFake;\n@@ -490,7 +491,8 @@ public class NotificationTestHelper {\n                 mPeopleNotificationIdentifier,\n                 mock(OnUserInteractionCallback.class),\n                 Optional.of(mock(BubblesManager.class)),\n-                mock(NotificationGutsManager.class));\n+                mock(NotificationGutsManager.class),\n+                mock(IStatusBarService.class));\n \n         row.setAboveShelfChangedListener(aboveShelf -> { });\n         mBindStage.getStageParams(entry).requireContentViews(extraInflationFlags);\n",
    "added_lines": 3,
    "deleted_lines": 1,
    "changed_methods": "NotificationTestHelper::generateRow"
   }
  ]
 },
 {
  "hash": "f76b124b6ede9ead86eb033d5053850d833f75bb",
  "commit": "Check key intent for selectors and prohibited flags\n\nBug: 265015796\nTest: atest\nFrameworksServicesTests: com.android.server.accounts.AccountManagerServiceTest\n(cherry picked from commit e53a96304352e2965176c8d32ac1b504e52ef185)\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:5e01f68bdabe8aa7154e1ed936235b5304f4c0cd)\nMerged-In: Ie16f8654337bd75eaad3156817470674b4f0cee3\nChange-Id: Ie16f8654337bd75eaad3156817470674b4f0cee3",
  "files": [
   {
    "filename": "AccountManagerService.java",
    "diff": "@@ -4881,10 +4881,6 @@ public class AccountManagerService\n             if (intent.getClipData() == null) {\n                 intent.setClipData(ClipData.newPlainText(null, null));\n             }\n-            intent.setFlags(intent.getFlags() & ~(Intent.FLAG_GRANT_READ_URI_PERMISSION\n-                    | Intent.FLAG_GRANT_WRITE_URI_PERMISSION\n-                    | Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION\n-                    | Intent.FLAG_GRANT_PREFIX_URI_PERMISSION));\n             final long bid = Binder.clearCallingIdentity();\n             try {\n                 PackageManager pm = mContext.getPackageManager();\n@@ -4931,7 +4927,19 @@ public class AccountManagerService\n             if (intent == null) {\n                 return (simulateIntent == null);\n             }\n-            return intent.filterEquals(simulateIntent);\n+            if (!intent.filterEquals(simulateIntent)) {\n+                return false;\n+            }\n+\n+            if (intent.getSelector() != simulateIntent.getSelector()) {\n+                return false;\n+            }\n+\n+            int prohibitedFlags = Intent.FLAG_GRANT_READ_URI_PERMISSION\n+                    | Intent.FLAG_GRANT_WRITE_URI_PERMISSION\n+                    | Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION\n+                    | Intent.FLAG_GRANT_PREFIX_URI_PERMISSION;\n+            return (simulateIntent.getFlags() & prohibitedFlags) == 0;\n         }\n \n         private boolean isExportedSystemActivity(ActivityInfo activityInfo) {\n",
    "added_lines": 13,
    "deleted_lines": 5,
    "changed_methods": "AccountManagerService::Session::checkKeyIntentParceledCorrectly, AccountManagerService::Session::checkKeyIntent"
   },
   {
    "filename": "AccountManagerServiceTest.java",
    "diff": "@@ -18,6 +18,7 @@ package com.android.server.accounts;\n \n import static android.database.sqlite.SQLiteDatabase.deleteDatabase;\n \n+import static org.mockito.ArgumentMatchers.contains;\n import static org.mockito.Matchers.any;\n import static org.mockito.Matchers.anyBoolean;\n import static org.mockito.Matchers.anyInt;\n@@ -705,6 +706,41 @@ public class AccountManagerServiceTest extends AndroidTestCase {\n         assertNotNull(intent.getParcelableExtra(AccountManagerServiceTestFixtures.KEY_CALLBACK));\n     }\n \n+    @SmallTest\n+    public void testStartAddAccountSessionWhereAuthenticatorReturnsIntentWithProhibitedFlags()\n+            throws Exception {\n+        unlockSystemUser();\n+        ResolveInfo resolveInfo = new ResolveInfo();\n+        resolveInfo.activityInfo = new ActivityInfo();\n+        resolveInfo.activityInfo.applicationInfo = new ApplicationInfo();\n+        when(mMockPackageManager.resolveActivityAsUser(\n+                any(Intent.class), anyInt(), anyInt())).thenReturn(resolveInfo);\n+        when(mMockPackageManager.checkSignatures(\n+                anyInt(), anyInt())).thenReturn(PackageManager.SIGNATURE_MATCH);\n+\n+        final CountDownLatch latch = new CountDownLatch(1);\n+        Response response = new Response(latch, mMockAccountManagerResponse);\n+        Bundle options = createOptionsWithAccountName(\n+                AccountManagerServiceTestFixtures.ACCOUNT_NAME_INTERVENE);\n+        int prohibitedFlags = Intent.FLAG_GRANT_READ_URI_PERMISSION\n+                | Intent.FLAG_GRANT_WRITE_URI_PERMISSION\n+                | Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION\n+                | Intent.FLAG_GRANT_PREFIX_URI_PERMISSION;\n+        options.putInt(AccountManagerServiceTestFixtures.KEY_INTENT_FLAGS, prohibitedFlags);\n+\n+        mAms.startAddAccountSession(\n+                response, // response\n+                AccountManagerServiceTestFixtures.ACCOUNT_TYPE_1, // accountType\n+                \"authTokenType\",\n+                null, // requiredFeatures\n+                true, // expectActivityLaunch\n+                options); // optionsIn\n+        waitForLatch(latch);\n+\n+        verify(mMockAccountManagerResponse).onError(\n+                eq(AccountManager.ERROR_CODE_INVALID_RESPONSE), contains(\"invalid intent\"));\n+    }\n+\n     @SmallTest\n     public void testStartAddAccountSessionError() throws Exception {\n         unlockSystemUser();\n",
    "added_lines": 36,
    "deleted_lines": 0,
    "changed_methods": "AccountManagerServiceTest::testStartAddAccountSessionWhereAuthenticatorReturnsIntentWithProhibitedFlags"
   },
   {
    "filename": "AccountManagerServiceTestFixtures.java",
    "diff": "@@ -17,9 +17,6 @@ package com.android.server.accounts;\n \n import android.accounts.Account;\n \n-import java.util.ArrayList;\n-import java.util.List;\n-\n /**\n  * Constants shared between test AccountAuthenticators and AccountManagerServiceTest.\n  */\n@@ -31,6 +28,8 @@ public final class AccountManagerServiceTestFixtures {\n             \"account_manager_service_test:account_status_token_key\";\n     public static final String KEY_ACCOUNT_PASSWORD =\n             \"account_manager_service_test:account_password_key\";\n+    public static final String KEY_INTENT_FLAGS =\n+            \"account_manager_service_test:intent_flags_key\";\n     public static final String KEY_OPTIONS_BUNDLE =\n             \"account_manager_service_test:option_bundle_key\";\n     public static final String ACCOUNT_NAME_SUCCESS = \"success_on_return@fixture.com\";\n",
    "added_lines": 2,
    "deleted_lines": 3,
    "changed_methods": ""
   },
   {
    "filename": "TestAccountType1Authenticator.java",
    "diff": "@@ -24,8 +24,6 @@ import android.content.Context;\n import android.content.Intent;\n import android.os.Bundle;\n \n-import com.android.frameworks.servicestests.R;\n-\n import java.util.concurrent.atomic.AtomicInteger;\n \n /**\n@@ -270,11 +268,13 @@ public class TestAccountType1Authenticator extends AbstractAccountAuthenticator\n         String accountName = null;\n         Bundle sessionBundle = null;\n         String password = null;\n+        int intentFlags = 0;\n         if (options != null) {\n             accountName = options.getString(AccountManagerServiceTestFixtures.KEY_ACCOUNT_NAME);\n             sessionBundle = options.getBundle(\n                     AccountManagerServiceTestFixtures.KEY_ACCOUNT_SESSION_BUNDLE);\n             password = options.getString(AccountManagerServiceTestFixtures.KEY_ACCOUNT_PASSWORD);\n+            intentFlags = options.getInt(AccountManagerServiceTestFixtures.KEY_INTENT_FLAGS, 0);\n         }\n \n         Bundle result = new Bundle();\n@@ -302,6 +302,7 @@ public class TestAccountType1Authenticator extends AbstractAccountAuthenticator\n             intent.putExtra(AccountManagerServiceTestFixtures.KEY_RESULT,\n                     eventualActivityResultData);\n             intent.putExtra(AccountManagerServiceTestFixtures.KEY_CALLBACK, response);\n+            intent.setFlags(intentFlags);\n \n             result.putParcelable(AccountManager.KEY_INTENT, intent);\n         } else {\n",
    "added_lines": 3,
    "deleted_lines": 2,
    "changed_methods": "TestAccountType1Authenticator::startAddAccountSession"
   }
  ]
 },
 {
  "hash": "f76b124b6ede9ead86eb033d5053850d833f75bb",
  "commit": "Check key intent for selectors and prohibited flags\n\nBug: 265015796\nTest: atest\nFrameworksServicesTests: com.android.server.accounts.AccountManagerServiceTest\n(cherry picked from commit e53a96304352e2965176c8d32ac1b504e52ef185)\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:5e01f68bdabe8aa7154e1ed936235b5304f4c0cd)\nMerged-In: Ie16f8654337bd75eaad3156817470674b4f0cee3\nChange-Id: Ie16f8654337bd75eaad3156817470674b4f0cee3",
  "files": [
   {
    "filename": "AccountManagerService.java",
    "diff": "@@ -4881,10 +4881,6 @@ public class AccountManagerService\n             if (intent.getClipData() == null) {\n                 intent.setClipData(ClipData.newPlainText(null, null));\n             }\n-            intent.setFlags(intent.getFlags() & ~(Intent.FLAG_GRANT_READ_URI_PERMISSION\n-                    | Intent.FLAG_GRANT_WRITE_URI_PERMISSION\n-                    | Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION\n-                    | Intent.FLAG_GRANT_PREFIX_URI_PERMISSION));\n             final long bid = Binder.clearCallingIdentity();\n             try {\n                 PackageManager pm = mContext.getPackageManager();\n@@ -4931,7 +4927,19 @@ public class AccountManagerService\n             if (intent == null) {\n                 return (simulateIntent == null);\n             }\n-            return intent.filterEquals(simulateIntent);\n+            if (!intent.filterEquals(simulateIntent)) {\n+                return false;\n+            }\n+\n+            if (intent.getSelector() != simulateIntent.getSelector()) {\n+                return false;\n+            }\n+\n+            int prohibitedFlags = Intent.FLAG_GRANT_READ_URI_PERMISSION\n+                    | Intent.FLAG_GRANT_WRITE_URI_PERMISSION\n+                    | Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION\n+                    | Intent.FLAG_GRANT_PREFIX_URI_PERMISSION;\n+            return (simulateIntent.getFlags() & prohibitedFlags) == 0;\n         }\n \n         private boolean isExportedSystemActivity(ActivityInfo activityInfo) {\n",
    "added_lines": 13,
    "deleted_lines": 5,
    "changed_methods": "AccountManagerService::Session::checkKeyIntentParceledCorrectly, AccountManagerService::Session::checkKeyIntent"
   },
   {
    "filename": "AccountManagerServiceTest.java",
    "diff": "@@ -18,6 +18,7 @@ package com.android.server.accounts;\n \n import static android.database.sqlite.SQLiteDatabase.deleteDatabase;\n \n+import static org.mockito.ArgumentMatchers.contains;\n import static org.mockito.Matchers.any;\n import static org.mockito.Matchers.anyBoolean;\n import static org.mockito.Matchers.anyInt;\n@@ -705,6 +706,41 @@ public class AccountManagerServiceTest extends AndroidTestCase {\n         assertNotNull(intent.getParcelableExtra(AccountManagerServiceTestFixtures.KEY_CALLBACK));\n     }\n \n+    @SmallTest\n+    public void testStartAddAccountSessionWhereAuthenticatorReturnsIntentWithProhibitedFlags()\n+            throws Exception {\n+        unlockSystemUser();\n+        ResolveInfo resolveInfo = new ResolveInfo();\n+        resolveInfo.activityInfo = new ActivityInfo();\n+        resolveInfo.activityInfo.applicationInfo = new ApplicationInfo();\n+        when(mMockPackageManager.resolveActivityAsUser(\n+                any(Intent.class), anyInt(), anyInt())).thenReturn(resolveInfo);\n+        when(mMockPackageManager.checkSignatures(\n+                anyInt(), anyInt())).thenReturn(PackageManager.SIGNATURE_MATCH);\n+\n+        final CountDownLatch latch = new CountDownLatch(1);\n+        Response response = new Response(latch, mMockAccountManagerResponse);\n+        Bundle options = createOptionsWithAccountName(\n+                AccountManagerServiceTestFixtures.ACCOUNT_NAME_INTERVENE);\n+        int prohibitedFlags = Intent.FLAG_GRANT_READ_URI_PERMISSION\n+                | Intent.FLAG_GRANT_WRITE_URI_PERMISSION\n+                | Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION\n+                | Intent.FLAG_GRANT_PREFIX_URI_PERMISSION;\n+        options.putInt(AccountManagerServiceTestFixtures.KEY_INTENT_FLAGS, prohibitedFlags);\n+\n+        mAms.startAddAccountSession(\n+                response, // response\n+                AccountManagerServiceTestFixtures.ACCOUNT_TYPE_1, // accountType\n+                \"authTokenType\",\n+                null, // requiredFeatures\n+                true, // expectActivityLaunch\n+                options); // optionsIn\n+        waitForLatch(latch);\n+\n+        verify(mMockAccountManagerResponse).onError(\n+                eq(AccountManager.ERROR_CODE_INVALID_RESPONSE), contains(\"invalid intent\"));\n+    }\n+\n     @SmallTest\n     public void testStartAddAccountSessionError() throws Exception {\n         unlockSystemUser();\n",
    "added_lines": 36,
    "deleted_lines": 0,
    "changed_methods": "AccountManagerServiceTest::testStartAddAccountSessionWhereAuthenticatorReturnsIntentWithProhibitedFlags"
   },
   {
    "filename": "AccountManagerServiceTestFixtures.java",
    "diff": "@@ -17,9 +17,6 @@ package com.android.server.accounts;\n \n import android.accounts.Account;\n \n-import java.util.ArrayList;\n-import java.util.List;\n-\n /**\n  * Constants shared between test AccountAuthenticators and AccountManagerServiceTest.\n  */\n@@ -31,6 +28,8 @@ public final class AccountManagerServiceTestFixtures {\n             \"account_manager_service_test:account_status_token_key\";\n     public static final String KEY_ACCOUNT_PASSWORD =\n             \"account_manager_service_test:account_password_key\";\n+    public static final String KEY_INTENT_FLAGS =\n+            \"account_manager_service_test:intent_flags_key\";\n     public static final String KEY_OPTIONS_BUNDLE =\n             \"account_manager_service_test:option_bundle_key\";\n     public static final String ACCOUNT_NAME_SUCCESS = \"success_on_return@fixture.com\";\n",
    "added_lines": 2,
    "deleted_lines": 3,
    "changed_methods": ""
   },
   {
    "filename": "TestAccountType1Authenticator.java",
    "diff": "@@ -24,8 +24,6 @@ import android.content.Context;\n import android.content.Intent;\n import android.os.Bundle;\n \n-import com.android.frameworks.servicestests.R;\n-\n import java.util.concurrent.atomic.AtomicInteger;\n \n /**\n@@ -270,11 +268,13 @@ public class TestAccountType1Authenticator extends AbstractAccountAuthenticator\n         String accountName = null;\n         Bundle sessionBundle = null;\n         String password = null;\n+        int intentFlags = 0;\n         if (options != null) {\n             accountName = options.getString(AccountManagerServiceTestFixtures.KEY_ACCOUNT_NAME);\n             sessionBundle = options.getBundle(\n                     AccountManagerServiceTestFixtures.KEY_ACCOUNT_SESSION_BUNDLE);\n             password = options.getString(AccountManagerServiceTestFixtures.KEY_ACCOUNT_PASSWORD);\n+            intentFlags = options.getInt(AccountManagerServiceTestFixtures.KEY_INTENT_FLAGS, 0);\n         }\n \n         Bundle result = new Bundle();\n@@ -302,6 +302,7 @@ public class TestAccountType1Authenticator extends AbstractAccountAuthenticator\n             intent.putExtra(AccountManagerServiceTestFixtures.KEY_RESULT,\n                     eventualActivityResultData);\n             intent.putExtra(AccountManagerServiceTestFixtures.KEY_CALLBACK, response);\n+            intent.setFlags(intentFlags);\n \n             result.putParcelable(AccountManager.KEY_INTENT, intent);\n         } else {\n",
    "added_lines": 3,
    "deleted_lines": 2,
    "changed_methods": "TestAccountType1Authenticator::startAddAccountSession"
   }
  ]
 },
 {
  "hash": "f76b124b6ede9ead86eb033d5053850d833f75bb",
  "commit": "Check key intent for selectors and prohibited flags\n\nBug: 265015796\nTest: atest\nFrameworksServicesTests: com.android.server.accounts.AccountManagerServiceTest\n(cherry picked from commit e53a96304352e2965176c8d32ac1b504e52ef185)\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:5e01f68bdabe8aa7154e1ed936235b5304f4c0cd)\nMerged-In: Ie16f8654337bd75eaad3156817470674b4f0cee3\nChange-Id: Ie16f8654337bd75eaad3156817470674b4f0cee3",
  "files": [
   {
    "filename": "AccountManagerService.java",
    "diff": "@@ -4881,10 +4881,6 @@ public class AccountManagerService\n             if (intent.getClipData() == null) {\n                 intent.setClipData(ClipData.newPlainText(null, null));\n             }\n-            intent.setFlags(intent.getFlags() & ~(Intent.FLAG_GRANT_READ_URI_PERMISSION\n-                    | Intent.FLAG_GRANT_WRITE_URI_PERMISSION\n-                    | Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION\n-                    | Intent.FLAG_GRANT_PREFIX_URI_PERMISSION));\n             final long bid = Binder.clearCallingIdentity();\n             try {\n                 PackageManager pm = mContext.getPackageManager();\n@@ -4931,7 +4927,19 @@ public class AccountManagerService\n             if (intent == null) {\n                 return (simulateIntent == null);\n             }\n-            return intent.filterEquals(simulateIntent);\n+            if (!intent.filterEquals(simulateIntent)) {\n+                return false;\n+            }\n+\n+            if (intent.getSelector() != simulateIntent.getSelector()) {\n+                return false;\n+            }\n+\n+            int prohibitedFlags = Intent.FLAG_GRANT_READ_URI_PERMISSION\n+                    | Intent.FLAG_GRANT_WRITE_URI_PERMISSION\n+                    | Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION\n+                    | Intent.FLAG_GRANT_PREFIX_URI_PERMISSION;\n+            return (simulateIntent.getFlags() & prohibitedFlags) == 0;\n         }\n \n         private boolean isExportedSystemActivity(ActivityInfo activityInfo) {\n",
    "added_lines": 13,
    "deleted_lines": 5,
    "changed_methods": "AccountManagerService::Session::checkKeyIntentParceledCorrectly, AccountManagerService::Session::checkKeyIntent"
   },
   {
    "filename": "AccountManagerServiceTest.java",
    "diff": "@@ -18,6 +18,7 @@ package com.android.server.accounts;\n \n import static android.database.sqlite.SQLiteDatabase.deleteDatabase;\n \n+import static org.mockito.ArgumentMatchers.contains;\n import static org.mockito.Matchers.any;\n import static org.mockito.Matchers.anyBoolean;\n import static org.mockito.Matchers.anyInt;\n@@ -705,6 +706,41 @@ public class AccountManagerServiceTest extends AndroidTestCase {\n         assertNotNull(intent.getParcelableExtra(AccountManagerServiceTestFixtures.KEY_CALLBACK));\n     }\n \n+    @SmallTest\n+    public void testStartAddAccountSessionWhereAuthenticatorReturnsIntentWithProhibitedFlags()\n+            throws Exception {\n+        unlockSystemUser();\n+        ResolveInfo resolveInfo = new ResolveInfo();\n+        resolveInfo.activityInfo = new ActivityInfo();\n+        resolveInfo.activityInfo.applicationInfo = new ApplicationInfo();\n+        when(mMockPackageManager.resolveActivityAsUser(\n+                any(Intent.class), anyInt(), anyInt())).thenReturn(resolveInfo);\n+        when(mMockPackageManager.checkSignatures(\n+                anyInt(), anyInt())).thenReturn(PackageManager.SIGNATURE_MATCH);\n+\n+        final CountDownLatch latch = new CountDownLatch(1);\n+        Response response = new Response(latch, mMockAccountManagerResponse);\n+        Bundle options = createOptionsWithAccountName(\n+                AccountManagerServiceTestFixtures.ACCOUNT_NAME_INTERVENE);\n+        int prohibitedFlags = Intent.FLAG_GRANT_READ_URI_PERMISSION\n+                | Intent.FLAG_GRANT_WRITE_URI_PERMISSION\n+                | Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION\n+                | Intent.FLAG_GRANT_PREFIX_URI_PERMISSION;\n+        options.putInt(AccountManagerServiceTestFixtures.KEY_INTENT_FLAGS, prohibitedFlags);\n+\n+        mAms.startAddAccountSession(\n+                response, // response\n+                AccountManagerServiceTestFixtures.ACCOUNT_TYPE_1, // accountType\n+                \"authTokenType\",\n+                null, // requiredFeatures\n+                true, // expectActivityLaunch\n+                options); // optionsIn\n+        waitForLatch(latch);\n+\n+        verify(mMockAccountManagerResponse).onError(\n+                eq(AccountManager.ERROR_CODE_INVALID_RESPONSE), contains(\"invalid intent\"));\n+    }\n+\n     @SmallTest\n     public void testStartAddAccountSessionError() throws Exception {\n         unlockSystemUser();\n",
    "added_lines": 36,
    "deleted_lines": 0,
    "changed_methods": "AccountManagerServiceTest::testStartAddAccountSessionWhereAuthenticatorReturnsIntentWithProhibitedFlags"
   },
   {
    "filename": "AccountManagerServiceTestFixtures.java",
    "diff": "@@ -17,9 +17,6 @@ package com.android.server.accounts;\n \n import android.accounts.Account;\n \n-import java.util.ArrayList;\n-import java.util.List;\n-\n /**\n  * Constants shared between test AccountAuthenticators and AccountManagerServiceTest.\n  */\n@@ -31,6 +28,8 @@ public final class AccountManagerServiceTestFixtures {\n             \"account_manager_service_test:account_status_token_key\";\n     public static final String KEY_ACCOUNT_PASSWORD =\n             \"account_manager_service_test:account_password_key\";\n+    public static final String KEY_INTENT_FLAGS =\n+            \"account_manager_service_test:intent_flags_key\";\n     public static final String KEY_OPTIONS_BUNDLE =\n             \"account_manager_service_test:option_bundle_key\";\n     public static final String ACCOUNT_NAME_SUCCESS = \"success_on_return@fixture.com\";\n",
    "added_lines": 2,
    "deleted_lines": 3,
    "changed_methods": ""
   },
   {
    "filename": "TestAccountType1Authenticator.java",
    "diff": "@@ -24,8 +24,6 @@ import android.content.Context;\n import android.content.Intent;\n import android.os.Bundle;\n \n-import com.android.frameworks.servicestests.R;\n-\n import java.util.concurrent.atomic.AtomicInteger;\n \n /**\n@@ -270,11 +268,13 @@ public class TestAccountType1Authenticator extends AbstractAccountAuthenticator\n         String accountName = null;\n         Bundle sessionBundle = null;\n         String password = null;\n+        int intentFlags = 0;\n         if (options != null) {\n             accountName = options.getString(AccountManagerServiceTestFixtures.KEY_ACCOUNT_NAME);\n             sessionBundle = options.getBundle(\n                     AccountManagerServiceTestFixtures.KEY_ACCOUNT_SESSION_BUNDLE);\n             password = options.getString(AccountManagerServiceTestFixtures.KEY_ACCOUNT_PASSWORD);\n+            intentFlags = options.getInt(AccountManagerServiceTestFixtures.KEY_INTENT_FLAGS, 0);\n         }\n \n         Bundle result = new Bundle();\n@@ -302,6 +302,7 @@ public class TestAccountType1Authenticator extends AbstractAccountAuthenticator\n             intent.putExtra(AccountManagerServiceTestFixtures.KEY_RESULT,\n                     eventualActivityResultData);\n             intent.putExtra(AccountManagerServiceTestFixtures.KEY_CALLBACK, response);\n+            intent.setFlags(intentFlags);\n \n             result.putParcelable(AccountManager.KEY_INTENT, intent);\n         } else {\n",
    "added_lines": 3,
    "deleted_lines": 2,
    "changed_methods": "TestAccountType1Authenticator::startAddAccountSession"
   }
  ]
 },
 {
  "hash": "f76b124b6ede9ead86eb033d5053850d833f75bb",
  "commit": "Check key intent for selectors and prohibited flags\n\nBug: 265015796\nTest: atest\nFrameworksServicesTests: com.android.server.accounts.AccountManagerServiceTest\n(cherry picked from commit e53a96304352e2965176c8d32ac1b504e52ef185)\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:5e01f68bdabe8aa7154e1ed936235b5304f4c0cd)\nMerged-In: Ie16f8654337bd75eaad3156817470674b4f0cee3\nChange-Id: Ie16f8654337bd75eaad3156817470674b4f0cee3",
  "files": [
   {
    "filename": "AccountManagerService.java",
    "diff": "@@ -4881,10 +4881,6 @@ public class AccountManagerService\n             if (intent.getClipData() == null) {\n                 intent.setClipData(ClipData.newPlainText(null, null));\n             }\n-            intent.setFlags(intent.getFlags() & ~(Intent.FLAG_GRANT_READ_URI_PERMISSION\n-                    | Intent.FLAG_GRANT_WRITE_URI_PERMISSION\n-                    | Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION\n-                    | Intent.FLAG_GRANT_PREFIX_URI_PERMISSION));\n             final long bid = Binder.clearCallingIdentity();\n             try {\n                 PackageManager pm = mContext.getPackageManager();\n@@ -4931,7 +4927,19 @@ public class AccountManagerService\n             if (intent == null) {\n                 return (simulateIntent == null);\n             }\n-            return intent.filterEquals(simulateIntent);\n+            if (!intent.filterEquals(simulateIntent)) {\n+                return false;\n+            }\n+\n+            if (intent.getSelector() != simulateIntent.getSelector()) {\n+                return false;\n+            }\n+\n+            int prohibitedFlags = Intent.FLAG_GRANT_READ_URI_PERMISSION\n+                    | Intent.FLAG_GRANT_WRITE_URI_PERMISSION\n+                    | Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION\n+                    | Intent.FLAG_GRANT_PREFIX_URI_PERMISSION;\n+            return (simulateIntent.getFlags() & prohibitedFlags) == 0;\n         }\n \n         private boolean isExportedSystemActivity(ActivityInfo activityInfo) {\n",
    "added_lines": 13,
    "deleted_lines": 5,
    "changed_methods": "AccountManagerService::Session::checkKeyIntentParceledCorrectly, AccountManagerService::Session::checkKeyIntent"
   },
   {
    "filename": "AccountManagerServiceTest.java",
    "diff": "@@ -18,6 +18,7 @@ package com.android.server.accounts;\n \n import static android.database.sqlite.SQLiteDatabase.deleteDatabase;\n \n+import static org.mockito.ArgumentMatchers.contains;\n import static org.mockito.Matchers.any;\n import static org.mockito.Matchers.anyBoolean;\n import static org.mockito.Matchers.anyInt;\n@@ -705,6 +706,41 @@ public class AccountManagerServiceTest extends AndroidTestCase {\n         assertNotNull(intent.getParcelableExtra(AccountManagerServiceTestFixtures.KEY_CALLBACK));\n     }\n \n+    @SmallTest\n+    public void testStartAddAccountSessionWhereAuthenticatorReturnsIntentWithProhibitedFlags()\n+            throws Exception {\n+        unlockSystemUser();\n+        ResolveInfo resolveInfo = new ResolveInfo();\n+        resolveInfo.activityInfo = new ActivityInfo();\n+        resolveInfo.activityInfo.applicationInfo = new ApplicationInfo();\n+        when(mMockPackageManager.resolveActivityAsUser(\n+                any(Intent.class), anyInt(), anyInt())).thenReturn(resolveInfo);\n+        when(mMockPackageManager.checkSignatures(\n+                anyInt(), anyInt())).thenReturn(PackageManager.SIGNATURE_MATCH);\n+\n+        final CountDownLatch latch = new CountDownLatch(1);\n+        Response response = new Response(latch, mMockAccountManagerResponse);\n+        Bundle options = createOptionsWithAccountName(\n+                AccountManagerServiceTestFixtures.ACCOUNT_NAME_INTERVENE);\n+        int prohibitedFlags = Intent.FLAG_GRANT_READ_URI_PERMISSION\n+                | Intent.FLAG_GRANT_WRITE_URI_PERMISSION\n+                | Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION\n+                | Intent.FLAG_GRANT_PREFIX_URI_PERMISSION;\n+        options.putInt(AccountManagerServiceTestFixtures.KEY_INTENT_FLAGS, prohibitedFlags);\n+\n+        mAms.startAddAccountSession(\n+                response, // response\n+                AccountManagerServiceTestFixtures.ACCOUNT_TYPE_1, // accountType\n+                \"authTokenType\",\n+                null, // requiredFeatures\n+                true, // expectActivityLaunch\n+                options); // optionsIn\n+        waitForLatch(latch);\n+\n+        verify(mMockAccountManagerResponse).onError(\n+                eq(AccountManager.ERROR_CODE_INVALID_RESPONSE), contains(\"invalid intent\"));\n+    }\n+\n     @SmallTest\n     public void testStartAddAccountSessionError() throws Exception {\n         unlockSystemUser();\n",
    "added_lines": 36,
    "deleted_lines": 0,
    "changed_methods": "AccountManagerServiceTest::testStartAddAccountSessionWhereAuthenticatorReturnsIntentWithProhibitedFlags"
   },
   {
    "filename": "AccountManagerServiceTestFixtures.java",
    "diff": "@@ -17,9 +17,6 @@ package com.android.server.accounts;\n \n import android.accounts.Account;\n \n-import java.util.ArrayList;\n-import java.util.List;\n-\n /**\n  * Constants shared between test AccountAuthenticators and AccountManagerServiceTest.\n  */\n@@ -31,6 +28,8 @@ public final class AccountManagerServiceTestFixtures {\n             \"account_manager_service_test:account_status_token_key\";\n     public static final String KEY_ACCOUNT_PASSWORD =\n             \"account_manager_service_test:account_password_key\";\n+    public static final String KEY_INTENT_FLAGS =\n+            \"account_manager_service_test:intent_flags_key\";\n     public static final String KEY_OPTIONS_BUNDLE =\n             \"account_manager_service_test:option_bundle_key\";\n     public static final String ACCOUNT_NAME_SUCCESS = \"success_on_return@fixture.com\";\n",
    "added_lines": 2,
    "deleted_lines": 3,
    "changed_methods": ""
   },
   {
    "filename": "TestAccountType1Authenticator.java",
    "diff": "@@ -24,8 +24,6 @@ import android.content.Context;\n import android.content.Intent;\n import android.os.Bundle;\n \n-import com.android.frameworks.servicestests.R;\n-\n import java.util.concurrent.atomic.AtomicInteger;\n \n /**\n@@ -270,11 +268,13 @@ public class TestAccountType1Authenticator extends AbstractAccountAuthenticator\n         String accountName = null;\n         Bundle sessionBundle = null;\n         String password = null;\n+        int intentFlags = 0;\n         if (options != null) {\n             accountName = options.getString(AccountManagerServiceTestFixtures.KEY_ACCOUNT_NAME);\n             sessionBundle = options.getBundle(\n                     AccountManagerServiceTestFixtures.KEY_ACCOUNT_SESSION_BUNDLE);\n             password = options.getString(AccountManagerServiceTestFixtures.KEY_ACCOUNT_PASSWORD);\n+            intentFlags = options.getInt(AccountManagerServiceTestFixtures.KEY_INTENT_FLAGS, 0);\n         }\n \n         Bundle result = new Bundle();\n@@ -302,6 +302,7 @@ public class TestAccountType1Authenticator extends AbstractAccountAuthenticator\n             intent.putExtra(AccountManagerServiceTestFixtures.KEY_RESULT,\n                     eventualActivityResultData);\n             intent.putExtra(AccountManagerServiceTestFixtures.KEY_CALLBACK, response);\n+            intent.setFlags(intentFlags);\n \n             result.putParcelable(AccountManager.KEY_INTENT, intent);\n         } else {\n",
    "added_lines": 3,
    "deleted_lines": 2,
    "changed_methods": "TestAccountType1Authenticator::startAddAccountSession"
   }
  ]
 },
 {
  "hash": "b8457600c1b0e1ed4f621bc13fce5088c6ab18c9",
  "commit": "Handle invalid data during job loading.\n\nCatch exceptions that may be thrown if invalid data ended up in the\npersisted job file.\n\nBug: 246541702\nBug: 246542132\nBug: 246542285\nBug: 246542330\nTest: install test app with invalid job config, start app to schedule job, then reboot device\n(cherry picked from commit c98fb42b480b3beedc2d94de6110f50212c4aa0b)\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:7bdc1e8a3affd8534a829744001ef3ea26cce074)\nMerged-In: Id0ceba345942baf21177f687b8dd85ef001c0a9e\nChange-Id: Id0ceba345942baf21177f687b8dd85ef001c0a9e",
  "files": [
   {
    "filename": "JobStore.java",
    "diff": "@@ -733,6 +733,10 @@ public final class JobStore {\n                 }\n             } catch (XmlPullParserException | IOException e) {\n                 Slog.wtf(TAG, \"Error jobstore xml.\", e);\n+            } catch (Exception e) {\n+                // Crashing at this point would result in a boot loop, so live with a general\n+                // Exception for system stability's sake.\n+                Slog.wtf(TAG, \"Unexpected exception\", e);\n             } finally {\n                 if (mPersistInfo.countAllJobsLoaded < 0) { // Only set them once.\n                     mPersistInfo.countAllJobsLoaded = numJobs;\n@@ -869,6 +873,9 @@ public final class JobStore {\n             } catch (IOException e) {\n                 Slog.d(TAG, \"Error I/O Exception.\", e);\n                 return null;\n+            } catch (IllegalArgumentException e) {\n+                Slog.e(TAG, \"Constraints contained invalid data\", e);\n+                return null;\n             }\n \n             parser.next(); // Consume </constraints>\n@@ -965,8 +972,14 @@ public final class JobStore {\n                 return null;\n             }\n \n-            PersistableBundle extras = PersistableBundle.restoreFromXml(parser);\n-            jobBuilder.setExtras(extras);\n+            final PersistableBundle extras;\n+            try {\n+                extras = PersistableBundle.restoreFromXml(parser);\n+                jobBuilder.setExtras(extras);\n+            } catch (IllegalArgumentException e) {\n+                Slog.e(TAG, \"Persisted extras contained invalid data\", e);\n+                return null;\n+            }\n             parser.nextTag(); // Consume </extras>\n \n             final JobInfo builtJob;\n",
    "added_lines": 15,
    "deleted_lines": 2,
    "changed_methods": "JobStore::ReadJobMapFromDiskRunnable::restoreJobFromXml, JobStore::ReadJobMapFromDiskRunnable::run"
   }
  ]
 },
 {
  "hash": "2510c72e34c660e42599f9866ca846395ba1aebf",
  "commit": "Allow filtering of services\n\nTest: ServiceListingTest\nBug: 260570119\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:a9c75de2b4ae92f4b7e7aade8433fd44ef376e11)\nMerged-In: Ib4740ba401667de62fa1a33334c2c1fbee25b760\nChange-Id: Ib4740ba401667de62fa1a33334c2c1fbee25b760",
  "files": [
   {
    "filename": "ServiceListing.java",
    "diff": "@@ -35,6 +35,7 @@ import android.util.Slog;\n import java.util.ArrayList;\n import java.util.HashSet;\n import java.util.List;\n+import java.util.function.Predicate;\n \n /**\n  * Class for managing services matching a given intent and requesting a given permission.\n@@ -51,12 +52,13 @@ public class ServiceListing {\n     private final HashSet<ComponentName> mEnabledServices = new HashSet<>();\n     private final List<ServiceInfo> mServices = new ArrayList<>();\n     private final List<Callback> mCallbacks = new ArrayList<>();\n+    private final Predicate mValidator;\n \n     private boolean mListening;\n \n     private ServiceListing(Context context, String tag,\n             String setting, String intentAction, String permission, String noun,\n-            boolean addDeviceLockedFlags) {\n+            boolean addDeviceLockedFlags, Predicate validator) {\n         mContentResolver = context.getContentResolver();\n         mContext = context;\n         mTag = tag;\n@@ -65,6 +67,7 @@ public class ServiceListing {\n         mPermission = permission;\n         mNoun = noun;\n         mAddDeviceLockedFlags = addDeviceLockedFlags;\n+        mValidator = validator;\n     }\n \n     public void addCallback(Callback callback) {\n@@ -137,7 +140,6 @@ public class ServiceListing {\n         final PackageManager pmWrapper = mContext.getPackageManager();\n         List<ResolveInfo> installedServices = pmWrapper.queryIntentServicesAsUser(\n                 new Intent(mIntentAction), flags, user);\n-\n         for (ResolveInfo resolveInfo : installedServices) {\n             ServiceInfo info = resolveInfo.serviceInfo;\n \n@@ -148,6 +150,9 @@ public class ServiceListing {\n                         + mPermission);\n                 continue;\n             }\n+            if (mValidator != null && !mValidator.test(info)) {\n+                continue;\n+            }\n             mServices.add(info);\n         }\n         for (Callback callback : mCallbacks) {\n@@ -194,6 +199,7 @@ public class ServiceListing {\n         private String mPermission;\n         private String mNoun;\n         private boolean mAddDeviceLockedFlags = false;\n+        private Predicate mValidator;\n \n         public Builder(Context context) {\n             mContext = context;\n@@ -224,6 +230,11 @@ public class ServiceListing {\n             return this;\n         }\n \n+        public Builder setValidator(Predicate<ServiceInfo> validator) {\n+            mValidator = validator;\n+            return this;\n+        }\n+\n         /**\n          * Set to true to add support for both MATCH_DIRECT_BOOT_AWARE and\n          * MATCH_DIRECT_BOOT_UNAWARE flags when querying PackageManager. Required to get results\n@@ -236,7 +247,7 @@ public class ServiceListing {\n \n         public ServiceListing build() {\n             return new ServiceListing(mContext, mTag, mSetting, mIntentAction, mPermission, mNoun,\n-                    mAddDeviceLockedFlags);\n+                    mAddDeviceLockedFlags, mValidator);\n         }\n     }\n }\n",
    "added_lines": 14,
    "deleted_lines": 3,
    "changed_methods": "ServiceListing::ServiceListing, ServiceListing::reload, ServiceListing::Builder::build, ServiceListing::Builder::setValidator, ServiceListing::ServiceListing"
   },
   {
    "filename": "ServiceListingTest.java",
    "diff": "@@ -18,20 +18,35 @@ package com.android.settingslib.applications;\n \n import static com.google.common.truth.Truth.assertThat;\n \n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyInt;\n import static org.mockito.ArgumentMatchers.anyList;\n import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n import static org.mockito.Mockito.times;\n import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n \n import android.content.ComponentName;\n+import android.content.Context;\n+import android.content.pm.PackageManager;\n+import android.content.pm.ResolveInfo;\n+import android.content.pm.ServiceInfo;\n import android.provider.Settings;\n \n+import androidx.test.core.app.ApplicationProvider;\n+\n+import com.google.common.collect.ImmutableList;\n+\n import org.junit.Before;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n+import org.mockito.ArgumentCaptor;\n import org.robolectric.RobolectricTestRunner;\n import org.robolectric.RuntimeEnvironment;\n \n+import java.util.List;\n+\n @RunWith(RobolectricTestRunner.class)\n public class ServiceListingTest {\n \n@@ -39,16 +54,97 @@ public class ServiceListingTest {\n     private static final String TEST_INTENT = \"com.example.intent\";\n \n     private ServiceListing mServiceListing;\n+    private Context mContext;\n+    private PackageManager mPm;\n \n     @Before\n     public void setUp() {\n-        mServiceListing = new ServiceListing.Builder(RuntimeEnvironment.application)\n+        mPm = mock(PackageManager.class);\n+        mContext = spy(ApplicationProvider.getApplicationContext());\n+        when(mContext.getPackageManager()).thenReturn(mPm);\n+\n+        mServiceListing = new ServiceListing.Builder(mContext)\n+                .setTag(\"testTag\")\n+                .setSetting(TEST_SETTING)\n+                .setNoun(\"testNoun\")\n+                .setIntentAction(TEST_INTENT)\n+                .setPermission(\"testPermission\")\n+                .build();\n+    }\n+\n+    @Test\n+    public void testValidator() {\n+        ServiceInfo s1 = new ServiceInfo();\n+        s1.permission = \"testPermission\";\n+        s1.packageName = \"pkg\";\n+        ServiceInfo s2 = new ServiceInfo();\n+        s2.permission = \"testPermission\";\n+        s2.packageName = \"pkg2\";\n+        ResolveInfo r1 = new ResolveInfo();\n+        r1.serviceInfo = s1;\n+        ResolveInfo r2 = new ResolveInfo();\n+        r2.serviceInfo = s2;\n+\n+        when(mPm.queryIntentServicesAsUser(any(), anyInt(), anyInt())).thenReturn(\n+                ImmutableList.of(r1, r2));\n+\n+        mServiceListing = new ServiceListing.Builder(mContext)\n+                .setTag(\"testTag\")\n+                .setSetting(TEST_SETTING)\n+                .setNoun(\"testNoun\")\n+                .setIntentAction(TEST_INTENT)\n+                .setValidator(info -> {\n+                    if (info.packageName.equals(\"pkg\")) {\n+                        return true;\n+                    }\n+                    return false;\n+                })\n+                .setPermission(\"testPermission\")\n+                .build();\n+        ServiceListing.Callback callback = mock(ServiceListing.Callback.class);\n+        mServiceListing.addCallback(callback);\n+        mServiceListing.reload();\n+\n+        verify(mPm).queryIntentServicesAsUser(any(), anyInt(), anyInt());\n+        ArgumentCaptor<List<ServiceInfo>> captor = ArgumentCaptor.forClass(List.class);\n+        verify(callback, times(1)).onServicesReloaded(captor.capture());\n+\n+        assertThat(captor.getValue().size()).isEqualTo(1);\n+        assertThat(captor.getValue().get(0)).isEqualTo(s1);\n+    }\n+\n+    @Test\n+    public void testNoValidator() {\n+        ServiceInfo s1 = new ServiceInfo();\n+        s1.permission = \"testPermission\";\n+        s1.packageName = \"pkg\";\n+        ServiceInfo s2 = new ServiceInfo();\n+        s2.permission = \"testPermission\";\n+        s2.packageName = \"pkg2\";\n+        ResolveInfo r1 = new ResolveInfo();\n+        r1.serviceInfo = s1;\n+        ResolveInfo r2 = new ResolveInfo();\n+        r2.serviceInfo = s2;\n+\n+        when(mPm.queryIntentServicesAsUser(any(), anyInt(), anyInt())).thenReturn(\n+                ImmutableList.of(r1, r2));\n+\n+        mServiceListing = new ServiceListing.Builder(mContext)\n                 .setTag(\"testTag\")\n                 .setSetting(TEST_SETTING)\n                 .setNoun(\"testNoun\")\n                 .setIntentAction(TEST_INTENT)\n                 .setPermission(\"testPermission\")\n                 .build();\n+        ServiceListing.Callback callback = mock(ServiceListing.Callback.class);\n+        mServiceListing.addCallback(callback);\n+        mServiceListing.reload();\n+\n+        verify(mPm).queryIntentServicesAsUser(any(), anyInt(), anyInt());\n+        ArgumentCaptor<List<ServiceInfo>> captor = ArgumentCaptor.forClass(List.class);\n+        verify(callback, times(1)).onServicesReloaded(captor.capture());\n+\n+        assertThat(captor.getValue().size()).isEqualTo(2);\n     }\n \n     @Test\n",
    "added_lines": 97,
    "deleted_lines": 1,
    "changed_methods": "ServiceListingTest::testValidator, ServiceListingTest::testNoValidator, ServiceListingTest::setUp"
   }
  ]
 },
 {
  "hash": "2510c72e34c660e42599f9866ca846395ba1aebf",
  "commit": "Allow filtering of services\n\nTest: ServiceListingTest\nBug: 260570119\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:a9c75de2b4ae92f4b7e7aade8433fd44ef376e11)\nMerged-In: Ib4740ba401667de62fa1a33334c2c1fbee25b760\nChange-Id: Ib4740ba401667de62fa1a33334c2c1fbee25b760",
  "files": [
   {
    "filename": "ServiceListing.java",
    "diff": "@@ -35,6 +35,7 @@ import android.util.Slog;\n import java.util.ArrayList;\n import java.util.HashSet;\n import java.util.List;\n+import java.util.function.Predicate;\n \n /**\n  * Class for managing services matching a given intent and requesting a given permission.\n@@ -51,12 +52,13 @@ public class ServiceListing {\n     private final HashSet<ComponentName> mEnabledServices = new HashSet<>();\n     private final List<ServiceInfo> mServices = new ArrayList<>();\n     private final List<Callback> mCallbacks = new ArrayList<>();\n+    private final Predicate mValidator;\n \n     private boolean mListening;\n \n     private ServiceListing(Context context, String tag,\n             String setting, String intentAction, String permission, String noun,\n-            boolean addDeviceLockedFlags) {\n+            boolean addDeviceLockedFlags, Predicate validator) {\n         mContentResolver = context.getContentResolver();\n         mContext = context;\n         mTag = tag;\n@@ -65,6 +67,7 @@ public class ServiceListing {\n         mPermission = permission;\n         mNoun = noun;\n         mAddDeviceLockedFlags = addDeviceLockedFlags;\n+        mValidator = validator;\n     }\n \n     public void addCallback(Callback callback) {\n@@ -137,7 +140,6 @@ public class ServiceListing {\n         final PackageManager pmWrapper = mContext.getPackageManager();\n         List<ResolveInfo> installedServices = pmWrapper.queryIntentServicesAsUser(\n                 new Intent(mIntentAction), flags, user);\n-\n         for (ResolveInfo resolveInfo : installedServices) {\n             ServiceInfo info = resolveInfo.serviceInfo;\n \n@@ -148,6 +150,9 @@ public class ServiceListing {\n                         + mPermission);\n                 continue;\n             }\n+            if (mValidator != null && !mValidator.test(info)) {\n+                continue;\n+            }\n             mServices.add(info);\n         }\n         for (Callback callback : mCallbacks) {\n@@ -194,6 +199,7 @@ public class ServiceListing {\n         private String mPermission;\n         private String mNoun;\n         private boolean mAddDeviceLockedFlags = false;\n+        private Predicate mValidator;\n \n         public Builder(Context context) {\n             mContext = context;\n@@ -224,6 +230,11 @@ public class ServiceListing {\n             return this;\n         }\n \n+        public Builder setValidator(Predicate<ServiceInfo> validator) {\n+            mValidator = validator;\n+            return this;\n+        }\n+\n         /**\n          * Set to true to add support for both MATCH_DIRECT_BOOT_AWARE and\n          * MATCH_DIRECT_BOOT_UNAWARE flags when querying PackageManager. Required to get results\n@@ -236,7 +247,7 @@ public class ServiceListing {\n \n         public ServiceListing build() {\n             return new ServiceListing(mContext, mTag, mSetting, mIntentAction, mPermission, mNoun,\n-                    mAddDeviceLockedFlags);\n+                    mAddDeviceLockedFlags, mValidator);\n         }\n     }\n }\n",
    "added_lines": 14,
    "deleted_lines": 3,
    "changed_methods": "ServiceListing::ServiceListing, ServiceListing::reload, ServiceListing::Builder::build, ServiceListing::Builder::setValidator, ServiceListing::ServiceListing"
   },
   {
    "filename": "ServiceListingTest.java",
    "diff": "@@ -18,20 +18,35 @@ package com.android.settingslib.applications;\n \n import static com.google.common.truth.Truth.assertThat;\n \n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyInt;\n import static org.mockito.ArgumentMatchers.anyList;\n import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n import static org.mockito.Mockito.times;\n import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n \n import android.content.ComponentName;\n+import android.content.Context;\n+import android.content.pm.PackageManager;\n+import android.content.pm.ResolveInfo;\n+import android.content.pm.ServiceInfo;\n import android.provider.Settings;\n \n+import androidx.test.core.app.ApplicationProvider;\n+\n+import com.google.common.collect.ImmutableList;\n+\n import org.junit.Before;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n+import org.mockito.ArgumentCaptor;\n import org.robolectric.RobolectricTestRunner;\n import org.robolectric.RuntimeEnvironment;\n \n+import java.util.List;\n+\n @RunWith(RobolectricTestRunner.class)\n public class ServiceListingTest {\n \n@@ -39,16 +54,97 @@ public class ServiceListingTest {\n     private static final String TEST_INTENT = \"com.example.intent\";\n \n     private ServiceListing mServiceListing;\n+    private Context mContext;\n+    private PackageManager mPm;\n \n     @Before\n     public void setUp() {\n-        mServiceListing = new ServiceListing.Builder(RuntimeEnvironment.application)\n+        mPm = mock(PackageManager.class);\n+        mContext = spy(ApplicationProvider.getApplicationContext());\n+        when(mContext.getPackageManager()).thenReturn(mPm);\n+\n+        mServiceListing = new ServiceListing.Builder(mContext)\n+                .setTag(\"testTag\")\n+                .setSetting(TEST_SETTING)\n+                .setNoun(\"testNoun\")\n+                .setIntentAction(TEST_INTENT)\n+                .setPermission(\"testPermission\")\n+                .build();\n+    }\n+\n+    @Test\n+    public void testValidator() {\n+        ServiceInfo s1 = new ServiceInfo();\n+        s1.permission = \"testPermission\";\n+        s1.packageName = \"pkg\";\n+        ServiceInfo s2 = new ServiceInfo();\n+        s2.permission = \"testPermission\";\n+        s2.packageName = \"pkg2\";\n+        ResolveInfo r1 = new ResolveInfo();\n+        r1.serviceInfo = s1;\n+        ResolveInfo r2 = new ResolveInfo();\n+        r2.serviceInfo = s2;\n+\n+        when(mPm.queryIntentServicesAsUser(any(), anyInt(), anyInt())).thenReturn(\n+                ImmutableList.of(r1, r2));\n+\n+        mServiceListing = new ServiceListing.Builder(mContext)\n+                .setTag(\"testTag\")\n+                .setSetting(TEST_SETTING)\n+                .setNoun(\"testNoun\")\n+                .setIntentAction(TEST_INTENT)\n+                .setValidator(info -> {\n+                    if (info.packageName.equals(\"pkg\")) {\n+                        return true;\n+                    }\n+                    return false;\n+                })\n+                .setPermission(\"testPermission\")\n+                .build();\n+        ServiceListing.Callback callback = mock(ServiceListing.Callback.class);\n+        mServiceListing.addCallback(callback);\n+        mServiceListing.reload();\n+\n+        verify(mPm).queryIntentServicesAsUser(any(), anyInt(), anyInt());\n+        ArgumentCaptor<List<ServiceInfo>> captor = ArgumentCaptor.forClass(List.class);\n+        verify(callback, times(1)).onServicesReloaded(captor.capture());\n+\n+        assertThat(captor.getValue().size()).isEqualTo(1);\n+        assertThat(captor.getValue().get(0)).isEqualTo(s1);\n+    }\n+\n+    @Test\n+    public void testNoValidator() {\n+        ServiceInfo s1 = new ServiceInfo();\n+        s1.permission = \"testPermission\";\n+        s1.packageName = \"pkg\";\n+        ServiceInfo s2 = new ServiceInfo();\n+        s2.permission = \"testPermission\";\n+        s2.packageName = \"pkg2\";\n+        ResolveInfo r1 = new ResolveInfo();\n+        r1.serviceInfo = s1;\n+        ResolveInfo r2 = new ResolveInfo();\n+        r2.serviceInfo = s2;\n+\n+        when(mPm.queryIntentServicesAsUser(any(), anyInt(), anyInt())).thenReturn(\n+                ImmutableList.of(r1, r2));\n+\n+        mServiceListing = new ServiceListing.Builder(mContext)\n                 .setTag(\"testTag\")\n                 .setSetting(TEST_SETTING)\n                 .setNoun(\"testNoun\")\n                 .setIntentAction(TEST_INTENT)\n                 .setPermission(\"testPermission\")\n                 .build();\n+        ServiceListing.Callback callback = mock(ServiceListing.Callback.class);\n+        mServiceListing.addCallback(callback);\n+        mServiceListing.reload();\n+\n+        verify(mPm).queryIntentServicesAsUser(any(), anyInt(), anyInt());\n+        ArgumentCaptor<List<ServiceInfo>> captor = ArgumentCaptor.forClass(List.class);\n+        verify(callback, times(1)).onServicesReloaded(captor.capture());\n+\n+        assertThat(captor.getValue().size()).isEqualTo(2);\n     }\n \n     @Test\n",
    "added_lines": 97,
    "deleted_lines": 1,
    "changed_methods": "ServiceListingTest::testValidator, ServiceListingTest::testNoValidator, ServiceListingTest::setUp"
   }
  ]
 },
 {
  "hash": "645206dd8566eb1b4ca286b4c0ede04b4e057fd4",
  "commit": "Enforce DevicePolicyManager.setUserControlDisabledPackages in AppStandbyController\n\nWhen deciding an app's standby bucket, check if the\napp has its user control disabled by an IT admin. If so,\nthe app should be the exempted restricted bucket.\n\nBug: 272042183\nTest: atest AppStandbyControllerTests\n(cherry picked from commit 269fcb6873dee199dd8023831f882aafff1f6291)\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:3dbab873d6d8f78c4d498a575ad37fd0dc20efbe)\nMerged-In: I4279dc37f0e17aedb1c2a87468478248443a253e\nChange-Id: I4279dc37f0e17aedb1c2a87468478248443a253e",
  "files": [
   {
    "filename": "AppStandbyInternal.java",
    "diff": "@@ -157,6 +157,8 @@ public interface AppStandbyInternal {\n \n     void setActiveAdminApps(Set<String> adminPkgs, int userId);\n \n+    void setAdminProtectedPackages(Set<String> packageNames, int userId);\n+\n     void onAdminDataAvailable();\n \n     void clearCarrierPrivilegedApps();\n",
    "added_lines": 2,
    "deleted_lines": 0,
    "changed_methods": ""
   },
   {
    "filename": "AppStandbyController.java",
    "diff": "@@ -247,6 +247,10 @@ public class AppStandbyController\n     @GuardedBy(\"mActiveAdminApps\")\n     private final SparseArray<Set<String>> mActiveAdminApps = new SparseArray<>();\n \n+    /** List of admin protected packages. Can contain {@link android.os.UserHandle#USER_ALL}. */\n+    @GuardedBy(\"mAdminProtectedPackages\")\n+    private final SparseArray<Set<String>> mAdminProtectedPackages = new SparseArray<>();\n+\n     /**\n      * Set of system apps that are headless (don't have any declared activities, enabled or\n      * disabled). Presence in this map indicates that the app is a headless system app.\n@@ -1088,6 +1092,9 @@ public class AppStandbyController\n             synchronized (mActiveAdminApps) {\n                 mActiveAdminApps.remove(userId);\n             }\n+            synchronized (mAdminProtectedPackages) {\n+                mAdminProtectedPackages.remove(userId);\n+            }\n         }\n     }\n \n@@ -1177,6 +1184,10 @@ public class AppStandbyController\n                 return STANDBY_BUCKET_EXEMPTED;\n             }\n \n+            if (isAdminProtectedPackages(packageName, userId)) {\n+                return STANDBY_BUCKET_EXEMPTED;\n+            }\n+\n             if (isActiveNetworkScorer(packageName)) {\n                 return STANDBY_BUCKET_EXEMPTED;\n             }\n@@ -1583,6 +1594,17 @@ public class AppStandbyController\n         }\n     }\n \n+    private boolean isAdminProtectedPackages(String packageName, int userId) {\n+        synchronized (mAdminProtectedPackages) {\n+            if (mAdminProtectedPackages.contains(UserHandle.USER_ALL)\n+                    && mAdminProtectedPackages.get(UserHandle.USER_ALL).contains(packageName)) {\n+                return true;\n+            }\n+            return mAdminProtectedPackages.contains(userId)\n+                    && mAdminProtectedPackages.get(userId).contains(packageName);\n+        }\n+    }\n+\n     @Override\n     public void addActiveDeviceAdmin(String adminPkg, int userId) {\n         synchronized (mActiveAdminApps) {\n@@ -1606,6 +1628,17 @@ public class AppStandbyController\n         }\n     }\n \n+    @Override\n+    public void setAdminProtectedPackages(Set<String> packageNames, int userId) {\n+        synchronized (mAdminProtectedPackages) {\n+            if (packageNames == null || packageNames.isEmpty()) {\n+                mAdminProtectedPackages.remove(userId);\n+            } else {\n+                mAdminProtectedPackages.put(userId, packageNames);\n+            }\n+        }\n+    }\n+\n     @Override\n     public void onAdminDataAvailable() {\n         mAdminDataAvailableLatch.countDown();\n@@ -1628,6 +1661,13 @@ public class AppStandbyController\n         }\n     }\n \n+    @VisibleForTesting\n+    Set<String> getAdminProtectedPackagesForTest(int userId) {\n+        synchronized (mAdminProtectedPackages) {\n+            return mAdminProtectedPackages.get(userId);\n+        }\n+    }\n+\n     /**\n      * Returns {@code true} if the supplied package is the device provisioning app. Otherwise,\n      * returns {@code false}.\n",
    "added_lines": 40,
    "deleted_lines": 0,
    "changed_methods": "AppStandbyController::getAppMinBucket, AppStandbyController::getAdminProtectedPackagesForTest, AppStandbyController::onUserRemoved, AppStandbyController::isAdminProtectedPackages, AppStandbyController::setAdminProtectedPackages"
   },
   {
    "filename": "DevicePolicyManager.java",
    "diff": "@@ -13573,7 +13573,8 @@ public class DevicePolicyManager {\n \n     /**\n      * Called by Device owner to disable user control over apps. User will not be able to clear\n-     * app data or force-stop packages.\n+     * app data or force-stop packages. Packages with user control disabled are exempted from\n+     * App Standby Buckets.\n      *\n      * @param admin which {@link DeviceAdminReceiver} this request is associated with\n      * @param packages The package names for the apps.\n",
    "added_lines": 2,
    "deleted_lines": 1,
    "changed_methods": ""
   },
   {
    "filename": "UsageStatsManagerInternal.java",
    "diff": "@@ -198,6 +198,16 @@ public abstract class UsageStatsManagerInternal {\n      */\n     public abstract void setActiveAdminApps(Set<String> adminApps, int userId);\n \n+    /**\n+     * Called by DevicePolicyManagerService to inform about the protected packages for a user.\n+     * User control will be disabled for protected packages.\n+     *\n+     * @param packageNames the set of protected packages for {@code userId}.\n+     * @param userId the userId to which the protected packages belong.\n+     */\n+    public abstract void setAdminProtectedPackages(@Nullable Set<String> packageNames,\n+            @UserIdInt int userId);\n+\n     /**\n      * Called by DevicePolicyManagerService during boot to inform that admin data is loaded and\n      * pushed to UsageStatsService.\n",
    "added_lines": 10,
    "deleted_lines": 0,
    "changed_methods": ""
   },
   {
    "filename": "DevicePolicyManagerService.java",
    "diff": "@@ -1341,7 +1341,7 @@ public class DevicePolicyManagerService extends BaseIDevicePolicyManager {\n         Owners newOwners() {\n             return new Owners(getUserManager(), getUserManagerInternal(),\n                     getPackageManagerInternal(), getActivityTaskManagerInternal(),\n-                    getActivityManagerInternal());\n+                    getActivityManagerInternal(), getUsageStatsManagerInternal());\n         }\n \n         UserManager getUserManager() {\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "DevicePolicyManagerService::Injector::newOwners"
   },
   {
    "filename": "Owners.java",
    "diff": "@@ -24,6 +24,7 @@ import android.app.AppOpsManagerInternal;\n import android.app.admin.DevicePolicyManager.DeviceOwnerType;\n import android.app.admin.SystemUpdateInfo;\n import android.app.admin.SystemUpdatePolicy;\n+import android.app.usage.UsageStatsManagerInternal;\n import android.content.ComponentName;\n import android.content.pm.PackageManager;\n import android.content.pm.PackageManagerInternal;\n@@ -123,6 +124,7 @@ class Owners {\n     private final PackageManagerInternal mPackageManagerInternal;\n     private final ActivityTaskManagerInternal mActivityTaskManagerInternal;\n     private final ActivityManagerInternal mActivityManagerInternal;\n+    private final UsageStatsManagerInternal mUsageStatsManagerInternal;\n \n     private boolean mSystemReady;\n \n@@ -155,9 +157,11 @@ class Owners {\n             UserManagerInternal userManagerInternal,\n             PackageManagerInternal packageManagerInternal,\n             ActivityTaskManagerInternal activityTaskManagerInternal,\n-            ActivityManagerInternal activitykManagerInternal) {\n+            ActivityManagerInternal activitykManagerInternal,\n+            UsageStatsManagerInternal usageStatsManagerInternal) {\n         this(userManager, userManagerInternal, packageManagerInternal,\n-                activityTaskManagerInternal, activitykManagerInternal, new Injector());\n+                activityTaskManagerInternal, activitykManagerInternal,\n+                usageStatsManagerInternal, new Injector());\n     }\n \n     @VisibleForTesting\n@@ -166,12 +170,14 @@ class Owners {\n             PackageManagerInternal packageManagerInternal,\n             ActivityTaskManagerInternal activityTaskManagerInternal,\n             ActivityManagerInternal activityManagerInternal,\n+            UsageStatsManagerInternal usageStatsManagerInternal,\n             Injector injector) {\n         mUserManager = userManager;\n         mUserManagerInternal = userManagerInternal;\n         mPackageManagerInternal = packageManagerInternal;\n         mActivityTaskManagerInternal = activityTaskManagerInternal;\n         mActivityManagerInternal = activityManagerInternal;\n+        mUsageStatsManagerInternal = usageStatsManagerInternal;\n         mInjector = injector;\n     }\n \n@@ -226,6 +232,8 @@ class Owners {\n                     mDeviceOwnerProtectedPackages.entrySet()) {\n                 mPackageManagerInternal.setDeviceOwnerProtectedPackages(\n                         entry.getKey(), entry.getValue());\n+                mUsageStatsManagerInternal.setAdminProtectedPackages(\n+                        new ArraySet(entry.getValue()), UserHandle.USER_ALL);\n             }\n         }\n     }\n@@ -359,6 +367,8 @@ class Owners {\n             if (protectedPackages != null) {\n                 mPackageManagerInternal.setDeviceOwnerProtectedPackages(\n                         mDeviceOwner.packageName, new ArrayList<>());\n+                mUsageStatsManagerInternal.setAdminProtectedPackages(\n+                        Collections.emptySet(), UserHandle.USER_ALL);\n             }\n             mDeviceOwner = null;\n             mDeviceOwnerUserId = UserHandle.USER_NULL;\n@@ -416,6 +426,8 @@ class Owners {\n             if (previousProtectedPackages != null) {\n                 mPackageManagerInternal.setDeviceOwnerProtectedPackages(\n                         mDeviceOwner.packageName, new ArrayList<>());\n+                mUsageStatsManagerInternal.setAdminProtectedPackages(\n+                        Collections.emptySet(), UserHandle.USER_ALL);\n             }\n             // We don't set a name because it's not used anyway.\n             // See DevicePolicyManagerService#getDeviceOwnerName\n@@ -684,6 +696,8 @@ class Owners {\n \n             mDeviceOwnerProtectedPackages.put(packageName, protectedPackages);\n             mPackageManagerInternal.setDeviceOwnerProtectedPackages(packageName, protectedPackages);\n+            mUsageStatsManagerInternal.setAdminProtectedPackages(\n+                        new ArraySet(protectedPackages), UserHandle.USER_ALL);\n             writeDeviceOwner();\n         }\n     }\n",
    "added_lines": 16,
    "deleted_lines": 2,
    "changed_methods": "Owners::transferDeviceOwnership, Owners::clearDeviceOwner, Owners::load, Owners::setDeviceOwnerProtectedPackages, Owners::Owners, Owners::Owners, Owners::Owners"
   },
   {
    "filename": "DevicePolicyManagerServiceTestable.java",
    "diff": "@@ -69,7 +69,8 @@ public class DevicePolicyManagerServiceTestable extends DevicePolicyManagerServi\n         public OwnersTestable(MockSystemServices services) {\n             super(services.userManager, services.userManagerInternal,\n                     services.packageManagerInternal, services.activityTaskManagerInternal,\n-                    services.activityManagerInternal, new MockInjector(services));\n+                    services.activityManagerInternal, services.usageStatsManagerInternal,\n+                    new MockInjector(services));\n         }\n \n         static class MockInjector extends Injector {\n",
    "added_lines": 2,
    "deleted_lines": 1,
    "changed_methods": "DevicePolicyManagerServiceTestable::OwnersTestable::OwnersTestable"
   },
   {
    "filename": "AppStandbyControllerTests.java",
    "diff": "@@ -152,6 +152,9 @@ public class AppStandbyControllerTests {\n     private static final String ADMIN_PKG2 = \"com.android.admin2\";\n     private static final String ADMIN_PKG3 = \"com.android.admin3\";\n \n+    private static final String ADMIN_PROTECTED_PKG = \"com.android.admin.protected\";\n+    private static final String ADMIN_PROTECTED_PKG2 = \"com.android.admin.protected2\";\n+\n     private static final long MINUTE_MS = 60 * 1000;\n     private static final long HOUR_MS = 60 * MINUTE_MS;\n     private static final long DAY_MS = 24 * HOUR_MS;\n@@ -1631,6 +1634,19 @@ public class AppStandbyControllerTests {\n         assertIsNotActiveAdmin(ADMIN_PKG2, USER_ID);\n     }\n \n+    @Test\n+    public void testSetAdminProtectedPackages() {\n+        assertAdminProtectedPackagesForTest(USER_ID, (String[]) null);\n+        assertAdminProtectedPackagesForTest(USER_ID2, (String[]) null);\n+\n+        setAdminProtectedPackages(USER_ID, ADMIN_PROTECTED_PKG, ADMIN_PROTECTED_PKG2);\n+        assertAdminProtectedPackagesForTest(USER_ID, ADMIN_PROTECTED_PKG, ADMIN_PROTECTED_PKG2);\n+        assertAdminProtectedPackagesForTest(USER_ID2, (String[]) null);\n+\n+        setAdminProtectedPackages(USER_ID, (String[]) null);\n+        assertAdminProtectedPackagesForTest(USER_ID, (String[]) null);\n+    }\n+\n     @Test\n     @FlakyTest(bugId = 185169504)\n     public void testUserInteraction_CrossProfile() throws Exception {\n@@ -2025,6 +2041,28 @@ public class AppStandbyControllerTests {\n         mController.setActiveAdminApps(new ArraySet<>(Arrays.asList(admins)), userId);\n     }\n \n+    private void setAdminProtectedPackages(int userId, String... packageNames) {\n+        Set<String> adminProtectedPackages = packageNames != null ? new ArraySet<>(\n+                Arrays.asList(packageNames)) : null;\n+        mController.setAdminProtectedPackages(adminProtectedPackages, userId);\n+    }\n+\n+    private void assertAdminProtectedPackagesForTest(int userId, String... packageNames) {\n+        final Set<String> actualAdminProtectedPackages =\n+                mController.getAdminProtectedPackagesForTest(userId);\n+        if (packageNames == null) {\n+            if (actualAdminProtectedPackages != null && !actualAdminProtectedPackages.isEmpty()) {\n+                fail(\"Admin protected packages should be null; \" + getAdminAppsStr(userId,\n+                        actualAdminProtectedPackages));\n+            }\n+            return;\n+        }\n+        assertEquals(packageNames.length, actualAdminProtectedPackages.size());\n+        for (String adminProtectedPackage : packageNames) {\n+            assertTrue(actualAdminProtectedPackages.contains(adminProtectedPackage));\n+        }\n+    }\n+\n     private void setAndAssertBucket(String pkg, int user, int bucket, int reason) throws Exception {\n         rearmLatch(pkg);\n         mController.setAppStandbyBucket(pkg, user, bucket, reason);\n",
    "added_lines": 38,
    "deleted_lines": 0,
    "changed_methods": "AppStandbyControllerTests::testSetAdminProtectedPackages, AppStandbyControllerTests::assertAdminProtectedPackagesForTest, AppStandbyControllerTests::setAdminProtectedPackages"
   },
   {
    "filename": "UsageStatsService.java",
    "diff": "@@ -2494,6 +2494,11 @@ public class UsageStatsService extends SystemService implements\n             mAppStandby.setActiveAdminApps(packageNames, userId);\n         }\n \n+        @Override\n+        public void setAdminProtectedPackages(Set<String> packageNames, int userId) {\n+            mAppStandby.setAdminProtectedPackages(packageNames, userId);\n+        }\n+\n         @Override\n         public void onAdminDataAvailable() {\n             mAppStandby.onAdminDataAvailable();\n",
    "added_lines": 5,
    "deleted_lines": 0,
    "changed_methods": "UsageStatsService::LocalService::setAdminProtectedPackages"
   }
  ]
 },
 {
  "hash": "645206dd8566eb1b4ca286b4c0ede04b4e057fd4",
  "commit": "Enforce DevicePolicyManager.setUserControlDisabledPackages in AppStandbyController\n\nWhen deciding an app's standby bucket, check if the\napp has its user control disabled by an IT admin. If so,\nthe app should be the exempted restricted bucket.\n\nBug: 272042183\nTest: atest AppStandbyControllerTests\n(cherry picked from commit 269fcb6873dee199dd8023831f882aafff1f6291)\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:3dbab873d6d8f78c4d498a575ad37fd0dc20efbe)\nMerged-In: I4279dc37f0e17aedb1c2a87468478248443a253e\nChange-Id: I4279dc37f0e17aedb1c2a87468478248443a253e",
  "files": [
   {
    "filename": "AppStandbyInternal.java",
    "diff": "@@ -157,6 +157,8 @@ public interface AppStandbyInternal {\n \n     void setActiveAdminApps(Set<String> adminPkgs, int userId);\n \n+    void setAdminProtectedPackages(Set<String> packageNames, int userId);\n+\n     void onAdminDataAvailable();\n \n     void clearCarrierPrivilegedApps();\n",
    "added_lines": 2,
    "deleted_lines": 0,
    "changed_methods": ""
   },
   {
    "filename": "AppStandbyController.java",
    "diff": "@@ -247,6 +247,10 @@ public class AppStandbyController\n     @GuardedBy(\"mActiveAdminApps\")\n     private final SparseArray<Set<String>> mActiveAdminApps = new SparseArray<>();\n \n+    /** List of admin protected packages. Can contain {@link android.os.UserHandle#USER_ALL}. */\n+    @GuardedBy(\"mAdminProtectedPackages\")\n+    private final SparseArray<Set<String>> mAdminProtectedPackages = new SparseArray<>();\n+\n     /**\n      * Set of system apps that are headless (don't have any declared activities, enabled or\n      * disabled). Presence in this map indicates that the app is a headless system app.\n@@ -1088,6 +1092,9 @@ public class AppStandbyController\n             synchronized (mActiveAdminApps) {\n                 mActiveAdminApps.remove(userId);\n             }\n+            synchronized (mAdminProtectedPackages) {\n+                mAdminProtectedPackages.remove(userId);\n+            }\n         }\n     }\n \n@@ -1177,6 +1184,10 @@ public class AppStandbyController\n                 return STANDBY_BUCKET_EXEMPTED;\n             }\n \n+            if (isAdminProtectedPackages(packageName, userId)) {\n+                return STANDBY_BUCKET_EXEMPTED;\n+            }\n+\n             if (isActiveNetworkScorer(packageName)) {\n                 return STANDBY_BUCKET_EXEMPTED;\n             }\n@@ -1583,6 +1594,17 @@ public class AppStandbyController\n         }\n     }\n \n+    private boolean isAdminProtectedPackages(String packageName, int userId) {\n+        synchronized (mAdminProtectedPackages) {\n+            if (mAdminProtectedPackages.contains(UserHandle.USER_ALL)\n+                    && mAdminProtectedPackages.get(UserHandle.USER_ALL).contains(packageName)) {\n+                return true;\n+            }\n+            return mAdminProtectedPackages.contains(userId)\n+                    && mAdminProtectedPackages.get(userId).contains(packageName);\n+        }\n+    }\n+\n     @Override\n     public void addActiveDeviceAdmin(String adminPkg, int userId) {\n         synchronized (mActiveAdminApps) {\n@@ -1606,6 +1628,17 @@ public class AppStandbyController\n         }\n     }\n \n+    @Override\n+    public void setAdminProtectedPackages(Set<String> packageNames, int userId) {\n+        synchronized (mAdminProtectedPackages) {\n+            if (packageNames == null || packageNames.isEmpty()) {\n+                mAdminProtectedPackages.remove(userId);\n+            } else {\n+                mAdminProtectedPackages.put(userId, packageNames);\n+            }\n+        }\n+    }\n+\n     @Override\n     public void onAdminDataAvailable() {\n         mAdminDataAvailableLatch.countDown();\n@@ -1628,6 +1661,13 @@ public class AppStandbyController\n         }\n     }\n \n+    @VisibleForTesting\n+    Set<String> getAdminProtectedPackagesForTest(int userId) {\n+        synchronized (mAdminProtectedPackages) {\n+            return mAdminProtectedPackages.get(userId);\n+        }\n+    }\n+\n     /**\n      * Returns {@code true} if the supplied package is the device provisioning app. Otherwise,\n      * returns {@code false}.\n",
    "added_lines": 40,
    "deleted_lines": 0,
    "changed_methods": "AppStandbyController::getAppMinBucket, AppStandbyController::getAdminProtectedPackagesForTest, AppStandbyController::onUserRemoved, AppStandbyController::isAdminProtectedPackages, AppStandbyController::setAdminProtectedPackages"
   },
   {
    "filename": "DevicePolicyManager.java",
    "diff": "@@ -13573,7 +13573,8 @@ public class DevicePolicyManager {\n \n     /**\n      * Called by Device owner to disable user control over apps. User will not be able to clear\n-     * app data or force-stop packages.\n+     * app data or force-stop packages. Packages with user control disabled are exempted from\n+     * App Standby Buckets.\n      *\n      * @param admin which {@link DeviceAdminReceiver} this request is associated with\n      * @param packages The package names for the apps.\n",
    "added_lines": 2,
    "deleted_lines": 1,
    "changed_methods": ""
   },
   {
    "filename": "UsageStatsManagerInternal.java",
    "diff": "@@ -198,6 +198,16 @@ public abstract class UsageStatsManagerInternal {\n      */\n     public abstract void setActiveAdminApps(Set<String> adminApps, int userId);\n \n+    /**\n+     * Called by DevicePolicyManagerService to inform about the protected packages for a user.\n+     * User control will be disabled for protected packages.\n+     *\n+     * @param packageNames the set of protected packages for {@code userId}.\n+     * @param userId the userId to which the protected packages belong.\n+     */\n+    public abstract void setAdminProtectedPackages(@Nullable Set<String> packageNames,\n+            @UserIdInt int userId);\n+\n     /**\n      * Called by DevicePolicyManagerService during boot to inform that admin data is loaded and\n      * pushed to UsageStatsService.\n",
    "added_lines": 10,
    "deleted_lines": 0,
    "changed_methods": ""
   },
   {
    "filename": "DevicePolicyManagerService.java",
    "diff": "@@ -1341,7 +1341,7 @@ public class DevicePolicyManagerService extends BaseIDevicePolicyManager {\n         Owners newOwners() {\n             return new Owners(getUserManager(), getUserManagerInternal(),\n                     getPackageManagerInternal(), getActivityTaskManagerInternal(),\n-                    getActivityManagerInternal());\n+                    getActivityManagerInternal(), getUsageStatsManagerInternal());\n         }\n \n         UserManager getUserManager() {\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "DevicePolicyManagerService::Injector::newOwners"
   },
   {
    "filename": "Owners.java",
    "diff": "@@ -24,6 +24,7 @@ import android.app.AppOpsManagerInternal;\n import android.app.admin.DevicePolicyManager.DeviceOwnerType;\n import android.app.admin.SystemUpdateInfo;\n import android.app.admin.SystemUpdatePolicy;\n+import android.app.usage.UsageStatsManagerInternal;\n import android.content.ComponentName;\n import android.content.pm.PackageManager;\n import android.content.pm.PackageManagerInternal;\n@@ -123,6 +124,7 @@ class Owners {\n     private final PackageManagerInternal mPackageManagerInternal;\n     private final ActivityTaskManagerInternal mActivityTaskManagerInternal;\n     private final ActivityManagerInternal mActivityManagerInternal;\n+    private final UsageStatsManagerInternal mUsageStatsManagerInternal;\n \n     private boolean mSystemReady;\n \n@@ -155,9 +157,11 @@ class Owners {\n             UserManagerInternal userManagerInternal,\n             PackageManagerInternal packageManagerInternal,\n             ActivityTaskManagerInternal activityTaskManagerInternal,\n-            ActivityManagerInternal activitykManagerInternal) {\n+            ActivityManagerInternal activitykManagerInternal,\n+            UsageStatsManagerInternal usageStatsManagerInternal) {\n         this(userManager, userManagerInternal, packageManagerInternal,\n-                activityTaskManagerInternal, activitykManagerInternal, new Injector());\n+                activityTaskManagerInternal, activitykManagerInternal,\n+                usageStatsManagerInternal, new Injector());\n     }\n \n     @VisibleForTesting\n@@ -166,12 +170,14 @@ class Owners {\n             PackageManagerInternal packageManagerInternal,\n             ActivityTaskManagerInternal activityTaskManagerInternal,\n             ActivityManagerInternal activityManagerInternal,\n+            UsageStatsManagerInternal usageStatsManagerInternal,\n             Injector injector) {\n         mUserManager = userManager;\n         mUserManagerInternal = userManagerInternal;\n         mPackageManagerInternal = packageManagerInternal;\n         mActivityTaskManagerInternal = activityTaskManagerInternal;\n         mActivityManagerInternal = activityManagerInternal;\n+        mUsageStatsManagerInternal = usageStatsManagerInternal;\n         mInjector = injector;\n     }\n \n@@ -226,6 +232,8 @@ class Owners {\n                     mDeviceOwnerProtectedPackages.entrySet()) {\n                 mPackageManagerInternal.setDeviceOwnerProtectedPackages(\n                         entry.getKey(), entry.getValue());\n+                mUsageStatsManagerInternal.setAdminProtectedPackages(\n+                        new ArraySet(entry.getValue()), UserHandle.USER_ALL);\n             }\n         }\n     }\n@@ -359,6 +367,8 @@ class Owners {\n             if (protectedPackages != null) {\n                 mPackageManagerInternal.setDeviceOwnerProtectedPackages(\n                         mDeviceOwner.packageName, new ArrayList<>());\n+                mUsageStatsManagerInternal.setAdminProtectedPackages(\n+                        Collections.emptySet(), UserHandle.USER_ALL);\n             }\n             mDeviceOwner = null;\n             mDeviceOwnerUserId = UserHandle.USER_NULL;\n@@ -416,6 +426,8 @@ class Owners {\n             if (previousProtectedPackages != null) {\n                 mPackageManagerInternal.setDeviceOwnerProtectedPackages(\n                         mDeviceOwner.packageName, new ArrayList<>());\n+                mUsageStatsManagerInternal.setAdminProtectedPackages(\n+                        Collections.emptySet(), UserHandle.USER_ALL);\n             }\n             // We don't set a name because it's not used anyway.\n             // See DevicePolicyManagerService#getDeviceOwnerName\n@@ -684,6 +696,8 @@ class Owners {\n \n             mDeviceOwnerProtectedPackages.put(packageName, protectedPackages);\n             mPackageManagerInternal.setDeviceOwnerProtectedPackages(packageName, protectedPackages);\n+            mUsageStatsManagerInternal.setAdminProtectedPackages(\n+                        new ArraySet(protectedPackages), UserHandle.USER_ALL);\n             writeDeviceOwner();\n         }\n     }\n",
    "added_lines": 16,
    "deleted_lines": 2,
    "changed_methods": "Owners::transferDeviceOwnership, Owners::clearDeviceOwner, Owners::load, Owners::setDeviceOwnerProtectedPackages, Owners::Owners, Owners::Owners, Owners::Owners"
   },
   {
    "filename": "DevicePolicyManagerServiceTestable.java",
    "diff": "@@ -69,7 +69,8 @@ public class DevicePolicyManagerServiceTestable extends DevicePolicyManagerServi\n         public OwnersTestable(MockSystemServices services) {\n             super(services.userManager, services.userManagerInternal,\n                     services.packageManagerInternal, services.activityTaskManagerInternal,\n-                    services.activityManagerInternal, new MockInjector(services));\n+                    services.activityManagerInternal, services.usageStatsManagerInternal,\n+                    new MockInjector(services));\n         }\n \n         static class MockInjector extends Injector {\n",
    "added_lines": 2,
    "deleted_lines": 1,
    "changed_methods": "DevicePolicyManagerServiceTestable::OwnersTestable::OwnersTestable"
   },
   {
    "filename": "AppStandbyControllerTests.java",
    "diff": "@@ -152,6 +152,9 @@ public class AppStandbyControllerTests {\n     private static final String ADMIN_PKG2 = \"com.android.admin2\";\n     private static final String ADMIN_PKG3 = \"com.android.admin3\";\n \n+    private static final String ADMIN_PROTECTED_PKG = \"com.android.admin.protected\";\n+    private static final String ADMIN_PROTECTED_PKG2 = \"com.android.admin.protected2\";\n+\n     private static final long MINUTE_MS = 60 * 1000;\n     private static final long HOUR_MS = 60 * MINUTE_MS;\n     private static final long DAY_MS = 24 * HOUR_MS;\n@@ -1631,6 +1634,19 @@ public class AppStandbyControllerTests {\n         assertIsNotActiveAdmin(ADMIN_PKG2, USER_ID);\n     }\n \n+    @Test\n+    public void testSetAdminProtectedPackages() {\n+        assertAdminProtectedPackagesForTest(USER_ID, (String[]) null);\n+        assertAdminProtectedPackagesForTest(USER_ID2, (String[]) null);\n+\n+        setAdminProtectedPackages(USER_ID, ADMIN_PROTECTED_PKG, ADMIN_PROTECTED_PKG2);\n+        assertAdminProtectedPackagesForTest(USER_ID, ADMIN_PROTECTED_PKG, ADMIN_PROTECTED_PKG2);\n+        assertAdminProtectedPackagesForTest(USER_ID2, (String[]) null);\n+\n+        setAdminProtectedPackages(USER_ID, (String[]) null);\n+        assertAdminProtectedPackagesForTest(USER_ID, (String[]) null);\n+    }\n+\n     @Test\n     @FlakyTest(bugId = 185169504)\n     public void testUserInteraction_CrossProfile() throws Exception {\n@@ -2025,6 +2041,28 @@ public class AppStandbyControllerTests {\n         mController.setActiveAdminApps(new ArraySet<>(Arrays.asList(admins)), userId);\n     }\n \n+    private void setAdminProtectedPackages(int userId, String... packageNames) {\n+        Set<String> adminProtectedPackages = packageNames != null ? new ArraySet<>(\n+                Arrays.asList(packageNames)) : null;\n+        mController.setAdminProtectedPackages(adminProtectedPackages, userId);\n+    }\n+\n+    private void assertAdminProtectedPackagesForTest(int userId, String... packageNames) {\n+        final Set<String> actualAdminProtectedPackages =\n+                mController.getAdminProtectedPackagesForTest(userId);\n+        if (packageNames == null) {\n+            if (actualAdminProtectedPackages != null && !actualAdminProtectedPackages.isEmpty()) {\n+                fail(\"Admin protected packages should be null; \" + getAdminAppsStr(userId,\n+                        actualAdminProtectedPackages));\n+            }\n+            return;\n+        }\n+        assertEquals(packageNames.length, actualAdminProtectedPackages.size());\n+        for (String adminProtectedPackage : packageNames) {\n+            assertTrue(actualAdminProtectedPackages.contains(adminProtectedPackage));\n+        }\n+    }\n+\n     private void setAndAssertBucket(String pkg, int user, int bucket, int reason) throws Exception {\n         rearmLatch(pkg);\n         mController.setAppStandbyBucket(pkg, user, bucket, reason);\n",
    "added_lines": 38,
    "deleted_lines": 0,
    "changed_methods": "AppStandbyControllerTests::testSetAdminProtectedPackages, AppStandbyControllerTests::assertAdminProtectedPackagesForTest, AppStandbyControllerTests::setAdminProtectedPackages"
   },
   {
    "filename": "UsageStatsService.java",
    "diff": "@@ -2494,6 +2494,11 @@ public class UsageStatsService extends SystemService implements\n             mAppStandby.setActiveAdminApps(packageNames, userId);\n         }\n \n+        @Override\n+        public void setAdminProtectedPackages(Set<String> packageNames, int userId) {\n+            mAppStandby.setAdminProtectedPackages(packageNames, userId);\n+        }\n+\n         @Override\n         public void onAdminDataAvailable() {\n             mAppStandby.onAdminDataAvailable();\n",
    "added_lines": 5,
    "deleted_lines": 0,
    "changed_methods": "UsageStatsService::LocalService::setAdminProtectedPackages"
   }
  ]
 },
 {
  "hash": "645206dd8566eb1b4ca286b4c0ede04b4e057fd4",
  "commit": "Enforce DevicePolicyManager.setUserControlDisabledPackages in AppStandbyController\n\nWhen deciding an app's standby bucket, check if the\napp has its user control disabled by an IT admin. If so,\nthe app should be the exempted restricted bucket.\n\nBug: 272042183\nTest: atest AppStandbyControllerTests\n(cherry picked from commit 269fcb6873dee199dd8023831f882aafff1f6291)\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:3dbab873d6d8f78c4d498a575ad37fd0dc20efbe)\nMerged-In: I4279dc37f0e17aedb1c2a87468478248443a253e\nChange-Id: I4279dc37f0e17aedb1c2a87468478248443a253e",
  "files": [
   {
    "filename": "AppStandbyInternal.java",
    "diff": "@@ -157,6 +157,8 @@ public interface AppStandbyInternal {\n \n     void setActiveAdminApps(Set<String> adminPkgs, int userId);\n \n+    void setAdminProtectedPackages(Set<String> packageNames, int userId);\n+\n     void onAdminDataAvailable();\n \n     void clearCarrierPrivilegedApps();\n",
    "added_lines": 2,
    "deleted_lines": 0,
    "changed_methods": ""
   },
   {
    "filename": "AppStandbyController.java",
    "diff": "@@ -247,6 +247,10 @@ public class AppStandbyController\n     @GuardedBy(\"mActiveAdminApps\")\n     private final SparseArray<Set<String>> mActiveAdminApps = new SparseArray<>();\n \n+    /** List of admin protected packages. Can contain {@link android.os.UserHandle#USER_ALL}. */\n+    @GuardedBy(\"mAdminProtectedPackages\")\n+    private final SparseArray<Set<String>> mAdminProtectedPackages = new SparseArray<>();\n+\n     /**\n      * Set of system apps that are headless (don't have any declared activities, enabled or\n      * disabled). Presence in this map indicates that the app is a headless system app.\n@@ -1088,6 +1092,9 @@ public class AppStandbyController\n             synchronized (mActiveAdminApps) {\n                 mActiveAdminApps.remove(userId);\n             }\n+            synchronized (mAdminProtectedPackages) {\n+                mAdminProtectedPackages.remove(userId);\n+            }\n         }\n     }\n \n@@ -1177,6 +1184,10 @@ public class AppStandbyController\n                 return STANDBY_BUCKET_EXEMPTED;\n             }\n \n+            if (isAdminProtectedPackages(packageName, userId)) {\n+                return STANDBY_BUCKET_EXEMPTED;\n+            }\n+\n             if (isActiveNetworkScorer(packageName)) {\n                 return STANDBY_BUCKET_EXEMPTED;\n             }\n@@ -1583,6 +1594,17 @@ public class AppStandbyController\n         }\n     }\n \n+    private boolean isAdminProtectedPackages(String packageName, int userId) {\n+        synchronized (mAdminProtectedPackages) {\n+            if (mAdminProtectedPackages.contains(UserHandle.USER_ALL)\n+                    && mAdminProtectedPackages.get(UserHandle.USER_ALL).contains(packageName)) {\n+                return true;\n+            }\n+            return mAdminProtectedPackages.contains(userId)\n+                    && mAdminProtectedPackages.get(userId).contains(packageName);\n+        }\n+    }\n+\n     @Override\n     public void addActiveDeviceAdmin(String adminPkg, int userId) {\n         synchronized (mActiveAdminApps) {\n@@ -1606,6 +1628,17 @@ public class AppStandbyController\n         }\n     }\n \n+    @Override\n+    public void setAdminProtectedPackages(Set<String> packageNames, int userId) {\n+        synchronized (mAdminProtectedPackages) {\n+            if (packageNames == null || packageNames.isEmpty()) {\n+                mAdminProtectedPackages.remove(userId);\n+            } else {\n+                mAdminProtectedPackages.put(userId, packageNames);\n+            }\n+        }\n+    }\n+\n     @Override\n     public void onAdminDataAvailable() {\n         mAdminDataAvailableLatch.countDown();\n@@ -1628,6 +1661,13 @@ public class AppStandbyController\n         }\n     }\n \n+    @VisibleForTesting\n+    Set<String> getAdminProtectedPackagesForTest(int userId) {\n+        synchronized (mAdminProtectedPackages) {\n+            return mAdminProtectedPackages.get(userId);\n+        }\n+    }\n+\n     /**\n      * Returns {@code true} if the supplied package is the device provisioning app. Otherwise,\n      * returns {@code false}.\n",
    "added_lines": 40,
    "deleted_lines": 0,
    "changed_methods": "AppStandbyController::getAppMinBucket, AppStandbyController::getAdminProtectedPackagesForTest, AppStandbyController::onUserRemoved, AppStandbyController::isAdminProtectedPackages, AppStandbyController::setAdminProtectedPackages"
   },
   {
    "filename": "DevicePolicyManager.java",
    "diff": "@@ -13573,7 +13573,8 @@ public class DevicePolicyManager {\n \n     /**\n      * Called by Device owner to disable user control over apps. User will not be able to clear\n-     * app data or force-stop packages.\n+     * app data or force-stop packages. Packages with user control disabled are exempted from\n+     * App Standby Buckets.\n      *\n      * @param admin which {@link DeviceAdminReceiver} this request is associated with\n      * @param packages The package names for the apps.\n",
    "added_lines": 2,
    "deleted_lines": 1,
    "changed_methods": ""
   },
   {
    "filename": "UsageStatsManagerInternal.java",
    "diff": "@@ -198,6 +198,16 @@ public abstract class UsageStatsManagerInternal {\n      */\n     public abstract void setActiveAdminApps(Set<String> adminApps, int userId);\n \n+    /**\n+     * Called by DevicePolicyManagerService to inform about the protected packages for a user.\n+     * User control will be disabled for protected packages.\n+     *\n+     * @param packageNames the set of protected packages for {@code userId}.\n+     * @param userId the userId to which the protected packages belong.\n+     */\n+    public abstract void setAdminProtectedPackages(@Nullable Set<String> packageNames,\n+            @UserIdInt int userId);\n+\n     /**\n      * Called by DevicePolicyManagerService during boot to inform that admin data is loaded and\n      * pushed to UsageStatsService.\n",
    "added_lines": 10,
    "deleted_lines": 0,
    "changed_methods": ""
   },
   {
    "filename": "DevicePolicyManagerService.java",
    "diff": "@@ -1341,7 +1341,7 @@ public class DevicePolicyManagerService extends BaseIDevicePolicyManager {\n         Owners newOwners() {\n             return new Owners(getUserManager(), getUserManagerInternal(),\n                     getPackageManagerInternal(), getActivityTaskManagerInternal(),\n-                    getActivityManagerInternal());\n+                    getActivityManagerInternal(), getUsageStatsManagerInternal());\n         }\n \n         UserManager getUserManager() {\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "DevicePolicyManagerService::Injector::newOwners"
   },
   {
    "filename": "Owners.java",
    "diff": "@@ -24,6 +24,7 @@ import android.app.AppOpsManagerInternal;\n import android.app.admin.DevicePolicyManager.DeviceOwnerType;\n import android.app.admin.SystemUpdateInfo;\n import android.app.admin.SystemUpdatePolicy;\n+import android.app.usage.UsageStatsManagerInternal;\n import android.content.ComponentName;\n import android.content.pm.PackageManager;\n import android.content.pm.PackageManagerInternal;\n@@ -123,6 +124,7 @@ class Owners {\n     private final PackageManagerInternal mPackageManagerInternal;\n     private final ActivityTaskManagerInternal mActivityTaskManagerInternal;\n     private final ActivityManagerInternal mActivityManagerInternal;\n+    private final UsageStatsManagerInternal mUsageStatsManagerInternal;\n \n     private boolean mSystemReady;\n \n@@ -155,9 +157,11 @@ class Owners {\n             UserManagerInternal userManagerInternal,\n             PackageManagerInternal packageManagerInternal,\n             ActivityTaskManagerInternal activityTaskManagerInternal,\n-            ActivityManagerInternal activitykManagerInternal) {\n+            ActivityManagerInternal activitykManagerInternal,\n+            UsageStatsManagerInternal usageStatsManagerInternal) {\n         this(userManager, userManagerInternal, packageManagerInternal,\n-                activityTaskManagerInternal, activitykManagerInternal, new Injector());\n+                activityTaskManagerInternal, activitykManagerInternal,\n+                usageStatsManagerInternal, new Injector());\n     }\n \n     @VisibleForTesting\n@@ -166,12 +170,14 @@ class Owners {\n             PackageManagerInternal packageManagerInternal,\n             ActivityTaskManagerInternal activityTaskManagerInternal,\n             ActivityManagerInternal activityManagerInternal,\n+            UsageStatsManagerInternal usageStatsManagerInternal,\n             Injector injector) {\n         mUserManager = userManager;\n         mUserManagerInternal = userManagerInternal;\n         mPackageManagerInternal = packageManagerInternal;\n         mActivityTaskManagerInternal = activityTaskManagerInternal;\n         mActivityManagerInternal = activityManagerInternal;\n+        mUsageStatsManagerInternal = usageStatsManagerInternal;\n         mInjector = injector;\n     }\n \n@@ -226,6 +232,8 @@ class Owners {\n                     mDeviceOwnerProtectedPackages.entrySet()) {\n                 mPackageManagerInternal.setDeviceOwnerProtectedPackages(\n                         entry.getKey(), entry.getValue());\n+                mUsageStatsManagerInternal.setAdminProtectedPackages(\n+                        new ArraySet(entry.getValue()), UserHandle.USER_ALL);\n             }\n         }\n     }\n@@ -359,6 +367,8 @@ class Owners {\n             if (protectedPackages != null) {\n                 mPackageManagerInternal.setDeviceOwnerProtectedPackages(\n                         mDeviceOwner.packageName, new ArrayList<>());\n+                mUsageStatsManagerInternal.setAdminProtectedPackages(\n+                        Collections.emptySet(), UserHandle.USER_ALL);\n             }\n             mDeviceOwner = null;\n             mDeviceOwnerUserId = UserHandle.USER_NULL;\n@@ -416,6 +426,8 @@ class Owners {\n             if (previousProtectedPackages != null) {\n                 mPackageManagerInternal.setDeviceOwnerProtectedPackages(\n                         mDeviceOwner.packageName, new ArrayList<>());\n+                mUsageStatsManagerInternal.setAdminProtectedPackages(\n+                        Collections.emptySet(), UserHandle.USER_ALL);\n             }\n             // We don't set a name because it's not used anyway.\n             // See DevicePolicyManagerService#getDeviceOwnerName\n@@ -684,6 +696,8 @@ class Owners {\n \n             mDeviceOwnerProtectedPackages.put(packageName, protectedPackages);\n             mPackageManagerInternal.setDeviceOwnerProtectedPackages(packageName, protectedPackages);\n+            mUsageStatsManagerInternal.setAdminProtectedPackages(\n+                        new ArraySet(protectedPackages), UserHandle.USER_ALL);\n             writeDeviceOwner();\n         }\n     }\n",
    "added_lines": 16,
    "deleted_lines": 2,
    "changed_methods": "Owners::transferDeviceOwnership, Owners::clearDeviceOwner, Owners::load, Owners::setDeviceOwnerProtectedPackages, Owners::Owners, Owners::Owners, Owners::Owners"
   },
   {
    "filename": "DevicePolicyManagerServiceTestable.java",
    "diff": "@@ -69,7 +69,8 @@ public class DevicePolicyManagerServiceTestable extends DevicePolicyManagerServi\n         public OwnersTestable(MockSystemServices services) {\n             super(services.userManager, services.userManagerInternal,\n                     services.packageManagerInternal, services.activityTaskManagerInternal,\n-                    services.activityManagerInternal, new MockInjector(services));\n+                    services.activityManagerInternal, services.usageStatsManagerInternal,\n+                    new MockInjector(services));\n         }\n \n         static class MockInjector extends Injector {\n",
    "added_lines": 2,
    "deleted_lines": 1,
    "changed_methods": "DevicePolicyManagerServiceTestable::OwnersTestable::OwnersTestable"
   },
   {
    "filename": "AppStandbyControllerTests.java",
    "diff": "@@ -152,6 +152,9 @@ public class AppStandbyControllerTests {\n     private static final String ADMIN_PKG2 = \"com.android.admin2\";\n     private static final String ADMIN_PKG3 = \"com.android.admin3\";\n \n+    private static final String ADMIN_PROTECTED_PKG = \"com.android.admin.protected\";\n+    private static final String ADMIN_PROTECTED_PKG2 = \"com.android.admin.protected2\";\n+\n     private static final long MINUTE_MS = 60 * 1000;\n     private static final long HOUR_MS = 60 * MINUTE_MS;\n     private static final long DAY_MS = 24 * HOUR_MS;\n@@ -1631,6 +1634,19 @@ public class AppStandbyControllerTests {\n         assertIsNotActiveAdmin(ADMIN_PKG2, USER_ID);\n     }\n \n+    @Test\n+    public void testSetAdminProtectedPackages() {\n+        assertAdminProtectedPackagesForTest(USER_ID, (String[]) null);\n+        assertAdminProtectedPackagesForTest(USER_ID2, (String[]) null);\n+\n+        setAdminProtectedPackages(USER_ID, ADMIN_PROTECTED_PKG, ADMIN_PROTECTED_PKG2);\n+        assertAdminProtectedPackagesForTest(USER_ID, ADMIN_PROTECTED_PKG, ADMIN_PROTECTED_PKG2);\n+        assertAdminProtectedPackagesForTest(USER_ID2, (String[]) null);\n+\n+        setAdminProtectedPackages(USER_ID, (String[]) null);\n+        assertAdminProtectedPackagesForTest(USER_ID, (String[]) null);\n+    }\n+\n     @Test\n     @FlakyTest(bugId = 185169504)\n     public void testUserInteraction_CrossProfile() throws Exception {\n@@ -2025,6 +2041,28 @@ public class AppStandbyControllerTests {\n         mController.setActiveAdminApps(new ArraySet<>(Arrays.asList(admins)), userId);\n     }\n \n+    private void setAdminProtectedPackages(int userId, String... packageNames) {\n+        Set<String> adminProtectedPackages = packageNames != null ? new ArraySet<>(\n+                Arrays.asList(packageNames)) : null;\n+        mController.setAdminProtectedPackages(adminProtectedPackages, userId);\n+    }\n+\n+    private void assertAdminProtectedPackagesForTest(int userId, String... packageNames) {\n+        final Set<String> actualAdminProtectedPackages =\n+                mController.getAdminProtectedPackagesForTest(userId);\n+        if (packageNames == null) {\n+            if (actualAdminProtectedPackages != null && !actualAdminProtectedPackages.isEmpty()) {\n+                fail(\"Admin protected packages should be null; \" + getAdminAppsStr(userId,\n+                        actualAdminProtectedPackages));\n+            }\n+            return;\n+        }\n+        assertEquals(packageNames.length, actualAdminProtectedPackages.size());\n+        for (String adminProtectedPackage : packageNames) {\n+            assertTrue(actualAdminProtectedPackages.contains(adminProtectedPackage));\n+        }\n+    }\n+\n     private void setAndAssertBucket(String pkg, int user, int bucket, int reason) throws Exception {\n         rearmLatch(pkg);\n         mController.setAppStandbyBucket(pkg, user, bucket, reason);\n",
    "added_lines": 38,
    "deleted_lines": 0,
    "changed_methods": "AppStandbyControllerTests::testSetAdminProtectedPackages, AppStandbyControllerTests::assertAdminProtectedPackagesForTest, AppStandbyControllerTests::setAdminProtectedPackages"
   },
   {
    "filename": "UsageStatsService.java",
    "diff": "@@ -2494,6 +2494,11 @@ public class UsageStatsService extends SystemService implements\n             mAppStandby.setActiveAdminApps(packageNames, userId);\n         }\n \n+        @Override\n+        public void setAdminProtectedPackages(Set<String> packageNames, int userId) {\n+            mAppStandby.setAdminProtectedPackages(packageNames, userId);\n+        }\n+\n         @Override\n         public void onAdminDataAvailable() {\n             mAppStandby.onAdminDataAvailable();\n",
    "added_lines": 5,
    "deleted_lines": 0,
    "changed_methods": "UsageStatsService::LocalService::setAdminProtectedPackages"
   }
  ]
 },
 {
  "hash": "645206dd8566eb1b4ca286b4c0ede04b4e057fd4",
  "commit": "Enforce DevicePolicyManager.setUserControlDisabledPackages in AppStandbyController\n\nWhen deciding an app's standby bucket, check if the\napp has its user control disabled by an IT admin. If so,\nthe app should be the exempted restricted bucket.\n\nBug: 272042183\nTest: atest AppStandbyControllerTests\n(cherry picked from commit 269fcb6873dee199dd8023831f882aafff1f6291)\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:3dbab873d6d8f78c4d498a575ad37fd0dc20efbe)\nMerged-In: I4279dc37f0e17aedb1c2a87468478248443a253e\nChange-Id: I4279dc37f0e17aedb1c2a87468478248443a253e",
  "files": [
   {
    "filename": "AppStandbyInternal.java",
    "diff": "@@ -157,6 +157,8 @@ public interface AppStandbyInternal {\n \n     void setActiveAdminApps(Set<String> adminPkgs, int userId);\n \n+    void setAdminProtectedPackages(Set<String> packageNames, int userId);\n+\n     void onAdminDataAvailable();\n \n     void clearCarrierPrivilegedApps();\n",
    "added_lines": 2,
    "deleted_lines": 0,
    "changed_methods": ""
   },
   {
    "filename": "AppStandbyController.java",
    "diff": "@@ -247,6 +247,10 @@ public class AppStandbyController\n     @GuardedBy(\"mActiveAdminApps\")\n     private final SparseArray<Set<String>> mActiveAdminApps = new SparseArray<>();\n \n+    /** List of admin protected packages. Can contain {@link android.os.UserHandle#USER_ALL}. */\n+    @GuardedBy(\"mAdminProtectedPackages\")\n+    private final SparseArray<Set<String>> mAdminProtectedPackages = new SparseArray<>();\n+\n     /**\n      * Set of system apps that are headless (don't have any declared activities, enabled or\n      * disabled). Presence in this map indicates that the app is a headless system app.\n@@ -1088,6 +1092,9 @@ public class AppStandbyController\n             synchronized (mActiveAdminApps) {\n                 mActiveAdminApps.remove(userId);\n             }\n+            synchronized (mAdminProtectedPackages) {\n+                mAdminProtectedPackages.remove(userId);\n+            }\n         }\n     }\n \n@@ -1177,6 +1184,10 @@ public class AppStandbyController\n                 return STANDBY_BUCKET_EXEMPTED;\n             }\n \n+            if (isAdminProtectedPackages(packageName, userId)) {\n+                return STANDBY_BUCKET_EXEMPTED;\n+            }\n+\n             if (isActiveNetworkScorer(packageName)) {\n                 return STANDBY_BUCKET_EXEMPTED;\n             }\n@@ -1583,6 +1594,17 @@ public class AppStandbyController\n         }\n     }\n \n+    private boolean isAdminProtectedPackages(String packageName, int userId) {\n+        synchronized (mAdminProtectedPackages) {\n+            if (mAdminProtectedPackages.contains(UserHandle.USER_ALL)\n+                    && mAdminProtectedPackages.get(UserHandle.USER_ALL).contains(packageName)) {\n+                return true;\n+            }\n+            return mAdminProtectedPackages.contains(userId)\n+                    && mAdminProtectedPackages.get(userId).contains(packageName);\n+        }\n+    }\n+\n     @Override\n     public void addActiveDeviceAdmin(String adminPkg, int userId) {\n         synchronized (mActiveAdminApps) {\n@@ -1606,6 +1628,17 @@ public class AppStandbyController\n         }\n     }\n \n+    @Override\n+    public void setAdminProtectedPackages(Set<String> packageNames, int userId) {\n+        synchronized (mAdminProtectedPackages) {\n+            if (packageNames == null || packageNames.isEmpty()) {\n+                mAdminProtectedPackages.remove(userId);\n+            } else {\n+                mAdminProtectedPackages.put(userId, packageNames);\n+            }\n+        }\n+    }\n+\n     @Override\n     public void onAdminDataAvailable() {\n         mAdminDataAvailableLatch.countDown();\n@@ -1628,6 +1661,13 @@ public class AppStandbyController\n         }\n     }\n \n+    @VisibleForTesting\n+    Set<String> getAdminProtectedPackagesForTest(int userId) {\n+        synchronized (mAdminProtectedPackages) {\n+            return mAdminProtectedPackages.get(userId);\n+        }\n+    }\n+\n     /**\n      * Returns {@code true} if the supplied package is the device provisioning app. Otherwise,\n      * returns {@code false}.\n",
    "added_lines": 40,
    "deleted_lines": 0,
    "changed_methods": "AppStandbyController::getAppMinBucket, AppStandbyController::getAdminProtectedPackagesForTest, AppStandbyController::onUserRemoved, AppStandbyController::isAdminProtectedPackages, AppStandbyController::setAdminProtectedPackages"
   },
   {
    "filename": "DevicePolicyManager.java",
    "diff": "@@ -13573,7 +13573,8 @@ public class DevicePolicyManager {\n \n     /**\n      * Called by Device owner to disable user control over apps. User will not be able to clear\n-     * app data or force-stop packages.\n+     * app data or force-stop packages. Packages with user control disabled are exempted from\n+     * App Standby Buckets.\n      *\n      * @param admin which {@link DeviceAdminReceiver} this request is associated with\n      * @param packages The package names for the apps.\n",
    "added_lines": 2,
    "deleted_lines": 1,
    "changed_methods": ""
   },
   {
    "filename": "UsageStatsManagerInternal.java",
    "diff": "@@ -198,6 +198,16 @@ public abstract class UsageStatsManagerInternal {\n      */\n     public abstract void setActiveAdminApps(Set<String> adminApps, int userId);\n \n+    /**\n+     * Called by DevicePolicyManagerService to inform about the protected packages for a user.\n+     * User control will be disabled for protected packages.\n+     *\n+     * @param packageNames the set of protected packages for {@code userId}.\n+     * @param userId the userId to which the protected packages belong.\n+     */\n+    public abstract void setAdminProtectedPackages(@Nullable Set<String> packageNames,\n+            @UserIdInt int userId);\n+\n     /**\n      * Called by DevicePolicyManagerService during boot to inform that admin data is loaded and\n      * pushed to UsageStatsService.\n",
    "added_lines": 10,
    "deleted_lines": 0,
    "changed_methods": ""
   },
   {
    "filename": "DevicePolicyManagerService.java",
    "diff": "@@ -1341,7 +1341,7 @@ public class DevicePolicyManagerService extends BaseIDevicePolicyManager {\n         Owners newOwners() {\n             return new Owners(getUserManager(), getUserManagerInternal(),\n                     getPackageManagerInternal(), getActivityTaskManagerInternal(),\n-                    getActivityManagerInternal());\n+                    getActivityManagerInternal(), getUsageStatsManagerInternal());\n         }\n \n         UserManager getUserManager() {\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "DevicePolicyManagerService::Injector::newOwners"
   },
   {
    "filename": "Owners.java",
    "diff": "@@ -24,6 +24,7 @@ import android.app.AppOpsManagerInternal;\n import android.app.admin.DevicePolicyManager.DeviceOwnerType;\n import android.app.admin.SystemUpdateInfo;\n import android.app.admin.SystemUpdatePolicy;\n+import android.app.usage.UsageStatsManagerInternal;\n import android.content.ComponentName;\n import android.content.pm.PackageManager;\n import android.content.pm.PackageManagerInternal;\n@@ -123,6 +124,7 @@ class Owners {\n     private final PackageManagerInternal mPackageManagerInternal;\n     private final ActivityTaskManagerInternal mActivityTaskManagerInternal;\n     private final ActivityManagerInternal mActivityManagerInternal;\n+    private final UsageStatsManagerInternal mUsageStatsManagerInternal;\n \n     private boolean mSystemReady;\n \n@@ -155,9 +157,11 @@ class Owners {\n             UserManagerInternal userManagerInternal,\n             PackageManagerInternal packageManagerInternal,\n             ActivityTaskManagerInternal activityTaskManagerInternal,\n-            ActivityManagerInternal activitykManagerInternal) {\n+            ActivityManagerInternal activitykManagerInternal,\n+            UsageStatsManagerInternal usageStatsManagerInternal) {\n         this(userManager, userManagerInternal, packageManagerInternal,\n-                activityTaskManagerInternal, activitykManagerInternal, new Injector());\n+                activityTaskManagerInternal, activitykManagerInternal,\n+                usageStatsManagerInternal, new Injector());\n     }\n \n     @VisibleForTesting\n@@ -166,12 +170,14 @@ class Owners {\n             PackageManagerInternal packageManagerInternal,\n             ActivityTaskManagerInternal activityTaskManagerInternal,\n             ActivityManagerInternal activityManagerInternal,\n+            UsageStatsManagerInternal usageStatsManagerInternal,\n             Injector injector) {\n         mUserManager = userManager;\n         mUserManagerInternal = userManagerInternal;\n         mPackageManagerInternal = packageManagerInternal;\n         mActivityTaskManagerInternal = activityTaskManagerInternal;\n         mActivityManagerInternal = activityManagerInternal;\n+        mUsageStatsManagerInternal = usageStatsManagerInternal;\n         mInjector = injector;\n     }\n \n@@ -226,6 +232,8 @@ class Owners {\n                     mDeviceOwnerProtectedPackages.entrySet()) {\n                 mPackageManagerInternal.setDeviceOwnerProtectedPackages(\n                         entry.getKey(), entry.getValue());\n+                mUsageStatsManagerInternal.setAdminProtectedPackages(\n+                        new ArraySet(entry.getValue()), UserHandle.USER_ALL);\n             }\n         }\n     }\n@@ -359,6 +367,8 @@ class Owners {\n             if (protectedPackages != null) {\n                 mPackageManagerInternal.setDeviceOwnerProtectedPackages(\n                         mDeviceOwner.packageName, new ArrayList<>());\n+                mUsageStatsManagerInternal.setAdminProtectedPackages(\n+                        Collections.emptySet(), UserHandle.USER_ALL);\n             }\n             mDeviceOwner = null;\n             mDeviceOwnerUserId = UserHandle.USER_NULL;\n@@ -416,6 +426,8 @@ class Owners {\n             if (previousProtectedPackages != null) {\n                 mPackageManagerInternal.setDeviceOwnerProtectedPackages(\n                         mDeviceOwner.packageName, new ArrayList<>());\n+                mUsageStatsManagerInternal.setAdminProtectedPackages(\n+                        Collections.emptySet(), UserHandle.USER_ALL);\n             }\n             // We don't set a name because it's not used anyway.\n             // See DevicePolicyManagerService#getDeviceOwnerName\n@@ -684,6 +696,8 @@ class Owners {\n \n             mDeviceOwnerProtectedPackages.put(packageName, protectedPackages);\n             mPackageManagerInternal.setDeviceOwnerProtectedPackages(packageName, protectedPackages);\n+            mUsageStatsManagerInternal.setAdminProtectedPackages(\n+                        new ArraySet(protectedPackages), UserHandle.USER_ALL);\n             writeDeviceOwner();\n         }\n     }\n",
    "added_lines": 16,
    "deleted_lines": 2,
    "changed_methods": "Owners::transferDeviceOwnership, Owners::clearDeviceOwner, Owners::load, Owners::setDeviceOwnerProtectedPackages, Owners::Owners, Owners::Owners, Owners::Owners"
   },
   {
    "filename": "DevicePolicyManagerServiceTestable.java",
    "diff": "@@ -69,7 +69,8 @@ public class DevicePolicyManagerServiceTestable extends DevicePolicyManagerServi\n         public OwnersTestable(MockSystemServices services) {\n             super(services.userManager, services.userManagerInternal,\n                     services.packageManagerInternal, services.activityTaskManagerInternal,\n-                    services.activityManagerInternal, new MockInjector(services));\n+                    services.activityManagerInternal, services.usageStatsManagerInternal,\n+                    new MockInjector(services));\n         }\n \n         static class MockInjector extends Injector {\n",
    "added_lines": 2,
    "deleted_lines": 1,
    "changed_methods": "DevicePolicyManagerServiceTestable::OwnersTestable::OwnersTestable"
   },
   {
    "filename": "AppStandbyControllerTests.java",
    "diff": "@@ -152,6 +152,9 @@ public class AppStandbyControllerTests {\n     private static final String ADMIN_PKG2 = \"com.android.admin2\";\n     private static final String ADMIN_PKG3 = \"com.android.admin3\";\n \n+    private static final String ADMIN_PROTECTED_PKG = \"com.android.admin.protected\";\n+    private static final String ADMIN_PROTECTED_PKG2 = \"com.android.admin.protected2\";\n+\n     private static final long MINUTE_MS = 60 * 1000;\n     private static final long HOUR_MS = 60 * MINUTE_MS;\n     private static final long DAY_MS = 24 * HOUR_MS;\n@@ -1631,6 +1634,19 @@ public class AppStandbyControllerTests {\n         assertIsNotActiveAdmin(ADMIN_PKG2, USER_ID);\n     }\n \n+    @Test\n+    public void testSetAdminProtectedPackages() {\n+        assertAdminProtectedPackagesForTest(USER_ID, (String[]) null);\n+        assertAdminProtectedPackagesForTest(USER_ID2, (String[]) null);\n+\n+        setAdminProtectedPackages(USER_ID, ADMIN_PROTECTED_PKG, ADMIN_PROTECTED_PKG2);\n+        assertAdminProtectedPackagesForTest(USER_ID, ADMIN_PROTECTED_PKG, ADMIN_PROTECTED_PKG2);\n+        assertAdminProtectedPackagesForTest(USER_ID2, (String[]) null);\n+\n+        setAdminProtectedPackages(USER_ID, (String[]) null);\n+        assertAdminProtectedPackagesForTest(USER_ID, (String[]) null);\n+    }\n+\n     @Test\n     @FlakyTest(bugId = 185169504)\n     public void testUserInteraction_CrossProfile() throws Exception {\n@@ -2025,6 +2041,28 @@ public class AppStandbyControllerTests {\n         mController.setActiveAdminApps(new ArraySet<>(Arrays.asList(admins)), userId);\n     }\n \n+    private void setAdminProtectedPackages(int userId, String... packageNames) {\n+        Set<String> adminProtectedPackages = packageNames != null ? new ArraySet<>(\n+                Arrays.asList(packageNames)) : null;\n+        mController.setAdminProtectedPackages(adminProtectedPackages, userId);\n+    }\n+\n+    private void assertAdminProtectedPackagesForTest(int userId, String... packageNames) {\n+        final Set<String> actualAdminProtectedPackages =\n+                mController.getAdminProtectedPackagesForTest(userId);\n+        if (packageNames == null) {\n+            if (actualAdminProtectedPackages != null && !actualAdminProtectedPackages.isEmpty()) {\n+                fail(\"Admin protected packages should be null; \" + getAdminAppsStr(userId,\n+                        actualAdminProtectedPackages));\n+            }\n+            return;\n+        }\n+        assertEquals(packageNames.length, actualAdminProtectedPackages.size());\n+        for (String adminProtectedPackage : packageNames) {\n+            assertTrue(actualAdminProtectedPackages.contains(adminProtectedPackage));\n+        }\n+    }\n+\n     private void setAndAssertBucket(String pkg, int user, int bucket, int reason) throws Exception {\n         rearmLatch(pkg);\n         mController.setAppStandbyBucket(pkg, user, bucket, reason);\n",
    "added_lines": 38,
    "deleted_lines": 0,
    "changed_methods": "AppStandbyControllerTests::testSetAdminProtectedPackages, AppStandbyControllerTests::assertAdminProtectedPackagesForTest, AppStandbyControllerTests::setAdminProtectedPackages"
   },
   {
    "filename": "UsageStatsService.java",
    "diff": "@@ -2494,6 +2494,11 @@ public class UsageStatsService extends SystemService implements\n             mAppStandby.setActiveAdminApps(packageNames, userId);\n         }\n \n+        @Override\n+        public void setAdminProtectedPackages(Set<String> packageNames, int userId) {\n+            mAppStandby.setAdminProtectedPackages(packageNames, userId);\n+        }\n+\n         @Override\n         public void onAdminDataAvailable() {\n             mAppStandby.onAdminDataAvailable();\n",
    "added_lines": 5,
    "deleted_lines": 0,
    "changed_methods": "UsageStatsService::LocalService::setAdminProtectedPackages"
   }
  ]
 },
 {
  "hash": "645206dd8566eb1b4ca286b4c0ede04b4e057fd4",
  "commit": "Enforce DevicePolicyManager.setUserControlDisabledPackages in AppStandbyController\n\nWhen deciding an app's standby bucket, check if the\napp has its user control disabled by an IT admin. If so,\nthe app should be the exempted restricted bucket.\n\nBug: 272042183\nTest: atest AppStandbyControllerTests\n(cherry picked from commit 269fcb6873dee199dd8023831f882aafff1f6291)\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:3dbab873d6d8f78c4d498a575ad37fd0dc20efbe)\nMerged-In: I4279dc37f0e17aedb1c2a87468478248443a253e\nChange-Id: I4279dc37f0e17aedb1c2a87468478248443a253e",
  "files": [
   {
    "filename": "AppStandbyInternal.java",
    "diff": "@@ -157,6 +157,8 @@ public interface AppStandbyInternal {\n \n     void setActiveAdminApps(Set<String> adminPkgs, int userId);\n \n+    void setAdminProtectedPackages(Set<String> packageNames, int userId);\n+\n     void onAdminDataAvailable();\n \n     void clearCarrierPrivilegedApps();\n",
    "added_lines": 2,
    "deleted_lines": 0,
    "changed_methods": ""
   },
   {
    "filename": "AppStandbyController.java",
    "diff": "@@ -247,6 +247,10 @@ public class AppStandbyController\n     @GuardedBy(\"mActiveAdminApps\")\n     private final SparseArray<Set<String>> mActiveAdminApps = new SparseArray<>();\n \n+    /** List of admin protected packages. Can contain {@link android.os.UserHandle#USER_ALL}. */\n+    @GuardedBy(\"mAdminProtectedPackages\")\n+    private final SparseArray<Set<String>> mAdminProtectedPackages = new SparseArray<>();\n+\n     /**\n      * Set of system apps that are headless (don't have any declared activities, enabled or\n      * disabled). Presence in this map indicates that the app is a headless system app.\n@@ -1088,6 +1092,9 @@ public class AppStandbyController\n             synchronized (mActiveAdminApps) {\n                 mActiveAdminApps.remove(userId);\n             }\n+            synchronized (mAdminProtectedPackages) {\n+                mAdminProtectedPackages.remove(userId);\n+            }\n         }\n     }\n \n@@ -1177,6 +1184,10 @@ public class AppStandbyController\n                 return STANDBY_BUCKET_EXEMPTED;\n             }\n \n+            if (isAdminProtectedPackages(packageName, userId)) {\n+                return STANDBY_BUCKET_EXEMPTED;\n+            }\n+\n             if (isActiveNetworkScorer(packageName)) {\n                 return STANDBY_BUCKET_EXEMPTED;\n             }\n@@ -1583,6 +1594,17 @@ public class AppStandbyController\n         }\n     }\n \n+    private boolean isAdminProtectedPackages(String packageName, int userId) {\n+        synchronized (mAdminProtectedPackages) {\n+            if (mAdminProtectedPackages.contains(UserHandle.USER_ALL)\n+                    && mAdminProtectedPackages.get(UserHandle.USER_ALL).contains(packageName)) {\n+                return true;\n+            }\n+            return mAdminProtectedPackages.contains(userId)\n+                    && mAdminProtectedPackages.get(userId).contains(packageName);\n+        }\n+    }\n+\n     @Override\n     public void addActiveDeviceAdmin(String adminPkg, int userId) {\n         synchronized (mActiveAdminApps) {\n@@ -1606,6 +1628,17 @@ public class AppStandbyController\n         }\n     }\n \n+    @Override\n+    public void setAdminProtectedPackages(Set<String> packageNames, int userId) {\n+        synchronized (mAdminProtectedPackages) {\n+            if (packageNames == null || packageNames.isEmpty()) {\n+                mAdminProtectedPackages.remove(userId);\n+            } else {\n+                mAdminProtectedPackages.put(userId, packageNames);\n+            }\n+        }\n+    }\n+\n     @Override\n     public void onAdminDataAvailable() {\n         mAdminDataAvailableLatch.countDown();\n@@ -1628,6 +1661,13 @@ public class AppStandbyController\n         }\n     }\n \n+    @VisibleForTesting\n+    Set<String> getAdminProtectedPackagesForTest(int userId) {\n+        synchronized (mAdminProtectedPackages) {\n+            return mAdminProtectedPackages.get(userId);\n+        }\n+    }\n+\n     /**\n      * Returns {@code true} if the supplied package is the device provisioning app. Otherwise,\n      * returns {@code false}.\n",
    "added_lines": 40,
    "deleted_lines": 0,
    "changed_methods": "AppStandbyController::getAppMinBucket, AppStandbyController::getAdminProtectedPackagesForTest, AppStandbyController::onUserRemoved, AppStandbyController::isAdminProtectedPackages, AppStandbyController::setAdminProtectedPackages"
   },
   {
    "filename": "DevicePolicyManager.java",
    "diff": "@@ -13573,7 +13573,8 @@ public class DevicePolicyManager {\n \n     /**\n      * Called by Device owner to disable user control over apps. User will not be able to clear\n-     * app data or force-stop packages.\n+     * app data or force-stop packages. Packages with user control disabled are exempted from\n+     * App Standby Buckets.\n      *\n      * @param admin which {@link DeviceAdminReceiver} this request is associated with\n      * @param packages The package names for the apps.\n",
    "added_lines": 2,
    "deleted_lines": 1,
    "changed_methods": ""
   },
   {
    "filename": "UsageStatsManagerInternal.java",
    "diff": "@@ -198,6 +198,16 @@ public abstract class UsageStatsManagerInternal {\n      */\n     public abstract void setActiveAdminApps(Set<String> adminApps, int userId);\n \n+    /**\n+     * Called by DevicePolicyManagerService to inform about the protected packages for a user.\n+     * User control will be disabled for protected packages.\n+     *\n+     * @param packageNames the set of protected packages for {@code userId}.\n+     * @param userId the userId to which the protected packages belong.\n+     */\n+    public abstract void setAdminProtectedPackages(@Nullable Set<String> packageNames,\n+            @UserIdInt int userId);\n+\n     /**\n      * Called by DevicePolicyManagerService during boot to inform that admin data is loaded and\n      * pushed to UsageStatsService.\n",
    "added_lines": 10,
    "deleted_lines": 0,
    "changed_methods": ""
   },
   {
    "filename": "DevicePolicyManagerService.java",
    "diff": "@@ -1341,7 +1341,7 @@ public class DevicePolicyManagerService extends BaseIDevicePolicyManager {\n         Owners newOwners() {\n             return new Owners(getUserManager(), getUserManagerInternal(),\n                     getPackageManagerInternal(), getActivityTaskManagerInternal(),\n-                    getActivityManagerInternal());\n+                    getActivityManagerInternal(), getUsageStatsManagerInternal());\n         }\n \n         UserManager getUserManager() {\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "DevicePolicyManagerService::Injector::newOwners"
   },
   {
    "filename": "Owners.java",
    "diff": "@@ -24,6 +24,7 @@ import android.app.AppOpsManagerInternal;\n import android.app.admin.DevicePolicyManager.DeviceOwnerType;\n import android.app.admin.SystemUpdateInfo;\n import android.app.admin.SystemUpdatePolicy;\n+import android.app.usage.UsageStatsManagerInternal;\n import android.content.ComponentName;\n import android.content.pm.PackageManager;\n import android.content.pm.PackageManagerInternal;\n@@ -123,6 +124,7 @@ class Owners {\n     private final PackageManagerInternal mPackageManagerInternal;\n     private final ActivityTaskManagerInternal mActivityTaskManagerInternal;\n     private final ActivityManagerInternal mActivityManagerInternal;\n+    private final UsageStatsManagerInternal mUsageStatsManagerInternal;\n \n     private boolean mSystemReady;\n \n@@ -155,9 +157,11 @@ class Owners {\n             UserManagerInternal userManagerInternal,\n             PackageManagerInternal packageManagerInternal,\n             ActivityTaskManagerInternal activityTaskManagerInternal,\n-            ActivityManagerInternal activitykManagerInternal) {\n+            ActivityManagerInternal activitykManagerInternal,\n+            UsageStatsManagerInternal usageStatsManagerInternal) {\n         this(userManager, userManagerInternal, packageManagerInternal,\n-                activityTaskManagerInternal, activitykManagerInternal, new Injector());\n+                activityTaskManagerInternal, activitykManagerInternal,\n+                usageStatsManagerInternal, new Injector());\n     }\n \n     @VisibleForTesting\n@@ -166,12 +170,14 @@ class Owners {\n             PackageManagerInternal packageManagerInternal,\n             ActivityTaskManagerInternal activityTaskManagerInternal,\n             ActivityManagerInternal activityManagerInternal,\n+            UsageStatsManagerInternal usageStatsManagerInternal,\n             Injector injector) {\n         mUserManager = userManager;\n         mUserManagerInternal = userManagerInternal;\n         mPackageManagerInternal = packageManagerInternal;\n         mActivityTaskManagerInternal = activityTaskManagerInternal;\n         mActivityManagerInternal = activityManagerInternal;\n+        mUsageStatsManagerInternal = usageStatsManagerInternal;\n         mInjector = injector;\n     }\n \n@@ -226,6 +232,8 @@ class Owners {\n                     mDeviceOwnerProtectedPackages.entrySet()) {\n                 mPackageManagerInternal.setDeviceOwnerProtectedPackages(\n                         entry.getKey(), entry.getValue());\n+                mUsageStatsManagerInternal.setAdminProtectedPackages(\n+                        new ArraySet(entry.getValue()), UserHandle.USER_ALL);\n             }\n         }\n     }\n@@ -359,6 +367,8 @@ class Owners {\n             if (protectedPackages != null) {\n                 mPackageManagerInternal.setDeviceOwnerProtectedPackages(\n                         mDeviceOwner.packageName, new ArrayList<>());\n+                mUsageStatsManagerInternal.setAdminProtectedPackages(\n+                        Collections.emptySet(), UserHandle.USER_ALL);\n             }\n             mDeviceOwner = null;\n             mDeviceOwnerUserId = UserHandle.USER_NULL;\n@@ -416,6 +426,8 @@ class Owners {\n             if (previousProtectedPackages != null) {\n                 mPackageManagerInternal.setDeviceOwnerProtectedPackages(\n                         mDeviceOwner.packageName, new ArrayList<>());\n+                mUsageStatsManagerInternal.setAdminProtectedPackages(\n+                        Collections.emptySet(), UserHandle.USER_ALL);\n             }\n             // We don't set a name because it's not used anyway.\n             // See DevicePolicyManagerService#getDeviceOwnerName\n@@ -684,6 +696,8 @@ class Owners {\n \n             mDeviceOwnerProtectedPackages.put(packageName, protectedPackages);\n             mPackageManagerInternal.setDeviceOwnerProtectedPackages(packageName, protectedPackages);\n+            mUsageStatsManagerInternal.setAdminProtectedPackages(\n+                        new ArraySet(protectedPackages), UserHandle.USER_ALL);\n             writeDeviceOwner();\n         }\n     }\n",
    "added_lines": 16,
    "deleted_lines": 2,
    "changed_methods": "Owners::transferDeviceOwnership, Owners::clearDeviceOwner, Owners::load, Owners::setDeviceOwnerProtectedPackages, Owners::Owners, Owners::Owners, Owners::Owners"
   },
   {
    "filename": "DevicePolicyManagerServiceTestable.java",
    "diff": "@@ -69,7 +69,8 @@ public class DevicePolicyManagerServiceTestable extends DevicePolicyManagerServi\n         public OwnersTestable(MockSystemServices services) {\n             super(services.userManager, services.userManagerInternal,\n                     services.packageManagerInternal, services.activityTaskManagerInternal,\n-                    services.activityManagerInternal, new MockInjector(services));\n+                    services.activityManagerInternal, services.usageStatsManagerInternal,\n+                    new MockInjector(services));\n         }\n \n         static class MockInjector extends Injector {\n",
    "added_lines": 2,
    "deleted_lines": 1,
    "changed_methods": "DevicePolicyManagerServiceTestable::OwnersTestable::OwnersTestable"
   },
   {
    "filename": "AppStandbyControllerTests.java",
    "diff": "@@ -152,6 +152,9 @@ public class AppStandbyControllerTests {\n     private static final String ADMIN_PKG2 = \"com.android.admin2\";\n     private static final String ADMIN_PKG3 = \"com.android.admin3\";\n \n+    private static final String ADMIN_PROTECTED_PKG = \"com.android.admin.protected\";\n+    private static final String ADMIN_PROTECTED_PKG2 = \"com.android.admin.protected2\";\n+\n     private static final long MINUTE_MS = 60 * 1000;\n     private static final long HOUR_MS = 60 * MINUTE_MS;\n     private static final long DAY_MS = 24 * HOUR_MS;\n@@ -1631,6 +1634,19 @@ public class AppStandbyControllerTests {\n         assertIsNotActiveAdmin(ADMIN_PKG2, USER_ID);\n     }\n \n+    @Test\n+    public void testSetAdminProtectedPackages() {\n+        assertAdminProtectedPackagesForTest(USER_ID, (String[]) null);\n+        assertAdminProtectedPackagesForTest(USER_ID2, (String[]) null);\n+\n+        setAdminProtectedPackages(USER_ID, ADMIN_PROTECTED_PKG, ADMIN_PROTECTED_PKG2);\n+        assertAdminProtectedPackagesForTest(USER_ID, ADMIN_PROTECTED_PKG, ADMIN_PROTECTED_PKG2);\n+        assertAdminProtectedPackagesForTest(USER_ID2, (String[]) null);\n+\n+        setAdminProtectedPackages(USER_ID, (String[]) null);\n+        assertAdminProtectedPackagesForTest(USER_ID, (String[]) null);\n+    }\n+\n     @Test\n     @FlakyTest(bugId = 185169504)\n     public void testUserInteraction_CrossProfile() throws Exception {\n@@ -2025,6 +2041,28 @@ public class AppStandbyControllerTests {\n         mController.setActiveAdminApps(new ArraySet<>(Arrays.asList(admins)), userId);\n     }\n \n+    private void setAdminProtectedPackages(int userId, String... packageNames) {\n+        Set<String> adminProtectedPackages = packageNames != null ? new ArraySet<>(\n+                Arrays.asList(packageNames)) : null;\n+        mController.setAdminProtectedPackages(adminProtectedPackages, userId);\n+    }\n+\n+    private void assertAdminProtectedPackagesForTest(int userId, String... packageNames) {\n+        final Set<String> actualAdminProtectedPackages =\n+                mController.getAdminProtectedPackagesForTest(userId);\n+        if (packageNames == null) {\n+            if (actualAdminProtectedPackages != null && !actualAdminProtectedPackages.isEmpty()) {\n+                fail(\"Admin protected packages should be null; \" + getAdminAppsStr(userId,\n+                        actualAdminProtectedPackages));\n+            }\n+            return;\n+        }\n+        assertEquals(packageNames.length, actualAdminProtectedPackages.size());\n+        for (String adminProtectedPackage : packageNames) {\n+            assertTrue(actualAdminProtectedPackages.contains(adminProtectedPackage));\n+        }\n+    }\n+\n     private void setAndAssertBucket(String pkg, int user, int bucket, int reason) throws Exception {\n         rearmLatch(pkg);\n         mController.setAppStandbyBucket(pkg, user, bucket, reason);\n",
    "added_lines": 38,
    "deleted_lines": 0,
    "changed_methods": "AppStandbyControllerTests::testSetAdminProtectedPackages, AppStandbyControllerTests::assertAdminProtectedPackagesForTest, AppStandbyControllerTests::setAdminProtectedPackages"
   },
   {
    "filename": "UsageStatsService.java",
    "diff": "@@ -2494,6 +2494,11 @@ public class UsageStatsService extends SystemService implements\n             mAppStandby.setActiveAdminApps(packageNames, userId);\n         }\n \n+        @Override\n+        public void setAdminProtectedPackages(Set<String> packageNames, int userId) {\n+            mAppStandby.setAdminProtectedPackages(packageNames, userId);\n+        }\n+\n         @Override\n         public void onAdminDataAvailable() {\n             mAppStandby.onAdminDataAvailable();\n",
    "added_lines": 5,
    "deleted_lines": 0,
    "changed_methods": "UsageStatsService::LocalService::setAdminProtectedPackages"
   }
  ]
 },
 {
  "hash": "645206dd8566eb1b4ca286b4c0ede04b4e057fd4",
  "commit": "Enforce DevicePolicyManager.setUserControlDisabledPackages in AppStandbyController\n\nWhen deciding an app's standby bucket, check if the\napp has its user control disabled by an IT admin. If so,\nthe app should be the exempted restricted bucket.\n\nBug: 272042183\nTest: atest AppStandbyControllerTests\n(cherry picked from commit 269fcb6873dee199dd8023831f882aafff1f6291)\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:3dbab873d6d8f78c4d498a575ad37fd0dc20efbe)\nMerged-In: I4279dc37f0e17aedb1c2a87468478248443a253e\nChange-Id: I4279dc37f0e17aedb1c2a87468478248443a253e",
  "files": [
   {
    "filename": "AppStandbyInternal.java",
    "diff": "@@ -157,6 +157,8 @@ public interface AppStandbyInternal {\n \n     void setActiveAdminApps(Set<String> adminPkgs, int userId);\n \n+    void setAdminProtectedPackages(Set<String> packageNames, int userId);\n+\n     void onAdminDataAvailable();\n \n     void clearCarrierPrivilegedApps();\n",
    "added_lines": 2,
    "deleted_lines": 0,
    "changed_methods": ""
   },
   {
    "filename": "AppStandbyController.java",
    "diff": "@@ -247,6 +247,10 @@ public class AppStandbyController\n     @GuardedBy(\"mActiveAdminApps\")\n     private final SparseArray<Set<String>> mActiveAdminApps = new SparseArray<>();\n \n+    /** List of admin protected packages. Can contain {@link android.os.UserHandle#USER_ALL}. */\n+    @GuardedBy(\"mAdminProtectedPackages\")\n+    private final SparseArray<Set<String>> mAdminProtectedPackages = new SparseArray<>();\n+\n     /**\n      * Set of system apps that are headless (don't have any declared activities, enabled or\n      * disabled). Presence in this map indicates that the app is a headless system app.\n@@ -1088,6 +1092,9 @@ public class AppStandbyController\n             synchronized (mActiveAdminApps) {\n                 mActiveAdminApps.remove(userId);\n             }\n+            synchronized (mAdminProtectedPackages) {\n+                mAdminProtectedPackages.remove(userId);\n+            }\n         }\n     }\n \n@@ -1177,6 +1184,10 @@ public class AppStandbyController\n                 return STANDBY_BUCKET_EXEMPTED;\n             }\n \n+            if (isAdminProtectedPackages(packageName, userId)) {\n+                return STANDBY_BUCKET_EXEMPTED;\n+            }\n+\n             if (isActiveNetworkScorer(packageName)) {\n                 return STANDBY_BUCKET_EXEMPTED;\n             }\n@@ -1583,6 +1594,17 @@ public class AppStandbyController\n         }\n     }\n \n+    private boolean isAdminProtectedPackages(String packageName, int userId) {\n+        synchronized (mAdminProtectedPackages) {\n+            if (mAdminProtectedPackages.contains(UserHandle.USER_ALL)\n+                    && mAdminProtectedPackages.get(UserHandle.USER_ALL).contains(packageName)) {\n+                return true;\n+            }\n+            return mAdminProtectedPackages.contains(userId)\n+                    && mAdminProtectedPackages.get(userId).contains(packageName);\n+        }\n+    }\n+\n     @Override\n     public void addActiveDeviceAdmin(String adminPkg, int userId) {\n         synchronized (mActiveAdminApps) {\n@@ -1606,6 +1628,17 @@ public class AppStandbyController\n         }\n     }\n \n+    @Override\n+    public void setAdminProtectedPackages(Set<String> packageNames, int userId) {\n+        synchronized (mAdminProtectedPackages) {\n+            if (packageNames == null || packageNames.isEmpty()) {\n+                mAdminProtectedPackages.remove(userId);\n+            } else {\n+                mAdminProtectedPackages.put(userId, packageNames);\n+            }\n+        }\n+    }\n+\n     @Override\n     public void onAdminDataAvailable() {\n         mAdminDataAvailableLatch.countDown();\n@@ -1628,6 +1661,13 @@ public class AppStandbyController\n         }\n     }\n \n+    @VisibleForTesting\n+    Set<String> getAdminProtectedPackagesForTest(int userId) {\n+        synchronized (mAdminProtectedPackages) {\n+            return mAdminProtectedPackages.get(userId);\n+        }\n+    }\n+\n     /**\n      * Returns {@code true} if the supplied package is the device provisioning app. Otherwise,\n      * returns {@code false}.\n",
    "added_lines": 40,
    "deleted_lines": 0,
    "changed_methods": "AppStandbyController::getAppMinBucket, AppStandbyController::getAdminProtectedPackagesForTest, AppStandbyController::onUserRemoved, AppStandbyController::isAdminProtectedPackages, AppStandbyController::setAdminProtectedPackages"
   },
   {
    "filename": "DevicePolicyManager.java",
    "diff": "@@ -13573,7 +13573,8 @@ public class DevicePolicyManager {\n \n     /**\n      * Called by Device owner to disable user control over apps. User will not be able to clear\n-     * app data or force-stop packages.\n+     * app data or force-stop packages. Packages with user control disabled are exempted from\n+     * App Standby Buckets.\n      *\n      * @param admin which {@link DeviceAdminReceiver} this request is associated with\n      * @param packages The package names for the apps.\n",
    "added_lines": 2,
    "deleted_lines": 1,
    "changed_methods": ""
   },
   {
    "filename": "UsageStatsManagerInternal.java",
    "diff": "@@ -198,6 +198,16 @@ public abstract class UsageStatsManagerInternal {\n      */\n     public abstract void setActiveAdminApps(Set<String> adminApps, int userId);\n \n+    /**\n+     * Called by DevicePolicyManagerService to inform about the protected packages for a user.\n+     * User control will be disabled for protected packages.\n+     *\n+     * @param packageNames the set of protected packages for {@code userId}.\n+     * @param userId the userId to which the protected packages belong.\n+     */\n+    public abstract void setAdminProtectedPackages(@Nullable Set<String> packageNames,\n+            @UserIdInt int userId);\n+\n     /**\n      * Called by DevicePolicyManagerService during boot to inform that admin data is loaded and\n      * pushed to UsageStatsService.\n",
    "added_lines": 10,
    "deleted_lines": 0,
    "changed_methods": ""
   },
   {
    "filename": "DevicePolicyManagerService.java",
    "diff": "@@ -1341,7 +1341,7 @@ public class DevicePolicyManagerService extends BaseIDevicePolicyManager {\n         Owners newOwners() {\n             return new Owners(getUserManager(), getUserManagerInternal(),\n                     getPackageManagerInternal(), getActivityTaskManagerInternal(),\n-                    getActivityManagerInternal());\n+                    getActivityManagerInternal(), getUsageStatsManagerInternal());\n         }\n \n         UserManager getUserManager() {\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "DevicePolicyManagerService::Injector::newOwners"
   },
   {
    "filename": "Owners.java",
    "diff": "@@ -24,6 +24,7 @@ import android.app.AppOpsManagerInternal;\n import android.app.admin.DevicePolicyManager.DeviceOwnerType;\n import android.app.admin.SystemUpdateInfo;\n import android.app.admin.SystemUpdatePolicy;\n+import android.app.usage.UsageStatsManagerInternal;\n import android.content.ComponentName;\n import android.content.pm.PackageManager;\n import android.content.pm.PackageManagerInternal;\n@@ -123,6 +124,7 @@ class Owners {\n     private final PackageManagerInternal mPackageManagerInternal;\n     private final ActivityTaskManagerInternal mActivityTaskManagerInternal;\n     private final ActivityManagerInternal mActivityManagerInternal;\n+    private final UsageStatsManagerInternal mUsageStatsManagerInternal;\n \n     private boolean mSystemReady;\n \n@@ -155,9 +157,11 @@ class Owners {\n             UserManagerInternal userManagerInternal,\n             PackageManagerInternal packageManagerInternal,\n             ActivityTaskManagerInternal activityTaskManagerInternal,\n-            ActivityManagerInternal activitykManagerInternal) {\n+            ActivityManagerInternal activitykManagerInternal,\n+            UsageStatsManagerInternal usageStatsManagerInternal) {\n         this(userManager, userManagerInternal, packageManagerInternal,\n-                activityTaskManagerInternal, activitykManagerInternal, new Injector());\n+                activityTaskManagerInternal, activitykManagerInternal,\n+                usageStatsManagerInternal, new Injector());\n     }\n \n     @VisibleForTesting\n@@ -166,12 +170,14 @@ class Owners {\n             PackageManagerInternal packageManagerInternal,\n             ActivityTaskManagerInternal activityTaskManagerInternal,\n             ActivityManagerInternal activityManagerInternal,\n+            UsageStatsManagerInternal usageStatsManagerInternal,\n             Injector injector) {\n         mUserManager = userManager;\n         mUserManagerInternal = userManagerInternal;\n         mPackageManagerInternal = packageManagerInternal;\n         mActivityTaskManagerInternal = activityTaskManagerInternal;\n         mActivityManagerInternal = activityManagerInternal;\n+        mUsageStatsManagerInternal = usageStatsManagerInternal;\n         mInjector = injector;\n     }\n \n@@ -226,6 +232,8 @@ class Owners {\n                     mDeviceOwnerProtectedPackages.entrySet()) {\n                 mPackageManagerInternal.setDeviceOwnerProtectedPackages(\n                         entry.getKey(), entry.getValue());\n+                mUsageStatsManagerInternal.setAdminProtectedPackages(\n+                        new ArraySet(entry.getValue()), UserHandle.USER_ALL);\n             }\n         }\n     }\n@@ -359,6 +367,8 @@ class Owners {\n             if (protectedPackages != null) {\n                 mPackageManagerInternal.setDeviceOwnerProtectedPackages(\n                         mDeviceOwner.packageName, new ArrayList<>());\n+                mUsageStatsManagerInternal.setAdminProtectedPackages(\n+                        Collections.emptySet(), UserHandle.USER_ALL);\n             }\n             mDeviceOwner = null;\n             mDeviceOwnerUserId = UserHandle.USER_NULL;\n@@ -416,6 +426,8 @@ class Owners {\n             if (previousProtectedPackages != null) {\n                 mPackageManagerInternal.setDeviceOwnerProtectedPackages(\n                         mDeviceOwner.packageName, new ArrayList<>());\n+                mUsageStatsManagerInternal.setAdminProtectedPackages(\n+                        Collections.emptySet(), UserHandle.USER_ALL);\n             }\n             // We don't set a name because it's not used anyway.\n             // See DevicePolicyManagerService#getDeviceOwnerName\n@@ -684,6 +696,8 @@ class Owners {\n \n             mDeviceOwnerProtectedPackages.put(packageName, protectedPackages);\n             mPackageManagerInternal.setDeviceOwnerProtectedPackages(packageName, protectedPackages);\n+            mUsageStatsManagerInternal.setAdminProtectedPackages(\n+                        new ArraySet(protectedPackages), UserHandle.USER_ALL);\n             writeDeviceOwner();\n         }\n     }\n",
    "added_lines": 16,
    "deleted_lines": 2,
    "changed_methods": "Owners::transferDeviceOwnership, Owners::clearDeviceOwner, Owners::load, Owners::setDeviceOwnerProtectedPackages, Owners::Owners, Owners::Owners, Owners::Owners"
   },
   {
    "filename": "DevicePolicyManagerServiceTestable.java",
    "diff": "@@ -69,7 +69,8 @@ public class DevicePolicyManagerServiceTestable extends DevicePolicyManagerServi\n         public OwnersTestable(MockSystemServices services) {\n             super(services.userManager, services.userManagerInternal,\n                     services.packageManagerInternal, services.activityTaskManagerInternal,\n-                    services.activityManagerInternal, new MockInjector(services));\n+                    services.activityManagerInternal, services.usageStatsManagerInternal,\n+                    new MockInjector(services));\n         }\n \n         static class MockInjector extends Injector {\n",
    "added_lines": 2,
    "deleted_lines": 1,
    "changed_methods": "DevicePolicyManagerServiceTestable::OwnersTestable::OwnersTestable"
   },
   {
    "filename": "AppStandbyControllerTests.java",
    "diff": "@@ -152,6 +152,9 @@ public class AppStandbyControllerTests {\n     private static final String ADMIN_PKG2 = \"com.android.admin2\";\n     private static final String ADMIN_PKG3 = \"com.android.admin3\";\n \n+    private static final String ADMIN_PROTECTED_PKG = \"com.android.admin.protected\";\n+    private static final String ADMIN_PROTECTED_PKG2 = \"com.android.admin.protected2\";\n+\n     private static final long MINUTE_MS = 60 * 1000;\n     private static final long HOUR_MS = 60 * MINUTE_MS;\n     private static final long DAY_MS = 24 * HOUR_MS;\n@@ -1631,6 +1634,19 @@ public class AppStandbyControllerTests {\n         assertIsNotActiveAdmin(ADMIN_PKG2, USER_ID);\n     }\n \n+    @Test\n+    public void testSetAdminProtectedPackages() {\n+        assertAdminProtectedPackagesForTest(USER_ID, (String[]) null);\n+        assertAdminProtectedPackagesForTest(USER_ID2, (String[]) null);\n+\n+        setAdminProtectedPackages(USER_ID, ADMIN_PROTECTED_PKG, ADMIN_PROTECTED_PKG2);\n+        assertAdminProtectedPackagesForTest(USER_ID, ADMIN_PROTECTED_PKG, ADMIN_PROTECTED_PKG2);\n+        assertAdminProtectedPackagesForTest(USER_ID2, (String[]) null);\n+\n+        setAdminProtectedPackages(USER_ID, (String[]) null);\n+        assertAdminProtectedPackagesForTest(USER_ID, (String[]) null);\n+    }\n+\n     @Test\n     @FlakyTest(bugId = 185169504)\n     public void testUserInteraction_CrossProfile() throws Exception {\n@@ -2025,6 +2041,28 @@ public class AppStandbyControllerTests {\n         mController.setActiveAdminApps(new ArraySet<>(Arrays.asList(admins)), userId);\n     }\n \n+    private void setAdminProtectedPackages(int userId, String... packageNames) {\n+        Set<String> adminProtectedPackages = packageNames != null ? new ArraySet<>(\n+                Arrays.asList(packageNames)) : null;\n+        mController.setAdminProtectedPackages(adminProtectedPackages, userId);\n+    }\n+\n+    private void assertAdminProtectedPackagesForTest(int userId, String... packageNames) {\n+        final Set<String> actualAdminProtectedPackages =\n+                mController.getAdminProtectedPackagesForTest(userId);\n+        if (packageNames == null) {\n+            if (actualAdminProtectedPackages != null && !actualAdminProtectedPackages.isEmpty()) {\n+                fail(\"Admin protected packages should be null; \" + getAdminAppsStr(userId,\n+                        actualAdminProtectedPackages));\n+            }\n+            return;\n+        }\n+        assertEquals(packageNames.length, actualAdminProtectedPackages.size());\n+        for (String adminProtectedPackage : packageNames) {\n+            assertTrue(actualAdminProtectedPackages.contains(adminProtectedPackage));\n+        }\n+    }\n+\n     private void setAndAssertBucket(String pkg, int user, int bucket, int reason) throws Exception {\n         rearmLatch(pkg);\n         mController.setAppStandbyBucket(pkg, user, bucket, reason);\n",
    "added_lines": 38,
    "deleted_lines": 0,
    "changed_methods": "AppStandbyControllerTests::testSetAdminProtectedPackages, AppStandbyControllerTests::assertAdminProtectedPackagesForTest, AppStandbyControllerTests::setAdminProtectedPackages"
   },
   {
    "filename": "UsageStatsService.java",
    "diff": "@@ -2494,6 +2494,11 @@ public class UsageStatsService extends SystemService implements\n             mAppStandby.setActiveAdminApps(packageNames, userId);\n         }\n \n+        @Override\n+        public void setAdminProtectedPackages(Set<String> packageNames, int userId) {\n+            mAppStandby.setAdminProtectedPackages(packageNames, userId);\n+        }\n+\n         @Override\n         public void onAdminDataAvailable() {\n             mAppStandby.onAdminDataAvailable();\n",
    "added_lines": 5,
    "deleted_lines": 0,
    "changed_methods": "UsageStatsService::LocalService::setAdminProtectedPackages"
   }
  ]
 },
 {
  "hash": "645206dd8566eb1b4ca286b4c0ede04b4e057fd4",
  "commit": "Enforce DevicePolicyManager.setUserControlDisabledPackages in AppStandbyController\n\nWhen deciding an app's standby bucket, check if the\napp has its user control disabled by an IT admin. If so,\nthe app should be the exempted restricted bucket.\n\nBug: 272042183\nTest: atest AppStandbyControllerTests\n(cherry picked from commit 269fcb6873dee199dd8023831f882aafff1f6291)\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:3dbab873d6d8f78c4d498a575ad37fd0dc20efbe)\nMerged-In: I4279dc37f0e17aedb1c2a87468478248443a253e\nChange-Id: I4279dc37f0e17aedb1c2a87468478248443a253e",
  "files": [
   {
    "filename": "AppStandbyInternal.java",
    "diff": "@@ -157,6 +157,8 @@ public interface AppStandbyInternal {\n \n     void setActiveAdminApps(Set<String> adminPkgs, int userId);\n \n+    void setAdminProtectedPackages(Set<String> packageNames, int userId);\n+\n     void onAdminDataAvailable();\n \n     void clearCarrierPrivilegedApps();\n",
    "added_lines": 2,
    "deleted_lines": 0,
    "changed_methods": ""
   },
   {
    "filename": "AppStandbyController.java",
    "diff": "@@ -247,6 +247,10 @@ public class AppStandbyController\n     @GuardedBy(\"mActiveAdminApps\")\n     private final SparseArray<Set<String>> mActiveAdminApps = new SparseArray<>();\n \n+    /** List of admin protected packages. Can contain {@link android.os.UserHandle#USER_ALL}. */\n+    @GuardedBy(\"mAdminProtectedPackages\")\n+    private final SparseArray<Set<String>> mAdminProtectedPackages = new SparseArray<>();\n+\n     /**\n      * Set of system apps that are headless (don't have any declared activities, enabled or\n      * disabled). Presence in this map indicates that the app is a headless system app.\n@@ -1088,6 +1092,9 @@ public class AppStandbyController\n             synchronized (mActiveAdminApps) {\n                 mActiveAdminApps.remove(userId);\n             }\n+            synchronized (mAdminProtectedPackages) {\n+                mAdminProtectedPackages.remove(userId);\n+            }\n         }\n     }\n \n@@ -1177,6 +1184,10 @@ public class AppStandbyController\n                 return STANDBY_BUCKET_EXEMPTED;\n             }\n \n+            if (isAdminProtectedPackages(packageName, userId)) {\n+                return STANDBY_BUCKET_EXEMPTED;\n+            }\n+\n             if (isActiveNetworkScorer(packageName)) {\n                 return STANDBY_BUCKET_EXEMPTED;\n             }\n@@ -1583,6 +1594,17 @@ public class AppStandbyController\n         }\n     }\n \n+    private boolean isAdminProtectedPackages(String packageName, int userId) {\n+        synchronized (mAdminProtectedPackages) {\n+            if (mAdminProtectedPackages.contains(UserHandle.USER_ALL)\n+                    && mAdminProtectedPackages.get(UserHandle.USER_ALL).contains(packageName)) {\n+                return true;\n+            }\n+            return mAdminProtectedPackages.contains(userId)\n+                    && mAdminProtectedPackages.get(userId).contains(packageName);\n+        }\n+    }\n+\n     @Override\n     public void addActiveDeviceAdmin(String adminPkg, int userId) {\n         synchronized (mActiveAdminApps) {\n@@ -1606,6 +1628,17 @@ public class AppStandbyController\n         }\n     }\n \n+    @Override\n+    public void setAdminProtectedPackages(Set<String> packageNames, int userId) {\n+        synchronized (mAdminProtectedPackages) {\n+            if (packageNames == null || packageNames.isEmpty()) {\n+                mAdminProtectedPackages.remove(userId);\n+            } else {\n+                mAdminProtectedPackages.put(userId, packageNames);\n+            }\n+        }\n+    }\n+\n     @Override\n     public void onAdminDataAvailable() {\n         mAdminDataAvailableLatch.countDown();\n@@ -1628,6 +1661,13 @@ public class AppStandbyController\n         }\n     }\n \n+    @VisibleForTesting\n+    Set<String> getAdminProtectedPackagesForTest(int userId) {\n+        synchronized (mAdminProtectedPackages) {\n+            return mAdminProtectedPackages.get(userId);\n+        }\n+    }\n+\n     /**\n      * Returns {@code true} if the supplied package is the device provisioning app. Otherwise,\n      * returns {@code false}.\n",
    "added_lines": 40,
    "deleted_lines": 0,
    "changed_methods": "AppStandbyController::getAppMinBucket, AppStandbyController::getAdminProtectedPackagesForTest, AppStandbyController::onUserRemoved, AppStandbyController::isAdminProtectedPackages, AppStandbyController::setAdminProtectedPackages"
   },
   {
    "filename": "DevicePolicyManager.java",
    "diff": "@@ -13573,7 +13573,8 @@ public class DevicePolicyManager {\n \n     /**\n      * Called by Device owner to disable user control over apps. User will not be able to clear\n-     * app data or force-stop packages.\n+     * app data or force-stop packages. Packages with user control disabled are exempted from\n+     * App Standby Buckets.\n      *\n      * @param admin which {@link DeviceAdminReceiver} this request is associated with\n      * @param packages The package names for the apps.\n",
    "added_lines": 2,
    "deleted_lines": 1,
    "changed_methods": ""
   },
   {
    "filename": "UsageStatsManagerInternal.java",
    "diff": "@@ -198,6 +198,16 @@ public abstract class UsageStatsManagerInternal {\n      */\n     public abstract void setActiveAdminApps(Set<String> adminApps, int userId);\n \n+    /**\n+     * Called by DevicePolicyManagerService to inform about the protected packages for a user.\n+     * User control will be disabled for protected packages.\n+     *\n+     * @param packageNames the set of protected packages for {@code userId}.\n+     * @param userId the userId to which the protected packages belong.\n+     */\n+    public abstract void setAdminProtectedPackages(@Nullable Set<String> packageNames,\n+            @UserIdInt int userId);\n+\n     /**\n      * Called by DevicePolicyManagerService during boot to inform that admin data is loaded and\n      * pushed to UsageStatsService.\n",
    "added_lines": 10,
    "deleted_lines": 0,
    "changed_methods": ""
   },
   {
    "filename": "DevicePolicyManagerService.java",
    "diff": "@@ -1341,7 +1341,7 @@ public class DevicePolicyManagerService extends BaseIDevicePolicyManager {\n         Owners newOwners() {\n             return new Owners(getUserManager(), getUserManagerInternal(),\n                     getPackageManagerInternal(), getActivityTaskManagerInternal(),\n-                    getActivityManagerInternal());\n+                    getActivityManagerInternal(), getUsageStatsManagerInternal());\n         }\n \n         UserManager getUserManager() {\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "DevicePolicyManagerService::Injector::newOwners"
   },
   {
    "filename": "Owners.java",
    "diff": "@@ -24,6 +24,7 @@ import android.app.AppOpsManagerInternal;\n import android.app.admin.DevicePolicyManager.DeviceOwnerType;\n import android.app.admin.SystemUpdateInfo;\n import android.app.admin.SystemUpdatePolicy;\n+import android.app.usage.UsageStatsManagerInternal;\n import android.content.ComponentName;\n import android.content.pm.PackageManager;\n import android.content.pm.PackageManagerInternal;\n@@ -123,6 +124,7 @@ class Owners {\n     private final PackageManagerInternal mPackageManagerInternal;\n     private final ActivityTaskManagerInternal mActivityTaskManagerInternal;\n     private final ActivityManagerInternal mActivityManagerInternal;\n+    private final UsageStatsManagerInternal mUsageStatsManagerInternal;\n \n     private boolean mSystemReady;\n \n@@ -155,9 +157,11 @@ class Owners {\n             UserManagerInternal userManagerInternal,\n             PackageManagerInternal packageManagerInternal,\n             ActivityTaskManagerInternal activityTaskManagerInternal,\n-            ActivityManagerInternal activitykManagerInternal) {\n+            ActivityManagerInternal activitykManagerInternal,\n+            UsageStatsManagerInternal usageStatsManagerInternal) {\n         this(userManager, userManagerInternal, packageManagerInternal,\n-                activityTaskManagerInternal, activitykManagerInternal, new Injector());\n+                activityTaskManagerInternal, activitykManagerInternal,\n+                usageStatsManagerInternal, new Injector());\n     }\n \n     @VisibleForTesting\n@@ -166,12 +170,14 @@ class Owners {\n             PackageManagerInternal packageManagerInternal,\n             ActivityTaskManagerInternal activityTaskManagerInternal,\n             ActivityManagerInternal activityManagerInternal,\n+            UsageStatsManagerInternal usageStatsManagerInternal,\n             Injector injector) {\n         mUserManager = userManager;\n         mUserManagerInternal = userManagerInternal;\n         mPackageManagerInternal = packageManagerInternal;\n         mActivityTaskManagerInternal = activityTaskManagerInternal;\n         mActivityManagerInternal = activityManagerInternal;\n+        mUsageStatsManagerInternal = usageStatsManagerInternal;\n         mInjector = injector;\n     }\n \n@@ -226,6 +232,8 @@ class Owners {\n                     mDeviceOwnerProtectedPackages.entrySet()) {\n                 mPackageManagerInternal.setDeviceOwnerProtectedPackages(\n                         entry.getKey(), entry.getValue());\n+                mUsageStatsManagerInternal.setAdminProtectedPackages(\n+                        new ArraySet(entry.getValue()), UserHandle.USER_ALL);\n             }\n         }\n     }\n@@ -359,6 +367,8 @@ class Owners {\n             if (protectedPackages != null) {\n                 mPackageManagerInternal.setDeviceOwnerProtectedPackages(\n                         mDeviceOwner.packageName, new ArrayList<>());\n+                mUsageStatsManagerInternal.setAdminProtectedPackages(\n+                        Collections.emptySet(), UserHandle.USER_ALL);\n             }\n             mDeviceOwner = null;\n             mDeviceOwnerUserId = UserHandle.USER_NULL;\n@@ -416,6 +426,8 @@ class Owners {\n             if (previousProtectedPackages != null) {\n                 mPackageManagerInternal.setDeviceOwnerProtectedPackages(\n                         mDeviceOwner.packageName, new ArrayList<>());\n+                mUsageStatsManagerInternal.setAdminProtectedPackages(\n+                        Collections.emptySet(), UserHandle.USER_ALL);\n             }\n             // We don't set a name because it's not used anyway.\n             // See DevicePolicyManagerService#getDeviceOwnerName\n@@ -684,6 +696,8 @@ class Owners {\n \n             mDeviceOwnerProtectedPackages.put(packageName, protectedPackages);\n             mPackageManagerInternal.setDeviceOwnerProtectedPackages(packageName, protectedPackages);\n+            mUsageStatsManagerInternal.setAdminProtectedPackages(\n+                        new ArraySet(protectedPackages), UserHandle.USER_ALL);\n             writeDeviceOwner();\n         }\n     }\n",
    "added_lines": 16,
    "deleted_lines": 2,
    "changed_methods": "Owners::transferDeviceOwnership, Owners::clearDeviceOwner, Owners::load, Owners::setDeviceOwnerProtectedPackages, Owners::Owners, Owners::Owners, Owners::Owners"
   },
   {
    "filename": "DevicePolicyManagerServiceTestable.java",
    "diff": "@@ -69,7 +69,8 @@ public class DevicePolicyManagerServiceTestable extends DevicePolicyManagerServi\n         public OwnersTestable(MockSystemServices services) {\n             super(services.userManager, services.userManagerInternal,\n                     services.packageManagerInternal, services.activityTaskManagerInternal,\n-                    services.activityManagerInternal, new MockInjector(services));\n+                    services.activityManagerInternal, services.usageStatsManagerInternal,\n+                    new MockInjector(services));\n         }\n \n         static class MockInjector extends Injector {\n",
    "added_lines": 2,
    "deleted_lines": 1,
    "changed_methods": "DevicePolicyManagerServiceTestable::OwnersTestable::OwnersTestable"
   },
   {
    "filename": "AppStandbyControllerTests.java",
    "diff": "@@ -152,6 +152,9 @@ public class AppStandbyControllerTests {\n     private static final String ADMIN_PKG2 = \"com.android.admin2\";\n     private static final String ADMIN_PKG3 = \"com.android.admin3\";\n \n+    private static final String ADMIN_PROTECTED_PKG = \"com.android.admin.protected\";\n+    private static final String ADMIN_PROTECTED_PKG2 = \"com.android.admin.protected2\";\n+\n     private static final long MINUTE_MS = 60 * 1000;\n     private static final long HOUR_MS = 60 * MINUTE_MS;\n     private static final long DAY_MS = 24 * HOUR_MS;\n@@ -1631,6 +1634,19 @@ public class AppStandbyControllerTests {\n         assertIsNotActiveAdmin(ADMIN_PKG2, USER_ID);\n     }\n \n+    @Test\n+    public void testSetAdminProtectedPackages() {\n+        assertAdminProtectedPackagesForTest(USER_ID, (String[]) null);\n+        assertAdminProtectedPackagesForTest(USER_ID2, (String[]) null);\n+\n+        setAdminProtectedPackages(USER_ID, ADMIN_PROTECTED_PKG, ADMIN_PROTECTED_PKG2);\n+        assertAdminProtectedPackagesForTest(USER_ID, ADMIN_PROTECTED_PKG, ADMIN_PROTECTED_PKG2);\n+        assertAdminProtectedPackagesForTest(USER_ID2, (String[]) null);\n+\n+        setAdminProtectedPackages(USER_ID, (String[]) null);\n+        assertAdminProtectedPackagesForTest(USER_ID, (String[]) null);\n+    }\n+\n     @Test\n     @FlakyTest(bugId = 185169504)\n     public void testUserInteraction_CrossProfile() throws Exception {\n@@ -2025,6 +2041,28 @@ public class AppStandbyControllerTests {\n         mController.setActiveAdminApps(new ArraySet<>(Arrays.asList(admins)), userId);\n     }\n \n+    private void setAdminProtectedPackages(int userId, String... packageNames) {\n+        Set<String> adminProtectedPackages = packageNames != null ? new ArraySet<>(\n+                Arrays.asList(packageNames)) : null;\n+        mController.setAdminProtectedPackages(adminProtectedPackages, userId);\n+    }\n+\n+    private void assertAdminProtectedPackagesForTest(int userId, String... packageNames) {\n+        final Set<String> actualAdminProtectedPackages =\n+                mController.getAdminProtectedPackagesForTest(userId);\n+        if (packageNames == null) {\n+            if (actualAdminProtectedPackages != null && !actualAdminProtectedPackages.isEmpty()) {\n+                fail(\"Admin protected packages should be null; \" + getAdminAppsStr(userId,\n+                        actualAdminProtectedPackages));\n+            }\n+            return;\n+        }\n+        assertEquals(packageNames.length, actualAdminProtectedPackages.size());\n+        for (String adminProtectedPackage : packageNames) {\n+            assertTrue(actualAdminProtectedPackages.contains(adminProtectedPackage));\n+        }\n+    }\n+\n     private void setAndAssertBucket(String pkg, int user, int bucket, int reason) throws Exception {\n         rearmLatch(pkg);\n         mController.setAppStandbyBucket(pkg, user, bucket, reason);\n",
    "added_lines": 38,
    "deleted_lines": 0,
    "changed_methods": "AppStandbyControllerTests::testSetAdminProtectedPackages, AppStandbyControllerTests::assertAdminProtectedPackagesForTest, AppStandbyControllerTests::setAdminProtectedPackages"
   },
   {
    "filename": "UsageStatsService.java",
    "diff": "@@ -2494,6 +2494,11 @@ public class UsageStatsService extends SystemService implements\n             mAppStandby.setActiveAdminApps(packageNames, userId);\n         }\n \n+        @Override\n+        public void setAdminProtectedPackages(Set<String> packageNames, int userId) {\n+            mAppStandby.setAdminProtectedPackages(packageNames, userId);\n+        }\n+\n         @Override\n         public void onAdminDataAvailable() {\n             mAppStandby.onAdminDataAvailable();\n",
    "added_lines": 5,
    "deleted_lines": 0,
    "changed_methods": "UsageStatsService::LocalService::setAdminProtectedPackages"
   }
  ]
 },
 {
  "hash": "645206dd8566eb1b4ca286b4c0ede04b4e057fd4",
  "commit": "Enforce DevicePolicyManager.setUserControlDisabledPackages in AppStandbyController\n\nWhen deciding an app's standby bucket, check if the\napp has its user control disabled by an IT admin. If so,\nthe app should be the exempted restricted bucket.\n\nBug: 272042183\nTest: atest AppStandbyControllerTests\n(cherry picked from commit 269fcb6873dee199dd8023831f882aafff1f6291)\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:3dbab873d6d8f78c4d498a575ad37fd0dc20efbe)\nMerged-In: I4279dc37f0e17aedb1c2a87468478248443a253e\nChange-Id: I4279dc37f0e17aedb1c2a87468478248443a253e",
  "files": [
   {
    "filename": "AppStandbyInternal.java",
    "diff": "@@ -157,6 +157,8 @@ public interface AppStandbyInternal {\n \n     void setActiveAdminApps(Set<String> adminPkgs, int userId);\n \n+    void setAdminProtectedPackages(Set<String> packageNames, int userId);\n+\n     void onAdminDataAvailable();\n \n     void clearCarrierPrivilegedApps();\n",
    "added_lines": 2,
    "deleted_lines": 0,
    "changed_methods": ""
   },
   {
    "filename": "AppStandbyController.java",
    "diff": "@@ -247,6 +247,10 @@ public class AppStandbyController\n     @GuardedBy(\"mActiveAdminApps\")\n     private final SparseArray<Set<String>> mActiveAdminApps = new SparseArray<>();\n \n+    /** List of admin protected packages. Can contain {@link android.os.UserHandle#USER_ALL}. */\n+    @GuardedBy(\"mAdminProtectedPackages\")\n+    private final SparseArray<Set<String>> mAdminProtectedPackages = new SparseArray<>();\n+\n     /**\n      * Set of system apps that are headless (don't have any declared activities, enabled or\n      * disabled). Presence in this map indicates that the app is a headless system app.\n@@ -1088,6 +1092,9 @@ public class AppStandbyController\n             synchronized (mActiveAdminApps) {\n                 mActiveAdminApps.remove(userId);\n             }\n+            synchronized (mAdminProtectedPackages) {\n+                mAdminProtectedPackages.remove(userId);\n+            }\n         }\n     }\n \n@@ -1177,6 +1184,10 @@ public class AppStandbyController\n                 return STANDBY_BUCKET_EXEMPTED;\n             }\n \n+            if (isAdminProtectedPackages(packageName, userId)) {\n+                return STANDBY_BUCKET_EXEMPTED;\n+            }\n+\n             if (isActiveNetworkScorer(packageName)) {\n                 return STANDBY_BUCKET_EXEMPTED;\n             }\n@@ -1583,6 +1594,17 @@ public class AppStandbyController\n         }\n     }\n \n+    private boolean isAdminProtectedPackages(String packageName, int userId) {\n+        synchronized (mAdminProtectedPackages) {\n+            if (mAdminProtectedPackages.contains(UserHandle.USER_ALL)\n+                    && mAdminProtectedPackages.get(UserHandle.USER_ALL).contains(packageName)) {\n+                return true;\n+            }\n+            return mAdminProtectedPackages.contains(userId)\n+                    && mAdminProtectedPackages.get(userId).contains(packageName);\n+        }\n+    }\n+\n     @Override\n     public void addActiveDeviceAdmin(String adminPkg, int userId) {\n         synchronized (mActiveAdminApps) {\n@@ -1606,6 +1628,17 @@ public class AppStandbyController\n         }\n     }\n \n+    @Override\n+    public void setAdminProtectedPackages(Set<String> packageNames, int userId) {\n+        synchronized (mAdminProtectedPackages) {\n+            if (packageNames == null || packageNames.isEmpty()) {\n+                mAdminProtectedPackages.remove(userId);\n+            } else {\n+                mAdminProtectedPackages.put(userId, packageNames);\n+            }\n+        }\n+    }\n+\n     @Override\n     public void onAdminDataAvailable() {\n         mAdminDataAvailableLatch.countDown();\n@@ -1628,6 +1661,13 @@ public class AppStandbyController\n         }\n     }\n \n+    @VisibleForTesting\n+    Set<String> getAdminProtectedPackagesForTest(int userId) {\n+        synchronized (mAdminProtectedPackages) {\n+            return mAdminProtectedPackages.get(userId);\n+        }\n+    }\n+\n     /**\n      * Returns {@code true} if the supplied package is the device provisioning app. Otherwise,\n      * returns {@code false}.\n",
    "added_lines": 40,
    "deleted_lines": 0,
    "changed_methods": "AppStandbyController::getAppMinBucket, AppStandbyController::getAdminProtectedPackagesForTest, AppStandbyController::onUserRemoved, AppStandbyController::isAdminProtectedPackages, AppStandbyController::setAdminProtectedPackages"
   },
   {
    "filename": "DevicePolicyManager.java",
    "diff": "@@ -13573,7 +13573,8 @@ public class DevicePolicyManager {\n \n     /**\n      * Called by Device owner to disable user control over apps. User will not be able to clear\n-     * app data or force-stop packages.\n+     * app data or force-stop packages. Packages with user control disabled are exempted from\n+     * App Standby Buckets.\n      *\n      * @param admin which {@link DeviceAdminReceiver} this request is associated with\n      * @param packages The package names for the apps.\n",
    "added_lines": 2,
    "deleted_lines": 1,
    "changed_methods": ""
   },
   {
    "filename": "UsageStatsManagerInternal.java",
    "diff": "@@ -198,6 +198,16 @@ public abstract class UsageStatsManagerInternal {\n      */\n     public abstract void setActiveAdminApps(Set<String> adminApps, int userId);\n \n+    /**\n+     * Called by DevicePolicyManagerService to inform about the protected packages for a user.\n+     * User control will be disabled for protected packages.\n+     *\n+     * @param packageNames the set of protected packages for {@code userId}.\n+     * @param userId the userId to which the protected packages belong.\n+     */\n+    public abstract void setAdminProtectedPackages(@Nullable Set<String> packageNames,\n+            @UserIdInt int userId);\n+\n     /**\n      * Called by DevicePolicyManagerService during boot to inform that admin data is loaded and\n      * pushed to UsageStatsService.\n",
    "added_lines": 10,
    "deleted_lines": 0,
    "changed_methods": ""
   },
   {
    "filename": "DevicePolicyManagerService.java",
    "diff": "@@ -1341,7 +1341,7 @@ public class DevicePolicyManagerService extends BaseIDevicePolicyManager {\n         Owners newOwners() {\n             return new Owners(getUserManager(), getUserManagerInternal(),\n                     getPackageManagerInternal(), getActivityTaskManagerInternal(),\n-                    getActivityManagerInternal());\n+                    getActivityManagerInternal(), getUsageStatsManagerInternal());\n         }\n \n         UserManager getUserManager() {\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "DevicePolicyManagerService::Injector::newOwners"
   },
   {
    "filename": "Owners.java",
    "diff": "@@ -24,6 +24,7 @@ import android.app.AppOpsManagerInternal;\n import android.app.admin.DevicePolicyManager.DeviceOwnerType;\n import android.app.admin.SystemUpdateInfo;\n import android.app.admin.SystemUpdatePolicy;\n+import android.app.usage.UsageStatsManagerInternal;\n import android.content.ComponentName;\n import android.content.pm.PackageManager;\n import android.content.pm.PackageManagerInternal;\n@@ -123,6 +124,7 @@ class Owners {\n     private final PackageManagerInternal mPackageManagerInternal;\n     private final ActivityTaskManagerInternal mActivityTaskManagerInternal;\n     private final ActivityManagerInternal mActivityManagerInternal;\n+    private final UsageStatsManagerInternal mUsageStatsManagerInternal;\n \n     private boolean mSystemReady;\n \n@@ -155,9 +157,11 @@ class Owners {\n             UserManagerInternal userManagerInternal,\n             PackageManagerInternal packageManagerInternal,\n             ActivityTaskManagerInternal activityTaskManagerInternal,\n-            ActivityManagerInternal activitykManagerInternal) {\n+            ActivityManagerInternal activitykManagerInternal,\n+            UsageStatsManagerInternal usageStatsManagerInternal) {\n         this(userManager, userManagerInternal, packageManagerInternal,\n-                activityTaskManagerInternal, activitykManagerInternal, new Injector());\n+                activityTaskManagerInternal, activitykManagerInternal,\n+                usageStatsManagerInternal, new Injector());\n     }\n \n     @VisibleForTesting\n@@ -166,12 +170,14 @@ class Owners {\n             PackageManagerInternal packageManagerInternal,\n             ActivityTaskManagerInternal activityTaskManagerInternal,\n             ActivityManagerInternal activityManagerInternal,\n+            UsageStatsManagerInternal usageStatsManagerInternal,\n             Injector injector) {\n         mUserManager = userManager;\n         mUserManagerInternal = userManagerInternal;\n         mPackageManagerInternal = packageManagerInternal;\n         mActivityTaskManagerInternal = activityTaskManagerInternal;\n         mActivityManagerInternal = activityManagerInternal;\n+        mUsageStatsManagerInternal = usageStatsManagerInternal;\n         mInjector = injector;\n     }\n \n@@ -226,6 +232,8 @@ class Owners {\n                     mDeviceOwnerProtectedPackages.entrySet()) {\n                 mPackageManagerInternal.setDeviceOwnerProtectedPackages(\n                         entry.getKey(), entry.getValue());\n+                mUsageStatsManagerInternal.setAdminProtectedPackages(\n+                        new ArraySet(entry.getValue()), UserHandle.USER_ALL);\n             }\n         }\n     }\n@@ -359,6 +367,8 @@ class Owners {\n             if (protectedPackages != null) {\n                 mPackageManagerInternal.setDeviceOwnerProtectedPackages(\n                         mDeviceOwner.packageName, new ArrayList<>());\n+                mUsageStatsManagerInternal.setAdminProtectedPackages(\n+                        Collections.emptySet(), UserHandle.USER_ALL);\n             }\n             mDeviceOwner = null;\n             mDeviceOwnerUserId = UserHandle.USER_NULL;\n@@ -416,6 +426,8 @@ class Owners {\n             if (previousProtectedPackages != null) {\n                 mPackageManagerInternal.setDeviceOwnerProtectedPackages(\n                         mDeviceOwner.packageName, new ArrayList<>());\n+                mUsageStatsManagerInternal.setAdminProtectedPackages(\n+                        Collections.emptySet(), UserHandle.USER_ALL);\n             }\n             // We don't set a name because it's not used anyway.\n             // See DevicePolicyManagerService#getDeviceOwnerName\n@@ -684,6 +696,8 @@ class Owners {\n \n             mDeviceOwnerProtectedPackages.put(packageName, protectedPackages);\n             mPackageManagerInternal.setDeviceOwnerProtectedPackages(packageName, protectedPackages);\n+            mUsageStatsManagerInternal.setAdminProtectedPackages(\n+                        new ArraySet(protectedPackages), UserHandle.USER_ALL);\n             writeDeviceOwner();\n         }\n     }\n",
    "added_lines": 16,
    "deleted_lines": 2,
    "changed_methods": "Owners::transferDeviceOwnership, Owners::clearDeviceOwner, Owners::load, Owners::setDeviceOwnerProtectedPackages, Owners::Owners, Owners::Owners, Owners::Owners"
   },
   {
    "filename": "DevicePolicyManagerServiceTestable.java",
    "diff": "@@ -69,7 +69,8 @@ public class DevicePolicyManagerServiceTestable extends DevicePolicyManagerServi\n         public OwnersTestable(MockSystemServices services) {\n             super(services.userManager, services.userManagerInternal,\n                     services.packageManagerInternal, services.activityTaskManagerInternal,\n-                    services.activityManagerInternal, new MockInjector(services));\n+                    services.activityManagerInternal, services.usageStatsManagerInternal,\n+                    new MockInjector(services));\n         }\n \n         static class MockInjector extends Injector {\n",
    "added_lines": 2,
    "deleted_lines": 1,
    "changed_methods": "DevicePolicyManagerServiceTestable::OwnersTestable::OwnersTestable"
   },
   {
    "filename": "AppStandbyControllerTests.java",
    "diff": "@@ -152,6 +152,9 @@ public class AppStandbyControllerTests {\n     private static final String ADMIN_PKG2 = \"com.android.admin2\";\n     private static final String ADMIN_PKG3 = \"com.android.admin3\";\n \n+    private static final String ADMIN_PROTECTED_PKG = \"com.android.admin.protected\";\n+    private static final String ADMIN_PROTECTED_PKG2 = \"com.android.admin.protected2\";\n+\n     private static final long MINUTE_MS = 60 * 1000;\n     private static final long HOUR_MS = 60 * MINUTE_MS;\n     private static final long DAY_MS = 24 * HOUR_MS;\n@@ -1631,6 +1634,19 @@ public class AppStandbyControllerTests {\n         assertIsNotActiveAdmin(ADMIN_PKG2, USER_ID);\n     }\n \n+    @Test\n+    public void testSetAdminProtectedPackages() {\n+        assertAdminProtectedPackagesForTest(USER_ID, (String[]) null);\n+        assertAdminProtectedPackagesForTest(USER_ID2, (String[]) null);\n+\n+        setAdminProtectedPackages(USER_ID, ADMIN_PROTECTED_PKG, ADMIN_PROTECTED_PKG2);\n+        assertAdminProtectedPackagesForTest(USER_ID, ADMIN_PROTECTED_PKG, ADMIN_PROTECTED_PKG2);\n+        assertAdminProtectedPackagesForTest(USER_ID2, (String[]) null);\n+\n+        setAdminProtectedPackages(USER_ID, (String[]) null);\n+        assertAdminProtectedPackagesForTest(USER_ID, (String[]) null);\n+    }\n+\n     @Test\n     @FlakyTest(bugId = 185169504)\n     public void testUserInteraction_CrossProfile() throws Exception {\n@@ -2025,6 +2041,28 @@ public class AppStandbyControllerTests {\n         mController.setActiveAdminApps(new ArraySet<>(Arrays.asList(admins)), userId);\n     }\n \n+    private void setAdminProtectedPackages(int userId, String... packageNames) {\n+        Set<String> adminProtectedPackages = packageNames != null ? new ArraySet<>(\n+                Arrays.asList(packageNames)) : null;\n+        mController.setAdminProtectedPackages(adminProtectedPackages, userId);\n+    }\n+\n+    private void assertAdminProtectedPackagesForTest(int userId, String... packageNames) {\n+        final Set<String> actualAdminProtectedPackages =\n+                mController.getAdminProtectedPackagesForTest(userId);\n+        if (packageNames == null) {\n+            if (actualAdminProtectedPackages != null && !actualAdminProtectedPackages.isEmpty()) {\n+                fail(\"Admin protected packages should be null; \" + getAdminAppsStr(userId,\n+                        actualAdminProtectedPackages));\n+            }\n+            return;\n+        }\n+        assertEquals(packageNames.length, actualAdminProtectedPackages.size());\n+        for (String adminProtectedPackage : packageNames) {\n+            assertTrue(actualAdminProtectedPackages.contains(adminProtectedPackage));\n+        }\n+    }\n+\n     private void setAndAssertBucket(String pkg, int user, int bucket, int reason) throws Exception {\n         rearmLatch(pkg);\n         mController.setAppStandbyBucket(pkg, user, bucket, reason);\n",
    "added_lines": 38,
    "deleted_lines": 0,
    "changed_methods": "AppStandbyControllerTests::testSetAdminProtectedPackages, AppStandbyControllerTests::assertAdminProtectedPackagesForTest, AppStandbyControllerTests::setAdminProtectedPackages"
   },
   {
    "filename": "UsageStatsService.java",
    "diff": "@@ -2494,6 +2494,11 @@ public class UsageStatsService extends SystemService implements\n             mAppStandby.setActiveAdminApps(packageNames, userId);\n         }\n \n+        @Override\n+        public void setAdminProtectedPackages(Set<String> packageNames, int userId) {\n+            mAppStandby.setAdminProtectedPackages(packageNames, userId);\n+        }\n+\n         @Override\n         public void onAdminDataAvailable() {\n             mAppStandby.onAdminDataAvailable();\n",
    "added_lines": 5,
    "deleted_lines": 0,
    "changed_methods": "UsageStatsService::LocalService::setAdminProtectedPackages"
   }
  ]
 },
 {
  "hash": "645206dd8566eb1b4ca286b4c0ede04b4e057fd4",
  "commit": "Enforce DevicePolicyManager.setUserControlDisabledPackages in AppStandbyController\n\nWhen deciding an app's standby bucket, check if the\napp has its user control disabled by an IT admin. If so,\nthe app should be the exempted restricted bucket.\n\nBug: 272042183\nTest: atest AppStandbyControllerTests\n(cherry picked from commit 269fcb6873dee199dd8023831f882aafff1f6291)\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:3dbab873d6d8f78c4d498a575ad37fd0dc20efbe)\nMerged-In: I4279dc37f0e17aedb1c2a87468478248443a253e\nChange-Id: I4279dc37f0e17aedb1c2a87468478248443a253e",
  "files": [
   {
    "filename": "AppStandbyInternal.java",
    "diff": "@@ -157,6 +157,8 @@ public interface AppStandbyInternal {\n \n     void setActiveAdminApps(Set<String> adminPkgs, int userId);\n \n+    void setAdminProtectedPackages(Set<String> packageNames, int userId);\n+\n     void onAdminDataAvailable();\n \n     void clearCarrierPrivilegedApps();\n",
    "added_lines": 2,
    "deleted_lines": 0,
    "changed_methods": ""
   },
   {
    "filename": "AppStandbyController.java",
    "diff": "@@ -247,6 +247,10 @@ public class AppStandbyController\n     @GuardedBy(\"mActiveAdminApps\")\n     private final SparseArray<Set<String>> mActiveAdminApps = new SparseArray<>();\n \n+    /** List of admin protected packages. Can contain {@link android.os.UserHandle#USER_ALL}. */\n+    @GuardedBy(\"mAdminProtectedPackages\")\n+    private final SparseArray<Set<String>> mAdminProtectedPackages = new SparseArray<>();\n+\n     /**\n      * Set of system apps that are headless (don't have any declared activities, enabled or\n      * disabled). Presence in this map indicates that the app is a headless system app.\n@@ -1088,6 +1092,9 @@ public class AppStandbyController\n             synchronized (mActiveAdminApps) {\n                 mActiveAdminApps.remove(userId);\n             }\n+            synchronized (mAdminProtectedPackages) {\n+                mAdminProtectedPackages.remove(userId);\n+            }\n         }\n     }\n \n@@ -1177,6 +1184,10 @@ public class AppStandbyController\n                 return STANDBY_BUCKET_EXEMPTED;\n             }\n \n+            if (isAdminProtectedPackages(packageName, userId)) {\n+                return STANDBY_BUCKET_EXEMPTED;\n+            }\n+\n             if (isActiveNetworkScorer(packageName)) {\n                 return STANDBY_BUCKET_EXEMPTED;\n             }\n@@ -1583,6 +1594,17 @@ public class AppStandbyController\n         }\n     }\n \n+    private boolean isAdminProtectedPackages(String packageName, int userId) {\n+        synchronized (mAdminProtectedPackages) {\n+            if (mAdminProtectedPackages.contains(UserHandle.USER_ALL)\n+                    && mAdminProtectedPackages.get(UserHandle.USER_ALL).contains(packageName)) {\n+                return true;\n+            }\n+            return mAdminProtectedPackages.contains(userId)\n+                    && mAdminProtectedPackages.get(userId).contains(packageName);\n+        }\n+    }\n+\n     @Override\n     public void addActiveDeviceAdmin(String adminPkg, int userId) {\n         synchronized (mActiveAdminApps) {\n@@ -1606,6 +1628,17 @@ public class AppStandbyController\n         }\n     }\n \n+    @Override\n+    public void setAdminProtectedPackages(Set<String> packageNames, int userId) {\n+        synchronized (mAdminProtectedPackages) {\n+            if (packageNames == null || packageNames.isEmpty()) {\n+                mAdminProtectedPackages.remove(userId);\n+            } else {\n+                mAdminProtectedPackages.put(userId, packageNames);\n+            }\n+        }\n+    }\n+\n     @Override\n     public void onAdminDataAvailable() {\n         mAdminDataAvailableLatch.countDown();\n@@ -1628,6 +1661,13 @@ public class AppStandbyController\n         }\n     }\n \n+    @VisibleForTesting\n+    Set<String> getAdminProtectedPackagesForTest(int userId) {\n+        synchronized (mAdminProtectedPackages) {\n+            return mAdminProtectedPackages.get(userId);\n+        }\n+    }\n+\n     /**\n      * Returns {@code true} if the supplied package is the device provisioning app. Otherwise,\n      * returns {@code false}.\n",
    "added_lines": 40,
    "deleted_lines": 0,
    "changed_methods": "AppStandbyController::getAppMinBucket, AppStandbyController::getAdminProtectedPackagesForTest, AppStandbyController::onUserRemoved, AppStandbyController::isAdminProtectedPackages, AppStandbyController::setAdminProtectedPackages"
   },
   {
    "filename": "DevicePolicyManager.java",
    "diff": "@@ -13573,7 +13573,8 @@ public class DevicePolicyManager {\n \n     /**\n      * Called by Device owner to disable user control over apps. User will not be able to clear\n-     * app data or force-stop packages.\n+     * app data or force-stop packages. Packages with user control disabled are exempted from\n+     * App Standby Buckets.\n      *\n      * @param admin which {@link DeviceAdminReceiver} this request is associated with\n      * @param packages The package names for the apps.\n",
    "added_lines": 2,
    "deleted_lines": 1,
    "changed_methods": ""
   },
   {
    "filename": "UsageStatsManagerInternal.java",
    "diff": "@@ -198,6 +198,16 @@ public abstract class UsageStatsManagerInternal {\n      */\n     public abstract void setActiveAdminApps(Set<String> adminApps, int userId);\n \n+    /**\n+     * Called by DevicePolicyManagerService to inform about the protected packages for a user.\n+     * User control will be disabled for protected packages.\n+     *\n+     * @param packageNames the set of protected packages for {@code userId}.\n+     * @param userId the userId to which the protected packages belong.\n+     */\n+    public abstract void setAdminProtectedPackages(@Nullable Set<String> packageNames,\n+            @UserIdInt int userId);\n+\n     /**\n      * Called by DevicePolicyManagerService during boot to inform that admin data is loaded and\n      * pushed to UsageStatsService.\n",
    "added_lines": 10,
    "deleted_lines": 0,
    "changed_methods": ""
   },
   {
    "filename": "DevicePolicyManagerService.java",
    "diff": "@@ -1341,7 +1341,7 @@ public class DevicePolicyManagerService extends BaseIDevicePolicyManager {\n         Owners newOwners() {\n             return new Owners(getUserManager(), getUserManagerInternal(),\n                     getPackageManagerInternal(), getActivityTaskManagerInternal(),\n-                    getActivityManagerInternal());\n+                    getActivityManagerInternal(), getUsageStatsManagerInternal());\n         }\n \n         UserManager getUserManager() {\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "DevicePolicyManagerService::Injector::newOwners"
   },
   {
    "filename": "Owners.java",
    "diff": "@@ -24,6 +24,7 @@ import android.app.AppOpsManagerInternal;\n import android.app.admin.DevicePolicyManager.DeviceOwnerType;\n import android.app.admin.SystemUpdateInfo;\n import android.app.admin.SystemUpdatePolicy;\n+import android.app.usage.UsageStatsManagerInternal;\n import android.content.ComponentName;\n import android.content.pm.PackageManager;\n import android.content.pm.PackageManagerInternal;\n@@ -123,6 +124,7 @@ class Owners {\n     private final PackageManagerInternal mPackageManagerInternal;\n     private final ActivityTaskManagerInternal mActivityTaskManagerInternal;\n     private final ActivityManagerInternal mActivityManagerInternal;\n+    private final UsageStatsManagerInternal mUsageStatsManagerInternal;\n \n     private boolean mSystemReady;\n \n@@ -155,9 +157,11 @@ class Owners {\n             UserManagerInternal userManagerInternal,\n             PackageManagerInternal packageManagerInternal,\n             ActivityTaskManagerInternal activityTaskManagerInternal,\n-            ActivityManagerInternal activitykManagerInternal) {\n+            ActivityManagerInternal activitykManagerInternal,\n+            UsageStatsManagerInternal usageStatsManagerInternal) {\n         this(userManager, userManagerInternal, packageManagerInternal,\n-                activityTaskManagerInternal, activitykManagerInternal, new Injector());\n+                activityTaskManagerInternal, activitykManagerInternal,\n+                usageStatsManagerInternal, new Injector());\n     }\n \n     @VisibleForTesting\n@@ -166,12 +170,14 @@ class Owners {\n             PackageManagerInternal packageManagerInternal,\n             ActivityTaskManagerInternal activityTaskManagerInternal,\n             ActivityManagerInternal activityManagerInternal,\n+            UsageStatsManagerInternal usageStatsManagerInternal,\n             Injector injector) {\n         mUserManager = userManager;\n         mUserManagerInternal = userManagerInternal;\n         mPackageManagerInternal = packageManagerInternal;\n         mActivityTaskManagerInternal = activityTaskManagerInternal;\n         mActivityManagerInternal = activityManagerInternal;\n+        mUsageStatsManagerInternal = usageStatsManagerInternal;\n         mInjector = injector;\n     }\n \n@@ -226,6 +232,8 @@ class Owners {\n                     mDeviceOwnerProtectedPackages.entrySet()) {\n                 mPackageManagerInternal.setDeviceOwnerProtectedPackages(\n                         entry.getKey(), entry.getValue());\n+                mUsageStatsManagerInternal.setAdminProtectedPackages(\n+                        new ArraySet(entry.getValue()), UserHandle.USER_ALL);\n             }\n         }\n     }\n@@ -359,6 +367,8 @@ class Owners {\n             if (protectedPackages != null) {\n                 mPackageManagerInternal.setDeviceOwnerProtectedPackages(\n                         mDeviceOwner.packageName, new ArrayList<>());\n+                mUsageStatsManagerInternal.setAdminProtectedPackages(\n+                        Collections.emptySet(), UserHandle.USER_ALL);\n             }\n             mDeviceOwner = null;\n             mDeviceOwnerUserId = UserHandle.USER_NULL;\n@@ -416,6 +426,8 @@ class Owners {\n             if (previousProtectedPackages != null) {\n                 mPackageManagerInternal.setDeviceOwnerProtectedPackages(\n                         mDeviceOwner.packageName, new ArrayList<>());\n+                mUsageStatsManagerInternal.setAdminProtectedPackages(\n+                        Collections.emptySet(), UserHandle.USER_ALL);\n             }\n             // We don't set a name because it's not used anyway.\n             // See DevicePolicyManagerService#getDeviceOwnerName\n@@ -684,6 +696,8 @@ class Owners {\n \n             mDeviceOwnerProtectedPackages.put(packageName, protectedPackages);\n             mPackageManagerInternal.setDeviceOwnerProtectedPackages(packageName, protectedPackages);\n+            mUsageStatsManagerInternal.setAdminProtectedPackages(\n+                        new ArraySet(protectedPackages), UserHandle.USER_ALL);\n             writeDeviceOwner();\n         }\n     }\n",
    "added_lines": 16,
    "deleted_lines": 2,
    "changed_methods": "Owners::transferDeviceOwnership, Owners::clearDeviceOwner, Owners::load, Owners::setDeviceOwnerProtectedPackages, Owners::Owners, Owners::Owners, Owners::Owners"
   },
   {
    "filename": "DevicePolicyManagerServiceTestable.java",
    "diff": "@@ -69,7 +69,8 @@ public class DevicePolicyManagerServiceTestable extends DevicePolicyManagerServi\n         public OwnersTestable(MockSystemServices services) {\n             super(services.userManager, services.userManagerInternal,\n                     services.packageManagerInternal, services.activityTaskManagerInternal,\n-                    services.activityManagerInternal, new MockInjector(services));\n+                    services.activityManagerInternal, services.usageStatsManagerInternal,\n+                    new MockInjector(services));\n         }\n \n         static class MockInjector extends Injector {\n",
    "added_lines": 2,
    "deleted_lines": 1,
    "changed_methods": "DevicePolicyManagerServiceTestable::OwnersTestable::OwnersTestable"
   },
   {
    "filename": "AppStandbyControllerTests.java",
    "diff": "@@ -152,6 +152,9 @@ public class AppStandbyControllerTests {\n     private static final String ADMIN_PKG2 = \"com.android.admin2\";\n     private static final String ADMIN_PKG3 = \"com.android.admin3\";\n \n+    private static final String ADMIN_PROTECTED_PKG = \"com.android.admin.protected\";\n+    private static final String ADMIN_PROTECTED_PKG2 = \"com.android.admin.protected2\";\n+\n     private static final long MINUTE_MS = 60 * 1000;\n     private static final long HOUR_MS = 60 * MINUTE_MS;\n     private static final long DAY_MS = 24 * HOUR_MS;\n@@ -1631,6 +1634,19 @@ public class AppStandbyControllerTests {\n         assertIsNotActiveAdmin(ADMIN_PKG2, USER_ID);\n     }\n \n+    @Test\n+    public void testSetAdminProtectedPackages() {\n+        assertAdminProtectedPackagesForTest(USER_ID, (String[]) null);\n+        assertAdminProtectedPackagesForTest(USER_ID2, (String[]) null);\n+\n+        setAdminProtectedPackages(USER_ID, ADMIN_PROTECTED_PKG, ADMIN_PROTECTED_PKG2);\n+        assertAdminProtectedPackagesForTest(USER_ID, ADMIN_PROTECTED_PKG, ADMIN_PROTECTED_PKG2);\n+        assertAdminProtectedPackagesForTest(USER_ID2, (String[]) null);\n+\n+        setAdminProtectedPackages(USER_ID, (String[]) null);\n+        assertAdminProtectedPackagesForTest(USER_ID, (String[]) null);\n+    }\n+\n     @Test\n     @FlakyTest(bugId = 185169504)\n     public void testUserInteraction_CrossProfile() throws Exception {\n@@ -2025,6 +2041,28 @@ public class AppStandbyControllerTests {\n         mController.setActiveAdminApps(new ArraySet<>(Arrays.asList(admins)), userId);\n     }\n \n+    private void setAdminProtectedPackages(int userId, String... packageNames) {\n+        Set<String> adminProtectedPackages = packageNames != null ? new ArraySet<>(\n+                Arrays.asList(packageNames)) : null;\n+        mController.setAdminProtectedPackages(adminProtectedPackages, userId);\n+    }\n+\n+    private void assertAdminProtectedPackagesForTest(int userId, String... packageNames) {\n+        final Set<String> actualAdminProtectedPackages =\n+                mController.getAdminProtectedPackagesForTest(userId);\n+        if (packageNames == null) {\n+            if (actualAdminProtectedPackages != null && !actualAdminProtectedPackages.isEmpty()) {\n+                fail(\"Admin protected packages should be null; \" + getAdminAppsStr(userId,\n+                        actualAdminProtectedPackages));\n+            }\n+            return;\n+        }\n+        assertEquals(packageNames.length, actualAdminProtectedPackages.size());\n+        for (String adminProtectedPackage : packageNames) {\n+            assertTrue(actualAdminProtectedPackages.contains(adminProtectedPackage));\n+        }\n+    }\n+\n     private void setAndAssertBucket(String pkg, int user, int bucket, int reason) throws Exception {\n         rearmLatch(pkg);\n         mController.setAppStandbyBucket(pkg, user, bucket, reason);\n",
    "added_lines": 38,
    "deleted_lines": 0,
    "changed_methods": "AppStandbyControllerTests::testSetAdminProtectedPackages, AppStandbyControllerTests::assertAdminProtectedPackagesForTest, AppStandbyControllerTests::setAdminProtectedPackages"
   },
   {
    "filename": "UsageStatsService.java",
    "diff": "@@ -2494,6 +2494,11 @@ public class UsageStatsService extends SystemService implements\n             mAppStandby.setActiveAdminApps(packageNames, userId);\n         }\n \n+        @Override\n+        public void setAdminProtectedPackages(Set<String> packageNames, int userId) {\n+            mAppStandby.setAdminProtectedPackages(packageNames, userId);\n+        }\n+\n         @Override\n         public void onAdminDataAvailable() {\n             mAppStandby.onAdminDataAvailable();\n",
    "added_lines": 5,
    "deleted_lines": 0,
    "changed_methods": "UsageStatsService::LocalService::setAdminProtectedPackages"
   }
  ]
 },
 {
  "hash": "59729e1be98eec30bcfe9600c48248729fc0203b",
  "commit": "[RESTRICT AUTOMERGE] Add BubbleMetadata detection to block FSI\n\nBug: 274759612\nTest: atest NotificationInterruptStateProviderImplTest\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:1bc1be92ce0d8bd8abd9efa13e85ac0d33556a3b)\nMerged-In: I40e1aa6377b8a60d91cb2f4189df1e9a4a4578a2\nChange-Id: I40e1aa6377b8a60d91cb2f4189df1e9a4a4578a2",
  "files": [
   {
    "filename": "NotificationInterruptStateProviderImpl.java",
    "diff": "@@ -18,6 +18,7 @@ package com.android.systemui.statusbar.notification.interruption;\n \n import static com.android.systemui.statusbar.StatusBarState.SHADE;\n \n+import android.app.Notification;\n import android.app.NotificationManager;\n import android.content.ContentResolver;\n import android.database.ContentObserver;\n@@ -210,6 +211,20 @@ public class NotificationInterruptStateProviderImpl implements NotificationInter\n             return false;\n         }\n \n+        // If the notification has suppressive BubbleMetadata, block FSI and warn.\n+        Notification.BubbleMetadata bubbleMetadata = sbn.getNotification().getBubbleMetadata();\n+        if (bubbleMetadata != null && bubbleMetadata.isNotificationSuppressed()) {\n+            // b/274759612: Detect and report an event when a notification has both an FSI and a\n+            // suppressive BubbleMetadata, and now correctly block the FSI from firing.\n+            final int uid = entry.getSbn().getUid();\n+            android.util.EventLog.writeEvent(0x534e4554, \"274759612\", uid, \"bubbleMetadata\");\n+            if (DEBUG) {\n+                Log.w(TAG, \"No FullScreenIntent: WARNING: BubbleMetadata may prevent HUN: \"\n+                        + entry.getKey());\n+            }\n+            return false;\n+        }\n+\n         // If the screen is off, then launch the FullScreenIntent\n         if (!mPowerManager.isInteractive()) {\n             if (DEBUG) {\n",
    "added_lines": 15,
    "deleted_lines": 0,
    "changed_methods": "NotificationInterruptStateProviderImpl::shouldLaunchFullScreenIntentWhenAdded"
   },
   {
    "filename": "NotificationInterruptStateProviderImplTest.java",
    "diff": "@@ -435,9 +435,27 @@ public class NotificationInterruptStateProviderImplTest extends SysuiTestCase {\n                 .isFalse();\n     }\n \n+\n+    @Test\n+    public void testShouldNotFullScreen_isSuppressedByBubbleMetadata() throws RemoteException {\n+        NotificationEntry entry = createFsiNotification(IMPORTANCE_HIGH, /* silenced */ false);\n+        Notification.BubbleMetadata bubbleMetadata = new Notification.BubbleMetadata.Builder(\"foo\")\n+                .setSuppressNotification(true).build();\n+        entry.getSbn().getNotification().setBubbleMetadata(bubbleMetadata);\n+        when(mPowerManager.isInteractive()).thenReturn(false);\n+        when(mDreamManager.isDreaming()).thenReturn(true);\n+        when(mStatusBarStateController.getState()).thenReturn(KEYGUARD);\n+\n+        assertThat(mNotifInterruptionStateProvider.shouldLaunchFullScreenIntentWhenAdded(entry))\n+                .isFalse();\n+    }\n+\n     @Test\n     public void testShouldFullScreen_notInteractive() throws RemoteException {\n         NotificationEntry entry = createFsiNotification(IMPORTANCE_HIGH, /* silenced */ false);\n+        Notification.BubbleMetadata bubbleMetadata = new Notification.BubbleMetadata.Builder(\"foo\")\n+                .setSuppressNotification(false).build();\n+        entry.getSbn().getNotification().setBubbleMetadata(bubbleMetadata);\n         when(mPowerManager.isInteractive()).thenReturn(false);\n         when(mDreamManager.isDreaming()).thenReturn(false);\n         when(mStatusBarStateController.getState()).thenReturn(SHADE);\n",
    "added_lines": 18,
    "deleted_lines": 0,
    "changed_methods": "NotificationInterruptStateProviderImplTest::testShouldFullScreen_notInteractive, NotificationInterruptStateProviderImplTest::testShouldNotFullScreen_isSuppressedByBubbleMetadata"
   }
  ]
 },
 {
  "hash": "59729e1be98eec30bcfe9600c48248729fc0203b",
  "commit": "[RESTRICT AUTOMERGE] Add BubbleMetadata detection to block FSI\n\nBug: 274759612\nTest: atest NotificationInterruptStateProviderImplTest\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:1bc1be92ce0d8bd8abd9efa13e85ac0d33556a3b)\nMerged-In: I40e1aa6377b8a60d91cb2f4189df1e9a4a4578a2\nChange-Id: I40e1aa6377b8a60d91cb2f4189df1e9a4a4578a2",
  "files": [
   {
    "filename": "NotificationInterruptStateProviderImpl.java",
    "diff": "@@ -18,6 +18,7 @@ package com.android.systemui.statusbar.notification.interruption;\n \n import static com.android.systemui.statusbar.StatusBarState.SHADE;\n \n+import android.app.Notification;\n import android.app.NotificationManager;\n import android.content.ContentResolver;\n import android.database.ContentObserver;\n@@ -210,6 +211,20 @@ public class NotificationInterruptStateProviderImpl implements NotificationInter\n             return false;\n         }\n \n+        // If the notification has suppressive BubbleMetadata, block FSI and warn.\n+        Notification.BubbleMetadata bubbleMetadata = sbn.getNotification().getBubbleMetadata();\n+        if (bubbleMetadata != null && bubbleMetadata.isNotificationSuppressed()) {\n+            // b/274759612: Detect and report an event when a notification has both an FSI and a\n+            // suppressive BubbleMetadata, and now correctly block the FSI from firing.\n+            final int uid = entry.getSbn().getUid();\n+            android.util.EventLog.writeEvent(0x534e4554, \"274759612\", uid, \"bubbleMetadata\");\n+            if (DEBUG) {\n+                Log.w(TAG, \"No FullScreenIntent: WARNING: BubbleMetadata may prevent HUN: \"\n+                        + entry.getKey());\n+            }\n+            return false;\n+        }\n+\n         // If the screen is off, then launch the FullScreenIntent\n         if (!mPowerManager.isInteractive()) {\n             if (DEBUG) {\n",
    "added_lines": 15,
    "deleted_lines": 0,
    "changed_methods": "NotificationInterruptStateProviderImpl::shouldLaunchFullScreenIntentWhenAdded"
   },
   {
    "filename": "NotificationInterruptStateProviderImplTest.java",
    "diff": "@@ -435,9 +435,27 @@ public class NotificationInterruptStateProviderImplTest extends SysuiTestCase {\n                 .isFalse();\n     }\n \n+\n+    @Test\n+    public void testShouldNotFullScreen_isSuppressedByBubbleMetadata() throws RemoteException {\n+        NotificationEntry entry = createFsiNotification(IMPORTANCE_HIGH, /* silenced */ false);\n+        Notification.BubbleMetadata bubbleMetadata = new Notification.BubbleMetadata.Builder(\"foo\")\n+                .setSuppressNotification(true).build();\n+        entry.getSbn().getNotification().setBubbleMetadata(bubbleMetadata);\n+        when(mPowerManager.isInteractive()).thenReturn(false);\n+        when(mDreamManager.isDreaming()).thenReturn(true);\n+        when(mStatusBarStateController.getState()).thenReturn(KEYGUARD);\n+\n+        assertThat(mNotifInterruptionStateProvider.shouldLaunchFullScreenIntentWhenAdded(entry))\n+                .isFalse();\n+    }\n+\n     @Test\n     public void testShouldFullScreen_notInteractive() throws RemoteException {\n         NotificationEntry entry = createFsiNotification(IMPORTANCE_HIGH, /* silenced */ false);\n+        Notification.BubbleMetadata bubbleMetadata = new Notification.BubbleMetadata.Builder(\"foo\")\n+                .setSuppressNotification(false).build();\n+        entry.getSbn().getNotification().setBubbleMetadata(bubbleMetadata);\n         when(mPowerManager.isInteractive()).thenReturn(false);\n         when(mDreamManager.isDreaming()).thenReturn(false);\n         when(mStatusBarStateController.getState()).thenReturn(SHADE);\n",
    "added_lines": 18,
    "deleted_lines": 0,
    "changed_methods": "NotificationInterruptStateProviderImplTest::testShouldFullScreen_notInteractive, NotificationInterruptStateProviderImplTest::testShouldNotFullScreen_isSuppressedByBubbleMetadata"
   }
  ]
 },
 {
  "hash": "fad839e2d005566d74fe8263c223f4c64e586712",
  "commit": "Prevent sharesheet from previewing unowned URIs\n\nBug: 261036568\nTest: manually via supplied tool (see bug)\n(cherry picked from commit 3062b80fb28014a7482d5fa8b2a5c852134a5845)\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:08809fa8c938ccc6f0cd21036fcc464a96d93384)\nMerged-In: I21accf6f753d2f676f1602d6e1ce829c5ef29e9a\nChange-Id: I21accf6f753d2f676f1602d6e1ce829c5ef29e9a",
  "files": [
   {
    "filename": "ChooserActivity.java",
    "diff": "@@ -16,6 +16,8 @@\n \n package com.android.internal.app;\n \n+import static android.content.ContentProvider.getUserIdFromUri;\n+\n import static java.lang.annotation.RetentionPolicy.SOURCE;\n \n import android.animation.Animator;\n@@ -149,6 +151,7 @@ import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n+import java.util.stream.Collectors;\n \n /**\n  * The Chooser Activity handles intent resolution specifically for sharing intents -\n@@ -1375,7 +1378,7 @@ public class ChooserActivity extends ResolverActivity implements\n \n             ImageView previewThumbnailView = contentPreviewLayout.findViewById(\n                     R.id.content_preview_thumbnail);\n-            if (previewThumbnail == null) {\n+            if (!validForContentPreview(previewThumbnail)) {\n                 previewThumbnailView.setVisibility(View.GONE);\n             } else {\n                 mPreviewCoord = new ContentPreviewCoordinator(contentPreviewLayout, false);\n@@ -1406,6 +1409,10 @@ public class ChooserActivity extends ResolverActivity implements\n \n         if (Intent.ACTION_SEND.equals(action)) {\n             Uri uri = targetIntent.getParcelableExtra(Intent.EXTRA_STREAM);\n+            if (!validForContentPreview(uri)) {\n+                contentPreviewLayout.setVisibility(View.GONE);\n+                return contentPreviewLayout;\n+            }\n             imagePreview.findViewById(R.id.content_preview_image_1_large)\n                     .setTransitionName(ChooserActivity.FIRST_IMAGE_PREVIEW_TRANSITION_NAME);\n             mPreviewCoord.loadUriIntoView(R.id.content_preview_image_1_large, uri, 0);\n@@ -1415,7 +1422,7 @@ public class ChooserActivity extends ResolverActivity implements\n             List<Uri> uris = targetIntent.getParcelableArrayListExtra(Intent.EXTRA_STREAM);\n             List<Uri> imageUris = new ArrayList<>();\n             for (Uri uri : uris) {\n-                if (isImageType(resolver.getType(uri))) {\n+                if (validForContentPreview(uri) && isImageType(resolver.getType(uri))) {\n                     imageUris.add(uri);\n                 }\n             }\n@@ -1524,9 +1531,16 @@ public class ChooserActivity extends ResolverActivity implements\n         String action = targetIntent.getAction();\n         if (Intent.ACTION_SEND.equals(action)) {\n             Uri uri = targetIntent.getParcelableExtra(Intent.EXTRA_STREAM);\n+            if (!validForContentPreview(uri)) {\n+                contentPreviewLayout.setVisibility(View.GONE);\n+                return contentPreviewLayout;\n+            }\n             loadFileUriIntoView(uri, contentPreviewLayout);\n         } else {\n             List<Uri> uris = targetIntent.getParcelableArrayListExtra(Intent.EXTRA_STREAM);\n+            uris = uris.stream()\n+                    .filter(ChooserActivity::validForContentPreview)\n+                    .collect(Collectors.toList());\n             int uriCount = uris.size();\n \n             if (uriCount == 0) {\n@@ -1580,6 +1594,24 @@ public class ChooserActivity extends ResolverActivity implements\n         }\n     }\n \n+    /**\n+     * Indicate if the incoming content URI should be allowed.\n+     *\n+     * @param uri the uri to test\n+     * @return true if the URI is allowed for content preview\n+     */\n+    private static boolean validForContentPreview(Uri uri) throws SecurityException {\n+        if (uri == null) {\n+            return false;\n+        }\n+        int userId = getUserIdFromUri(uri, UserHandle.USER_CURRENT);\n+        if (userId != UserHandle.USER_CURRENT && userId != UserHandle.myUserId()) {\n+            Log.e(TAG, \"dropped invalid content URI belonging to user \" + userId);\n+            return false;\n+        }\n+        return true;\n+    }\n+\n     @VisibleForTesting\n     protected boolean isImageType(String mimeType) {\n         return mimeType != null && mimeType.startsWith(\"image/\");\n",
    "added_lines": 34,
    "deleted_lines": 2,
    "changed_methods": "ChooserActivity::validForContentPreview, ChooserActivity::displayImageContentPreview, ChooserActivity::displayFileContentPreview, ChooserActivity::displayTextContentPreview"
   }
  ]
 },
 {
  "hash": "ddb8198e65c965ed74fdf4be5144a84d844802e0",
  "commit": "Sanitize VPN label to prevent HTML injection\n\nThis commit will try to sanitize the content of VpnDialog. This\ncommit creates a function which will try to sanitize the VPN\nlabel, if the sanitized VPN label is different from the original\none, which means the VPN label might contain HTML tag or the VPN\nlabel violates the words restriction(may contain some wording\nwhich will mislead the user). For this kind of case, show the\npackage name instead of the VPN label to prevent misleading the\nuser.\n\nThe malicious VPN app might be able to add a large number of line\nbreaks with HTML in order to hide the system-displayed text from\nthe user in the connection request dialog. Thus, sanitizing the\ncontent of the dialog is needed.\n\nBug: 204554636\nTest: N/A\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:2178216b98bf9865edee198f45192f0b883624ab)\nMerged-In: I8eb890fd2e5797d8d6ab5b12f9c628bc9616081d\nChange-Id: I8eb890fd2e5797d8d6ab5b12f9c628bc9616081d",
  "files": [
   {
    "filename": "ConfirmDialog.java",
    "diff": "@@ -40,12 +40,18 @@ public class ConfirmDialog extends AlertActivity\n         implements DialogInterface.OnClickListener, ImageGetter {\n     private static final String TAG = \"VpnConfirm\";\n \n+    // Usually the label represents the app name, 150 code points might be enough to display the app\n+    // name, and 150 code points won't cover the warning message from VpnDialog.\n+    static final int MAX_VPN_LABEL_LENGTH = 150;\n+\n     @VpnManager.VpnType private final int mVpnType;\n \n     private String mPackage;\n \n     private VpnManager mVm;\n \n+    private View mView;\n+\n     public ConfirmDialog() {\n         this(VpnManager.TYPE_VPN_SERVICE);\n     }\n@@ -54,6 +60,42 @@ public class ConfirmDialog extends AlertActivity\n         mVpnType = vpnType;\n     }\n \n+    /**\n+     * This function will use the string resource to combine the VPN label and the package name.\n+     *\n+     * If the VPN label violates the length restriction, the first 30 code points of VPN label and\n+     * the package name will be returned. Or return the VPN label and the package name directly if\n+     * the VPN label doesn't violate the length restriction.\n+     *\n+     * The result will be something like,\n+     * - ThisIsAVeryLongVpnAppNameWhich... (com.vpn.app)\n+     *   if the VPN label violates the length restriction.\n+     * or\n+     * - VpnLabelWith&lt;br&gt;HtmlTag (com.vpn.app)\n+     *   if the VPN label doesn't violate the length restriction.\n+     *\n+     */\n+    private String getSimplifiedLabel(String vpnLabel, String packageName) {\n+        if (vpnLabel.codePointCount(0, vpnLabel.length()) > 30) {\n+            return getString(R.string.sanitized_vpn_label_with_ellipsis,\n+                vpnLabel.substring(0, vpnLabel.offsetByCodePoints(0, 30)),\n+                packageName);\n+        }\n+\n+        return getString(R.string.sanitized_vpn_label, vpnLabel, packageName);\n+    }\n+\n+    protected String getSanitizedVpnLabel(String vpnLabel, String packageName) {\n+        final String sanitizedVpnLabel = Html.escapeHtml(vpnLabel);\n+        final boolean exceedMaxVpnLabelLength = sanitizedVpnLabel.codePointCount(0,\n+            sanitizedVpnLabel.length()) > MAX_VPN_LABEL_LENGTH;\n+        if (exceedMaxVpnLabelLength || !vpnLabel.equals(sanitizedVpnLabel)) {\n+            return getSimplifiedLabel(sanitizedVpnLabel, packageName);\n+        }\n+\n+        return sanitizedVpnLabel;\n+    }\n+\n     @Override\n     protected void onCreate(Bundle savedInstanceState) {\n         super.onCreate(savedInstanceState);\n@@ -75,15 +117,16 @@ public class ConfirmDialog extends AlertActivity\n             finish();\n             return;\n         }\n-        View view = View.inflate(this, R.layout.confirm, null);\n-        ((TextView) view.findViewById(R.id.warning)).setText(\n-                Html.fromHtml(getString(R.string.warning, getVpnLabel()),\n-                        this, null /* tagHandler */));\n+        mView = View.inflate(this, R.layout.confirm, null);\n+        ((TextView) mView.findViewById(R.id.warning)).setText(\n+                Html.fromHtml(getString(R.string.warning, getSanitizedVpnLabel(\n+                    getVpnLabel().toString(), mPackage)),\n+                    this /* imageGetter */, null /* tagHandler */));\n         mAlertParams.mTitle = getText(R.string.prompt);\n         mAlertParams.mPositiveButtonText = getText(android.R.string.ok);\n         mAlertParams.mPositiveButtonListener = this;\n         mAlertParams.mNegativeButtonText = getText(android.R.string.cancel);\n-        mAlertParams.mView = view;\n+        mAlertParams.mView = mView;\n         setupAlert();\n \n         getWindow().setCloseOnTouchOutside(false);\n",
    "added_lines": 48,
    "deleted_lines": 5,
    "changed_methods": "ConfirmDialog::getSimplifiedLabel, ConfirmDialog::getSanitizedVpnLabel, ConfirmDialog::onCreate"
   }
  ]
 },
 {
  "hash": "cdd8435eba6773ff9a71ac90568c71bbad7b51dd",
  "commit": "Limit the number of supported v1 and v2 signers\n\nThe v1 and v2 APK Signature Schemes support multiple signers; this\nwas intended to allow multiple entities to sign an APK. Previously,\nthe platform had no limits placed on the number of signers supported\nin an APK, but this commit sets a hard limit of 10 supported signers\nfor these signature schemes to ensure a large number of signers\ndoes not place undue burden on the platform.\n\nBug: 266580022\nTest: Manually verified the platform only allowed an APK with the\n       maximum number of supported signers.\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:6f6ee8a55f37c2b8c0df041b2bd53ec928764597)\nMerged-In: I6aa86b615b203cdc69d58a593ccf8f18474ca091\nChange-Id: I6aa86b615b203cdc69d58a593ccf8f18474ca091",
  "files": [
   {
    "filename": "ApkSignatureSchemeV2Verifier.java",
    "diff": "@@ -74,6 +74,11 @@ public class ApkSignatureSchemeV2Verifier {\n \n     private static final int APK_SIGNATURE_SCHEME_V2_BLOCK_ID = 0x7109871a;\n \n+    /**\n+     * The maximum number of signers supported by the v2 APK signature scheme.\n+     */\n+    private static final int MAX_V2_SIGNERS = 10;\n+\n     /**\n      * Returns {@code true} if the provided APK contains an APK Signature Scheme V2 signature.\n      *\n@@ -182,6 +187,11 @@ public class ApkSignatureSchemeV2Verifier {\n         }\n         while (signers.hasRemaining()) {\n             signerCount++;\n+            if (signerCount > MAX_V2_SIGNERS) {\n+                throw new SecurityException(\n+                        \"APK Signature Scheme v2 only supports a maximum of \" + MAX_V2_SIGNERS\n+                                + \" signers\");\n+            }\n             try {\n                 ByteBuffer signer = getLengthPrefixedSlice(signers);\n                 X509Certificate[] certs = verifySigner(signer, contentDigests, certFactory);\n",
    "added_lines": 10,
    "deleted_lines": 0,
    "changed_methods": "ApkSignatureSchemeV2Verifier::verify"
   },
   {
    "filename": "StrictJarVerifier.java",
    "diff": "@@ -78,6 +78,11 @@ class StrictJarVerifier {\n         \"SHA1\",\n     };\n \n+    /**\n+     * The maximum number of signers supported by the JAR signature scheme.\n+     */\n+    private static final int MAX_JAR_SIGNERS = 10;\n+\n     private final String jarName;\n     private final StrictJarManifest manifest;\n     private final HashMap<String, byte[]> metaEntries;\n@@ -293,10 +298,16 @@ class StrictJarVerifier {\n             return false;\n         }\n \n+        int signerCount = 0;\n         Iterator<String> it = metaEntries.keySet().iterator();\n         while (it.hasNext()) {\n             String key = it.next();\n             if (key.endsWith(\".DSA\") || key.endsWith(\".RSA\") || key.endsWith(\".EC\")) {\n+                if (++signerCount > MAX_JAR_SIGNERS) {\n+                    throw new SecurityException(\n+                            \"APK Signature Scheme v1 only supports a maximum of \" + MAX_JAR_SIGNERS\n+                                    + \" signers\");\n+                }\n                 verifyCertificate(key);\n                 it.remove();\n             }\n",
    "added_lines": 11,
    "deleted_lines": 0,
    "changed_methods": "StrictJarVerifier::readCertificates"
   }
  ]
 },
 {
  "hash": "cdd8435eba6773ff9a71ac90568c71bbad7b51dd",
  "commit": "Limit the number of supported v1 and v2 signers\n\nThe v1 and v2 APK Signature Schemes support multiple signers; this\nwas intended to allow multiple entities to sign an APK. Previously,\nthe platform had no limits placed on the number of signers supported\nin an APK, but this commit sets a hard limit of 10 supported signers\nfor these signature schemes to ensure a large number of signers\ndoes not place undue burden on the platform.\n\nBug: 266580022\nTest: Manually verified the platform only allowed an APK with the\n       maximum number of supported signers.\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:6f6ee8a55f37c2b8c0df041b2bd53ec928764597)\nMerged-In: I6aa86b615b203cdc69d58a593ccf8f18474ca091\nChange-Id: I6aa86b615b203cdc69d58a593ccf8f18474ca091",
  "files": [
   {
    "filename": "ApkSignatureSchemeV2Verifier.java",
    "diff": "@@ -74,6 +74,11 @@ public class ApkSignatureSchemeV2Verifier {\n \n     private static final int APK_SIGNATURE_SCHEME_V2_BLOCK_ID = 0x7109871a;\n \n+    /**\n+     * The maximum number of signers supported by the v2 APK signature scheme.\n+     */\n+    private static final int MAX_V2_SIGNERS = 10;\n+\n     /**\n      * Returns {@code true} if the provided APK contains an APK Signature Scheme V2 signature.\n      *\n@@ -182,6 +187,11 @@ public class ApkSignatureSchemeV2Verifier {\n         }\n         while (signers.hasRemaining()) {\n             signerCount++;\n+            if (signerCount > MAX_V2_SIGNERS) {\n+                throw new SecurityException(\n+                        \"APK Signature Scheme v2 only supports a maximum of \" + MAX_V2_SIGNERS\n+                                + \" signers\");\n+            }\n             try {\n                 ByteBuffer signer = getLengthPrefixedSlice(signers);\n                 X509Certificate[] certs = verifySigner(signer, contentDigests, certFactory);\n",
    "added_lines": 10,
    "deleted_lines": 0,
    "changed_methods": "ApkSignatureSchemeV2Verifier::verify"
   },
   {
    "filename": "StrictJarVerifier.java",
    "diff": "@@ -78,6 +78,11 @@ class StrictJarVerifier {\n         \"SHA1\",\n     };\n \n+    /**\n+     * The maximum number of signers supported by the JAR signature scheme.\n+     */\n+    private static final int MAX_JAR_SIGNERS = 10;\n+\n     private final String jarName;\n     private final StrictJarManifest manifest;\n     private final HashMap<String, byte[]> metaEntries;\n@@ -293,10 +298,16 @@ class StrictJarVerifier {\n             return false;\n         }\n \n+        int signerCount = 0;\n         Iterator<String> it = metaEntries.keySet().iterator();\n         while (it.hasNext()) {\n             String key = it.next();\n             if (key.endsWith(\".DSA\") || key.endsWith(\".RSA\") || key.endsWith(\".EC\")) {\n+                if (++signerCount > MAX_JAR_SIGNERS) {\n+                    throw new SecurityException(\n+                            \"APK Signature Scheme v1 only supports a maximum of \" + MAX_JAR_SIGNERS\n+                                    + \" signers\");\n+                }\n                 verifyCertificate(key);\n                 it.remove();\n             }\n",
    "added_lines": 11,
    "deleted_lines": 0,
    "changed_methods": "StrictJarVerifier::readCertificates"
   }
  ]
 },
 {
  "hash": "477cb8ed3bc58fbac41689cfcdbda05402692c1b",
  "commit": "Grant URI permissions to the CallStyle-related ones\n\nThis will also verify that the caller app can actually grant them.\n\nFix: 274592467\nTest: atest NotificationManagerServiceTest\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:4dee5aab12e95cd8b4d663ad050f07b0f2433596)\nMerged-In: I83429f9e63e51c615a6e3f03befb76bb5b8ea7fc\nChange-Id: I83429f9e63e51c615a6e3f03befb76bb5b8ea7fc",
  "files": [
   {
    "filename": "Notification.java",
    "diff": "@@ -2837,6 +2837,14 @@ public class Notification implements Parcelable\n             }\n         }\n \n+        if (isStyle(CallStyle.class) & extras != null) {\n+            Person callPerson = extras.getParcelable(EXTRA_CALL_PERSON);\n+            if (callPerson != null) {\n+                visitor.accept(callPerson.getIconUri());\n+            }\n+            visitIconUri(visitor, extras.getParcelable(EXTRA_VERIFICATION_ICON));\n+        }\n+\n         if (mBubbleMetadata != null) {\n             visitIconUri(visitor, mBubbleMetadata.getIcon());\n         }\n",
    "added_lines": 8,
    "deleted_lines": 0,
    "changed_methods": "Notification::visitUris"
   },
   {
    "filename": "NotificationManagerServiceTest.java",
    "diff": "@@ -4463,6 +4463,29 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n         verify(visitor, times(1)).accept(eq(backgroundImage));\n     }\n \n+    @Test\n+    public void testVisitUris_callStyle() {\n+        Icon personIcon = Icon.createWithContentUri(\"content://media/person\");\n+        Icon verificationIcon = Icon.createWithContentUri(\"content://media/verification\");\n+        Person callingPerson = new Person.Builder().setName(\"Someone\")\n+                .setIcon(personIcon)\n+                .build();\n+        PendingIntent hangUpIntent = PendingIntent.getActivity(mContext, 0, new Intent(),\n+                PendingIntent.FLAG_IMMUTABLE);\n+        Notification n = new Notification.Builder(mContext, \"a\")\n+                .setStyle(Notification.CallStyle.forOngoingCall(callingPerson, hangUpIntent)\n+                        .setVerificationIcon(verificationIcon))\n+                .setContentTitle(\"Calling...\")\n+                .setSmallIcon(android.R.drawable.sym_def_app_icon)\n+                .build();\n+\n+        Consumer<Uri> visitor = (Consumer<Uri>) spy(Consumer.class);\n+        n.visitUris(visitor);\n+\n+        verify(visitor, times(1)).accept(eq(personIcon.getUri()));\n+        verify(visitor, times(1)).accept(eq(verificationIcon.getUri()));\n+    }\n+\n     @Test\n     public void testVisitUris_audioContentsString() throws Exception {\n         final Uri audioContents = Uri.parse(\"content://com.example/audio\");\n",
    "added_lines": 23,
    "deleted_lines": 0,
    "changed_methods": "NotificationManagerServiceTest::testVisitUris_callStyle"
   }
  ]
 },
 {
  "hash": "477cb8ed3bc58fbac41689cfcdbda05402692c1b",
  "commit": "Grant URI permissions to the CallStyle-related ones\n\nThis will also verify that the caller app can actually grant them.\n\nFix: 274592467\nTest: atest NotificationManagerServiceTest\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:4dee5aab12e95cd8b4d663ad050f07b0f2433596)\nMerged-In: I83429f9e63e51c615a6e3f03befb76bb5b8ea7fc\nChange-Id: I83429f9e63e51c615a6e3f03befb76bb5b8ea7fc",
  "files": [
   {
    "filename": "Notification.java",
    "diff": "@@ -2837,6 +2837,14 @@ public class Notification implements Parcelable\n             }\n         }\n \n+        if (isStyle(CallStyle.class) & extras != null) {\n+            Person callPerson = extras.getParcelable(EXTRA_CALL_PERSON);\n+            if (callPerson != null) {\n+                visitor.accept(callPerson.getIconUri());\n+            }\n+            visitIconUri(visitor, extras.getParcelable(EXTRA_VERIFICATION_ICON));\n+        }\n+\n         if (mBubbleMetadata != null) {\n             visitIconUri(visitor, mBubbleMetadata.getIcon());\n         }\n",
    "added_lines": 8,
    "deleted_lines": 0,
    "changed_methods": "Notification::visitUris"
   },
   {
    "filename": "NotificationManagerServiceTest.java",
    "diff": "@@ -4463,6 +4463,29 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n         verify(visitor, times(1)).accept(eq(backgroundImage));\n     }\n \n+    @Test\n+    public void testVisitUris_callStyle() {\n+        Icon personIcon = Icon.createWithContentUri(\"content://media/person\");\n+        Icon verificationIcon = Icon.createWithContentUri(\"content://media/verification\");\n+        Person callingPerson = new Person.Builder().setName(\"Someone\")\n+                .setIcon(personIcon)\n+                .build();\n+        PendingIntent hangUpIntent = PendingIntent.getActivity(mContext, 0, new Intent(),\n+                PendingIntent.FLAG_IMMUTABLE);\n+        Notification n = new Notification.Builder(mContext, \"a\")\n+                .setStyle(Notification.CallStyle.forOngoingCall(callingPerson, hangUpIntent)\n+                        .setVerificationIcon(verificationIcon))\n+                .setContentTitle(\"Calling...\")\n+                .setSmallIcon(android.R.drawable.sym_def_app_icon)\n+                .build();\n+\n+        Consumer<Uri> visitor = (Consumer<Uri>) spy(Consumer.class);\n+        n.visitUris(visitor);\n+\n+        verify(visitor, times(1)).accept(eq(personIcon.getUri()));\n+        verify(visitor, times(1)).accept(eq(verificationIcon.getUri()));\n+    }\n+\n     @Test\n     public void testVisitUris_audioContentsString() throws Exception {\n         final Uri audioContents = Uri.parse(\"content://com.example/audio\");\n",
    "added_lines": 23,
    "deleted_lines": 0,
    "changed_methods": "NotificationManagerServiceTest::testVisitUris_callStyle"
   }
  ]
 },
 {
  "hash": "796e70d56d9490e78e654e88578699f4d4f71553",
  "commit": "Only allow NEW_TASK flag when adjusting pending intents\n\nBug: 243794108\nTest: atest CtsSecurityBulletinHostTestCases:android.security.cts.CVE_2023_20918\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:c62d2e1021a030f4f0ae5fcfc8fe8e0875fa669f)\nMerged-In: I5d329beecef1902c36704e93d0bc5cb60d0e2f5b\nChange-Id: I5d329beecef1902c36704e93d0bc5cb60d0e2f5b",
  "files": [
   {
    "filename": "ActivityOptions.java",
    "diff": "@@ -20,6 +20,8 @@ import static android.Manifest.permission.CONTROL_REMOTE_APP_TRANSITION_ANIMATIO\n import static android.Manifest.permission.START_TASKS_FROM_RECENTS;\n import static android.app.WindowConfiguration.ACTIVITY_TYPE_UNDEFINED;\n import static android.app.WindowConfiguration.WINDOWING_MODE_UNDEFINED;\n+import static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;\n+import static android.content.Intent.FLAG_RECEIVER_FOREGROUND;\n import static android.view.Display.INVALID_DISPLAY;\n \n import android.annotation.IntDef;\n@@ -1553,7 +1555,9 @@ public class ActivityOptions extends ComponentOptions {\n      * @hide\n      */\n     public int getPendingIntentLaunchFlags() {\n-        return mPendingIntentLaunchFlags;\n+        // b/243794108: Ignore all flags except the new task flag, to be reconsidered in b/254490217\n+        return mPendingIntentLaunchFlags &\n+                (FLAG_ACTIVITY_NEW_TASK | FLAG_RECEIVER_FOREGROUND);\n     }\n \n     /**\n",
    "added_lines": 5,
    "deleted_lines": 1,
    "changed_methods": "ActivityOptions::getPendingIntentLaunchFlags"
   }
  ]
 },
 {
  "hash": "37ca905ed529c3bbb624b5dfe244cf09e0fef417",
  "commit": "Dismiss keyguard when simpin auth'd and...\n\nsecurity method is none. This is mostly to fix the case where we auth\nsim pin in the set up wizard and it goes straight to keyguard instead of\nthe setup wizard activity.\n\nThis works with the prevent bypass keyguard flag because the device\nshould be noe secure in this case.\n\nFixes: 222446076\nTest: turn locked sim on, which opens the sim pin screen. Auth the\nscreen and observe that keyguard is not shown.\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:48fa9bef3451e4a358c941af5b230f99881c5cb6)\nCherry-picking this CL as a security fix\n\nBug: 222446076\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:65ea56f54c059584eb27ec53d486dba8161316ab)\nMerged-In: Id302c41f63028bc6dd58ba686e23d73565de9675\nChange-Id: Id302c41f63028bc6dd58ba686e23d73565de9675",
  "files": [
   {
    "filename": "KeyguardSecurityContainerController.java",
    "diff": "@@ -426,7 +426,7 @@ public class KeyguardSecurityContainerController extends ViewController<Keyguard\n                 case SimPuk:\n                     // Shortcut for SIM PIN/PUK to go to directly to user's security screen or home\n                     SecurityMode securityMode = mSecurityModel.getSecurityMode(targetUserId);\n-                    if (securityMode == SecurityMode.None && mLockPatternUtils.isLockScreenDisabled(\n+                    if (securityMode == SecurityMode.None || mLockPatternUtils.isLockScreenDisabled(\n                             KeyguardUpdateMonitor.getCurrentUser())) {\n                         finish = true;\n                         eventSubtype = BOUNCER_DISMISS_SIM;\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "KeyguardSecurityContainerController::showNextSecurityScreenOrFinish"
   }
  ]
 },
 {
  "hash": "26a1ac33ad29ce6f22acbfcd087d0f882aa0ed40",
  "commit": "Verify URI permissions for EXTRA_REMOTE_INPUT_HISTORY_ITEMS.\n\nAlso added the person URIs in the test, since they weren't being\nchecked.\n\nTest: atest NotificationManagerServiceTest & tested with POC from bug\nBug: 276729064\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:43b1711332763788c7abf05c3baa931296c45bbb)\nMerged-In: I848545f7aee202495c515f47a32871a2cb6ae707\nChange-Id: I848545f7aee202495c515f47a32871a2cb6ae707",
  "files": [
   {
    "filename": "Notification.java",
    "diff": "@@ -2807,6 +2807,17 @@ public class Notification implements Parcelable\n             if (person != null) {\n                 visitor.accept(person.getIconUri());\n             }\n+\n+            final RemoteInputHistoryItem[] history = (RemoteInputHistoryItem[])\n+                    extras.getParcelableArray(Notification.EXTRA_REMOTE_INPUT_HISTORY_ITEMS);\n+            if (history != null) {\n+                for (int i = 0; i < history.length; i++) {\n+                    RemoteInputHistoryItem item = history[i];\n+                    if (item.getUri() != null) {\n+                        visitor.accept(item.getUri());\n+                    }\n+                }\n+            }\n         }\n \n         if (isStyle(MessagingStyle.class) && extras != null) {\n",
    "added_lines": 11,
    "deleted_lines": 0,
    "changed_methods": "Notification::visitUris"
   },
   {
    "filename": "NotificationManagerServiceTest.java",
    "diff": "@@ -115,6 +115,7 @@ import android.app.NotificationManager;\n import android.app.PendingIntent;\n import android.app.Person;\n import android.app.RemoteInput;\n+import android.app.RemoteInputHistoryItem;\n import android.app.StatsManager;\n import android.app.admin.DevicePolicyManagerInternal;\n import android.app.usage.UsageStatsManagerInternal;\n@@ -4446,10 +4447,36 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n     public void testVisitUris() throws Exception {\n         final Uri audioContents = Uri.parse(\"content://com.example/audio\");\n         final Uri backgroundImage = Uri.parse(\"content://com.example/background\");\n+        final Icon personIcon1 = Icon.createWithContentUri(\"content://media/person1\");\n+        final Icon personIcon2 = Icon.createWithContentUri(\"content://media/person2\");\n+        final Icon personIcon3 = Icon.createWithContentUri(\"content://media/person3\");\n+        final Person person1 = new Person.Builder()\n+                .setName(\"Messaging Person\")\n+                .setIcon(personIcon1)\n+                .build();\n+        final Person person2 = new Person.Builder()\n+                .setName(\"People List Person 1\")\n+                .setIcon(personIcon2)\n+                .build();\n+        final Person person3 = new Person.Builder()\n+                .setName(\"People List Person 2\")\n+                .setIcon(personIcon3)\n+                .build();\n+        final Uri historyUri1 = Uri.parse(\"content://com.example/history1\");\n+        final Uri historyUri2 = Uri.parse(\"content://com.example/history2\");\n+        final RemoteInputHistoryItem historyItem1 = new RemoteInputHistoryItem(null, historyUri1,\n+                \"a\");\n+        final RemoteInputHistoryItem historyItem2 = new RemoteInputHistoryItem(null, historyUri2,\n+                \"b\");\n \n         Bundle extras = new Bundle();\n         extras.putParcelable(Notification.EXTRA_AUDIO_CONTENTS_URI, audioContents);\n         extras.putString(Notification.EXTRA_BACKGROUND_IMAGE_URI, backgroundImage.toString());\n+        extras.putParcelable(Notification.EXTRA_MESSAGING_PERSON, person1);\n+        extras.putParcelableArrayList(Notification.EXTRA_PEOPLE_LIST,\n+                new ArrayList<>(Arrays.asList(person2, person3)));\n+        extras.putParcelableArray(Notification.EXTRA_REMOTE_INPUT_HISTORY_ITEMS,\n+                new RemoteInputHistoryItem[]{historyItem1, historyItem2});\n \n         Notification n = new Notification.Builder(mContext, \"a\")\n                 .setContentTitle(\"notification with uris\")\n@@ -4461,6 +4488,11 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n         n.visitUris(visitor);\n         verify(visitor, times(1)).accept(eq(audioContents));\n         verify(visitor, times(1)).accept(eq(backgroundImage));\n+        verify(visitor, times(1)).accept(eq(personIcon1.getUri()));\n+        verify(visitor, times(1)).accept(eq(personIcon2.getUri()));\n+        verify(visitor, times(1)).accept(eq(personIcon3.getUri()));\n+        verify(visitor, times(1)).accept(eq(historyUri1));\n+        verify(visitor, times(1)).accept(eq(historyUri2));\n     }\n \n     @Test\n",
    "added_lines": 32,
    "deleted_lines": 0,
    "changed_methods": "NotificationManagerServiceTest::testVisitUris"
   }
  ]
 },
 {
  "hash": "26a1ac33ad29ce6f22acbfcd087d0f882aa0ed40",
  "commit": "Verify URI permissions for EXTRA_REMOTE_INPUT_HISTORY_ITEMS.\n\nAlso added the person URIs in the test, since they weren't being\nchecked.\n\nTest: atest NotificationManagerServiceTest & tested with POC from bug\nBug: 276729064\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:43b1711332763788c7abf05c3baa931296c45bbb)\nMerged-In: I848545f7aee202495c515f47a32871a2cb6ae707\nChange-Id: I848545f7aee202495c515f47a32871a2cb6ae707",
  "files": [
   {
    "filename": "Notification.java",
    "diff": "@@ -2807,6 +2807,17 @@ public class Notification implements Parcelable\n             if (person != null) {\n                 visitor.accept(person.getIconUri());\n             }\n+\n+            final RemoteInputHistoryItem[] history = (RemoteInputHistoryItem[])\n+                    extras.getParcelableArray(Notification.EXTRA_REMOTE_INPUT_HISTORY_ITEMS);\n+            if (history != null) {\n+                for (int i = 0; i < history.length; i++) {\n+                    RemoteInputHistoryItem item = history[i];\n+                    if (item.getUri() != null) {\n+                        visitor.accept(item.getUri());\n+                    }\n+                }\n+            }\n         }\n \n         if (isStyle(MessagingStyle.class) && extras != null) {\n",
    "added_lines": 11,
    "deleted_lines": 0,
    "changed_methods": "Notification::visitUris"
   },
   {
    "filename": "NotificationManagerServiceTest.java",
    "diff": "@@ -115,6 +115,7 @@ import android.app.NotificationManager;\n import android.app.PendingIntent;\n import android.app.Person;\n import android.app.RemoteInput;\n+import android.app.RemoteInputHistoryItem;\n import android.app.StatsManager;\n import android.app.admin.DevicePolicyManagerInternal;\n import android.app.usage.UsageStatsManagerInternal;\n@@ -4446,10 +4447,36 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n     public void testVisitUris() throws Exception {\n         final Uri audioContents = Uri.parse(\"content://com.example/audio\");\n         final Uri backgroundImage = Uri.parse(\"content://com.example/background\");\n+        final Icon personIcon1 = Icon.createWithContentUri(\"content://media/person1\");\n+        final Icon personIcon2 = Icon.createWithContentUri(\"content://media/person2\");\n+        final Icon personIcon3 = Icon.createWithContentUri(\"content://media/person3\");\n+        final Person person1 = new Person.Builder()\n+                .setName(\"Messaging Person\")\n+                .setIcon(personIcon1)\n+                .build();\n+        final Person person2 = new Person.Builder()\n+                .setName(\"People List Person 1\")\n+                .setIcon(personIcon2)\n+                .build();\n+        final Person person3 = new Person.Builder()\n+                .setName(\"People List Person 2\")\n+                .setIcon(personIcon3)\n+                .build();\n+        final Uri historyUri1 = Uri.parse(\"content://com.example/history1\");\n+        final Uri historyUri2 = Uri.parse(\"content://com.example/history2\");\n+        final RemoteInputHistoryItem historyItem1 = new RemoteInputHistoryItem(null, historyUri1,\n+                \"a\");\n+        final RemoteInputHistoryItem historyItem2 = new RemoteInputHistoryItem(null, historyUri2,\n+                \"b\");\n \n         Bundle extras = new Bundle();\n         extras.putParcelable(Notification.EXTRA_AUDIO_CONTENTS_URI, audioContents);\n         extras.putString(Notification.EXTRA_BACKGROUND_IMAGE_URI, backgroundImage.toString());\n+        extras.putParcelable(Notification.EXTRA_MESSAGING_PERSON, person1);\n+        extras.putParcelableArrayList(Notification.EXTRA_PEOPLE_LIST,\n+                new ArrayList<>(Arrays.asList(person2, person3)));\n+        extras.putParcelableArray(Notification.EXTRA_REMOTE_INPUT_HISTORY_ITEMS,\n+                new RemoteInputHistoryItem[]{historyItem1, historyItem2});\n \n         Notification n = new Notification.Builder(mContext, \"a\")\n                 .setContentTitle(\"notification with uris\")\n@@ -4461,6 +4488,11 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n         n.visitUris(visitor);\n         verify(visitor, times(1)).accept(eq(audioContents));\n         verify(visitor, times(1)).accept(eq(backgroundImage));\n+        verify(visitor, times(1)).accept(eq(personIcon1.getUri()));\n+        verify(visitor, times(1)).accept(eq(personIcon2.getUri()));\n+        verify(visitor, times(1)).accept(eq(personIcon3.getUri()));\n+        verify(visitor, times(1)).accept(eq(historyUri1));\n+        verify(visitor, times(1)).accept(eq(historyUri2));\n     }\n \n     @Test\n",
    "added_lines": 32,
    "deleted_lines": 0,
    "changed_methods": "NotificationManagerServiceTest::testVisitUris"
   }
  ]
 },
 {
  "hash": "94cd71b3e35328c30778d02c07ee9a21d3ad6544",
  "commit": "Truncate ShortcutInfo Id\n\nCreating Conversation with a ShortcutId longer than 65_535 (max unsigned short), we did not save the conversation settings into the notification_policy.xml due to a restriction in FastDataOutput.\nThis put us to a state where the user changing the importance or turning off the notifications for the given conversation had no effect on notification behavior.\n\nFixes: 273729476\nTest: atest ShortcutManagerTest2\nTest: Create a test app which creates a Conversation with a long shortcutId. Go to the Conversation Settings and turn off Notifications. Post a new Notification to this Conversation and see if it is displayed.\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:ab0c8ac5b47509a71f27c4e5e9ce104d51bab0a8)\nMerged-In: I2617de6f9e8a7dbfd8fbeff589a7d592f00d87c5\nChange-Id: I2617de6f9e8a7dbfd8fbeff589a7d592f00d87c5",
  "files": [
   {
    "filename": "ShortcutInfo.java",
    "diff": "@@ -276,6 +276,12 @@ public final class ShortcutInfo implements Parcelable {\n      */\n     public static final int DISABLED_REASON_OTHER_RESTORE_ISSUE = 103;\n \n+    /**\n+     * The maximum length of Shortcut ID. IDs will be truncated at this limit.\n+     * @hide\n+     */\n+    public static final int MAX_ID_LENGTH = 1000;\n+\n     /** @hide */\n     @IntDef(prefix = { \"DISABLED_REASON_\" }, value = {\n             DISABLED_REASON_NOT_DISABLED,\n@@ -453,8 +459,7 @@ public final class ShortcutInfo implements Parcelable {\n \n     private ShortcutInfo(Builder b) {\n         mUserId = b.mContext.getUserId();\n-\n-        mId = Preconditions.checkStringNotEmpty(b.mId, \"Shortcut ID must be provided\");\n+        mId = getSafeId(Preconditions.checkStringNotEmpty(b.mId, \"Shortcut ID must be provided\"));\n \n         // Note we can't do other null checks here because SM.updateShortcuts() takes partial\n         // information.\n@@ -558,6 +563,14 @@ public final class ShortcutInfo implements Parcelable {\n         return ret;\n     }\n \n+    @NonNull\n+    private static String getSafeId(@NonNull String id) {\n+        if (id.length() > MAX_ID_LENGTH) {\n+            return id.substring(0, MAX_ID_LENGTH);\n+        }\n+        return id;\n+    }\n+\n     /**\n      * Throws if any of the mandatory fields is not set.\n      *\n@@ -2141,7 +2154,8 @@ public final class ShortcutInfo implements Parcelable {\n         final ClassLoader cl = getClass().getClassLoader();\n \n         mUserId = source.readInt();\n-        mId = source.readString8();\n+        mId = getSafeId(Preconditions.checkStringNotEmpty(source.readString8(),\n+                \"Shortcut ID must be provided\"));\n         mPackageName = source.readString8();\n         mActivity = source.readParcelable(cl);\n         mFlags = source.readInt();\n",
    "added_lines": 17,
    "deleted_lines": 3,
    "changed_methods": "ShortcutInfo::ShortcutInfo, ShortcutInfo::getSafeId, ShortcutInfo::ShortcutInfo"
   },
   {
    "filename": "ShortcutManagerTest2.java",
    "diff": "@@ -53,6 +53,7 @@ import java.io.File;\n import java.io.FileWriter;\n import java.io.IOException;\n import java.io.Writer;\n+import java.util.Collections;\n import java.util.Locale;\n \n /**\n@@ -223,6 +224,15 @@ public class ShortcutManagerTest2 extends BaseShortcutManagerTest {\n                 });\n     }\n \n+    public void testShortcutIdTruncated() {\n+        ShortcutInfo si = new ShortcutInfo.Builder(getTestContext(),\n+                String.join(\"\", Collections.nCopies(Short.MAX_VALUE, \"s\"))).build();\n+\n+        assertTrue(\n+                \"id must be truncated to MAX_ID_LENGTH\",\n+                si.getId().length() <= ShortcutInfo.MAX_ID_LENGTH);\n+    }\n+\n     public void testShortcutInfoParcel() {\n         setCaller(CALLING_PACKAGE_1, USER_10);\n         ShortcutInfo si = parceled(new ShortcutInfo.Builder(mClientContext)\n",
    "added_lines": 10,
    "deleted_lines": 0,
    "changed_methods": "ShortcutManagerTest2::testShortcutIdTruncated"
   }
  ]
 },
 {
  "hash": "94cd71b3e35328c30778d02c07ee9a21d3ad6544",
  "commit": "Truncate ShortcutInfo Id\n\nCreating Conversation with a ShortcutId longer than 65_535 (max unsigned short), we did not save the conversation settings into the notification_policy.xml due to a restriction in FastDataOutput.\nThis put us to a state where the user changing the importance or turning off the notifications for the given conversation had no effect on notification behavior.\n\nFixes: 273729476\nTest: atest ShortcutManagerTest2\nTest: Create a test app which creates a Conversation with a long shortcutId. Go to the Conversation Settings and turn off Notifications. Post a new Notification to this Conversation and see if it is displayed.\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:ab0c8ac5b47509a71f27c4e5e9ce104d51bab0a8)\nMerged-In: I2617de6f9e8a7dbfd8fbeff589a7d592f00d87c5\nChange-Id: I2617de6f9e8a7dbfd8fbeff589a7d592f00d87c5",
  "files": [
   {
    "filename": "ShortcutInfo.java",
    "diff": "@@ -276,6 +276,12 @@ public final class ShortcutInfo implements Parcelable {\n      */\n     public static final int DISABLED_REASON_OTHER_RESTORE_ISSUE = 103;\n \n+    /**\n+     * The maximum length of Shortcut ID. IDs will be truncated at this limit.\n+     * @hide\n+     */\n+    public static final int MAX_ID_LENGTH = 1000;\n+\n     /** @hide */\n     @IntDef(prefix = { \"DISABLED_REASON_\" }, value = {\n             DISABLED_REASON_NOT_DISABLED,\n@@ -453,8 +459,7 @@ public final class ShortcutInfo implements Parcelable {\n \n     private ShortcutInfo(Builder b) {\n         mUserId = b.mContext.getUserId();\n-\n-        mId = Preconditions.checkStringNotEmpty(b.mId, \"Shortcut ID must be provided\");\n+        mId = getSafeId(Preconditions.checkStringNotEmpty(b.mId, \"Shortcut ID must be provided\"));\n \n         // Note we can't do other null checks here because SM.updateShortcuts() takes partial\n         // information.\n@@ -558,6 +563,14 @@ public final class ShortcutInfo implements Parcelable {\n         return ret;\n     }\n \n+    @NonNull\n+    private static String getSafeId(@NonNull String id) {\n+        if (id.length() > MAX_ID_LENGTH) {\n+            return id.substring(0, MAX_ID_LENGTH);\n+        }\n+        return id;\n+    }\n+\n     /**\n      * Throws if any of the mandatory fields is not set.\n      *\n@@ -2141,7 +2154,8 @@ public final class ShortcutInfo implements Parcelable {\n         final ClassLoader cl = getClass().getClassLoader();\n \n         mUserId = source.readInt();\n-        mId = source.readString8();\n+        mId = getSafeId(Preconditions.checkStringNotEmpty(source.readString8(),\n+                \"Shortcut ID must be provided\"));\n         mPackageName = source.readString8();\n         mActivity = source.readParcelable(cl);\n         mFlags = source.readInt();\n",
    "added_lines": 17,
    "deleted_lines": 3,
    "changed_methods": "ShortcutInfo::ShortcutInfo, ShortcutInfo::getSafeId, ShortcutInfo::ShortcutInfo"
   },
   {
    "filename": "ShortcutManagerTest2.java",
    "diff": "@@ -53,6 +53,7 @@ import java.io.File;\n import java.io.FileWriter;\n import java.io.IOException;\n import java.io.Writer;\n+import java.util.Collections;\n import java.util.Locale;\n \n /**\n@@ -223,6 +224,15 @@ public class ShortcutManagerTest2 extends BaseShortcutManagerTest {\n                 });\n     }\n \n+    public void testShortcutIdTruncated() {\n+        ShortcutInfo si = new ShortcutInfo.Builder(getTestContext(),\n+                String.join(\"\", Collections.nCopies(Short.MAX_VALUE, \"s\"))).build();\n+\n+        assertTrue(\n+                \"id must be truncated to MAX_ID_LENGTH\",\n+                si.getId().length() <= ShortcutInfo.MAX_ID_LENGTH);\n+    }\n+\n     public void testShortcutInfoParcel() {\n         setCaller(CALLING_PACKAGE_1, USER_10);\n         ShortcutInfo si = parceled(new ShortcutInfo.Builder(mClientContext)\n",
    "added_lines": 10,
    "deleted_lines": 0,
    "changed_methods": "ShortcutManagerTest2::testShortcutIdTruncated"
   }
  ]
 },
 {
  "hash": "b2dfeb065030eef7d5dd1307068c54896e688171",
  "commit": "Visit URIs in landscape/portrait custom remote views.\n\nBug: 277740848\nTest: atest RemoteViewsTest NotificationManagerServiceTest & tested with POC from bug\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:b4692946c10d11c1e935869e11dc709a9cdcba69)\nMerged-In: I7d3d35df0ec38945019f71755bed8797b7af4517\nChange-Id: I7d3d35df0ec38945019f71755bed8797b7af4517",
  "files": [
   {
    "filename": "RemoteViews.java",
    "diff": "@@ -709,6 +709,12 @@ public class RemoteViews implements Parcelable, Filter {\n                 mActions.get(i).visitUris(visitor);\n             }\n         }\n+        if (mLandscape != null) {\n+            mLandscape.visitUris(visitor);\n+        }\n+        if (mPortrait != null) {\n+            mPortrait.visitUris(visitor);\n+        }\n     }\n \n     private static void visitIconUri(Icon icon, @NonNull Consumer<Uri> visitor) {\n",
    "added_lines": 6,
    "deleted_lines": 0,
    "changed_methods": "RemoteViews::visitUris"
   },
   {
    "filename": "RemoteViewsTest.java",
    "diff": "@@ -20,6 +20,10 @@ import static org.junit.Assert.assertArrayEquals;\n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertSame;\n import static org.junit.Assert.assertTrue;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n \n import android.app.ActivityOptions;\n import android.app.PendingIntent;\n@@ -29,6 +33,8 @@ import android.content.Intent;\n import android.graphics.Bitmap;\n import android.graphics.drawable.BitmapDrawable;\n import android.graphics.drawable.Drawable;\n+import android.graphics.drawable.Icon;\n+import android.net.Uri;\n import android.os.AsyncTask;\n import android.os.Binder;\n import android.os.Parcel;\n@@ -50,6 +56,7 @@ import org.junit.runner.RunWith;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.concurrent.CountDownLatch;\n+import java.util.function.Consumer;\n \n /**\n  * Tests for RemoteViews.\n@@ -499,4 +506,61 @@ public class RemoteViewsTest {\n             return null;\n         }\n     }\n+\n+    @Test\n+    public void visitUris() {\n+        RemoteViews views = new RemoteViews(mPackage, R.layout.remote_views_test);\n+\n+        final Uri imageUri = Uri.parse(\"content://media/image\");\n+        final Icon icon1 = Icon.createWithContentUri(\"content://media/icon1\");\n+        final Icon icon2 = Icon.createWithContentUri(\"content://media/icon2\");\n+        final Icon icon3 = Icon.createWithContentUri(\"content://media/icon3\");\n+        final Icon icon4 = Icon.createWithContentUri(\"content://media/icon4\");\n+        views.setImageViewUri(R.id.image, imageUri);\n+        views.setTextViewCompoundDrawables(R.id.text, icon1, icon2, icon3, icon4);\n+\n+        Consumer<Uri> visitor = (Consumer<Uri>) spy(Consumer.class);\n+        views.visitUris(visitor);\n+        verify(visitor, times(1)).accept(eq(imageUri));\n+        verify(visitor, times(1)).accept(eq(icon1.getUri()));\n+        verify(visitor, times(1)).accept(eq(icon2.getUri()));\n+        verify(visitor, times(1)).accept(eq(icon3.getUri()));\n+        verify(visitor, times(1)).accept(eq(icon4.getUri()));\n+    }\n+\n+    @Test\n+    public void visitUris_separateOrientation() {\n+        final RemoteViews landscape = new RemoteViews(mPackage, R.layout.remote_views_test);\n+        final Uri imageUriL = Uri.parse(\"content://landscape/image\");\n+        final Icon icon1L = Icon.createWithContentUri(\"content://landscape/icon1\");\n+        final Icon icon2L = Icon.createWithContentUri(\"content://landscape/icon2\");\n+        final Icon icon3L = Icon.createWithContentUri(\"content://landscape/icon3\");\n+        final Icon icon4L = Icon.createWithContentUri(\"content://landscape/icon4\");\n+        landscape.setImageViewUri(R.id.image, imageUriL);\n+        landscape.setTextViewCompoundDrawables(R.id.text, icon1L, icon2L, icon3L, icon4L);\n+\n+        final RemoteViews portrait = new RemoteViews(mPackage, 33);\n+        final Uri imageUriP = Uri.parse(\"content://portrait/image\");\n+        final Icon icon1P = Icon.createWithContentUri(\"content://portrait/icon1\");\n+        final Icon icon2P = Icon.createWithContentUri(\"content://portrait/icon2\");\n+        final Icon icon3P = Icon.createWithContentUri(\"content://portrait/icon3\");\n+        final Icon icon4P = Icon.createWithContentUri(\"content://portrait/icon4\");\n+        portrait.setImageViewUri(R.id.image, imageUriP);\n+        portrait.setTextViewCompoundDrawables(R.id.text, icon1P, icon2P, icon3P, icon4P);\n+\n+        RemoteViews views = new RemoteViews(landscape, portrait);\n+\n+        Consumer<Uri> visitor = (Consumer<Uri>) spy(Consumer.class);\n+        views.visitUris(visitor);\n+        verify(visitor, times(1)).accept(eq(imageUriL));\n+        verify(visitor, times(1)).accept(eq(icon1L.getUri()));\n+        verify(visitor, times(1)).accept(eq(icon2L.getUri()));\n+        verify(visitor, times(1)).accept(eq(icon3L.getUri()));\n+        verify(visitor, times(1)).accept(eq(icon4L.getUri()));\n+        verify(visitor, times(1)).accept(eq(imageUriP));\n+        verify(visitor, times(1)).accept(eq(icon1P.getUri()));\n+        verify(visitor, times(1)).accept(eq(icon2P.getUri()));\n+        verify(visitor, times(1)).accept(eq(icon3P.getUri()));\n+        verify(visitor, times(1)).accept(eq(icon4P.getUri()));\n+    }\n }\n",
    "added_lines": 64,
    "deleted_lines": 0,
    "changed_methods": "RemoteViewsTest::visitUris_separateOrientation, RemoteViewsTest::visitUris"
   }
  ]
 },
 {
  "hash": "b2dfeb065030eef7d5dd1307068c54896e688171",
  "commit": "Visit URIs in landscape/portrait custom remote views.\n\nBug: 277740848\nTest: atest RemoteViewsTest NotificationManagerServiceTest & tested with POC from bug\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:b4692946c10d11c1e935869e11dc709a9cdcba69)\nMerged-In: I7d3d35df0ec38945019f71755bed8797b7af4517\nChange-Id: I7d3d35df0ec38945019f71755bed8797b7af4517",
  "files": [
   {
    "filename": "RemoteViews.java",
    "diff": "@@ -709,6 +709,12 @@ public class RemoteViews implements Parcelable, Filter {\n                 mActions.get(i).visitUris(visitor);\n             }\n         }\n+        if (mLandscape != null) {\n+            mLandscape.visitUris(visitor);\n+        }\n+        if (mPortrait != null) {\n+            mPortrait.visitUris(visitor);\n+        }\n     }\n \n     private static void visitIconUri(Icon icon, @NonNull Consumer<Uri> visitor) {\n",
    "added_lines": 6,
    "deleted_lines": 0,
    "changed_methods": "RemoteViews::visitUris"
   },
   {
    "filename": "RemoteViewsTest.java",
    "diff": "@@ -20,6 +20,10 @@ import static org.junit.Assert.assertArrayEquals;\n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertSame;\n import static org.junit.Assert.assertTrue;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n \n import android.app.ActivityOptions;\n import android.app.PendingIntent;\n@@ -29,6 +33,8 @@ import android.content.Intent;\n import android.graphics.Bitmap;\n import android.graphics.drawable.BitmapDrawable;\n import android.graphics.drawable.Drawable;\n+import android.graphics.drawable.Icon;\n+import android.net.Uri;\n import android.os.AsyncTask;\n import android.os.Binder;\n import android.os.Parcel;\n@@ -50,6 +56,7 @@ import org.junit.runner.RunWith;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.concurrent.CountDownLatch;\n+import java.util.function.Consumer;\n \n /**\n  * Tests for RemoteViews.\n@@ -499,4 +506,61 @@ public class RemoteViewsTest {\n             return null;\n         }\n     }\n+\n+    @Test\n+    public void visitUris() {\n+        RemoteViews views = new RemoteViews(mPackage, R.layout.remote_views_test);\n+\n+        final Uri imageUri = Uri.parse(\"content://media/image\");\n+        final Icon icon1 = Icon.createWithContentUri(\"content://media/icon1\");\n+        final Icon icon2 = Icon.createWithContentUri(\"content://media/icon2\");\n+        final Icon icon3 = Icon.createWithContentUri(\"content://media/icon3\");\n+        final Icon icon4 = Icon.createWithContentUri(\"content://media/icon4\");\n+        views.setImageViewUri(R.id.image, imageUri);\n+        views.setTextViewCompoundDrawables(R.id.text, icon1, icon2, icon3, icon4);\n+\n+        Consumer<Uri> visitor = (Consumer<Uri>) spy(Consumer.class);\n+        views.visitUris(visitor);\n+        verify(visitor, times(1)).accept(eq(imageUri));\n+        verify(visitor, times(1)).accept(eq(icon1.getUri()));\n+        verify(visitor, times(1)).accept(eq(icon2.getUri()));\n+        verify(visitor, times(1)).accept(eq(icon3.getUri()));\n+        verify(visitor, times(1)).accept(eq(icon4.getUri()));\n+    }\n+\n+    @Test\n+    public void visitUris_separateOrientation() {\n+        final RemoteViews landscape = new RemoteViews(mPackage, R.layout.remote_views_test);\n+        final Uri imageUriL = Uri.parse(\"content://landscape/image\");\n+        final Icon icon1L = Icon.createWithContentUri(\"content://landscape/icon1\");\n+        final Icon icon2L = Icon.createWithContentUri(\"content://landscape/icon2\");\n+        final Icon icon3L = Icon.createWithContentUri(\"content://landscape/icon3\");\n+        final Icon icon4L = Icon.createWithContentUri(\"content://landscape/icon4\");\n+        landscape.setImageViewUri(R.id.image, imageUriL);\n+        landscape.setTextViewCompoundDrawables(R.id.text, icon1L, icon2L, icon3L, icon4L);\n+\n+        final RemoteViews portrait = new RemoteViews(mPackage, 33);\n+        final Uri imageUriP = Uri.parse(\"content://portrait/image\");\n+        final Icon icon1P = Icon.createWithContentUri(\"content://portrait/icon1\");\n+        final Icon icon2P = Icon.createWithContentUri(\"content://portrait/icon2\");\n+        final Icon icon3P = Icon.createWithContentUri(\"content://portrait/icon3\");\n+        final Icon icon4P = Icon.createWithContentUri(\"content://portrait/icon4\");\n+        portrait.setImageViewUri(R.id.image, imageUriP);\n+        portrait.setTextViewCompoundDrawables(R.id.text, icon1P, icon2P, icon3P, icon4P);\n+\n+        RemoteViews views = new RemoteViews(landscape, portrait);\n+\n+        Consumer<Uri> visitor = (Consumer<Uri>) spy(Consumer.class);\n+        views.visitUris(visitor);\n+        verify(visitor, times(1)).accept(eq(imageUriL));\n+        verify(visitor, times(1)).accept(eq(icon1L.getUri()));\n+        verify(visitor, times(1)).accept(eq(icon2L.getUri()));\n+        verify(visitor, times(1)).accept(eq(icon3L.getUri()));\n+        verify(visitor, times(1)).accept(eq(icon4L.getUri()));\n+        verify(visitor, times(1)).accept(eq(imageUriP));\n+        verify(visitor, times(1)).accept(eq(icon1P.getUri()));\n+        verify(visitor, times(1)).accept(eq(icon2P.getUri()));\n+        verify(visitor, times(1)).accept(eq(icon3P.getUri()));\n+        verify(visitor, times(1)).accept(eq(icon4P.getUri()));\n+    }\n }\n",
    "added_lines": 64,
    "deleted_lines": 0,
    "changed_methods": "RemoteViewsTest::visitUris_separateOrientation, RemoteViewsTest::visitUris"
   }
  ]
 },
 {
  "hash": "1db9575c599343530de8b6ff78f2179625f1c381",
  "commit": "DO NOT MERGE: ActivityManager#killBackgroundProcesses can kill caller's own app only\n\nunless it's a system app.\n\nBug: 239423414\nBug: 223376078\nTest: atest CtsAppTestCases:ActivityManagerTest\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:d1c95670b248df945784b0f2830acf83b5682de3)\nMerged-In: Iac6baa889965b8ffecd9a43179a4c96632ad1d02\nChange-Id: Iac6baa889965b8ffecd9a43179a4c96632ad1d02",
  "files": [
   {
    "filename": "ActivityManager.java",
    "diff": "@@ -3666,6 +3666,9 @@ public class ActivityManager {\n      * processes to reclaim memory; the system will take care of restarting\n      * these processes in the future as needed.\n      *\n+     * <p class=\"note\">Third party applications can only use this API to kill their own processes.\n+     * </p>\n+     *\n      * @param packageName The name of the package whose processes are to\n      * be killed.\n      */\n",
    "added_lines": 3,
    "deleted_lines": 0,
    "changed_methods": ""
   },
   {
    "filename": "ActivityManagerService.java",
    "diff": "@@ -3618,8 +3618,20 @@ public class ActivityManagerService extends IActivityManager.Stub\n             Slog.w(TAG, msg);\n             throw new SecurityException(msg);\n         }\n+        final int callingUid = Binder.getCallingUid();\n+        final int callingPid = Binder.getCallingPid();\n+        final int callingAppId = UserHandle.getAppId(callingUid);\n \n-        userId = mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(),\n+        ProcessRecord proc;\n+        synchronized (mPidsSelfLocked) {\n+            proc = mPidsSelfLocked.get(callingPid);\n+        }\n+        final boolean hasKillAllPermission = PERMISSION_GRANTED == checkPermission(\n+                android.Manifest.permission.FORCE_STOP_PACKAGES, callingPid, callingUid)\n+                || UserHandle.isCore(callingUid)\n+                || (proc != null && proc.info.isSystemApp());\n+\n+        userId = mUserController.handleIncomingUser(callingPid, callingUid,\n                 userId, true, ALLOW_FULL_ONLY, \"killBackgroundProcesses\", null);\n         final int[] userIds = mUserController.expandUserId(userId);\n \n@@ -3634,7 +3646,7 @@ public class ActivityManagerService extends IActivityManager.Stub\n                                     targetUserId));\n                 } catch (RemoteException e) {\n                 }\n-                if (appId == -1) {\n+                if (appId == -1 || (!hasKillAllPermission && appId != callingAppId)) {\n                     Slog.w(TAG, \"Invalid packageName: \" + packageName);\n                     return;\n                 }\n@@ -3702,6 +3714,22 @@ public class ActivityManagerService extends IActivityManager.Stub\n             throw new SecurityException(msg);\n         }\n \n+        final int callingUid = Binder.getCallingUid();\n+        final int callingPid = Binder.getCallingPid();\n+\n+        ProcessRecord proc;\n+        synchronized (mPidsSelfLocked) {\n+            proc = mPidsSelfLocked.get(callingPid);\n+        }\n+        if (callingUid >= FIRST_APPLICATION_UID\n+                && (proc == null || !proc.info.isSystemApp())) {\n+            final String msg = \"Permission Denial: killAllBackgroundProcesses() from pid=\"\n+                    + callingPid + \", uid=\" + callingUid + \" is not allowed\";\n+            Slog.w(TAG, msg);\n+            // Silently return to avoid existing apps from crashing.\n+            return;\n+        }\n+\n         final long callingId = Binder.clearCallingIdentity();\n         try {\n             synchronized (this) {\n",
    "added_lines": 30,
    "deleted_lines": 2,
    "changed_methods": "ActivityManagerService::killBackgroundProcesses, ActivityManagerService::killAllBackgroundProcessesExcept"
   }
  ]
 },
 {
  "hash": "1db9575c599343530de8b6ff78f2179625f1c381",
  "commit": "DO NOT MERGE: ActivityManager#killBackgroundProcesses can kill caller's own app only\n\nunless it's a system app.\n\nBug: 239423414\nBug: 223376078\nTest: atest CtsAppTestCases:ActivityManagerTest\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:d1c95670b248df945784b0f2830acf83b5682de3)\nMerged-In: Iac6baa889965b8ffecd9a43179a4c96632ad1d02\nChange-Id: Iac6baa889965b8ffecd9a43179a4c96632ad1d02",
  "files": [
   {
    "filename": "ActivityManager.java",
    "diff": "@@ -3666,6 +3666,9 @@ public class ActivityManager {\n      * processes to reclaim memory; the system will take care of restarting\n      * these processes in the future as needed.\n      *\n+     * <p class=\"note\">Third party applications can only use this API to kill their own processes.\n+     * </p>\n+     *\n      * @param packageName The name of the package whose processes are to\n      * be killed.\n      */\n",
    "added_lines": 3,
    "deleted_lines": 0,
    "changed_methods": ""
   },
   {
    "filename": "ActivityManagerService.java",
    "diff": "@@ -3618,8 +3618,20 @@ public class ActivityManagerService extends IActivityManager.Stub\n             Slog.w(TAG, msg);\n             throw new SecurityException(msg);\n         }\n+        final int callingUid = Binder.getCallingUid();\n+        final int callingPid = Binder.getCallingPid();\n+        final int callingAppId = UserHandle.getAppId(callingUid);\n \n-        userId = mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(),\n+        ProcessRecord proc;\n+        synchronized (mPidsSelfLocked) {\n+            proc = mPidsSelfLocked.get(callingPid);\n+        }\n+        final boolean hasKillAllPermission = PERMISSION_GRANTED == checkPermission(\n+                android.Manifest.permission.FORCE_STOP_PACKAGES, callingPid, callingUid)\n+                || UserHandle.isCore(callingUid)\n+                || (proc != null && proc.info.isSystemApp());\n+\n+        userId = mUserController.handleIncomingUser(callingPid, callingUid,\n                 userId, true, ALLOW_FULL_ONLY, \"killBackgroundProcesses\", null);\n         final int[] userIds = mUserController.expandUserId(userId);\n \n@@ -3634,7 +3646,7 @@ public class ActivityManagerService extends IActivityManager.Stub\n                                     targetUserId));\n                 } catch (RemoteException e) {\n                 }\n-                if (appId == -1) {\n+                if (appId == -1 || (!hasKillAllPermission && appId != callingAppId)) {\n                     Slog.w(TAG, \"Invalid packageName: \" + packageName);\n                     return;\n                 }\n@@ -3702,6 +3714,22 @@ public class ActivityManagerService extends IActivityManager.Stub\n             throw new SecurityException(msg);\n         }\n \n+        final int callingUid = Binder.getCallingUid();\n+        final int callingPid = Binder.getCallingPid();\n+\n+        ProcessRecord proc;\n+        synchronized (mPidsSelfLocked) {\n+            proc = mPidsSelfLocked.get(callingPid);\n+        }\n+        if (callingUid >= FIRST_APPLICATION_UID\n+                && (proc == null || !proc.info.isSystemApp())) {\n+            final String msg = \"Permission Denial: killAllBackgroundProcesses() from pid=\"\n+                    + callingPid + \", uid=\" + callingUid + \" is not allowed\";\n+            Slog.w(TAG, msg);\n+            // Silently return to avoid existing apps from crashing.\n+            return;\n+        }\n+\n         final long callingId = Binder.clearCallingIdentity();\n         try {\n             synchronized (this) {\n",
    "added_lines": 30,
    "deleted_lines": 2,
    "changed_methods": "ActivityManagerService::killBackgroundProcesses, ActivityManagerService::killAllBackgroundProcessesExcept"
   }
  ]
 },
 {
  "hash": "6fc71babb098385e882e7cd491f44970499608ab",
  "commit": "ActivityManagerService: Allow openContentUri from vendor/system/product.\n\nApps should not have direct access to this entry point. Check that the\ncaller is a vendor, system, or product package.\n\nTest: Ran PoC app and CtsMediaPlayerTestCases.\nBug: 236688380\n(cherry picked from commit d0ba7467c2cb2815f94f6651cbb1c2f405e8e9c7)\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:e37820e47c383aecf9d1173a0676c27e6a59ce4f)\nMerged-In: I0335496d28fa5fc3bfe1fecd4be90040b0b3687f\nChange-Id: I0335496d28fa5fc3bfe1fecd4be90040b0b3687f",
  "files": [
   {
    "filename": "ActivityManagerService.java",
    "diff": "@@ -6313,7 +6313,7 @@ public class ActivityManagerService extends IActivityManager.Stub\n         mActivityTaskManager.unhandledBack();\n     }\n \n-    // TODO: Move to ContentProviderHelper?\n+    // TODO: Replace this method with one that returns a bound IContentProvider.\n     public ParcelFileDescriptor openContentUri(String uriString) throws RemoteException {\n         enforceNotIsolatedCaller(\"openContentUri\");\n         final int userId = UserHandle.getCallingUserId();\n@@ -6342,6 +6342,16 @@ public class ActivityManagerService extends IActivityManager.Stub\n                     Log.e(TAG, \"Cannot find package for uid: \" + uid);\n                     return null;\n                 }\n+\n+                final ApplicationInfo appInfo = mPackageManagerInt.getApplicationInfo(\n+                        androidPackage.getPackageName(), /*flags*/0, Process.SYSTEM_UID,\n+                        UserHandle.USER_SYSTEM);\n+                if (!appInfo.isVendor() && !appInfo.isSystemApp() && !appInfo.isSystemExt()\n+                        && !appInfo.isProduct()) {\n+                    Log.e(TAG, \"openContentUri may only be used by vendor/system/product.\");\n+                    return null;\n+                }\n+\n                 final AttributionSource attributionSource = new AttributionSource(\n                         Binder.getCallingUid(), androidPackage.getPackageName(), null);\n                 pfd = cph.provider.openFile(attributionSource, uri, \"r\", null);\n",
    "added_lines": 11,
    "deleted_lines": 1,
    "changed_methods": "ActivityManagerService::openContentUri"
   }
  ]
 },
 {
  "hash": "64e1eb289bb272e03cf735733211a08dac802b8c",
  "commit": "Do not load drawable for wallet card if the card image icon iscreated\nwith content URI.\n\nThis prevents the primary user from accessing the secondary user's\nphotos for QAW card images.\n\nTest: manually, atest\nBug: 272020068\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:ff753ae693065685d85bbda6af2953905fdf434c)\nMerged-In: I6932c5131b3c795bac4ea9b537938e7ef4f3ea4e\nChange-Id: I6932c5131b3c795bac4ea9b537938e7ef4f3ea4e",
  "files": [
   {
    "filename": "QuickAccessWalletTile.java",
    "diff": "@@ -16,6 +16,7 @@\n \n package com.android.systemui.qs.tiles;\n \n+import static android.graphics.drawable.Icon.TYPE_URI;\n import static android.provider.Settings.Secure.NFC_PAYMENT_DEFAULT_COMPONENT;\n \n import static com.android.systemui.wallet.controller.QuickAccessWalletController.WalletChangeEvent.DEFAULT_PAYMENT_APP_CHANGE;\n@@ -240,7 +241,12 @@ public class QuickAccessWalletTile extends QSTileImpl<QSTile.State> {\n                 return;\n             }\n             mSelectedCard = cards.get(selectedIndex);\n-            mCardViewDrawable = mSelectedCard.getCardImage().loadDrawable(mContext);\n+            android.graphics.drawable.Icon cardImageIcon = mSelectedCard.getCardImage();\n+            if (cardImageIcon.getType() == TYPE_URI) {\n+                mCardViewDrawable = null;\n+            } else {\n+                mCardViewDrawable = mSelectedCard.getCardImage().loadDrawable(mContext);\n+            }\n             refreshState();\n         }\n \n",
    "added_lines": 7,
    "deleted_lines": 1,
    "changed_methods": "QuickAccessWalletTile::WalletCardRetriever::onWalletCardsRetrieved"
   },
   {
    "filename": "WalletScreenController.java",
    "diff": "@@ -318,7 +318,12 @@ public class WalletScreenController implements\n          */\n         QAWalletCardViewInfo(Context context, WalletCard walletCard) {\n             mWalletCard = walletCard;\n-            mCardDrawable = mWalletCard.getCardImage().loadDrawable(context);\n+            Icon cardImageIcon = mWalletCard.getCardImage();\n+            if (cardImageIcon.getType() == Icon.TYPE_URI) {\n+                mCardDrawable = null;\n+            } else {\n+                mCardDrawable = mWalletCard.getCardImage().loadDrawable(context);\n+            }\n             Icon icon = mWalletCard.getCardIcon();\n             mIconDrawable = icon == null ? null : icon.loadDrawable(context);\n         }\n",
    "added_lines": 6,
    "deleted_lines": 1,
    "changed_methods": "WalletScreenController::QAWalletCardViewInfo::QAWalletCardViewInfo"
   },
   {
    "filename": "QuickAccessWalletTileTest.java",
    "diff": "@@ -91,8 +91,11 @@ public class QuickAccessWalletTileTest extends SysuiTestCase {\n \n     private static final String CARD_ID = \"card_id\";\n     private static final String LABEL = \"QAW\";\n+    private static final String CARD_DESCRIPTION = \"\u2022\u2022\u2022\u2022 1234\";\n     private static final Icon CARD_IMAGE =\n             Icon.createWithBitmap(Bitmap.createBitmap(70, 50, Bitmap.Config.ARGB_8888));\n+    private static final int PRIMARY_USER_ID = 0;\n+    private static final int SECONDARY_USER_ID = 10;\n \n     private final Drawable mTileIcon = mContext.getDrawable(R.drawable.ic_qs_wallet);\n     private final Intent mWalletIntent = new Intent(QuickAccessWalletService.ACTION_VIEW_WALLET)\n@@ -119,6 +122,8 @@ public class QuickAccessWalletTileTest extends SysuiTestCase {\n     private SecureSettings mSecureSettings;\n     @Mock\n     private QuickAccessWalletController mController;\n+    @Mock\n+    private Icon mCardImage;\n     @Captor\n     ArgumentCaptor<Intent> mIntentCaptor;\n     @Captor\n@@ -144,6 +149,8 @@ public class QuickAccessWalletTileTest extends SysuiTestCase {\n         when(mQuickAccessWalletClient.isWalletServiceAvailable()).thenReturn(true);\n         when(mQuickAccessWalletClient.isWalletFeatureAvailableWhenDeviceLocked()).thenReturn(true);\n         when(mController.getWalletClient()).thenReturn(mQuickAccessWalletClient);\n+        when(mCardImage.getType()).thenReturn(Icon.TYPE_URI);\n+        when(mCardImage.loadDrawableAsUser(any(), eq(SECONDARY_USER_ID))).thenReturn(null);\n \n         mTile = new QuickAccessWalletTile(\n                 mHost,\n@@ -418,6 +425,28 @@ public class QuickAccessWalletTileTest extends SysuiTestCase {\n         assertNotNull(mTile.getState().sideViewCustomDrawable);\n     }\n \n+    @Test\n+    public void testQueryCards_notCurrentUser_hasCards_noSideViewDrawable() {\n+        when(mKeyguardStateController.isUnlocked()).thenReturn(true);\n+\n+        PendingIntent pendingIntent =\n+                PendingIntent.getActivity(mContext, 0, mWalletIntent, PendingIntent.FLAG_IMMUTABLE);\n+        WalletCard walletCard =\n+                new WalletCard.Builder(\n+                    CARD_ID, mCardImage, CARD_DESCRIPTION, pendingIntent).build();\n+        GetWalletCardsResponse response =\n+                new GetWalletCardsResponse(Collections.singletonList(walletCard), 0);\n+\n+        mTile.handleSetListening(true);\n+\n+        verify(mController).queryWalletCards(mCallbackCaptor.capture());\n+\n+        mCallbackCaptor.getValue().onWalletCardsRetrieved(response);\n+        mTestableLooper.processAllMessages();\n+\n+        assertNull(mTile.getState().sideViewCustomDrawable);\n+    }\n+\n     @Test\n     public void testQueryCards_noCards_notUpdateSideViewDrawable() {\n         setUpWalletCard(/* hasCard= */ false);\n@@ -465,6 +494,6 @@ public class QuickAccessWalletTileTest extends SysuiTestCase {\n     private WalletCard createWalletCard(Context context) {\n         PendingIntent pendingIntent =\n                 PendingIntent.getActivity(context, 0, mWalletIntent, PendingIntent.FLAG_IMMUTABLE);\n-        return new WalletCard.Builder(CARD_ID, CARD_IMAGE, \"\u2022\u2022\u2022\u2022 1234\", pendingIntent).build();\n+        return new WalletCard.Builder(CARD_ID, CARD_IMAGE, CARD_DESCRIPTION, pendingIntent).build();\n     }\n }\n",
    "added_lines": 30,
    "deleted_lines": 1,
    "changed_methods": "QuickAccessWalletTileTest::createWalletCard, QuickAccessWalletTileTest::testQueryCards_notCurrentUser_hasCards_noSideViewDrawable, QuickAccessWalletTileTest::setUp"
   }
  ]
 },
 {
  "hash": "64e1eb289bb272e03cf735733211a08dac802b8c",
  "commit": "Do not load drawable for wallet card if the card image icon iscreated\nwith content URI.\n\nThis prevents the primary user from accessing the secondary user's\nphotos for QAW card images.\n\nTest: manually, atest\nBug: 272020068\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:ff753ae693065685d85bbda6af2953905fdf434c)\nMerged-In: I6932c5131b3c795bac4ea9b537938e7ef4f3ea4e\nChange-Id: I6932c5131b3c795bac4ea9b537938e7ef4f3ea4e",
  "files": [
   {
    "filename": "QuickAccessWalletTile.java",
    "diff": "@@ -16,6 +16,7 @@\n \n package com.android.systemui.qs.tiles;\n \n+import static android.graphics.drawable.Icon.TYPE_URI;\n import static android.provider.Settings.Secure.NFC_PAYMENT_DEFAULT_COMPONENT;\n \n import static com.android.systemui.wallet.controller.QuickAccessWalletController.WalletChangeEvent.DEFAULT_PAYMENT_APP_CHANGE;\n@@ -240,7 +241,12 @@ public class QuickAccessWalletTile extends QSTileImpl<QSTile.State> {\n                 return;\n             }\n             mSelectedCard = cards.get(selectedIndex);\n-            mCardViewDrawable = mSelectedCard.getCardImage().loadDrawable(mContext);\n+            android.graphics.drawable.Icon cardImageIcon = mSelectedCard.getCardImage();\n+            if (cardImageIcon.getType() == TYPE_URI) {\n+                mCardViewDrawable = null;\n+            } else {\n+                mCardViewDrawable = mSelectedCard.getCardImage().loadDrawable(mContext);\n+            }\n             refreshState();\n         }\n \n",
    "added_lines": 7,
    "deleted_lines": 1,
    "changed_methods": "QuickAccessWalletTile::WalletCardRetriever::onWalletCardsRetrieved"
   },
   {
    "filename": "WalletScreenController.java",
    "diff": "@@ -318,7 +318,12 @@ public class WalletScreenController implements\n          */\n         QAWalletCardViewInfo(Context context, WalletCard walletCard) {\n             mWalletCard = walletCard;\n-            mCardDrawable = mWalletCard.getCardImage().loadDrawable(context);\n+            Icon cardImageIcon = mWalletCard.getCardImage();\n+            if (cardImageIcon.getType() == Icon.TYPE_URI) {\n+                mCardDrawable = null;\n+            } else {\n+                mCardDrawable = mWalletCard.getCardImage().loadDrawable(context);\n+            }\n             Icon icon = mWalletCard.getCardIcon();\n             mIconDrawable = icon == null ? null : icon.loadDrawable(context);\n         }\n",
    "added_lines": 6,
    "deleted_lines": 1,
    "changed_methods": "WalletScreenController::QAWalletCardViewInfo::QAWalletCardViewInfo"
   },
   {
    "filename": "QuickAccessWalletTileTest.java",
    "diff": "@@ -91,8 +91,11 @@ public class QuickAccessWalletTileTest extends SysuiTestCase {\n \n     private static final String CARD_ID = \"card_id\";\n     private static final String LABEL = \"QAW\";\n+    private static final String CARD_DESCRIPTION = \"\u2022\u2022\u2022\u2022 1234\";\n     private static final Icon CARD_IMAGE =\n             Icon.createWithBitmap(Bitmap.createBitmap(70, 50, Bitmap.Config.ARGB_8888));\n+    private static final int PRIMARY_USER_ID = 0;\n+    private static final int SECONDARY_USER_ID = 10;\n \n     private final Drawable mTileIcon = mContext.getDrawable(R.drawable.ic_qs_wallet);\n     private final Intent mWalletIntent = new Intent(QuickAccessWalletService.ACTION_VIEW_WALLET)\n@@ -119,6 +122,8 @@ public class QuickAccessWalletTileTest extends SysuiTestCase {\n     private SecureSettings mSecureSettings;\n     @Mock\n     private QuickAccessWalletController mController;\n+    @Mock\n+    private Icon mCardImage;\n     @Captor\n     ArgumentCaptor<Intent> mIntentCaptor;\n     @Captor\n@@ -144,6 +149,8 @@ public class QuickAccessWalletTileTest extends SysuiTestCase {\n         when(mQuickAccessWalletClient.isWalletServiceAvailable()).thenReturn(true);\n         when(mQuickAccessWalletClient.isWalletFeatureAvailableWhenDeviceLocked()).thenReturn(true);\n         when(mController.getWalletClient()).thenReturn(mQuickAccessWalletClient);\n+        when(mCardImage.getType()).thenReturn(Icon.TYPE_URI);\n+        when(mCardImage.loadDrawableAsUser(any(), eq(SECONDARY_USER_ID))).thenReturn(null);\n \n         mTile = new QuickAccessWalletTile(\n                 mHost,\n@@ -418,6 +425,28 @@ public class QuickAccessWalletTileTest extends SysuiTestCase {\n         assertNotNull(mTile.getState().sideViewCustomDrawable);\n     }\n \n+    @Test\n+    public void testQueryCards_notCurrentUser_hasCards_noSideViewDrawable() {\n+        when(mKeyguardStateController.isUnlocked()).thenReturn(true);\n+\n+        PendingIntent pendingIntent =\n+                PendingIntent.getActivity(mContext, 0, mWalletIntent, PendingIntent.FLAG_IMMUTABLE);\n+        WalletCard walletCard =\n+                new WalletCard.Builder(\n+                    CARD_ID, mCardImage, CARD_DESCRIPTION, pendingIntent).build();\n+        GetWalletCardsResponse response =\n+                new GetWalletCardsResponse(Collections.singletonList(walletCard), 0);\n+\n+        mTile.handleSetListening(true);\n+\n+        verify(mController).queryWalletCards(mCallbackCaptor.capture());\n+\n+        mCallbackCaptor.getValue().onWalletCardsRetrieved(response);\n+        mTestableLooper.processAllMessages();\n+\n+        assertNull(mTile.getState().sideViewCustomDrawable);\n+    }\n+\n     @Test\n     public void testQueryCards_noCards_notUpdateSideViewDrawable() {\n         setUpWalletCard(/* hasCard= */ false);\n@@ -465,6 +494,6 @@ public class QuickAccessWalletTileTest extends SysuiTestCase {\n     private WalletCard createWalletCard(Context context) {\n         PendingIntent pendingIntent =\n                 PendingIntent.getActivity(context, 0, mWalletIntent, PendingIntent.FLAG_IMMUTABLE);\n-        return new WalletCard.Builder(CARD_ID, CARD_IMAGE, \"\u2022\u2022\u2022\u2022 1234\", pendingIntent).build();\n+        return new WalletCard.Builder(CARD_ID, CARD_IMAGE, CARD_DESCRIPTION, pendingIntent).build();\n     }\n }\n",
    "added_lines": 30,
    "deleted_lines": 1,
    "changed_methods": "QuickAccessWalletTileTest::createWalletCard, QuickAccessWalletTileTest::testQueryCards_notCurrentUser_hasCards_noSideViewDrawable, QuickAccessWalletTileTest::setUp"
   }
  ]
 },
 {
  "hash": "64e1eb289bb272e03cf735733211a08dac802b8c",
  "commit": "Do not load drawable for wallet card if the card image icon iscreated\nwith content URI.\n\nThis prevents the primary user from accessing the secondary user's\nphotos for QAW card images.\n\nTest: manually, atest\nBug: 272020068\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:ff753ae693065685d85bbda6af2953905fdf434c)\nMerged-In: I6932c5131b3c795bac4ea9b537938e7ef4f3ea4e\nChange-Id: I6932c5131b3c795bac4ea9b537938e7ef4f3ea4e",
  "files": [
   {
    "filename": "QuickAccessWalletTile.java",
    "diff": "@@ -16,6 +16,7 @@\n \n package com.android.systemui.qs.tiles;\n \n+import static android.graphics.drawable.Icon.TYPE_URI;\n import static android.provider.Settings.Secure.NFC_PAYMENT_DEFAULT_COMPONENT;\n \n import static com.android.systemui.wallet.controller.QuickAccessWalletController.WalletChangeEvent.DEFAULT_PAYMENT_APP_CHANGE;\n@@ -240,7 +241,12 @@ public class QuickAccessWalletTile extends QSTileImpl<QSTile.State> {\n                 return;\n             }\n             mSelectedCard = cards.get(selectedIndex);\n-            mCardViewDrawable = mSelectedCard.getCardImage().loadDrawable(mContext);\n+            android.graphics.drawable.Icon cardImageIcon = mSelectedCard.getCardImage();\n+            if (cardImageIcon.getType() == TYPE_URI) {\n+                mCardViewDrawable = null;\n+            } else {\n+                mCardViewDrawable = mSelectedCard.getCardImage().loadDrawable(mContext);\n+            }\n             refreshState();\n         }\n \n",
    "added_lines": 7,
    "deleted_lines": 1,
    "changed_methods": "QuickAccessWalletTile::WalletCardRetriever::onWalletCardsRetrieved"
   },
   {
    "filename": "WalletScreenController.java",
    "diff": "@@ -318,7 +318,12 @@ public class WalletScreenController implements\n          */\n         QAWalletCardViewInfo(Context context, WalletCard walletCard) {\n             mWalletCard = walletCard;\n-            mCardDrawable = mWalletCard.getCardImage().loadDrawable(context);\n+            Icon cardImageIcon = mWalletCard.getCardImage();\n+            if (cardImageIcon.getType() == Icon.TYPE_URI) {\n+                mCardDrawable = null;\n+            } else {\n+                mCardDrawable = mWalletCard.getCardImage().loadDrawable(context);\n+            }\n             Icon icon = mWalletCard.getCardIcon();\n             mIconDrawable = icon == null ? null : icon.loadDrawable(context);\n         }\n",
    "added_lines": 6,
    "deleted_lines": 1,
    "changed_methods": "WalletScreenController::QAWalletCardViewInfo::QAWalletCardViewInfo"
   },
   {
    "filename": "QuickAccessWalletTileTest.java",
    "diff": "@@ -91,8 +91,11 @@ public class QuickAccessWalletTileTest extends SysuiTestCase {\n \n     private static final String CARD_ID = \"card_id\";\n     private static final String LABEL = \"QAW\";\n+    private static final String CARD_DESCRIPTION = \"\u2022\u2022\u2022\u2022 1234\";\n     private static final Icon CARD_IMAGE =\n             Icon.createWithBitmap(Bitmap.createBitmap(70, 50, Bitmap.Config.ARGB_8888));\n+    private static final int PRIMARY_USER_ID = 0;\n+    private static final int SECONDARY_USER_ID = 10;\n \n     private final Drawable mTileIcon = mContext.getDrawable(R.drawable.ic_qs_wallet);\n     private final Intent mWalletIntent = new Intent(QuickAccessWalletService.ACTION_VIEW_WALLET)\n@@ -119,6 +122,8 @@ public class QuickAccessWalletTileTest extends SysuiTestCase {\n     private SecureSettings mSecureSettings;\n     @Mock\n     private QuickAccessWalletController mController;\n+    @Mock\n+    private Icon mCardImage;\n     @Captor\n     ArgumentCaptor<Intent> mIntentCaptor;\n     @Captor\n@@ -144,6 +149,8 @@ public class QuickAccessWalletTileTest extends SysuiTestCase {\n         when(mQuickAccessWalletClient.isWalletServiceAvailable()).thenReturn(true);\n         when(mQuickAccessWalletClient.isWalletFeatureAvailableWhenDeviceLocked()).thenReturn(true);\n         when(mController.getWalletClient()).thenReturn(mQuickAccessWalletClient);\n+        when(mCardImage.getType()).thenReturn(Icon.TYPE_URI);\n+        when(mCardImage.loadDrawableAsUser(any(), eq(SECONDARY_USER_ID))).thenReturn(null);\n \n         mTile = new QuickAccessWalletTile(\n                 mHost,\n@@ -418,6 +425,28 @@ public class QuickAccessWalletTileTest extends SysuiTestCase {\n         assertNotNull(mTile.getState().sideViewCustomDrawable);\n     }\n \n+    @Test\n+    public void testQueryCards_notCurrentUser_hasCards_noSideViewDrawable() {\n+        when(mKeyguardStateController.isUnlocked()).thenReturn(true);\n+\n+        PendingIntent pendingIntent =\n+                PendingIntent.getActivity(mContext, 0, mWalletIntent, PendingIntent.FLAG_IMMUTABLE);\n+        WalletCard walletCard =\n+                new WalletCard.Builder(\n+                    CARD_ID, mCardImage, CARD_DESCRIPTION, pendingIntent).build();\n+        GetWalletCardsResponse response =\n+                new GetWalletCardsResponse(Collections.singletonList(walletCard), 0);\n+\n+        mTile.handleSetListening(true);\n+\n+        verify(mController).queryWalletCards(mCallbackCaptor.capture());\n+\n+        mCallbackCaptor.getValue().onWalletCardsRetrieved(response);\n+        mTestableLooper.processAllMessages();\n+\n+        assertNull(mTile.getState().sideViewCustomDrawable);\n+    }\n+\n     @Test\n     public void testQueryCards_noCards_notUpdateSideViewDrawable() {\n         setUpWalletCard(/* hasCard= */ false);\n@@ -465,6 +494,6 @@ public class QuickAccessWalletTileTest extends SysuiTestCase {\n     private WalletCard createWalletCard(Context context) {\n         PendingIntent pendingIntent =\n                 PendingIntent.getActivity(context, 0, mWalletIntent, PendingIntent.FLAG_IMMUTABLE);\n-        return new WalletCard.Builder(CARD_ID, CARD_IMAGE, \"\u2022\u2022\u2022\u2022 1234\", pendingIntent).build();\n+        return new WalletCard.Builder(CARD_ID, CARD_IMAGE, CARD_DESCRIPTION, pendingIntent).build();\n     }\n }\n",
    "added_lines": 30,
    "deleted_lines": 1,
    "changed_methods": "QuickAccessWalletTileTest::createWalletCard, QuickAccessWalletTileTest::testQueryCards_notCurrentUser_hasCards_noSideViewDrawable, QuickAccessWalletTileTest::setUp"
   }
  ]
 },
 {
  "hash": "ee234c797474f17f1206dbe9bfaa11c39e4e175e",
  "commit": "Verify URI permissions for notification shortcutIcon.\n\nBug: 277593270\nTest: atest NotificationManagerServiceTest\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:beb185c5cd60edc68f4ef386c4407eba9c02c698)\nMerged-In: Iaf2a9a82f18e018e60e6cdc020da6ebf7267e8b1\nChange-Id: Iaf2a9a82f18e018e60e6cdc020da6ebf7267e8b1",
  "files": [
   {
    "filename": "Notification.java",
    "diff": "@@ -2846,6 +2846,8 @@ public class Notification implements Parcelable\n                     }\n                 }\n             }\n+\n+            visitIconUri(visitor, extras.getParcelable(EXTRA_CONVERSATION_ICON));\n         }\n \n         if (isStyle(CallStyle.class) & extras != null) {\n",
    "added_lines": 2,
    "deleted_lines": 0,
    "changed_methods": "Notification::visitUris"
   },
   {
    "filename": "NotificationManagerServiceTest.java",
    "diff": "@@ -4447,6 +4447,8 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n     public void testVisitUris() throws Exception {\n         final Uri audioContents = Uri.parse(\"content://com.example/audio\");\n         final Uri backgroundImage = Uri.parse(\"content://com.example/background\");\n+        final Icon smallIcon = Icon.createWithContentUri(\"content://media/small/icon\");\n+        final Icon largeIcon = Icon.createWithContentUri(\"content://media/large/icon\");\n         final Icon personIcon1 = Icon.createWithContentUri(\"content://media/person1\");\n         final Icon personIcon2 = Icon.createWithContentUri(\"content://media/person2\");\n         final Icon personIcon3 = Icon.createWithContentUri(\"content://media/person3\");\n@@ -4480,7 +4482,8 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n \n         Notification n = new Notification.Builder(mContext, \"a\")\n                 .setContentTitle(\"notification with uris\")\n-                .setSmallIcon(android.R.drawable.sym_def_app_icon)\n+                .setSmallIcon(smallIcon)\n+                .setLargeIcon(largeIcon)\n                 .addExtras(extras)\n                 .build();\n \n@@ -4488,6 +4491,8 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n         n.visitUris(visitor);\n         verify(visitor, times(1)).accept(eq(audioContents));\n         verify(visitor, times(1)).accept(eq(backgroundImage));\n+        verify(visitor, times(1)).accept(eq(smallIcon.getUri()));\n+        verify(visitor, times(1)).accept(eq(largeIcon.getUri()));\n         verify(visitor, times(1)).accept(eq(personIcon1.getUri()));\n         verify(visitor, times(1)).accept(eq(personIcon2.getUri()));\n         verify(visitor, times(1)).accept(eq(personIcon3.getUri()));\n@@ -4495,6 +4500,68 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n         verify(visitor, times(1)).accept(eq(historyUri2));\n     }\n \n+    @Test\n+    public void testVisitUris_audioContentsString() throws Exception {\n+        final Uri audioContents = Uri.parse(\"content://com.example/audio\");\n+\n+        Bundle extras = new Bundle();\n+        extras.putString(Notification.EXTRA_AUDIO_CONTENTS_URI, audioContents.toString());\n+\n+        Notification n = new Notification.Builder(mContext, \"a\")\n+                .setContentTitle(\"notification with uris\")\n+                .setSmallIcon(android.R.drawable.sym_def_app_icon)\n+                .addExtras(extras)\n+                .build();\n+\n+        Consumer<Uri> visitor = (Consumer<Uri>) spy(Consumer.class);\n+        n.visitUris(visitor);\n+        verify(visitor, times(1)).accept(eq(audioContents));\n+    }\n+\n+    @Test\n+    public void testVisitUris_messagingStyle() {\n+        final Icon personIcon1 = Icon.createWithContentUri(\"content://media/person1\");\n+        final Icon personIcon2 = Icon.createWithContentUri(\"content://media/person2\");\n+        final Icon personIcon3 = Icon.createWithContentUri(\"content://media/person3\");\n+        final Person person1 = new Person.Builder()\n+                .setName(\"Messaging Person 1\")\n+                .setIcon(personIcon1)\n+                .build();\n+        final Person person2 = new Person.Builder()\n+                .setName(\"Messaging Person 2\")\n+                .setIcon(personIcon2)\n+                .build();\n+        final Person person3 = new Person.Builder()\n+                .setName(\"Messaging Person 3\")\n+                .setIcon(personIcon3)\n+                .build();\n+        Icon shortcutIcon = Icon.createWithContentUri(\"content://media/shortcut\");\n+\n+        Notification.Builder builder = new Notification.Builder(mContext, \"a\")\n+                .setCategory(Notification.CATEGORY_MESSAGE)\n+                .setContentTitle(\"new message!\")\n+                .setContentText(\"Conversation Notification\")\n+                .setSmallIcon(android.R.drawable.sym_def_app_icon);\n+        Notification.MessagingStyle.Message message1 = new Notification.MessagingStyle.Message(\n+                \"Marco?\", System.currentTimeMillis(), person2);\n+        Notification.MessagingStyle.Message message2 = new Notification.MessagingStyle.Message(\n+                \"Polo!\", System.currentTimeMillis(), person3);\n+        Notification.MessagingStyle style = new Notification.MessagingStyle(person1)\n+                .addMessage(message1)\n+                .addMessage(message2)\n+                .setShortcutIcon(shortcutIcon);\n+        builder.setStyle(style);\n+        Notification n = builder.build();\n+\n+        Consumer<Uri> visitor = (Consumer<Uri>) spy(Consumer.class);\n+        n.visitUris(visitor);\n+\n+        verify(visitor, times(1)).accept(eq(shortcutIcon.getUri()));\n+        verify(visitor, times(1)).accept(eq(personIcon1.getUri()));\n+        verify(visitor, times(1)).accept(eq(personIcon2.getUri()));\n+        verify(visitor, times(1)).accept(eq(personIcon3.getUri()));\n+    }\n+\n     @Test\n     public void testVisitUris_callStyle() {\n         Icon personIcon = Icon.createWithContentUri(\"content://media/person\");\n@@ -4518,24 +4585,6 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n         verify(visitor, times(1)).accept(eq(verificationIcon.getUri()));\n     }\n \n-    @Test\n-    public void testVisitUris_audioContentsString() throws Exception {\n-        final Uri audioContents = Uri.parse(\"content://com.example/audio\");\n-\n-        Bundle extras = new Bundle();\n-        extras.putString(Notification.EXTRA_AUDIO_CONTENTS_URI, audioContents.toString());\n-\n-        Notification n = new Notification.Builder(mContext, \"a\")\n-                .setContentTitle(\"notification with uris\")\n-                .setSmallIcon(android.R.drawable.sym_def_app_icon)\n-                .addExtras(extras)\n-                .build();\n-\n-        Consumer<Uri> visitor = (Consumer<Uri>) spy(Consumer.class);\n-        n.visitUris(visitor);\n-        verify(visitor, times(1)).accept(eq(audioContents));\n-    }\n-\n     @Test\n     public void testSetNotificationPolicy_preP_setOldFields() {\n         ZenModeHelper mZenModeHelper = mock(ZenModeHelper.class);\n",
    "added_lines": 68,
    "deleted_lines": 19,
    "changed_methods": "NotificationManagerServiceTest::testVisitUris_audioContentsString, NotificationManagerServiceTest::testVisitUris, NotificationManagerServiceTest::testVisitUris_messagingStyle"
   }
  ]
 },
 {
  "hash": "ee234c797474f17f1206dbe9bfaa11c39e4e175e",
  "commit": "Verify URI permissions for notification shortcutIcon.\n\nBug: 277593270\nTest: atest NotificationManagerServiceTest\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:beb185c5cd60edc68f4ef386c4407eba9c02c698)\nMerged-In: Iaf2a9a82f18e018e60e6cdc020da6ebf7267e8b1\nChange-Id: Iaf2a9a82f18e018e60e6cdc020da6ebf7267e8b1",
  "files": [
   {
    "filename": "Notification.java",
    "diff": "@@ -2846,6 +2846,8 @@ public class Notification implements Parcelable\n                     }\n                 }\n             }\n+\n+            visitIconUri(visitor, extras.getParcelable(EXTRA_CONVERSATION_ICON));\n         }\n \n         if (isStyle(CallStyle.class) & extras != null) {\n",
    "added_lines": 2,
    "deleted_lines": 0,
    "changed_methods": "Notification::visitUris"
   },
   {
    "filename": "NotificationManagerServiceTest.java",
    "diff": "@@ -4447,6 +4447,8 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n     public void testVisitUris() throws Exception {\n         final Uri audioContents = Uri.parse(\"content://com.example/audio\");\n         final Uri backgroundImage = Uri.parse(\"content://com.example/background\");\n+        final Icon smallIcon = Icon.createWithContentUri(\"content://media/small/icon\");\n+        final Icon largeIcon = Icon.createWithContentUri(\"content://media/large/icon\");\n         final Icon personIcon1 = Icon.createWithContentUri(\"content://media/person1\");\n         final Icon personIcon2 = Icon.createWithContentUri(\"content://media/person2\");\n         final Icon personIcon3 = Icon.createWithContentUri(\"content://media/person3\");\n@@ -4480,7 +4482,8 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n \n         Notification n = new Notification.Builder(mContext, \"a\")\n                 .setContentTitle(\"notification with uris\")\n-                .setSmallIcon(android.R.drawable.sym_def_app_icon)\n+                .setSmallIcon(smallIcon)\n+                .setLargeIcon(largeIcon)\n                 .addExtras(extras)\n                 .build();\n \n@@ -4488,6 +4491,8 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n         n.visitUris(visitor);\n         verify(visitor, times(1)).accept(eq(audioContents));\n         verify(visitor, times(1)).accept(eq(backgroundImage));\n+        verify(visitor, times(1)).accept(eq(smallIcon.getUri()));\n+        verify(visitor, times(1)).accept(eq(largeIcon.getUri()));\n         verify(visitor, times(1)).accept(eq(personIcon1.getUri()));\n         verify(visitor, times(1)).accept(eq(personIcon2.getUri()));\n         verify(visitor, times(1)).accept(eq(personIcon3.getUri()));\n@@ -4495,6 +4500,68 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n         verify(visitor, times(1)).accept(eq(historyUri2));\n     }\n \n+    @Test\n+    public void testVisitUris_audioContentsString() throws Exception {\n+        final Uri audioContents = Uri.parse(\"content://com.example/audio\");\n+\n+        Bundle extras = new Bundle();\n+        extras.putString(Notification.EXTRA_AUDIO_CONTENTS_URI, audioContents.toString());\n+\n+        Notification n = new Notification.Builder(mContext, \"a\")\n+                .setContentTitle(\"notification with uris\")\n+                .setSmallIcon(android.R.drawable.sym_def_app_icon)\n+                .addExtras(extras)\n+                .build();\n+\n+        Consumer<Uri> visitor = (Consumer<Uri>) spy(Consumer.class);\n+        n.visitUris(visitor);\n+        verify(visitor, times(1)).accept(eq(audioContents));\n+    }\n+\n+    @Test\n+    public void testVisitUris_messagingStyle() {\n+        final Icon personIcon1 = Icon.createWithContentUri(\"content://media/person1\");\n+        final Icon personIcon2 = Icon.createWithContentUri(\"content://media/person2\");\n+        final Icon personIcon3 = Icon.createWithContentUri(\"content://media/person3\");\n+        final Person person1 = new Person.Builder()\n+                .setName(\"Messaging Person 1\")\n+                .setIcon(personIcon1)\n+                .build();\n+        final Person person2 = new Person.Builder()\n+                .setName(\"Messaging Person 2\")\n+                .setIcon(personIcon2)\n+                .build();\n+        final Person person3 = new Person.Builder()\n+                .setName(\"Messaging Person 3\")\n+                .setIcon(personIcon3)\n+                .build();\n+        Icon shortcutIcon = Icon.createWithContentUri(\"content://media/shortcut\");\n+\n+        Notification.Builder builder = new Notification.Builder(mContext, \"a\")\n+                .setCategory(Notification.CATEGORY_MESSAGE)\n+                .setContentTitle(\"new message!\")\n+                .setContentText(\"Conversation Notification\")\n+                .setSmallIcon(android.R.drawable.sym_def_app_icon);\n+        Notification.MessagingStyle.Message message1 = new Notification.MessagingStyle.Message(\n+                \"Marco?\", System.currentTimeMillis(), person2);\n+        Notification.MessagingStyle.Message message2 = new Notification.MessagingStyle.Message(\n+                \"Polo!\", System.currentTimeMillis(), person3);\n+        Notification.MessagingStyle style = new Notification.MessagingStyle(person1)\n+                .addMessage(message1)\n+                .addMessage(message2)\n+                .setShortcutIcon(shortcutIcon);\n+        builder.setStyle(style);\n+        Notification n = builder.build();\n+\n+        Consumer<Uri> visitor = (Consumer<Uri>) spy(Consumer.class);\n+        n.visitUris(visitor);\n+\n+        verify(visitor, times(1)).accept(eq(shortcutIcon.getUri()));\n+        verify(visitor, times(1)).accept(eq(personIcon1.getUri()));\n+        verify(visitor, times(1)).accept(eq(personIcon2.getUri()));\n+        verify(visitor, times(1)).accept(eq(personIcon3.getUri()));\n+    }\n+\n     @Test\n     public void testVisitUris_callStyle() {\n         Icon personIcon = Icon.createWithContentUri(\"content://media/person\");\n@@ -4518,24 +4585,6 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n         verify(visitor, times(1)).accept(eq(verificationIcon.getUri()));\n     }\n \n-    @Test\n-    public void testVisitUris_audioContentsString() throws Exception {\n-        final Uri audioContents = Uri.parse(\"content://com.example/audio\");\n-\n-        Bundle extras = new Bundle();\n-        extras.putString(Notification.EXTRA_AUDIO_CONTENTS_URI, audioContents.toString());\n-\n-        Notification n = new Notification.Builder(mContext, \"a\")\n-                .setContentTitle(\"notification with uris\")\n-                .setSmallIcon(android.R.drawable.sym_def_app_icon)\n-                .addExtras(extras)\n-                .build();\n-\n-        Consumer<Uri> visitor = (Consumer<Uri>) spy(Consumer.class);\n-        n.visitUris(visitor);\n-        verify(visitor, times(1)).accept(eq(audioContents));\n-    }\n-\n     @Test\n     public void testSetNotificationPolicy_preP_setOldFields() {\n         ZenModeHelper mZenModeHelper = mock(ZenModeHelper.class);\n",
    "added_lines": 68,
    "deleted_lines": 19,
    "changed_methods": "NotificationManagerServiceTest::testVisitUris_audioContentsString, NotificationManagerServiceTest::testVisitUris, NotificationManagerServiceTest::testVisitUris_messagingStyle"
   }
  ]
 },
 {
  "hash": "580ee2c3614140ff611acd1af2132a43a16bb88f",
  "commit": "Ensure policy has no absurdly long strings\n\nThe following APIs now enforce limits and throw IllegalArgumentException\nwhen limits are violated:\n* DPM.setTrustAgentConfiguration() limits agent packgage name,\n  component name, and strings within configuration bundle.\n* DPM.setPermittedAccessibilityServices() limits package names.\n* DPM.setPermittedInputMethods() limits package names.\n* DPM.setAccountManagementDisabled() limits account name.\n* DPM.setLockTaskPackages() limits package names.\n* DPM.setAffiliationIds() limits id.\n* DPM.transferOwnership() limits strings inside the bundle.\n\nPackage names are limited at 223, because they become directory names\nand it is a filesystem restriction, see FrameworkParsingPackageUtils.\n\nAll other strings are limited at 65535, because longer ones break binary\nXML serializer.\n\nThe following APIs silently truncate strings that are long beyond reason:\n* DPM.setShortSupportMessage() truncates message at 200.\n* DPM.setLongSupportMessage() truncates message at 20000.\n* DPM.setOrganizationName() truncates org name at 200.\n\nBug: 260729089\nTest: atest com.android.server.devicepolicy\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:12c201509e911f4dddabf371bd22c93e097e5d99)\nMerged-In: Idcf54e408722f164d16bf2f24a00cd1f5b626d23\nChange-Id: Idcf54e408722f164d16bf2f24a00cd1f5b626d23",
  "files": [
   {
    "filename": "DevicePolicyManager.java",
    "diff": "@@ -11411,7 +11411,8 @@ public class DevicePolicyManager {\n \n     /**\n      * Called by a device admin to set the long support message. This will be displayed to the user\n-     * in the device administators settings screen.\n+     * in the device administrators settings screen. If the message is longer than 20000 characters\n+     * it may be truncated.\n      * <p>\n      * If the long support message needs to be localized, it is the responsibility of the\n      * {@link DeviceAdminReceiver} to listen to the {@link Intent#ACTION_LOCALE_CHANGED} broadcast\n",
    "added_lines": 2,
    "deleted_lines": 1,
    "changed_methods": ""
   },
   {
    "filename": "DevicePolicyManagerService.java",
    "diff": "@@ -361,6 +361,7 @@ import java.security.cert.CertificateFactory;\n import java.security.cert.X509Certificate;\n import java.text.DateFormat;\n import java.time.LocalDate;\n+import java.util.ArrayDeque;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collection;\n@@ -372,6 +373,7 @@ import java.util.List;\n import java.util.Locale;\n import java.util.Map;\n import java.util.Objects;\n+import java.util.Queue;\n import java.util.Set;\n import java.util.concurrent.TimeUnit;\n import java.util.function.Function;\n@@ -400,6 +402,15 @@ public class DevicePolicyManagerService extends BaseIDevicePolicyManager {\n \n     private static final int REQUEST_PROFILE_OFF_DEADLINE = 5572;\n \n+    // Binary XML serializer doesn't support longer strings\n+    private static final int MAX_POLICY_STRING_LENGTH = 65535;\n+    // FrameworkParsingPackageUtils#MAX_FILE_NAME_SIZE, Android packages are used in dir names.\n+    private static final int MAX_PACKAGE_NAME_LENGTH = 223;\n+\n+    private static final int MAX_LONG_SUPPORT_MESSAGE_LENGTH = 20000;\n+    private static final int MAX_SHORT_SUPPORT_MESSAGE_LENGTH = 200;\n+    private static final int MAX_ORG_NAME_LENGTH = 200;\n+\n     private static final long MS_PER_DAY = TimeUnit.DAYS.toMillis(1);\n \n     private static final long EXPIRATION_GRACE_PERIOD_MS = 5 * MS_PER_DAY; // 5 days, in ms\n@@ -9983,6 +9994,12 @@ public class DevicePolicyManagerService extends BaseIDevicePolicyManager {\n         }\n         Objects.requireNonNull(admin, \"admin is null\");\n         Objects.requireNonNull(agent, \"agent is null\");\n+        enforceMaxPackageNameLength(agent.getPackageName());\n+        final String agentAsString = agent.flattenToString();\n+        enforceMaxStringLength(agentAsString, \"agent name\");\n+        if (args != null) {\n+            enforceMaxStringLength(args, \"args\");\n+        }\n         final int userHandle = UserHandle.getCallingUserId();\n         synchronized (getLockObject()) {\n             ActiveAdmin ap = getActiveAdminForCallerLocked(admin,\n@@ -10221,6 +10238,10 @@ public class DevicePolicyManagerService extends BaseIDevicePolicyManager {\n         final CallerIdentity caller = getCallerIdentity(who);\n \n         if (packageList != null) {\n+            for (String pkg : (List<String>) packageList) {\n+                enforceMaxPackageNameLength(pkg);\n+            }\n+\n             int userId = caller.getUserId();\n             final List<AccessibilityServiceInfo> enabledServices;\n             long id = mInjector.binderClearCallingIdentity();\n@@ -10387,6 +10408,10 @@ public class DevicePolicyManagerService extends BaseIDevicePolicyManager {\n         }\n \n         if (packageList != null) {\n+            for (String pkg : (List<String>) packageList) {\n+                enforceMaxPackageNameLength(pkg);\n+            }\n+\n             List<InputMethodInfo> enabledImes = mInjector.binderWithCleanCallingIdentity(() ->\n                     InputMethodManagerInternal.get().getEnabledInputMethodListAsUser(userId));\n             if (enabledImes != null) {\n@@ -11706,6 +11731,8 @@ public class DevicePolicyManagerService extends BaseIDevicePolicyManager {\n             return;\n         }\n         Objects.requireNonNull(who, \"ComponentName is null\");\n+        enforceMaxStringLength(accountType, \"account type\");\n+\n         final CallerIdentity caller = getCallerIdentity(who);\n         synchronized (getLockObject()) {\n             /*\n@@ -12124,6 +12151,10 @@ public class DevicePolicyManagerService extends BaseIDevicePolicyManager {\n             throws SecurityException {\n         Objects.requireNonNull(who, \"ComponentName is null\");\n         Objects.requireNonNull(packages, \"packages is null\");\n+        for (String pkg : packages) {\n+            enforceMaxPackageNameLength(pkg);\n+        }\n+\n         final CallerIdentity caller = getCallerIdentity(who);\n \n         synchronized (getLockObject()) {\n@@ -14174,6 +14205,8 @@ public class DevicePolicyManagerService extends BaseIDevicePolicyManager {\n             return;\n         }\n         Objects.requireNonNull(who, \"ComponentName is null\");\n+        message = truncateIfLonger(message, MAX_SHORT_SUPPORT_MESSAGE_LENGTH);\n+\n         final CallerIdentity caller = getCallerIdentity(who);\n         synchronized (getLockObject()) {\n             ActiveAdmin admin = getActiveAdminForUidLocked(who, caller.getUid());\n@@ -14206,6 +14239,9 @@ public class DevicePolicyManagerService extends BaseIDevicePolicyManager {\n         if (!mHasFeature) {\n             return;\n         }\n+\n+        message = truncateIfLonger(message, MAX_LONG_SUPPORT_MESSAGE_LENGTH);\n+\n         Objects.requireNonNull(who, \"ComponentName is null\");\n         final CallerIdentity caller = getCallerIdentity(who);\n         synchronized (getLockObject()) {\n@@ -14355,6 +14391,8 @@ public class DevicePolicyManagerService extends BaseIDevicePolicyManager {\n         Objects.requireNonNull(who, \"ComponentName is null\");\n         final CallerIdentity caller = getCallerIdentity(who);\n \n+        text = truncateIfLonger(text, MAX_ORG_NAME_LENGTH);\n+\n         synchronized (getLockObject()) {\n             ActiveAdmin admin = getProfileOwnerOrDeviceOwnerLocked(caller);\n             if (!TextUtils.equals(admin.organizationName, text)) {\n@@ -14604,9 +14642,8 @@ public class DevicePolicyManagerService extends BaseIDevicePolicyManager {\n             throw new IllegalArgumentException(\"ids must not be null\");\n         }\n         for (String id : ids) {\n-            if (TextUtils.isEmpty(id)) {\n-                throw new IllegalArgumentException(\"ids must not contain empty string\");\n-            }\n+            Preconditions.checkArgument(!TextUtils.isEmpty(id), \"ids must not have empty string\");\n+            enforceMaxStringLength(id, \"affiliation id\");\n         }\n \n         final Set<String> affiliationIds = new ArraySet<>(ids);\n@@ -15889,6 +15926,9 @@ public class DevicePolicyManagerService extends BaseIDevicePolicyManager {\n                 \"Provided administrator and target are the same object.\");\n         Preconditions.checkArgument(!admin.getPackageName().equals(target.getPackageName()),\n                 \"Provided administrator and target have the same package name.\");\n+        if (bundle != null) {\n+            enforceMaxStringLength(bundle, \"bundle\");\n+        }\n \n         final CallerIdentity caller = getCallerIdentity(admin);\n         Preconditions.checkCallAuthorization(isDeviceOwner(caller) || isProfileOwner(caller));\n@@ -17998,4 +18038,51 @@ public class DevicePolicyManagerService extends BaseIDevicePolicyManager {\n                         && mInjector.getUsbManager().getUsbHalVersion() >= UsbManager.USB_HAL_V1_3\n         );\n     }\n+\n+    /**\n+     * Truncates char sequence to maximum length, nulls are ignored.\n+     */\n+    private static CharSequence truncateIfLonger(CharSequence input, int maxLength) {\n+        return input == null || input.length() <= maxLength\n+                ? input\n+                : input.subSequence(0, maxLength);\n+    }\n+\n+    /**\n+     * Throw if string argument is too long to be serialized.\n+     */\n+    private static void enforceMaxStringLength(String str, String argName) {\n+        Preconditions.checkArgument(\n+                str.length() <= MAX_POLICY_STRING_LENGTH, argName + \" loo long\");\n+    }\n+\n+    private static void enforceMaxPackageNameLength(String pkg) {\n+        Preconditions.checkArgument(\n+                pkg.length() <= MAX_PACKAGE_NAME_LENGTH, \"Package name too long\");\n+    }\n+\n+    /**\n+     * Throw if persistable bundle contains any string that we can't serialize.\n+     */\n+    private static void enforceMaxStringLength(PersistableBundle bundle, String argName) {\n+        // Persistable bundles can have other persistable bundles as values, traverse with a queue.\n+        Queue<PersistableBundle> queue = new ArrayDeque<>();\n+        queue.add(bundle);\n+        while (!queue.isEmpty()) {\n+            PersistableBundle current = queue.remove();\n+            for (String key : current.keySet()) {\n+                enforceMaxStringLength(key, \"key in \" + argName);\n+                Object value = current.get(key);\n+                if (value instanceof String) {\n+                    enforceMaxStringLength((String) value, \"string value in \" + argName);\n+                } else if (value instanceof String[]) {\n+                    for (String str : (String[]) value) {\n+                        enforceMaxStringLength(str, \"string value in \" + argName);\n+                    }\n+                } else if (value instanceof PersistableBundle) {\n+                    queue.add((PersistableBundle) value);\n+                }\n+            }\n+        }\n+    }\n }\n",
    "added_lines": 90,
    "deleted_lines": 3,
    "changed_methods": "DevicePolicyManagerService::setPermittedAccessibilityServices, DevicePolicyManagerService::enforceMaxStringLength, DevicePolicyManagerService::setAffiliationIds, DevicePolicyManagerService::setLockTaskPackages, DevicePolicyManagerService::enforceMaxStringLength, DevicePolicyManagerService::setTrustAgentConfiguration, DevicePolicyManagerService::truncateIfLonger, DevicePolicyManagerService::setAccountManagementDisabled, DevicePolicyManagerService::setPermittedInputMethods, DevicePolicyManagerService::setShortSupportMessage, DevicePolicyManagerService::enforceMaxPackageNameLength, DevicePolicyManagerService::setOrganizationName, DevicePolicyManagerService::transferOwnership, DevicePolicyManagerService::setLongSupportMessage"
   }
  ]
 },
 {
  "hash": "580ee2c3614140ff611acd1af2132a43a16bb88f",
  "commit": "Ensure policy has no absurdly long strings\n\nThe following APIs now enforce limits and throw IllegalArgumentException\nwhen limits are violated:\n* DPM.setTrustAgentConfiguration() limits agent packgage name,\n  component name, and strings within configuration bundle.\n* DPM.setPermittedAccessibilityServices() limits package names.\n* DPM.setPermittedInputMethods() limits package names.\n* DPM.setAccountManagementDisabled() limits account name.\n* DPM.setLockTaskPackages() limits package names.\n* DPM.setAffiliationIds() limits id.\n* DPM.transferOwnership() limits strings inside the bundle.\n\nPackage names are limited at 223, because they become directory names\nand it is a filesystem restriction, see FrameworkParsingPackageUtils.\n\nAll other strings are limited at 65535, because longer ones break binary\nXML serializer.\n\nThe following APIs silently truncate strings that are long beyond reason:\n* DPM.setShortSupportMessage() truncates message at 200.\n* DPM.setLongSupportMessage() truncates message at 20000.\n* DPM.setOrganizationName() truncates org name at 200.\n\nBug: 260729089\nTest: atest com.android.server.devicepolicy\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:12c201509e911f4dddabf371bd22c93e097e5d99)\nMerged-In: Idcf54e408722f164d16bf2f24a00cd1f5b626d23\nChange-Id: Idcf54e408722f164d16bf2f24a00cd1f5b626d23",
  "files": [
   {
    "filename": "DevicePolicyManager.java",
    "diff": "@@ -11411,7 +11411,8 @@ public class DevicePolicyManager {\n \n     /**\n      * Called by a device admin to set the long support message. This will be displayed to the user\n-     * in the device administators settings screen.\n+     * in the device administrators settings screen. If the message is longer than 20000 characters\n+     * it may be truncated.\n      * <p>\n      * If the long support message needs to be localized, it is the responsibility of the\n      * {@link DeviceAdminReceiver} to listen to the {@link Intent#ACTION_LOCALE_CHANGED} broadcast\n",
    "added_lines": 2,
    "deleted_lines": 1,
    "changed_methods": ""
   },
   {
    "filename": "DevicePolicyManagerService.java",
    "diff": "@@ -361,6 +361,7 @@ import java.security.cert.CertificateFactory;\n import java.security.cert.X509Certificate;\n import java.text.DateFormat;\n import java.time.LocalDate;\n+import java.util.ArrayDeque;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collection;\n@@ -372,6 +373,7 @@ import java.util.List;\n import java.util.Locale;\n import java.util.Map;\n import java.util.Objects;\n+import java.util.Queue;\n import java.util.Set;\n import java.util.concurrent.TimeUnit;\n import java.util.function.Function;\n@@ -400,6 +402,15 @@ public class DevicePolicyManagerService extends BaseIDevicePolicyManager {\n \n     private static final int REQUEST_PROFILE_OFF_DEADLINE = 5572;\n \n+    // Binary XML serializer doesn't support longer strings\n+    private static final int MAX_POLICY_STRING_LENGTH = 65535;\n+    // FrameworkParsingPackageUtils#MAX_FILE_NAME_SIZE, Android packages are used in dir names.\n+    private static final int MAX_PACKAGE_NAME_LENGTH = 223;\n+\n+    private static final int MAX_LONG_SUPPORT_MESSAGE_LENGTH = 20000;\n+    private static final int MAX_SHORT_SUPPORT_MESSAGE_LENGTH = 200;\n+    private static final int MAX_ORG_NAME_LENGTH = 200;\n+\n     private static final long MS_PER_DAY = TimeUnit.DAYS.toMillis(1);\n \n     private static final long EXPIRATION_GRACE_PERIOD_MS = 5 * MS_PER_DAY; // 5 days, in ms\n@@ -9983,6 +9994,12 @@ public class DevicePolicyManagerService extends BaseIDevicePolicyManager {\n         }\n         Objects.requireNonNull(admin, \"admin is null\");\n         Objects.requireNonNull(agent, \"agent is null\");\n+        enforceMaxPackageNameLength(agent.getPackageName());\n+        final String agentAsString = agent.flattenToString();\n+        enforceMaxStringLength(agentAsString, \"agent name\");\n+        if (args != null) {\n+            enforceMaxStringLength(args, \"args\");\n+        }\n         final int userHandle = UserHandle.getCallingUserId();\n         synchronized (getLockObject()) {\n             ActiveAdmin ap = getActiveAdminForCallerLocked(admin,\n@@ -10221,6 +10238,10 @@ public class DevicePolicyManagerService extends BaseIDevicePolicyManager {\n         final CallerIdentity caller = getCallerIdentity(who);\n \n         if (packageList != null) {\n+            for (String pkg : (List<String>) packageList) {\n+                enforceMaxPackageNameLength(pkg);\n+            }\n+\n             int userId = caller.getUserId();\n             final List<AccessibilityServiceInfo> enabledServices;\n             long id = mInjector.binderClearCallingIdentity();\n@@ -10387,6 +10408,10 @@ public class DevicePolicyManagerService extends BaseIDevicePolicyManager {\n         }\n \n         if (packageList != null) {\n+            for (String pkg : (List<String>) packageList) {\n+                enforceMaxPackageNameLength(pkg);\n+            }\n+\n             List<InputMethodInfo> enabledImes = mInjector.binderWithCleanCallingIdentity(() ->\n                     InputMethodManagerInternal.get().getEnabledInputMethodListAsUser(userId));\n             if (enabledImes != null) {\n@@ -11706,6 +11731,8 @@ public class DevicePolicyManagerService extends BaseIDevicePolicyManager {\n             return;\n         }\n         Objects.requireNonNull(who, \"ComponentName is null\");\n+        enforceMaxStringLength(accountType, \"account type\");\n+\n         final CallerIdentity caller = getCallerIdentity(who);\n         synchronized (getLockObject()) {\n             /*\n@@ -12124,6 +12151,10 @@ public class DevicePolicyManagerService extends BaseIDevicePolicyManager {\n             throws SecurityException {\n         Objects.requireNonNull(who, \"ComponentName is null\");\n         Objects.requireNonNull(packages, \"packages is null\");\n+        for (String pkg : packages) {\n+            enforceMaxPackageNameLength(pkg);\n+        }\n+\n         final CallerIdentity caller = getCallerIdentity(who);\n \n         synchronized (getLockObject()) {\n@@ -14174,6 +14205,8 @@ public class DevicePolicyManagerService extends BaseIDevicePolicyManager {\n             return;\n         }\n         Objects.requireNonNull(who, \"ComponentName is null\");\n+        message = truncateIfLonger(message, MAX_SHORT_SUPPORT_MESSAGE_LENGTH);\n+\n         final CallerIdentity caller = getCallerIdentity(who);\n         synchronized (getLockObject()) {\n             ActiveAdmin admin = getActiveAdminForUidLocked(who, caller.getUid());\n@@ -14206,6 +14239,9 @@ public class DevicePolicyManagerService extends BaseIDevicePolicyManager {\n         if (!mHasFeature) {\n             return;\n         }\n+\n+        message = truncateIfLonger(message, MAX_LONG_SUPPORT_MESSAGE_LENGTH);\n+\n         Objects.requireNonNull(who, \"ComponentName is null\");\n         final CallerIdentity caller = getCallerIdentity(who);\n         synchronized (getLockObject()) {\n@@ -14355,6 +14391,8 @@ public class DevicePolicyManagerService extends BaseIDevicePolicyManager {\n         Objects.requireNonNull(who, \"ComponentName is null\");\n         final CallerIdentity caller = getCallerIdentity(who);\n \n+        text = truncateIfLonger(text, MAX_ORG_NAME_LENGTH);\n+\n         synchronized (getLockObject()) {\n             ActiveAdmin admin = getProfileOwnerOrDeviceOwnerLocked(caller);\n             if (!TextUtils.equals(admin.organizationName, text)) {\n@@ -14604,9 +14642,8 @@ public class DevicePolicyManagerService extends BaseIDevicePolicyManager {\n             throw new IllegalArgumentException(\"ids must not be null\");\n         }\n         for (String id : ids) {\n-            if (TextUtils.isEmpty(id)) {\n-                throw new IllegalArgumentException(\"ids must not contain empty string\");\n-            }\n+            Preconditions.checkArgument(!TextUtils.isEmpty(id), \"ids must not have empty string\");\n+            enforceMaxStringLength(id, \"affiliation id\");\n         }\n \n         final Set<String> affiliationIds = new ArraySet<>(ids);\n@@ -15889,6 +15926,9 @@ public class DevicePolicyManagerService extends BaseIDevicePolicyManager {\n                 \"Provided administrator and target are the same object.\");\n         Preconditions.checkArgument(!admin.getPackageName().equals(target.getPackageName()),\n                 \"Provided administrator and target have the same package name.\");\n+        if (bundle != null) {\n+            enforceMaxStringLength(bundle, \"bundle\");\n+        }\n \n         final CallerIdentity caller = getCallerIdentity(admin);\n         Preconditions.checkCallAuthorization(isDeviceOwner(caller) || isProfileOwner(caller));\n@@ -17998,4 +18038,51 @@ public class DevicePolicyManagerService extends BaseIDevicePolicyManager {\n                         && mInjector.getUsbManager().getUsbHalVersion() >= UsbManager.USB_HAL_V1_3\n         );\n     }\n+\n+    /**\n+     * Truncates char sequence to maximum length, nulls are ignored.\n+     */\n+    private static CharSequence truncateIfLonger(CharSequence input, int maxLength) {\n+        return input == null || input.length() <= maxLength\n+                ? input\n+                : input.subSequence(0, maxLength);\n+    }\n+\n+    /**\n+     * Throw if string argument is too long to be serialized.\n+     */\n+    private static void enforceMaxStringLength(String str, String argName) {\n+        Preconditions.checkArgument(\n+                str.length() <= MAX_POLICY_STRING_LENGTH, argName + \" loo long\");\n+    }\n+\n+    private static void enforceMaxPackageNameLength(String pkg) {\n+        Preconditions.checkArgument(\n+                pkg.length() <= MAX_PACKAGE_NAME_LENGTH, \"Package name too long\");\n+    }\n+\n+    /**\n+     * Throw if persistable bundle contains any string that we can't serialize.\n+     */\n+    private static void enforceMaxStringLength(PersistableBundle bundle, String argName) {\n+        // Persistable bundles can have other persistable bundles as values, traverse with a queue.\n+        Queue<PersistableBundle> queue = new ArrayDeque<>();\n+        queue.add(bundle);\n+        while (!queue.isEmpty()) {\n+            PersistableBundle current = queue.remove();\n+            for (String key : current.keySet()) {\n+                enforceMaxStringLength(key, \"key in \" + argName);\n+                Object value = current.get(key);\n+                if (value instanceof String) {\n+                    enforceMaxStringLength((String) value, \"string value in \" + argName);\n+                } else if (value instanceof String[]) {\n+                    for (String str : (String[]) value) {\n+                        enforceMaxStringLength(str, \"string value in \" + argName);\n+                    }\n+                } else if (value instanceof PersistableBundle) {\n+                    queue.add((PersistableBundle) value);\n+                }\n+            }\n+        }\n+    }\n }\n",
    "added_lines": 90,
    "deleted_lines": 3,
    "changed_methods": "DevicePolicyManagerService::setPermittedAccessibilityServices, DevicePolicyManagerService::enforceMaxStringLength, DevicePolicyManagerService::setAffiliationIds, DevicePolicyManagerService::setLockTaskPackages, DevicePolicyManagerService::enforceMaxStringLength, DevicePolicyManagerService::setTrustAgentConfiguration, DevicePolicyManagerService::truncateIfLonger, DevicePolicyManagerService::setAccountManagementDisabled, DevicePolicyManagerService::setPermittedInputMethods, DevicePolicyManagerService::setShortSupportMessage, DevicePolicyManagerService::enforceMaxPackageNameLength, DevicePolicyManagerService::setOrganizationName, DevicePolicyManagerService::transferOwnership, DevicePolicyManagerService::setLongSupportMessage"
   }
  ]
 },
 {
  "hash": "68d20cfadb029f339a80634271fd2a2da5557adb",
  "commit": "On device lockdown, always show the keyguard\n\nManual test steps:\n1. Enable app pinning and disable \"Ask for PIN before unpinning\" setting\n2. Pin an app (ie: Settings)\n3. Lockdown from the power menu\nObserve: user is brought to the keyguard, primary auth is required\nto enter the device. After entering credential, the device is still in\napp pinning mode.\n\nTest: atest KeyguardViewMediatorTest\nTest: manual steps outlined above\nBug: 218495634\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:b23c2d5fb6630ea0da503b937f62880594b13e94)\nMerged-In: I9a7c5e1acadabd4484e58573331f98dba895f2a2\nChange-Id: I9a7c5e1acadabd4484e58573331f98dba895f2a2\n\nChange-Id: Ia967920c8b3f2388d7a1d4ce7a717525b2680923",
  "files": [
   {
    "filename": "KeyguardViewMediator.java",
    "diff": "@@ -677,6 +677,13 @@ public class KeyguardViewMediator extends SystemUI implements Dumpable,\n                 }\n             }\n         }\n+\n+        @Override\n+        public void onStrongAuthStateChanged(int userId) {\n+            if (mLockPatternUtils.isUserInLockdown(KeyguardUpdateMonitor.getCurrentUser())) {\n+                doKeyguardLocked(null);\n+            }\n+        }\n     };\n \n     ViewMediatorCallback mViewMediatorCallback = new ViewMediatorCallback() {\n@@ -1535,7 +1542,8 @@ public class KeyguardViewMediator extends SystemUI implements Dumpable,\n         }\n \n         // if another app is disabling us, don't show\n-        if (!mExternallyEnabled) {\n+        if (!mExternallyEnabled\n+            && !mLockPatternUtils.isUserInLockdown(KeyguardUpdateMonitor.getCurrentUser())) {\n             if (DEBUG) Log.d(TAG, \"doKeyguard: not showing because externally disabled\");\n \n             mNeedToReshowWhenReenabled = true;\n",
    "added_lines": 9,
    "deleted_lines": 1,
    "changed_methods": "KeyguardViewMediator::KeyguardUpdateMonitorCallback, KeyguardViewMediator::doKeyguardLocked"
   }
  ]
 },
 {
  "hash": "a8ec22f965959cb1f8c76fa5ea9c0edf73ccc003",
  "commit": "Preserve flags for non-runtime permissions upon package update.\n\nPermissionManagerServiceImpl.restorePermissionState() creates a new\nUID permission state for non-shared-UID packages that have been\nupdated (i.e. replaced), however the existing logic for non-runtime\npermission never carried over the flags from the old state. This\nwasn't an issue for much older platforms because permission flags\nweren't used for non-runtime permissions, however since we are\nstarting to use them for role protected permissions (ROLE_GRANTED) and\napp op permissions (USER_SET), we do need to preserver the permission\nflags.\n\nThis change merges the logic for granting and revoking a non-runtime\npermission in restorePermissionState() into a single if branch, and\nappends the logic to copy the flag from the old state in that branch.\n\nBug: 283006437\nTest: PermissionFlagsTest#nonRuntimePermissionFlagsPreservedAfterReinstall\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:0e1ebd84e27f5d4fa8bc6577705293251bcbac4f)\nMerged-In: Iea3c66710e7d28c6fc730b1939da64f1172b08db\nChange-Id: Iea3c66710e7d28c6fc730b1939da64f1172b08db",
  "files": [
   {
    "filename": "PermissionManagerService.java",
    "diff": "@@ -2882,29 +2882,55 @@ public class PermissionManagerService extends IPermissionManager.Stub {\n                                 + pkg.getPackageName());\n                     }\n \n-                    if ((bp.isNormal() && shouldGrantNormalPermission)\n-                            || (bp.isSignature()\n-                                    && (!bp.isPrivileged() || CollectionUtils.contains(\n-                                            isPrivilegedPermissionAllowlisted, permName))\n-                                    && (CollectionUtils.contains(shouldGrantSignaturePermission,\n-                                            permName)\n-                                            || (((bp.isPrivileged() && CollectionUtils.contains(\n-                                                    shouldGrantPrivilegedPermissionIfWasGranted,\n-                                                    permName)) || bp.isDevelopment() || bp.isRole())\n-                                                    && origState.isPermissionGranted(permName))))\n-                            || (bp.isInternal()\n-                                    && (!bp.isPrivileged() || CollectionUtils.contains(\n-                                            isPrivilegedPermissionAllowlisted, permName))\n-                                    && (CollectionUtils.contains(shouldGrantInternalPermission,\n-                                            permName)\n-                                            || (((bp.isPrivileged() && CollectionUtils.contains(\n-                                                    shouldGrantPrivilegedPermissionIfWasGranted,\n-                                                    permName)) || bp.isDevelopment() || bp.isRole())\n-                                                    && origState.isPermissionGranted(permName))))) {\n-                        // Grant an install permission.\n-                        if (uidState.grantPermission(bp)) {\n-                            changedInstallPermission = true;\n+                    if (bp.isNormal() || bp.isSignature() || bp.isInternal()) {\n+                        if ((bp.isNormal() && shouldGrantNormalPermission)\n+                                || (bp.isSignature()\n+                                        && (!bp.isPrivileged() || CollectionUtils.contains(\n+                                                isPrivilegedPermissionAllowlisted, permName))\n+                                        && (CollectionUtils.contains(shouldGrantSignaturePermission,\n+                                                permName)\n+                                                || (((bp.isPrivileged() && CollectionUtils.contains(\n+                                                        shouldGrantPrivilegedPermissionIfWasGranted,\n+                                                        permName)) || bp.isDevelopment()\n+                                                                || bp.isRole())\n+                                                        && origState.isPermissionGranted(\n+                                                                permName))))\n+                                || (bp.isInternal()\n+                                        && (!bp.isPrivileged() || CollectionUtils.contains(\n+                                                isPrivilegedPermissionAllowlisted, permName))\n+                                        && (CollectionUtils.contains(shouldGrantInternalPermission,\n+                                                permName)\n+                                                || (((bp.isPrivileged() && CollectionUtils.contains(\n+                                                        shouldGrantPrivilegedPermissionIfWasGranted,\n+                                                        permName)) || bp.isDevelopment()\n+                                                                || bp.isRole())\n+                                                        && origState.isPermissionGranted(\n+                                                                permName))))) {\n+                            // Grant an install permission.\n+                            if (uidState.grantPermission(bp)) {\n+                                changedInstallPermission = true;\n+                            }\n+                        } else {\n+                            if (DEBUG_PERMISSIONS) {\n+                                boolean wasGranted = uidState.isPermissionGranted(bp.getName());\n+                                if (wasGranted || bp.isAppOp()) {\n+                                    Slog.i(TAG, (wasGranted ? \"Un-granting\" : \"Not granting\")\n+                                            + \" permission \" + perm\n+                                            + \" from package \" + friendlyName\n+                                            + \" (protectionLevel=\" + bp.getProtectionLevel()\n+                                            + \" flags=0x\"\n+                                            + Integer.toHexString(PackageInfoUtils.appInfoFlags(pkg,\n+                                            ps))\n+                                            + \")\");\n+                                }\n+                            }\n+                            if (uidState.revokePermission(bp)) {\n+                                changedInstallPermission = true;\n+                            }\n                         }\n+                        PermissionState origPermState = origState.getPermissionState(perm);\n+                        int flags = origPermState != null ? origPermState.getFlags() : 0;\n+                        uidState.updatePermissionFlags(bp, MASK_PERMISSION_FLAGS_ALL, flags);\n                     } else if (bp.isRuntime()) {\n                         boolean hardRestricted = bp.isHardRestricted();\n                         boolean softRestricted = bp.isSoftRestricted();\n@@ -3018,22 +3044,8 @@ public class PermissionManagerService extends IPermissionManager.Stub {\n                         uidState.updatePermissionFlags(bp, MASK_PERMISSION_FLAGS_ALL,\n                                 flags);\n                     } else {\n-                        if (DEBUG_PERMISSIONS) {\n-                            boolean wasGranted = uidState.isPermissionGranted(bp.getName());\n-                            if (wasGranted || bp.isAppOp()) {\n-                                Slog.i(TAG, (wasGranted ? \"Un-granting\" : \"Not granting\")\n-                                        + \" permission \" + perm\n-                                        + \" from package \" + friendlyName\n-                                        + \" (protectionLevel=\" + bp.getProtectionLevel()\n-                                        + \" flags=0x\"\n-                                        + Integer.toHexString(PackageInfoUtils.appInfoFlags(pkg,\n-                                                ps))\n-                                        + \")\");\n-                            }\n-                        }\n-                        if (uidState.removePermissionState(bp.getName())) {\n-                            changedInstallPermission = true;\n-                        }\n+                        Slog.wtf(LOG_TAG, \"Unknown permission protection \" + bp.getProtection()\n+                                + \" for permission \" + bp.getName());\n                     }\n                 }\n \n",
    "added_lines": 50,
    "deleted_lines": 38,
    "changed_methods": "PermissionManagerService::restorePermissionState"
   }
  ]
 },
 {
  "hash": "147730e4612628fa05de5d9099bb802a2ca29591",
  "commit": "Check URIs in notification public version.\n\nBug: 276294099\nTest: atest NotificationManagerServiceTest NotificationVisitUrisTest\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:67cd169d073486c7c047b80ab83843cdee69bf53)\nMerged-In: I670198b213abb2cb29a9865eb9d1e897700508b4\nChange-Id: I670198b213abb2cb29a9865eb9d1e897700508b4",
  "files": [
   {
    "filename": "Notification.java",
    "diff": "@@ -2761,6 +2761,10 @@ public class Notification implements Parcelable\n      * @hide\n      */\n     public void visitUris(@NonNull Consumer<Uri> visitor) {\n+        if (publicVersion != null) {\n+            publicVersion.visitUris(visitor);\n+        }\n+\n         visitor.accept(sound);\n \n         if (tickerView != null) tickerView.visitUris(visitor);\n",
    "added_lines": 4,
    "deleted_lines": 0,
    "changed_methods": "Notification::visitUris"
   },
   {
    "filename": "NotificationManagerServiceTest.java",
    "diff": "@@ -4500,6 +4500,26 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n         verify(visitor, times(1)).accept(eq(historyUri2));\n     }\n \n+    @Test\n+    public void testVisitUris_publicVersion() throws Exception {\n+        final Icon smallIconPublic = Icon.createWithContentUri(\"content://media/small/icon\");\n+        final Icon largeIconPrivate = Icon.createWithContentUri(\"content://media/large/icon\");\n+\n+        Notification publicVersion = new Notification.Builder(mContext, \"a\")\n+                .setContentTitle(\"notification with uris\")\n+                .setSmallIcon(smallIconPublic)\n+                .build();\n+        Notification n = new Notification.Builder(mContext, \"a\")\n+                .setLargeIcon(largeIconPrivate)\n+                .setPublicVersion(publicVersion)\n+                .build();\n+\n+        Consumer<Uri> visitor = (Consumer<Uri>) spy(Consumer.class);\n+        n.visitUris(visitor);\n+        verify(visitor, times(1)).accept(eq(smallIconPublic.getUri()));\n+        verify(visitor, times(1)).accept(eq(largeIconPrivate.getUri()));\n+    }\n+\n     @Test\n     public void testVisitUris_audioContentsString() throws Exception {\n         final Uri audioContents = Uri.parse(\"content://com.example/audio\");\n",
    "added_lines": 20,
    "deleted_lines": 0,
    "changed_methods": "NotificationManagerServiceTest::testVisitUris_publicVersion"
   }
  ]
 },
 {
  "hash": "147730e4612628fa05de5d9099bb802a2ca29591",
  "commit": "Check URIs in notification public version.\n\nBug: 276294099\nTest: atest NotificationManagerServiceTest NotificationVisitUrisTest\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:67cd169d073486c7c047b80ab83843cdee69bf53)\nMerged-In: I670198b213abb2cb29a9865eb9d1e897700508b4\nChange-Id: I670198b213abb2cb29a9865eb9d1e897700508b4",
  "files": [
   {
    "filename": "Notification.java",
    "diff": "@@ -2761,6 +2761,10 @@ public class Notification implements Parcelable\n      * @hide\n      */\n     public void visitUris(@NonNull Consumer<Uri> visitor) {\n+        if (publicVersion != null) {\n+            publicVersion.visitUris(visitor);\n+        }\n+\n         visitor.accept(sound);\n \n         if (tickerView != null) tickerView.visitUris(visitor);\n",
    "added_lines": 4,
    "deleted_lines": 0,
    "changed_methods": "Notification::visitUris"
   },
   {
    "filename": "NotificationManagerServiceTest.java",
    "diff": "@@ -4500,6 +4500,26 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n         verify(visitor, times(1)).accept(eq(historyUri2));\n     }\n \n+    @Test\n+    public void testVisitUris_publicVersion() throws Exception {\n+        final Icon smallIconPublic = Icon.createWithContentUri(\"content://media/small/icon\");\n+        final Icon largeIconPrivate = Icon.createWithContentUri(\"content://media/large/icon\");\n+\n+        Notification publicVersion = new Notification.Builder(mContext, \"a\")\n+                .setContentTitle(\"notification with uris\")\n+                .setSmallIcon(smallIconPublic)\n+                .build();\n+        Notification n = new Notification.Builder(mContext, \"a\")\n+                .setLargeIcon(largeIconPrivate)\n+                .setPublicVersion(publicVersion)\n+                .build();\n+\n+        Consumer<Uri> visitor = (Consumer<Uri>) spy(Consumer.class);\n+        n.visitUris(visitor);\n+        verify(visitor, times(1)).accept(eq(smallIconPublic.getUri()));\n+        verify(visitor, times(1)).accept(eq(largeIconPrivate.getUri()));\n+    }\n+\n     @Test\n     public void testVisitUris_audioContentsString() throws Exception {\n         final Uri audioContents = Uri.parse(\"content://com.example/audio\");\n",
    "added_lines": 20,
    "deleted_lines": 0,
    "changed_methods": "NotificationManagerServiceTest::testVisitUris_publicVersion"
   }
  ]
 },
 {
  "hash": "2861dab20a619329f4c391cc0fac0d2ba24cd724",
  "commit": "Implement visitUris for RemoteViews ViewGroupActionAdd.\n\nThis is to prevent a vulnerability where notifications can show\nresources belonging to other users, since the URI in the nested views\nwas not being checked.\n\nBug: 277740082\nTest: atest RemoteViewsTest NotificationVisitUrisTest\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:850fd984e5f346645b5a941ed7307387c7e4c4de)\nMerged-In: I5c71f0bad0a6f6361eb5ceffe8d1e47e936d78f8\nChange-Id: I5c71f0bad0a6f6361eb5ceffe8d1e47e936d78f8",
  "files": [
   {
    "filename": "RemoteViews.java",
    "diff": "@@ -2560,6 +2560,11 @@ public class RemoteViews implements Parcelable, Filter {\n         public int getActionTag() {\n             return VIEW_GROUP_ACTION_ADD_TAG;\n         }\n+\n+        @Override\n+        public final void visitUris(@NonNull Consumer<Uri> visitor) {\n+            mNestedViews.visitUris(visitor);\n+        }\n     }\n \n     /**\n",
    "added_lines": 5,
    "deleted_lines": 0,
    "changed_methods": "RemoteViews::ViewGroupActionAdd::visitUris"
   },
   {
    "filename": "RemoteViewsTest.java",
    "diff": "@@ -528,6 +528,30 @@ public class RemoteViewsTest {\n         verify(visitor, times(1)).accept(eq(icon4.getUri()));\n     }\n \n+    @Test\n+    public void visitUris_nestedViews() {\n+        final RemoteViews outer = new RemoteViews(mPackage, R.layout.remote_views_test);\n+\n+        final RemoteViews inner = new RemoteViews(mPackage, 33);\n+        final Uri imageUriI = Uri.parse(\"content://inner/image\");\n+        final Icon icon1 = Icon.createWithContentUri(\"content://inner/icon1\");\n+        final Icon icon2 = Icon.createWithContentUri(\"content://inner/icon2\");\n+        final Icon icon3 = Icon.createWithContentUri(\"content://inner/icon3\");\n+        final Icon icon4 = Icon.createWithContentUri(\"content://inner/icon4\");\n+        inner.setImageViewUri(R.id.image, imageUriI);\n+        inner.setTextViewCompoundDrawables(R.id.text, icon1, icon2, icon3, icon4);\n+\n+        outer.addView(R.id.layout, inner);\n+\n+        Consumer<Uri> visitor = (Consumer<Uri>) spy(Consumer.class);\n+        outer.visitUris(visitor);\n+        verify(visitor, times(1)).accept(eq(imageUriI));\n+        verify(visitor, times(1)).accept(eq(icon1.getUri()));\n+        verify(visitor, times(1)).accept(eq(icon2.getUri()));\n+        verify(visitor, times(1)).accept(eq(icon3.getUri()));\n+        verify(visitor, times(1)).accept(eq(icon4.getUri()));\n+    }\n+\n     @Test\n     public void visitUris_separateOrientation() {\n         final RemoteViews landscape = new RemoteViews(mPackage, R.layout.remote_views_test);\n",
    "added_lines": 24,
    "deleted_lines": 0,
    "changed_methods": "RemoteViewsTest::visitUris_nestedViews"
   }
  ]
 },
 {
  "hash": "2861dab20a619329f4c391cc0fac0d2ba24cd724",
  "commit": "Implement visitUris for RemoteViews ViewGroupActionAdd.\n\nThis is to prevent a vulnerability where notifications can show\nresources belonging to other users, since the URI in the nested views\nwas not being checked.\n\nBug: 277740082\nTest: atest RemoteViewsTest NotificationVisitUrisTest\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:850fd984e5f346645b5a941ed7307387c7e4c4de)\nMerged-In: I5c71f0bad0a6f6361eb5ceffe8d1e47e936d78f8\nChange-Id: I5c71f0bad0a6f6361eb5ceffe8d1e47e936d78f8",
  "files": [
   {
    "filename": "RemoteViews.java",
    "diff": "@@ -2560,6 +2560,11 @@ public class RemoteViews implements Parcelable, Filter {\n         public int getActionTag() {\n             return VIEW_GROUP_ACTION_ADD_TAG;\n         }\n+\n+        @Override\n+        public final void visitUris(@NonNull Consumer<Uri> visitor) {\n+            mNestedViews.visitUris(visitor);\n+        }\n     }\n \n     /**\n",
    "added_lines": 5,
    "deleted_lines": 0,
    "changed_methods": "RemoteViews::ViewGroupActionAdd::visitUris"
   },
   {
    "filename": "RemoteViewsTest.java",
    "diff": "@@ -528,6 +528,30 @@ public class RemoteViewsTest {\n         verify(visitor, times(1)).accept(eq(icon4.getUri()));\n     }\n \n+    @Test\n+    public void visitUris_nestedViews() {\n+        final RemoteViews outer = new RemoteViews(mPackage, R.layout.remote_views_test);\n+\n+        final RemoteViews inner = new RemoteViews(mPackage, 33);\n+        final Uri imageUriI = Uri.parse(\"content://inner/image\");\n+        final Icon icon1 = Icon.createWithContentUri(\"content://inner/icon1\");\n+        final Icon icon2 = Icon.createWithContentUri(\"content://inner/icon2\");\n+        final Icon icon3 = Icon.createWithContentUri(\"content://inner/icon3\");\n+        final Icon icon4 = Icon.createWithContentUri(\"content://inner/icon4\");\n+        inner.setImageViewUri(R.id.image, imageUriI);\n+        inner.setTextViewCompoundDrawables(R.id.text, icon1, icon2, icon3, icon4);\n+\n+        outer.addView(R.id.layout, inner);\n+\n+        Consumer<Uri> visitor = (Consumer<Uri>) spy(Consumer.class);\n+        outer.visitUris(visitor);\n+        verify(visitor, times(1)).accept(eq(imageUriI));\n+        verify(visitor, times(1)).accept(eq(icon1.getUri()));\n+        verify(visitor, times(1)).accept(eq(icon2.getUri()));\n+        verify(visitor, times(1)).accept(eq(icon3.getUri()));\n+        verify(visitor, times(1)).accept(eq(icon4.getUri()));\n+    }\n+\n     @Test\n     public void visitUris_separateOrientation() {\n         final RemoteViews landscape = new RemoteViews(mPackage, R.layout.remote_views_test);\n",
    "added_lines": 24,
    "deleted_lines": 0,
    "changed_methods": "RemoteViewsTest::visitUris_nestedViews"
   }
  ]
 },
 {
  "hash": "b48846957a0a716c7d5696ba389f728b2e874f11",
  "commit": "Validate ComponentName for MediaButtonBroadcastReceiver\n\nThis is a security fix for b/270049379.\n\nBug: 270049379\nTest: atest CtsMediaMiscTestCases\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:c573c83a2aa36ca022302f675d705518dd723a3c)\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:ba546a306217389a8ff9e5e948612651fd496081)\nMerged-In: I05626f7abf1efef86c9e01ee3f077d7177d7f662\nChange-Id: I05626f7abf1efef86c9e01ee3f077d7177d7f662",
  "files": [
   {
    "filename": "MediaSession.java",
    "diff": "@@ -297,9 +297,11 @@ public final class MediaSession {\n      * class that should receive media buttons. This allows restarting playback after the session\n      * has been stopped. If your app is started in this way an {@link Intent#ACTION_MEDIA_BUTTON}\n      * intent will be sent to the broadcast receiver.\n-     * <p>\n-     * Note: The given {@link android.content.BroadcastReceiver} should belong to the same package\n-     * as the context that was given when creating {@link MediaSession}.\n+     *\n+     * <p>Note: The given {@link android.content.BroadcastReceiver} should belong to the same\n+     * package as the context that was given when creating {@link MediaSession}.\n+     *\n+     * <p>Calls with invalid or non-existent receivers will be ignored.\n      *\n      * @param broadcastReceiver the component name of the BroadcastReceiver class\n      */\n",
    "added_lines": 5,
    "deleted_lines": 3,
    "changed_methods": ""
   },
   {
    "filename": "MediaSessionRecord.java",
    "diff": "@@ -16,12 +16,17 @@\n \n package com.android.server.media;\n \n+import android.Manifest;\n+import android.annotation.NonNull;\n import android.annotation.Nullable;\n+import android.annotation.RequiresPermission;\n import android.app.PendingIntent;\n import android.content.ComponentName;\n import android.content.Context;\n import android.content.Intent;\n+import android.content.pm.PackageManager;\n import android.content.pm.ParceledListSlice;\n+import android.content.pm.ResolveInfo;\n import android.media.AudioAttributes;\n import android.media.AudioManager;\n import android.media.AudioSystem;\n@@ -52,6 +57,7 @@ import android.os.Process;\n import android.os.RemoteException;\n import android.os.ResultReceiver;\n import android.os.SystemClock;\n+import android.os.UserHandle;\n import android.text.TextUtils;\n import android.util.EventLog;\n import android.util.Log;\n@@ -879,6 +885,22 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR\n         }\n     };\n \n+    @RequiresPermission(Manifest.permission.INTERACT_ACROSS_USERS)\n+    private static boolean componentNameExists(\n+            @NonNull ComponentName componentName, @NonNull Context context, int userId) {\n+        Intent mediaButtonIntent = new Intent(Intent.ACTION_MEDIA_BUTTON);\n+        mediaButtonIntent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);\n+        mediaButtonIntent.setComponent(componentName);\n+\n+        UserHandle userHandle = UserHandle.of(userId);\n+        PackageManager pm = context.getPackageManager();\n+\n+        List<ResolveInfo> resolveInfos =\n+                pm.queryBroadcastReceiversAsUser(\n+                        mediaButtonIntent, /* flags */ 0, userHandle);\n+        return !resolveInfos.isEmpty();\n+    }\n+\n     private final class SessionStub extends ISession.Stub {\n         @Override\n         public void destroySession() throws RemoteException {\n@@ -949,6 +971,7 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR\n         }\n \n         @Override\n+        @RequiresPermission(Manifest.permission.INTERACT_ACROSS_USERS)\n         public void setMediaButtonBroadcastReceiver(ComponentName receiver) throws RemoteException {\n             final long token = Binder.clearCallingIdentity();\n             try {\n@@ -964,6 +987,16 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR\n                         != 0) {\n                     return;\n                 }\n+\n+                if (!componentNameExists(receiver, mContext, mUserId)) {\n+                    Log.w(\n+                            TAG,\n+                            \"setMediaButtonBroadcastReceiver(): \"\n+                                    + \"Ignoring invalid component name=\"\n+                                    + receiver);\n+                    return;\n+                }\n+\n                 mMediaButtonReceiverHolder = MediaButtonReceiverHolder.create(mUserId, receiver);\n                 mService.onMediaButtonReceiverChanged(MediaSessionRecord.this);\n             } finally {\n",
    "added_lines": 33,
    "deleted_lines": 0,
    "changed_methods": "MediaSessionRecord::SessionStub::setMediaButtonBroadcastReceiver, MediaSessionRecord::componentNameExists"
   }
  ]
 },
 {
  "hash": "b48846957a0a716c7d5696ba389f728b2e874f11",
  "commit": "Validate ComponentName for MediaButtonBroadcastReceiver\n\nThis is a security fix for b/270049379.\n\nBug: 270049379\nTest: atest CtsMediaMiscTestCases\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:c573c83a2aa36ca022302f675d705518dd723a3c)\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:ba546a306217389a8ff9e5e948612651fd496081)\nMerged-In: I05626f7abf1efef86c9e01ee3f077d7177d7f662\nChange-Id: I05626f7abf1efef86c9e01ee3f077d7177d7f662",
  "files": [
   {
    "filename": "MediaSession.java",
    "diff": "@@ -297,9 +297,11 @@ public final class MediaSession {\n      * class that should receive media buttons. This allows restarting playback after the session\n      * has been stopped. If your app is started in this way an {@link Intent#ACTION_MEDIA_BUTTON}\n      * intent will be sent to the broadcast receiver.\n-     * <p>\n-     * Note: The given {@link android.content.BroadcastReceiver} should belong to the same package\n-     * as the context that was given when creating {@link MediaSession}.\n+     *\n+     * <p>Note: The given {@link android.content.BroadcastReceiver} should belong to the same\n+     * package as the context that was given when creating {@link MediaSession}.\n+     *\n+     * <p>Calls with invalid or non-existent receivers will be ignored.\n      *\n      * @param broadcastReceiver the component name of the BroadcastReceiver class\n      */\n",
    "added_lines": 5,
    "deleted_lines": 3,
    "changed_methods": ""
   },
   {
    "filename": "MediaSessionRecord.java",
    "diff": "@@ -16,12 +16,17 @@\n \n package com.android.server.media;\n \n+import android.Manifest;\n+import android.annotation.NonNull;\n import android.annotation.Nullable;\n+import android.annotation.RequiresPermission;\n import android.app.PendingIntent;\n import android.content.ComponentName;\n import android.content.Context;\n import android.content.Intent;\n+import android.content.pm.PackageManager;\n import android.content.pm.ParceledListSlice;\n+import android.content.pm.ResolveInfo;\n import android.media.AudioAttributes;\n import android.media.AudioManager;\n import android.media.AudioSystem;\n@@ -52,6 +57,7 @@ import android.os.Process;\n import android.os.RemoteException;\n import android.os.ResultReceiver;\n import android.os.SystemClock;\n+import android.os.UserHandle;\n import android.text.TextUtils;\n import android.util.EventLog;\n import android.util.Log;\n@@ -879,6 +885,22 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR\n         }\n     };\n \n+    @RequiresPermission(Manifest.permission.INTERACT_ACROSS_USERS)\n+    private static boolean componentNameExists(\n+            @NonNull ComponentName componentName, @NonNull Context context, int userId) {\n+        Intent mediaButtonIntent = new Intent(Intent.ACTION_MEDIA_BUTTON);\n+        mediaButtonIntent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);\n+        mediaButtonIntent.setComponent(componentName);\n+\n+        UserHandle userHandle = UserHandle.of(userId);\n+        PackageManager pm = context.getPackageManager();\n+\n+        List<ResolveInfo> resolveInfos =\n+                pm.queryBroadcastReceiversAsUser(\n+                        mediaButtonIntent, /* flags */ 0, userHandle);\n+        return !resolveInfos.isEmpty();\n+    }\n+\n     private final class SessionStub extends ISession.Stub {\n         @Override\n         public void destroySession() throws RemoteException {\n@@ -949,6 +971,7 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR\n         }\n \n         @Override\n+        @RequiresPermission(Manifest.permission.INTERACT_ACROSS_USERS)\n         public void setMediaButtonBroadcastReceiver(ComponentName receiver) throws RemoteException {\n             final long token = Binder.clearCallingIdentity();\n             try {\n@@ -964,6 +987,16 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR\n                         != 0) {\n                     return;\n                 }\n+\n+                if (!componentNameExists(receiver, mContext, mUserId)) {\n+                    Log.w(\n+                            TAG,\n+                            \"setMediaButtonBroadcastReceiver(): \"\n+                                    + \"Ignoring invalid component name=\"\n+                                    + receiver);\n+                    return;\n+                }\n+\n                 mMediaButtonReceiverHolder = MediaButtonReceiverHolder.create(mUserId, receiver);\n                 mService.onMediaButtonReceiverChanged(MediaSessionRecord.this);\n             } finally {\n",
    "added_lines": 33,
    "deleted_lines": 0,
    "changed_methods": "MediaSessionRecord::SessionStub::setMediaButtonBroadcastReceiver, MediaSessionRecord::componentNameExists"
   }
  ]
 },
 {
  "hash": "26c9cf7140ef6b8782a0b08fa331fbefe7ce6858",
  "commit": "Check URIs in sized remote views.\n\nBug: 277741109\nTest: atest RemoteViewsTest\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:ae0d45137b0f8ea49a085bbce4d39f901685c4a5)\nMerged-In: Iceb33606da3a49b9638ab21aeae17a168c1b411a\nChange-Id: Iceb33606da3a49b9638ab21aeae17a168c1b411a",
  "files": [
   {
    "filename": "RemoteViews.java",
    "diff": "@@ -709,6 +709,11 @@ public class RemoteViews implements Parcelable, Filter {\n                 mActions.get(i).visitUris(visitor);\n             }\n         }\n+        if (mSizedRemoteViews != null) {\n+            for (int i = 0; i < mSizedRemoteViews.size(); i++) {\n+                mSizedRemoteViews.get(i).visitUris(visitor);\n+            }\n+        }\n         if (mLandscape != null) {\n             mLandscape.visitUris(visitor);\n         }\n",
    "added_lines": 5,
    "deleted_lines": 0,
    "changed_methods": "RemoteViews::visitUris"
   },
   {
    "filename": "RemoteViewsTest.java",
    "diff": "@@ -38,6 +38,7 @@ import android.net.Uri;\n import android.os.AsyncTask;\n import android.os.Binder;\n import android.os.Parcel;\n+import android.util.SizeF;\n import android.view.View;\n import android.view.ViewGroup;\n \n@@ -55,6 +56,7 @@ import org.junit.runner.RunWith;\n \n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.HashMap;\n import java.util.concurrent.CountDownLatch;\n import java.util.function.Consumer;\n \n@@ -587,4 +589,43 @@ public class RemoteViewsTest {\n         verify(visitor, times(1)).accept(eq(icon3P.getUri()));\n         verify(visitor, times(1)).accept(eq(icon4P.getUri()));\n     }\n+\n+    @Test\n+    public void visitUris_sizedViews() {\n+        final RemoteViews large = new RemoteViews(mPackage, R.layout.remote_views_test);\n+        final Uri imageUriL = Uri.parse(\"content://large/image\");\n+        final Icon icon1L = Icon.createWithContentUri(\"content://large/icon1\");\n+        final Icon icon2L = Icon.createWithContentUri(\"content://large/icon2\");\n+        final Icon icon3L = Icon.createWithContentUri(\"content://large/icon3\");\n+        final Icon icon4L = Icon.createWithContentUri(\"content://large/icon4\");\n+        large.setImageViewUri(R.id.image, imageUriL);\n+        large.setTextViewCompoundDrawables(R.id.text, icon1L, icon2L, icon3L, icon4L);\n+\n+        final RemoteViews small = new RemoteViews(mPackage, 33);\n+        final Uri imageUriS = Uri.parse(\"content://small/image\");\n+        final Icon icon1S = Icon.createWithContentUri(\"content://small/icon1\");\n+        final Icon icon2S = Icon.createWithContentUri(\"content://small/icon2\");\n+        final Icon icon3S = Icon.createWithContentUri(\"content://small/icon3\");\n+        final Icon icon4S = Icon.createWithContentUri(\"content://small/icon4\");\n+        small.setImageViewUri(R.id.image, imageUriS);\n+        small.setTextViewCompoundDrawables(R.id.text, icon1S, icon2S, icon3S, icon4S);\n+\n+        HashMap<SizeF, RemoteViews> sizedViews = new HashMap<>();\n+        sizedViews.put(new SizeF(300, 300), large);\n+        sizedViews.put(new SizeF(100, 100), small);\n+        RemoteViews views = new RemoteViews(sizedViews);\n+\n+        Consumer<Uri> visitor = (Consumer<Uri>) spy(Consumer.class);\n+        views.visitUris(visitor);\n+        verify(visitor, times(1)).accept(eq(imageUriL));\n+        verify(visitor, times(1)).accept(eq(icon1L.getUri()));\n+        verify(visitor, times(1)).accept(eq(icon2L.getUri()));\n+        verify(visitor, times(1)).accept(eq(icon3L.getUri()));\n+        verify(visitor, times(1)).accept(eq(icon4L.getUri()));\n+        verify(visitor, times(1)).accept(eq(imageUriS));\n+        verify(visitor, times(1)).accept(eq(icon1S.getUri()));\n+        verify(visitor, times(1)).accept(eq(icon2S.getUri()));\n+        verify(visitor, times(1)).accept(eq(icon3S.getUri()));\n+        verify(visitor, times(1)).accept(eq(icon4S.getUri()));\n+    }\n }\n",
    "added_lines": 41,
    "deleted_lines": 0,
    "changed_methods": "RemoteViewsTest::visitUris_sizedViews"
   }
  ]
 },
 {
  "hash": "26c9cf7140ef6b8782a0b08fa331fbefe7ce6858",
  "commit": "Check URIs in sized remote views.\n\nBug: 277741109\nTest: atest RemoteViewsTest\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:ae0d45137b0f8ea49a085bbce4d39f901685c4a5)\nMerged-In: Iceb33606da3a49b9638ab21aeae17a168c1b411a\nChange-Id: Iceb33606da3a49b9638ab21aeae17a168c1b411a",
  "files": [
   {
    "filename": "RemoteViews.java",
    "diff": "@@ -709,6 +709,11 @@ public class RemoteViews implements Parcelable, Filter {\n                 mActions.get(i).visitUris(visitor);\n             }\n         }\n+        if (mSizedRemoteViews != null) {\n+            for (int i = 0; i < mSizedRemoteViews.size(); i++) {\n+                mSizedRemoteViews.get(i).visitUris(visitor);\n+            }\n+        }\n         if (mLandscape != null) {\n             mLandscape.visitUris(visitor);\n         }\n",
    "added_lines": 5,
    "deleted_lines": 0,
    "changed_methods": "RemoteViews::visitUris"
   },
   {
    "filename": "RemoteViewsTest.java",
    "diff": "@@ -38,6 +38,7 @@ import android.net.Uri;\n import android.os.AsyncTask;\n import android.os.Binder;\n import android.os.Parcel;\n+import android.util.SizeF;\n import android.view.View;\n import android.view.ViewGroup;\n \n@@ -55,6 +56,7 @@ import org.junit.runner.RunWith;\n \n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.HashMap;\n import java.util.concurrent.CountDownLatch;\n import java.util.function.Consumer;\n \n@@ -587,4 +589,43 @@ public class RemoteViewsTest {\n         verify(visitor, times(1)).accept(eq(icon3P.getUri()));\n         verify(visitor, times(1)).accept(eq(icon4P.getUri()));\n     }\n+\n+    @Test\n+    public void visitUris_sizedViews() {\n+        final RemoteViews large = new RemoteViews(mPackage, R.layout.remote_views_test);\n+        final Uri imageUriL = Uri.parse(\"content://large/image\");\n+        final Icon icon1L = Icon.createWithContentUri(\"content://large/icon1\");\n+        final Icon icon2L = Icon.createWithContentUri(\"content://large/icon2\");\n+        final Icon icon3L = Icon.createWithContentUri(\"content://large/icon3\");\n+        final Icon icon4L = Icon.createWithContentUri(\"content://large/icon4\");\n+        large.setImageViewUri(R.id.image, imageUriL);\n+        large.setTextViewCompoundDrawables(R.id.text, icon1L, icon2L, icon3L, icon4L);\n+\n+        final RemoteViews small = new RemoteViews(mPackage, 33);\n+        final Uri imageUriS = Uri.parse(\"content://small/image\");\n+        final Icon icon1S = Icon.createWithContentUri(\"content://small/icon1\");\n+        final Icon icon2S = Icon.createWithContentUri(\"content://small/icon2\");\n+        final Icon icon3S = Icon.createWithContentUri(\"content://small/icon3\");\n+        final Icon icon4S = Icon.createWithContentUri(\"content://small/icon4\");\n+        small.setImageViewUri(R.id.image, imageUriS);\n+        small.setTextViewCompoundDrawables(R.id.text, icon1S, icon2S, icon3S, icon4S);\n+\n+        HashMap<SizeF, RemoteViews> sizedViews = new HashMap<>();\n+        sizedViews.put(new SizeF(300, 300), large);\n+        sizedViews.put(new SizeF(100, 100), small);\n+        RemoteViews views = new RemoteViews(sizedViews);\n+\n+        Consumer<Uri> visitor = (Consumer<Uri>) spy(Consumer.class);\n+        views.visitUris(visitor);\n+        verify(visitor, times(1)).accept(eq(imageUriL));\n+        verify(visitor, times(1)).accept(eq(icon1L.getUri()));\n+        verify(visitor, times(1)).accept(eq(icon2L.getUri()));\n+        verify(visitor, times(1)).accept(eq(icon3L.getUri()));\n+        verify(visitor, times(1)).accept(eq(icon4L.getUri()));\n+        verify(visitor, times(1)).accept(eq(imageUriS));\n+        verify(visitor, times(1)).accept(eq(icon1S.getUri()));\n+        verify(visitor, times(1)).accept(eq(icon2S.getUri()));\n+        verify(visitor, times(1)).accept(eq(icon3S.getUri()));\n+        verify(visitor, times(1)).accept(eq(icon4S.getUri()));\n+    }\n }\n",
    "added_lines": 41,
    "deleted_lines": 0,
    "changed_methods": "RemoteViewsTest::visitUris_sizedViews"
   }
  ]
 },
 {
  "hash": "2559e77cbb043c06e358444f526281cb9434b2d6",
  "commit": "Visit URIs in themed remoteviews icons.\n\nBug: 281018094\nTest: atest RemoteViewsTest NotificationVisitUrisTest\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:634a69b7700017eac534f3f58cdcc2572f3cc659)\nMerged-In: I2014bf21cf90267f7f1b3f370bf00ab7001b064e\nChange-Id: I2014bf21cf90267f7f1b3f370bf00ab7001b064e",
  "files": [
   {
    "filename": "RemoteViews.java",
    "diff": "@@ -1808,7 +1808,7 @@ public class RemoteViews implements Parcelable, Filter {\n         }\n \n         @Override\n-        public final void visitUris(@NonNull Consumer<Uri> visitor) {\n+        public void visitUris(@NonNull Consumer<Uri> visitor) {\n             switch (this.type) {\n                 case URI:\n                     final Uri uri = (Uri) getParameterValue(null);\n@@ -2271,6 +2271,14 @@ public class RemoteViews implements Parcelable, Filter {\n         public int getActionTag() {\n             return NIGHT_MODE_REFLECTION_ACTION_TAG;\n         }\n+\n+        @Override\n+        public void visitUris(@NonNull Consumer<Uri> visitor) {\n+            if (this.type == ICON) {\n+                visitIconUri((Icon) mDarkValue, visitor);\n+                visitIconUri((Icon) mLightValue, visitor);\n+            }\n+        }\n     }\n \n     /**\n",
    "added_lines": 9,
    "deleted_lines": 1,
    "changed_methods": "RemoteViews::BaseReflectionAction::visitUris, RemoteViews::NightModeReflectionAction::visitUris"
   },
   {
    "filename": "RemoteViewsTest.java",
    "diff": "@@ -530,6 +530,19 @@ public class RemoteViewsTest {\n         verify(visitor, times(1)).accept(eq(icon4.getUri()));\n     }\n \n+    @Test\n+    public void visitUris_themedIcons() {\n+        RemoteViews views = new RemoteViews(mPackage, R.layout.remote_views_test);\n+        final Icon iconLight = Icon.createWithContentUri(\"content://light/icon\");\n+        final Icon iconDark = Icon.createWithContentUri(\"content://dark/icon\");\n+        views.setIcon(R.id.layout, \"setLargeIcon\", iconLight, iconDark);\n+\n+        Consumer<Uri> visitor = (Consumer<Uri>) spy(Consumer.class);\n+        views.visitUris(visitor);\n+        verify(visitor, times(1)).accept(eq(iconLight.getUri()));\n+        verify(visitor, times(1)).accept(eq(iconDark.getUri()));\n+    }\n+\n     @Test\n     public void visitUris_nestedViews() {\n         final RemoteViews outer = new RemoteViews(mPackage, R.layout.remote_views_test);\n",
    "added_lines": 13,
    "deleted_lines": 0,
    "changed_methods": "RemoteViewsTest::visitUris_themedIcons"
   }
  ]
 },
 {
  "hash": "2559e77cbb043c06e358444f526281cb9434b2d6",
  "commit": "Visit URIs in themed remoteviews icons.\n\nBug: 281018094\nTest: atest RemoteViewsTest NotificationVisitUrisTest\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:634a69b7700017eac534f3f58cdcc2572f3cc659)\nMerged-In: I2014bf21cf90267f7f1b3f370bf00ab7001b064e\nChange-Id: I2014bf21cf90267f7f1b3f370bf00ab7001b064e",
  "files": [
   {
    "filename": "RemoteViews.java",
    "diff": "@@ -1808,7 +1808,7 @@ public class RemoteViews implements Parcelable, Filter {\n         }\n \n         @Override\n-        public final void visitUris(@NonNull Consumer<Uri> visitor) {\n+        public void visitUris(@NonNull Consumer<Uri> visitor) {\n             switch (this.type) {\n                 case URI:\n                     final Uri uri = (Uri) getParameterValue(null);\n@@ -2271,6 +2271,14 @@ public class RemoteViews implements Parcelable, Filter {\n         public int getActionTag() {\n             return NIGHT_MODE_REFLECTION_ACTION_TAG;\n         }\n+\n+        @Override\n+        public void visitUris(@NonNull Consumer<Uri> visitor) {\n+            if (this.type == ICON) {\n+                visitIconUri((Icon) mDarkValue, visitor);\n+                visitIconUri((Icon) mLightValue, visitor);\n+            }\n+        }\n     }\n \n     /**\n",
    "added_lines": 9,
    "deleted_lines": 1,
    "changed_methods": "RemoteViews::BaseReflectionAction::visitUris, RemoteViews::NightModeReflectionAction::visitUris"
   },
   {
    "filename": "RemoteViewsTest.java",
    "diff": "@@ -530,6 +530,19 @@ public class RemoteViewsTest {\n         verify(visitor, times(1)).accept(eq(icon4.getUri()));\n     }\n \n+    @Test\n+    public void visitUris_themedIcons() {\n+        RemoteViews views = new RemoteViews(mPackage, R.layout.remote_views_test);\n+        final Icon iconLight = Icon.createWithContentUri(\"content://light/icon\");\n+        final Icon iconDark = Icon.createWithContentUri(\"content://dark/icon\");\n+        views.setIcon(R.id.layout, \"setLargeIcon\", iconLight, iconDark);\n+\n+        Consumer<Uri> visitor = (Consumer<Uri>) spy(Consumer.class);\n+        views.visitUris(visitor);\n+        verify(visitor, times(1)).accept(eq(iconLight.getUri()));\n+        verify(visitor, times(1)).accept(eq(iconDark.getUri()));\n+    }\n+\n     @Test\n     public void visitUris_nestedViews() {\n         final RemoteViews outer = new RemoteViews(mPackage, R.layout.remote_views_test);\n",
    "added_lines": 13,
    "deleted_lines": 0,
    "changed_methods": "RemoteViewsTest::visitUris_themedIcons"
   }
  ]
 },
 {
  "hash": "eee49f9cb80a37b3c2f70375cd1de64e32e2f86f",
  "commit": "Merge \"Use Settings.System.getIntForUser instead of getInt to make sure user specific settings are used\" into rvc-dev am: d198f5165c am: 886d492c8c\n\nOriginal change: https://googleplex-android-review.googlesource.com/c/platform/frameworks/base/+/23475765\n\nSigned-off-by: Automerger Merge Worker <android-build-automerger-merge-worker@system.gserviceaccount.com>\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:f37a92b8c8c98ca40f858782fe3720362565c16c)\nMerged-In: Idda8cdb4c853b6046ba19d35eeea2a1a6ee73541\nChange-Id: Idda8cdb4c853b6046ba19d35eeea2a1a6ee73541",
  "files": [
   {
    "filename": "KeyguardViewMediator.java",
    "diff": "@@ -1145,9 +1145,9 @@ public class KeyguardViewMediator extends SystemUI implements Dumpable,\n         final ContentResolver cr = mContext.getContentResolver();\n \n         // From SecuritySettings\n-        final long lockAfterTimeout = Settings.Secure.getInt(cr,\n+        final long lockAfterTimeout = Settings.Secure.getIntForUser(cr,\n                 Settings.Secure.LOCK_SCREEN_LOCK_AFTER_TIMEOUT,\n-                KEYGUARD_LOCK_AFTER_DELAY_DEFAULT);\n+                KEYGUARD_LOCK_AFTER_DELAY_DEFAULT, userId);\n \n         // From DevicePolicyAdmin\n         final long policyTimeout = mLockPatternUtils.getDevicePolicyManager()\n@@ -1159,8 +1159,8 @@ public class KeyguardViewMediator extends SystemUI implements Dumpable,\n             timeout = lockAfterTimeout;\n         } else {\n             // From DisplaySettings\n-            long displayTimeout = Settings.System.getInt(cr, SCREEN_OFF_TIMEOUT,\n-                    KEYGUARD_DISPLAY_TIMEOUT_DELAY_DEFAULT);\n+            long displayTimeout = Settings.System.getIntForUser(cr, SCREEN_OFF_TIMEOUT,\n+                    KEYGUARD_DISPLAY_TIMEOUT_DELAY_DEFAULT, userId);\n \n             // policy in effect. Make sure we don't go beyond policy limit.\n             displayTimeout = Math.max(displayTimeout, 0); // ignore negative values\n@@ -2033,7 +2033,10 @@ public class KeyguardViewMediator extends SystemUI implements Dumpable,\n     private void playSound(int soundId) {\n         if (soundId == 0) return;\n         final ContentResolver cr = mContext.getContentResolver();\n-        if (Settings.System.getInt(cr, Settings.System.LOCKSCREEN_SOUNDS_ENABLED, 1) == 1) {\n+        int lockscreenSoundsEnabled = Settings.System.getIntForUser(cr,\n+                Settings.System.LOCKSCREEN_SOUNDS_ENABLED, 1,\n+                KeyguardUpdateMonitor.getCurrentUser());\n+        if (lockscreenSoundsEnabled == 1) {\n \n             mLockSounds.stop(mLockSoundStreamId);\n             // Init mAudioManager\n",
    "added_lines": 8,
    "deleted_lines": 5,
    "changed_methods": "KeyguardViewMediator::getLockTimeout, KeyguardViewMediator::playSound"
   }
  ]
 },
 {
  "hash": "0e3a03142bcdade071c3997b1cb7be93678c1b42",
  "commit": "Verify URI permissions in MediaMetadata\n\nAdd a check for URI permission to make sure that user can access the URI\nset in MediaMetadata. If permission is denied, clear the URI string set\nin metadata.\n\nBug: 271851153\nTest: atest MediaSessionTest\nTest: Verified by POC app attached in bug, image of second user is not\nthe UMO background of the first user.\n\n(cherry picked from commit b8a7fd8e6f41ee54d27c1e7aaa15b4a3f5365a02)\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:91705f7cc95a87a5cc7814f543669adcd3b35f09)\nMerged-In: I384f8e230c909d8fc8e5f147e2fd3558fec44626\nChange-Id: I384f8e230c909d8fc8e5f147e2fd3558fec44626",
  "files": [
   {
    "filename": "MediaSessionRecord.java",
    "diff": "@@ -22,6 +22,8 @@ import android.annotation.Nullable;\n import android.annotation.RequiresPermission;\n import android.app.PendingIntent;\n import android.content.ComponentName;\n+import android.content.ContentProvider;\n+import android.content.ContentResolver;\n import android.content.Context;\n import android.content.Intent;\n import android.content.pm.PackageManager;\n@@ -63,6 +65,9 @@ import android.util.EventLog;\n import android.util.Log;\n import android.view.KeyEvent;\n \n+import com.android.server.LocalServices;\n+import com.android.server.uri.UriGrantsManagerInternal;\n+\n import java.io.PrintWriter;\n import java.util.ArrayList;\n import java.util.Arrays;\n@@ -77,6 +82,10 @@ import java.util.concurrent.CopyOnWriteArrayList;\n // TODO(jaewan): Do not call service method directly -- introduce listener instead.\n public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionRecordImpl {\n     private static final String TAG = \"MediaSessionRecord\";\n+    private static final String[] ART_URIS = new String[] {\n+            MediaMetadata.METADATA_KEY_ALBUM_ART_URI,\n+            MediaMetadata.METADATA_KEY_ART_URI,\n+            MediaMetadata.METADATA_KEY_DISPLAY_ICON_URI};\n     private static final boolean DEBUG = Log.isLoggable(TAG, Log.DEBUG);\n \n     /**\n@@ -130,6 +139,7 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR\n     private final SessionStub mSession;\n     private final SessionCb mSessionCb;\n     private final MediaSessionService mService;\n+    private final UriGrantsManagerInternal mUgmInternal;\n     private final Context mContext;\n     private final boolean mVolumeAdjustmentForRemoteGroupSessions;\n \n@@ -193,6 +203,7 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR\n         mPolicies = policies;\n         mVolumeAdjustmentForRemoteGroupSessions = mContext.getResources().getBoolean(\n                 com.android.internal.R.bool.config_volumeAdjustmentForRemoteGroupSessions);\n+        mUgmInternal = LocalServices.getService(UriGrantsManagerInternal.class);\n \n         // May throw RemoteException if the session app is killed.\n         mSessionCb.mCb.asBinder().linkToDeath(this, 0);\n@@ -1013,21 +1024,45 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR\n         public void setMetadata(MediaMetadata metadata, long duration, String metadataDescription)\n                 throws RemoteException {\n             synchronized (mLock) {\n-                MediaMetadata temp = metadata == null ? null : new MediaMetadata.Builder(metadata)\n-                        .build();\n-                // This is to guarantee that the underlying bundle is unparceled\n-                // before we set it to prevent concurrent reads from throwing an\n-                // exception\n-                if (temp != null) {\n-                    temp.size();\n-                }\n-                mMetadata = temp;\n                 mDuration = duration;\n                 mMetadataDescription = metadataDescription;\n+                mMetadata = sanitizeMediaMetadata(metadata);\n             }\n             mHandler.post(MessageHandler.MSG_UPDATE_METADATA);\n         }\n \n+        private MediaMetadata sanitizeMediaMetadata(MediaMetadata metadata) {\n+            if (metadata == null) {\n+                return null;\n+            }\n+            MediaMetadata.Builder metadataBuilder = new MediaMetadata.Builder(metadata);\n+            for (String key: ART_URIS) {\n+                String uriString = metadata.getString(key);\n+                if (TextUtils.isEmpty(uriString)) {\n+                    continue;\n+                }\n+                Uri uri = Uri.parse(uriString);\n+                if (!ContentResolver.SCHEME_CONTENT.equals(uri.getScheme())) {\n+                    continue;\n+                }\n+                try {\n+                    mUgmInternal.checkGrantUriPermission(getUid(),\n+                            getPackageName(),\n+                            ContentProvider.getUriWithoutUserId(uri),\n+                            Intent.FLAG_GRANT_READ_URI_PERMISSION,\n+                            ContentProvider.getUserIdFromUri(uri, getUserId()));\n+                } catch (SecurityException e) {\n+                    metadataBuilder.putString(key, null);\n+                }\n+            }\n+            MediaMetadata sanitizedMetadata = metadataBuilder.build();\n+            // sanitizedMetadata.size() guarantees that the underlying bundle is unparceled\n+            // before we set it to prevent concurrent reads from throwing an\n+            // exception\n+            sanitizedMetadata.size();\n+            return sanitizedMetadata;\n+        }\n+\n         @Override\n         public void setPlaybackState(PlaybackState state) throws RemoteException {\n             int oldState = mPlaybackState == null\n",
    "added_lines": 44,
    "deleted_lines": 9,
    "changed_methods": "MediaSessionRecord::SessionStub::sanitizeMediaMetadata, MediaSessionRecord::MediaSessionRecord, MediaSessionRecord::SessionStub::setMetadata"
   }
  ]
 },
 {
  "hash": "0101ae8a47ff484d43af3dde506d19cde4590f65",
  "commit": "Merge \"Resolve StatusHints image exploit across user.\" into rvc-dev am: 543e6febbf am: 8c3d465b5e\n\nOriginal change: https://googleplex-android-review.googlesource.com/c/platform/frameworks/base/+/23438530\n\nFixes: 285650146\nFixes: 280797684\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:06456af560729b8a8d209613bb117ede3496fd9d)\nMerged-In: I7822bf2bb75c775faaaa7023fd2c9af9f6d6888f\nChange-Id: I7822bf2bb75c775faaaa7023fd2c9af9f6d6888f",
  "files": [
   {
    "filename": "ParcelableConference.java",
    "diff": "@@ -21,12 +21,12 @@ import android.os.Bundle;\n import android.os.Parcel;\n import android.os.Parcelable;\n \n+import com.android.internal.telecom.IVideoProvider;\n+\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.List;\n \n-import com.android.internal.telecom.IVideoProvider;\n-\n /**\n  * A parcelable representation of a conference connection.\n  * @hide\n@@ -287,6 +287,14 @@ public final class ParcelableConference implements Parcelable {\n         return mCallDirection;\n     }\n \n+    public String getCallerDisplayName() {\n+        return mCallerDisplayName;\n+    }\n+\n+    public int getCallerDisplayNamePresentation() {\n+        return mCallerDisplayNamePresentation;\n+    }\n+\n     public static final @android.annotation.NonNull Parcelable.Creator<ParcelableConference> CREATOR =\n             new Parcelable.Creator<ParcelableConference> () {\n         @Override\n",
    "added_lines": 10,
    "deleted_lines": 2,
    "changed_methods": "ParcelableConference::getCallerDisplayName, ParcelableConference::getCallerDisplayNamePresentation"
   },
   {
    "filename": "StatusHints.java",
    "diff": "@@ -16,14 +16,19 @@\n \n package android.telecom;\n \n+import android.annotation.Nullable;\n import android.annotation.SystemApi;\n import android.content.ComponentName;\n import android.content.Context;\n import android.graphics.drawable.Drawable;\n import android.graphics.drawable.Icon;\n+import android.os.Binder;\n import android.os.Bundle;\n import android.os.Parcel;\n import android.os.Parcelable;\n+import android.os.UserHandle;\n+\n+import com.android.internal.annotations.VisibleForTesting;\n \n import java.util.Objects;\n \n@@ -33,7 +38,7 @@ import java.util.Objects;\n public final class StatusHints implements Parcelable {\n \n     private final CharSequence mLabel;\n-    private final Icon mIcon;\n+    private Icon mIcon;\n     private final Bundle mExtras;\n \n     /**\n@@ -48,10 +53,30 @@ public final class StatusHints implements Parcelable {\n \n     public StatusHints(CharSequence label, Icon icon, Bundle extras) {\n         mLabel = label;\n-        mIcon = icon;\n+        mIcon = validateAccountIconUserBoundary(icon, Binder.getCallingUserHandle());\n         mExtras = extras;\n     }\n \n+    /**\n+     * @param icon\n+     * @hide\n+     */\n+    @VisibleForTesting\n+    public StatusHints(@Nullable Icon icon) {\n+        mLabel = null;\n+        mExtras = null;\n+        mIcon = icon;\n+    }\n+\n+    /**\n+     *\n+     * @param icon\n+     * @hide\n+     */\n+    public void setIcon(@Nullable Icon icon) {\n+        mIcon = icon;\n+    }\n+\n     /**\n      * @return A package used to load the icon.\n      *\n@@ -112,6 +137,30 @@ public final class StatusHints implements Parcelable {\n         return 0;\n     }\n \n+    /**\n+     * Validates the StatusHints image icon to see if it's not in the calling user space.\n+     * Invalidates the icon if so, otherwise returns back the original icon.\n+     *\n+     * @param icon\n+     * @return icon (validated)\n+     * @hide\n+     */\n+    public static Icon validateAccountIconUserBoundary(Icon icon, UserHandle callingUserHandle) {\n+        // Refer to Icon#getUriString for context. The URI string is invalid for icons of\n+        // incompatible types.\n+        if (icon != null && (icon.getType() == Icon.TYPE_URI\n+                || icon.getType() == Icon.TYPE_URI_ADAPTIVE_BITMAP)) {\n+            String encodedUser = icon.getUri().getEncodedUserInfo();\n+            // If there is no encoded user, the URI is calling into the calling user space\n+            if (encodedUser != null) {\n+                int userId = Integer.parseInt(encodedUser);\n+                // Do not try to save the icon if the user id isn't in the calling user space.\n+                if (userId != callingUserHandle.getIdentifier()) return null;\n+            }\n+        }\n+        return icon;\n+    }\n+\n     @Override\n     public void writeToParcel(Parcel out, int flags) {\n         out.writeCharSequence(mLabel);\n",
    "added_lines": 51,
    "deleted_lines": 2,
    "changed_methods": "StatusHints::validateAccountIconUserBoundary, StatusHints::setIcon, StatusHints::StatusHints, StatusHints::StatusHints"
   }
  ]
 },
 {
  "hash": "0101ae8a47ff484d43af3dde506d19cde4590f65",
  "commit": "Merge \"Resolve StatusHints image exploit across user.\" into rvc-dev am: 543e6febbf am: 8c3d465b5e\n\nOriginal change: https://googleplex-android-review.googlesource.com/c/platform/frameworks/base/+/23438530\n\nFixes: 285650146\nFixes: 280797684\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:06456af560729b8a8d209613bb117ede3496fd9d)\nMerged-In: I7822bf2bb75c775faaaa7023fd2c9af9f6d6888f\nChange-Id: I7822bf2bb75c775faaaa7023fd2c9af9f6d6888f",
  "files": [
   {
    "filename": "ParcelableConference.java",
    "diff": "@@ -21,12 +21,12 @@ import android.os.Bundle;\n import android.os.Parcel;\n import android.os.Parcelable;\n \n+import com.android.internal.telecom.IVideoProvider;\n+\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.List;\n \n-import com.android.internal.telecom.IVideoProvider;\n-\n /**\n  * A parcelable representation of a conference connection.\n  * @hide\n@@ -287,6 +287,14 @@ public final class ParcelableConference implements Parcelable {\n         return mCallDirection;\n     }\n \n+    public String getCallerDisplayName() {\n+        return mCallerDisplayName;\n+    }\n+\n+    public int getCallerDisplayNamePresentation() {\n+        return mCallerDisplayNamePresentation;\n+    }\n+\n     public static final @android.annotation.NonNull Parcelable.Creator<ParcelableConference> CREATOR =\n             new Parcelable.Creator<ParcelableConference> () {\n         @Override\n",
    "added_lines": 10,
    "deleted_lines": 2,
    "changed_methods": "ParcelableConference::getCallerDisplayName, ParcelableConference::getCallerDisplayNamePresentation"
   },
   {
    "filename": "StatusHints.java",
    "diff": "@@ -16,14 +16,19 @@\n \n package android.telecom;\n \n+import android.annotation.Nullable;\n import android.annotation.SystemApi;\n import android.content.ComponentName;\n import android.content.Context;\n import android.graphics.drawable.Drawable;\n import android.graphics.drawable.Icon;\n+import android.os.Binder;\n import android.os.Bundle;\n import android.os.Parcel;\n import android.os.Parcelable;\n+import android.os.UserHandle;\n+\n+import com.android.internal.annotations.VisibleForTesting;\n \n import java.util.Objects;\n \n@@ -33,7 +38,7 @@ import java.util.Objects;\n public final class StatusHints implements Parcelable {\n \n     private final CharSequence mLabel;\n-    private final Icon mIcon;\n+    private Icon mIcon;\n     private final Bundle mExtras;\n \n     /**\n@@ -48,10 +53,30 @@ public final class StatusHints implements Parcelable {\n \n     public StatusHints(CharSequence label, Icon icon, Bundle extras) {\n         mLabel = label;\n-        mIcon = icon;\n+        mIcon = validateAccountIconUserBoundary(icon, Binder.getCallingUserHandle());\n         mExtras = extras;\n     }\n \n+    /**\n+     * @param icon\n+     * @hide\n+     */\n+    @VisibleForTesting\n+    public StatusHints(@Nullable Icon icon) {\n+        mLabel = null;\n+        mExtras = null;\n+        mIcon = icon;\n+    }\n+\n+    /**\n+     *\n+     * @param icon\n+     * @hide\n+     */\n+    public void setIcon(@Nullable Icon icon) {\n+        mIcon = icon;\n+    }\n+\n     /**\n      * @return A package used to load the icon.\n      *\n@@ -112,6 +137,30 @@ public final class StatusHints implements Parcelable {\n         return 0;\n     }\n \n+    /**\n+     * Validates the StatusHints image icon to see if it's not in the calling user space.\n+     * Invalidates the icon if so, otherwise returns back the original icon.\n+     *\n+     * @param icon\n+     * @return icon (validated)\n+     * @hide\n+     */\n+    public static Icon validateAccountIconUserBoundary(Icon icon, UserHandle callingUserHandle) {\n+        // Refer to Icon#getUriString for context. The URI string is invalid for icons of\n+        // incompatible types.\n+        if (icon != null && (icon.getType() == Icon.TYPE_URI\n+                || icon.getType() == Icon.TYPE_URI_ADAPTIVE_BITMAP)) {\n+            String encodedUser = icon.getUri().getEncodedUserInfo();\n+            // If there is no encoded user, the URI is calling into the calling user space\n+            if (encodedUser != null) {\n+                int userId = Integer.parseInt(encodedUser);\n+                // Do not try to save the icon if the user id isn't in the calling user space.\n+                if (userId != callingUserHandle.getIdentifier()) return null;\n+            }\n+        }\n+        return icon;\n+    }\n+\n     @Override\n     public void writeToParcel(Parcel out, int flags) {\n         out.writeCharSequence(mLabel);\n",
    "added_lines": 51,
    "deleted_lines": 2,
    "changed_methods": "StatusHints::validateAccountIconUserBoundary, StatusHints::setIcon, StatusHints::StatusHints, StatusHints::StatusHints"
   }
  ]
 },
 {
  "hash": "5a90c77327de244dee82de520ca602581d5341ed",
  "commit": "DO NOT MERGE Revert \"Verify URI permissions for EXTRA_REMOTE_INPUT_HISTORY_ITEMS.\"\n\nThis reverts commit 43b1711332763788c7abf05c3baa931296c45bbb.\n\nReason for revert: regression reported at b/289223315\n\nBug: 289223315\nBug: 276729064\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:28428b737903c9b82d7ce3682336d15d8ad00762)\nMerged-In: I101938fbc51592537023345ba1e642827510981b\nChange-Id: I101938fbc51592537023345ba1e642827510981b",
  "files": [
   {
    "filename": "Notification.java",
    "diff": "@@ -2811,17 +2811,6 @@ public class Notification implements Parcelable\n             if (person != null) {\n                 visitor.accept(person.getIconUri());\n             }\n-\n-            final RemoteInputHistoryItem[] history = (RemoteInputHistoryItem[])\n-                    extras.getParcelableArray(Notification.EXTRA_REMOTE_INPUT_HISTORY_ITEMS);\n-            if (history != null) {\n-                for (int i = 0; i < history.length; i++) {\n-                    RemoteInputHistoryItem item = history[i];\n-                    if (item.getUri() != null) {\n-                        visitor.accept(item.getUri());\n-                    }\n-                }\n-            }\n         }\n \n         if (isStyle(MessagingStyle.class) && extras != null) {\n",
    "added_lines": 0,
    "deleted_lines": 11,
    "changed_methods": "Notification::visitUris"
   },
   {
    "filename": "NotificationManagerServiceTest.java",
    "diff": "@@ -115,7 +115,6 @@ import android.app.NotificationManager;\n import android.app.PendingIntent;\n import android.app.Person;\n import android.app.RemoteInput;\n-import android.app.RemoteInputHistoryItem;\n import android.app.StatsManager;\n import android.app.admin.DevicePolicyManagerInternal;\n import android.app.usage.UsageStatsManagerInternal;\n@@ -4464,12 +4463,6 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n                 .setName(\"People List Person 2\")\n                 .setIcon(personIcon3)\n                 .build();\n-        final Uri historyUri1 = Uri.parse(\"content://com.example/history1\");\n-        final Uri historyUri2 = Uri.parse(\"content://com.example/history2\");\n-        final RemoteInputHistoryItem historyItem1 = new RemoteInputHistoryItem(null, historyUri1,\n-                \"a\");\n-        final RemoteInputHistoryItem historyItem2 = new RemoteInputHistoryItem(null, historyUri2,\n-                \"b\");\n \n         Bundle extras = new Bundle();\n         extras.putParcelable(Notification.EXTRA_AUDIO_CONTENTS_URI, audioContents);\n@@ -4477,8 +4470,6 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n         extras.putParcelable(Notification.EXTRA_MESSAGING_PERSON, person1);\n         extras.putParcelableArrayList(Notification.EXTRA_PEOPLE_LIST,\n                 new ArrayList<>(Arrays.asList(person2, person3)));\n-        extras.putParcelableArray(Notification.EXTRA_REMOTE_INPUT_HISTORY_ITEMS,\n-                new RemoteInputHistoryItem[]{historyItem1, historyItem2});\n \n         Notification n = new Notification.Builder(mContext, \"a\")\n                 .setContentTitle(\"notification with uris\")\n@@ -4496,8 +4487,6 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n         verify(visitor, times(1)).accept(eq(personIcon1.getUri()));\n         verify(visitor, times(1)).accept(eq(personIcon2.getUri()));\n         verify(visitor, times(1)).accept(eq(personIcon3.getUri()));\n-        verify(visitor, times(1)).accept(eq(historyUri1));\n-        verify(visitor, times(1)).accept(eq(historyUri2));\n     }\n \n     @Test\n",
    "added_lines": 0,
    "deleted_lines": 11,
    "changed_methods": "NotificationManagerServiceTest::testVisitUris"
   }
  ]
 },
 {
  "hash": "5a90c77327de244dee82de520ca602581d5341ed",
  "commit": "DO NOT MERGE Revert \"Verify URI permissions for EXTRA_REMOTE_INPUT_HISTORY_ITEMS.\"\n\nThis reverts commit 43b1711332763788c7abf05c3baa931296c45bbb.\n\nReason for revert: regression reported at b/289223315\n\nBug: 289223315\nBug: 276729064\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:28428b737903c9b82d7ce3682336d15d8ad00762)\nMerged-In: I101938fbc51592537023345ba1e642827510981b\nChange-Id: I101938fbc51592537023345ba1e642827510981b",
  "files": [
   {
    "filename": "Notification.java",
    "diff": "@@ -2811,17 +2811,6 @@ public class Notification implements Parcelable\n             if (person != null) {\n                 visitor.accept(person.getIconUri());\n             }\n-\n-            final RemoteInputHistoryItem[] history = (RemoteInputHistoryItem[])\n-                    extras.getParcelableArray(Notification.EXTRA_REMOTE_INPUT_HISTORY_ITEMS);\n-            if (history != null) {\n-                for (int i = 0; i < history.length; i++) {\n-                    RemoteInputHistoryItem item = history[i];\n-                    if (item.getUri() != null) {\n-                        visitor.accept(item.getUri());\n-                    }\n-                }\n-            }\n         }\n \n         if (isStyle(MessagingStyle.class) && extras != null) {\n",
    "added_lines": 0,
    "deleted_lines": 11,
    "changed_methods": "Notification::visitUris"
   },
   {
    "filename": "NotificationManagerServiceTest.java",
    "diff": "@@ -115,7 +115,6 @@ import android.app.NotificationManager;\n import android.app.PendingIntent;\n import android.app.Person;\n import android.app.RemoteInput;\n-import android.app.RemoteInputHistoryItem;\n import android.app.StatsManager;\n import android.app.admin.DevicePolicyManagerInternal;\n import android.app.usage.UsageStatsManagerInternal;\n@@ -4464,12 +4463,6 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n                 .setName(\"People List Person 2\")\n                 .setIcon(personIcon3)\n                 .build();\n-        final Uri historyUri1 = Uri.parse(\"content://com.example/history1\");\n-        final Uri historyUri2 = Uri.parse(\"content://com.example/history2\");\n-        final RemoteInputHistoryItem historyItem1 = new RemoteInputHistoryItem(null, historyUri1,\n-                \"a\");\n-        final RemoteInputHistoryItem historyItem2 = new RemoteInputHistoryItem(null, historyUri2,\n-                \"b\");\n \n         Bundle extras = new Bundle();\n         extras.putParcelable(Notification.EXTRA_AUDIO_CONTENTS_URI, audioContents);\n@@ -4477,8 +4470,6 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n         extras.putParcelable(Notification.EXTRA_MESSAGING_PERSON, person1);\n         extras.putParcelableArrayList(Notification.EXTRA_PEOPLE_LIST,\n                 new ArrayList<>(Arrays.asList(person2, person3)));\n-        extras.putParcelableArray(Notification.EXTRA_REMOTE_INPUT_HISTORY_ITEMS,\n-                new RemoteInputHistoryItem[]{historyItem1, historyItem2});\n \n         Notification n = new Notification.Builder(mContext, \"a\")\n                 .setContentTitle(\"notification with uris\")\n@@ -4496,8 +4487,6 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n         verify(visitor, times(1)).accept(eq(personIcon1.getUri()));\n         verify(visitor, times(1)).accept(eq(personIcon2.getUri()));\n         verify(visitor, times(1)).accept(eq(personIcon3.getUri()));\n-        verify(visitor, times(1)).accept(eq(historyUri1));\n-        verify(visitor, times(1)).accept(eq(historyUri2));\n     }\n \n     @Test\n",
    "added_lines": 0,
    "deleted_lines": 11,
    "changed_methods": "NotificationManagerServiceTest::testVisitUris"
   }
  ]
 },
 {
  "hash": "7d92e02aa27e2f5aa236d568f341f960256071de",
  "commit": "DO NOT MERGE Grant carrier privileges if package has carrier config access.\n\nTelephonyManager#hasCarrierPrivileges internally uses\nSubscriptionManager#canManageSubscription to decide whether to grant\ncarrier privilege status to an app or not.\nSubscriptionManager#canManageSubscription returns true if caller APK's\ncertificate matches with one of the mNativeAccessRules or\nmCarrierConfigAccessRules. This over-grants carrier privilege status\nto apps that only has mNativeAccessRules.\nCarrier privilege status should\nbe granted to the caller APK only if it's certificate matches with one\nof mCarrierConfigAccessRules.\nReplaced SubscriptionManager#canManageSubscription with\nPhoneInterfaceManager#hasCarrierConfigAccess which returns true only if\ncaller APK certificates matches with one of mCarrierConfigAccessRules of\nthe given subscription.\n\nBug: 226593252\nTest: Manual Testing as explained in b/226593252#comment51\n      atest CtsTelephonyTestCases\n      Flashed build on raven-userdebug and performed basic\n      funtionality tests\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:fc32ff6c0bbbeeb7dd6c4e0af1f77ce8f19bcbd1)\nMerged-In: I662064529d2a9348f395fe3b541366de8bc2fe7d\nChange-Id: I662064529d2a9348f395fe3b541366de8bc2fe7d",
  "files": [
   {
    "filename": "SubscriptionInfo.java",
    "diff": "@@ -18,6 +18,7 @@ package android.telephony;\n \n import static android.text.TextUtils.formatSimple;\n \n+import android.annotation.NonNull;\n import android.annotation.Nullable;\n import android.annotation.SystemApi;\n import android.compat.annotation.UnsupportedAppUsage;\n@@ -696,6 +697,15 @@ public class SubscriptionInfo implements Parcelable {\n         return merged.isEmpty() ? null : merged;\n     }\n \n+    /**\n+     * @hide\n+     * @return mCarrierConfigAccessRules associated with this subscription.\n+     */\n+    public @NonNull List<UiccAccessRule> getCarrierConfigAccessRules() {\n+        return mCarrierConfigAccessRules == null ? Collections.emptyList() :\n+            Arrays.asList(mCarrierConfigAccessRules);\n+    }\n+\n     /**\n      * Returns the card string of the SIM card which contains the subscription.\n      *\n",
    "added_lines": 10,
    "deleted_lines": 0,
    "changed_methods": "SubscriptionInfo::getCarrierConfigAccessRules"
   }
  ]
 },
 {
  "hash": "c916dad1dfd40b0a4031fb954ada07989121f607",
  "commit": "[DO NOT MERGE] Update quickshare intent rather than recreating\n\nCurrently, we extract the quickshare intent and re-wrap it as a new\nPendingIntent once we get the screenshot URI. This is insecure as\nit leads to executing the original with SysUI's permissions, which\nthe app may not have. This change switches to using Intent.fillin\nto add the URI, keeping the original PendingIntent and original\npermission set.\n\nBug: 278720336\nTest: manual (to test successful quickshare), atest\nSaveImageInBackgroundTaskTest (to verify original pending intent\nunchanged)\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:573d31ef204bc8bbf24a7341afe17870708c0904)\nMerged-In: Icad3d5f939fcfb894e2038948954bc2735dbe326\nChange-Id: Icad3d5f939fcfb894e2038948954bc2735dbe326\n\nChange-Id: I0fe48b575e68daf89de7dbcb98502bff84aa2658",
  "files": [
   {
    "filename": "SaveImageInBackgroundTask.java",
    "diff": "@@ -89,7 +89,8 @@ class SaveImageInBackgroundTask extends AsyncTask<String, Void, Void> {\n     SaveImageInBackgroundTask(Context context, ImageExporter exporter,\n             ScreenshotSmartActions screenshotSmartActions,\n             ScreenshotController.SaveImageInBackgroundData data,\n-            Supplier<ActionTransition> sharedElementTransition) {\n+            Supplier<ActionTransition> sharedElementTransition,\n+            boolean smartActionsEnabled) {\n         mContext = context;\n         mScreenshotSmartActions = screenshotSmartActions;\n         mImageData = new ScreenshotController.SavedImageData();\n@@ -101,8 +102,7 @@ class SaveImageInBackgroundTask extends AsyncTask<String, Void, Void> {\n         mParams = data;\n \n         // Initialize screenshot notification smart actions provider.\n-        mSmartActionsEnabled = DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_SYSTEMUI,\n-                SystemUiDeviceConfigFlags.ENABLE_SCREENSHOT_NOTIFICATION_SMART_ACTIONS, true);\n+        mSmartActionsEnabled = smartActionsEnabled;\n         if (mSmartActionsEnabled) {\n             mSmartActionsProvider =\n                     SystemUIFactory.getInstance()\n@@ -135,7 +135,12 @@ class SaveImageInBackgroundTask extends AsyncTask<String, Void, Void> {\n                 // Since Quick Share target recommendation does not rely on image URL, it is\n                 // queried and surfaced before image compress/export. Action intent would not be\n                 // used, because it does not contain image URL.\n-                queryQuickShareAction(image, user);\n+                Notification.Action quickShare =\n+                        queryQuickShareAction(mScreenshotId, image, user, null);\n+                if (quickShare != null) {\n+                    mQuickShareData.quickShareAction = quickShare;\n+                    mParams.mQuickShareActionsReadyListener.onActionsReady(mQuickShareData);\n+                }\n             }\n \n             // Call synchronously here since already on a background thread.\n@@ -170,8 +175,9 @@ class SaveImageInBackgroundTask extends AsyncTask<String, Void, Void> {\n             mImageData.shareTransition = createShareAction(mContext, mContext.getResources(), uri);\n             mImageData.editTransition = createEditAction(mContext, mContext.getResources(), uri);\n             mImageData.deleteAction = createDeleteAction(mContext, mContext.getResources(), uri);\n-            mImageData.quickShareAction = createQuickShareAction(mContext,\n-                    mQuickShareData.quickShareAction, uri);\n+            mImageData.quickShareAction = createQuickShareAction(\n+                    mQuickShareData.quickShareAction, mScreenshotId, uri, mImageTime, image,\n+                    user);\n \n             mParams.mActionsReadyListener.onActionsReady(mImageData);\n             if (DEBUG_CALLBACK) {\n@@ -454,60 +460,73 @@ class SaveImageInBackgroundTask extends AsyncTask<String, Void, Void> {\n     }\n \n     /**\n-     * Populate image uri into intent of Quick Share action.\n+     * Wrap the quickshare intent and populate the fillin intent with the URI\n      */\n     @VisibleForTesting\n-    private Notification.Action createQuickShareAction(Context context, Notification.Action action,\n-            Uri uri) {\n-        if (action == null) {\n+    Notification.Action createQuickShareAction(\n+            Notification.Action quickShare, String screenshotId, Uri uri, long imageTime,\n+            Bitmap image, UserHandle user) {\n+        if (quickShare == null) {\n             return null;\n+        } else if (quickShare.actionIntent.isImmutable()) {\n+            Notification.Action quickShareWithUri =\n+                    queryQuickShareAction(screenshotId, image, user, uri);\n+            if (quickShareWithUri == null\n+                    || !quickShareWithUri.title.toString().contentEquals(quickShare.title)) {\n+                return null;\n+            }\n+            quickShare = quickShareWithUri;\n         }\n-        // Populate image URI into Quick Share chip intent\n-        Intent sharingIntent = action.actionIntent.getIntent();\n-        sharingIntent.setType(\"image/png\");\n-        sharingIntent.putExtra(Intent.EXTRA_STREAM, uri);\n-        String subjectDate = DateFormat.getDateTimeInstance().format(new Date(mImageTime));\n+\n+        Intent wrappedIntent = new Intent(mContext, SmartActionsReceiver.class)\n+                .putExtra(ScreenshotController.EXTRA_ACTION_INTENT, quickShare.actionIntent)\n+                .putExtra(ScreenshotController.EXTRA_ACTION_INTENT_FILLIN,\n+                        createFillInIntent(uri, imageTime))\n+                .addFlags(Intent.FLAG_RECEIVER_FOREGROUND);\n+        Bundle extras = quickShare.getExtras();\n+        String actionType = extras.getString(\n+                ScreenshotNotificationSmartActionsProvider.ACTION_TYPE,\n+                ScreenshotNotificationSmartActionsProvider.DEFAULT_ACTION_TYPE);\n+        addIntentExtras(screenshotId, wrappedIntent, actionType, mSmartActionsEnabled);\n+        PendingIntent broadcastIntent =\n+                PendingIntent.getBroadcast(mContext, mRandom.nextInt(), wrappedIntent,\n+                        PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_IMMUTABLE);\n+        return new Notification.Action.Builder(quickShare.getIcon(), quickShare.title,\n+                broadcastIntent)\n+                .setContextual(true)\n+                .addExtras(extras)\n+                .build();\n+    }\n+\n+    private Intent createFillInIntent(Uri uri, long imageTime) {\n+        Intent fillIn = new Intent();\n+        fillIn.setType(\"image/png\");\n+        fillIn.putExtra(Intent.EXTRA_STREAM, uri);\n+        String subjectDate = DateFormat.getDateTimeInstance().format(new Date(imageTime));\n         String subject = String.format(SCREENSHOT_SHARE_SUBJECT_TEMPLATE, subjectDate);\n-        sharingIntent.putExtra(Intent.EXTRA_SUBJECT, subject);\n+        fillIn.putExtra(Intent.EXTRA_SUBJECT, subject);\n         // Include URI in ClipData also, so that grantPermission picks it up.\n         // We don't use setData here because some apps interpret this as \"to:\".\n-        ClipData clipdata = new ClipData(new ClipDescription(\"content\",\n-                new String[]{\"image/png\"}),\n+        ClipData clipData = new ClipData(\n+                new ClipDescription(\"content\", new String[]{\"image/png\"}),\n                 new ClipData.Item(uri));\n-        sharingIntent.setClipData(clipdata);\n-        sharingIntent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);\n-        PendingIntent updatedPendingIntent = PendingIntent.getActivity(\n-                context, 0, sharingIntent,\n-                PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_IMMUTABLE);\n-\n-        // Proxy smart actions through {@link GlobalScreenshot.SmartActionsReceiver}\n-        // for logging smart actions.\n-        Bundle extras = action.getExtras();\n-        String actionType = extras.getString(\n-                ScreenshotNotificationSmartActionsProvider.ACTION_TYPE,\n-                ScreenshotNotificationSmartActionsProvider.DEFAULT_ACTION_TYPE);\n-        Intent intent = new Intent(context, SmartActionsReceiver.class)\n-                .putExtra(ScreenshotController.EXTRA_ACTION_INTENT, updatedPendingIntent)\n-                .addFlags(Intent.FLAG_RECEIVER_FOREGROUND);\n-        addIntentExtras(mScreenshotId, intent, actionType, mSmartActionsEnabled);\n-        PendingIntent broadcastIntent = PendingIntent.getBroadcast(context,\n-                mRandom.nextInt(),\n-                intent,\n-                PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_IMMUTABLE);\n-        return new Notification.Action.Builder(action.getIcon(), action.title,\n-                broadcastIntent).setContextual(true).addExtras(extras).build();\n+        fillIn.setClipData(clipData);\n+        fillIn.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);\n+        return fillIn;\n     }\n \n     /**\n      * Query and surface Quick Share chip if it is available. Action intent would not be used,\n      * because it does not contain image URL which would be populated in {@link\n-     * #createQuickShareAction(Context, Notification.Action, Uri)}\n+     * #createQuickShareAction(Notification.Action, String, Uri, long, Bitmap, UserHandle)}\n      */\n-    private void queryQuickShareAction(Bitmap image, UserHandle user) {\n+\n+    @VisibleForTesting\n+    Notification.Action queryQuickShareAction(\n+            String screenshotId, Bitmap image, UserHandle user, Uri uri) {\n         CompletableFuture<List<Notification.Action>> quickShareActionsFuture =\n                 mScreenshotSmartActions.getSmartActionsFuture(\n-                        mScreenshotId, null, image, mSmartActionsProvider,\n-                        QUICK_SHARE_ACTION,\n+                        screenshotId, uri, image, mSmartActionsProvider, QUICK_SHARE_ACTION,\n                         mSmartActionsEnabled, user);\n         int timeoutMs = DeviceConfig.getInt(\n                 DeviceConfig.NAMESPACE_SYSTEMUI,\n@@ -515,11 +534,11 @@ class SaveImageInBackgroundTask extends AsyncTask<String, Void, Void> {\n                 500);\n         List<Notification.Action> quickShareActions =\n                 mScreenshotSmartActions.getSmartActions(\n-                        mScreenshotId, quickShareActionsFuture, timeoutMs,\n+                        screenshotId, quickShareActionsFuture, timeoutMs,\n                         mSmartActionsProvider, QUICK_SHARE_ACTION);\n         if (!quickShareActions.isEmpty()) {\n-            mQuickShareData.quickShareAction = quickShareActions.get(0);\n-            mParams.mQuickShareActionsReadyListener.onActionsReady(mQuickShareData);\n+            return quickShareActions.get(0);\n         }\n+        return null;\n     }\n }\n",
    "added_lines": 66,
    "deleted_lines": 47,
    "changed_methods": "SaveImageInBackgroundTask::createFillInIntent, SaveImageInBackgroundTask::SaveImageInBackgroundTask, SaveImageInBackgroundTask::createQuickShareAction, SaveImageInBackgroundTask::doInBackground, SaveImageInBackgroundTask::queryQuickShareAction, SaveImageInBackgroundTask::queryQuickShareAction, SaveImageInBackgroundTask::SaveImageInBackgroundTask, SaveImageInBackgroundTask::createQuickShareAction"
   },
   {
    "filename": "ScreenshotController.java",
    "diff": "@@ -62,6 +62,7 @@ import android.os.Message;\n import android.os.RemoteException;\n import android.os.VibrationEffect;\n import android.os.Vibrator;\n+import android.provider.DeviceConfig;\n import android.provider.Settings;\n import android.util.DisplayMetrics;\n import android.util.Log;\n@@ -88,6 +89,7 @@ import android.widget.Toast;\n import android.window.WindowContext;\n \n import com.android.internal.app.ChooserActivity;\n+import com.android.internal.config.sysui.SystemUiDeviceConfigFlags;\n import com.android.internal.logging.UiEventLogger;\n import com.android.internal.policy.PhoneWindow;\n import com.android.internal.statusbar.IStatusBarService;\n@@ -237,6 +239,7 @@ public class ScreenshotController {\n     static final String EXTRA_SMART_ACTIONS_ENABLED = \"android:smart_actions_enabled\";\n     static final String EXTRA_OVERRIDE_TRANSITION = \"android:screenshot_override_transition\";\n     static final String EXTRA_ACTION_INTENT = \"android:screenshot_action_intent\";\n+    static final String EXTRA_ACTION_INTENT_FILLIN = \"android:screenshot_action_intent_fillin\";\n \n     static final String SCREENSHOT_URI_ID = \"android:screenshot_uri_id\";\n     static final String EXTRA_CANCEL_NOTIFICATION = \"android:screenshot_cancel_notification\";\n@@ -961,8 +964,11 @@ public class ScreenshotController {\n             mSaveInBgTask.setActionsReadyListener(this::logSuccessOnActionsReady);\n         }\n \n+        boolean smartActionsEnabled = DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_SYSTEMUI,\n+                SystemUiDeviceConfigFlags.ENABLE_SCREENSHOT_NOTIFICATION_SMART_ACTIONS, true);\n+\n         mSaveInBgTask = new SaveImageInBackgroundTask(mContext, mImageExporter,\n-                mScreenshotSmartActions, data, getActionTransitionSupplier());\n+                mScreenshotSmartActions, data, getActionTransitionSupplier(), smartActionsEnabled);\n         mSaveInBgTask.execute(getForegroundAppLabel());\n     }\n \n",
    "added_lines": 7,
    "deleted_lines": 1,
    "changed_methods": "ScreenshotController::saveScreenshotInWorkerThread"
   },
   {
    "filename": "SmartActionsReceiver.java",
    "diff": "@@ -18,6 +18,7 @@ package com.android.systemui.screenshot;\n \n import static com.android.systemui.screenshot.LogConfig.DEBUG_ACTIONS;\n import static com.android.systemui.screenshot.ScreenshotController.EXTRA_ACTION_INTENT;\n+import static com.android.systemui.screenshot.ScreenshotController.EXTRA_ACTION_INTENT_FILLIN;\n import static com.android.systemui.screenshot.ScreenshotController.EXTRA_ACTION_TYPE;\n import static com.android.systemui.screenshot.ScreenshotController.EXTRA_ID;\n \n@@ -47,6 +48,7 @@ public class SmartActionsReceiver extends BroadcastReceiver {\n     @Override\n     public void onReceive(Context context, Intent intent) {\n         PendingIntent pendingIntent = intent.getParcelableExtra(EXTRA_ACTION_INTENT);\n+        Intent fillIn = intent.getParcelableExtra(EXTRA_ACTION_INTENT_FILLIN);\n         String actionType = intent.getStringExtra(EXTRA_ACTION_TYPE);\n         if (DEBUG_ACTIONS) {\n             Log.d(TAG, \"Executing smart action [\" + actionType + \"]:\" + pendingIntent.getIntent());\n@@ -54,7 +56,7 @@ public class SmartActionsReceiver extends BroadcastReceiver {\n         ActivityOptions opts = ActivityOptions.makeBasic();\n \n         try {\n-            pendingIntent.send(context, 0, null, null, null, null, opts.toBundle());\n+            pendingIntent.send(context, 0, fillIn, null, null, null, opts.toBundle());\n         } catch (PendingIntent.CanceledException e) {\n             Log.e(TAG, \"Pending intent canceled\", e);\n         }\n",
    "added_lines": 3,
    "deleted_lines": 1,
    "changed_methods": "SmartActionsReceiver::onReceive"
   },
   {
    "filename": "ScreenshotNotificationSmartActionsTest.java",
    "diff": "@@ -211,7 +211,7 @@ public class ScreenshotNotificationSmartActionsTest extends SysuiTestCase {\n         data.mActionsReadyListener = null;\n         SaveImageInBackgroundTask task =\n                 new SaveImageInBackgroundTask(mContext, null, mScreenshotSmartActions, data,\n-                        ActionTransition::new);\n+                        ActionTransition::new, false);\n \n         Notification.Action shareAction = task.createShareAction(mContext, mContext.getResources(),\n                 Uri.parse(\"Screenshot_123.png\")).get().action;\n@@ -239,7 +239,7 @@ public class ScreenshotNotificationSmartActionsTest extends SysuiTestCase {\n         data.mActionsReadyListener = null;\n         SaveImageInBackgroundTask task =\n                 new SaveImageInBackgroundTask(mContext, null, mScreenshotSmartActions, data,\n-                        ActionTransition::new);\n+                        ActionTransition::new, false);\n \n         Notification.Action editAction = task.createEditAction(mContext, mContext.getResources(),\n                 Uri.parse(\"Screenshot_123.png\")).get().action;\n@@ -267,7 +267,7 @@ public class ScreenshotNotificationSmartActionsTest extends SysuiTestCase {\n         data.mActionsReadyListener = null;\n         SaveImageInBackgroundTask task =\n                 new SaveImageInBackgroundTask(mContext, null, mScreenshotSmartActions, data,\n-                        ActionTransition::new);\n+                        ActionTransition::new, false);\n \n         Notification.Action deleteAction = task.createDeleteAction(mContext,\n                 mContext.getResources(),\n",
    "added_lines": 3,
    "deleted_lines": 3,
    "changed_methods": "ScreenshotNotificationSmartActionsTest::testEditActionExtras, ScreenshotNotificationSmartActionsTest::testShareActionExtras, ScreenshotNotificationSmartActionsTest::testDeleteActionExtras"
   }
  ]
 },
 {
  "hash": "c916dad1dfd40b0a4031fb954ada07989121f607",
  "commit": "[DO NOT MERGE] Update quickshare intent rather than recreating\n\nCurrently, we extract the quickshare intent and re-wrap it as a new\nPendingIntent once we get the screenshot URI. This is insecure as\nit leads to executing the original with SysUI's permissions, which\nthe app may not have. This change switches to using Intent.fillin\nto add the URI, keeping the original PendingIntent and original\npermission set.\n\nBug: 278720336\nTest: manual (to test successful quickshare), atest\nSaveImageInBackgroundTaskTest (to verify original pending intent\nunchanged)\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:573d31ef204bc8bbf24a7341afe17870708c0904)\nMerged-In: Icad3d5f939fcfb894e2038948954bc2735dbe326\nChange-Id: Icad3d5f939fcfb894e2038948954bc2735dbe326\n\nChange-Id: I0fe48b575e68daf89de7dbcb98502bff84aa2658",
  "files": [
   {
    "filename": "SaveImageInBackgroundTask.java",
    "diff": "@@ -89,7 +89,8 @@ class SaveImageInBackgroundTask extends AsyncTask<String, Void, Void> {\n     SaveImageInBackgroundTask(Context context, ImageExporter exporter,\n             ScreenshotSmartActions screenshotSmartActions,\n             ScreenshotController.SaveImageInBackgroundData data,\n-            Supplier<ActionTransition> sharedElementTransition) {\n+            Supplier<ActionTransition> sharedElementTransition,\n+            boolean smartActionsEnabled) {\n         mContext = context;\n         mScreenshotSmartActions = screenshotSmartActions;\n         mImageData = new ScreenshotController.SavedImageData();\n@@ -101,8 +102,7 @@ class SaveImageInBackgroundTask extends AsyncTask<String, Void, Void> {\n         mParams = data;\n \n         // Initialize screenshot notification smart actions provider.\n-        mSmartActionsEnabled = DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_SYSTEMUI,\n-                SystemUiDeviceConfigFlags.ENABLE_SCREENSHOT_NOTIFICATION_SMART_ACTIONS, true);\n+        mSmartActionsEnabled = smartActionsEnabled;\n         if (mSmartActionsEnabled) {\n             mSmartActionsProvider =\n                     SystemUIFactory.getInstance()\n@@ -135,7 +135,12 @@ class SaveImageInBackgroundTask extends AsyncTask<String, Void, Void> {\n                 // Since Quick Share target recommendation does not rely on image URL, it is\n                 // queried and surfaced before image compress/export. Action intent would not be\n                 // used, because it does not contain image URL.\n-                queryQuickShareAction(image, user);\n+                Notification.Action quickShare =\n+                        queryQuickShareAction(mScreenshotId, image, user, null);\n+                if (quickShare != null) {\n+                    mQuickShareData.quickShareAction = quickShare;\n+                    mParams.mQuickShareActionsReadyListener.onActionsReady(mQuickShareData);\n+                }\n             }\n \n             // Call synchronously here since already on a background thread.\n@@ -170,8 +175,9 @@ class SaveImageInBackgroundTask extends AsyncTask<String, Void, Void> {\n             mImageData.shareTransition = createShareAction(mContext, mContext.getResources(), uri);\n             mImageData.editTransition = createEditAction(mContext, mContext.getResources(), uri);\n             mImageData.deleteAction = createDeleteAction(mContext, mContext.getResources(), uri);\n-            mImageData.quickShareAction = createQuickShareAction(mContext,\n-                    mQuickShareData.quickShareAction, uri);\n+            mImageData.quickShareAction = createQuickShareAction(\n+                    mQuickShareData.quickShareAction, mScreenshotId, uri, mImageTime, image,\n+                    user);\n \n             mParams.mActionsReadyListener.onActionsReady(mImageData);\n             if (DEBUG_CALLBACK) {\n@@ -454,60 +460,73 @@ class SaveImageInBackgroundTask extends AsyncTask<String, Void, Void> {\n     }\n \n     /**\n-     * Populate image uri into intent of Quick Share action.\n+     * Wrap the quickshare intent and populate the fillin intent with the URI\n      */\n     @VisibleForTesting\n-    private Notification.Action createQuickShareAction(Context context, Notification.Action action,\n-            Uri uri) {\n-        if (action == null) {\n+    Notification.Action createQuickShareAction(\n+            Notification.Action quickShare, String screenshotId, Uri uri, long imageTime,\n+            Bitmap image, UserHandle user) {\n+        if (quickShare == null) {\n             return null;\n+        } else if (quickShare.actionIntent.isImmutable()) {\n+            Notification.Action quickShareWithUri =\n+                    queryQuickShareAction(screenshotId, image, user, uri);\n+            if (quickShareWithUri == null\n+                    || !quickShareWithUri.title.toString().contentEquals(quickShare.title)) {\n+                return null;\n+            }\n+            quickShare = quickShareWithUri;\n         }\n-        // Populate image URI into Quick Share chip intent\n-        Intent sharingIntent = action.actionIntent.getIntent();\n-        sharingIntent.setType(\"image/png\");\n-        sharingIntent.putExtra(Intent.EXTRA_STREAM, uri);\n-        String subjectDate = DateFormat.getDateTimeInstance().format(new Date(mImageTime));\n+\n+        Intent wrappedIntent = new Intent(mContext, SmartActionsReceiver.class)\n+                .putExtra(ScreenshotController.EXTRA_ACTION_INTENT, quickShare.actionIntent)\n+                .putExtra(ScreenshotController.EXTRA_ACTION_INTENT_FILLIN,\n+                        createFillInIntent(uri, imageTime))\n+                .addFlags(Intent.FLAG_RECEIVER_FOREGROUND);\n+        Bundle extras = quickShare.getExtras();\n+        String actionType = extras.getString(\n+                ScreenshotNotificationSmartActionsProvider.ACTION_TYPE,\n+                ScreenshotNotificationSmartActionsProvider.DEFAULT_ACTION_TYPE);\n+        addIntentExtras(screenshotId, wrappedIntent, actionType, mSmartActionsEnabled);\n+        PendingIntent broadcastIntent =\n+                PendingIntent.getBroadcast(mContext, mRandom.nextInt(), wrappedIntent,\n+                        PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_IMMUTABLE);\n+        return new Notification.Action.Builder(quickShare.getIcon(), quickShare.title,\n+                broadcastIntent)\n+                .setContextual(true)\n+                .addExtras(extras)\n+                .build();\n+    }\n+\n+    private Intent createFillInIntent(Uri uri, long imageTime) {\n+        Intent fillIn = new Intent();\n+        fillIn.setType(\"image/png\");\n+        fillIn.putExtra(Intent.EXTRA_STREAM, uri);\n+        String subjectDate = DateFormat.getDateTimeInstance().format(new Date(imageTime));\n         String subject = String.format(SCREENSHOT_SHARE_SUBJECT_TEMPLATE, subjectDate);\n-        sharingIntent.putExtra(Intent.EXTRA_SUBJECT, subject);\n+        fillIn.putExtra(Intent.EXTRA_SUBJECT, subject);\n         // Include URI in ClipData also, so that grantPermission picks it up.\n         // We don't use setData here because some apps interpret this as \"to:\".\n-        ClipData clipdata = new ClipData(new ClipDescription(\"content\",\n-                new String[]{\"image/png\"}),\n+        ClipData clipData = new ClipData(\n+                new ClipDescription(\"content\", new String[]{\"image/png\"}),\n                 new ClipData.Item(uri));\n-        sharingIntent.setClipData(clipdata);\n-        sharingIntent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);\n-        PendingIntent updatedPendingIntent = PendingIntent.getActivity(\n-                context, 0, sharingIntent,\n-                PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_IMMUTABLE);\n-\n-        // Proxy smart actions through {@link GlobalScreenshot.SmartActionsReceiver}\n-        // for logging smart actions.\n-        Bundle extras = action.getExtras();\n-        String actionType = extras.getString(\n-                ScreenshotNotificationSmartActionsProvider.ACTION_TYPE,\n-                ScreenshotNotificationSmartActionsProvider.DEFAULT_ACTION_TYPE);\n-        Intent intent = new Intent(context, SmartActionsReceiver.class)\n-                .putExtra(ScreenshotController.EXTRA_ACTION_INTENT, updatedPendingIntent)\n-                .addFlags(Intent.FLAG_RECEIVER_FOREGROUND);\n-        addIntentExtras(mScreenshotId, intent, actionType, mSmartActionsEnabled);\n-        PendingIntent broadcastIntent = PendingIntent.getBroadcast(context,\n-                mRandom.nextInt(),\n-                intent,\n-                PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_IMMUTABLE);\n-        return new Notification.Action.Builder(action.getIcon(), action.title,\n-                broadcastIntent).setContextual(true).addExtras(extras).build();\n+        fillIn.setClipData(clipData);\n+        fillIn.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);\n+        return fillIn;\n     }\n \n     /**\n      * Query and surface Quick Share chip if it is available. Action intent would not be used,\n      * because it does not contain image URL which would be populated in {@link\n-     * #createQuickShareAction(Context, Notification.Action, Uri)}\n+     * #createQuickShareAction(Notification.Action, String, Uri, long, Bitmap, UserHandle)}\n      */\n-    private void queryQuickShareAction(Bitmap image, UserHandle user) {\n+\n+    @VisibleForTesting\n+    Notification.Action queryQuickShareAction(\n+            String screenshotId, Bitmap image, UserHandle user, Uri uri) {\n         CompletableFuture<List<Notification.Action>> quickShareActionsFuture =\n                 mScreenshotSmartActions.getSmartActionsFuture(\n-                        mScreenshotId, null, image, mSmartActionsProvider,\n-                        QUICK_SHARE_ACTION,\n+                        screenshotId, uri, image, mSmartActionsProvider, QUICK_SHARE_ACTION,\n                         mSmartActionsEnabled, user);\n         int timeoutMs = DeviceConfig.getInt(\n                 DeviceConfig.NAMESPACE_SYSTEMUI,\n@@ -515,11 +534,11 @@ class SaveImageInBackgroundTask extends AsyncTask<String, Void, Void> {\n                 500);\n         List<Notification.Action> quickShareActions =\n                 mScreenshotSmartActions.getSmartActions(\n-                        mScreenshotId, quickShareActionsFuture, timeoutMs,\n+                        screenshotId, quickShareActionsFuture, timeoutMs,\n                         mSmartActionsProvider, QUICK_SHARE_ACTION);\n         if (!quickShareActions.isEmpty()) {\n-            mQuickShareData.quickShareAction = quickShareActions.get(0);\n-            mParams.mQuickShareActionsReadyListener.onActionsReady(mQuickShareData);\n+            return quickShareActions.get(0);\n         }\n+        return null;\n     }\n }\n",
    "added_lines": 66,
    "deleted_lines": 47,
    "changed_methods": "SaveImageInBackgroundTask::createFillInIntent, SaveImageInBackgroundTask::SaveImageInBackgroundTask, SaveImageInBackgroundTask::createQuickShareAction, SaveImageInBackgroundTask::doInBackground, SaveImageInBackgroundTask::queryQuickShareAction, SaveImageInBackgroundTask::queryQuickShareAction, SaveImageInBackgroundTask::SaveImageInBackgroundTask, SaveImageInBackgroundTask::createQuickShareAction"
   },
   {
    "filename": "ScreenshotController.java",
    "diff": "@@ -62,6 +62,7 @@ import android.os.Message;\n import android.os.RemoteException;\n import android.os.VibrationEffect;\n import android.os.Vibrator;\n+import android.provider.DeviceConfig;\n import android.provider.Settings;\n import android.util.DisplayMetrics;\n import android.util.Log;\n@@ -88,6 +89,7 @@ import android.widget.Toast;\n import android.window.WindowContext;\n \n import com.android.internal.app.ChooserActivity;\n+import com.android.internal.config.sysui.SystemUiDeviceConfigFlags;\n import com.android.internal.logging.UiEventLogger;\n import com.android.internal.policy.PhoneWindow;\n import com.android.internal.statusbar.IStatusBarService;\n@@ -237,6 +239,7 @@ public class ScreenshotController {\n     static final String EXTRA_SMART_ACTIONS_ENABLED = \"android:smart_actions_enabled\";\n     static final String EXTRA_OVERRIDE_TRANSITION = \"android:screenshot_override_transition\";\n     static final String EXTRA_ACTION_INTENT = \"android:screenshot_action_intent\";\n+    static final String EXTRA_ACTION_INTENT_FILLIN = \"android:screenshot_action_intent_fillin\";\n \n     static final String SCREENSHOT_URI_ID = \"android:screenshot_uri_id\";\n     static final String EXTRA_CANCEL_NOTIFICATION = \"android:screenshot_cancel_notification\";\n@@ -961,8 +964,11 @@ public class ScreenshotController {\n             mSaveInBgTask.setActionsReadyListener(this::logSuccessOnActionsReady);\n         }\n \n+        boolean smartActionsEnabled = DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_SYSTEMUI,\n+                SystemUiDeviceConfigFlags.ENABLE_SCREENSHOT_NOTIFICATION_SMART_ACTIONS, true);\n+\n         mSaveInBgTask = new SaveImageInBackgroundTask(mContext, mImageExporter,\n-                mScreenshotSmartActions, data, getActionTransitionSupplier());\n+                mScreenshotSmartActions, data, getActionTransitionSupplier(), smartActionsEnabled);\n         mSaveInBgTask.execute(getForegroundAppLabel());\n     }\n \n",
    "added_lines": 7,
    "deleted_lines": 1,
    "changed_methods": "ScreenshotController::saveScreenshotInWorkerThread"
   },
   {
    "filename": "SmartActionsReceiver.java",
    "diff": "@@ -18,6 +18,7 @@ package com.android.systemui.screenshot;\n \n import static com.android.systemui.screenshot.LogConfig.DEBUG_ACTIONS;\n import static com.android.systemui.screenshot.ScreenshotController.EXTRA_ACTION_INTENT;\n+import static com.android.systemui.screenshot.ScreenshotController.EXTRA_ACTION_INTENT_FILLIN;\n import static com.android.systemui.screenshot.ScreenshotController.EXTRA_ACTION_TYPE;\n import static com.android.systemui.screenshot.ScreenshotController.EXTRA_ID;\n \n@@ -47,6 +48,7 @@ public class SmartActionsReceiver extends BroadcastReceiver {\n     @Override\n     public void onReceive(Context context, Intent intent) {\n         PendingIntent pendingIntent = intent.getParcelableExtra(EXTRA_ACTION_INTENT);\n+        Intent fillIn = intent.getParcelableExtra(EXTRA_ACTION_INTENT_FILLIN);\n         String actionType = intent.getStringExtra(EXTRA_ACTION_TYPE);\n         if (DEBUG_ACTIONS) {\n             Log.d(TAG, \"Executing smart action [\" + actionType + \"]:\" + pendingIntent.getIntent());\n@@ -54,7 +56,7 @@ public class SmartActionsReceiver extends BroadcastReceiver {\n         ActivityOptions opts = ActivityOptions.makeBasic();\n \n         try {\n-            pendingIntent.send(context, 0, null, null, null, null, opts.toBundle());\n+            pendingIntent.send(context, 0, fillIn, null, null, null, opts.toBundle());\n         } catch (PendingIntent.CanceledException e) {\n             Log.e(TAG, \"Pending intent canceled\", e);\n         }\n",
    "added_lines": 3,
    "deleted_lines": 1,
    "changed_methods": "SmartActionsReceiver::onReceive"
   },
   {
    "filename": "ScreenshotNotificationSmartActionsTest.java",
    "diff": "@@ -211,7 +211,7 @@ public class ScreenshotNotificationSmartActionsTest extends SysuiTestCase {\n         data.mActionsReadyListener = null;\n         SaveImageInBackgroundTask task =\n                 new SaveImageInBackgroundTask(mContext, null, mScreenshotSmartActions, data,\n-                        ActionTransition::new);\n+                        ActionTransition::new, false);\n \n         Notification.Action shareAction = task.createShareAction(mContext, mContext.getResources(),\n                 Uri.parse(\"Screenshot_123.png\")).get().action;\n@@ -239,7 +239,7 @@ public class ScreenshotNotificationSmartActionsTest extends SysuiTestCase {\n         data.mActionsReadyListener = null;\n         SaveImageInBackgroundTask task =\n                 new SaveImageInBackgroundTask(mContext, null, mScreenshotSmartActions, data,\n-                        ActionTransition::new);\n+                        ActionTransition::new, false);\n \n         Notification.Action editAction = task.createEditAction(mContext, mContext.getResources(),\n                 Uri.parse(\"Screenshot_123.png\")).get().action;\n@@ -267,7 +267,7 @@ public class ScreenshotNotificationSmartActionsTest extends SysuiTestCase {\n         data.mActionsReadyListener = null;\n         SaveImageInBackgroundTask task =\n                 new SaveImageInBackgroundTask(mContext, null, mScreenshotSmartActions, data,\n-                        ActionTransition::new);\n+                        ActionTransition::new, false);\n \n         Notification.Action deleteAction = task.createDeleteAction(mContext,\n                 mContext.getResources(),\n",
    "added_lines": 3,
    "deleted_lines": 3,
    "changed_methods": "ScreenshotNotificationSmartActionsTest::testEditActionExtras, ScreenshotNotificationSmartActionsTest::testShareActionExtras, ScreenshotNotificationSmartActionsTest::testDeleteActionExtras"
   }
  ]
 },
 {
  "hash": "c916dad1dfd40b0a4031fb954ada07989121f607",
  "commit": "[DO NOT MERGE] Update quickshare intent rather than recreating\n\nCurrently, we extract the quickshare intent and re-wrap it as a new\nPendingIntent once we get the screenshot URI. This is insecure as\nit leads to executing the original with SysUI's permissions, which\nthe app may not have. This change switches to using Intent.fillin\nto add the URI, keeping the original PendingIntent and original\npermission set.\n\nBug: 278720336\nTest: manual (to test successful quickshare), atest\nSaveImageInBackgroundTaskTest (to verify original pending intent\nunchanged)\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:573d31ef204bc8bbf24a7341afe17870708c0904)\nMerged-In: Icad3d5f939fcfb894e2038948954bc2735dbe326\nChange-Id: Icad3d5f939fcfb894e2038948954bc2735dbe326\n\nChange-Id: I0fe48b575e68daf89de7dbcb98502bff84aa2658",
  "files": [
   {
    "filename": "SaveImageInBackgroundTask.java",
    "diff": "@@ -89,7 +89,8 @@ class SaveImageInBackgroundTask extends AsyncTask<String, Void, Void> {\n     SaveImageInBackgroundTask(Context context, ImageExporter exporter,\n             ScreenshotSmartActions screenshotSmartActions,\n             ScreenshotController.SaveImageInBackgroundData data,\n-            Supplier<ActionTransition> sharedElementTransition) {\n+            Supplier<ActionTransition> sharedElementTransition,\n+            boolean smartActionsEnabled) {\n         mContext = context;\n         mScreenshotSmartActions = screenshotSmartActions;\n         mImageData = new ScreenshotController.SavedImageData();\n@@ -101,8 +102,7 @@ class SaveImageInBackgroundTask extends AsyncTask<String, Void, Void> {\n         mParams = data;\n \n         // Initialize screenshot notification smart actions provider.\n-        mSmartActionsEnabled = DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_SYSTEMUI,\n-                SystemUiDeviceConfigFlags.ENABLE_SCREENSHOT_NOTIFICATION_SMART_ACTIONS, true);\n+        mSmartActionsEnabled = smartActionsEnabled;\n         if (mSmartActionsEnabled) {\n             mSmartActionsProvider =\n                     SystemUIFactory.getInstance()\n@@ -135,7 +135,12 @@ class SaveImageInBackgroundTask extends AsyncTask<String, Void, Void> {\n                 // Since Quick Share target recommendation does not rely on image URL, it is\n                 // queried and surfaced before image compress/export. Action intent would not be\n                 // used, because it does not contain image URL.\n-                queryQuickShareAction(image, user);\n+                Notification.Action quickShare =\n+                        queryQuickShareAction(mScreenshotId, image, user, null);\n+                if (quickShare != null) {\n+                    mQuickShareData.quickShareAction = quickShare;\n+                    mParams.mQuickShareActionsReadyListener.onActionsReady(mQuickShareData);\n+                }\n             }\n \n             // Call synchronously here since already on a background thread.\n@@ -170,8 +175,9 @@ class SaveImageInBackgroundTask extends AsyncTask<String, Void, Void> {\n             mImageData.shareTransition = createShareAction(mContext, mContext.getResources(), uri);\n             mImageData.editTransition = createEditAction(mContext, mContext.getResources(), uri);\n             mImageData.deleteAction = createDeleteAction(mContext, mContext.getResources(), uri);\n-            mImageData.quickShareAction = createQuickShareAction(mContext,\n-                    mQuickShareData.quickShareAction, uri);\n+            mImageData.quickShareAction = createQuickShareAction(\n+                    mQuickShareData.quickShareAction, mScreenshotId, uri, mImageTime, image,\n+                    user);\n \n             mParams.mActionsReadyListener.onActionsReady(mImageData);\n             if (DEBUG_CALLBACK) {\n@@ -454,60 +460,73 @@ class SaveImageInBackgroundTask extends AsyncTask<String, Void, Void> {\n     }\n \n     /**\n-     * Populate image uri into intent of Quick Share action.\n+     * Wrap the quickshare intent and populate the fillin intent with the URI\n      */\n     @VisibleForTesting\n-    private Notification.Action createQuickShareAction(Context context, Notification.Action action,\n-            Uri uri) {\n-        if (action == null) {\n+    Notification.Action createQuickShareAction(\n+            Notification.Action quickShare, String screenshotId, Uri uri, long imageTime,\n+            Bitmap image, UserHandle user) {\n+        if (quickShare == null) {\n             return null;\n+        } else if (quickShare.actionIntent.isImmutable()) {\n+            Notification.Action quickShareWithUri =\n+                    queryQuickShareAction(screenshotId, image, user, uri);\n+            if (quickShareWithUri == null\n+                    || !quickShareWithUri.title.toString().contentEquals(quickShare.title)) {\n+                return null;\n+            }\n+            quickShare = quickShareWithUri;\n         }\n-        // Populate image URI into Quick Share chip intent\n-        Intent sharingIntent = action.actionIntent.getIntent();\n-        sharingIntent.setType(\"image/png\");\n-        sharingIntent.putExtra(Intent.EXTRA_STREAM, uri);\n-        String subjectDate = DateFormat.getDateTimeInstance().format(new Date(mImageTime));\n+\n+        Intent wrappedIntent = new Intent(mContext, SmartActionsReceiver.class)\n+                .putExtra(ScreenshotController.EXTRA_ACTION_INTENT, quickShare.actionIntent)\n+                .putExtra(ScreenshotController.EXTRA_ACTION_INTENT_FILLIN,\n+                        createFillInIntent(uri, imageTime))\n+                .addFlags(Intent.FLAG_RECEIVER_FOREGROUND);\n+        Bundle extras = quickShare.getExtras();\n+        String actionType = extras.getString(\n+                ScreenshotNotificationSmartActionsProvider.ACTION_TYPE,\n+                ScreenshotNotificationSmartActionsProvider.DEFAULT_ACTION_TYPE);\n+        addIntentExtras(screenshotId, wrappedIntent, actionType, mSmartActionsEnabled);\n+        PendingIntent broadcastIntent =\n+                PendingIntent.getBroadcast(mContext, mRandom.nextInt(), wrappedIntent,\n+                        PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_IMMUTABLE);\n+        return new Notification.Action.Builder(quickShare.getIcon(), quickShare.title,\n+                broadcastIntent)\n+                .setContextual(true)\n+                .addExtras(extras)\n+                .build();\n+    }\n+\n+    private Intent createFillInIntent(Uri uri, long imageTime) {\n+        Intent fillIn = new Intent();\n+        fillIn.setType(\"image/png\");\n+        fillIn.putExtra(Intent.EXTRA_STREAM, uri);\n+        String subjectDate = DateFormat.getDateTimeInstance().format(new Date(imageTime));\n         String subject = String.format(SCREENSHOT_SHARE_SUBJECT_TEMPLATE, subjectDate);\n-        sharingIntent.putExtra(Intent.EXTRA_SUBJECT, subject);\n+        fillIn.putExtra(Intent.EXTRA_SUBJECT, subject);\n         // Include URI in ClipData also, so that grantPermission picks it up.\n         // We don't use setData here because some apps interpret this as \"to:\".\n-        ClipData clipdata = new ClipData(new ClipDescription(\"content\",\n-                new String[]{\"image/png\"}),\n+        ClipData clipData = new ClipData(\n+                new ClipDescription(\"content\", new String[]{\"image/png\"}),\n                 new ClipData.Item(uri));\n-        sharingIntent.setClipData(clipdata);\n-        sharingIntent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);\n-        PendingIntent updatedPendingIntent = PendingIntent.getActivity(\n-                context, 0, sharingIntent,\n-                PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_IMMUTABLE);\n-\n-        // Proxy smart actions through {@link GlobalScreenshot.SmartActionsReceiver}\n-        // for logging smart actions.\n-        Bundle extras = action.getExtras();\n-        String actionType = extras.getString(\n-                ScreenshotNotificationSmartActionsProvider.ACTION_TYPE,\n-                ScreenshotNotificationSmartActionsProvider.DEFAULT_ACTION_TYPE);\n-        Intent intent = new Intent(context, SmartActionsReceiver.class)\n-                .putExtra(ScreenshotController.EXTRA_ACTION_INTENT, updatedPendingIntent)\n-                .addFlags(Intent.FLAG_RECEIVER_FOREGROUND);\n-        addIntentExtras(mScreenshotId, intent, actionType, mSmartActionsEnabled);\n-        PendingIntent broadcastIntent = PendingIntent.getBroadcast(context,\n-                mRandom.nextInt(),\n-                intent,\n-                PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_IMMUTABLE);\n-        return new Notification.Action.Builder(action.getIcon(), action.title,\n-                broadcastIntent).setContextual(true).addExtras(extras).build();\n+        fillIn.setClipData(clipData);\n+        fillIn.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);\n+        return fillIn;\n     }\n \n     /**\n      * Query and surface Quick Share chip if it is available. Action intent would not be used,\n      * because it does not contain image URL which would be populated in {@link\n-     * #createQuickShareAction(Context, Notification.Action, Uri)}\n+     * #createQuickShareAction(Notification.Action, String, Uri, long, Bitmap, UserHandle)}\n      */\n-    private void queryQuickShareAction(Bitmap image, UserHandle user) {\n+\n+    @VisibleForTesting\n+    Notification.Action queryQuickShareAction(\n+            String screenshotId, Bitmap image, UserHandle user, Uri uri) {\n         CompletableFuture<List<Notification.Action>> quickShareActionsFuture =\n                 mScreenshotSmartActions.getSmartActionsFuture(\n-                        mScreenshotId, null, image, mSmartActionsProvider,\n-                        QUICK_SHARE_ACTION,\n+                        screenshotId, uri, image, mSmartActionsProvider, QUICK_SHARE_ACTION,\n                         mSmartActionsEnabled, user);\n         int timeoutMs = DeviceConfig.getInt(\n                 DeviceConfig.NAMESPACE_SYSTEMUI,\n@@ -515,11 +534,11 @@ class SaveImageInBackgroundTask extends AsyncTask<String, Void, Void> {\n                 500);\n         List<Notification.Action> quickShareActions =\n                 mScreenshotSmartActions.getSmartActions(\n-                        mScreenshotId, quickShareActionsFuture, timeoutMs,\n+                        screenshotId, quickShareActionsFuture, timeoutMs,\n                         mSmartActionsProvider, QUICK_SHARE_ACTION);\n         if (!quickShareActions.isEmpty()) {\n-            mQuickShareData.quickShareAction = quickShareActions.get(0);\n-            mParams.mQuickShareActionsReadyListener.onActionsReady(mQuickShareData);\n+            return quickShareActions.get(0);\n         }\n+        return null;\n     }\n }\n",
    "added_lines": 66,
    "deleted_lines": 47,
    "changed_methods": "SaveImageInBackgroundTask::createFillInIntent, SaveImageInBackgroundTask::SaveImageInBackgroundTask, SaveImageInBackgroundTask::createQuickShareAction, SaveImageInBackgroundTask::doInBackground, SaveImageInBackgroundTask::queryQuickShareAction, SaveImageInBackgroundTask::queryQuickShareAction, SaveImageInBackgroundTask::SaveImageInBackgroundTask, SaveImageInBackgroundTask::createQuickShareAction"
   },
   {
    "filename": "ScreenshotController.java",
    "diff": "@@ -62,6 +62,7 @@ import android.os.Message;\n import android.os.RemoteException;\n import android.os.VibrationEffect;\n import android.os.Vibrator;\n+import android.provider.DeviceConfig;\n import android.provider.Settings;\n import android.util.DisplayMetrics;\n import android.util.Log;\n@@ -88,6 +89,7 @@ import android.widget.Toast;\n import android.window.WindowContext;\n \n import com.android.internal.app.ChooserActivity;\n+import com.android.internal.config.sysui.SystemUiDeviceConfigFlags;\n import com.android.internal.logging.UiEventLogger;\n import com.android.internal.policy.PhoneWindow;\n import com.android.internal.statusbar.IStatusBarService;\n@@ -237,6 +239,7 @@ public class ScreenshotController {\n     static final String EXTRA_SMART_ACTIONS_ENABLED = \"android:smart_actions_enabled\";\n     static final String EXTRA_OVERRIDE_TRANSITION = \"android:screenshot_override_transition\";\n     static final String EXTRA_ACTION_INTENT = \"android:screenshot_action_intent\";\n+    static final String EXTRA_ACTION_INTENT_FILLIN = \"android:screenshot_action_intent_fillin\";\n \n     static final String SCREENSHOT_URI_ID = \"android:screenshot_uri_id\";\n     static final String EXTRA_CANCEL_NOTIFICATION = \"android:screenshot_cancel_notification\";\n@@ -961,8 +964,11 @@ public class ScreenshotController {\n             mSaveInBgTask.setActionsReadyListener(this::logSuccessOnActionsReady);\n         }\n \n+        boolean smartActionsEnabled = DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_SYSTEMUI,\n+                SystemUiDeviceConfigFlags.ENABLE_SCREENSHOT_NOTIFICATION_SMART_ACTIONS, true);\n+\n         mSaveInBgTask = new SaveImageInBackgroundTask(mContext, mImageExporter,\n-                mScreenshotSmartActions, data, getActionTransitionSupplier());\n+                mScreenshotSmartActions, data, getActionTransitionSupplier(), smartActionsEnabled);\n         mSaveInBgTask.execute(getForegroundAppLabel());\n     }\n \n",
    "added_lines": 7,
    "deleted_lines": 1,
    "changed_methods": "ScreenshotController::saveScreenshotInWorkerThread"
   },
   {
    "filename": "SmartActionsReceiver.java",
    "diff": "@@ -18,6 +18,7 @@ package com.android.systemui.screenshot;\n \n import static com.android.systemui.screenshot.LogConfig.DEBUG_ACTIONS;\n import static com.android.systemui.screenshot.ScreenshotController.EXTRA_ACTION_INTENT;\n+import static com.android.systemui.screenshot.ScreenshotController.EXTRA_ACTION_INTENT_FILLIN;\n import static com.android.systemui.screenshot.ScreenshotController.EXTRA_ACTION_TYPE;\n import static com.android.systemui.screenshot.ScreenshotController.EXTRA_ID;\n \n@@ -47,6 +48,7 @@ public class SmartActionsReceiver extends BroadcastReceiver {\n     @Override\n     public void onReceive(Context context, Intent intent) {\n         PendingIntent pendingIntent = intent.getParcelableExtra(EXTRA_ACTION_INTENT);\n+        Intent fillIn = intent.getParcelableExtra(EXTRA_ACTION_INTENT_FILLIN);\n         String actionType = intent.getStringExtra(EXTRA_ACTION_TYPE);\n         if (DEBUG_ACTIONS) {\n             Log.d(TAG, \"Executing smart action [\" + actionType + \"]:\" + pendingIntent.getIntent());\n@@ -54,7 +56,7 @@ public class SmartActionsReceiver extends BroadcastReceiver {\n         ActivityOptions opts = ActivityOptions.makeBasic();\n \n         try {\n-            pendingIntent.send(context, 0, null, null, null, null, opts.toBundle());\n+            pendingIntent.send(context, 0, fillIn, null, null, null, opts.toBundle());\n         } catch (PendingIntent.CanceledException e) {\n             Log.e(TAG, \"Pending intent canceled\", e);\n         }\n",
    "added_lines": 3,
    "deleted_lines": 1,
    "changed_methods": "SmartActionsReceiver::onReceive"
   },
   {
    "filename": "ScreenshotNotificationSmartActionsTest.java",
    "diff": "@@ -211,7 +211,7 @@ public class ScreenshotNotificationSmartActionsTest extends SysuiTestCase {\n         data.mActionsReadyListener = null;\n         SaveImageInBackgroundTask task =\n                 new SaveImageInBackgroundTask(mContext, null, mScreenshotSmartActions, data,\n-                        ActionTransition::new);\n+                        ActionTransition::new, false);\n \n         Notification.Action shareAction = task.createShareAction(mContext, mContext.getResources(),\n                 Uri.parse(\"Screenshot_123.png\")).get().action;\n@@ -239,7 +239,7 @@ public class ScreenshotNotificationSmartActionsTest extends SysuiTestCase {\n         data.mActionsReadyListener = null;\n         SaveImageInBackgroundTask task =\n                 new SaveImageInBackgroundTask(mContext, null, mScreenshotSmartActions, data,\n-                        ActionTransition::new);\n+                        ActionTransition::new, false);\n \n         Notification.Action editAction = task.createEditAction(mContext, mContext.getResources(),\n                 Uri.parse(\"Screenshot_123.png\")).get().action;\n@@ -267,7 +267,7 @@ public class ScreenshotNotificationSmartActionsTest extends SysuiTestCase {\n         data.mActionsReadyListener = null;\n         SaveImageInBackgroundTask task =\n                 new SaveImageInBackgroundTask(mContext, null, mScreenshotSmartActions, data,\n-                        ActionTransition::new);\n+                        ActionTransition::new, false);\n \n         Notification.Action deleteAction = task.createDeleteAction(mContext,\n                 mContext.getResources(),\n",
    "added_lines": 3,
    "deleted_lines": 3,
    "changed_methods": "ScreenshotNotificationSmartActionsTest::testEditActionExtras, ScreenshotNotificationSmartActionsTest::testShareActionExtras, ScreenshotNotificationSmartActionsTest::testDeleteActionExtras"
   }
  ]
 },
 {
  "hash": "c916dad1dfd40b0a4031fb954ada07989121f607",
  "commit": "[DO NOT MERGE] Update quickshare intent rather than recreating\n\nCurrently, we extract the quickshare intent and re-wrap it as a new\nPendingIntent once we get the screenshot URI. This is insecure as\nit leads to executing the original with SysUI's permissions, which\nthe app may not have. This change switches to using Intent.fillin\nto add the URI, keeping the original PendingIntent and original\npermission set.\n\nBug: 278720336\nTest: manual (to test successful quickshare), atest\nSaveImageInBackgroundTaskTest (to verify original pending intent\nunchanged)\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:573d31ef204bc8bbf24a7341afe17870708c0904)\nMerged-In: Icad3d5f939fcfb894e2038948954bc2735dbe326\nChange-Id: Icad3d5f939fcfb894e2038948954bc2735dbe326\n\nChange-Id: I0fe48b575e68daf89de7dbcb98502bff84aa2658",
  "files": [
   {
    "filename": "SaveImageInBackgroundTask.java",
    "diff": "@@ -89,7 +89,8 @@ class SaveImageInBackgroundTask extends AsyncTask<String, Void, Void> {\n     SaveImageInBackgroundTask(Context context, ImageExporter exporter,\n             ScreenshotSmartActions screenshotSmartActions,\n             ScreenshotController.SaveImageInBackgroundData data,\n-            Supplier<ActionTransition> sharedElementTransition) {\n+            Supplier<ActionTransition> sharedElementTransition,\n+            boolean smartActionsEnabled) {\n         mContext = context;\n         mScreenshotSmartActions = screenshotSmartActions;\n         mImageData = new ScreenshotController.SavedImageData();\n@@ -101,8 +102,7 @@ class SaveImageInBackgroundTask extends AsyncTask<String, Void, Void> {\n         mParams = data;\n \n         // Initialize screenshot notification smart actions provider.\n-        mSmartActionsEnabled = DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_SYSTEMUI,\n-                SystemUiDeviceConfigFlags.ENABLE_SCREENSHOT_NOTIFICATION_SMART_ACTIONS, true);\n+        mSmartActionsEnabled = smartActionsEnabled;\n         if (mSmartActionsEnabled) {\n             mSmartActionsProvider =\n                     SystemUIFactory.getInstance()\n@@ -135,7 +135,12 @@ class SaveImageInBackgroundTask extends AsyncTask<String, Void, Void> {\n                 // Since Quick Share target recommendation does not rely on image URL, it is\n                 // queried and surfaced before image compress/export. Action intent would not be\n                 // used, because it does not contain image URL.\n-                queryQuickShareAction(image, user);\n+                Notification.Action quickShare =\n+                        queryQuickShareAction(mScreenshotId, image, user, null);\n+                if (quickShare != null) {\n+                    mQuickShareData.quickShareAction = quickShare;\n+                    mParams.mQuickShareActionsReadyListener.onActionsReady(mQuickShareData);\n+                }\n             }\n \n             // Call synchronously here since already on a background thread.\n@@ -170,8 +175,9 @@ class SaveImageInBackgroundTask extends AsyncTask<String, Void, Void> {\n             mImageData.shareTransition = createShareAction(mContext, mContext.getResources(), uri);\n             mImageData.editTransition = createEditAction(mContext, mContext.getResources(), uri);\n             mImageData.deleteAction = createDeleteAction(mContext, mContext.getResources(), uri);\n-            mImageData.quickShareAction = createQuickShareAction(mContext,\n-                    mQuickShareData.quickShareAction, uri);\n+            mImageData.quickShareAction = createQuickShareAction(\n+                    mQuickShareData.quickShareAction, mScreenshotId, uri, mImageTime, image,\n+                    user);\n \n             mParams.mActionsReadyListener.onActionsReady(mImageData);\n             if (DEBUG_CALLBACK) {\n@@ -454,60 +460,73 @@ class SaveImageInBackgroundTask extends AsyncTask<String, Void, Void> {\n     }\n \n     /**\n-     * Populate image uri into intent of Quick Share action.\n+     * Wrap the quickshare intent and populate the fillin intent with the URI\n      */\n     @VisibleForTesting\n-    private Notification.Action createQuickShareAction(Context context, Notification.Action action,\n-            Uri uri) {\n-        if (action == null) {\n+    Notification.Action createQuickShareAction(\n+            Notification.Action quickShare, String screenshotId, Uri uri, long imageTime,\n+            Bitmap image, UserHandle user) {\n+        if (quickShare == null) {\n             return null;\n+        } else if (quickShare.actionIntent.isImmutable()) {\n+            Notification.Action quickShareWithUri =\n+                    queryQuickShareAction(screenshotId, image, user, uri);\n+            if (quickShareWithUri == null\n+                    || !quickShareWithUri.title.toString().contentEquals(quickShare.title)) {\n+                return null;\n+            }\n+            quickShare = quickShareWithUri;\n         }\n-        // Populate image URI into Quick Share chip intent\n-        Intent sharingIntent = action.actionIntent.getIntent();\n-        sharingIntent.setType(\"image/png\");\n-        sharingIntent.putExtra(Intent.EXTRA_STREAM, uri);\n-        String subjectDate = DateFormat.getDateTimeInstance().format(new Date(mImageTime));\n+\n+        Intent wrappedIntent = new Intent(mContext, SmartActionsReceiver.class)\n+                .putExtra(ScreenshotController.EXTRA_ACTION_INTENT, quickShare.actionIntent)\n+                .putExtra(ScreenshotController.EXTRA_ACTION_INTENT_FILLIN,\n+                        createFillInIntent(uri, imageTime))\n+                .addFlags(Intent.FLAG_RECEIVER_FOREGROUND);\n+        Bundle extras = quickShare.getExtras();\n+        String actionType = extras.getString(\n+                ScreenshotNotificationSmartActionsProvider.ACTION_TYPE,\n+                ScreenshotNotificationSmartActionsProvider.DEFAULT_ACTION_TYPE);\n+        addIntentExtras(screenshotId, wrappedIntent, actionType, mSmartActionsEnabled);\n+        PendingIntent broadcastIntent =\n+                PendingIntent.getBroadcast(mContext, mRandom.nextInt(), wrappedIntent,\n+                        PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_IMMUTABLE);\n+        return new Notification.Action.Builder(quickShare.getIcon(), quickShare.title,\n+                broadcastIntent)\n+                .setContextual(true)\n+                .addExtras(extras)\n+                .build();\n+    }\n+\n+    private Intent createFillInIntent(Uri uri, long imageTime) {\n+        Intent fillIn = new Intent();\n+        fillIn.setType(\"image/png\");\n+        fillIn.putExtra(Intent.EXTRA_STREAM, uri);\n+        String subjectDate = DateFormat.getDateTimeInstance().format(new Date(imageTime));\n         String subject = String.format(SCREENSHOT_SHARE_SUBJECT_TEMPLATE, subjectDate);\n-        sharingIntent.putExtra(Intent.EXTRA_SUBJECT, subject);\n+        fillIn.putExtra(Intent.EXTRA_SUBJECT, subject);\n         // Include URI in ClipData also, so that grantPermission picks it up.\n         // We don't use setData here because some apps interpret this as \"to:\".\n-        ClipData clipdata = new ClipData(new ClipDescription(\"content\",\n-                new String[]{\"image/png\"}),\n+        ClipData clipData = new ClipData(\n+                new ClipDescription(\"content\", new String[]{\"image/png\"}),\n                 new ClipData.Item(uri));\n-        sharingIntent.setClipData(clipdata);\n-        sharingIntent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);\n-        PendingIntent updatedPendingIntent = PendingIntent.getActivity(\n-                context, 0, sharingIntent,\n-                PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_IMMUTABLE);\n-\n-        // Proxy smart actions through {@link GlobalScreenshot.SmartActionsReceiver}\n-        // for logging smart actions.\n-        Bundle extras = action.getExtras();\n-        String actionType = extras.getString(\n-                ScreenshotNotificationSmartActionsProvider.ACTION_TYPE,\n-                ScreenshotNotificationSmartActionsProvider.DEFAULT_ACTION_TYPE);\n-        Intent intent = new Intent(context, SmartActionsReceiver.class)\n-                .putExtra(ScreenshotController.EXTRA_ACTION_INTENT, updatedPendingIntent)\n-                .addFlags(Intent.FLAG_RECEIVER_FOREGROUND);\n-        addIntentExtras(mScreenshotId, intent, actionType, mSmartActionsEnabled);\n-        PendingIntent broadcastIntent = PendingIntent.getBroadcast(context,\n-                mRandom.nextInt(),\n-                intent,\n-                PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_IMMUTABLE);\n-        return new Notification.Action.Builder(action.getIcon(), action.title,\n-                broadcastIntent).setContextual(true).addExtras(extras).build();\n+        fillIn.setClipData(clipData);\n+        fillIn.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);\n+        return fillIn;\n     }\n \n     /**\n      * Query and surface Quick Share chip if it is available. Action intent would not be used,\n      * because it does not contain image URL which would be populated in {@link\n-     * #createQuickShareAction(Context, Notification.Action, Uri)}\n+     * #createQuickShareAction(Notification.Action, String, Uri, long, Bitmap, UserHandle)}\n      */\n-    private void queryQuickShareAction(Bitmap image, UserHandle user) {\n+\n+    @VisibleForTesting\n+    Notification.Action queryQuickShareAction(\n+            String screenshotId, Bitmap image, UserHandle user, Uri uri) {\n         CompletableFuture<List<Notification.Action>> quickShareActionsFuture =\n                 mScreenshotSmartActions.getSmartActionsFuture(\n-                        mScreenshotId, null, image, mSmartActionsProvider,\n-                        QUICK_SHARE_ACTION,\n+                        screenshotId, uri, image, mSmartActionsProvider, QUICK_SHARE_ACTION,\n                         mSmartActionsEnabled, user);\n         int timeoutMs = DeviceConfig.getInt(\n                 DeviceConfig.NAMESPACE_SYSTEMUI,\n@@ -515,11 +534,11 @@ class SaveImageInBackgroundTask extends AsyncTask<String, Void, Void> {\n                 500);\n         List<Notification.Action> quickShareActions =\n                 mScreenshotSmartActions.getSmartActions(\n-                        mScreenshotId, quickShareActionsFuture, timeoutMs,\n+                        screenshotId, quickShareActionsFuture, timeoutMs,\n                         mSmartActionsProvider, QUICK_SHARE_ACTION);\n         if (!quickShareActions.isEmpty()) {\n-            mQuickShareData.quickShareAction = quickShareActions.get(0);\n-            mParams.mQuickShareActionsReadyListener.onActionsReady(mQuickShareData);\n+            return quickShareActions.get(0);\n         }\n+        return null;\n     }\n }\n",
    "added_lines": 66,
    "deleted_lines": 47,
    "changed_methods": "SaveImageInBackgroundTask::createFillInIntent, SaveImageInBackgroundTask::SaveImageInBackgroundTask, SaveImageInBackgroundTask::createQuickShareAction, SaveImageInBackgroundTask::doInBackground, SaveImageInBackgroundTask::queryQuickShareAction, SaveImageInBackgroundTask::queryQuickShareAction, SaveImageInBackgroundTask::SaveImageInBackgroundTask, SaveImageInBackgroundTask::createQuickShareAction"
   },
   {
    "filename": "ScreenshotController.java",
    "diff": "@@ -62,6 +62,7 @@ import android.os.Message;\n import android.os.RemoteException;\n import android.os.VibrationEffect;\n import android.os.Vibrator;\n+import android.provider.DeviceConfig;\n import android.provider.Settings;\n import android.util.DisplayMetrics;\n import android.util.Log;\n@@ -88,6 +89,7 @@ import android.widget.Toast;\n import android.window.WindowContext;\n \n import com.android.internal.app.ChooserActivity;\n+import com.android.internal.config.sysui.SystemUiDeviceConfigFlags;\n import com.android.internal.logging.UiEventLogger;\n import com.android.internal.policy.PhoneWindow;\n import com.android.internal.statusbar.IStatusBarService;\n@@ -237,6 +239,7 @@ public class ScreenshotController {\n     static final String EXTRA_SMART_ACTIONS_ENABLED = \"android:smart_actions_enabled\";\n     static final String EXTRA_OVERRIDE_TRANSITION = \"android:screenshot_override_transition\";\n     static final String EXTRA_ACTION_INTENT = \"android:screenshot_action_intent\";\n+    static final String EXTRA_ACTION_INTENT_FILLIN = \"android:screenshot_action_intent_fillin\";\n \n     static final String SCREENSHOT_URI_ID = \"android:screenshot_uri_id\";\n     static final String EXTRA_CANCEL_NOTIFICATION = \"android:screenshot_cancel_notification\";\n@@ -961,8 +964,11 @@ public class ScreenshotController {\n             mSaveInBgTask.setActionsReadyListener(this::logSuccessOnActionsReady);\n         }\n \n+        boolean smartActionsEnabled = DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_SYSTEMUI,\n+                SystemUiDeviceConfigFlags.ENABLE_SCREENSHOT_NOTIFICATION_SMART_ACTIONS, true);\n+\n         mSaveInBgTask = new SaveImageInBackgroundTask(mContext, mImageExporter,\n-                mScreenshotSmartActions, data, getActionTransitionSupplier());\n+                mScreenshotSmartActions, data, getActionTransitionSupplier(), smartActionsEnabled);\n         mSaveInBgTask.execute(getForegroundAppLabel());\n     }\n \n",
    "added_lines": 7,
    "deleted_lines": 1,
    "changed_methods": "ScreenshotController::saveScreenshotInWorkerThread"
   },
   {
    "filename": "SmartActionsReceiver.java",
    "diff": "@@ -18,6 +18,7 @@ package com.android.systemui.screenshot;\n \n import static com.android.systemui.screenshot.LogConfig.DEBUG_ACTIONS;\n import static com.android.systemui.screenshot.ScreenshotController.EXTRA_ACTION_INTENT;\n+import static com.android.systemui.screenshot.ScreenshotController.EXTRA_ACTION_INTENT_FILLIN;\n import static com.android.systemui.screenshot.ScreenshotController.EXTRA_ACTION_TYPE;\n import static com.android.systemui.screenshot.ScreenshotController.EXTRA_ID;\n \n@@ -47,6 +48,7 @@ public class SmartActionsReceiver extends BroadcastReceiver {\n     @Override\n     public void onReceive(Context context, Intent intent) {\n         PendingIntent pendingIntent = intent.getParcelableExtra(EXTRA_ACTION_INTENT);\n+        Intent fillIn = intent.getParcelableExtra(EXTRA_ACTION_INTENT_FILLIN);\n         String actionType = intent.getStringExtra(EXTRA_ACTION_TYPE);\n         if (DEBUG_ACTIONS) {\n             Log.d(TAG, \"Executing smart action [\" + actionType + \"]:\" + pendingIntent.getIntent());\n@@ -54,7 +56,7 @@ public class SmartActionsReceiver extends BroadcastReceiver {\n         ActivityOptions opts = ActivityOptions.makeBasic();\n \n         try {\n-            pendingIntent.send(context, 0, null, null, null, null, opts.toBundle());\n+            pendingIntent.send(context, 0, fillIn, null, null, null, opts.toBundle());\n         } catch (PendingIntent.CanceledException e) {\n             Log.e(TAG, \"Pending intent canceled\", e);\n         }\n",
    "added_lines": 3,
    "deleted_lines": 1,
    "changed_methods": "SmartActionsReceiver::onReceive"
   },
   {
    "filename": "ScreenshotNotificationSmartActionsTest.java",
    "diff": "@@ -211,7 +211,7 @@ public class ScreenshotNotificationSmartActionsTest extends SysuiTestCase {\n         data.mActionsReadyListener = null;\n         SaveImageInBackgroundTask task =\n                 new SaveImageInBackgroundTask(mContext, null, mScreenshotSmartActions, data,\n-                        ActionTransition::new);\n+                        ActionTransition::new, false);\n \n         Notification.Action shareAction = task.createShareAction(mContext, mContext.getResources(),\n                 Uri.parse(\"Screenshot_123.png\")).get().action;\n@@ -239,7 +239,7 @@ public class ScreenshotNotificationSmartActionsTest extends SysuiTestCase {\n         data.mActionsReadyListener = null;\n         SaveImageInBackgroundTask task =\n                 new SaveImageInBackgroundTask(mContext, null, mScreenshotSmartActions, data,\n-                        ActionTransition::new);\n+                        ActionTransition::new, false);\n \n         Notification.Action editAction = task.createEditAction(mContext, mContext.getResources(),\n                 Uri.parse(\"Screenshot_123.png\")).get().action;\n@@ -267,7 +267,7 @@ public class ScreenshotNotificationSmartActionsTest extends SysuiTestCase {\n         data.mActionsReadyListener = null;\n         SaveImageInBackgroundTask task =\n                 new SaveImageInBackgroundTask(mContext, null, mScreenshotSmartActions, data,\n-                        ActionTransition::new);\n+                        ActionTransition::new, false);\n \n         Notification.Action deleteAction = task.createDeleteAction(mContext,\n                 mContext.getResources(),\n",
    "added_lines": 3,
    "deleted_lines": 3,
    "changed_methods": "ScreenshotNotificationSmartActionsTest::testEditActionExtras, ScreenshotNotificationSmartActionsTest::testShareActionExtras, ScreenshotNotificationSmartActionsTest::testDeleteActionExtras"
   }
  ]
 },
 {
  "hash": "f5fd00ab73631e1a840445cae87077517e83ffc4",
  "commit": "Ignore virtual presentation windows - RESTRICT AUTOMERGE\n\nWindows of TYPE_PRESENTATION on virtual displays should not be counted\nas visible windows to determine if BAL is allowed.\n\nTest: manual test, atest BackgroundActivityLaunchTest\nBug: 264029851, 205130886\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:bf60a0c6f153a55714d4879bb6cf5b239381a22a)\nMerged-In: I08b16ba1c155e951286ddc22019180cbd6334dfa\nChange-Id: I08b16ba1c155e951286ddc22019180cbd6334dfa",
  "files": [
   {
    "filename": "WindowState.java",
    "diff": "@@ -3616,8 +3616,12 @@ class WindowState extends WindowContainer<WindowState> implements WindowManagerP\n         // apps won't always be considered as foreground state.\n         // Exclude private presentations as they can only be shown on private virtual displays and\n         // shouldn't be the cause of an app be considered foreground.\n-        if (mAttrs.type >= FIRST_SYSTEM_WINDOW && mAttrs.type != TYPE_TOAST\n-                && mAttrs.type != TYPE_PRIVATE_PRESENTATION) {\n+        // Exclude presentations on virtual displays as they are not actually visible.\n+        if (mAttrs.type >= FIRST_SYSTEM_WINDOW\n+                && mAttrs.type != TYPE_TOAST\n+                && mAttrs.type != TYPE_PRIVATE_PRESENTATION\n+                && !(mAttrs.type == TYPE_PRESENTATION && isOnVirtualDisplay())\n+        ) {\n             mWmService.mAtmService.mActiveUids.onNonAppSurfaceVisibilityChanged(mOwnerUid, shown);\n         }\n         if (mIsImWindow && mWmService.mAccessibilityController.hasCallbacks()) {\n@@ -3625,6 +3629,10 @@ class WindowState extends WindowContainer<WindowState> implements WindowManagerP\n         }\n     }\n \n+    private boolean isOnVirtualDisplay() {\n+        return getDisplayContent().mDisplay.getType() == Display.TYPE_VIRTUAL;\n+    }\n+\n     private void logExclusionRestrictions(int side) {\n         if (!logsGestureExclusionRestrictions(this)\n                 || SystemClock.uptimeMillis() < mLastExclusionLogUptimeMillis[side]\n",
    "added_lines": 10,
    "deleted_lines": 2,
    "changed_methods": "WindowState::isOnVirtualDisplay, WindowState::onSurfaceShownChanged"
   }
  ]
 },
 {
  "hash": "83ee559375e3286e01ce4c66f0905fee007278ca",
  "commit": "Forbid granting access to NLSes with too-long component names\n\nThis makes the limitation, which was previously only checked on the Settings UI, enforced everywhere.\n\nFixes: 260570119\nFixes: 286043036\nTest: atest + manually\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:8a40b0b3a17658af16922b4ba99ccc4258af89f5)\nMerged-In: I4c25d80978cb37a8fa1531f5045259d25ac64692\nChange-Id: I4c25d80978cb37a8fa1531f5045259d25ac64692",
  "files": [
   {
    "filename": "NotificationManager.java",
    "diff": "@@ -561,6 +561,12 @@ public class NotificationManager {\n      */\n     public static final int BUBBLE_PREFERENCE_SELECTED = 2;\n \n+    /**\n+     * Maximum length of the component name of a registered NotificationListenerService.\n+     * @hide\n+     */\n+    public static int MAX_SERVICE_COMPONENT_NAME_LENGTH = 500;\n+\n     @UnsupportedAppUsage\n     private static INotificationManager sService;\n \n",
    "added_lines": 6,
    "deleted_lines": 0,
    "changed_methods": ""
   },
   {
    "filename": "NotificationManagerService.java",
    "diff": "@@ -5296,6 +5296,11 @@ public class NotificationManagerService extends SystemService {\n                 boolean granted, boolean userSet) {\n             Objects.requireNonNull(listener);\n             checkNotificationListenerAccess();\n+            if (granted && listener.flattenToString().length()\n+                    > NotificationManager.MAX_SERVICE_COMPONENT_NAME_LENGTH) {\n+                throw new IllegalArgumentException(\n+                        \"Component name too long: \" + listener.flattenToString());\n+            }\n             if (!userSet && isNotificationListenerAccessUserSet(listener)) {\n                 // Don't override user's choice\n                 return;\n",
    "added_lines": 5,
    "deleted_lines": 0,
    "changed_methods": "NotificationManagerService::Stub"
   },
   {
    "filename": "VrManagerService.java",
    "diff": "@@ -1049,7 +1049,11 @@ public class VrManagerService extends SystemService\n \n         for (ComponentName c : possibleServices) {\n             if (Objects.equals(c.getPackageName(), pkg)) {\n-                nm.setNotificationListenerAccessGrantedForUser(c, userId, true);\n+                try {\n+                    nm.setNotificationListenerAccessGrantedForUser(c, userId, true);\n+                } catch (Exception e) {\n+                    Slog.w(TAG, \"Could not grant NLS access to package \" + pkg, e);\n+                }\n             }\n         }\n     }\n",
    "added_lines": 5,
    "deleted_lines": 1,
    "changed_methods": "VrManagerService::grantNotificationListenerAccess"
   },
   {
    "filename": "NotificationManagerServiceTest.java",
    "diff": "@@ -74,6 +74,7 @@ import static junit.framework.Assert.assertNull;\n import static junit.framework.Assert.assertTrue;\n import static junit.framework.Assert.fail;\n \n+import static org.junit.Assert.assertThrows;\n import static org.mockito.ArgumentMatchers.isNull;\n import static org.mockito.Matchers.anyBoolean;\n import static org.mockito.Matchers.anyLong;\n@@ -3166,6 +3167,30 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n                 any(), anyInt(), anyBoolean(), anyBoolean(), anyBoolean());\n     }\n \n+    @Test\n+    public void testSetListenerAccessForUser_grantWithNameTooLong_throws() {\n+        UserHandle user = UserHandle.of(mContext.getUserId() + 10);\n+        ComponentName c = new ComponentName(\"com.example.package\",\n+                com.google.common.base.Strings.repeat(\"Blah\", 150));\n+\n+        assertThrows(IllegalArgumentException.class,\n+                () -> mBinderService.setNotificationListenerAccessGrantedForUser(\n+                        c, user.getIdentifier(), /* enabled= */ true, true));\n+    }\n+\n+    @Test\n+    public void testSetListenerAccessForUser_revokeWithNameTooLong_okay() throws Exception {\n+        UserHandle user = UserHandle.of(mContext.getUserId() + 10);\n+        ComponentName c = new ComponentName(\"com.example.package\",\n+                com.google.common.base.Strings.repeat(\"Blah\", 150));\n+\n+        mBinderService.setNotificationListenerAccessGrantedForUser(\n+                c, user.getIdentifier(), /* enabled= */ false, true);\n+\n+        verify(mListeners).setPackageOrComponentEnabled(\n+                c.flattenToString(), user.getIdentifier(), true, /* enabled= */ false, true);\n+    }\n+\n     @Test\n     public void testSetAssistantAccessForUser() throws Exception {\n         UserInfo ui = new UserInfo();\n",
    "added_lines": 25,
    "deleted_lines": 0,
    "changed_methods": "NotificationManagerServiceTest::testSetListenerAccessForUser_grantWithNameTooLong_throws, NotificationManagerServiceTest::testSetListenerAccessForUser_revokeWithNameTooLong_okay"
   }
  ]
 },
 {
  "hash": "83ee559375e3286e01ce4c66f0905fee007278ca",
  "commit": "Forbid granting access to NLSes with too-long component names\n\nThis makes the limitation, which was previously only checked on the Settings UI, enforced everywhere.\n\nFixes: 260570119\nFixes: 286043036\nTest: atest + manually\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:8a40b0b3a17658af16922b4ba99ccc4258af89f5)\nMerged-In: I4c25d80978cb37a8fa1531f5045259d25ac64692\nChange-Id: I4c25d80978cb37a8fa1531f5045259d25ac64692",
  "files": [
   {
    "filename": "NotificationManager.java",
    "diff": "@@ -561,6 +561,12 @@ public class NotificationManager {\n      */\n     public static final int BUBBLE_PREFERENCE_SELECTED = 2;\n \n+    /**\n+     * Maximum length of the component name of a registered NotificationListenerService.\n+     * @hide\n+     */\n+    public static int MAX_SERVICE_COMPONENT_NAME_LENGTH = 500;\n+\n     @UnsupportedAppUsage\n     private static INotificationManager sService;\n \n",
    "added_lines": 6,
    "deleted_lines": 0,
    "changed_methods": ""
   },
   {
    "filename": "NotificationManagerService.java",
    "diff": "@@ -5296,6 +5296,11 @@ public class NotificationManagerService extends SystemService {\n                 boolean granted, boolean userSet) {\n             Objects.requireNonNull(listener);\n             checkNotificationListenerAccess();\n+            if (granted && listener.flattenToString().length()\n+                    > NotificationManager.MAX_SERVICE_COMPONENT_NAME_LENGTH) {\n+                throw new IllegalArgumentException(\n+                        \"Component name too long: \" + listener.flattenToString());\n+            }\n             if (!userSet && isNotificationListenerAccessUserSet(listener)) {\n                 // Don't override user's choice\n                 return;\n",
    "added_lines": 5,
    "deleted_lines": 0,
    "changed_methods": "NotificationManagerService::Stub"
   },
   {
    "filename": "VrManagerService.java",
    "diff": "@@ -1049,7 +1049,11 @@ public class VrManagerService extends SystemService\n \n         for (ComponentName c : possibleServices) {\n             if (Objects.equals(c.getPackageName(), pkg)) {\n-                nm.setNotificationListenerAccessGrantedForUser(c, userId, true);\n+                try {\n+                    nm.setNotificationListenerAccessGrantedForUser(c, userId, true);\n+                } catch (Exception e) {\n+                    Slog.w(TAG, \"Could not grant NLS access to package \" + pkg, e);\n+                }\n             }\n         }\n     }\n",
    "added_lines": 5,
    "deleted_lines": 1,
    "changed_methods": "VrManagerService::grantNotificationListenerAccess"
   },
   {
    "filename": "NotificationManagerServiceTest.java",
    "diff": "@@ -74,6 +74,7 @@ import static junit.framework.Assert.assertNull;\n import static junit.framework.Assert.assertTrue;\n import static junit.framework.Assert.fail;\n \n+import static org.junit.Assert.assertThrows;\n import static org.mockito.ArgumentMatchers.isNull;\n import static org.mockito.Matchers.anyBoolean;\n import static org.mockito.Matchers.anyLong;\n@@ -3166,6 +3167,30 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n                 any(), anyInt(), anyBoolean(), anyBoolean(), anyBoolean());\n     }\n \n+    @Test\n+    public void testSetListenerAccessForUser_grantWithNameTooLong_throws() {\n+        UserHandle user = UserHandle.of(mContext.getUserId() + 10);\n+        ComponentName c = new ComponentName(\"com.example.package\",\n+                com.google.common.base.Strings.repeat(\"Blah\", 150));\n+\n+        assertThrows(IllegalArgumentException.class,\n+                () -> mBinderService.setNotificationListenerAccessGrantedForUser(\n+                        c, user.getIdentifier(), /* enabled= */ true, true));\n+    }\n+\n+    @Test\n+    public void testSetListenerAccessForUser_revokeWithNameTooLong_okay() throws Exception {\n+        UserHandle user = UserHandle.of(mContext.getUserId() + 10);\n+        ComponentName c = new ComponentName(\"com.example.package\",\n+                com.google.common.base.Strings.repeat(\"Blah\", 150));\n+\n+        mBinderService.setNotificationListenerAccessGrantedForUser(\n+                c, user.getIdentifier(), /* enabled= */ false, true);\n+\n+        verify(mListeners).setPackageOrComponentEnabled(\n+                c.flattenToString(), user.getIdentifier(), true, /* enabled= */ false, true);\n+    }\n+\n     @Test\n     public void testSetAssistantAccessForUser() throws Exception {\n         UserInfo ui = new UserInfo();\n",
    "added_lines": 25,
    "deleted_lines": 0,
    "changed_methods": "NotificationManagerServiceTest::testSetListenerAccessForUser_grantWithNameTooLong_throws, NotificationManagerServiceTest::testSetListenerAccessForUser_revokeWithNameTooLong_okay"
   }
  ]
 },
 {
  "hash": "83ee559375e3286e01ce4c66f0905fee007278ca",
  "commit": "Forbid granting access to NLSes with too-long component names\n\nThis makes the limitation, which was previously only checked on the Settings UI, enforced everywhere.\n\nFixes: 260570119\nFixes: 286043036\nTest: atest + manually\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:8a40b0b3a17658af16922b4ba99ccc4258af89f5)\nMerged-In: I4c25d80978cb37a8fa1531f5045259d25ac64692\nChange-Id: I4c25d80978cb37a8fa1531f5045259d25ac64692",
  "files": [
   {
    "filename": "NotificationManager.java",
    "diff": "@@ -561,6 +561,12 @@ public class NotificationManager {\n      */\n     public static final int BUBBLE_PREFERENCE_SELECTED = 2;\n \n+    /**\n+     * Maximum length of the component name of a registered NotificationListenerService.\n+     * @hide\n+     */\n+    public static int MAX_SERVICE_COMPONENT_NAME_LENGTH = 500;\n+\n     @UnsupportedAppUsage\n     private static INotificationManager sService;\n \n",
    "added_lines": 6,
    "deleted_lines": 0,
    "changed_methods": ""
   },
   {
    "filename": "NotificationManagerService.java",
    "diff": "@@ -5296,6 +5296,11 @@ public class NotificationManagerService extends SystemService {\n                 boolean granted, boolean userSet) {\n             Objects.requireNonNull(listener);\n             checkNotificationListenerAccess();\n+            if (granted && listener.flattenToString().length()\n+                    > NotificationManager.MAX_SERVICE_COMPONENT_NAME_LENGTH) {\n+                throw new IllegalArgumentException(\n+                        \"Component name too long: \" + listener.flattenToString());\n+            }\n             if (!userSet && isNotificationListenerAccessUserSet(listener)) {\n                 // Don't override user's choice\n                 return;\n",
    "added_lines": 5,
    "deleted_lines": 0,
    "changed_methods": "NotificationManagerService::Stub"
   },
   {
    "filename": "VrManagerService.java",
    "diff": "@@ -1049,7 +1049,11 @@ public class VrManagerService extends SystemService\n \n         for (ComponentName c : possibleServices) {\n             if (Objects.equals(c.getPackageName(), pkg)) {\n-                nm.setNotificationListenerAccessGrantedForUser(c, userId, true);\n+                try {\n+                    nm.setNotificationListenerAccessGrantedForUser(c, userId, true);\n+                } catch (Exception e) {\n+                    Slog.w(TAG, \"Could not grant NLS access to package \" + pkg, e);\n+                }\n             }\n         }\n     }\n",
    "added_lines": 5,
    "deleted_lines": 1,
    "changed_methods": "VrManagerService::grantNotificationListenerAccess"
   },
   {
    "filename": "NotificationManagerServiceTest.java",
    "diff": "@@ -74,6 +74,7 @@ import static junit.framework.Assert.assertNull;\n import static junit.framework.Assert.assertTrue;\n import static junit.framework.Assert.fail;\n \n+import static org.junit.Assert.assertThrows;\n import static org.mockito.ArgumentMatchers.isNull;\n import static org.mockito.Matchers.anyBoolean;\n import static org.mockito.Matchers.anyLong;\n@@ -3166,6 +3167,30 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n                 any(), anyInt(), anyBoolean(), anyBoolean(), anyBoolean());\n     }\n \n+    @Test\n+    public void testSetListenerAccessForUser_grantWithNameTooLong_throws() {\n+        UserHandle user = UserHandle.of(mContext.getUserId() + 10);\n+        ComponentName c = new ComponentName(\"com.example.package\",\n+                com.google.common.base.Strings.repeat(\"Blah\", 150));\n+\n+        assertThrows(IllegalArgumentException.class,\n+                () -> mBinderService.setNotificationListenerAccessGrantedForUser(\n+                        c, user.getIdentifier(), /* enabled= */ true, true));\n+    }\n+\n+    @Test\n+    public void testSetListenerAccessForUser_revokeWithNameTooLong_okay() throws Exception {\n+        UserHandle user = UserHandle.of(mContext.getUserId() + 10);\n+        ComponentName c = new ComponentName(\"com.example.package\",\n+                com.google.common.base.Strings.repeat(\"Blah\", 150));\n+\n+        mBinderService.setNotificationListenerAccessGrantedForUser(\n+                c, user.getIdentifier(), /* enabled= */ false, true);\n+\n+        verify(mListeners).setPackageOrComponentEnabled(\n+                c.flattenToString(), user.getIdentifier(), true, /* enabled= */ false, true);\n+    }\n+\n     @Test\n     public void testSetAssistantAccessForUser() throws Exception {\n         UserInfo ui = new UserInfo();\n",
    "added_lines": 25,
    "deleted_lines": 0,
    "changed_methods": "NotificationManagerServiceTest::testSetListenerAccessForUser_grantWithNameTooLong_throws, NotificationManagerServiceTest::testSetListenerAccessForUser_revokeWithNameTooLong_okay"
   }
  ]
 },
 {
  "hash": "83ee559375e3286e01ce4c66f0905fee007278ca",
  "commit": "Forbid granting access to NLSes with too-long component names\n\nThis makes the limitation, which was previously only checked on the Settings UI, enforced everywhere.\n\nFixes: 260570119\nFixes: 286043036\nTest: atest + manually\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:8a40b0b3a17658af16922b4ba99ccc4258af89f5)\nMerged-In: I4c25d80978cb37a8fa1531f5045259d25ac64692\nChange-Id: I4c25d80978cb37a8fa1531f5045259d25ac64692",
  "files": [
   {
    "filename": "NotificationManager.java",
    "diff": "@@ -561,6 +561,12 @@ public class NotificationManager {\n      */\n     public static final int BUBBLE_PREFERENCE_SELECTED = 2;\n \n+    /**\n+     * Maximum length of the component name of a registered NotificationListenerService.\n+     * @hide\n+     */\n+    public static int MAX_SERVICE_COMPONENT_NAME_LENGTH = 500;\n+\n     @UnsupportedAppUsage\n     private static INotificationManager sService;\n \n",
    "added_lines": 6,
    "deleted_lines": 0,
    "changed_methods": ""
   },
   {
    "filename": "NotificationManagerService.java",
    "diff": "@@ -5296,6 +5296,11 @@ public class NotificationManagerService extends SystemService {\n                 boolean granted, boolean userSet) {\n             Objects.requireNonNull(listener);\n             checkNotificationListenerAccess();\n+            if (granted && listener.flattenToString().length()\n+                    > NotificationManager.MAX_SERVICE_COMPONENT_NAME_LENGTH) {\n+                throw new IllegalArgumentException(\n+                        \"Component name too long: \" + listener.flattenToString());\n+            }\n             if (!userSet && isNotificationListenerAccessUserSet(listener)) {\n                 // Don't override user's choice\n                 return;\n",
    "added_lines": 5,
    "deleted_lines": 0,
    "changed_methods": "NotificationManagerService::Stub"
   },
   {
    "filename": "VrManagerService.java",
    "diff": "@@ -1049,7 +1049,11 @@ public class VrManagerService extends SystemService\n \n         for (ComponentName c : possibleServices) {\n             if (Objects.equals(c.getPackageName(), pkg)) {\n-                nm.setNotificationListenerAccessGrantedForUser(c, userId, true);\n+                try {\n+                    nm.setNotificationListenerAccessGrantedForUser(c, userId, true);\n+                } catch (Exception e) {\n+                    Slog.w(TAG, \"Could not grant NLS access to package \" + pkg, e);\n+                }\n             }\n         }\n     }\n",
    "added_lines": 5,
    "deleted_lines": 1,
    "changed_methods": "VrManagerService::grantNotificationListenerAccess"
   },
   {
    "filename": "NotificationManagerServiceTest.java",
    "diff": "@@ -74,6 +74,7 @@ import static junit.framework.Assert.assertNull;\n import static junit.framework.Assert.assertTrue;\n import static junit.framework.Assert.fail;\n \n+import static org.junit.Assert.assertThrows;\n import static org.mockito.ArgumentMatchers.isNull;\n import static org.mockito.Matchers.anyBoolean;\n import static org.mockito.Matchers.anyLong;\n@@ -3166,6 +3167,30 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n                 any(), anyInt(), anyBoolean(), anyBoolean(), anyBoolean());\n     }\n \n+    @Test\n+    public void testSetListenerAccessForUser_grantWithNameTooLong_throws() {\n+        UserHandle user = UserHandle.of(mContext.getUserId() + 10);\n+        ComponentName c = new ComponentName(\"com.example.package\",\n+                com.google.common.base.Strings.repeat(\"Blah\", 150));\n+\n+        assertThrows(IllegalArgumentException.class,\n+                () -> mBinderService.setNotificationListenerAccessGrantedForUser(\n+                        c, user.getIdentifier(), /* enabled= */ true, true));\n+    }\n+\n+    @Test\n+    public void testSetListenerAccessForUser_revokeWithNameTooLong_okay() throws Exception {\n+        UserHandle user = UserHandle.of(mContext.getUserId() + 10);\n+        ComponentName c = new ComponentName(\"com.example.package\",\n+                com.google.common.base.Strings.repeat(\"Blah\", 150));\n+\n+        mBinderService.setNotificationListenerAccessGrantedForUser(\n+                c, user.getIdentifier(), /* enabled= */ false, true);\n+\n+        verify(mListeners).setPackageOrComponentEnabled(\n+                c.flattenToString(), user.getIdentifier(), true, /* enabled= */ false, true);\n+    }\n+\n     @Test\n     public void testSetAssistantAccessForUser() throws Exception {\n         UserInfo ui = new UserInfo();\n",
    "added_lines": 25,
    "deleted_lines": 0,
    "changed_methods": "NotificationManagerServiceTest::testSetListenerAccessForUser_grantWithNameTooLong_throws, NotificationManagerServiceTest::testSetListenerAccessForUser_revokeWithNameTooLong_okay"
   }
  ]
 },
 {
  "hash": "dc790136f99780793fc2fe1c8d7c478d1b00c3e5",
  "commit": "Update AccountManagerService checkKeyIntentParceledCorrectly.\n\nBug: 265798288\nTest: manual\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:b117b506ec0504ff9eb2fa523e82f1879ecb8cc1)\nMerged-In: Iad33851af32a11c99d11bc2b5c76d124c3e97ebb\nChange-Id: Iad33851af32a11c99d11bc2b5c76d124c3e97ebb",
  "files": [
   {
    "filename": "AccountManagerService.java",
    "diff": "@@ -4923,6 +4923,9 @@ public class AccountManagerService\n             Bundle simulateBundle = p.readBundle();\n             p.recycle();\n             Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT);\n+            if (intent != null && intent.getClass() != Intent.class) {\n+                return false;\n+            }\n             Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT);\n             if (intent == null) {\n                 return (simulateIntent == null);\n",
    "added_lines": 3,
    "deleted_lines": 0,
    "changed_methods": "AccountManagerService::Session::checkKeyIntentParceledCorrectly"
   }
  ]
 },
 {
  "hash": "492ce6e3bcffd9996657e37b36dea35c4bb84347",
  "commit": "Improve user handling when querying for resumable media\n\n- Before trying to query recent media from a saved component, check\n  whether the current user actually has that component installed\n- Track user when creating the MediaBrowser, in case the user changes\n  before the MBS returns a result\n\nTest: atest MediaResumeListenerTest\nBug: 284297711\n(cherry picked from commit e566a250ad61e269119b475c7ebdae6ca962c4a7)\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:8dccce4f519c91354d5bc6850137269fec715e5d)\nMerged-In: I838ff0e125acadabc8436a00dbff707cc4be6249\nChange-Id: I838ff0e125acadabc8436a00dbff707cc4be6249",
  "files": [
   {
    "filename": "ResumeMediaBrowser.java",
    "diff": "@@ -17,6 +17,7 @@\n package com.android.systemui.media;\n \n import android.annotation.Nullable;\n+import android.annotation.UserIdInt;\n import android.app.PendingIntent;\n import android.content.ComponentName;\n import android.content.Context;\n@@ -50,6 +51,8 @@ public class ResumeMediaBrowser {\n     private final Context mContext;\n     @Nullable private final Callback mCallback;\n     private MediaBrowserFactory mBrowserFactory;\n+    @UserIdInt private final int mUserId;\n+\n     private MediaBrowser mMediaBrowser;\n     private ComponentName mComponentName;\n \n@@ -58,13 +61,19 @@ public class ResumeMediaBrowser {\n      * @param context the context\n      * @param callback used to report media items found\n      * @param componentName Component name of the MediaBrowserService this browser will connect to\n+     * @param userId ID of the current user\n      */\n-    public ResumeMediaBrowser(Context context, @Nullable Callback callback,\n-            ComponentName componentName, MediaBrowserFactory browserFactory) {\n+    public ResumeMediaBrowser(\n+            Context context,\n+            @Nullable Callback callback,\n+            ComponentName componentName,\n+            MediaBrowserFactory browserFactory,\n+            @UserIdInt int userId) {\n         mContext = context;\n         mCallback = callback;\n         mComponentName = componentName;\n         mBrowserFactory = browserFactory;\n+        mUserId = userId;\n     }\n \n     /**\n@@ -259,6 +268,14 @@ public class ResumeMediaBrowser {\n         return new MediaController(mContext, token);\n     }\n \n+    /**\n+     * Get the ID of the user associated with this broswer\n+     * @return the user ID\n+     */\n+    public @UserIdInt int getUserId() {\n+        return mUserId;\n+    }\n+\n     /**\n      * Get the media session token\n      * @return the token, or null if the MediaBrowser is null or disconnected\n",
    "added_lines": 19,
    "deleted_lines": 2,
    "changed_methods": "ResumeMediaBrowser::ResumeMediaBrowser, ResumeMediaBrowser::ResumeMediaBrowser, ResumeMediaBrowser::getUserId"
   },
   {
    "filename": "ResumeMediaBrowserFactory.java",
    "diff": "@@ -16,6 +16,7 @@\n \n package com.android.systemui.media;\n \n+import android.annotation.UserIdInt;\n import android.content.ComponentName;\n import android.content.Context;\n \n@@ -39,10 +40,12 @@ public class ResumeMediaBrowserFactory {\n      *\n      * @param callback will be called on connection or error, and addTrack when media item found\n      * @param componentName component to browse\n+     * @param userId ID of the current user\n      * @return\n      */\n     public ResumeMediaBrowser create(ResumeMediaBrowser.Callback callback,\n-            ComponentName componentName) {\n-        return new ResumeMediaBrowser(mContext, callback, componentName, mBrowserFactory);\n+            ComponentName componentName, @UserIdInt int userId) {\n+        return new ResumeMediaBrowser(mContext, callback, componentName, mBrowserFactory,\n+            userId);\n     }\n }\n",
    "added_lines": 5,
    "deleted_lines": 2,
    "changed_methods": "ResumeMediaBrowserFactory::create, ResumeMediaBrowserFactory::create"
   }
  ]
 },
 {
  "hash": "492ce6e3bcffd9996657e37b36dea35c4bb84347",
  "commit": "Improve user handling when querying for resumable media\n\n- Before trying to query recent media from a saved component, check\n  whether the current user actually has that component installed\n- Track user when creating the MediaBrowser, in case the user changes\n  before the MBS returns a result\n\nTest: atest MediaResumeListenerTest\nBug: 284297711\n(cherry picked from commit e566a250ad61e269119b475c7ebdae6ca962c4a7)\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:8dccce4f519c91354d5bc6850137269fec715e5d)\nMerged-In: I838ff0e125acadabc8436a00dbff707cc4be6249\nChange-Id: I838ff0e125acadabc8436a00dbff707cc4be6249",
  "files": [
   {
    "filename": "ResumeMediaBrowser.java",
    "diff": "@@ -17,6 +17,7 @@\n package com.android.systemui.media;\n \n import android.annotation.Nullable;\n+import android.annotation.UserIdInt;\n import android.app.PendingIntent;\n import android.content.ComponentName;\n import android.content.Context;\n@@ -50,6 +51,8 @@ public class ResumeMediaBrowser {\n     private final Context mContext;\n     @Nullable private final Callback mCallback;\n     private MediaBrowserFactory mBrowserFactory;\n+    @UserIdInt private final int mUserId;\n+\n     private MediaBrowser mMediaBrowser;\n     private ComponentName mComponentName;\n \n@@ -58,13 +61,19 @@ public class ResumeMediaBrowser {\n      * @param context the context\n      * @param callback used to report media items found\n      * @param componentName Component name of the MediaBrowserService this browser will connect to\n+     * @param userId ID of the current user\n      */\n-    public ResumeMediaBrowser(Context context, @Nullable Callback callback,\n-            ComponentName componentName, MediaBrowserFactory browserFactory) {\n+    public ResumeMediaBrowser(\n+            Context context,\n+            @Nullable Callback callback,\n+            ComponentName componentName,\n+            MediaBrowserFactory browserFactory,\n+            @UserIdInt int userId) {\n         mContext = context;\n         mCallback = callback;\n         mComponentName = componentName;\n         mBrowserFactory = browserFactory;\n+        mUserId = userId;\n     }\n \n     /**\n@@ -259,6 +268,14 @@ public class ResumeMediaBrowser {\n         return new MediaController(mContext, token);\n     }\n \n+    /**\n+     * Get the ID of the user associated with this broswer\n+     * @return the user ID\n+     */\n+    public @UserIdInt int getUserId() {\n+        return mUserId;\n+    }\n+\n     /**\n      * Get the media session token\n      * @return the token, or null if the MediaBrowser is null or disconnected\n",
    "added_lines": 19,
    "deleted_lines": 2,
    "changed_methods": "ResumeMediaBrowser::ResumeMediaBrowser, ResumeMediaBrowser::ResumeMediaBrowser, ResumeMediaBrowser::getUserId"
   },
   {
    "filename": "ResumeMediaBrowserFactory.java",
    "diff": "@@ -16,6 +16,7 @@\n \n package com.android.systemui.media;\n \n+import android.annotation.UserIdInt;\n import android.content.ComponentName;\n import android.content.Context;\n \n@@ -39,10 +40,12 @@ public class ResumeMediaBrowserFactory {\n      *\n      * @param callback will be called on connection or error, and addTrack when media item found\n      * @param componentName component to browse\n+     * @param userId ID of the current user\n      * @return\n      */\n     public ResumeMediaBrowser create(ResumeMediaBrowser.Callback callback,\n-            ComponentName componentName) {\n-        return new ResumeMediaBrowser(mContext, callback, componentName, mBrowserFactory);\n+            ComponentName componentName, @UserIdInt int userId) {\n+        return new ResumeMediaBrowser(mContext, callback, componentName, mBrowserFactory,\n+            userId);\n     }\n }\n",
    "added_lines": 5,
    "deleted_lines": 2,
    "changed_methods": "ResumeMediaBrowserFactory::create, ResumeMediaBrowserFactory::create"
   }
  ]
 },
 {
  "hash": "71e3acf509833bb428b8d1efee42daea316d5a0d",
  "commit": "RingtoneManager: verify default ringtone is audio\n\nWhen a ringtone picker tries to set a ringtone through\nRingtoneManager.setActualDefaultRingtoneUri (also\ncalled by com.android.settings.DefaultRingtonePreference),\nverify the mimeType can be obtained (not found when caller\ndoesn't have access to it) and it is an audio resource.\n\nBug: 205837340\nTest: atest android.media.audio.cts.RingtoneManagerTest\n(cherry picked from commit 38618f9fb16d3b5617e2289354d47abe5af17dad)\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:a67982c990496d8efded6cc3a7471e30b66dce60)\nMerged-In: I3f2c487ded405c0c1a83ef0a2fe99cff7cc9328e\nChange-Id: I3f2c487ded405c0c1a83ef0a2fe99cff7cc9328e",
  "files": [
   {
    "filename": "RingtoneManager.java",
    "diff": "@@ -802,10 +802,10 @@ public class RingtoneManager {\n \n         return ringtoneUri;\n     }\n-    \n+\n     /**\n      * Sets the {@link Uri} of the default sound for a given sound type.\n-     * \n+     *\n      * @param context A context used for querying.\n      * @param type The type whose default sound should be set. One of\n      *            {@link #TYPE_RINGTONE}, {@link #TYPE_NOTIFICATION}, or\n@@ -826,6 +826,21 @@ public class RingtoneManager {\n         if(!isInternalRingtoneUri(ringtoneUri)) {\n             ringtoneUri = ContentProvider.maybeAddUserId(ringtoneUri, context.getUserId());\n         }\n+\n+        if (ringtoneUri != null) {\n+            final String mimeType = resolver.getType(ringtoneUri);\n+            if (mimeType == null) {\n+                Log.e(TAG, \"setActualDefaultRingtoneUri for URI:\" + ringtoneUri\n+                        + \" ignored: failure to find mimeType (no access from this context?)\");\n+                return;\n+            }\n+            if (!(mimeType.startsWith(\"audio/\") || mimeType.equals(\"application/ogg\"))) {\n+                Log.e(TAG, \"setActualDefaultRingtoneUri for URI:\" + ringtoneUri\n+                        + \" ignored: associated mimeType:\" + mimeType + \" is not an audio type\");\n+                return;\n+            }\n+        }\n+\n         Settings.System.putStringForUser(resolver, setting,\n                 ringtoneUri != null ? ringtoneUri.toString() : null, context.getUserId());\n \n",
    "added_lines": 17,
    "deleted_lines": 2,
    "changed_methods": "RingtoneManager::setActualDefaultRingtoneUri"
   }
  ]
 },
 {
  "hash": "193a8234fe89f9ede2ade8972056fbecc1722cd7",
  "commit": "Verify URI permissions for EXTRA_REMOTE_INPUT_HISTORY_ITEMS.\n\nAlso added a step to serialize & deserialize the notification in the\ntest, to prevent exceptions about not being able to cast e.g.\nParcelable[] to RemoteInputHistoryItem[].\n\nTest: atest NotificationManagerServiceTest & tested with POC from bug\nBug: 276729064\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:88e597d2b31d054ab5286b3a666accb08a8db5d5)\nMerged-In: I7053ca59f9c7f1df5226418594109cfb8b609b1e\nChange-Id: I7053ca59f9c7f1df5226418594109cfb8b609b1e",
  "files": [
   {
    "filename": "Notification.java",
    "diff": "@@ -2811,6 +2811,17 @@ public class Notification implements Parcelable\n             if (person != null) {\n                 visitor.accept(person.getIconUri());\n             }\n+\n+            final RemoteInputHistoryItem[] history = getParcelableArrayFromBundle(extras,\n+                Notification.EXTRA_REMOTE_INPUT_HISTORY_ITEMS, RemoteInputHistoryItem.class);\n+            if (history != null) {\n+                for (int i = 0; i < history.length; i++) {\n+                    RemoteInputHistoryItem item = history[i];\n+                    if (item.getUri() != null) {\n+                        visitor.accept(item.getUri());\n+                    }\n+                }\n+            }\n         }\n \n         if (isStyle(MessagingStyle.class) && extras != null) {\n",
    "added_lines": 11,
    "deleted_lines": 0,
    "changed_methods": "Notification::visitUris"
   },
   {
    "filename": "NotificationManagerServiceTest.java",
    "diff": "@@ -116,6 +116,7 @@ import android.app.NotificationManager;\n import android.app.PendingIntent;\n import android.app.Person;\n import android.app.RemoteInput;\n+import android.app.RemoteInputHistoryItem;\n import android.app.StatsManager;\n import android.app.admin.DevicePolicyManagerInternal;\n import android.app.usage.UsageStatsManagerInternal;\n@@ -4488,6 +4489,12 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n                 .setName(\"People List Person 2\")\n                 .setIcon(personIcon3)\n                 .build();\n+        final Uri historyUri1 = Uri.parse(\"content://com.example/history1\");\n+        final Uri historyUri2 = Uri.parse(\"content://com.example/history2\");\n+        final RemoteInputHistoryItem historyItem1 = new RemoteInputHistoryItem(null, historyUri1,\n+                \"a\");\n+        final RemoteInputHistoryItem historyItem2 = new RemoteInputHistoryItem(null, historyUri2,\n+                \"b\");\n \n         Bundle extras = new Bundle();\n         extras.putParcelable(Notification.EXTRA_AUDIO_CONTENTS_URI, audioContents);\n@@ -4495,6 +4502,8 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n         extras.putParcelable(Notification.EXTRA_MESSAGING_PERSON, person1);\n         extras.putParcelableArrayList(Notification.EXTRA_PEOPLE_LIST,\n                 new ArrayList<>(Arrays.asList(person2, person3)));\n+        extras.putParcelableArray(Notification.EXTRA_REMOTE_INPUT_HISTORY_ITEMS,\n+                new RemoteInputHistoryItem[]{historyItem1, historyItem2});\n \n         Notification n = new Notification.Builder(mContext, \"a\")\n                 .setContentTitle(\"notification with uris\")\n@@ -4503,6 +4512,13 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n                 .addExtras(extras)\n                 .build();\n \n+        // Serialize and deserialize the notification to make sure nothing breaks in the process,\n+        // since that's what will usually happen before we get to call visitUris.\n+        Parcel parcel = Parcel.obtain();\n+        n.writeToParcel(parcel, 0);\n+        parcel.setDataPosition(0);\n+        n = new Notification(parcel);\n+\n         Consumer<Uri> visitor = (Consumer<Uri>) spy(Consumer.class);\n         n.visitUris(visitor);\n         verify(visitor, times(1)).accept(eq(audioContents));\n@@ -4512,6 +4528,8 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n         verify(visitor, times(1)).accept(eq(personIcon1.getUri()));\n         verify(visitor, times(1)).accept(eq(personIcon2.getUri()));\n         verify(visitor, times(1)).accept(eq(personIcon3.getUri()));\n+        verify(visitor, times(1)).accept(eq(historyUri1));\n+        verify(visitor, times(1)).accept(eq(historyUri2));\n     }\n \n     @Test\n",
    "added_lines": 18,
    "deleted_lines": 0,
    "changed_methods": "NotificationManagerServiceTest::testVisitUris"
   }
  ]
 },
 {
  "hash": "193a8234fe89f9ede2ade8972056fbecc1722cd7",
  "commit": "Verify URI permissions for EXTRA_REMOTE_INPUT_HISTORY_ITEMS.\n\nAlso added a step to serialize & deserialize the notification in the\ntest, to prevent exceptions about not being able to cast e.g.\nParcelable[] to RemoteInputHistoryItem[].\n\nTest: atest NotificationManagerServiceTest & tested with POC from bug\nBug: 276729064\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:88e597d2b31d054ab5286b3a666accb08a8db5d5)\nMerged-In: I7053ca59f9c7f1df5226418594109cfb8b609b1e\nChange-Id: I7053ca59f9c7f1df5226418594109cfb8b609b1e",
  "files": [
   {
    "filename": "Notification.java",
    "diff": "@@ -2811,6 +2811,17 @@ public class Notification implements Parcelable\n             if (person != null) {\n                 visitor.accept(person.getIconUri());\n             }\n+\n+            final RemoteInputHistoryItem[] history = getParcelableArrayFromBundle(extras,\n+                Notification.EXTRA_REMOTE_INPUT_HISTORY_ITEMS, RemoteInputHistoryItem.class);\n+            if (history != null) {\n+                for (int i = 0; i < history.length; i++) {\n+                    RemoteInputHistoryItem item = history[i];\n+                    if (item.getUri() != null) {\n+                        visitor.accept(item.getUri());\n+                    }\n+                }\n+            }\n         }\n \n         if (isStyle(MessagingStyle.class) && extras != null) {\n",
    "added_lines": 11,
    "deleted_lines": 0,
    "changed_methods": "Notification::visitUris"
   },
   {
    "filename": "NotificationManagerServiceTest.java",
    "diff": "@@ -116,6 +116,7 @@ import android.app.NotificationManager;\n import android.app.PendingIntent;\n import android.app.Person;\n import android.app.RemoteInput;\n+import android.app.RemoteInputHistoryItem;\n import android.app.StatsManager;\n import android.app.admin.DevicePolicyManagerInternal;\n import android.app.usage.UsageStatsManagerInternal;\n@@ -4488,6 +4489,12 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n                 .setName(\"People List Person 2\")\n                 .setIcon(personIcon3)\n                 .build();\n+        final Uri historyUri1 = Uri.parse(\"content://com.example/history1\");\n+        final Uri historyUri2 = Uri.parse(\"content://com.example/history2\");\n+        final RemoteInputHistoryItem historyItem1 = new RemoteInputHistoryItem(null, historyUri1,\n+                \"a\");\n+        final RemoteInputHistoryItem historyItem2 = new RemoteInputHistoryItem(null, historyUri2,\n+                \"b\");\n \n         Bundle extras = new Bundle();\n         extras.putParcelable(Notification.EXTRA_AUDIO_CONTENTS_URI, audioContents);\n@@ -4495,6 +4502,8 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n         extras.putParcelable(Notification.EXTRA_MESSAGING_PERSON, person1);\n         extras.putParcelableArrayList(Notification.EXTRA_PEOPLE_LIST,\n                 new ArrayList<>(Arrays.asList(person2, person3)));\n+        extras.putParcelableArray(Notification.EXTRA_REMOTE_INPUT_HISTORY_ITEMS,\n+                new RemoteInputHistoryItem[]{historyItem1, historyItem2});\n \n         Notification n = new Notification.Builder(mContext, \"a\")\n                 .setContentTitle(\"notification with uris\")\n@@ -4503,6 +4512,13 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n                 .addExtras(extras)\n                 .build();\n \n+        // Serialize and deserialize the notification to make sure nothing breaks in the process,\n+        // since that's what will usually happen before we get to call visitUris.\n+        Parcel parcel = Parcel.obtain();\n+        n.writeToParcel(parcel, 0);\n+        parcel.setDataPosition(0);\n+        n = new Notification(parcel);\n+\n         Consumer<Uri> visitor = (Consumer<Uri>) spy(Consumer.class);\n         n.visitUris(visitor);\n         verify(visitor, times(1)).accept(eq(audioContents));\n@@ -4512,6 +4528,8 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n         verify(visitor, times(1)).accept(eq(personIcon1.getUri()));\n         verify(visitor, times(1)).accept(eq(personIcon2.getUri()));\n         verify(visitor, times(1)).accept(eq(personIcon3.getUri()));\n+        verify(visitor, times(1)).accept(eq(historyUri1));\n+        verify(visitor, times(1)).accept(eq(historyUri2));\n     }\n \n     @Test\n",
    "added_lines": 18,
    "deleted_lines": 0,
    "changed_methods": "NotificationManagerServiceTest::testVisitUris"
   }
  ]
 },
 {
  "hash": "5b1e387eb079f165d3cbef4c263cc9b030791db9",
  "commit": "[DO NOT MERGE] Verify URI Permissions in Autofill RemoteViews\n\nCheck permissions of URI inside of FillResponse's RemoteViews. If the\ncurrent user does not have the required permissions to view the URI, the\nRemoteView is dropped from displaying.\n\nThis fixes a security spill in which a user can view content of another\nuser through a malicious Autofill provider.\n\nBug: 283137865\nFixes: b/283264674 b/281666022 b/281665050 b/281848557 b/281533566\nb/281534749 b/283101289\nTest: Verified by POC app attached in bugs\nTest: atest CtsAutoFillServiceTestCases (added new tests)\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:73fa082a7202100da107ae14dd7742ecd86da053)\nMerged-In: I6f4d2a35e89bbed7bd9e07bf5cd3e2d68b20af9a\nChange-Id: I6f4d2a35e89bbed7bd9e07bf5cd3e2d68b20af9a",
  "files": [
   {
    "filename": "Helper.java",
    "diff": "@@ -18,6 +18,8 @@ package com.android.server.autofill;\n \n import android.annotation.NonNull;\n import android.annotation.Nullable;\n+import android.annotation.UserIdInt;\n+import android.app.ActivityManager;\n import android.app.assist.AssistStructure;\n import android.app.assist.AssistStructure.ViewNode;\n import android.app.assist.AssistStructure.WindowNode;\n@@ -34,6 +36,7 @@ import android.view.View;\n import android.view.WindowManager;\n import android.view.autofill.AutofillId;\n import android.view.autofill.AutofillValue;\n+import android.widget.RemoteViews;\n \n import com.android.internal.logging.nano.MetricsProto.MetricsEvent;\n import com.android.internal.util.ArrayUtils;\n@@ -42,6 +45,8 @@ import java.io.PrintWriter;\n import java.util.ArrayDeque;\n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n \n public final class Helper {\n \n@@ -75,6 +80,44 @@ public final class Helper {\n         throw new UnsupportedOperationException(\"contains static members only\");\n     }\n \n+    private static boolean checkRemoteViewUriPermissions(\n+            @UserIdInt int userId, @NonNull RemoteViews rView) {\n+        final AtomicBoolean permissionsOk = new AtomicBoolean(true);\n+\n+        rView.visitUris(uri -> {\n+            int uriOwnerId = android.content.ContentProvider.getUserIdFromUri(uri);\n+            boolean allowed = uriOwnerId == userId;\n+            permissionsOk.set(allowed && permissionsOk.get());\n+        });\n+\n+        return permissionsOk.get();\n+    }\n+\n+    /**\n+     * Checks the URI permissions of the remote view,\n+     * to see if the current userId is able to access it.\n+     *\n+     * Returns the RemoteView that is passed if user is able, null otherwise.\n+     *\n+     * TODO: instead of returning a null remoteview when\n+     * the current userId cannot access an URI,\n+     * return a new RemoteView with the URI removed.\n+     */\n+    public static @Nullable RemoteViews sanitizeRemoteView(RemoteViews rView) {\n+        if (rView == null) return null;\n+\n+        int userId = ActivityManager.getCurrentUser();\n+\n+        boolean ok = checkRemoteViewUriPermissions(userId, rView);\n+        if (!ok) {\n+            Slog.w(TAG,\n+                    \"sanitizeRemoteView() user: \" + userId\n+                    + \" tried accessing resource that does not belong to them\");\n+        }\n+        return (ok ? rView : null);\n+    }\n+\n+\n     @Nullable\n     static AutofillId[] toArray(@Nullable ArraySet<AutofillId> set) {\n         if (set == null) return null;\n",
    "added_lines": 43,
    "deleted_lines": 0,
    "changed_methods": "Helper::checkRemoteViewUriPermissions, Helper::sanitizeRemoteView"
   },
   {
    "filename": "FillUi.java",
    "diff": "@@ -141,8 +141,9 @@ final class FillUi {\n \n         final LayoutInflater inflater = LayoutInflater.from(mContext);\n \n-        final RemoteViews headerPresentation = response.getHeader();\n-        final RemoteViews footerPresentation = response.getFooter();\n+        final RemoteViews headerPresentation = Helper.sanitizeRemoteView(response.getHeader());\n+        final RemoteViews footerPresentation = Helper.sanitizeRemoteView(response.getFooter());\n+\n         final ViewGroup decor;\n         if (mFullScreen) {\n             decor = (ViewGroup) inflater.inflate(R.layout.autofill_dataset_picker_fullscreen, null);\n@@ -220,6 +221,9 @@ final class FillUi {\n             ViewGroup container = decor.findViewById(R.id.autofill_dataset_picker);\n             final View content;\n             try {\n+                if (Helper.sanitizeRemoteView(response.getPresentation()) == null) {\n+                    throw new RuntimeException(\"Permission error accessing RemoteView\");\n+                }\n                 content = response.getPresentation().applyWithTheme(\n                         mContext, decor, interceptionHandler, mThemeId);\n                 container.addView(content);\n@@ -299,7 +303,8 @@ final class FillUi {\n                 final Dataset dataset = response.getDatasets().get(i);\n                 final int index = dataset.getFieldIds().indexOf(focusedViewId);\n                 if (index >= 0) {\n-                    final RemoteViews presentation = dataset.getFieldPresentation(index);\n+                    final RemoteViews presentation = Helper.sanitizeRemoteView(\n+                            dataset.getFieldPresentation(index));\n                     if (presentation == null) {\n                         Slog.w(TAG, \"not displaying UI on field \" + focusedViewId + \" because \"\n                                 + \"service didn't provide a presentation for it on \" + dataset);\n",
    "added_lines": 8,
    "deleted_lines": 3,
    "changed_methods": "FillUi::FillUi"
   },
   {
    "filename": "SaveUi.java",
    "diff": "@@ -368,8 +368,7 @@ final class SaveUi {\n             return false;\n         }\n         writeLog(MetricsEvent.AUTOFILL_SAVE_CUSTOM_DESCRIPTION);\n-\n-        final RemoteViews template = customDescription.getPresentation();\n+        final RemoteViews template = Helper.sanitizeRemoteView(customDescription.getPresentation());\n         if (template == null) {\n             Slog.w(TAG, \"No remote view on custom description\");\n             return false;\n",
    "added_lines": 1,
    "deleted_lines": 2,
    "changed_methods": "SaveUi::applyCustomDescription"
   }
  ]
 },
 {
  "hash": "5b1e387eb079f165d3cbef4c263cc9b030791db9",
  "commit": "[DO NOT MERGE] Verify URI Permissions in Autofill RemoteViews\n\nCheck permissions of URI inside of FillResponse's RemoteViews. If the\ncurrent user does not have the required permissions to view the URI, the\nRemoteView is dropped from displaying.\n\nThis fixes a security spill in which a user can view content of another\nuser through a malicious Autofill provider.\n\nBug: 283137865\nFixes: b/283264674 b/281666022 b/281665050 b/281848557 b/281533566\nb/281534749 b/283101289\nTest: Verified by POC app attached in bugs\nTest: atest CtsAutoFillServiceTestCases (added new tests)\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:73fa082a7202100da107ae14dd7742ecd86da053)\nMerged-In: I6f4d2a35e89bbed7bd9e07bf5cd3e2d68b20af9a\nChange-Id: I6f4d2a35e89bbed7bd9e07bf5cd3e2d68b20af9a",
  "files": [
   {
    "filename": "Helper.java",
    "diff": "@@ -18,6 +18,8 @@ package com.android.server.autofill;\n \n import android.annotation.NonNull;\n import android.annotation.Nullable;\n+import android.annotation.UserIdInt;\n+import android.app.ActivityManager;\n import android.app.assist.AssistStructure;\n import android.app.assist.AssistStructure.ViewNode;\n import android.app.assist.AssistStructure.WindowNode;\n@@ -34,6 +36,7 @@ import android.view.View;\n import android.view.WindowManager;\n import android.view.autofill.AutofillId;\n import android.view.autofill.AutofillValue;\n+import android.widget.RemoteViews;\n \n import com.android.internal.logging.nano.MetricsProto.MetricsEvent;\n import com.android.internal.util.ArrayUtils;\n@@ -42,6 +45,8 @@ import java.io.PrintWriter;\n import java.util.ArrayDeque;\n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n \n public final class Helper {\n \n@@ -75,6 +80,44 @@ public final class Helper {\n         throw new UnsupportedOperationException(\"contains static members only\");\n     }\n \n+    private static boolean checkRemoteViewUriPermissions(\n+            @UserIdInt int userId, @NonNull RemoteViews rView) {\n+        final AtomicBoolean permissionsOk = new AtomicBoolean(true);\n+\n+        rView.visitUris(uri -> {\n+            int uriOwnerId = android.content.ContentProvider.getUserIdFromUri(uri);\n+            boolean allowed = uriOwnerId == userId;\n+            permissionsOk.set(allowed && permissionsOk.get());\n+        });\n+\n+        return permissionsOk.get();\n+    }\n+\n+    /**\n+     * Checks the URI permissions of the remote view,\n+     * to see if the current userId is able to access it.\n+     *\n+     * Returns the RemoteView that is passed if user is able, null otherwise.\n+     *\n+     * TODO: instead of returning a null remoteview when\n+     * the current userId cannot access an URI,\n+     * return a new RemoteView with the URI removed.\n+     */\n+    public static @Nullable RemoteViews sanitizeRemoteView(RemoteViews rView) {\n+        if (rView == null) return null;\n+\n+        int userId = ActivityManager.getCurrentUser();\n+\n+        boolean ok = checkRemoteViewUriPermissions(userId, rView);\n+        if (!ok) {\n+            Slog.w(TAG,\n+                    \"sanitizeRemoteView() user: \" + userId\n+                    + \" tried accessing resource that does not belong to them\");\n+        }\n+        return (ok ? rView : null);\n+    }\n+\n+\n     @Nullable\n     static AutofillId[] toArray(@Nullable ArraySet<AutofillId> set) {\n         if (set == null) return null;\n",
    "added_lines": 43,
    "deleted_lines": 0,
    "changed_methods": "Helper::checkRemoteViewUriPermissions, Helper::sanitizeRemoteView"
   },
   {
    "filename": "FillUi.java",
    "diff": "@@ -141,8 +141,9 @@ final class FillUi {\n \n         final LayoutInflater inflater = LayoutInflater.from(mContext);\n \n-        final RemoteViews headerPresentation = response.getHeader();\n-        final RemoteViews footerPresentation = response.getFooter();\n+        final RemoteViews headerPresentation = Helper.sanitizeRemoteView(response.getHeader());\n+        final RemoteViews footerPresentation = Helper.sanitizeRemoteView(response.getFooter());\n+\n         final ViewGroup decor;\n         if (mFullScreen) {\n             decor = (ViewGroup) inflater.inflate(R.layout.autofill_dataset_picker_fullscreen, null);\n@@ -220,6 +221,9 @@ final class FillUi {\n             ViewGroup container = decor.findViewById(R.id.autofill_dataset_picker);\n             final View content;\n             try {\n+                if (Helper.sanitizeRemoteView(response.getPresentation()) == null) {\n+                    throw new RuntimeException(\"Permission error accessing RemoteView\");\n+                }\n                 content = response.getPresentation().applyWithTheme(\n                         mContext, decor, interceptionHandler, mThemeId);\n                 container.addView(content);\n@@ -299,7 +303,8 @@ final class FillUi {\n                 final Dataset dataset = response.getDatasets().get(i);\n                 final int index = dataset.getFieldIds().indexOf(focusedViewId);\n                 if (index >= 0) {\n-                    final RemoteViews presentation = dataset.getFieldPresentation(index);\n+                    final RemoteViews presentation = Helper.sanitizeRemoteView(\n+                            dataset.getFieldPresentation(index));\n                     if (presentation == null) {\n                         Slog.w(TAG, \"not displaying UI on field \" + focusedViewId + \" because \"\n                                 + \"service didn't provide a presentation for it on \" + dataset);\n",
    "added_lines": 8,
    "deleted_lines": 3,
    "changed_methods": "FillUi::FillUi"
   },
   {
    "filename": "SaveUi.java",
    "diff": "@@ -368,8 +368,7 @@ final class SaveUi {\n             return false;\n         }\n         writeLog(MetricsEvent.AUTOFILL_SAVE_CUSTOM_DESCRIPTION);\n-\n-        final RemoteViews template = customDescription.getPresentation();\n+        final RemoteViews template = Helper.sanitizeRemoteView(customDescription.getPresentation());\n         if (template == null) {\n             Slog.w(TAG, \"No remote view on custom description\");\n             return false;\n",
    "added_lines": 1,
    "deleted_lines": 2,
    "changed_methods": "SaveUi::applyCustomDescription"
   }
  ]
 },
 {
  "hash": "5b1e387eb079f165d3cbef4c263cc9b030791db9",
  "commit": "[DO NOT MERGE] Verify URI Permissions in Autofill RemoteViews\n\nCheck permissions of URI inside of FillResponse's RemoteViews. If the\ncurrent user does not have the required permissions to view the URI, the\nRemoteView is dropped from displaying.\n\nThis fixes a security spill in which a user can view content of another\nuser through a malicious Autofill provider.\n\nBug: 283137865\nFixes: b/283264674 b/281666022 b/281665050 b/281848557 b/281533566\nb/281534749 b/283101289\nTest: Verified by POC app attached in bugs\nTest: atest CtsAutoFillServiceTestCases (added new tests)\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:73fa082a7202100da107ae14dd7742ecd86da053)\nMerged-In: I6f4d2a35e89bbed7bd9e07bf5cd3e2d68b20af9a\nChange-Id: I6f4d2a35e89bbed7bd9e07bf5cd3e2d68b20af9a",
  "files": [
   {
    "filename": "Helper.java",
    "diff": "@@ -18,6 +18,8 @@ package com.android.server.autofill;\n \n import android.annotation.NonNull;\n import android.annotation.Nullable;\n+import android.annotation.UserIdInt;\n+import android.app.ActivityManager;\n import android.app.assist.AssistStructure;\n import android.app.assist.AssistStructure.ViewNode;\n import android.app.assist.AssistStructure.WindowNode;\n@@ -34,6 +36,7 @@ import android.view.View;\n import android.view.WindowManager;\n import android.view.autofill.AutofillId;\n import android.view.autofill.AutofillValue;\n+import android.widget.RemoteViews;\n \n import com.android.internal.logging.nano.MetricsProto.MetricsEvent;\n import com.android.internal.util.ArrayUtils;\n@@ -42,6 +45,8 @@ import java.io.PrintWriter;\n import java.util.ArrayDeque;\n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n \n public final class Helper {\n \n@@ -75,6 +80,44 @@ public final class Helper {\n         throw new UnsupportedOperationException(\"contains static members only\");\n     }\n \n+    private static boolean checkRemoteViewUriPermissions(\n+            @UserIdInt int userId, @NonNull RemoteViews rView) {\n+        final AtomicBoolean permissionsOk = new AtomicBoolean(true);\n+\n+        rView.visitUris(uri -> {\n+            int uriOwnerId = android.content.ContentProvider.getUserIdFromUri(uri);\n+            boolean allowed = uriOwnerId == userId;\n+            permissionsOk.set(allowed && permissionsOk.get());\n+        });\n+\n+        return permissionsOk.get();\n+    }\n+\n+    /**\n+     * Checks the URI permissions of the remote view,\n+     * to see if the current userId is able to access it.\n+     *\n+     * Returns the RemoteView that is passed if user is able, null otherwise.\n+     *\n+     * TODO: instead of returning a null remoteview when\n+     * the current userId cannot access an URI,\n+     * return a new RemoteView with the URI removed.\n+     */\n+    public static @Nullable RemoteViews sanitizeRemoteView(RemoteViews rView) {\n+        if (rView == null) return null;\n+\n+        int userId = ActivityManager.getCurrentUser();\n+\n+        boolean ok = checkRemoteViewUriPermissions(userId, rView);\n+        if (!ok) {\n+            Slog.w(TAG,\n+                    \"sanitizeRemoteView() user: \" + userId\n+                    + \" tried accessing resource that does not belong to them\");\n+        }\n+        return (ok ? rView : null);\n+    }\n+\n+\n     @Nullable\n     static AutofillId[] toArray(@Nullable ArraySet<AutofillId> set) {\n         if (set == null) return null;\n",
    "added_lines": 43,
    "deleted_lines": 0,
    "changed_methods": "Helper::checkRemoteViewUriPermissions, Helper::sanitizeRemoteView"
   },
   {
    "filename": "FillUi.java",
    "diff": "@@ -141,8 +141,9 @@ final class FillUi {\n \n         final LayoutInflater inflater = LayoutInflater.from(mContext);\n \n-        final RemoteViews headerPresentation = response.getHeader();\n-        final RemoteViews footerPresentation = response.getFooter();\n+        final RemoteViews headerPresentation = Helper.sanitizeRemoteView(response.getHeader());\n+        final RemoteViews footerPresentation = Helper.sanitizeRemoteView(response.getFooter());\n+\n         final ViewGroup decor;\n         if (mFullScreen) {\n             decor = (ViewGroup) inflater.inflate(R.layout.autofill_dataset_picker_fullscreen, null);\n@@ -220,6 +221,9 @@ final class FillUi {\n             ViewGroup container = decor.findViewById(R.id.autofill_dataset_picker);\n             final View content;\n             try {\n+                if (Helper.sanitizeRemoteView(response.getPresentation()) == null) {\n+                    throw new RuntimeException(\"Permission error accessing RemoteView\");\n+                }\n                 content = response.getPresentation().applyWithTheme(\n                         mContext, decor, interceptionHandler, mThemeId);\n                 container.addView(content);\n@@ -299,7 +303,8 @@ final class FillUi {\n                 final Dataset dataset = response.getDatasets().get(i);\n                 final int index = dataset.getFieldIds().indexOf(focusedViewId);\n                 if (index >= 0) {\n-                    final RemoteViews presentation = dataset.getFieldPresentation(index);\n+                    final RemoteViews presentation = Helper.sanitizeRemoteView(\n+                            dataset.getFieldPresentation(index));\n                     if (presentation == null) {\n                         Slog.w(TAG, \"not displaying UI on field \" + focusedViewId + \" because \"\n                                 + \"service didn't provide a presentation for it on \" + dataset);\n",
    "added_lines": 8,
    "deleted_lines": 3,
    "changed_methods": "FillUi::FillUi"
   },
   {
    "filename": "SaveUi.java",
    "diff": "@@ -368,8 +368,7 @@ final class SaveUi {\n             return false;\n         }\n         writeLog(MetricsEvent.AUTOFILL_SAVE_CUSTOM_DESCRIPTION);\n-\n-        final RemoteViews template = customDescription.getPresentation();\n+        final RemoteViews template = Helper.sanitizeRemoteView(customDescription.getPresentation());\n         if (template == null) {\n             Slog.w(TAG, \"No remote view on custom description\");\n             return false;\n",
    "added_lines": 1,
    "deleted_lines": 2,
    "changed_methods": "SaveUi::applyCustomDescription"
   }
  ]
 },
 {
  "hash": "bc240fffa8cf75caf9fb5a8b14ea125809b8b5f6",
  "commit": "Disallow loading icon from content URI to PipMenu\n\nBug: 278246904\nTest: manually, with the PoC app attached to the bug\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:4bf71d74fc21cd9389dbe00fb750e2f9802eb789)\nMerged-In: Idbd4081bf464e2b3420d4c3fd22ca37867d26bc0\nChange-Id: Idbd4081bf464e2b3420d4c3fd22ca37867d26bc0",
  "files": [
   {
    "filename": "PipMenuView.java",
    "diff": "@@ -43,6 +43,7 @@ import android.content.Intent;\n import android.graphics.Color;\n import android.graphics.Rect;\n import android.graphics.drawable.Drawable;\n+import android.graphics.drawable.Icon;\n import android.net.Uri;\n import android.os.Bundle;\n import android.os.Handler;\n@@ -488,13 +489,19 @@ public class PipMenuView extends FrameLayout {\n                     final PipMenuActionView actionView =\n                             (PipMenuActionView) mActionsGroup.getChildAt(i);\n \n-                    // TODO: Check if the action drawable has changed before we reload it\n-                    action.getIcon().loadDrawableAsync(mContext, d -> {\n-                        if (d != null) {\n-                            d.setTint(Color.WHITE);\n-                            actionView.setImageDrawable(d);\n-                        }\n-                    }, mMainHandler);\n+                    final int iconType = action.getIcon().getType();\n+                    if (iconType == Icon.TYPE_URI || iconType == Icon.TYPE_URI_ADAPTIVE_BITMAP) {\n+                        // Disallow loading icon from content URI\n+                        actionView.setImageDrawable(null);\n+                    } else {\n+                        // TODO: Check if the action drawable has changed before we reload it\n+                        action.getIcon().loadDrawableAsync(mContext, d -> {\n+                            if (d != null) {\n+                                d.setTint(Color.WHITE);\n+                                actionView.setImageDrawable(d);\n+                            }\n+                        }, mMainHandler);\n+                    }\n                     actionView.setContentDescription(action.getContentDescription());\n                     if (action.isEnabled()) {\n                         actionView.setOnClickListener(v -> {\n",
    "added_lines": 14,
    "deleted_lines": 7,
    "changed_methods": "PipMenuView::updateActionViews"
   }
  ]
 },
 {
  "hash": "c28b8b46fbbf28633ecd7a78b7272a0abc3ac245",
  "commit": "Fixing DatabaseUtils to detect malformed UTF-16 strings\n\nTest: tested with POC in bug, also using atest\nBug: 224771621\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:fb4a72e3943d166088407e61aa4439ac349f3f12)\nMerged-In: Ide65205b83063801971c5778af3154bcf3f0e530\nChange-Id: Ide65205b83063801971c5778af3154bcf3f0e530",
  "files": [
   {
    "filename": "DatabaseUtils.java",
    "diff": "@@ -511,17 +511,31 @@ public class DatabaseUtils {\n      */\n     public static void appendEscapedSQLString(StringBuilder sb, String sqlString) {\n         sb.append('\\'');\n-        if (sqlString.indexOf('\\'') != -1) {\n-            int length = sqlString.length();\n-            for (int i = 0; i < length; i++) {\n-                char c = sqlString.charAt(i);\n-                if (c == '\\'') {\n-                    sb.append('\\'');\n+        int length = sqlString.length();\n+        for (int i = 0; i < length; i++) {\n+            char c = sqlString.charAt(i);\n+            if (Character.isHighSurrogate(c)) {\n+                if (i == length - 1) {\n+                    continue;\n+                }\n+                if (Character.isLowSurrogate(sqlString.charAt(i + 1))) {\n+                    // add them both\n+                    sb.append(c);\n+                    sb.append(sqlString.charAt(i + 1));\n+                    continue;\n+                } else {\n+                    // this is a lone surrogate, skip it\n+                    continue;\n                 }\n-                sb.append(c);\n             }\n-        } else\n-            sb.append(sqlString);\n+            if (Character.isLowSurrogate(c)) {\n+                continue;\n+            }\n+            if (c == '\\'') {\n+                sb.append('\\'');\n+            }\n+            sb.append(c);\n+        }\n         sb.append('\\'');\n     }\n \n",
    "added_lines": 23,
    "deleted_lines": 9,
    "changed_methods": "DatabaseUtils::appendEscapedSQLString"
   }
  ]
 },
 {
  "hash": "65a7753ad199415c14a969289e8aea76320f8a78",
  "commit": "RESTRICT AUTOMERGE: SettingsProvider: exclude secure_frp_mode from resets\n\nWhen RescueParty detects that a system process is crashing frequently,\nit tries to recover in various ways, such as by resetting all settings.\nUnfortunately, this included resetting the secure_frp_mode setting,\nwhich is the means by which the system keeps track of whether the\nFactory Reset Protection (FRP) challenge has been passed yet.  With this\nsetting reset, some FRP restrictions went away and it became possible to\nbypass FRP by setting a new lockscreen credential.\n\nFix this by excluding secure_frp_mode from resets.\n\nNote: currently this bug isn't reproducible on 'main' due to ag/23727749\ndisabling much of RescueParty, but that is a temporary change.\n\nBug: 253043065\nTest: With ag/23727749 reverted and with my fix to prevent\n      com.android.settings from crashing *not* applied, tried repeatedly\n      setting lockscreen credential while in FRP mode, using the\n      smartlock setup activity launched by intent via adb.  Verified\n      that although RescueParty is still triggered after 5 attempts,\n      secure_frp_mode is no longer reset (its value remains \"1\").\nTest: Verified that secure_frp_mode still gets changed from 1 to 0 when\n      FRP is passed legitimately.\nTest: atest com.android.providers.settings.SettingsProviderTest\nTest: atest android.provider.SettingsProviderTest\n(cherry picked from commit 9890dd7f15c091f7d1a09e4fddb9f85d32015955)\n(changed Global.SECURE_FRP_MODE to Secure.SECURE_FRP_MODE,\n needed because this setting was moved in U)\n(removed static keyword from shouldExcludeSettingFromReset(),\n needed for compatibility with Java 15 and earlier)\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:30d1770dbfa5d5264083de4d50560e1bde3c4ba1)\nMerged-In: Id95ed43b9cc2208090064392bcd5dc012710af93\nChange-Id: Id95ed43b9cc2208090064392bcd5dc012710af93",
  "files": [
   {
    "filename": "SettingsProvider.java",
    "diff": "@@ -3075,6 +3075,15 @@ public class SettingsProvider extends ContentProvider {\n             return settingsState.getSettingLocked(name);\n         }\n \n+        private boolean shouldExcludeSettingFromReset(Setting setting, String prefix) {\n+            // If a prefix was specified, exclude settings whose names don't start with it.\n+            if (prefix != null && !setting.getName().startsWith(prefix)) {\n+                return true;\n+            }\n+            // Never reset SECURE_FRP_MODE, as it could be abused to bypass FRP via RescueParty.\n+            return Secure.SECURE_FRP_MODE.equals(setting.getName());\n+        }\n+\n         public void resetSettingsLocked(int type, int userId, String packageName, int mode,\n                 String tag) {\n             resetSettingsLocked(type, userId, packageName, mode, tag, /*prefix=*/\n@@ -3097,7 +3106,7 @@ public class SettingsProvider extends ContentProvider {\n                         Setting setting = settingsState.getSettingLocked(name);\n                         if (packageName.equals(setting.getPackageName())) {\n                             if ((tag != null && !tag.equals(setting.getTag()))\n-                                    || (prefix != null && !setting.getName().startsWith(prefix))) {\n+                                    || shouldExcludeSettingFromReset(setting, prefix)) {\n                                 continue;\n                             }\n                             if (settingsState.resetSettingLocked(name)) {\n@@ -3117,7 +3126,7 @@ public class SettingsProvider extends ContentProvider {\n                         Setting setting = settingsState.getSettingLocked(name);\n                         if (!SettingsState.isSystemPackage(getContext(),\n                                 setting.getPackageName())) {\n-                            if (prefix != null && !setting.getName().startsWith(prefix)) {\n+                            if (shouldExcludeSettingFromReset(setting, prefix)) {\n                                 continue;\n                             }\n                             if (settingsState.resetSettingLocked(name)) {\n@@ -3137,7 +3146,7 @@ public class SettingsProvider extends ContentProvider {\n                         Setting setting = settingsState.getSettingLocked(name);\n                         if (!SettingsState.isSystemPackage(getContext(),\n                                 setting.getPackageName())) {\n-                            if (prefix != null && !setting.getName().startsWith(prefix)) {\n+                            if (shouldExcludeSettingFromReset(setting, prefix)) {\n                                 continue;\n                             }\n                             if (setting.isDefaultFromSystem()) {\n@@ -3160,7 +3169,7 @@ public class SettingsProvider extends ContentProvider {\n                     for (String name : settingsState.getSettingNamesLocked()) {\n                         Setting setting = settingsState.getSettingLocked(name);\n                         boolean someSettingChanged = false;\n-                        if (prefix != null && !setting.getName().startsWith(prefix)) {\n+                        if (shouldExcludeSettingFromReset(setting, prefix)) {\n                             continue;\n                         }\n                         if (setting.isDefaultFromSystem()) {\n",
    "added_lines": 13,
    "deleted_lines": 4,
    "changed_methods": "SettingsProvider::SettingsRegistry::shouldExcludeSettingFromReset, SettingsProvider::SettingsRegistry::resetSettingsLocked"
   },
   {
    "filename": "SettingsProviderTest.java",
    "diff": "@@ -466,6 +466,31 @@ public class SettingsProviderTest extends BaseSettingsProviderTest {\n         }\n     }\n \n+    // To prevent FRP bypasses, the SECURE_FRP_MODE setting should not be reset when all other\n+    // settings are reset.  But it should still be possible to explicitly set its value.\n+    @Test\n+    public void testSecureFrpModeSettingCannotBeReset() throws Exception {\n+        final String name = Settings.Secure.SECURE_FRP_MODE;\n+        final String origValue = getSetting(SETTING_TYPE_GLOBAL, name);\n+        setSettingViaShell(SETTING_TYPE_GLOBAL, name, \"1\", false);\n+        try {\n+            assertEquals(\"1\", getSetting(SETTING_TYPE_GLOBAL, name));\n+            for (int type : new int[] { SETTING_TYPE_GLOBAL, SETTING_TYPE_SECURE }) {\n+                resetSettingsViaShell(type, Settings.RESET_MODE_UNTRUSTED_DEFAULTS);\n+                resetSettingsViaShell(type, Settings.RESET_MODE_UNTRUSTED_CHANGES);\n+                resetSettingsViaShell(type, Settings.RESET_MODE_TRUSTED_DEFAULTS);\n+            }\n+            // The value should still be \"1\".  It should not have been reset to null.\n+            assertEquals(\"1\", getSetting(SETTING_TYPE_GLOBAL, name));\n+            // It should still be possible to explicitly set the value to \"0\".\n+            setSettingViaShell(SETTING_TYPE_GLOBAL, name, \"0\", false);\n+            assertEquals(\"0\", getSetting(SETTING_TYPE_GLOBAL, name));\n+        } finally {\n+            setSettingViaShell(SETTING_TYPE_GLOBAL, name, origValue, false);\n+            assertEquals(origValue, getSetting(SETTING_TYPE_GLOBAL, name));\n+        }\n+    }\n+\n     private void doTestQueryStringInBracketsViaProviderApiForType(int type) {\n         // Make sure we have a clean slate.\n         deleteStringViaProviderApi(type, FAKE_SETTING_NAME);\n",
    "added_lines": 25,
    "deleted_lines": 0,
    "changed_methods": "SettingsProviderTest::testSecureFrpModeSettingCannotBeReset"
   }
  ]
 },
 {
  "hash": "65a7753ad199415c14a969289e8aea76320f8a78",
  "commit": "RESTRICT AUTOMERGE: SettingsProvider: exclude secure_frp_mode from resets\n\nWhen RescueParty detects that a system process is crashing frequently,\nit tries to recover in various ways, such as by resetting all settings.\nUnfortunately, this included resetting the secure_frp_mode setting,\nwhich is the means by which the system keeps track of whether the\nFactory Reset Protection (FRP) challenge has been passed yet.  With this\nsetting reset, some FRP restrictions went away and it became possible to\nbypass FRP by setting a new lockscreen credential.\n\nFix this by excluding secure_frp_mode from resets.\n\nNote: currently this bug isn't reproducible on 'main' due to ag/23727749\ndisabling much of RescueParty, but that is a temporary change.\n\nBug: 253043065\nTest: With ag/23727749 reverted and with my fix to prevent\n      com.android.settings from crashing *not* applied, tried repeatedly\n      setting lockscreen credential while in FRP mode, using the\n      smartlock setup activity launched by intent via adb.  Verified\n      that although RescueParty is still triggered after 5 attempts,\n      secure_frp_mode is no longer reset (its value remains \"1\").\nTest: Verified that secure_frp_mode still gets changed from 1 to 0 when\n      FRP is passed legitimately.\nTest: atest com.android.providers.settings.SettingsProviderTest\nTest: atest android.provider.SettingsProviderTest\n(cherry picked from commit 9890dd7f15c091f7d1a09e4fddb9f85d32015955)\n(changed Global.SECURE_FRP_MODE to Secure.SECURE_FRP_MODE,\n needed because this setting was moved in U)\n(removed static keyword from shouldExcludeSettingFromReset(),\n needed for compatibility with Java 15 and earlier)\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:30d1770dbfa5d5264083de4d50560e1bde3c4ba1)\nMerged-In: Id95ed43b9cc2208090064392bcd5dc012710af93\nChange-Id: Id95ed43b9cc2208090064392bcd5dc012710af93",
  "files": [
   {
    "filename": "SettingsProvider.java",
    "diff": "@@ -3075,6 +3075,15 @@ public class SettingsProvider extends ContentProvider {\n             return settingsState.getSettingLocked(name);\n         }\n \n+        private boolean shouldExcludeSettingFromReset(Setting setting, String prefix) {\n+            // If a prefix was specified, exclude settings whose names don't start with it.\n+            if (prefix != null && !setting.getName().startsWith(prefix)) {\n+                return true;\n+            }\n+            // Never reset SECURE_FRP_MODE, as it could be abused to bypass FRP via RescueParty.\n+            return Secure.SECURE_FRP_MODE.equals(setting.getName());\n+        }\n+\n         public void resetSettingsLocked(int type, int userId, String packageName, int mode,\n                 String tag) {\n             resetSettingsLocked(type, userId, packageName, mode, tag, /*prefix=*/\n@@ -3097,7 +3106,7 @@ public class SettingsProvider extends ContentProvider {\n                         Setting setting = settingsState.getSettingLocked(name);\n                         if (packageName.equals(setting.getPackageName())) {\n                             if ((tag != null && !tag.equals(setting.getTag()))\n-                                    || (prefix != null && !setting.getName().startsWith(prefix))) {\n+                                    || shouldExcludeSettingFromReset(setting, prefix)) {\n                                 continue;\n                             }\n                             if (settingsState.resetSettingLocked(name)) {\n@@ -3117,7 +3126,7 @@ public class SettingsProvider extends ContentProvider {\n                         Setting setting = settingsState.getSettingLocked(name);\n                         if (!SettingsState.isSystemPackage(getContext(),\n                                 setting.getPackageName())) {\n-                            if (prefix != null && !setting.getName().startsWith(prefix)) {\n+                            if (shouldExcludeSettingFromReset(setting, prefix)) {\n                                 continue;\n                             }\n                             if (settingsState.resetSettingLocked(name)) {\n@@ -3137,7 +3146,7 @@ public class SettingsProvider extends ContentProvider {\n                         Setting setting = settingsState.getSettingLocked(name);\n                         if (!SettingsState.isSystemPackage(getContext(),\n                                 setting.getPackageName())) {\n-                            if (prefix != null && !setting.getName().startsWith(prefix)) {\n+                            if (shouldExcludeSettingFromReset(setting, prefix)) {\n                                 continue;\n                             }\n                             if (setting.isDefaultFromSystem()) {\n@@ -3160,7 +3169,7 @@ public class SettingsProvider extends ContentProvider {\n                     for (String name : settingsState.getSettingNamesLocked()) {\n                         Setting setting = settingsState.getSettingLocked(name);\n                         boolean someSettingChanged = false;\n-                        if (prefix != null && !setting.getName().startsWith(prefix)) {\n+                        if (shouldExcludeSettingFromReset(setting, prefix)) {\n                             continue;\n                         }\n                         if (setting.isDefaultFromSystem()) {\n",
    "added_lines": 13,
    "deleted_lines": 4,
    "changed_methods": "SettingsProvider::SettingsRegistry::shouldExcludeSettingFromReset, SettingsProvider::SettingsRegistry::resetSettingsLocked"
   },
   {
    "filename": "SettingsProviderTest.java",
    "diff": "@@ -466,6 +466,31 @@ public class SettingsProviderTest extends BaseSettingsProviderTest {\n         }\n     }\n \n+    // To prevent FRP bypasses, the SECURE_FRP_MODE setting should not be reset when all other\n+    // settings are reset.  But it should still be possible to explicitly set its value.\n+    @Test\n+    public void testSecureFrpModeSettingCannotBeReset() throws Exception {\n+        final String name = Settings.Secure.SECURE_FRP_MODE;\n+        final String origValue = getSetting(SETTING_TYPE_GLOBAL, name);\n+        setSettingViaShell(SETTING_TYPE_GLOBAL, name, \"1\", false);\n+        try {\n+            assertEquals(\"1\", getSetting(SETTING_TYPE_GLOBAL, name));\n+            for (int type : new int[] { SETTING_TYPE_GLOBAL, SETTING_TYPE_SECURE }) {\n+                resetSettingsViaShell(type, Settings.RESET_MODE_UNTRUSTED_DEFAULTS);\n+                resetSettingsViaShell(type, Settings.RESET_MODE_UNTRUSTED_CHANGES);\n+                resetSettingsViaShell(type, Settings.RESET_MODE_TRUSTED_DEFAULTS);\n+            }\n+            // The value should still be \"1\".  It should not have been reset to null.\n+            assertEquals(\"1\", getSetting(SETTING_TYPE_GLOBAL, name));\n+            // It should still be possible to explicitly set the value to \"0\".\n+            setSettingViaShell(SETTING_TYPE_GLOBAL, name, \"0\", false);\n+            assertEquals(\"0\", getSetting(SETTING_TYPE_GLOBAL, name));\n+        } finally {\n+            setSettingViaShell(SETTING_TYPE_GLOBAL, name, origValue, false);\n+            assertEquals(origValue, getSetting(SETTING_TYPE_GLOBAL, name));\n+        }\n+    }\n+\n     private void doTestQueryStringInBracketsViaProviderApiForType(int type) {\n         // Make sure we have a clean slate.\n         deleteStringViaProviderApi(type, FAKE_SETTING_NAME);\n",
    "added_lines": 25,
    "deleted_lines": 0,
    "changed_methods": "SettingsProviderTest::testSecureFrpModeSettingCannotBeReset"
   }
  ]
 },
 {
  "hash": "e3723d5b82b41892f11dab9fa12fb45cab186d73",
  "commit": "[RESTRICT AUTOMERGE] Ignore small source rect hint\n\nWhich may be abused by malicious app to create a non-visible PiP\nwindow that bypasses the background restriction.\n\nBug: 270368476\nTest: Manually, using the POC app\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:4fda9095ba9bdecb8250336d4f0ca328ed7c2aea)\nMerged-In: I3531a64fc67a1b6c43997ee33b7a7d4ab4e2d985\nChange-Id: I3531a64fc67a1b6c43997ee33b7a7d4ab4e2d985",
  "files": [
   {
    "filename": "PipBoundsAlgorithm.java",
    "diff": "@@ -182,6 +182,21 @@ public class PipBoundsAlgorithm {\n         return null;\n     }\n \n+    /**\n+     * Returns the source hint rect if it is valid (if provided and is contained by the current\n+     * task bounds and not too small).\n+     */\n+    public static Rect getValidSourceHintRect(PictureInPictureParams params, Rect sourceBounds,\n+                @NonNull Rect destinationBounds) {\n+        final Rect sourceHintRect = getValidSourceHintRect(params, sourceBounds);\n+        if (sourceHintRect != null\n+                && sourceHintRect.width() > destinationBounds.width()\n+                && sourceHintRect.height() > destinationBounds.height()) {\n+            return sourceHintRect;\n+        }\n+        return null;\n+    }\n+\n     public float getDefaultAspectRatio() {\n         return mDefaultAspectRatio;\n     }\n",
    "added_lines": 15,
    "deleted_lines": 0,
    "changed_methods": "PipBoundsAlgorithm::getValidSourceHintRect"
   },
   {
    "filename": "PipTaskOrganizer.java",
    "diff": "@@ -553,7 +553,7 @@ public class PipTaskOrganizer implements ShellTaskOrganizer.TaskListener,\n         if (mOneShotAnimationType == ANIM_TYPE_BOUNDS) {\n             mPipMenuController.attach(mLeash);\n             final Rect sourceHintRect = PipBoundsAlgorithm.getValidSourceHintRect(\n-                    info.pictureInPictureParams, currentBounds);\n+                    info.pictureInPictureParams, currentBounds, destinationBounds);\n             scheduleAnimateResizePip(currentBounds, destinationBounds, 0 /* startingAngle */,\n                     sourceHintRect, TRANSITION_DIRECTION_TO_PIP, mEnterAnimationDuration,\n                     null /* updateBoundsCallback */);\n@@ -579,9 +579,9 @@ public class PipTaskOrganizer implements ShellTaskOrganizer.TaskListener,\n             return;\n         }\n         final Rect currentBounds = mTaskInfo.configuration.windowConfiguration.getBounds();\n-        final Rect sourceHintRect = PipBoundsAlgorithm.getValidSourceHintRect(\n-                mPictureInPictureParams, currentBounds);\n         final Rect destinationBounds = mPipBoundsAlgorithm.getEntryDestinationBounds();\n+        final Rect sourceHintRect = PipBoundsAlgorithm.getValidSourceHintRect(\n+                mPictureInPictureParams, currentBounds, destinationBounds);\n         animateResizePip(currentBounds, destinationBounds, sourceHintRect,\n                 TRANSITION_DIRECTION_TO_PIP, mEnterAnimationDuration, 0 /* startingAngle */);\n         mPipTransitionState.setTransitionState(PipTransitionState.ENTERING_PIP);\n",
    "added_lines": 3,
    "deleted_lines": 3,
    "changed_methods": "PipTaskOrganizer::onTaskAppearedWithFixedRotation, PipTaskOrganizer::onTaskAppeared"
   },
   {
    "filename": "PipTransition.java",
    "diff": "@@ -318,7 +318,7 @@ public class PipTransition extends PipTransitionController {\n         if (mOneShotAnimationType == ANIM_TYPE_BOUNDS) {\n             final Rect sourceHintRect =\n                     PipBoundsAlgorithm.getValidSourceHintRect(\n-                            taskInfo.pictureInPictureParams, currentBounds);\n+                            taskInfo.pictureInPictureParams, currentBounds, destinationBounds);\n             animator = mPipAnimationController.getAnimator(taskInfo, leash, currentBounds,\n                     currentBounds, destinationBounds, sourceHintRect, TRANSITION_DIRECTION_TO_PIP,\n                     0 /* startingAngle */, rotationDelta);\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "PipTransition::startEnterAnimation"
   }
  ]
 },
 {
  "hash": "e3723d5b82b41892f11dab9fa12fb45cab186d73",
  "commit": "[RESTRICT AUTOMERGE] Ignore small source rect hint\n\nWhich may be abused by malicious app to create a non-visible PiP\nwindow that bypasses the background restriction.\n\nBug: 270368476\nTest: Manually, using the POC app\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:4fda9095ba9bdecb8250336d4f0ca328ed7c2aea)\nMerged-In: I3531a64fc67a1b6c43997ee33b7a7d4ab4e2d985\nChange-Id: I3531a64fc67a1b6c43997ee33b7a7d4ab4e2d985",
  "files": [
   {
    "filename": "PipBoundsAlgorithm.java",
    "diff": "@@ -182,6 +182,21 @@ public class PipBoundsAlgorithm {\n         return null;\n     }\n \n+    /**\n+     * Returns the source hint rect if it is valid (if provided and is contained by the current\n+     * task bounds and not too small).\n+     */\n+    public static Rect getValidSourceHintRect(PictureInPictureParams params, Rect sourceBounds,\n+                @NonNull Rect destinationBounds) {\n+        final Rect sourceHintRect = getValidSourceHintRect(params, sourceBounds);\n+        if (sourceHintRect != null\n+                && sourceHintRect.width() > destinationBounds.width()\n+                && sourceHintRect.height() > destinationBounds.height()) {\n+            return sourceHintRect;\n+        }\n+        return null;\n+    }\n+\n     public float getDefaultAspectRatio() {\n         return mDefaultAspectRatio;\n     }\n",
    "added_lines": 15,
    "deleted_lines": 0,
    "changed_methods": "PipBoundsAlgorithm::getValidSourceHintRect"
   },
   {
    "filename": "PipTaskOrganizer.java",
    "diff": "@@ -553,7 +553,7 @@ public class PipTaskOrganizer implements ShellTaskOrganizer.TaskListener,\n         if (mOneShotAnimationType == ANIM_TYPE_BOUNDS) {\n             mPipMenuController.attach(mLeash);\n             final Rect sourceHintRect = PipBoundsAlgorithm.getValidSourceHintRect(\n-                    info.pictureInPictureParams, currentBounds);\n+                    info.pictureInPictureParams, currentBounds, destinationBounds);\n             scheduleAnimateResizePip(currentBounds, destinationBounds, 0 /* startingAngle */,\n                     sourceHintRect, TRANSITION_DIRECTION_TO_PIP, mEnterAnimationDuration,\n                     null /* updateBoundsCallback */);\n@@ -579,9 +579,9 @@ public class PipTaskOrganizer implements ShellTaskOrganizer.TaskListener,\n             return;\n         }\n         final Rect currentBounds = mTaskInfo.configuration.windowConfiguration.getBounds();\n-        final Rect sourceHintRect = PipBoundsAlgorithm.getValidSourceHintRect(\n-                mPictureInPictureParams, currentBounds);\n         final Rect destinationBounds = mPipBoundsAlgorithm.getEntryDestinationBounds();\n+        final Rect sourceHintRect = PipBoundsAlgorithm.getValidSourceHintRect(\n+                mPictureInPictureParams, currentBounds, destinationBounds);\n         animateResizePip(currentBounds, destinationBounds, sourceHintRect,\n                 TRANSITION_DIRECTION_TO_PIP, mEnterAnimationDuration, 0 /* startingAngle */);\n         mPipTransitionState.setTransitionState(PipTransitionState.ENTERING_PIP);\n",
    "added_lines": 3,
    "deleted_lines": 3,
    "changed_methods": "PipTaskOrganizer::onTaskAppearedWithFixedRotation, PipTaskOrganizer::onTaskAppeared"
   },
   {
    "filename": "PipTransition.java",
    "diff": "@@ -318,7 +318,7 @@ public class PipTransition extends PipTransitionController {\n         if (mOneShotAnimationType == ANIM_TYPE_BOUNDS) {\n             final Rect sourceHintRect =\n                     PipBoundsAlgorithm.getValidSourceHintRect(\n-                            taskInfo.pictureInPictureParams, currentBounds);\n+                            taskInfo.pictureInPictureParams, currentBounds, destinationBounds);\n             animator = mPipAnimationController.getAnimator(taskInfo, leash, currentBounds,\n                     currentBounds, destinationBounds, sourceHintRect, TRANSITION_DIRECTION_TO_PIP,\n                     0 /* startingAngle */, rotationDelta);\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "PipTransition::startEnterAnimation"
   }
  ]
 },
 {
  "hash": "e3723d5b82b41892f11dab9fa12fb45cab186d73",
  "commit": "[RESTRICT AUTOMERGE] Ignore small source rect hint\n\nWhich may be abused by malicious app to create a non-visible PiP\nwindow that bypasses the background restriction.\n\nBug: 270368476\nTest: Manually, using the POC app\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:4fda9095ba9bdecb8250336d4f0ca328ed7c2aea)\nMerged-In: I3531a64fc67a1b6c43997ee33b7a7d4ab4e2d985\nChange-Id: I3531a64fc67a1b6c43997ee33b7a7d4ab4e2d985",
  "files": [
   {
    "filename": "PipBoundsAlgorithm.java",
    "diff": "@@ -182,6 +182,21 @@ public class PipBoundsAlgorithm {\n         return null;\n     }\n \n+    /**\n+     * Returns the source hint rect if it is valid (if provided and is contained by the current\n+     * task bounds and not too small).\n+     */\n+    public static Rect getValidSourceHintRect(PictureInPictureParams params, Rect sourceBounds,\n+                @NonNull Rect destinationBounds) {\n+        final Rect sourceHintRect = getValidSourceHintRect(params, sourceBounds);\n+        if (sourceHintRect != null\n+                && sourceHintRect.width() > destinationBounds.width()\n+                && sourceHintRect.height() > destinationBounds.height()) {\n+            return sourceHintRect;\n+        }\n+        return null;\n+    }\n+\n     public float getDefaultAspectRatio() {\n         return mDefaultAspectRatio;\n     }\n",
    "added_lines": 15,
    "deleted_lines": 0,
    "changed_methods": "PipBoundsAlgorithm::getValidSourceHintRect"
   },
   {
    "filename": "PipTaskOrganizer.java",
    "diff": "@@ -553,7 +553,7 @@ public class PipTaskOrganizer implements ShellTaskOrganizer.TaskListener,\n         if (mOneShotAnimationType == ANIM_TYPE_BOUNDS) {\n             mPipMenuController.attach(mLeash);\n             final Rect sourceHintRect = PipBoundsAlgorithm.getValidSourceHintRect(\n-                    info.pictureInPictureParams, currentBounds);\n+                    info.pictureInPictureParams, currentBounds, destinationBounds);\n             scheduleAnimateResizePip(currentBounds, destinationBounds, 0 /* startingAngle */,\n                     sourceHintRect, TRANSITION_DIRECTION_TO_PIP, mEnterAnimationDuration,\n                     null /* updateBoundsCallback */);\n@@ -579,9 +579,9 @@ public class PipTaskOrganizer implements ShellTaskOrganizer.TaskListener,\n             return;\n         }\n         final Rect currentBounds = mTaskInfo.configuration.windowConfiguration.getBounds();\n-        final Rect sourceHintRect = PipBoundsAlgorithm.getValidSourceHintRect(\n-                mPictureInPictureParams, currentBounds);\n         final Rect destinationBounds = mPipBoundsAlgorithm.getEntryDestinationBounds();\n+        final Rect sourceHintRect = PipBoundsAlgorithm.getValidSourceHintRect(\n+                mPictureInPictureParams, currentBounds, destinationBounds);\n         animateResizePip(currentBounds, destinationBounds, sourceHintRect,\n                 TRANSITION_DIRECTION_TO_PIP, mEnterAnimationDuration, 0 /* startingAngle */);\n         mPipTransitionState.setTransitionState(PipTransitionState.ENTERING_PIP);\n",
    "added_lines": 3,
    "deleted_lines": 3,
    "changed_methods": "PipTaskOrganizer::onTaskAppearedWithFixedRotation, PipTaskOrganizer::onTaskAppeared"
   },
   {
    "filename": "PipTransition.java",
    "diff": "@@ -318,7 +318,7 @@ public class PipTransition extends PipTransitionController {\n         if (mOneShotAnimationType == ANIM_TYPE_BOUNDS) {\n             final Rect sourceHintRect =\n                     PipBoundsAlgorithm.getValidSourceHintRect(\n-                            taskInfo.pictureInPictureParams, currentBounds);\n+                            taskInfo.pictureInPictureParams, currentBounds, destinationBounds);\n             animator = mPipAnimationController.getAnimator(taskInfo, leash, currentBounds,\n                     currentBounds, destinationBounds, sourceHintRect, TRANSITION_DIRECTION_TO_PIP,\n                     0 /* startingAngle */, rotationDelta);\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "PipTransition::startEnterAnimation"
   }
  ]
 },
 {
  "hash": "0b7e9f1dd833986faa7004f8fdbb9d65f213efa5",
  "commit": "Revert \"Dismiss keyguard when simpin auth'd and...\"\n\nRevert submission 22621774-cherrypicker-L22000000959901080:N28400001357657640\n\nReason for revert: causing a partner bug\nFixes: 295205456\nBug: 222446076\n\nReverted changes: /q/submissionid:22621774-cherrypicker-L22000000959901080:N28400001357657640\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:cdb57ca0a6462cf1d2b3f2469952586138c2cc43)\nMerged-In: Icb27b4d897696b4fbb4e4a878751d925f5205dfd\nChange-Id: Icb27b4d897696b4fbb4e4a878751d925f5205dfd",
  "files": [
   {
    "filename": "KeyguardSecurityContainerController.java",
    "diff": "@@ -426,7 +426,7 @@ public class KeyguardSecurityContainerController extends ViewController<Keyguard\n                 case SimPuk:\n                     // Shortcut for SIM PIN/PUK to go to directly to user's security screen or home\n                     SecurityMode securityMode = mSecurityModel.getSecurityMode(targetUserId);\n-                    if (securityMode == SecurityMode.None || mLockPatternUtils.isLockScreenDisabled(\n+                    if (securityMode == SecurityMode.None && mLockPatternUtils.isLockScreenDisabled(\n                             KeyguardUpdateMonitor.getCurrentUser())) {\n                         finish = true;\n                         eventSubtype = BOUNCER_DISMISS_SIM;\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "KeyguardSecurityContainerController::showNextSecurityScreenOrFinish"
   }
  ]
 },
 {
  "hash": "19d66c209a5e505ec352e6c64421297dd7627c8a",
  "commit": "DO NOT MERGE Fix BAL via notification.publicVersion\n\nWe stripped the token that allows app to retrieve their own notification\nand fire their own PI to launch activities from background. But we\nforgot to strip the token from notification.publicVersion\n\nBug: 278558814\nTest: NotificationManagerTest#testActivityStartFromRetrievedNotification_isBlocked\n(cherry picked from commit cf851d81a954f0a6dd0c2fd7defa93932539e7f9)\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:8d839e4985d0acc662e1019390c88fab20bacbd6)\nMerged-In: I8f25d7a5e47890a0496af023149717e1df482f98\nChange-Id: I8f25d7a5e47890a0496af023149717e1df482f98",
  "files": [
   {
    "filename": "Notification.java",
    "diff": "@@ -3357,8 +3357,11 @@ public class Notification implements Parcelable\n      *\n      * @hide\n      */\n-    public void setAllowlistToken(@Nullable IBinder token) {\n-        mAllowlistToken = token;\n+    public void clearAllowlistToken() {\n+        mAllowlistToken = null;\n+        if (publicVersion != null) {\n+            publicVersion.clearAllowlistToken();\n+        }\n     }\n \n     /**\n",
    "added_lines": 5,
    "deleted_lines": 2,
    "changed_methods": "Notification::setAllowlistToken, Notification::clearAllowlistToken"
   },
   {
    "filename": "NotificationManagerService.java",
    "diff": "@@ -4240,7 +4240,7 @@ public class NotificationManagerService extends SystemService {\n                     // Remove background token before returning notification to untrusted app, this\n                     // ensures the app isn't able to perform background operations that are\n                     // associated with notification interactions.\n-                    notification.setAllowlistToken(null);\n+                    notification.clearAllowlistToken();\n                     return new StatusBarNotification(\n                             sbn.getPackageName(),\n                             sbn.getOpPkg(),\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "NotificationManagerService::Stub"
   }
  ]
 },
 {
  "hash": "19d66c209a5e505ec352e6c64421297dd7627c8a",
  "commit": "DO NOT MERGE Fix BAL via notification.publicVersion\n\nWe stripped the token that allows app to retrieve their own notification\nand fire their own PI to launch activities from background. But we\nforgot to strip the token from notification.publicVersion\n\nBug: 278558814\nTest: NotificationManagerTest#testActivityStartFromRetrievedNotification_isBlocked\n(cherry picked from commit cf851d81a954f0a6dd0c2fd7defa93932539e7f9)\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:8d839e4985d0acc662e1019390c88fab20bacbd6)\nMerged-In: I8f25d7a5e47890a0496af023149717e1df482f98\nChange-Id: I8f25d7a5e47890a0496af023149717e1df482f98",
  "files": [
   {
    "filename": "Notification.java",
    "diff": "@@ -3357,8 +3357,11 @@ public class Notification implements Parcelable\n      *\n      * @hide\n      */\n-    public void setAllowlistToken(@Nullable IBinder token) {\n-        mAllowlistToken = token;\n+    public void clearAllowlistToken() {\n+        mAllowlistToken = null;\n+        if (publicVersion != null) {\n+            publicVersion.clearAllowlistToken();\n+        }\n     }\n \n     /**\n",
    "added_lines": 5,
    "deleted_lines": 2,
    "changed_methods": "Notification::setAllowlistToken, Notification::clearAllowlistToken"
   },
   {
    "filename": "NotificationManagerService.java",
    "diff": "@@ -4240,7 +4240,7 @@ public class NotificationManagerService extends SystemService {\n                     // Remove background token before returning notification to untrusted app, this\n                     // ensures the app isn't able to perform background operations that are\n                     // associated with notification interactions.\n-                    notification.setAllowlistToken(null);\n+                    notification.clearAllowlistToken();\n                     return new StatusBarNotification(\n                             sbn.getPackageName(),\n                             sbn.getOpPkg(),\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "NotificationManagerService::Stub"
   }
  ]
 },
 {
  "hash": "1aa5689959c783e10574b5b0c13e4ed4d34bbaae",
  "commit": "[DO NOT MERGE] Check caller's uid in backupAgentCreated callback\n\nAM.backupAgentCreated() should enforce that caller belongs the package called in the API.\n\nBug: 289549315\nTest: atest android.security.cts.ActivityManagerTest#testActivityManager_backupAgentCreated_rejectIfCallerUidNotEqualsPackageUid\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:ebdcc72a235d6b2a65e1d1c99d7a9eb89f309357)\nMerged-In: I9f3ae5ec0b8f00e020d471cc0eddf8bd8bdbb82d\nChange-Id: I9f3ae5ec0b8f00e020d471cc0eddf8bd8bdbb82d",
  "files": [
   {
    "filename": "ActivityManagerService.java",
    "diff": "@@ -2807,6 +2807,22 @@ public class ActivityManagerService extends IActivityManager.Stub\n         }\n     }\n \n+    /**\n+     * Enforces that the uid of the caller matches the uid of the package.\n+     *\n+     * @param packageName the name of the package to match uid against.\n+     * @param callingUid the uid of the caller.\n+     * @throws SecurityException if the calling uid doesn't match uid of the package.\n+     */\n+    private void enforceCallingPackage(String packageName, int callingUid) {\n+        final int userId = UserHandle.getUserId(callingUid);\n+        final int packageUid = getPackageManagerInternal().getPackageUid(packageName,\n+                /*flags=*/ 0, userId);\n+        if (packageUid != callingUid) {\n+            throw new SecurityException(packageName + \" does not belong to uid \" + callingUid);\n+        }\n+    }\n+\n     @Override\n     public void setPackageScreenCompatMode(String packageName, int mode) {\n         mActivityTaskManager.setPackageScreenCompatMode(packageName, mode);\n@@ -12267,13 +12283,16 @@ public class ActivityManagerService extends IActivityManager.Stub\n     // A backup agent has just come up\n     @Override\n     public void backupAgentCreated(String agentPackageName, IBinder agent, int userId) {\n+        final int callingUid = Binder.getCallingUid();\n+        enforceCallingPackage(agentPackageName, callingUid);\n+\n         // Resolve the target user id and enforce permissions.\n-        userId = mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(),\n+        userId = mUserController.handleIncomingUser(Binder.getCallingPid(), callingUid,\n                 userId, /* allowAll */ false, ALLOW_FULL_ONLY, \"backupAgentCreated\", null);\n         if (DEBUG_BACKUP) {\n             Slog.v(TAG_BACKUP, \"backupAgentCreated: \" + agentPackageName + \" = \" + agent\n                     + \" callingUserId = \" + UserHandle.getCallingUserId() + \" userId = \" + userId\n-                    + \" callingUid = \" + Binder.getCallingUid() + \" uid = \" + Process.myUid());\n+                    + \" callingUid = \" + callingUid + \" uid = \" + Process.myUid());\n         }\n \n         synchronized(this) {\n",
    "added_lines": 21,
    "deleted_lines": 2,
    "changed_methods": "ActivityManagerService::backupAgentCreated, ActivityManagerService::enforceCallingPackage"
   }
  ]
 },
 {
  "hash": "9a7ef3dc845c229d21061548d0f5d9b0be978b72",
  "commit": "Use type safe API of readParcelableArray\n\nBug: 291299076\nTest: Build and flash the device and check if it throws exception for\nnon UsbInterface object\nTest: atest CtsUsbManagerTestCases\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:85d7e6712a9eeeed3bdd68ea3c3862c7e88bfe70)\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:0362efc06e5e3987270b452f6e2ee8fcd78e2b5a)\nMerged-In: I2917c8331b6d56caaa9a6479bcd9a2d089f5f503\nChange-Id: I2917c8331b6d56caaa9a6479bcd9a2d089f5f503",
  "files": [
   {
    "filename": "UsbConfiguration.java",
    "diff": "@@ -172,7 +172,8 @@ public class UsbConfiguration implements Parcelable {\n             String name = in.readString();\n             int attributes = in.readInt();\n             int maxPower = in.readInt();\n-            Parcelable[] interfaces = in.readParcelableArray(UsbInterface.class.getClassLoader());\n+            Parcelable[] interfaces = in.readParcelableArray(\n+                    UsbInterface.class.getClassLoader(), UsbInterface.class);\n             UsbConfiguration configuration = new UsbConfiguration(id, name, attributes, maxPower);\n             configuration.setInterfaces(interfaces);\n             return configuration;\n",
    "added_lines": 2,
    "deleted_lines": 1,
    "changed_methods": "UsbConfiguration::Creator<UsbConfiguration>"
   }
  ]
 },
 {
  "hash": "c2a24edb3e383e4abd3044e64e25fb9d5c3eb251",
  "commit": "[SettingsProvider] verify ringtone URI before setting\n\nSimilar to ag/24422287, but the same URI verification should be done in\nSettingsProvider as well, which can be called by apps via\nSettings.System API or ContentProvider APIs without using\nRingtoneManager.\n\nBUG: 227201030\nTest: manual with a test app. Will add a CTS test.\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:1b234678ec122994ccbfc52ac48aafdad7fdb1ed)\nMerged-In: Ic0ffa1db14b5660d02880b632a7f2ad9e6e5d84b\nChange-Id: Ic0ffa1db14b5660d02880b632a7f2ad9e6e5d84b",
  "files": [
   {
    "filename": "SettingsProvider.java",
    "diff": "@@ -1906,6 +1906,9 @@ public class SettingsProvider extends ContentProvider {\n             cacheName = Settings.System.ALARM_ALERT_CACHE;\n         }\n         if (cacheName != null) {\n+            if (!isValidAudioUri(name, value)) {\n+                return false;\n+            }\n             final File cacheFile = new File(\n                     getRingtoneCacheDir(owningUserId), cacheName);\n             cacheFile.delete();\n@@ -1938,6 +1941,34 @@ public class SettingsProvider extends ContentProvider {\n         }\n     }\n \n+    private boolean isValidAudioUri(String name, String uri) {\n+        if (uri != null) {\n+            Uri audioUri = Uri.parse(uri);\n+            if (Settings.AUTHORITY.equals(\n+                    ContentProvider.getAuthorityWithoutUserId(audioUri.getAuthority()))) {\n+                // Don't accept setting the default uri to self-referential URIs like\n+                // Settings.System.DEFAULT_RINGTONE_URI, which is an alias to the value of this\n+                // setting.\n+                return false;\n+            }\n+            final String mimeType = getContext().getContentResolver().getType(audioUri);\n+            if (mimeType == null) {\n+                Slog.e(LOG_TAG,\n+                        \"mutateSystemSetting for setting: \" + name + \" URI: \" + audioUri\n+                        + \" ignored: failure to find mimeType (no access from this context?)\");\n+                return false;\n+            }\n+            if (!(mimeType.startsWith(\"audio/\") || mimeType.equals(\"application/ogg\")\n+                    || mimeType.equals(\"application/x-flac\"))) {\n+                Slog.e(LOG_TAG,\n+                        \"mutateSystemSetting for setting: \" + name + \" URI: \" + audioUri\n+                        + \" ignored: associated mimeType: \" + mimeType + \" is not an audio type\");\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n     private boolean hasWriteSecureSettingsPermission() {\n         // Write secure settings is a more protected permission. If caller has it we are good.\n         return getContext().checkCallingOrSelfPermission(Manifest.permission.WRITE_SECURE_SETTINGS)\n",
    "added_lines": 31,
    "deleted_lines": 0,
    "changed_methods": "SettingsProvider::mutateSystemSetting, SettingsProvider::isValidAudioUri"
   }
  ]
 },
 {
  "hash": "a47eec4fba3344b724ae0ca2e0e37985307d0696",
  "commit": "Visit Uris added by WearableExtender\n\nBug: 283962802\nTest: atest + manual (POC app now crashes on notify() as expected)\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:3d36966ea2aeebc3501a69a8ef7afce5ef593cee)\nMerged-In: I0da18c631eb5e4844a48760c7aaedab715a0bfed\nChange-Id: I0da18c631eb5e4844a48760c7aaedab715a0bfed",
  "files": [
   {
    "filename": "Notification.java",
    "diff": "@@ -2092,6 +2092,10 @@ public class Notification implements Parcelable\n             }\n         }\n \n+        private void visitUris(@NonNull Consumer<Uri> visitor) {\n+            visitIconUri(visitor, getIcon());\n+        }\n+\n         @Override\n         public Action clone() {\n             return new Action(\n@@ -2777,7 +2781,7 @@ public class Notification implements Parcelable\n \n         if (actions != null) {\n             for (Action action : actions) {\n-                visitIconUri(visitor, action.getIcon());\n+                action.visitUris(visitor);\n             }\n         }\n \n@@ -2865,6 +2869,11 @@ public class Notification implements Parcelable\n         if (mBubbleMetadata != null) {\n             visitIconUri(visitor, mBubbleMetadata.getIcon());\n         }\n+\n+        if (extras != null && extras.containsKey(WearableExtender.EXTRA_WEARABLE_EXTENSIONS)) {\n+            WearableExtender extender = new WearableExtender(this);\n+            extender.visitUris(visitor);\n+        }\n     }\n \n     /**\n@@ -11419,6 +11428,12 @@ public class Notification implements Parcelable\n                 mFlags &= ~mask;\n             }\n         }\n+\n+        private void visitUris(@NonNull Consumer<Uri> visitor) {\n+            for (Action action : mActions) {\n+                action.visitUris(visitor);\n+            }\n+        }\n     }\n \n     /**\n",
    "added_lines": 16,
    "deleted_lines": 1,
    "changed_methods": "Notification::visitUris, Notification::Action::visitUris, Notification::WearableExtender::visitUris"
   },
   {
    "filename": "NotificationManagerServiceTest.java",
    "diff": "@@ -4637,6 +4637,26 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n         verify(visitor, times(1)).accept(eq(verificationIcon.getUri()));\n     }\n \n+    @Test\n+    public void testVisitUris_wearableExtender() {\n+        Icon actionIcon = Icon.createWithContentUri(\"content://media/action\");\n+        Icon wearActionIcon = Icon.createWithContentUri(\"content://media/wearAction\");\n+        PendingIntent intent = PendingIntent.getActivity(mContext, 0, new Intent(),\n+                PendingIntent.FLAG_IMMUTABLE);\n+        Notification n = new Notification.Builder(mContext, \"a\")\n+                .setSmallIcon(android.R.drawable.sym_def_app_icon)\n+                .addAction(new Notification.Action.Builder(actionIcon, \"Hey!\", intent).build())\n+                .extend(new Notification.WearableExtender().addAction(\n+                        new Notification.Action.Builder(wearActionIcon, \"Wear!\", intent).build()))\n+                .build();\n+\n+        Consumer<Uri> visitor = (Consumer<Uri>) spy(Consumer.class);\n+        n.visitUris(visitor);\n+\n+        verify(visitor).accept(eq(actionIcon.getUri()));\n+        verify(visitor).accept(eq(wearActionIcon.getUri()));\n+    }\n+\n     @Test\n     public void testSetNotificationPolicy_preP_setOldFields() {\n         ZenModeHelper mZenModeHelper = mock(ZenModeHelper.class);\n",
    "added_lines": 20,
    "deleted_lines": 0,
    "changed_methods": "NotificationManagerServiceTest::testVisitUris_wearableExtender"
   }
  ]
 },
 {
  "hash": "a47eec4fba3344b724ae0ca2e0e37985307d0696",
  "commit": "Visit Uris added by WearableExtender\n\nBug: 283962802\nTest: atest + manual (POC app now crashes on notify() as expected)\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:3d36966ea2aeebc3501a69a8ef7afce5ef593cee)\nMerged-In: I0da18c631eb5e4844a48760c7aaedab715a0bfed\nChange-Id: I0da18c631eb5e4844a48760c7aaedab715a0bfed",
  "files": [
   {
    "filename": "Notification.java",
    "diff": "@@ -2092,6 +2092,10 @@ public class Notification implements Parcelable\n             }\n         }\n \n+        private void visitUris(@NonNull Consumer<Uri> visitor) {\n+            visitIconUri(visitor, getIcon());\n+        }\n+\n         @Override\n         public Action clone() {\n             return new Action(\n@@ -2777,7 +2781,7 @@ public class Notification implements Parcelable\n \n         if (actions != null) {\n             for (Action action : actions) {\n-                visitIconUri(visitor, action.getIcon());\n+                action.visitUris(visitor);\n             }\n         }\n \n@@ -2865,6 +2869,11 @@ public class Notification implements Parcelable\n         if (mBubbleMetadata != null) {\n             visitIconUri(visitor, mBubbleMetadata.getIcon());\n         }\n+\n+        if (extras != null && extras.containsKey(WearableExtender.EXTRA_WEARABLE_EXTENSIONS)) {\n+            WearableExtender extender = new WearableExtender(this);\n+            extender.visitUris(visitor);\n+        }\n     }\n \n     /**\n@@ -11419,6 +11428,12 @@ public class Notification implements Parcelable\n                 mFlags &= ~mask;\n             }\n         }\n+\n+        private void visitUris(@NonNull Consumer<Uri> visitor) {\n+            for (Action action : mActions) {\n+                action.visitUris(visitor);\n+            }\n+        }\n     }\n \n     /**\n",
    "added_lines": 16,
    "deleted_lines": 1,
    "changed_methods": "Notification::visitUris, Notification::Action::visitUris, Notification::WearableExtender::visitUris"
   },
   {
    "filename": "NotificationManagerServiceTest.java",
    "diff": "@@ -4637,6 +4637,26 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n         verify(visitor, times(1)).accept(eq(verificationIcon.getUri()));\n     }\n \n+    @Test\n+    public void testVisitUris_wearableExtender() {\n+        Icon actionIcon = Icon.createWithContentUri(\"content://media/action\");\n+        Icon wearActionIcon = Icon.createWithContentUri(\"content://media/wearAction\");\n+        PendingIntent intent = PendingIntent.getActivity(mContext, 0, new Intent(),\n+                PendingIntent.FLAG_IMMUTABLE);\n+        Notification n = new Notification.Builder(mContext, \"a\")\n+                .setSmallIcon(android.R.drawable.sym_def_app_icon)\n+                .addAction(new Notification.Action.Builder(actionIcon, \"Hey!\", intent).build())\n+                .extend(new Notification.WearableExtender().addAction(\n+                        new Notification.Action.Builder(wearActionIcon, \"Wear!\", intent).build()))\n+                .build();\n+\n+        Consumer<Uri> visitor = (Consumer<Uri>) spy(Consumer.class);\n+        n.visitUris(visitor);\n+\n+        verify(visitor).accept(eq(actionIcon.getUri()));\n+        verify(visitor).accept(eq(wearActionIcon.getUri()));\n+    }\n+\n     @Test\n     public void testSetNotificationPolicy_preP_setOldFields() {\n         ZenModeHelper mZenModeHelper = mock(ZenModeHelper.class);\n",
    "added_lines": 20,
    "deleted_lines": 0,
    "changed_methods": "NotificationManagerServiceTest::testVisitUris_wearableExtender"
   }
  ]
 },
 {
  "hash": "a76d515c92b5a854536dc16768c47577c3bcc945",
  "commit": "Fix bypass BAL via `requestGeofence`\n\nBug: 273729172\nTest: manually\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:7f9be7c3c859dc82d37452570d9878b58f6437a9)\nMerged-In: Ia8094244f908b20d42711b6ea8f58f9b3345b563\nChange-Id: Ia8094244f908b20d42711b6ea8f58f9b3345b563",
  "files": [
   {
    "filename": "PendingIntentUtils.java",
    "diff": "@@ -34,6 +34,7 @@ public class PendingIntentUtils {\n     public static Bundle createDontSendToRestrictedAppsBundle(@Nullable Bundle bundle) {\n         final BroadcastOptions options = BroadcastOptions.makeBasic();\n         options.setDontSendToRestrictedApps(true);\n+        options.setPendingIntentBackgroundActivityLaunchAllowed(false);\n         if (bundle == null) {\n             return options.toBundle();\n         }\n",
    "added_lines": 1,
    "deleted_lines": 0,
    "changed_methods": "PendingIntentUtils::createDontSendToRestrictedAppsBundle"
   }
  ]
 },
 {
  "hash": "c17682ed92206abf2db40f6f27de1a3d8ab2a855",
  "commit": "Visit Uris related to Notification style extras\n\nEven if the corresponding styles themselves were not applied to the Notification.Builder.\n\nTest: atest NotificationManagerServiceTest\nBug: 287640400\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:87db980ca1270083a2ba3c7317402a0cd289fd65)\nMerged-In: I25acab19be7dd486aabede8c91dbad5a1a217abf\nChange-Id: I25acab19be7dd486aabede8c91dbad5a1a217abf",
  "files": [
   {
    "filename": "Notification.java",
    "diff": "@@ -2811,11 +2811,6 @@ public class Notification implements Parcelable\n                 }\n             }\n \n-            final Person person = extras.getParcelable(EXTRA_MESSAGING_PERSON);\n-            if (person != null) {\n-                visitor.accept(person.getIconUri());\n-            }\n-\n             final RemoteInputHistoryItem[] history = getParcelableArrayFromBundle(extras,\n                 Notification.EXTRA_REMOTE_INPUT_HISTORY_ITEMS, RemoteInputHistoryItem.class);\n             if (history != null) {\n@@ -2826,9 +2821,14 @@ public class Notification implements Parcelable\n                     }\n                 }\n             }\n-        }\n \n-        if (isStyle(MessagingStyle.class) && extras != null) {\n+            // Extras for MessagingStyle. We visit them even if not isStyle(MessagingStyle), since\n+            // Notification Listeners might use directly (without the isStyle check).\n+            final Person person = extras.getParcelable(EXTRA_MESSAGING_PERSON);\n+            if (person != null) {\n+                visitor.accept(person.getIconUri());\n+            }\n+\n             final Parcelable[] messages = extras.getParcelableArray(EXTRA_MESSAGES);\n             if (!ArrayUtils.isEmpty(messages)) {\n                 for (MessagingStyle.Message message : MessagingStyle.Message\n@@ -2856,9 +2856,8 @@ public class Notification implements Parcelable\n             }\n \n             visitIconUri(visitor, extras.getParcelable(EXTRA_CONVERSATION_ICON));\n-        }\n \n-        if (isStyle(CallStyle.class) & extras != null) {\n+            // Extras for CallStyle (same reason for visiting without checking isStyle).\n             Person callPerson = extras.getParcelable(EXTRA_CALL_PERSON);\n             if (callPerson != null) {\n                 visitor.accept(callPerson.getIconUri());\n",
    "added_lines": 8,
    "deleted_lines": 9,
    "changed_methods": "Notification::visitUris"
   },
   {
    "filename": "NotificationManagerServiceTest.java",
    "diff": "@@ -4637,6 +4637,49 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n         verify(visitor, times(1)).accept(eq(verificationIcon.getUri()));\n     }\n \n+    @Test\n+    public void testVisitUris_styleExtrasWithoutStyle() {\n+        Notification notification = new Notification.Builder(mContext, \"a\")\n+                .setSmallIcon(android.R.drawable.sym_def_app_icon)\n+                .build();\n+\n+        Notification.MessagingStyle messagingStyle = new Notification.MessagingStyle(\n+                personWithIcon(\"content://user\"))\n+                .addHistoricMessage(new Notification.MessagingStyle.Message(\"Heyhey!\",\n+                                System.currentTimeMillis(),\n+                                personWithIcon(\"content://historicalMessenger\")))\n+                .addMessage(new Notification.MessagingStyle.Message(\"Are you there\",\n+                                System.currentTimeMillis(),\n+                                personWithIcon(\"content://messenger\")))\n+                        .setShortcutIcon(\n+                                Icon.createWithContentUri(\"content://conversationShortcut\"));\n+        messagingStyle.addExtras(notification.extras); // Instead of Builder.setStyle(style).\n+\n+        Notification.CallStyle callStyle = Notification.CallStyle.forOngoingCall(\n+                        personWithIcon(\"content://caller\"),\n+                        PendingIntent.getActivity(mContext, 0, new Intent(),\n+                                PendingIntent.FLAG_IMMUTABLE))\n+                .setVerificationIcon(Icon.createWithContentUri(\"content://callVerification\"));\n+        callStyle.addExtras(notification.extras); // Same.\n+\n+        Consumer<Uri> visitor = (Consumer<Uri>) spy(Consumer.class);\n+        notification.visitUris(visitor);\n+\n+        verify(visitor).accept(eq(Uri.parse(\"content://user\")));\n+        verify(visitor).accept(eq(Uri.parse(\"content://historicalMessenger\")));\n+        verify(visitor).accept(eq(Uri.parse(\"content://messenger\")));\n+        verify(visitor).accept(eq(Uri.parse(\"content://conversationShortcut\")));\n+        verify(visitor).accept(eq(Uri.parse(\"content://caller\")));\n+        verify(visitor).accept(eq(Uri.parse(\"content://callVerification\")));\n+    }\n+\n+    private static Person personWithIcon(String iconUri) {\n+        return new Person.Builder()\n+                .setName(\"Mr \" + iconUri)\n+                .setIcon(Icon.createWithContentUri(iconUri))\n+                .build();\n+    }\n+\n     @Test\n     public void testVisitUris_wearableExtender() {\n         Icon actionIcon = Icon.createWithContentUri(\"content://media/action\");\n",
    "added_lines": 43,
    "deleted_lines": 0,
    "changed_methods": "NotificationManagerServiceTest::personWithIcon, NotificationManagerServiceTest::testVisitUris_styleExtrasWithoutStyle"
   }
  ]
 },
 {
  "hash": "c17682ed92206abf2db40f6f27de1a3d8ab2a855",
  "commit": "Visit Uris related to Notification style extras\n\nEven if the corresponding styles themselves were not applied to the Notification.Builder.\n\nTest: atest NotificationManagerServiceTest\nBug: 287640400\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:87db980ca1270083a2ba3c7317402a0cd289fd65)\nMerged-In: I25acab19be7dd486aabede8c91dbad5a1a217abf\nChange-Id: I25acab19be7dd486aabede8c91dbad5a1a217abf",
  "files": [
   {
    "filename": "Notification.java",
    "diff": "@@ -2811,11 +2811,6 @@ public class Notification implements Parcelable\n                 }\n             }\n \n-            final Person person = extras.getParcelable(EXTRA_MESSAGING_PERSON);\n-            if (person != null) {\n-                visitor.accept(person.getIconUri());\n-            }\n-\n             final RemoteInputHistoryItem[] history = getParcelableArrayFromBundle(extras,\n                 Notification.EXTRA_REMOTE_INPUT_HISTORY_ITEMS, RemoteInputHistoryItem.class);\n             if (history != null) {\n@@ -2826,9 +2821,14 @@ public class Notification implements Parcelable\n                     }\n                 }\n             }\n-        }\n \n-        if (isStyle(MessagingStyle.class) && extras != null) {\n+            // Extras for MessagingStyle. We visit them even if not isStyle(MessagingStyle), since\n+            // Notification Listeners might use directly (without the isStyle check).\n+            final Person person = extras.getParcelable(EXTRA_MESSAGING_PERSON);\n+            if (person != null) {\n+                visitor.accept(person.getIconUri());\n+            }\n+\n             final Parcelable[] messages = extras.getParcelableArray(EXTRA_MESSAGES);\n             if (!ArrayUtils.isEmpty(messages)) {\n                 for (MessagingStyle.Message message : MessagingStyle.Message\n@@ -2856,9 +2856,8 @@ public class Notification implements Parcelable\n             }\n \n             visitIconUri(visitor, extras.getParcelable(EXTRA_CONVERSATION_ICON));\n-        }\n \n-        if (isStyle(CallStyle.class) & extras != null) {\n+            // Extras for CallStyle (same reason for visiting without checking isStyle).\n             Person callPerson = extras.getParcelable(EXTRA_CALL_PERSON);\n             if (callPerson != null) {\n                 visitor.accept(callPerson.getIconUri());\n",
    "added_lines": 8,
    "deleted_lines": 9,
    "changed_methods": "Notification::visitUris"
   },
   {
    "filename": "NotificationManagerServiceTest.java",
    "diff": "@@ -4637,6 +4637,49 @@ public class NotificationManagerServiceTest extends UiServiceTestCase {\n         verify(visitor, times(1)).accept(eq(verificationIcon.getUri()));\n     }\n \n+    @Test\n+    public void testVisitUris_styleExtrasWithoutStyle() {\n+        Notification notification = new Notification.Builder(mContext, \"a\")\n+                .setSmallIcon(android.R.drawable.sym_def_app_icon)\n+                .build();\n+\n+        Notification.MessagingStyle messagingStyle = new Notification.MessagingStyle(\n+                personWithIcon(\"content://user\"))\n+                .addHistoricMessage(new Notification.MessagingStyle.Message(\"Heyhey!\",\n+                                System.currentTimeMillis(),\n+                                personWithIcon(\"content://historicalMessenger\")))\n+                .addMessage(new Notification.MessagingStyle.Message(\"Are you there\",\n+                                System.currentTimeMillis(),\n+                                personWithIcon(\"content://messenger\")))\n+                        .setShortcutIcon(\n+                                Icon.createWithContentUri(\"content://conversationShortcut\"));\n+        messagingStyle.addExtras(notification.extras); // Instead of Builder.setStyle(style).\n+\n+        Notification.CallStyle callStyle = Notification.CallStyle.forOngoingCall(\n+                        personWithIcon(\"content://caller\"),\n+                        PendingIntent.getActivity(mContext, 0, new Intent(),\n+                                PendingIntent.FLAG_IMMUTABLE))\n+                .setVerificationIcon(Icon.createWithContentUri(\"content://callVerification\"));\n+        callStyle.addExtras(notification.extras); // Same.\n+\n+        Consumer<Uri> visitor = (Consumer<Uri>) spy(Consumer.class);\n+        notification.visitUris(visitor);\n+\n+        verify(visitor).accept(eq(Uri.parse(\"content://user\")));\n+        verify(visitor).accept(eq(Uri.parse(\"content://historicalMessenger\")));\n+        verify(visitor).accept(eq(Uri.parse(\"content://messenger\")));\n+        verify(visitor).accept(eq(Uri.parse(\"content://conversationShortcut\")));\n+        verify(visitor).accept(eq(Uri.parse(\"content://caller\")));\n+        verify(visitor).accept(eq(Uri.parse(\"content://callVerification\")));\n+    }\n+\n+    private static Person personWithIcon(String iconUri) {\n+        return new Person.Builder()\n+                .setName(\"Mr \" + iconUri)\n+                .setIcon(Icon.createWithContentUri(iconUri))\n+                .build();\n+    }\n+\n     @Test\n     public void testVisitUris_wearableExtender() {\n         Icon actionIcon = Icon.createWithContentUri(\"content://media/action\");\n",
    "added_lines": 43,
    "deleted_lines": 0,
    "changed_methods": "NotificationManagerServiceTest::personWithIcon, NotificationManagerServiceTest::testVisitUris_styleExtrasWithoutStyle"
   }
  ]
 },
 {
  "hash": "547b1d1ba0eecc25c98ae61e3d55903d0fc8d5bb",
  "commit": "RESTRICT AUTOMERGE: Drop invalid data.\n\nDrop invalid data when writing or reading from XML. PersistableBundle\ndoes lazy unparcelling, so checking the values during unparcelling would\nremove the benefit of the lazy unparcelling. Checking the validity when\nwriting to or reading from XML seems like the best alternative.\n\nBug: 246542285\nBug: 247513680\nTest: install test app with invalid job config, start app to schedule job, then check logcat and jobscheduler persisted file\n(cherry picked from commit 666e8ac60a31e2cc52b335b41004263f28a8db06)\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:0e0819c9d6a957e56764c89e68542bb51bdb7db4)\nMerged-In: Ie817aa0993e9046cb313a750d2323cadc8c1ef15\nChange-Id: Ie817aa0993e9046cb313a750d2323cadc8c1ef15",
  "files": [
   {
    "filename": "PersistableBundle.java",
    "diff": "@@ -21,6 +21,7 @@ import static java.nio.charset.StandardCharsets.UTF_8;\n import android.annotation.NonNull;\n import android.annotation.Nullable;\n import android.util.ArrayMap;\n+import android.util.Slog;\n import android.util.TypedXmlPullParser;\n import android.util.TypedXmlSerializer;\n import android.util.Xml;\n@@ -46,6 +47,8 @@ import java.util.ArrayList;\n  */\n public final class PersistableBundle extends BaseBundle implements Cloneable, Parcelable,\n         XmlUtils.WriteMapCallback {\n+    private static final String TAG = \"PersistableBundle\";\n+\n     private static final String TAG_PERSISTABLEMAP = \"pbundle_as_map\";\n \n     /** An unmodifiable {@code PersistableBundle} that is always {@link #isEmpty() empty}. */\n@@ -110,7 +113,11 @@ public final class PersistableBundle extends BaseBundle implements Cloneable, Pa\n      * @hide\n      */\n     public PersistableBundle(Bundle b) {\n-        this(b.getMap());\n+        this(b, true);\n+    }\n+\n+    private PersistableBundle(Bundle b, boolean throwException) {\n+        this(b.getMap(), throwException);\n     }\n \n     /**\n@@ -119,7 +126,7 @@ public final class PersistableBundle extends BaseBundle implements Cloneable, Pa\n      * @param map a Map containing only those items that can be persisted.\n      * @throws IllegalArgumentException if any element of #map cannot be persisted.\n      */\n-    private PersistableBundle(ArrayMap<String, Object> map) {\n+    private PersistableBundle(ArrayMap<String, Object> map, boolean throwException) {\n         super();\n         mFlags = FLAG_DEFUSABLE;\n \n@@ -128,16 +135,23 @@ public final class PersistableBundle extends BaseBundle implements Cloneable, Pa\n \n         // Now verify each item throwing an exception if there is a violation.\n         final int N = mMap.size();\n-        for (int i=0; i<N; i++) {\n+        for (int i = N - 1; i >= 0; --i) {\n             Object value = mMap.valueAt(i);\n             if (value instanceof ArrayMap) {\n                 // Fix up any Maps by replacing them with PersistableBundles.\n-                mMap.setValueAt(i, new PersistableBundle((ArrayMap<String, Object>) value));\n+                mMap.setValueAt(i,\n+                        new PersistableBundle((ArrayMap<String, Object>) value, throwException));\n             } else if (value instanceof Bundle) {\n-                mMap.setValueAt(i, new PersistableBundle(((Bundle) value)));\n+                mMap.setValueAt(i, new PersistableBundle((Bundle) value, throwException));\n             } else if (!isValidType(value)) {\n-                throw new IllegalArgumentException(\"Bad value in PersistableBundle key=\"\n-                        + mMap.keyAt(i) + \" value=\" + value);\n+                final String errorMsg = \"Bad value in PersistableBundle key=\"\n+                        + mMap.keyAt(i) + \" value=\" + value;\n+                if (throwException) {\n+                    throw new IllegalArgumentException(errorMsg);\n+                } else {\n+                    Slog.wtfStack(TAG, errorMsg);\n+                    mMap.removeAt(i);\n+                }\n             }\n         }\n     }\n@@ -257,6 +271,15 @@ public final class PersistableBundle extends BaseBundle implements Cloneable, Pa\n     /** @hide */\n     public void saveToXml(TypedXmlSerializer out) throws IOException, XmlPullParserException {\n         unparcel();\n+        // Explicitly drop invalid types an attacker may have added before persisting.\n+        for (int i = mMap.size() - 1; i >= 0; --i) {\n+            final Object value = mMap.valueAt(i);\n+            if (!isValidType(value)) {\n+                Slog.e(TAG, \"Dropping bad data before persisting: \"\n+                        + mMap.keyAt(i) + \"=\" + value);\n+                mMap.removeAt(i);\n+            }\n+        }\n         XmlUtils.writeMapXml(mMap, out, this);\n     }\n \n@@ -311,9 +334,12 @@ public final class PersistableBundle extends BaseBundle implements Cloneable, Pa\n         while (((event = in.next()) != XmlPullParser.END_DOCUMENT) &&\n                 (event != XmlPullParser.END_TAG || in.getDepth() < outerDepth)) {\n             if (event == XmlPullParser.START_TAG) {\n+                // Don't throw an exception when restoring from XML since an attacker could try to\n+                // input invalid data in the persisted file.\n                 return new PersistableBundle((ArrayMap<String, Object>)\n                         XmlUtils.readThisArrayMapXml(in, startTag, tagName,\n-                        new MyReadMapCallback()));\n+                        new MyReadMapCallback()),\n+                        /* throwException */ false);\n             }\n         }\n         return EMPTY;\n",
    "added_lines": 34,
    "deleted_lines": 8,
    "changed_methods": "PersistableBundle::saveToXml, PersistableBundle::restoreFromXml, PersistableBundle::PersistableBundle, PersistableBundle::PersistableBundle, PersistableBundle::PersistableBundle, PersistableBundle::PersistableBundle"
   }
  ]
 },
 {
  "hash": "d8f3301840a28985d71438a7924bb884f36e8dbe",
  "commit": "Validate URI-based shortcut icon at creation time.\n\nBug: 288113797\nTest: manual\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:3d41fb7620ffb9c81b23977c8367c323e4721e65)\nMerged-In: I392f8e923923bf40827a2b6207c4eaa262694fbc\nChange-Id: I392f8e923923bf40827a2b6207c4eaa262694fbc",
  "files": [
   {
    "filename": "ShortcutService.java",
    "diff": "@@ -34,6 +34,7 @@ import android.app.usage.UsageStatsManagerInternal;\n import android.appwidget.AppWidgetProviderInfo;\n import android.content.BroadcastReceiver;\n import android.content.ComponentName;\n+import android.content.ContentProvider;\n import android.content.Context;\n import android.content.Intent;\n import android.content.IntentFilter;\n@@ -1900,11 +1901,32 @@ public class ShortcutService extends IShortcutService.Stub {\n         }\n         if (shortcut.getIcon() != null) {\n             ShortcutInfo.validateIcon(shortcut.getIcon());\n+            validateIconURI(shortcut);\n         }\n \n         shortcut.replaceFlags(shortcut.getFlags() & ShortcutInfo.FLAG_LONG_LIVED);\n     }\n \n+    // Validates the calling process has permission to access shortcut icon's image uri\n+    private void validateIconURI(@NonNull final ShortcutInfo si) {\n+        final int callingUid = injectBinderCallingUid();\n+        final Icon icon = si.getIcon();\n+        if (icon == null) {\n+            // There's no icon in this shortcut, nothing to validate here.\n+            return;\n+        }\n+        int iconType = icon.getType();\n+        if (iconType != Icon.TYPE_URI && iconType != Icon.TYPE_URI_ADAPTIVE_BITMAP) {\n+            // The icon is not URI-based, nothing to validate.\n+            return;\n+        }\n+        final Uri uri = icon.getUri();\n+        mUriGrantsManagerInternal.checkGrantUriPermission(callingUid, si.getPackage(),\n+                ContentProvider.getUriWithoutUserId(uri),\n+                Intent.FLAG_GRANT_READ_URI_PERMISSION,\n+                ContentProvider.getUserIdFromUri(uri, UserHandle.getUserId(callingUid)));\n+    }\n+\n     private void fixUpIncomingShortcutInfo(@NonNull ShortcutInfo shortcut, boolean forUpdate) {\n         fixUpIncomingShortcutInfo(shortcut, forUpdate, /*forPinRequest=*/ false);\n     }\n",
    "added_lines": 22,
    "deleted_lines": 0,
    "changed_methods": "ShortcutService::fixUpIncomingShortcutInfo, ShortcutService::validateIconURI"
   }
  ]
 },
 {
  "hash": "9c0e09e708a704425e0acca6a75341f740c8fa70",
  "commit": "Disable priority conversation widget for secondary users\n\nTest: NotificationConversationInfoTest.java\nTest: make a conversation priority on the primary user\nTest: make a conversation priority on a secondary user\nBug: 288896269\n(cherry picked from commit adf620316dcfaf19d7d4a73e2c63322b4a3a4d3a)\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:b0522df0a33d0165656797df7edab978cb403bd4)\nMerged-In: I3f3991d2cb7fb9970cc8ada39ceae9a7ff2fcb31\nChange-Id: I3f3991d2cb7fb9970cc8ada39ceae9a7ff2fcb31",
  "files": [
   {
    "filename": "NotificationsModule.java",
    "diff": "@@ -21,6 +21,7 @@ import android.content.Context;\n import android.content.pm.LauncherApps;\n import android.content.pm.ShortcutManager;\n import android.os.Handler;\n+import android.os.UserManager;\n import android.view.accessibility.AccessibilityManager;\n \n import com.android.internal.logging.UiEventLogger;\n@@ -144,6 +145,7 @@ public interface NotificationsModule {\n             HighPriorityProvider highPriorityProvider,\n             INotificationManager notificationManager,\n             NotificationEntryManager notificationEntryManager,\n+            UserManager userManager,\n             PeopleSpaceWidgetManager peopleSpaceWidgetManager,\n             LauncherApps launcherApps,\n             ShortcutManager shortcutManager,\n@@ -164,6 +166,7 @@ public interface NotificationsModule {\n                 highPriorityProvider,\n                 notificationManager,\n                 notificationEntryManager,\n+                userManager,\n                 peopleSpaceWidgetManager,\n                 launcherApps,\n                 shortcutManager,\n",
    "added_lines": 3,
    "deleted_lines": 0,
    "changed_methods": "provideNotificationGutsManager"
   },
   {
    "filename": "NotificationConversationInfo.java",
    "diff": "@@ -48,6 +48,7 @@ import android.os.Bundle;\n import android.os.Handler;\n import android.os.RemoteException;\n import android.os.UserHandle;\n+import android.os.UserManager;\n import android.service.notification.StatusBarNotification;\n import android.text.TextUtils;\n import android.transition.ChangeBounds;\n@@ -118,6 +119,8 @@ public class NotificationConversationInfo extends LinearLayout implements\n     private NotificationGuts mGutsContainer;\n     private OnConversationSettingsClickListener mOnConversationSettingsClickListener;\n \n+    private UserManager mUm;\n+\n     @VisibleForTesting\n     boolean mSkipPost = false;\n     private int mActualHeight;\n@@ -152,10 +155,12 @@ public class NotificationConversationInfo extends LinearLayout implements\n         mPressedApply = true;\n \n         // If the user selected Priority and the previous selection was not priority, show a\n-        // People Tile add request.\n+        // People Tile add request if for same profile group.\n         if (mSelectedAction == ACTION_FAVORITE && getPriority() != mSelectedAction) {\n             mShadeController.animateCollapsePanels();\n-            mPeopleSpaceWidgetManager.requestPinAppWidget(mShortcutInfo, new Bundle());\n+            if (mUm.isSameProfileGroup(UserHandle.USER_SYSTEM, mSbn.getNormalizedUserId())) {\n+                mPeopleSpaceWidgetManager.requestPinAppWidget(mShortcutInfo, new Bundle());\n+            }\n         }\n         mGutsContainer.closeControls(v, true);\n     };\n@@ -189,6 +194,7 @@ public class NotificationConversationInfo extends LinearLayout implements\n             @Action int selectedAction,\n             ShortcutManager shortcutManager,\n             PackageManager pm,\n+            UserManager um,\n             PeopleSpaceWidgetManager peopleSpaceWidgetManager,\n             INotificationManager iNotificationManager,\n             OnUserInteractionCallback onUserInteractionCallback,\n@@ -214,6 +220,7 @@ public class NotificationConversationInfo extends LinearLayout implements\n         mEntry = entry;\n         mSbn = entry.getSbn();\n         mPm = pm;\n+        mUm = um;\n         mAppName = mPackageName;\n         mOnSettingsClickListener = onSettingsClick;\n         mNotificationChannel = notificationChannel;\n",
    "added_lines": 9,
    "deleted_lines": 2,
    "changed_methods": "NotificationConversationInfo::bindNotification, NotificationConversationInfo::if"
   },
   {
    "filename": "NotificationGutsManager.java",
    "diff": "@@ -31,6 +31,7 @@ import android.net.Uri;\n import android.os.Bundle;\n import android.os.Handler;\n import android.os.UserHandle;\n+import android.os.UserManager;\n import android.provider.Settings;\n import android.service.notification.StatusBarNotification;\n import android.util.ArraySet;\n@@ -127,6 +128,9 @@ public class NotificationGutsManager implements Dumpable, NotificationLifetimeEx\n     private Runnable mOpenRunnable;\n     private final INotificationManager mNotificationManager;\n     private final PeopleSpaceWidgetManager mPeopleSpaceWidgetManager;\n+\n+    private final UserManager mUserManager;\n+\n     private final LauncherApps mLauncherApps;\n     private final ShortcutManager mShortcutManager;\n     private final UserContextProvider mContextTracker;\n@@ -146,6 +150,7 @@ public class NotificationGutsManager implements Dumpable, NotificationLifetimeEx\n             HighPriorityProvider highPriorityProvider,\n             INotificationManager notificationManager,\n             NotificationEntryManager notificationEntryManager,\n+            UserManager userManager,\n             PeopleSpaceWidgetManager peopleSpaceWidgetManager,\n             LauncherApps launcherApps,\n             ShortcutManager shortcutManager,\n@@ -164,6 +169,7 @@ public class NotificationGutsManager implements Dumpable, NotificationLifetimeEx\n         mAccessibilityManager = accessibilityManager;\n         mHighPriorityProvider = highPriorityProvider;\n         mNotificationManager = notificationManager;\n+        mUserManager = userManager;\n         mPeopleSpaceWidgetManager = peopleSpaceWidgetManager;\n         mLauncherApps = launcherApps;\n         mShortcutManager = shortcutManager;\n@@ -491,6 +497,7 @@ public class NotificationGutsManager implements Dumpable, NotificationLifetimeEx\n                 notificationInfoView.getSelectedAction(),\n                 mShortcutManager,\n                 pmUser,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mNotificationManager,\n                 mOnUserInteractionCallback,\n",
    "added_lines": 7,
    "deleted_lines": 0,
    "changed_methods": "NotificationGutsManager::NotificationGutsManager, NotificationGutsManager::initializeConversationNotificationInfo"
   },
   {
    "filename": "NotificationConversationInfoTest.java",
    "diff": "@@ -62,6 +62,7 @@ import android.graphics.drawable.Drawable;\n import android.graphics.drawable.Icon;\n import android.os.Handler;\n import android.os.UserHandle;\n+import android.os.UserManager;\n import android.service.notification.StatusBarNotification;\n import android.test.suitebuilder.annotation.SmallTest;\n import android.testing.AndroidTestingRunner;\n@@ -132,6 +133,8 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n     @Mock\n     private PackageManager mMockPackageManager;\n     @Mock\n+    private UserManager mUserManager;\n+    @Mock\n     private OnUserInteractionCallback mOnUserInteractionCallback;\n     @Mock\n     private BubblesManager mBubblesManager;\n@@ -239,6 +242,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -264,6 +268,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -317,6 +322,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -343,6 +349,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -368,6 +375,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -404,6 +412,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -430,6 +439,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -460,6 +470,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -485,6 +496,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -514,6 +526,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -543,6 +556,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -575,6 +589,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -613,6 +628,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -642,6 +658,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -678,6 +695,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -707,6 +725,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -752,6 +771,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -796,6 +816,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -841,6 +862,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -879,6 +901,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -916,6 +939,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -957,6 +981,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1, // no action selected by default\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -988,6 +1013,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 NotificationConversationInfo.ACTION_FAVORITE, // \"Favorite\" selected by default\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -1018,6 +1044,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -1055,6 +1082,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -1092,6 +1120,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -1128,6 +1157,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -1163,6 +1193,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -1189,6 +1220,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -1210,12 +1242,14 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n \n     @Test\n     public void testSelectPriorityRequestsPinPeopleTile() {\n+        when(mUserManager.isSameProfileGroup(anyInt(), anyInt())).thenReturn(true);\n         //WHEN channel is default importance\n         mNotificationChannel.setImportantConversation(false);\n         mNotificationInfo.bindNotification(\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -1241,12 +1275,48 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n         verify(mPeopleSpaceWidgetManager, times(1)).requestPinAppWidget(any(), any());\n     }\n \n+    @Test\n+    public void testSelectPriorityRequestsPinPeopleTile_noMultiuser() {\n+        when(mUserManager.isSameProfileGroup(anyInt(), anyInt())).thenReturn(false);\n+        //WHEN channel is default importance\n+        mNotificationChannel.setImportantConversation(false);\n+        mNotificationInfo.bindNotification(\n+                -1,\n+                mShortcutManager,\n+                mMockPackageManager,\n+                mUserManager,\n+                mPeopleSpaceWidgetManager,\n+                mMockINotificationManager,\n+                mOnUserInteractionCallback,\n+                TEST_PACKAGE_NAME,\n+                mNotificationChannel,\n+                mEntry,\n+                mBubbleMetadata,\n+                null,\n+                mIconFactory,\n+                mContext,\n+                true,\n+                mTestHandler,\n+                mTestHandler, null, Optional.of(mBubblesManager),\n+                mShadeController);\n+\n+        // WHEN user clicks \"priority\"\n+        mNotificationInfo.setSelectedAction(NotificationConversationInfo.ACTION_FAVORITE);\n+\n+        // and then done\n+        mNotificationInfo.findViewById(R.id.done).performClick();\n+\n+        // No widget prompt; on a secondary user\n+        verify(mPeopleSpaceWidgetManager, never()).requestPinAppWidget(any(), any());\n+    }\n+\n     @Test\n     public void testSelectDefaultDoesNotRequestPinPeopleTile() {\n         mNotificationInfo.bindNotification(\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -1282,6 +1352,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n",
    "added_lines": 71,
    "deleted_lines": 0,
    "changed_methods": "NotificationConversationInfoTest::testBindNotification_priorityDnd, NotificationConversationInfoTest::testBindNotification_priorityDndAndBubble, NotificationConversationInfoTest::testDefault_andSave_doesNotChangeNonImportantBubbling, NotificationConversationInfoTest::testBindNotification_SetsShortcutIcon, NotificationConversationInfoTest::testBindNotification_SetsTextGroupName, NotificationConversationInfoTest::testSelectPriority_AlreadyPriority_DoesNotRequestPinPeopleTile, NotificationConversationInfoTest::testDefault_andSave, NotificationConversationInfoTest::testSelectPriorityRequestsPinPeopleTile_noMultiuser, NotificationConversationInfoTest::testDefault_andSave_doesNotDemoteImportance, NotificationConversationInfoTest::testBindNotification_SetsOnClickListenerForSettings, NotificationConversationInfoTest::testBindNotification_GroupNameHiddenIfNoGroup, NotificationConversationInfoTest::testDefaultSelectedWhenChannelIsDefault, NotificationConversationInfoTest::testBindNotification_noDelegate, NotificationConversationInfoTest::testBindNotification_default_allCanBubble, NotificationConversationInfoTest::testFavoriteSelectedWhenChannelIsDefault, NotificationConversationInfoTest::testSilence_andSave, NotificationConversationInfoTest::testBindNotification_SetsTextApplicationName, NotificationConversationInfoTest::testBindNotification_delegate, NotificationConversationInfoTest::testFavorite, NotificationConversationInfoTest::testBindNotification_SettingsButtonInvisibleWhenNoClickListener, NotificationConversationInfoTest::testBindNotification_createsNewChannel, NotificationConversationInfoTest::testSelectPriorityRequestsPinPeopleTile, NotificationConversationInfoTest::testBindNotification_silentSelected_isFave_isSilent, NotificationConversationInfoTest::testSelectDefaultDoesNotRequestPinPeopleTile, NotificationConversationInfoTest::testFavorite_andSave, NotificationConversationInfoTest::testBindNotification_priorityBaseline, NotificationConversationInfoTest::testBindNotification_SettingsButtonInvisibleWhenDeviceUnprovisioned, NotificationConversationInfoTest::testBindNotification_defaultSelected_notFave_notSilent, NotificationConversationInfoTest::testBindNotification_doesNotCreateNewChannelIfExists, NotificationConversationInfoTest::testSilence, NotificationConversationInfoTest::testDefault, NotificationConversationInfoTest::testFavorite_andSave_doesNotLowerImportance, NotificationConversationInfoTest::testFavorite_thenDefaultThenFavorite_andSave_nothingChanged"
   },
   {
    "filename": "NotificationGutsManagerTest.java",
    "diff": "@@ -54,6 +54,7 @@ import android.content.pm.ShortcutManager;\n import android.graphics.Color;\n import android.os.Binder;\n import android.os.Handler;\n+import android.os.UserManager;\n import android.provider.Settings;\n import android.service.notification.StatusBarNotification;\n import android.testing.AndroidTestingRunner;\n@@ -139,6 +140,8 @@ public class NotificationGutsManagerTest extends SysuiTestCase {\n     @Mock private PeopleSpaceWidgetManager mPeopleSpaceWidgetManager;\n     @Mock private AssistantFeedbackController mAssistantFeedbackController;\n \n+    @Mock private UserManager mUserManager;\n+\n     @Before\n     public void setUp() {\n         mTestableLooper = TestableLooper.get(this);\n@@ -156,7 +159,8 @@ public class NotificationGutsManagerTest extends SysuiTestCase {\n \n         mGutsManager = new NotificationGutsManager(mContext,\n                 () -> Optional.of(mStatusBar), mHandler, mHandler, mAccessibilityManager,\n-                mHighPriorityProvider, mINotificationManager, mNotificationEntryManager,\n+                mHighPriorityProvider, mINotificationManager, mUserManager,\n+                mNotificationEntryManager,\n                 mPeopleSpaceWidgetManager, mLauncherApps, mShortcutManager,\n                 mChannelEditorDialogController, mContextTracker, mAssistantFeedbackController,\n                 Optional.of(mBubblesManager), new UiEventLoggerFake(), mOnUserInteractionCallback,\n",
    "added_lines": 5,
    "deleted_lines": 1,
    "changed_methods": "NotificationGutsManagerTest::setUp"
   }
  ]
 },
 {
  "hash": "9c0e09e708a704425e0acca6a75341f740c8fa70",
  "commit": "Disable priority conversation widget for secondary users\n\nTest: NotificationConversationInfoTest.java\nTest: make a conversation priority on the primary user\nTest: make a conversation priority on a secondary user\nBug: 288896269\n(cherry picked from commit adf620316dcfaf19d7d4a73e2c63322b4a3a4d3a)\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:b0522df0a33d0165656797df7edab978cb403bd4)\nMerged-In: I3f3991d2cb7fb9970cc8ada39ceae9a7ff2fcb31\nChange-Id: I3f3991d2cb7fb9970cc8ada39ceae9a7ff2fcb31",
  "files": [
   {
    "filename": "NotificationsModule.java",
    "diff": "@@ -21,6 +21,7 @@ import android.content.Context;\n import android.content.pm.LauncherApps;\n import android.content.pm.ShortcutManager;\n import android.os.Handler;\n+import android.os.UserManager;\n import android.view.accessibility.AccessibilityManager;\n \n import com.android.internal.logging.UiEventLogger;\n@@ -144,6 +145,7 @@ public interface NotificationsModule {\n             HighPriorityProvider highPriorityProvider,\n             INotificationManager notificationManager,\n             NotificationEntryManager notificationEntryManager,\n+            UserManager userManager,\n             PeopleSpaceWidgetManager peopleSpaceWidgetManager,\n             LauncherApps launcherApps,\n             ShortcutManager shortcutManager,\n@@ -164,6 +166,7 @@ public interface NotificationsModule {\n                 highPriorityProvider,\n                 notificationManager,\n                 notificationEntryManager,\n+                userManager,\n                 peopleSpaceWidgetManager,\n                 launcherApps,\n                 shortcutManager,\n",
    "added_lines": 3,
    "deleted_lines": 0,
    "changed_methods": "provideNotificationGutsManager"
   },
   {
    "filename": "NotificationConversationInfo.java",
    "diff": "@@ -48,6 +48,7 @@ import android.os.Bundle;\n import android.os.Handler;\n import android.os.RemoteException;\n import android.os.UserHandle;\n+import android.os.UserManager;\n import android.service.notification.StatusBarNotification;\n import android.text.TextUtils;\n import android.transition.ChangeBounds;\n@@ -118,6 +119,8 @@ public class NotificationConversationInfo extends LinearLayout implements\n     private NotificationGuts mGutsContainer;\n     private OnConversationSettingsClickListener mOnConversationSettingsClickListener;\n \n+    private UserManager mUm;\n+\n     @VisibleForTesting\n     boolean mSkipPost = false;\n     private int mActualHeight;\n@@ -152,10 +155,12 @@ public class NotificationConversationInfo extends LinearLayout implements\n         mPressedApply = true;\n \n         // If the user selected Priority and the previous selection was not priority, show a\n-        // People Tile add request.\n+        // People Tile add request if for same profile group.\n         if (mSelectedAction == ACTION_FAVORITE && getPriority() != mSelectedAction) {\n             mShadeController.animateCollapsePanels();\n-            mPeopleSpaceWidgetManager.requestPinAppWidget(mShortcutInfo, new Bundle());\n+            if (mUm.isSameProfileGroup(UserHandle.USER_SYSTEM, mSbn.getNormalizedUserId())) {\n+                mPeopleSpaceWidgetManager.requestPinAppWidget(mShortcutInfo, new Bundle());\n+            }\n         }\n         mGutsContainer.closeControls(v, true);\n     };\n@@ -189,6 +194,7 @@ public class NotificationConversationInfo extends LinearLayout implements\n             @Action int selectedAction,\n             ShortcutManager shortcutManager,\n             PackageManager pm,\n+            UserManager um,\n             PeopleSpaceWidgetManager peopleSpaceWidgetManager,\n             INotificationManager iNotificationManager,\n             OnUserInteractionCallback onUserInteractionCallback,\n@@ -214,6 +220,7 @@ public class NotificationConversationInfo extends LinearLayout implements\n         mEntry = entry;\n         mSbn = entry.getSbn();\n         mPm = pm;\n+        mUm = um;\n         mAppName = mPackageName;\n         mOnSettingsClickListener = onSettingsClick;\n         mNotificationChannel = notificationChannel;\n",
    "added_lines": 9,
    "deleted_lines": 2,
    "changed_methods": "NotificationConversationInfo::bindNotification, NotificationConversationInfo::if"
   },
   {
    "filename": "NotificationGutsManager.java",
    "diff": "@@ -31,6 +31,7 @@ import android.net.Uri;\n import android.os.Bundle;\n import android.os.Handler;\n import android.os.UserHandle;\n+import android.os.UserManager;\n import android.provider.Settings;\n import android.service.notification.StatusBarNotification;\n import android.util.ArraySet;\n@@ -127,6 +128,9 @@ public class NotificationGutsManager implements Dumpable, NotificationLifetimeEx\n     private Runnable mOpenRunnable;\n     private final INotificationManager mNotificationManager;\n     private final PeopleSpaceWidgetManager mPeopleSpaceWidgetManager;\n+\n+    private final UserManager mUserManager;\n+\n     private final LauncherApps mLauncherApps;\n     private final ShortcutManager mShortcutManager;\n     private final UserContextProvider mContextTracker;\n@@ -146,6 +150,7 @@ public class NotificationGutsManager implements Dumpable, NotificationLifetimeEx\n             HighPriorityProvider highPriorityProvider,\n             INotificationManager notificationManager,\n             NotificationEntryManager notificationEntryManager,\n+            UserManager userManager,\n             PeopleSpaceWidgetManager peopleSpaceWidgetManager,\n             LauncherApps launcherApps,\n             ShortcutManager shortcutManager,\n@@ -164,6 +169,7 @@ public class NotificationGutsManager implements Dumpable, NotificationLifetimeEx\n         mAccessibilityManager = accessibilityManager;\n         mHighPriorityProvider = highPriorityProvider;\n         mNotificationManager = notificationManager;\n+        mUserManager = userManager;\n         mPeopleSpaceWidgetManager = peopleSpaceWidgetManager;\n         mLauncherApps = launcherApps;\n         mShortcutManager = shortcutManager;\n@@ -491,6 +497,7 @@ public class NotificationGutsManager implements Dumpable, NotificationLifetimeEx\n                 notificationInfoView.getSelectedAction(),\n                 mShortcutManager,\n                 pmUser,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mNotificationManager,\n                 mOnUserInteractionCallback,\n",
    "added_lines": 7,
    "deleted_lines": 0,
    "changed_methods": "NotificationGutsManager::NotificationGutsManager, NotificationGutsManager::initializeConversationNotificationInfo"
   },
   {
    "filename": "NotificationConversationInfoTest.java",
    "diff": "@@ -62,6 +62,7 @@ import android.graphics.drawable.Drawable;\n import android.graphics.drawable.Icon;\n import android.os.Handler;\n import android.os.UserHandle;\n+import android.os.UserManager;\n import android.service.notification.StatusBarNotification;\n import android.test.suitebuilder.annotation.SmallTest;\n import android.testing.AndroidTestingRunner;\n@@ -132,6 +133,8 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n     @Mock\n     private PackageManager mMockPackageManager;\n     @Mock\n+    private UserManager mUserManager;\n+    @Mock\n     private OnUserInteractionCallback mOnUserInteractionCallback;\n     @Mock\n     private BubblesManager mBubblesManager;\n@@ -239,6 +242,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -264,6 +268,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -317,6 +322,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -343,6 +349,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -368,6 +375,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -404,6 +412,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -430,6 +439,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -460,6 +470,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -485,6 +496,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -514,6 +526,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -543,6 +556,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -575,6 +589,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -613,6 +628,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -642,6 +658,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -678,6 +695,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -707,6 +725,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -752,6 +771,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -796,6 +816,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -841,6 +862,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -879,6 +901,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -916,6 +939,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -957,6 +981,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1, // no action selected by default\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -988,6 +1013,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 NotificationConversationInfo.ACTION_FAVORITE, // \"Favorite\" selected by default\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -1018,6 +1044,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -1055,6 +1082,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -1092,6 +1120,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -1128,6 +1157,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -1163,6 +1193,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -1189,6 +1220,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -1210,12 +1242,14 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n \n     @Test\n     public void testSelectPriorityRequestsPinPeopleTile() {\n+        when(mUserManager.isSameProfileGroup(anyInt(), anyInt())).thenReturn(true);\n         //WHEN channel is default importance\n         mNotificationChannel.setImportantConversation(false);\n         mNotificationInfo.bindNotification(\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -1241,12 +1275,48 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n         verify(mPeopleSpaceWidgetManager, times(1)).requestPinAppWidget(any(), any());\n     }\n \n+    @Test\n+    public void testSelectPriorityRequestsPinPeopleTile_noMultiuser() {\n+        when(mUserManager.isSameProfileGroup(anyInt(), anyInt())).thenReturn(false);\n+        //WHEN channel is default importance\n+        mNotificationChannel.setImportantConversation(false);\n+        mNotificationInfo.bindNotification(\n+                -1,\n+                mShortcutManager,\n+                mMockPackageManager,\n+                mUserManager,\n+                mPeopleSpaceWidgetManager,\n+                mMockINotificationManager,\n+                mOnUserInteractionCallback,\n+                TEST_PACKAGE_NAME,\n+                mNotificationChannel,\n+                mEntry,\n+                mBubbleMetadata,\n+                null,\n+                mIconFactory,\n+                mContext,\n+                true,\n+                mTestHandler,\n+                mTestHandler, null, Optional.of(mBubblesManager),\n+                mShadeController);\n+\n+        // WHEN user clicks \"priority\"\n+        mNotificationInfo.setSelectedAction(NotificationConversationInfo.ACTION_FAVORITE);\n+\n+        // and then done\n+        mNotificationInfo.findViewById(R.id.done).performClick();\n+\n+        // No widget prompt; on a secondary user\n+        verify(mPeopleSpaceWidgetManager, never()).requestPinAppWidget(any(), any());\n+    }\n+\n     @Test\n     public void testSelectDefaultDoesNotRequestPinPeopleTile() {\n         mNotificationInfo.bindNotification(\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -1282,6 +1352,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n",
    "added_lines": 71,
    "deleted_lines": 0,
    "changed_methods": "NotificationConversationInfoTest::testBindNotification_priorityDnd, NotificationConversationInfoTest::testBindNotification_priorityDndAndBubble, NotificationConversationInfoTest::testDefault_andSave_doesNotChangeNonImportantBubbling, NotificationConversationInfoTest::testBindNotification_SetsShortcutIcon, NotificationConversationInfoTest::testBindNotification_SetsTextGroupName, NotificationConversationInfoTest::testSelectPriority_AlreadyPriority_DoesNotRequestPinPeopleTile, NotificationConversationInfoTest::testDefault_andSave, NotificationConversationInfoTest::testSelectPriorityRequestsPinPeopleTile_noMultiuser, NotificationConversationInfoTest::testDefault_andSave_doesNotDemoteImportance, NotificationConversationInfoTest::testBindNotification_SetsOnClickListenerForSettings, NotificationConversationInfoTest::testBindNotification_GroupNameHiddenIfNoGroup, NotificationConversationInfoTest::testDefaultSelectedWhenChannelIsDefault, NotificationConversationInfoTest::testBindNotification_noDelegate, NotificationConversationInfoTest::testBindNotification_default_allCanBubble, NotificationConversationInfoTest::testFavoriteSelectedWhenChannelIsDefault, NotificationConversationInfoTest::testSilence_andSave, NotificationConversationInfoTest::testBindNotification_SetsTextApplicationName, NotificationConversationInfoTest::testBindNotification_delegate, NotificationConversationInfoTest::testFavorite, NotificationConversationInfoTest::testBindNotification_SettingsButtonInvisibleWhenNoClickListener, NotificationConversationInfoTest::testBindNotification_createsNewChannel, NotificationConversationInfoTest::testSelectPriorityRequestsPinPeopleTile, NotificationConversationInfoTest::testBindNotification_silentSelected_isFave_isSilent, NotificationConversationInfoTest::testSelectDefaultDoesNotRequestPinPeopleTile, NotificationConversationInfoTest::testFavorite_andSave, NotificationConversationInfoTest::testBindNotification_priorityBaseline, NotificationConversationInfoTest::testBindNotification_SettingsButtonInvisibleWhenDeviceUnprovisioned, NotificationConversationInfoTest::testBindNotification_defaultSelected_notFave_notSilent, NotificationConversationInfoTest::testBindNotification_doesNotCreateNewChannelIfExists, NotificationConversationInfoTest::testSilence, NotificationConversationInfoTest::testDefault, NotificationConversationInfoTest::testFavorite_andSave_doesNotLowerImportance, NotificationConversationInfoTest::testFavorite_thenDefaultThenFavorite_andSave_nothingChanged"
   },
   {
    "filename": "NotificationGutsManagerTest.java",
    "diff": "@@ -54,6 +54,7 @@ import android.content.pm.ShortcutManager;\n import android.graphics.Color;\n import android.os.Binder;\n import android.os.Handler;\n+import android.os.UserManager;\n import android.provider.Settings;\n import android.service.notification.StatusBarNotification;\n import android.testing.AndroidTestingRunner;\n@@ -139,6 +140,8 @@ public class NotificationGutsManagerTest extends SysuiTestCase {\n     @Mock private PeopleSpaceWidgetManager mPeopleSpaceWidgetManager;\n     @Mock private AssistantFeedbackController mAssistantFeedbackController;\n \n+    @Mock private UserManager mUserManager;\n+\n     @Before\n     public void setUp() {\n         mTestableLooper = TestableLooper.get(this);\n@@ -156,7 +159,8 @@ public class NotificationGutsManagerTest extends SysuiTestCase {\n \n         mGutsManager = new NotificationGutsManager(mContext,\n                 () -> Optional.of(mStatusBar), mHandler, mHandler, mAccessibilityManager,\n-                mHighPriorityProvider, mINotificationManager, mNotificationEntryManager,\n+                mHighPriorityProvider, mINotificationManager, mUserManager,\n+                mNotificationEntryManager,\n                 mPeopleSpaceWidgetManager, mLauncherApps, mShortcutManager,\n                 mChannelEditorDialogController, mContextTracker, mAssistantFeedbackController,\n                 Optional.of(mBubblesManager), new UiEventLoggerFake(), mOnUserInteractionCallback,\n",
    "added_lines": 5,
    "deleted_lines": 1,
    "changed_methods": "NotificationGutsManagerTest::setUp"
   }
  ]
 },
 {
  "hash": "9c0e09e708a704425e0acca6a75341f740c8fa70",
  "commit": "Disable priority conversation widget for secondary users\n\nTest: NotificationConversationInfoTest.java\nTest: make a conversation priority on the primary user\nTest: make a conversation priority on a secondary user\nBug: 288896269\n(cherry picked from commit adf620316dcfaf19d7d4a73e2c63322b4a3a4d3a)\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:b0522df0a33d0165656797df7edab978cb403bd4)\nMerged-In: I3f3991d2cb7fb9970cc8ada39ceae9a7ff2fcb31\nChange-Id: I3f3991d2cb7fb9970cc8ada39ceae9a7ff2fcb31",
  "files": [
   {
    "filename": "NotificationsModule.java",
    "diff": "@@ -21,6 +21,7 @@ import android.content.Context;\n import android.content.pm.LauncherApps;\n import android.content.pm.ShortcutManager;\n import android.os.Handler;\n+import android.os.UserManager;\n import android.view.accessibility.AccessibilityManager;\n \n import com.android.internal.logging.UiEventLogger;\n@@ -144,6 +145,7 @@ public interface NotificationsModule {\n             HighPriorityProvider highPriorityProvider,\n             INotificationManager notificationManager,\n             NotificationEntryManager notificationEntryManager,\n+            UserManager userManager,\n             PeopleSpaceWidgetManager peopleSpaceWidgetManager,\n             LauncherApps launcherApps,\n             ShortcutManager shortcutManager,\n@@ -164,6 +166,7 @@ public interface NotificationsModule {\n                 highPriorityProvider,\n                 notificationManager,\n                 notificationEntryManager,\n+                userManager,\n                 peopleSpaceWidgetManager,\n                 launcherApps,\n                 shortcutManager,\n",
    "added_lines": 3,
    "deleted_lines": 0,
    "changed_methods": "provideNotificationGutsManager"
   },
   {
    "filename": "NotificationConversationInfo.java",
    "diff": "@@ -48,6 +48,7 @@ import android.os.Bundle;\n import android.os.Handler;\n import android.os.RemoteException;\n import android.os.UserHandle;\n+import android.os.UserManager;\n import android.service.notification.StatusBarNotification;\n import android.text.TextUtils;\n import android.transition.ChangeBounds;\n@@ -118,6 +119,8 @@ public class NotificationConversationInfo extends LinearLayout implements\n     private NotificationGuts mGutsContainer;\n     private OnConversationSettingsClickListener mOnConversationSettingsClickListener;\n \n+    private UserManager mUm;\n+\n     @VisibleForTesting\n     boolean mSkipPost = false;\n     private int mActualHeight;\n@@ -152,10 +155,12 @@ public class NotificationConversationInfo extends LinearLayout implements\n         mPressedApply = true;\n \n         // If the user selected Priority and the previous selection was not priority, show a\n-        // People Tile add request.\n+        // People Tile add request if for same profile group.\n         if (mSelectedAction == ACTION_FAVORITE && getPriority() != mSelectedAction) {\n             mShadeController.animateCollapsePanels();\n-            mPeopleSpaceWidgetManager.requestPinAppWidget(mShortcutInfo, new Bundle());\n+            if (mUm.isSameProfileGroup(UserHandle.USER_SYSTEM, mSbn.getNormalizedUserId())) {\n+                mPeopleSpaceWidgetManager.requestPinAppWidget(mShortcutInfo, new Bundle());\n+            }\n         }\n         mGutsContainer.closeControls(v, true);\n     };\n@@ -189,6 +194,7 @@ public class NotificationConversationInfo extends LinearLayout implements\n             @Action int selectedAction,\n             ShortcutManager shortcutManager,\n             PackageManager pm,\n+            UserManager um,\n             PeopleSpaceWidgetManager peopleSpaceWidgetManager,\n             INotificationManager iNotificationManager,\n             OnUserInteractionCallback onUserInteractionCallback,\n@@ -214,6 +220,7 @@ public class NotificationConversationInfo extends LinearLayout implements\n         mEntry = entry;\n         mSbn = entry.getSbn();\n         mPm = pm;\n+        mUm = um;\n         mAppName = mPackageName;\n         mOnSettingsClickListener = onSettingsClick;\n         mNotificationChannel = notificationChannel;\n",
    "added_lines": 9,
    "deleted_lines": 2,
    "changed_methods": "NotificationConversationInfo::bindNotification, NotificationConversationInfo::if"
   },
   {
    "filename": "NotificationGutsManager.java",
    "diff": "@@ -31,6 +31,7 @@ import android.net.Uri;\n import android.os.Bundle;\n import android.os.Handler;\n import android.os.UserHandle;\n+import android.os.UserManager;\n import android.provider.Settings;\n import android.service.notification.StatusBarNotification;\n import android.util.ArraySet;\n@@ -127,6 +128,9 @@ public class NotificationGutsManager implements Dumpable, NotificationLifetimeEx\n     private Runnable mOpenRunnable;\n     private final INotificationManager mNotificationManager;\n     private final PeopleSpaceWidgetManager mPeopleSpaceWidgetManager;\n+\n+    private final UserManager mUserManager;\n+\n     private final LauncherApps mLauncherApps;\n     private final ShortcutManager mShortcutManager;\n     private final UserContextProvider mContextTracker;\n@@ -146,6 +150,7 @@ public class NotificationGutsManager implements Dumpable, NotificationLifetimeEx\n             HighPriorityProvider highPriorityProvider,\n             INotificationManager notificationManager,\n             NotificationEntryManager notificationEntryManager,\n+            UserManager userManager,\n             PeopleSpaceWidgetManager peopleSpaceWidgetManager,\n             LauncherApps launcherApps,\n             ShortcutManager shortcutManager,\n@@ -164,6 +169,7 @@ public class NotificationGutsManager implements Dumpable, NotificationLifetimeEx\n         mAccessibilityManager = accessibilityManager;\n         mHighPriorityProvider = highPriorityProvider;\n         mNotificationManager = notificationManager;\n+        mUserManager = userManager;\n         mPeopleSpaceWidgetManager = peopleSpaceWidgetManager;\n         mLauncherApps = launcherApps;\n         mShortcutManager = shortcutManager;\n@@ -491,6 +497,7 @@ public class NotificationGutsManager implements Dumpable, NotificationLifetimeEx\n                 notificationInfoView.getSelectedAction(),\n                 mShortcutManager,\n                 pmUser,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mNotificationManager,\n                 mOnUserInteractionCallback,\n",
    "added_lines": 7,
    "deleted_lines": 0,
    "changed_methods": "NotificationGutsManager::NotificationGutsManager, NotificationGutsManager::initializeConversationNotificationInfo"
   },
   {
    "filename": "NotificationConversationInfoTest.java",
    "diff": "@@ -62,6 +62,7 @@ import android.graphics.drawable.Drawable;\n import android.graphics.drawable.Icon;\n import android.os.Handler;\n import android.os.UserHandle;\n+import android.os.UserManager;\n import android.service.notification.StatusBarNotification;\n import android.test.suitebuilder.annotation.SmallTest;\n import android.testing.AndroidTestingRunner;\n@@ -132,6 +133,8 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n     @Mock\n     private PackageManager mMockPackageManager;\n     @Mock\n+    private UserManager mUserManager;\n+    @Mock\n     private OnUserInteractionCallback mOnUserInteractionCallback;\n     @Mock\n     private BubblesManager mBubblesManager;\n@@ -239,6 +242,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -264,6 +268,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -317,6 +322,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -343,6 +349,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -368,6 +375,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -404,6 +412,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -430,6 +439,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -460,6 +470,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -485,6 +496,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -514,6 +526,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -543,6 +556,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -575,6 +589,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -613,6 +628,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -642,6 +658,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -678,6 +695,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -707,6 +725,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -752,6 +771,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -796,6 +816,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -841,6 +862,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -879,6 +901,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -916,6 +939,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -957,6 +981,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1, // no action selected by default\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -988,6 +1013,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 NotificationConversationInfo.ACTION_FAVORITE, // \"Favorite\" selected by default\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -1018,6 +1044,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -1055,6 +1082,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -1092,6 +1120,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -1128,6 +1157,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -1163,6 +1193,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -1189,6 +1220,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -1210,12 +1242,14 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n \n     @Test\n     public void testSelectPriorityRequestsPinPeopleTile() {\n+        when(mUserManager.isSameProfileGroup(anyInt(), anyInt())).thenReturn(true);\n         //WHEN channel is default importance\n         mNotificationChannel.setImportantConversation(false);\n         mNotificationInfo.bindNotification(\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -1241,12 +1275,48 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n         verify(mPeopleSpaceWidgetManager, times(1)).requestPinAppWidget(any(), any());\n     }\n \n+    @Test\n+    public void testSelectPriorityRequestsPinPeopleTile_noMultiuser() {\n+        when(mUserManager.isSameProfileGroup(anyInt(), anyInt())).thenReturn(false);\n+        //WHEN channel is default importance\n+        mNotificationChannel.setImportantConversation(false);\n+        mNotificationInfo.bindNotification(\n+                -1,\n+                mShortcutManager,\n+                mMockPackageManager,\n+                mUserManager,\n+                mPeopleSpaceWidgetManager,\n+                mMockINotificationManager,\n+                mOnUserInteractionCallback,\n+                TEST_PACKAGE_NAME,\n+                mNotificationChannel,\n+                mEntry,\n+                mBubbleMetadata,\n+                null,\n+                mIconFactory,\n+                mContext,\n+                true,\n+                mTestHandler,\n+                mTestHandler, null, Optional.of(mBubblesManager),\n+                mShadeController);\n+\n+        // WHEN user clicks \"priority\"\n+        mNotificationInfo.setSelectedAction(NotificationConversationInfo.ACTION_FAVORITE);\n+\n+        // and then done\n+        mNotificationInfo.findViewById(R.id.done).performClick();\n+\n+        // No widget prompt; on a secondary user\n+        verify(mPeopleSpaceWidgetManager, never()).requestPinAppWidget(any(), any());\n+    }\n+\n     @Test\n     public void testSelectDefaultDoesNotRequestPinPeopleTile() {\n         mNotificationInfo.bindNotification(\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -1282,6 +1352,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n",
    "added_lines": 71,
    "deleted_lines": 0,
    "changed_methods": "NotificationConversationInfoTest::testBindNotification_priorityDnd, NotificationConversationInfoTest::testBindNotification_priorityDndAndBubble, NotificationConversationInfoTest::testDefault_andSave_doesNotChangeNonImportantBubbling, NotificationConversationInfoTest::testBindNotification_SetsShortcutIcon, NotificationConversationInfoTest::testBindNotification_SetsTextGroupName, NotificationConversationInfoTest::testSelectPriority_AlreadyPriority_DoesNotRequestPinPeopleTile, NotificationConversationInfoTest::testDefault_andSave, NotificationConversationInfoTest::testSelectPriorityRequestsPinPeopleTile_noMultiuser, NotificationConversationInfoTest::testDefault_andSave_doesNotDemoteImportance, NotificationConversationInfoTest::testBindNotification_SetsOnClickListenerForSettings, NotificationConversationInfoTest::testBindNotification_GroupNameHiddenIfNoGroup, NotificationConversationInfoTest::testDefaultSelectedWhenChannelIsDefault, NotificationConversationInfoTest::testBindNotification_noDelegate, NotificationConversationInfoTest::testBindNotification_default_allCanBubble, NotificationConversationInfoTest::testFavoriteSelectedWhenChannelIsDefault, NotificationConversationInfoTest::testSilence_andSave, NotificationConversationInfoTest::testBindNotification_SetsTextApplicationName, NotificationConversationInfoTest::testBindNotification_delegate, NotificationConversationInfoTest::testFavorite, NotificationConversationInfoTest::testBindNotification_SettingsButtonInvisibleWhenNoClickListener, NotificationConversationInfoTest::testBindNotification_createsNewChannel, NotificationConversationInfoTest::testSelectPriorityRequestsPinPeopleTile, NotificationConversationInfoTest::testBindNotification_silentSelected_isFave_isSilent, NotificationConversationInfoTest::testSelectDefaultDoesNotRequestPinPeopleTile, NotificationConversationInfoTest::testFavorite_andSave, NotificationConversationInfoTest::testBindNotification_priorityBaseline, NotificationConversationInfoTest::testBindNotification_SettingsButtonInvisibleWhenDeviceUnprovisioned, NotificationConversationInfoTest::testBindNotification_defaultSelected_notFave_notSilent, NotificationConversationInfoTest::testBindNotification_doesNotCreateNewChannelIfExists, NotificationConversationInfoTest::testSilence, NotificationConversationInfoTest::testDefault, NotificationConversationInfoTest::testFavorite_andSave_doesNotLowerImportance, NotificationConversationInfoTest::testFavorite_thenDefaultThenFavorite_andSave_nothingChanged"
   },
   {
    "filename": "NotificationGutsManagerTest.java",
    "diff": "@@ -54,6 +54,7 @@ import android.content.pm.ShortcutManager;\n import android.graphics.Color;\n import android.os.Binder;\n import android.os.Handler;\n+import android.os.UserManager;\n import android.provider.Settings;\n import android.service.notification.StatusBarNotification;\n import android.testing.AndroidTestingRunner;\n@@ -139,6 +140,8 @@ public class NotificationGutsManagerTest extends SysuiTestCase {\n     @Mock private PeopleSpaceWidgetManager mPeopleSpaceWidgetManager;\n     @Mock private AssistantFeedbackController mAssistantFeedbackController;\n \n+    @Mock private UserManager mUserManager;\n+\n     @Before\n     public void setUp() {\n         mTestableLooper = TestableLooper.get(this);\n@@ -156,7 +159,8 @@ public class NotificationGutsManagerTest extends SysuiTestCase {\n \n         mGutsManager = new NotificationGutsManager(mContext,\n                 () -> Optional.of(mStatusBar), mHandler, mHandler, mAccessibilityManager,\n-                mHighPriorityProvider, mINotificationManager, mNotificationEntryManager,\n+                mHighPriorityProvider, mINotificationManager, mUserManager,\n+                mNotificationEntryManager,\n                 mPeopleSpaceWidgetManager, mLauncherApps, mShortcutManager,\n                 mChannelEditorDialogController, mContextTracker, mAssistantFeedbackController,\n                 Optional.of(mBubblesManager), new UiEventLoggerFake(), mOnUserInteractionCallback,\n",
    "added_lines": 5,
    "deleted_lines": 1,
    "changed_methods": "NotificationGutsManagerTest::setUp"
   }
  ]
 },
 {
  "hash": "9c0e09e708a704425e0acca6a75341f740c8fa70",
  "commit": "Disable priority conversation widget for secondary users\n\nTest: NotificationConversationInfoTest.java\nTest: make a conversation priority on the primary user\nTest: make a conversation priority on a secondary user\nBug: 288896269\n(cherry picked from commit adf620316dcfaf19d7d4a73e2c63322b4a3a4d3a)\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:b0522df0a33d0165656797df7edab978cb403bd4)\nMerged-In: I3f3991d2cb7fb9970cc8ada39ceae9a7ff2fcb31\nChange-Id: I3f3991d2cb7fb9970cc8ada39ceae9a7ff2fcb31",
  "files": [
   {
    "filename": "NotificationsModule.java",
    "diff": "@@ -21,6 +21,7 @@ import android.content.Context;\n import android.content.pm.LauncherApps;\n import android.content.pm.ShortcutManager;\n import android.os.Handler;\n+import android.os.UserManager;\n import android.view.accessibility.AccessibilityManager;\n \n import com.android.internal.logging.UiEventLogger;\n@@ -144,6 +145,7 @@ public interface NotificationsModule {\n             HighPriorityProvider highPriorityProvider,\n             INotificationManager notificationManager,\n             NotificationEntryManager notificationEntryManager,\n+            UserManager userManager,\n             PeopleSpaceWidgetManager peopleSpaceWidgetManager,\n             LauncherApps launcherApps,\n             ShortcutManager shortcutManager,\n@@ -164,6 +166,7 @@ public interface NotificationsModule {\n                 highPriorityProvider,\n                 notificationManager,\n                 notificationEntryManager,\n+                userManager,\n                 peopleSpaceWidgetManager,\n                 launcherApps,\n                 shortcutManager,\n",
    "added_lines": 3,
    "deleted_lines": 0,
    "changed_methods": "provideNotificationGutsManager"
   },
   {
    "filename": "NotificationConversationInfo.java",
    "diff": "@@ -48,6 +48,7 @@ import android.os.Bundle;\n import android.os.Handler;\n import android.os.RemoteException;\n import android.os.UserHandle;\n+import android.os.UserManager;\n import android.service.notification.StatusBarNotification;\n import android.text.TextUtils;\n import android.transition.ChangeBounds;\n@@ -118,6 +119,8 @@ public class NotificationConversationInfo extends LinearLayout implements\n     private NotificationGuts mGutsContainer;\n     private OnConversationSettingsClickListener mOnConversationSettingsClickListener;\n \n+    private UserManager mUm;\n+\n     @VisibleForTesting\n     boolean mSkipPost = false;\n     private int mActualHeight;\n@@ -152,10 +155,12 @@ public class NotificationConversationInfo extends LinearLayout implements\n         mPressedApply = true;\n \n         // If the user selected Priority and the previous selection was not priority, show a\n-        // People Tile add request.\n+        // People Tile add request if for same profile group.\n         if (mSelectedAction == ACTION_FAVORITE && getPriority() != mSelectedAction) {\n             mShadeController.animateCollapsePanels();\n-            mPeopleSpaceWidgetManager.requestPinAppWidget(mShortcutInfo, new Bundle());\n+            if (mUm.isSameProfileGroup(UserHandle.USER_SYSTEM, mSbn.getNormalizedUserId())) {\n+                mPeopleSpaceWidgetManager.requestPinAppWidget(mShortcutInfo, new Bundle());\n+            }\n         }\n         mGutsContainer.closeControls(v, true);\n     };\n@@ -189,6 +194,7 @@ public class NotificationConversationInfo extends LinearLayout implements\n             @Action int selectedAction,\n             ShortcutManager shortcutManager,\n             PackageManager pm,\n+            UserManager um,\n             PeopleSpaceWidgetManager peopleSpaceWidgetManager,\n             INotificationManager iNotificationManager,\n             OnUserInteractionCallback onUserInteractionCallback,\n@@ -214,6 +220,7 @@ public class NotificationConversationInfo extends LinearLayout implements\n         mEntry = entry;\n         mSbn = entry.getSbn();\n         mPm = pm;\n+        mUm = um;\n         mAppName = mPackageName;\n         mOnSettingsClickListener = onSettingsClick;\n         mNotificationChannel = notificationChannel;\n",
    "added_lines": 9,
    "deleted_lines": 2,
    "changed_methods": "NotificationConversationInfo::bindNotification, NotificationConversationInfo::if"
   },
   {
    "filename": "NotificationGutsManager.java",
    "diff": "@@ -31,6 +31,7 @@ import android.net.Uri;\n import android.os.Bundle;\n import android.os.Handler;\n import android.os.UserHandle;\n+import android.os.UserManager;\n import android.provider.Settings;\n import android.service.notification.StatusBarNotification;\n import android.util.ArraySet;\n@@ -127,6 +128,9 @@ public class NotificationGutsManager implements Dumpable, NotificationLifetimeEx\n     private Runnable mOpenRunnable;\n     private final INotificationManager mNotificationManager;\n     private final PeopleSpaceWidgetManager mPeopleSpaceWidgetManager;\n+\n+    private final UserManager mUserManager;\n+\n     private final LauncherApps mLauncherApps;\n     private final ShortcutManager mShortcutManager;\n     private final UserContextProvider mContextTracker;\n@@ -146,6 +150,7 @@ public class NotificationGutsManager implements Dumpable, NotificationLifetimeEx\n             HighPriorityProvider highPriorityProvider,\n             INotificationManager notificationManager,\n             NotificationEntryManager notificationEntryManager,\n+            UserManager userManager,\n             PeopleSpaceWidgetManager peopleSpaceWidgetManager,\n             LauncherApps launcherApps,\n             ShortcutManager shortcutManager,\n@@ -164,6 +169,7 @@ public class NotificationGutsManager implements Dumpable, NotificationLifetimeEx\n         mAccessibilityManager = accessibilityManager;\n         mHighPriorityProvider = highPriorityProvider;\n         mNotificationManager = notificationManager;\n+        mUserManager = userManager;\n         mPeopleSpaceWidgetManager = peopleSpaceWidgetManager;\n         mLauncherApps = launcherApps;\n         mShortcutManager = shortcutManager;\n@@ -491,6 +497,7 @@ public class NotificationGutsManager implements Dumpable, NotificationLifetimeEx\n                 notificationInfoView.getSelectedAction(),\n                 mShortcutManager,\n                 pmUser,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mNotificationManager,\n                 mOnUserInteractionCallback,\n",
    "added_lines": 7,
    "deleted_lines": 0,
    "changed_methods": "NotificationGutsManager::NotificationGutsManager, NotificationGutsManager::initializeConversationNotificationInfo"
   },
   {
    "filename": "NotificationConversationInfoTest.java",
    "diff": "@@ -62,6 +62,7 @@ import android.graphics.drawable.Drawable;\n import android.graphics.drawable.Icon;\n import android.os.Handler;\n import android.os.UserHandle;\n+import android.os.UserManager;\n import android.service.notification.StatusBarNotification;\n import android.test.suitebuilder.annotation.SmallTest;\n import android.testing.AndroidTestingRunner;\n@@ -132,6 +133,8 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n     @Mock\n     private PackageManager mMockPackageManager;\n     @Mock\n+    private UserManager mUserManager;\n+    @Mock\n     private OnUserInteractionCallback mOnUserInteractionCallback;\n     @Mock\n     private BubblesManager mBubblesManager;\n@@ -239,6 +242,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -264,6 +268,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -317,6 +322,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -343,6 +349,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -368,6 +375,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -404,6 +412,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -430,6 +439,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -460,6 +470,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -485,6 +496,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -514,6 +526,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -543,6 +556,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -575,6 +589,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -613,6 +628,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -642,6 +658,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -678,6 +695,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -707,6 +725,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -752,6 +771,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -796,6 +816,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -841,6 +862,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -879,6 +901,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -916,6 +939,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -957,6 +981,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1, // no action selected by default\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -988,6 +1013,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 NotificationConversationInfo.ACTION_FAVORITE, // \"Favorite\" selected by default\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -1018,6 +1044,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -1055,6 +1082,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -1092,6 +1120,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -1128,6 +1157,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -1163,6 +1193,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -1189,6 +1220,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -1210,12 +1242,14 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n \n     @Test\n     public void testSelectPriorityRequestsPinPeopleTile() {\n+        when(mUserManager.isSameProfileGroup(anyInt(), anyInt())).thenReturn(true);\n         //WHEN channel is default importance\n         mNotificationChannel.setImportantConversation(false);\n         mNotificationInfo.bindNotification(\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -1241,12 +1275,48 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n         verify(mPeopleSpaceWidgetManager, times(1)).requestPinAppWidget(any(), any());\n     }\n \n+    @Test\n+    public void testSelectPriorityRequestsPinPeopleTile_noMultiuser() {\n+        when(mUserManager.isSameProfileGroup(anyInt(), anyInt())).thenReturn(false);\n+        //WHEN channel is default importance\n+        mNotificationChannel.setImportantConversation(false);\n+        mNotificationInfo.bindNotification(\n+                -1,\n+                mShortcutManager,\n+                mMockPackageManager,\n+                mUserManager,\n+                mPeopleSpaceWidgetManager,\n+                mMockINotificationManager,\n+                mOnUserInteractionCallback,\n+                TEST_PACKAGE_NAME,\n+                mNotificationChannel,\n+                mEntry,\n+                mBubbleMetadata,\n+                null,\n+                mIconFactory,\n+                mContext,\n+                true,\n+                mTestHandler,\n+                mTestHandler, null, Optional.of(mBubblesManager),\n+                mShadeController);\n+\n+        // WHEN user clicks \"priority\"\n+        mNotificationInfo.setSelectedAction(NotificationConversationInfo.ACTION_FAVORITE);\n+\n+        // and then done\n+        mNotificationInfo.findViewById(R.id.done).performClick();\n+\n+        // No widget prompt; on a secondary user\n+        verify(mPeopleSpaceWidgetManager, never()).requestPinAppWidget(any(), any());\n+    }\n+\n     @Test\n     public void testSelectDefaultDoesNotRequestPinPeopleTile() {\n         mNotificationInfo.bindNotification(\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -1282,6 +1352,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n",
    "added_lines": 71,
    "deleted_lines": 0,
    "changed_methods": "NotificationConversationInfoTest::testBindNotification_priorityDnd, NotificationConversationInfoTest::testBindNotification_priorityDndAndBubble, NotificationConversationInfoTest::testDefault_andSave_doesNotChangeNonImportantBubbling, NotificationConversationInfoTest::testBindNotification_SetsShortcutIcon, NotificationConversationInfoTest::testBindNotification_SetsTextGroupName, NotificationConversationInfoTest::testSelectPriority_AlreadyPriority_DoesNotRequestPinPeopleTile, NotificationConversationInfoTest::testDefault_andSave, NotificationConversationInfoTest::testSelectPriorityRequestsPinPeopleTile_noMultiuser, NotificationConversationInfoTest::testDefault_andSave_doesNotDemoteImportance, NotificationConversationInfoTest::testBindNotification_SetsOnClickListenerForSettings, NotificationConversationInfoTest::testBindNotification_GroupNameHiddenIfNoGroup, NotificationConversationInfoTest::testDefaultSelectedWhenChannelIsDefault, NotificationConversationInfoTest::testBindNotification_noDelegate, NotificationConversationInfoTest::testBindNotification_default_allCanBubble, NotificationConversationInfoTest::testFavoriteSelectedWhenChannelIsDefault, NotificationConversationInfoTest::testSilence_andSave, NotificationConversationInfoTest::testBindNotification_SetsTextApplicationName, NotificationConversationInfoTest::testBindNotification_delegate, NotificationConversationInfoTest::testFavorite, NotificationConversationInfoTest::testBindNotification_SettingsButtonInvisibleWhenNoClickListener, NotificationConversationInfoTest::testBindNotification_createsNewChannel, NotificationConversationInfoTest::testSelectPriorityRequestsPinPeopleTile, NotificationConversationInfoTest::testBindNotification_silentSelected_isFave_isSilent, NotificationConversationInfoTest::testSelectDefaultDoesNotRequestPinPeopleTile, NotificationConversationInfoTest::testFavorite_andSave, NotificationConversationInfoTest::testBindNotification_priorityBaseline, NotificationConversationInfoTest::testBindNotification_SettingsButtonInvisibleWhenDeviceUnprovisioned, NotificationConversationInfoTest::testBindNotification_defaultSelected_notFave_notSilent, NotificationConversationInfoTest::testBindNotification_doesNotCreateNewChannelIfExists, NotificationConversationInfoTest::testSilence, NotificationConversationInfoTest::testDefault, NotificationConversationInfoTest::testFavorite_andSave_doesNotLowerImportance, NotificationConversationInfoTest::testFavorite_thenDefaultThenFavorite_andSave_nothingChanged"
   },
   {
    "filename": "NotificationGutsManagerTest.java",
    "diff": "@@ -54,6 +54,7 @@ import android.content.pm.ShortcutManager;\n import android.graphics.Color;\n import android.os.Binder;\n import android.os.Handler;\n+import android.os.UserManager;\n import android.provider.Settings;\n import android.service.notification.StatusBarNotification;\n import android.testing.AndroidTestingRunner;\n@@ -139,6 +140,8 @@ public class NotificationGutsManagerTest extends SysuiTestCase {\n     @Mock private PeopleSpaceWidgetManager mPeopleSpaceWidgetManager;\n     @Mock private AssistantFeedbackController mAssistantFeedbackController;\n \n+    @Mock private UserManager mUserManager;\n+\n     @Before\n     public void setUp() {\n         mTestableLooper = TestableLooper.get(this);\n@@ -156,7 +159,8 @@ public class NotificationGutsManagerTest extends SysuiTestCase {\n \n         mGutsManager = new NotificationGutsManager(mContext,\n                 () -> Optional.of(mStatusBar), mHandler, mHandler, mAccessibilityManager,\n-                mHighPriorityProvider, mINotificationManager, mNotificationEntryManager,\n+                mHighPriorityProvider, mINotificationManager, mUserManager,\n+                mNotificationEntryManager,\n                 mPeopleSpaceWidgetManager, mLauncherApps, mShortcutManager,\n                 mChannelEditorDialogController, mContextTracker, mAssistantFeedbackController,\n                 Optional.of(mBubblesManager), new UiEventLoggerFake(), mOnUserInteractionCallback,\n",
    "added_lines": 5,
    "deleted_lines": 1,
    "changed_methods": "NotificationGutsManagerTest::setUp"
   }
  ]
 },
 {
  "hash": "9c0e09e708a704425e0acca6a75341f740c8fa70",
  "commit": "Disable priority conversation widget for secondary users\n\nTest: NotificationConversationInfoTest.java\nTest: make a conversation priority on the primary user\nTest: make a conversation priority on a secondary user\nBug: 288896269\n(cherry picked from commit adf620316dcfaf19d7d4a73e2c63322b4a3a4d3a)\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:b0522df0a33d0165656797df7edab978cb403bd4)\nMerged-In: I3f3991d2cb7fb9970cc8ada39ceae9a7ff2fcb31\nChange-Id: I3f3991d2cb7fb9970cc8ada39ceae9a7ff2fcb31",
  "files": [
   {
    "filename": "NotificationsModule.java",
    "diff": "@@ -21,6 +21,7 @@ import android.content.Context;\n import android.content.pm.LauncherApps;\n import android.content.pm.ShortcutManager;\n import android.os.Handler;\n+import android.os.UserManager;\n import android.view.accessibility.AccessibilityManager;\n \n import com.android.internal.logging.UiEventLogger;\n@@ -144,6 +145,7 @@ public interface NotificationsModule {\n             HighPriorityProvider highPriorityProvider,\n             INotificationManager notificationManager,\n             NotificationEntryManager notificationEntryManager,\n+            UserManager userManager,\n             PeopleSpaceWidgetManager peopleSpaceWidgetManager,\n             LauncherApps launcherApps,\n             ShortcutManager shortcutManager,\n@@ -164,6 +166,7 @@ public interface NotificationsModule {\n                 highPriorityProvider,\n                 notificationManager,\n                 notificationEntryManager,\n+                userManager,\n                 peopleSpaceWidgetManager,\n                 launcherApps,\n                 shortcutManager,\n",
    "added_lines": 3,
    "deleted_lines": 0,
    "changed_methods": "provideNotificationGutsManager"
   },
   {
    "filename": "NotificationConversationInfo.java",
    "diff": "@@ -48,6 +48,7 @@ import android.os.Bundle;\n import android.os.Handler;\n import android.os.RemoteException;\n import android.os.UserHandle;\n+import android.os.UserManager;\n import android.service.notification.StatusBarNotification;\n import android.text.TextUtils;\n import android.transition.ChangeBounds;\n@@ -118,6 +119,8 @@ public class NotificationConversationInfo extends LinearLayout implements\n     private NotificationGuts mGutsContainer;\n     private OnConversationSettingsClickListener mOnConversationSettingsClickListener;\n \n+    private UserManager mUm;\n+\n     @VisibleForTesting\n     boolean mSkipPost = false;\n     private int mActualHeight;\n@@ -152,10 +155,12 @@ public class NotificationConversationInfo extends LinearLayout implements\n         mPressedApply = true;\n \n         // If the user selected Priority and the previous selection was not priority, show a\n-        // People Tile add request.\n+        // People Tile add request if for same profile group.\n         if (mSelectedAction == ACTION_FAVORITE && getPriority() != mSelectedAction) {\n             mShadeController.animateCollapsePanels();\n-            mPeopleSpaceWidgetManager.requestPinAppWidget(mShortcutInfo, new Bundle());\n+            if (mUm.isSameProfileGroup(UserHandle.USER_SYSTEM, mSbn.getNormalizedUserId())) {\n+                mPeopleSpaceWidgetManager.requestPinAppWidget(mShortcutInfo, new Bundle());\n+            }\n         }\n         mGutsContainer.closeControls(v, true);\n     };\n@@ -189,6 +194,7 @@ public class NotificationConversationInfo extends LinearLayout implements\n             @Action int selectedAction,\n             ShortcutManager shortcutManager,\n             PackageManager pm,\n+            UserManager um,\n             PeopleSpaceWidgetManager peopleSpaceWidgetManager,\n             INotificationManager iNotificationManager,\n             OnUserInteractionCallback onUserInteractionCallback,\n@@ -214,6 +220,7 @@ public class NotificationConversationInfo extends LinearLayout implements\n         mEntry = entry;\n         mSbn = entry.getSbn();\n         mPm = pm;\n+        mUm = um;\n         mAppName = mPackageName;\n         mOnSettingsClickListener = onSettingsClick;\n         mNotificationChannel = notificationChannel;\n",
    "added_lines": 9,
    "deleted_lines": 2,
    "changed_methods": "NotificationConversationInfo::bindNotification, NotificationConversationInfo::if"
   },
   {
    "filename": "NotificationGutsManager.java",
    "diff": "@@ -31,6 +31,7 @@ import android.net.Uri;\n import android.os.Bundle;\n import android.os.Handler;\n import android.os.UserHandle;\n+import android.os.UserManager;\n import android.provider.Settings;\n import android.service.notification.StatusBarNotification;\n import android.util.ArraySet;\n@@ -127,6 +128,9 @@ public class NotificationGutsManager implements Dumpable, NotificationLifetimeEx\n     private Runnable mOpenRunnable;\n     private final INotificationManager mNotificationManager;\n     private final PeopleSpaceWidgetManager mPeopleSpaceWidgetManager;\n+\n+    private final UserManager mUserManager;\n+\n     private final LauncherApps mLauncherApps;\n     private final ShortcutManager mShortcutManager;\n     private final UserContextProvider mContextTracker;\n@@ -146,6 +150,7 @@ public class NotificationGutsManager implements Dumpable, NotificationLifetimeEx\n             HighPriorityProvider highPriorityProvider,\n             INotificationManager notificationManager,\n             NotificationEntryManager notificationEntryManager,\n+            UserManager userManager,\n             PeopleSpaceWidgetManager peopleSpaceWidgetManager,\n             LauncherApps launcherApps,\n             ShortcutManager shortcutManager,\n@@ -164,6 +169,7 @@ public class NotificationGutsManager implements Dumpable, NotificationLifetimeEx\n         mAccessibilityManager = accessibilityManager;\n         mHighPriorityProvider = highPriorityProvider;\n         mNotificationManager = notificationManager;\n+        mUserManager = userManager;\n         mPeopleSpaceWidgetManager = peopleSpaceWidgetManager;\n         mLauncherApps = launcherApps;\n         mShortcutManager = shortcutManager;\n@@ -491,6 +497,7 @@ public class NotificationGutsManager implements Dumpable, NotificationLifetimeEx\n                 notificationInfoView.getSelectedAction(),\n                 mShortcutManager,\n                 pmUser,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mNotificationManager,\n                 mOnUserInteractionCallback,\n",
    "added_lines": 7,
    "deleted_lines": 0,
    "changed_methods": "NotificationGutsManager::NotificationGutsManager, NotificationGutsManager::initializeConversationNotificationInfo"
   },
   {
    "filename": "NotificationConversationInfoTest.java",
    "diff": "@@ -62,6 +62,7 @@ import android.graphics.drawable.Drawable;\n import android.graphics.drawable.Icon;\n import android.os.Handler;\n import android.os.UserHandle;\n+import android.os.UserManager;\n import android.service.notification.StatusBarNotification;\n import android.test.suitebuilder.annotation.SmallTest;\n import android.testing.AndroidTestingRunner;\n@@ -132,6 +133,8 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n     @Mock\n     private PackageManager mMockPackageManager;\n     @Mock\n+    private UserManager mUserManager;\n+    @Mock\n     private OnUserInteractionCallback mOnUserInteractionCallback;\n     @Mock\n     private BubblesManager mBubblesManager;\n@@ -239,6 +242,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -264,6 +268,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -317,6 +322,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -343,6 +349,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -368,6 +375,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -404,6 +412,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -430,6 +439,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -460,6 +470,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -485,6 +496,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -514,6 +526,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -543,6 +556,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -575,6 +589,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -613,6 +628,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -642,6 +658,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -678,6 +695,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -707,6 +725,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -752,6 +771,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -796,6 +816,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -841,6 +862,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -879,6 +901,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -916,6 +939,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -957,6 +981,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1, // no action selected by default\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -988,6 +1013,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 NotificationConversationInfo.ACTION_FAVORITE, // \"Favorite\" selected by default\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -1018,6 +1044,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -1055,6 +1082,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -1092,6 +1120,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -1128,6 +1157,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -1163,6 +1193,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -1189,6 +1220,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -1210,12 +1242,14 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n \n     @Test\n     public void testSelectPriorityRequestsPinPeopleTile() {\n+        when(mUserManager.isSameProfileGroup(anyInt(), anyInt())).thenReturn(true);\n         //WHEN channel is default importance\n         mNotificationChannel.setImportantConversation(false);\n         mNotificationInfo.bindNotification(\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -1241,12 +1275,48 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n         verify(mPeopleSpaceWidgetManager, times(1)).requestPinAppWidget(any(), any());\n     }\n \n+    @Test\n+    public void testSelectPriorityRequestsPinPeopleTile_noMultiuser() {\n+        when(mUserManager.isSameProfileGroup(anyInt(), anyInt())).thenReturn(false);\n+        //WHEN channel is default importance\n+        mNotificationChannel.setImportantConversation(false);\n+        mNotificationInfo.bindNotification(\n+                -1,\n+                mShortcutManager,\n+                mMockPackageManager,\n+                mUserManager,\n+                mPeopleSpaceWidgetManager,\n+                mMockINotificationManager,\n+                mOnUserInteractionCallback,\n+                TEST_PACKAGE_NAME,\n+                mNotificationChannel,\n+                mEntry,\n+                mBubbleMetadata,\n+                null,\n+                mIconFactory,\n+                mContext,\n+                true,\n+                mTestHandler,\n+                mTestHandler, null, Optional.of(mBubblesManager),\n+                mShadeController);\n+\n+        // WHEN user clicks \"priority\"\n+        mNotificationInfo.setSelectedAction(NotificationConversationInfo.ACTION_FAVORITE);\n+\n+        // and then done\n+        mNotificationInfo.findViewById(R.id.done).performClick();\n+\n+        // No widget prompt; on a secondary user\n+        verify(mPeopleSpaceWidgetManager, never()).requestPinAppWidget(any(), any());\n+    }\n+\n     @Test\n     public void testSelectDefaultDoesNotRequestPinPeopleTile() {\n         mNotificationInfo.bindNotification(\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n@@ -1282,6 +1352,7 @@ public class NotificationConversationInfoTest extends SysuiTestCase {\n                 -1,\n                 mShortcutManager,\n                 mMockPackageManager,\n+                mUserManager,\n                 mPeopleSpaceWidgetManager,\n                 mMockINotificationManager,\n                 mOnUserInteractionCallback,\n",
    "added_lines": 71,
    "deleted_lines": 0,
    "changed_methods": "NotificationConversationInfoTest::testBindNotification_priorityDnd, NotificationConversationInfoTest::testBindNotification_priorityDndAndBubble, NotificationConversationInfoTest::testDefault_andSave_doesNotChangeNonImportantBubbling, NotificationConversationInfoTest::testBindNotification_SetsShortcutIcon, NotificationConversationInfoTest::testBindNotification_SetsTextGroupName, NotificationConversationInfoTest::testSelectPriority_AlreadyPriority_DoesNotRequestPinPeopleTile, NotificationConversationInfoTest::testDefault_andSave, NotificationConversationInfoTest::testSelectPriorityRequestsPinPeopleTile_noMultiuser, NotificationConversationInfoTest::testDefault_andSave_doesNotDemoteImportance, NotificationConversationInfoTest::testBindNotification_SetsOnClickListenerForSettings, NotificationConversationInfoTest::testBindNotification_GroupNameHiddenIfNoGroup, NotificationConversationInfoTest::testDefaultSelectedWhenChannelIsDefault, NotificationConversationInfoTest::testBindNotification_noDelegate, NotificationConversationInfoTest::testBindNotification_default_allCanBubble, NotificationConversationInfoTest::testFavoriteSelectedWhenChannelIsDefault, NotificationConversationInfoTest::testSilence_andSave, NotificationConversationInfoTest::testBindNotification_SetsTextApplicationName, NotificationConversationInfoTest::testBindNotification_delegate, NotificationConversationInfoTest::testFavorite, NotificationConversationInfoTest::testBindNotification_SettingsButtonInvisibleWhenNoClickListener, NotificationConversationInfoTest::testBindNotification_createsNewChannel, NotificationConversationInfoTest::testSelectPriorityRequestsPinPeopleTile, NotificationConversationInfoTest::testBindNotification_silentSelected_isFave_isSilent, NotificationConversationInfoTest::testSelectDefaultDoesNotRequestPinPeopleTile, NotificationConversationInfoTest::testFavorite_andSave, NotificationConversationInfoTest::testBindNotification_priorityBaseline, NotificationConversationInfoTest::testBindNotification_SettingsButtonInvisibleWhenDeviceUnprovisioned, NotificationConversationInfoTest::testBindNotification_defaultSelected_notFave_notSilent, NotificationConversationInfoTest::testBindNotification_doesNotCreateNewChannelIfExists, NotificationConversationInfoTest::testSilence, NotificationConversationInfoTest::testDefault, NotificationConversationInfoTest::testFavorite_andSave_doesNotLowerImportance, NotificationConversationInfoTest::testFavorite_thenDefaultThenFavorite_andSave_nothingChanged"
   },
   {
    "filename": "NotificationGutsManagerTest.java",
    "diff": "@@ -54,6 +54,7 @@ import android.content.pm.ShortcutManager;\n import android.graphics.Color;\n import android.os.Binder;\n import android.os.Handler;\n+import android.os.UserManager;\n import android.provider.Settings;\n import android.service.notification.StatusBarNotification;\n import android.testing.AndroidTestingRunner;\n@@ -139,6 +140,8 @@ public class NotificationGutsManagerTest extends SysuiTestCase {\n     @Mock private PeopleSpaceWidgetManager mPeopleSpaceWidgetManager;\n     @Mock private AssistantFeedbackController mAssistantFeedbackController;\n \n+    @Mock private UserManager mUserManager;\n+\n     @Before\n     public void setUp() {\n         mTestableLooper = TestableLooper.get(this);\n@@ -156,7 +159,8 @@ public class NotificationGutsManagerTest extends SysuiTestCase {\n \n         mGutsManager = new NotificationGutsManager(mContext,\n                 () -> Optional.of(mStatusBar), mHandler, mHandler, mAccessibilityManager,\n-                mHighPriorityProvider, mINotificationManager, mNotificationEntryManager,\n+                mHighPriorityProvider, mINotificationManager, mUserManager,\n+                mNotificationEntryManager,\n                 mPeopleSpaceWidgetManager, mLauncherApps, mShortcutManager,\n                 mChannelEditorDialogController, mContextTracker, mAssistantFeedbackController,\n                 Optional.of(mBubblesManager), new UiEventLoggerFake(), mOnUserInteractionCallback,\n",
    "added_lines": 5,
    "deleted_lines": 1,
    "changed_methods": "NotificationGutsManagerTest::setUp"
   }
  ]
 },
 {
  "hash": "969e47613b43d0a281aae08cb0766da7035921f9",
  "commit": "Require permission to unlock keyguard\n\nBug: 288896339\nTest: Manual, verify that the app which can be found on the bug can no longer call\nkeyguardGoingAway successfully\n\n\nRequire permission to unlock keyguard\n\nBug: 288896339\nTest: Manual, verify that the app which can be found on the bug can no longer call\nkeyguardGoingAway successfully\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:bd2aa5d309c5bf8e73161975bd5aba7945b25e84)\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:be6ececad17f268b20cc252b29cbf3e848aef8ae)\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:7f28e3eaaf7c91c6b22ef89a9f18bfe081ba5b1e)\nMerged-In: I7ba7e56f954c8e6f1f734311f735215918975bc6\nChange-Id: I7ba7e56f954c8e6f1f734311f735215918975bc6",
  "files": [
   {
    "filename": "ActivityTaskManagerService.java",
    "diff": "@@ -18,6 +18,7 @@ package com.android.server.wm;\n \n import static android.Manifest.permission.BIND_VOICE_INTERACTION;\n import static android.Manifest.permission.CHANGE_CONFIGURATION;\n+import static android.Manifest.permission.CONTROL_KEYGUARD;\n import static android.Manifest.permission.CONTROL_REMOTE_APP_TRANSITION_ANIMATIONS;\n import static android.Manifest.permission.INTERACT_ACROSS_USERS;\n import static android.Manifest.permission.INTERACT_ACROSS_USERS_FULL;\n@@ -3378,6 +3379,7 @@ public class ActivityTaskManagerService extends IActivityTaskManager.Stub {\n \n     @Override\n     public void keyguardGoingAway(int flags) {\n+        mAmInternal.enforceCallingPermission(CONTROL_KEYGUARD, \"unlock keyguard\");\n         enforceNotIsolatedCaller(\"keyguardGoingAway\");\n         final long token = Binder.clearCallingIdentity();\n         try {\n",
    "added_lines": 2,
    "deleted_lines": 0,
    "changed_methods": "ActivityTaskManagerService::keyguardGoingAway"
   }
  ]
 },
 {
  "hash": "aff1a9b475c4d8c1df92a600b809c55618b55ad1",
  "commit": "Restrict number of shortcuts can be added through addDynamicShortcuts\n\nThis CL fixes the issue where, when an app have multiple main\nactivities, the total number of shortcuts can grow indefinitely if they\nwere published through addDynamicShortcuts.\n\nBug: 281061287\nTest: manual\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:3215e73e36aa0463429226b5743ce24badf31227)\nMerged-In: Ib3eecefee34517b670c59dd5b8526fe9eb24f463\nChange-Id: Ib3eecefee34517b670c59dd5b8526fe9eb24f463",
  "files": [
   {
    "filename": "ShortcutPackage.java",
    "diff": "@@ -359,6 +359,7 @@ class ShortcutPackage extends ShortcutPackageItem {\n         // Extract Icon and update the icon res ID and the bitmap path.\n         s.saveIconAndFixUpShortcutLocked(newShortcut);\n         s.fixUpShortcutResourceNamesAndValues(newShortcut);\n+        ensureShortcutCountBeforePush();\n         saveShortcut(newShortcut);\n     }\n \n@@ -405,7 +406,6 @@ class ShortcutPackage extends ShortcutPackageItem {\n             @NonNull List<ShortcutInfo> changedShortcuts) {\n         Preconditions.checkArgument(newShortcut.isEnabled(),\n                 \"pushDynamicShortcuts() cannot publish disabled shortcuts\");\n-        ensureShortcutCountBeforePush();\n \n         newShortcut.addFlags(ShortcutInfo.FLAG_DYNAMIC);\n \n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "ShortcutPackage::pushDynamicShortcut, ShortcutPackage::forceReplaceShortcutInner"
   }
  ]
 },
 {
  "hash": "7f725d0750df7184351c3553f7cf66de3c6ad050",
  "commit": "Validate userId when publishing shortcuts\n\nBug: 288110451\nTest: manual\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:01bfd04ff445db6290ae430d44ea1bf1a115fe3c)\nMerged-In: Idbde676f871db83825155730e3714f3727e25762\nChange-Id: Idbde676f871db83825155730e3714f3727e25762",
  "files": [
   {
    "filename": "ShortcutService.java",
    "diff": "@@ -1733,6 +1733,10 @@ public class ShortcutService extends IShortcutService.Stub {\n             android.util.EventLog.writeEvent(0x534e4554, \"109824443\", -1, \"\");\n             throw new SecurityException(\"Shortcut package name mismatch\");\n         }\n+        final int callingUid = injectBinderCallingUid();\n+        if (UserHandle.getUserId(callingUid) != si.getUserId()) {\n+            throw new SecurityException(\"User-ID in shortcut doesn't match the caller\");\n+        }\n     }\n \n     private void verifyShortcutInfoPackages(\n",
    "added_lines": 4,
    "deleted_lines": 0,
    "changed_methods": "ShortcutService::verifyShortcutInfoPackage"
   }
  ]
 },
 {
  "hash": "c3594639ce04fa5e84136a01cc1aa65eeb0b8705",
  "commit": "Revert \"On device lockdown, always show the keyguard\"\n\nThis reverts commit b23c2d5fb6630ea0da503b937f62880594b13e94.\n\nReason for revert: b/300463732 regression\nBug: 300463732\nBug: 218495634\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:f57217125f2b124c16c463ef4507fb054cc1ba4f)\nMerged-In: I31485d0d8caa3060e998636b071dbe03f6b4fc82\nChange-Id: I31485d0d8caa3060e998636b071dbe03f6b4fc82\n\nChange-Id: Ib113b7e1182855d9a90ff9937014c9ebce679d38",
  "files": [
   {
    "filename": "KeyguardViewMediator.java",
    "diff": "@@ -677,13 +677,6 @@ public class KeyguardViewMediator extends SystemUI implements Dumpable,\n                 }\n             }\n         }\n-\n-        @Override\n-        public void onStrongAuthStateChanged(int userId) {\n-            if (mLockPatternUtils.isUserInLockdown(KeyguardUpdateMonitor.getCurrentUser())) {\n-                doKeyguardLocked(null);\n-            }\n-        }\n     };\n \n     ViewMediatorCallback mViewMediatorCallback = new ViewMediatorCallback() {\n@@ -1542,8 +1535,7 @@ public class KeyguardViewMediator extends SystemUI implements Dumpable,\n         }\n \n         // if another app is disabling us, don't show\n-        if (!mExternallyEnabled\n-            && !mLockPatternUtils.isUserInLockdown(KeyguardUpdateMonitor.getCurrentUser())) {\n+        if (!mExternallyEnabled) {\n             if (DEBUG) Log.d(TAG, \"doKeyguard: not showing because externally disabled\");\n \n             mNeedToReshowWhenReenabled = true;\n",
    "added_lines": 1,
    "deleted_lines": 9,
    "changed_methods": "KeyguardViewMediator::KeyguardUpdateMonitorCallback, KeyguardViewMediator::doKeyguardLocked"
   }
  ]
 },
 {
  "hash": "5a1c2d06321754ec065bf15fbe4208e89a0a15db",
  "commit": "Adding in verification of calling UID in onShellCommand\n\nTest: manual testing on device\nBug: b/261709193\n(cherry picked from commit b651d295b44eb82d664861b77f33dbde1bce9453)\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:3ef3f18ba3094c4cc4f954ba23d1da421f9ca8b0)\nMerged-In: I68903ebd6d3d85f4bc820b745e3233a448b62273\nChange-Id: I68903ebd6d3d85f4bc820b745e3233a448b62273",
  "files": [
   {
    "filename": "ActivityManagerService.java",
    "diff": "@@ -8715,6 +8715,13 @@ public class ActivityManagerService extends IActivityManager.Stub\n     public void onShellCommand(FileDescriptor in, FileDescriptor out,\n             FileDescriptor err, String[] args, ShellCallback callback,\n             ResultReceiver resultReceiver) {\n+        final int callingUid = Binder.getCallingUid();\n+        if (callingUid != ROOT_UID && callingUid != Process.SHELL_UID) {\n+            if (resultReceiver != null) {\n+                resultReceiver.send(-1, null);\n+            }\n+            throw new SecurityException(\"Shell commands are only callable by root or shell\");\n+        }\n         (new ActivityManagerShellCommand(this, false)).exec(\n                 this, in, out, err, args, callback, resultReceiver);\n     }\n",
    "added_lines": 7,
    "deleted_lines": 0,
    "changed_methods": "ActivityManagerService::onShellCommand"
   }
  ]
 },
 {
  "hash": "b452af38180ad07b3e8dd239a9a5193c8e87c40b",
  "commit": "Updated: always show the keyguard on device lockdown\n\nAdditionally, don't hide keyguard when it's disabled if the user has locked\ndown the device.\n\nManual test steps:\n    1. Enable app pinning and disable \"Ask for PIN before unpinning\" setting\n    2. Pin an app (ie: Settings)\n    3. Lockdown from the power menu\n    4. Observe: user is brought to the keyguard, primary auth is\n       required to enter the device.\n       => After entering correct credential, the device is still in\n          app pinning mode.\n       => After entering an incorrect credential, the keyguard remains\n          showing and the user can attempt again up to the limit\n\nBug: 300463732\nBug: 218495634\nTest: atest KeyguardViewMediatorTest\nTest: manual\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:35a6e2f2c952440b1102033b2c3e496438503cff)\nMerged-In: I70fdae80f717712b3dfc9df54b9649959b4bb8f0\nChange-Id: I70fdae80f717712b3dfc9df54b9649959b4bb8f0",
  "files": [
   {
    "filename": "KeyguardViewMediator.java",
    "diff": "@@ -669,6 +669,13 @@ public class KeyguardViewMediator extends SystemUI implements Dumpable,\n             }\n         }\n \n+        @Override\n+        public void onStrongAuthStateChanged(int userId) {\n+            if (mLockPatternUtils.isUserInLockdown(KeyguardUpdateMonitor.getCurrentUser())) {\n+                doKeyguardLocked(null);\n+            }\n+        }\n+\n         @Override\n         public void onTrustChanged(int userId) {\n             if (userId == KeyguardUpdateMonitor.getCurrentUser()) {\n@@ -1318,6 +1325,10 @@ public class KeyguardViewMediator extends SystemUI implements Dumpable,\n             mExternallyEnabled = enabled;\n \n             if (!enabled && mShowing) {\n+                if (mLockPatternUtils.isUserInLockdown(KeyguardUpdateMonitor.getCurrentUser())) {\n+                    Log.d(TAG, \"keyguardEnabled(false) overridden by user lockdown\");\n+                    return;\n+                }\n                 if (mExitSecureCallback != null) {\n                     if (DEBUG) Log.d(TAG, \"in process of verifyUnlock request, ignoring\");\n                     // we're in the process of handling a request to verify the user\n@@ -1534,8 +1545,9 @@ public class KeyguardViewMediator extends SystemUI implements Dumpable,\n             return;\n         }\n \n-        // if another app is disabling us, don't show\n-        if (!mExternallyEnabled) {\n+        // if another app is disabling us, don't show unless we're in lockdown mode\n+        if (!mExternallyEnabled\n+                && !mLockPatternUtils.isUserInLockdown(KeyguardUpdateMonitor.getCurrentUser())) {\n             if (DEBUG) Log.d(TAG, \"doKeyguard: not showing because externally disabled\");\n \n             mNeedToReshowWhenReenabled = true;\n",
    "added_lines": 14,
    "deleted_lines": 2,
    "changed_methods": "KeyguardViewMediator::KeyguardUpdateMonitorCallback, KeyguardViewMediator::setKeyguardEnabled, KeyguardViewMediator::doKeyguardLocked"
   }
  ]
 },
 {
  "hash": "29eaa0200523318863847f51deab2f71cde71884",
  "commit": "RESTRICT AUTOMERGE: Check URI permissions for resumable media artwork\n\nWhen resumable media is added that has artwork set via URI, check the\npermissions for the URI before attempting to load it\n\nTest: atest MediaDataManagerTest UriGrantsManagerServiceTest\nTest: manual with test app\nBug: 284297452\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:ffae193f19f902d4ae890be579cd44573feeaedc)\nMerged-In: Ie79915d3d1712f08dc2e8dfbd5bc7fd32bb308a3\nChange-Id: Ie79915d3d1712f08dc2e8dfbd5bc7fd32bb308a3\n\nChange-Id: I09b8b91f2dcc4d20862ba6be0ee03d98e434f771",
  "files": [
   {
    "filename": "UriGrantsManagerService.java",
    "diff": "@@ -41,6 +41,7 @@ import static org.xmlpull.v1.XmlPullParser.START_TAG;\n \n import android.annotation.NonNull;\n import android.annotation.Nullable;\n+import android.annotation.RequiresPermission;\n import android.app.ActivityManager;\n import android.app.ActivityManagerInternal;\n import android.app.AppGlobals;\n@@ -62,6 +63,7 @@ import android.os.Handler;\n import android.os.IBinder;\n import android.os.Looper;\n import android.os.Message;\n+import android.os.Process;\n import android.os.RemoteException;\n import android.os.SystemClock;\n import android.os.UserHandle;\n@@ -1302,6 +1304,46 @@ public class UriGrantsManagerService extends IUriGrantsManager.Stub {\n         return false;\n     }\n \n+    /**\n+     * Check if the targetPkg can be granted permission to access uri by\n+     * the callingUid using the given modeFlags. See {@link #checkGrantUriPermissionUnlocked}.\n+     *\n+     * @param callingUid The uid of the grantor app that has permissions to the uri.\n+     * @param targetPkg The package name of the granted app that needs permissions to the uri.\n+     * @param uri The uri for which permissions should be granted.\n+     * @param modeFlags The modes to grant. See {@link Intent#FLAG_GRANT_READ_URI_PERMISSION}, etc.\n+     * @param userId The userId in which the uri is to be resolved.\n+     * @return uid of the target or -1 if permission grant not required. Returns -1 if the caller\n+     *  does not hold INTERACT_ACROSS_USERS_FULL\n+     * @throws SecurityException if the grant is not allowed.\n+     */\n+    @Override\n+    @RequiresPermission(android.Manifest.permission.INTERACT_ACROSS_USERS_FULL)\n+    public int checkGrantUriPermission_ignoreNonSystem(int callingUid, String targetPkg, Uri uri,\n+            int modeFlags, int userId) {\n+        if (!isCallerIsSystemOrPrivileged()) {\n+            return Process.INVALID_UID;\n+        }\n+        final long origId = Binder.clearCallingIdentity();\n+        try {\n+            return checkGrantUriPermissionUnlocked(callingUid, targetPkg, uri, modeFlags,\n+                    userId);\n+        } finally {\n+            Binder.restoreCallingIdentity(origId);\n+        }\n+    }\n+\n+    private boolean isCallerIsSystemOrPrivileged() {\n+        final int uid = Binder.getCallingUid();\n+        if (uid == Process.SYSTEM_UID || uid == Process.ROOT_UID) {\n+            return true;\n+        }\n+        return ActivityManager.checkComponentPermission(\n+                android.Manifest.permission.INTERACT_ACROSS_USERS_FULL,\n+                uid, /* owningUid = */-1, /* exported = */ true)\n+                == PackageManager.PERMISSION_GRANTED;\n+    }\n+\n     @GuardedBy(\"mLock\")\n     private void writeGrantedUriPermissionsLocked() {\n         if (DEBUG) Slog.v(TAG, \"writeGrantedUriPermissions()\");\n",
    "added_lines": 42,
    "deleted_lines": 0,
    "changed_methods": "UriGrantsManagerService::isCallerIsSystemOrPrivileged, UriGrantsManagerService::checkGrantUriPermission_ignoreNonSystem"
   }
  ]
 },
 {
  "hash": "1bc3a825d92aa35c46083d767d2d1cd29abf2252",
  "commit": "Dismiss keyguard when simpin auth'd and...\n\nsecurity method is none. This is mostly to fix the case where we auth\nsim pin in the set up wizard and it goes straight to keyguard instead of\nthe setup wizard activity.\n\nThis works with the prevent bypass keyguard flag because the device\nshould be noe secure in this case.\n\nFixes: 222446076\nTest: turn locked sim on, which opens the sim pin screen. Auth the\nscreen and observe that keyguard is not shown.\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:48fa9bef3451e4a358c941af5b230f99881c5cb6)\nCherry-picking this CL as a security fix\n\nBug: 222446076\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:65ea56f54c059584eb27ec53d486dba8161316ab)\nMerged-In: Id302c41f63028bc6dd58ba686e23d73565de9675\nAOSP-Change-Id: Id302c41f63028bc6dd58ba686e23d73565de9675\nChange-Id: I91acff9b729e0546f64a6e5d0038a0e889a43f96",
  "files": [
   {
    "filename": "KeyguardSecurityContainerController.java",
    "diff": "@@ -426,7 +426,7 @@ public class KeyguardSecurityContainerController extends ViewController<Keyguard\n                 case SimPuk:\n                     // Shortcut for SIM PIN/PUK to go to directly to user's security screen or home\n                     SecurityMode securityMode = mSecurityModel.getSecurityMode(targetUserId);\n-                    if (securityMode == SecurityMode.None && mLockPatternUtils.isLockScreenDisabled(\n+                    if (securityMode == SecurityMode.None || mLockPatternUtils.isLockScreenDisabled(\n                             KeyguardUpdateMonitor.getCurrentUser())) {\n                         finish = true;\n                         eventSubtype = BOUNCER_DISMISS_SIM;\n",
    "added_lines": 1,
    "deleted_lines": 1,
    "changed_methods": "KeyguardSecurityContainerController::showNextSecurityScreenOrFinish"
   }
  ]
 },
 {
  "hash": "10e9c09cde3bbe154d88b7507c23fc79360c89b5",
  "commit": "DO NOT MERGE Ensure finish lockscreen when usersetup incomplete\n\nEnsure that when the usersetup for the user is not complete, we do not\nwant to go to lockscreen, even if lockscreen is not disabled.\n\nBug: 222446076\nTest: add Unit test,\nTest: Wipe device, auth sim pin in setup, observe that lockscreen is\nnot there.\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:da4c8f81d9bc31ce856069bfe911dc6693b97e98)\nMerged-In: I8e33db8eb6e2c917966cab3d6a4f982670473040\nChange-Id: I8e33db8eb6e2c917966cab3d6a4f982670473040",
  "files": [
   {
    "filename": "KeyguardSecurityContainerController.java",
    "diff": "@@ -54,6 +54,7 @@ import com.android.systemui.R;\n import com.android.systemui.classifier.FalsingCollector;\n import com.android.systemui.shared.system.SysUiStatsLog;\n import com.android.systemui.statusbar.policy.ConfigurationController;\n+import com.android.systemui.statusbar.policy.DeviceProvisionedController;\n import com.android.systemui.statusbar.policy.KeyguardStateController;\n import com.android.systemui.util.ViewController;\n \n@@ -221,6 +222,7 @@ public class KeyguardSecurityContainerController extends ViewController<Keyguard\n                     mSecurityViewFlipperController.reloadColors();\n                 }\n             };\n+    private final DeviceProvisionedController mDeviceProvisionedController;\n \n     private KeyguardSecurityContainerController(KeyguardSecurityContainer view,\n             AdminSecondaryLockScreenController.Factory adminSecondaryLockScreenControllerFactory,\n@@ -233,6 +235,7 @@ public class KeyguardSecurityContainerController extends ViewController<Keyguard\n             SecurityCallback securityCallback,\n             KeyguardSecurityViewFlipperController securityViewFlipperController,\n             ConfigurationController configurationController,\n+            DeviceProvisionedController deviceProvisionedController,\n             FalsingCollector falsingCollector) {\n         super(view);\n         mLockPatternUtils = lockPatternUtils;\n@@ -247,6 +250,7 @@ public class KeyguardSecurityContainerController extends ViewController<Keyguard\n                 mKeyguardSecurityCallback);\n         mConfigurationController = configurationController;\n         mLastOrientation = getResources().getConfiguration().orientation;\n+        mDeviceProvisionedController = deviceProvisionedController;\n         mFalsingCollector = falsingCollector;\n     }\n \n@@ -426,8 +430,11 @@ public class KeyguardSecurityContainerController extends ViewController<Keyguard\n                 case SimPuk:\n                     // Shortcut for SIM PIN/PUK to go to directly to user's security screen or home\n                     SecurityMode securityMode = mSecurityModel.getSecurityMode(targetUserId);\n-                    if (securityMode == SecurityMode.None || mLockPatternUtils.isLockScreenDisabled(\n-                            KeyguardUpdateMonitor.getCurrentUser())) {\n+                    boolean isLockscreenDisabled = mLockPatternUtils.isLockScreenDisabled(\n+                            KeyguardUpdateMonitor.getCurrentUser())\n+                            || !mDeviceProvisionedController.isUserSetup(targetUserId);\n+\n+                    if (securityMode == SecurityMode.None && isLockscreenDisabled) {\n                         finish = true;\n                         eventSubtype = BOUNCER_DISMISS_SIM;\n                         uiEvent = BouncerUiEvent.BOUNCER_DISMISS_SIM;\n@@ -625,6 +632,7 @@ public class KeyguardSecurityContainerController extends ViewController<Keyguard\n         private final KeyguardStateController mKeyguardStateController;\n         private final KeyguardSecurityViewFlipperController mSecurityViewFlipperController;\n         private final ConfigurationController mConfigurationController;\n+        private final DeviceProvisionedController mDeviceProvisionedController;\n         private final FalsingCollector mFalsingCollector;\n \n         @Inject\n@@ -639,6 +647,7 @@ public class KeyguardSecurityContainerController extends ViewController<Keyguard\n                 KeyguardStateController keyguardStateController,\n                 KeyguardSecurityViewFlipperController securityViewFlipperController,\n                 ConfigurationController configurationController,\n+                DeviceProvisionedController deviceProvisionedController,\n                 FalsingCollector falsingCollector) {\n             mView = view;\n             mAdminSecondaryLockScreenControllerFactory = adminSecondaryLockScreenControllerFactory;\n@@ -650,6 +659,7 @@ public class KeyguardSecurityContainerController extends ViewController<Keyguard\n             mKeyguardStateController = keyguardStateController;\n             mSecurityViewFlipperController = securityViewFlipperController;\n             mConfigurationController = configurationController;\n+            mDeviceProvisionedController = deviceProvisionedController;\n             mFalsingCollector = falsingCollector;\n         }\n \n@@ -659,7 +669,7 @@ public class KeyguardSecurityContainerController extends ViewController<Keyguard\n                     mAdminSecondaryLockScreenControllerFactory, mLockPatternUtils,\n                     mKeyguardUpdateMonitor, mKeyguardSecurityModel, mMetricsLogger, mUiEventLogger,\n                     mKeyguardStateController, securityCallback, mSecurityViewFlipperController,\n-                    mConfigurationController, mFalsingCollector);\n+                    mConfigurationController, mDeviceProvisionedController, mFalsingCollector);\n         }\n \n     }\n",
    "added_lines": 13,
    "deleted_lines": 3,
    "changed_methods": "KeyguardSecurityContainerController::Factory::create, KeyguardSecurityContainerController::KeyguardSecurityContainerController, KeyguardSecurityContainerController::Factory::Factory, KeyguardSecurityContainerController::showNextSecurityScreenOrFinish"
   },
   {
    "filename": "KeyguardSecurityContainerControllerTest.java",
    "diff": "@@ -50,6 +50,7 @@ import com.android.systemui.R;\n import com.android.systemui.SysuiTestCase;\n import com.android.systemui.classifier.FalsingCollector;\n import com.android.systemui.statusbar.policy.ConfigurationController;\n+import com.android.systemui.statusbar.policy.DeviceProvisionedController;\n import com.android.systemui.statusbar.policy.KeyguardStateController;\n \n import org.junit.Before;\n@@ -143,7 +144,7 @@ public class KeyguardSecurityContainerControllerTest extends SysuiTestCase {\n                 mView, mAdminSecondaryLockScreenControllerFactory, mLockPatternUtils,\n                 mKeyguardUpdateMonitor, mKeyguardSecurityModel, mMetricsLogger, mUiEventLogger,\n                 mKeyguardStateController, mKeyguardSecurityViewFlipperController,\n-                mConfigurationController, mFalsingCollector)\n+                mConfigurationController, mock(DeviceProvisionedController.class)), mFalsingCollector)\n                 .create(mSecurityCallback);\n     }\n \n",
    "added_lines": 2,
    "deleted_lines": 1,
    "changed_methods": "KeyguardSecurityContainerControllerTest::setup"
   }
  ]
 },
 {
  "hash": "10e9c09cde3bbe154d88b7507c23fc79360c89b5",
  "commit": "DO NOT MERGE Ensure finish lockscreen when usersetup incomplete\n\nEnsure that when the usersetup for the user is not complete, we do not\nwant to go to lockscreen, even if lockscreen is not disabled.\n\nBug: 222446076\nTest: add Unit test,\nTest: Wipe device, auth sim pin in setup, observe that lockscreen is\nnot there.\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:da4c8f81d9bc31ce856069bfe911dc6693b97e98)\nMerged-In: I8e33db8eb6e2c917966cab3d6a4f982670473040\nChange-Id: I8e33db8eb6e2c917966cab3d6a4f982670473040",
  "files": [
   {
    "filename": "KeyguardSecurityContainerController.java",
    "diff": "@@ -54,6 +54,7 @@ import com.android.systemui.R;\n import com.android.systemui.classifier.FalsingCollector;\n import com.android.systemui.shared.system.SysUiStatsLog;\n import com.android.systemui.statusbar.policy.ConfigurationController;\n+import com.android.systemui.statusbar.policy.DeviceProvisionedController;\n import com.android.systemui.statusbar.policy.KeyguardStateController;\n import com.android.systemui.util.ViewController;\n \n@@ -221,6 +222,7 @@ public class KeyguardSecurityContainerController extends ViewController<Keyguard\n                     mSecurityViewFlipperController.reloadColors();\n                 }\n             };\n+    private final DeviceProvisionedController mDeviceProvisionedController;\n \n     private KeyguardSecurityContainerController(KeyguardSecurityContainer view,\n             AdminSecondaryLockScreenController.Factory adminSecondaryLockScreenControllerFactory,\n@@ -233,6 +235,7 @@ public class KeyguardSecurityContainerController extends ViewController<Keyguard\n             SecurityCallback securityCallback,\n             KeyguardSecurityViewFlipperController securityViewFlipperController,\n             ConfigurationController configurationController,\n+            DeviceProvisionedController deviceProvisionedController,\n             FalsingCollector falsingCollector) {\n         super(view);\n         mLockPatternUtils = lockPatternUtils;\n@@ -247,6 +250,7 @@ public class KeyguardSecurityContainerController extends ViewController<Keyguard\n                 mKeyguardSecurityCallback);\n         mConfigurationController = configurationController;\n         mLastOrientation = getResources().getConfiguration().orientation;\n+        mDeviceProvisionedController = deviceProvisionedController;\n         mFalsingCollector = falsingCollector;\n     }\n \n@@ -426,8 +430,11 @@ public class KeyguardSecurityContainerController extends ViewController<Keyguard\n                 case SimPuk:\n                     // Shortcut for SIM PIN/PUK to go to directly to user's security screen or home\n                     SecurityMode securityMode = mSecurityModel.getSecurityMode(targetUserId);\n-                    if (securityMode == SecurityMode.None || mLockPatternUtils.isLockScreenDisabled(\n-                            KeyguardUpdateMonitor.getCurrentUser())) {\n+                    boolean isLockscreenDisabled = mLockPatternUtils.isLockScreenDisabled(\n+                            KeyguardUpdateMonitor.getCurrentUser())\n+                            || !mDeviceProvisionedController.isUserSetup(targetUserId);\n+\n+                    if (securityMode == SecurityMode.None && isLockscreenDisabled) {\n                         finish = true;\n                         eventSubtype = BOUNCER_DISMISS_SIM;\n                         uiEvent = BouncerUiEvent.BOUNCER_DISMISS_SIM;\n@@ -625,6 +632,7 @@ public class KeyguardSecurityContainerController extends ViewController<Keyguard\n         private final KeyguardStateController mKeyguardStateController;\n         private final KeyguardSecurityViewFlipperController mSecurityViewFlipperController;\n         private final ConfigurationController mConfigurationController;\n+        private final DeviceProvisionedController mDeviceProvisionedController;\n         private final FalsingCollector mFalsingCollector;\n \n         @Inject\n@@ -639,6 +647,7 @@ public class KeyguardSecurityContainerController extends ViewController<Keyguard\n                 KeyguardStateController keyguardStateController,\n                 KeyguardSecurityViewFlipperController securityViewFlipperController,\n                 ConfigurationController configurationController,\n+                DeviceProvisionedController deviceProvisionedController,\n                 FalsingCollector falsingCollector) {\n             mView = view;\n             mAdminSecondaryLockScreenControllerFactory = adminSecondaryLockScreenControllerFactory;\n@@ -650,6 +659,7 @@ public class KeyguardSecurityContainerController extends ViewController<Keyguard\n             mKeyguardStateController = keyguardStateController;\n             mSecurityViewFlipperController = securityViewFlipperController;\n             mConfigurationController = configurationController;\n+            mDeviceProvisionedController = deviceProvisionedController;\n             mFalsingCollector = falsingCollector;\n         }\n \n@@ -659,7 +669,7 @@ public class KeyguardSecurityContainerController extends ViewController<Keyguard\n                     mAdminSecondaryLockScreenControllerFactory, mLockPatternUtils,\n                     mKeyguardUpdateMonitor, mKeyguardSecurityModel, mMetricsLogger, mUiEventLogger,\n                     mKeyguardStateController, securityCallback, mSecurityViewFlipperController,\n-                    mConfigurationController, mFalsingCollector);\n+                    mConfigurationController, mDeviceProvisionedController, mFalsingCollector);\n         }\n \n     }\n",
    "added_lines": 13,
    "deleted_lines": 3,
    "changed_methods": "KeyguardSecurityContainerController::Factory::create, KeyguardSecurityContainerController::KeyguardSecurityContainerController, KeyguardSecurityContainerController::Factory::Factory, KeyguardSecurityContainerController::showNextSecurityScreenOrFinish"
   },
   {
    "filename": "KeyguardSecurityContainerControllerTest.java",
    "diff": "@@ -50,6 +50,7 @@ import com.android.systemui.R;\n import com.android.systemui.SysuiTestCase;\n import com.android.systemui.classifier.FalsingCollector;\n import com.android.systemui.statusbar.policy.ConfigurationController;\n+import com.android.systemui.statusbar.policy.DeviceProvisionedController;\n import com.android.systemui.statusbar.policy.KeyguardStateController;\n \n import org.junit.Before;\n@@ -143,7 +144,7 @@ public class KeyguardSecurityContainerControllerTest extends SysuiTestCase {\n                 mView, mAdminSecondaryLockScreenControllerFactory, mLockPatternUtils,\n                 mKeyguardUpdateMonitor, mKeyguardSecurityModel, mMetricsLogger, mUiEventLogger,\n                 mKeyguardStateController, mKeyguardSecurityViewFlipperController,\n-                mConfigurationController, mFalsingCollector)\n+                mConfigurationController, mock(DeviceProvisionedController.class)), mFalsingCollector)\n                 .create(mSecurityCallback);\n     }\n \n",
    "added_lines": 2,
    "deleted_lines": 1,
    "changed_methods": "KeyguardSecurityContainerControllerTest::setup"
   }
  ]
 },
 {
  "hash": "a7c40fadfd053fec2fd5e76137e3953d8b433352",
  "commit": "Truncate user data to a limit of 500 characters\n\nFix vulnerability that allows creating users with no restrictions. This is done by creating an intent to create a user and putting extras that are too long to be serialized. It causes IOException and the restrictions are not written in the file.\n\nBy truncating the string values when writing them to the file, we ensure that the exception does not happen and it can be recorded correctly.\n\nBug: 293602317\nTest: install app provided in the bug, open app and click add. Check logcat to see there is no more IOException. Reboot the device by either opening User details page or running adb shell dumpsys user | grep -A12 heen and see that the restrictions are in place.\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:46caac641941f2e8865a8d53400f959b3bd98d88)\nMerged-In: Ia71477601d036a3ca55e73cdc9698ae268a30f20\nChange-Id: Ia71477601d036a3ca55e73cdc9698ae268a30f20",
  "files": [
   {
    "filename": "UserManagerService.java",
    "diff": "@@ -248,6 +248,8 @@ public class UserManagerService extends IUserManager.Stub {\n \n     private static final int USER_VERSION = 9;\n \n+    private static final int MAX_USER_STRING_LENGTH = 500;\n+\n     private static final long EPOCH_PLUS_30_YEARS = 30L * 365 * 24 * 60 * 60 * 1000L; // ms\n \n     static final int WRITE_USER_MSG = 1;\n@@ -3157,15 +3159,17 @@ public class UserManagerService extends IUserManager.Stub {\n         // Write seed data\n         if (userData.persistSeedData) {\n             if (userData.seedAccountName != null) {\n-                serializer.attribute(null, ATTR_SEED_ACCOUNT_NAME, userData.seedAccountName);\n+                serializer.attribute(null, ATTR_SEED_ACCOUNT_NAME,\n+                        truncateString(userData.seedAccountName));\n             }\n             if (userData.seedAccountType != null) {\n-                serializer.attribute(null, ATTR_SEED_ACCOUNT_TYPE, userData.seedAccountType);\n+                serializer.attribute(null, ATTR_SEED_ACCOUNT_TYPE,\n+                        truncateString(userData.seedAccountType));\n             }\n         }\n         if (userInfo.name != null) {\n             serializer.startTag(null, TAG_NAME);\n-            serializer.text(userInfo.name);\n+            serializer.text(truncateString(userInfo.name));\n             serializer.endTag(null, TAG_NAME);\n         }\n         synchronized (mRestrictionsLock) {\n@@ -3205,6 +3209,13 @@ public class UserManagerService extends IUserManager.Stub {\n         serializer.endDocument();\n     }\n \n+    private String truncateString(String original) {\n+        if (original == null || original.length() <= MAX_USER_STRING_LENGTH) {\n+            return original;\n+        }\n+        return original.substring(0, MAX_USER_STRING_LENGTH);\n+    }\n+\n     /*\n      * Writes the user list file in this format:\n      *\n@@ -3565,6 +3576,7 @@ public class UserManagerService extends IUserManager.Stub {\n             boolean preCreate, @Nullable String[] disallowedPackages,\n             @NonNull TimingsTraceAndSlog t, @Nullable Object token)\n                     throws UserManager.CheckedUserOperationException {\n+        String truncatedName = truncateString(name);\n         final UserTypeDetails userTypeDetails = mUserTypes.get(userType);\n         if (userTypeDetails == null) {\n             Slog.e(LOG_TAG, \"Cannot create user of invalid user type: \" + userType);\n@@ -3590,8 +3602,9 @@ public class UserManagerService extends IUserManager.Stub {\n \n         // Try to use a pre-created user (if available).\n         if (!preCreate && parentId < 0 && isUserTypeEligibleForPreCreation(userTypeDetails)) {\n-            final UserInfo preCreatedUser = convertPreCreatedUserIfPossible(userType, flags, name,\n-                    token);\n+\n+            final UserInfo preCreatedUser = convertPreCreatedUserIfPossible(userType, flags,\n+                    truncatedName, token);\n             if (preCreatedUser != null) {\n                 return preCreatedUser;\n             }\n@@ -3684,7 +3697,7 @@ public class UserManagerService extends IUserManager.Stub {\n                         flags &= ~UserInfo.FLAG_EPHEMERAL;\n                     }\n \n-                    userInfo = new UserInfo(userId, name, null, flags, userType);\n+                    userInfo = new UserInfo(userId, truncatedName, null, flags, userType);\n                     userInfo.serialNumber = mNextSerialNumber++;\n                     userInfo.creationTime = getCreationTime();\n                     userInfo.partial = true;\n@@ -4983,8 +4996,8 @@ public class UserManagerService extends IUserManager.Stub {\n                     Slog.e(LOG_TAG, \"No such user for settings seed data u=\" + userId);\n                     return;\n                 }\n-                userData.seedAccountName = accountName;\n-                userData.seedAccountType = accountType;\n+                userData.seedAccountName = truncateString(accountName);\n+                userData.seedAccountType = truncateString(accountType);\n                 userData.seedAccountOptions = accountOptions;\n                 userData.persistSeedData = persist;\n             }\n",
    "added_lines": 21,
    "deleted_lines": 8,
    "changed_methods": "UserManagerService::truncateString, UserManagerService::writeUserLP, UserManagerService::createUserInternalUncheckedNoTracing, UserManagerService::setSeedAccountData"
   }
  ]
 },
 {
  "hash": "e7326f9d5b85ebabcac3fd2c726c78b64f0fcb64",
  "commit": "[CDM] Validate component name length before requesting notification access.\n\nBug: 295335110\nTest: Test app with long component name\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:edb1e78ee3a38f947b9518be90dbc12c223d1380)\nMerged-In: I7ea5d5c1f78858db9865f3310d1e0aff9c8b5579\nChange-Id: I7ea5d5c1f78858db9865f3310d1e0aff9c8b5579",
  "files": [
   {
    "filename": "CompanionDeviceManagerService.java",
    "diff": "@@ -172,6 +172,7 @@ public class CompanionDeviceManagerService extends SystemService implements Bind\n \n     private static final int ASSOCIATE_WITHOUT_PROMPT_MAX_PER_TIME_WINDOW = 5;\n     private static final long ASSOCIATE_WITHOUT_PROMPT_WINDOW_MS = 60 * 60 * 1000; // 60 min;\n+    private static final int MAX_CN_LENGTH = 500;\n \n     private static final String XML_TAG_ASSOCIATIONS = \"associations\";\n     private static final String XML_TAG_ASSOCIATION = \"association\";\n@@ -555,6 +556,9 @@ public class CompanionDeviceManagerService extends SystemService implements Bind\n             String callingPackage = component.getPackageName();\n             checkCanCallNotificationApi(callingPackage);\n             int userId = getCallingUserId();\n+            if (component.flattenToString().length() > MAX_CN_LENGTH) {\n+                throw new IllegalArgumentException(\"Component name is too long.\");\n+            }\n             final long identity = Binder.clearCallingIdentity();\n             try {\n                 return PendingIntent.getActivityAsUser(getContext(),\n",
    "added_lines": 4,
    "deleted_lines": 0,
    "changed_methods": "CompanionDeviceManagerService::CompanionDeviceManagerImpl::requestNotificationAccess"
   }
  ]
 },
 {
  "hash": "1e5b9954ad00d7de02b7b39854b72991ed20659f",
  "commit": "[SB][Privacy] Fetch current active appops on startup.\n\nThis also updates SysUI's chip animation scheduler to ignore an\n`isTooEarly` check if the chip animation is forced to be visible (which\nis true for privacy events).\n\nBug: 294104969\nTest: start recording, then kill systemui via adb-> verify privacy chip\nreappears after restart. Pull down shade and verify chip is correctly\nattributed. Stop recording and verify chip/dot disappears.\nTest: open camera, then kill systemui via adb -> verify privacy chip\nreappears after restart. Pull down shade and verify chip is correctly\nattributed. Close camera and verify chip/dot disappears.\nTest: smoke test of privacy chip and dot\nTest: atest AppOpsControllerTest SystemStatusAnimationSchedulerImplTest\n\n(cherry picked from commit 084a7afb4bb41e0cdfdbe67bdd60728d940b4331)\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:dac02d61f8cf755f733ef6c2fbd0f939ea13ee23)\nMerged-In: I664bb3003a2f6871113406e3257b7118bbdf2ab5\nChange-Id: I664bb3003a2f6871113406e3257b7118bbdf2ab5",
  "files": [
   {
    "filename": "AppOpsControllerImpl.java",
    "diff": "@@ -52,6 +52,7 @@ import java.io.FileDescriptor;\n import java.io.PrintWriter;\n import java.util.ArrayList;\n import java.util.List;\n+import java.util.Map;\n import java.util.Set;\n \n import javax.inject.Inject;\n@@ -144,6 +145,10 @@ public class AppOpsControllerImpl extends BroadcastReceiver implements AppOpsCon\n     protected void setListening(boolean listening) {\n         mListening = listening;\n         if (listening) {\n+            // System UI could be restarted while ops are active, so fetch the currently active ops\n+            // once System UI starts listening again.\n+            fetchCurrentActiveOps();\n+\n             mAppOps.startWatchingActive(OPS, this);\n             mAppOps.startWatchingNoted(OPS, this);\n             mAudioManager.registerAudioRecordingCallback(mAudioRecordingCallback, mBGHandler);\n@@ -176,6 +181,29 @@ public class AppOpsControllerImpl extends BroadcastReceiver implements AppOpsCon\n         }\n     }\n \n+    private void fetchCurrentActiveOps() {\n+        List<AppOpsManager.PackageOps> packageOps = mAppOps.getPackagesForOps(OPS);\n+        for (AppOpsManager.PackageOps op : packageOps) {\n+            for (AppOpsManager.OpEntry entry : op.getOps()) {\n+                for (Map.Entry<String, AppOpsManager.AttributedOpEntry> attributedOpEntry :\n+                        entry.getAttributedOpEntries().entrySet()) {\n+                    if (attributedOpEntry.getValue().isRunning()) {\n+                        onOpActiveChanged(\n+                                entry.getOpStr(),\n+                                op.getUid(),\n+                                op.getPackageName(),\n+                                /* attributionTag= */ attributedOpEntry.getKey(),\n+                                /* active= */ true,\n+                                // AppOpsManager doesn't have a way to fetch attribution flags or\n+                                // chain ID given an op entry, so default them to none.\n+                                AppOpsManager.ATTRIBUTION_FLAGS_NONE,\n+                                AppOpsManager.ATTRIBUTION_CHAIN_ID_NONE);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n     /**\n      * Adds a callback that will get notifified when an AppOp of the type the controller tracks\n      * changes\n",
    "added_lines": 28,
    "deleted_lines": 0,
    "changed_methods": "AppOpsControllerImpl::fetchCurrentActiveOps, AppOpsControllerImpl::setListening"
   },
   {
    "filename": "AppOpsControllerTest.java",
    "diff": "@@ -19,6 +19,8 @@ package com.android.systemui.appops;\n import static android.hardware.SensorPrivacyManager.Sensors.CAMERA;\n import static android.hardware.SensorPrivacyManager.Sensors.MICROPHONE;\n \n+import static com.google.common.truth.Truth.assertThat;\n+\n import static junit.framework.TestCase.assertFalse;\n \n import static org.junit.Assert.assertEquals;\n@@ -66,6 +68,7 @@ import org.mockito.MockitoAnnotations;\n \n import java.util.Collections;\n import java.util.List;\n+import java.util.Map;\n \n @SmallTest\n @RunWith(AndroidTestingRunner.class)\n@@ -157,6 +160,204 @@ public class AppOpsControllerTest extends SysuiTestCase {\n         verify(mSensorPrivacyController, times(1)).removeCallback(mController);\n     }\n \n+    @Test\n+    public void startListening_fetchesCurrentActive_none() {\n+        when(mAppOpsManager.getPackagesForOps(AppOpsControllerImpl.OPS))\n+                .thenReturn(List.of());\n+\n+        mController.setListening(true);\n+\n+        assertThat(mController.getActiveAppOps()).isEmpty();\n+    }\n+\n+    /** Regression test for b/294104969. */\n+    @Test\n+    public void startListening_fetchesCurrentActive_oneActive() {\n+        AppOpsManager.PackageOps packageOps = createPackageOp(\n+                \"package.test\",\n+                /* packageUid= */ 2,\n+                AppOpsManager.OPSTR_FINE_LOCATION,\n+                /* isRunning= */ true);\n+        when(mAppOpsManager.getPackagesForOps(AppOpsControllerImpl.OPS))\n+                .thenReturn(List.of(packageOps));\n+\n+        // WHEN we start listening\n+        mController.setListening(true);\n+\n+        // THEN the active list has the op\n+        List<AppOpItem> list = mController.getActiveAppOps();\n+        assertEquals(1, list.size());\n+        AppOpItem first = list.get(0);\n+        assertThat(first.getPackageName()).isEqualTo(\"package.test\");\n+        assertThat(first.getUid()).isEqualTo(2);\n+        assertThat(first.getCode()).isEqualTo(AppOpsManager.OP_FINE_LOCATION);\n+    }\n+\n+    @Test\n+    public void startListening_fetchesCurrentActive_multiplePackages() {\n+        AppOpsManager.PackageOps packageOps1 = createPackageOp(\n+                \"package.one\",\n+                /* packageUid= */ 1,\n+                AppOpsManager.OPSTR_FINE_LOCATION,\n+                /* isRunning= */ true);\n+        AppOpsManager.PackageOps packageOps2 = createPackageOp(\n+                \"package.two\",\n+                /* packageUid= */ 2,\n+                AppOpsManager.OPSTR_FINE_LOCATION,\n+                /* isRunning= */ false);\n+        AppOpsManager.PackageOps packageOps3 = createPackageOp(\n+                \"package.three\",\n+                /* packageUid= */ 3,\n+                AppOpsManager.OPSTR_FINE_LOCATION,\n+                /* isRunning= */ true);\n+        when(mAppOpsManager.getPackagesForOps(AppOpsControllerImpl.OPS))\n+                .thenReturn(List.of(packageOps1, packageOps2, packageOps3));\n+\n+        // WHEN we start listening\n+        mController.setListening(true);\n+\n+        // THEN the active list has the ops\n+        List<AppOpItem> list = mController.getActiveAppOps();\n+        assertEquals(2, list.size());\n+\n+        AppOpItem item0 = list.get(0);\n+        assertThat(item0.getPackageName()).isEqualTo(\"package.one\");\n+        assertThat(item0.getUid()).isEqualTo(1);\n+        assertThat(item0.getCode()).isEqualTo(AppOpsManager.OP_FINE_LOCATION);\n+\n+        AppOpItem item1 = list.get(1);\n+        assertThat(item1.getPackageName()).isEqualTo(\"package.three\");\n+        assertThat(item1.getUid()).isEqualTo(3);\n+        assertThat(item1.getCode()).isEqualTo(AppOpsManager.OP_FINE_LOCATION);\n+    }\n+\n+    @Test\n+    public void startListening_fetchesCurrentActive_multipleEntries() {\n+        AppOpsManager.PackageOps packageOps = mock(AppOpsManager.PackageOps.class);\n+        when(packageOps.getUid()).thenReturn(1);\n+        when(packageOps.getPackageName()).thenReturn(\"package.one\");\n+\n+        // Entry 1\n+        AppOpsManager.OpEntry entry1 = mock(AppOpsManager.OpEntry.class);\n+        when(entry1.getOpStr()).thenReturn(AppOpsManager.OPSTR_PHONE_CALL_MICROPHONE);\n+        AppOpsManager.AttributedOpEntry attributed1 = mock(AppOpsManager.AttributedOpEntry.class);\n+        when(attributed1.isRunning()).thenReturn(true);\n+        when(entry1.getAttributedOpEntries()).thenReturn(Map.of(\"tag\", attributed1));\n+        // Entry 2\n+        AppOpsManager.OpEntry entry2 = mock(AppOpsManager.OpEntry.class);\n+        when(entry2.getOpStr()).thenReturn(AppOpsManager.OPSTR_CAMERA);\n+        AppOpsManager.AttributedOpEntry attributed2 = mock(AppOpsManager.AttributedOpEntry.class);\n+        when(attributed2.isRunning()).thenReturn(true);\n+        when(entry2.getAttributedOpEntries()).thenReturn(Map.of(\"tag\", attributed2));\n+        // Entry 3\n+        AppOpsManager.OpEntry entry3 = mock(AppOpsManager.OpEntry.class);\n+        when(entry3.getOpStr()).thenReturn(AppOpsManager.OPSTR_FINE_LOCATION);\n+        AppOpsManager.AttributedOpEntry attributed3 = mock(AppOpsManager.AttributedOpEntry.class);\n+        when(attributed3.isRunning()).thenReturn(false);\n+        when(entry3.getAttributedOpEntries()).thenReturn(Map.of(\"tag\", attributed3));\n+\n+        when(packageOps.getOps()).thenReturn(List.of(entry1, entry2, entry3));\n+        when(mAppOpsManager.getPackagesForOps(AppOpsControllerImpl.OPS))\n+                .thenReturn(List.of(packageOps));\n+\n+        // WHEN we start listening\n+        mController.setListening(true);\n+\n+        // THEN the active list has the ops\n+        List<AppOpItem> list = mController.getActiveAppOps();\n+        assertEquals(2, list.size());\n+\n+        AppOpItem first = list.get(0);\n+        assertThat(first.getPackageName()).isEqualTo(\"package.one\");\n+        assertThat(first.getUid()).isEqualTo(1);\n+        assertThat(first.getCode()).isEqualTo(AppOpsManager.OP_PHONE_CALL_MICROPHONE);\n+\n+        AppOpItem second = list.get(1);\n+        assertThat(second.getPackageName()).isEqualTo(\"package.one\");\n+        assertThat(second.getUid()).isEqualTo(1);\n+        assertThat(second.getCode()).isEqualTo(AppOpsManager.OP_CAMERA);\n+    }\n+\n+    @Test\n+    public void startListening_fetchesCurrentActive_multipleAttributes() {\n+        AppOpsManager.PackageOps packageOps = mock(AppOpsManager.PackageOps.class);\n+        when(packageOps.getUid()).thenReturn(1);\n+        when(packageOps.getPackageName()).thenReturn(\"package.one\");\n+        AppOpsManager.OpEntry entry = mock(AppOpsManager.OpEntry.class);\n+        when(entry.getOpStr()).thenReturn(AppOpsManager.OPSTR_RECORD_AUDIO);\n+\n+        AppOpsManager.AttributedOpEntry attributed1 = mock(AppOpsManager.AttributedOpEntry.class);\n+        when(attributed1.isRunning()).thenReturn(false);\n+        AppOpsManager.AttributedOpEntry attributed2 = mock(AppOpsManager.AttributedOpEntry.class);\n+        when(attributed2.isRunning()).thenReturn(true);\n+        AppOpsManager.AttributedOpEntry attributed3 = mock(AppOpsManager.AttributedOpEntry.class);\n+        when(attributed3.isRunning()).thenReturn(true);\n+        when(entry.getAttributedOpEntries()).thenReturn(\n+                Map.of(\"attr1\", attributed1, \"attr2\", attributed2, \"attr3\", attributed3));\n+\n+        when(packageOps.getOps()).thenReturn(List.of(entry));\n+        when(mAppOpsManager.getPackagesForOps(AppOpsControllerImpl.OPS))\n+                .thenReturn(List.of(packageOps));\n+\n+        // WHEN we start listening\n+        mController.setListening(true);\n+\n+        // THEN the active list has the ops\n+        List<AppOpItem> list = mController.getActiveAppOps();\n+        // Multiple attributes get merged into one entry in the active ops\n+        assertEquals(1, list.size());\n+\n+        AppOpItem first = list.get(0);\n+        assertThat(first.getPackageName()).isEqualTo(\"package.one\");\n+        assertThat(first.getUid()).isEqualTo(1);\n+        assertThat(first.getCode()).isEqualTo(AppOpsManager.OP_RECORD_AUDIO);\n+    }\n+\n+    /** Regression test for b/294104969. */\n+    @Test\n+    public void addCallback_existingCallbacksNotifiedOfCurrentActive() {\n+        AppOpsManager.PackageOps packageOps1 = createPackageOp(\n+                \"package.one\",\n+                /* packageUid= */ 1,\n+                AppOpsManager.OPSTR_FINE_LOCATION,\n+                /* isRunning= */ true);\n+        AppOpsManager.PackageOps packageOps2 = createPackageOp(\n+                \"package.two\",\n+                /* packageUid= */ 2,\n+                AppOpsManager.OPSTR_RECORD_AUDIO,\n+                /* isRunning= */ true);\n+        AppOpsManager.PackageOps packageOps3 = createPackageOp(\n+                \"package.three\",\n+                /* packageUid= */ 3,\n+                AppOpsManager.OPSTR_PHONE_CALL_MICROPHONE,\n+                /* isRunning= */ true);\n+        when(mAppOpsManager.getPackagesForOps(AppOpsControllerImpl.OPS))\n+                .thenReturn(List.of(packageOps1, packageOps2, packageOps3));\n+\n+        // WHEN we start listening\n+        mController.addCallback(\n+                new int[]{AppOpsManager.OP_RECORD_AUDIO, AppOpsManager.OP_FINE_LOCATION},\n+                mCallback);\n+        mTestableLooper.processAllMessages();\n+\n+        // THEN the callback is notified of the current active ops it cares about\n+        verify(mCallback).onActiveStateChanged(\n+                AppOpsManager.OP_FINE_LOCATION,\n+                /* uid= */ 1,\n+                \"package.one\",\n+                true);\n+        verify(mCallback).onActiveStateChanged(\n+                AppOpsManager.OP_RECORD_AUDIO,\n+                /* uid= */ 2,\n+                \"package.two\",\n+                true);\n+        verify(mCallback, never()).onActiveStateChanged(\n+                AppOpsManager.OP_PHONE_CALL_MICROPHONE,\n+                /* uid= */ 3,\n+                \"package.three\",\n+                true);\n+    }\n+\n     @Test\n     public void addCallback_includedCode() {\n         mController.addCallback(\n@@ -673,6 +874,22 @@ public class AppOpsControllerTest extends SysuiTestCase {\n         assertEquals(AppOpsManager.OP_PHONE_CALL_CAMERA, list.get(cameraIdx).getCode());\n     }\n \n+    private AppOpsManager.PackageOps createPackageOp(\n+            String packageName, int packageUid, String opStr, boolean isRunning) {\n+        AppOpsManager.PackageOps packageOps = mock(AppOpsManager.PackageOps.class);\n+        when(packageOps.getPackageName()).thenReturn(packageName);\n+        when(packageOps.getUid()).thenReturn(packageUid);\n+        AppOpsManager.OpEntry entry = mock(AppOpsManager.OpEntry.class);\n+        when(entry.getOpStr()).thenReturn(opStr);\n+        AppOpsManager.AttributedOpEntry attributed = mock(AppOpsManager.AttributedOpEntry.class);\n+        when(attributed.isRunning()).thenReturn(isRunning);\n+\n+        when(packageOps.getOps()).thenReturn(Collections.singletonList(entry));\n+        when(entry.getAttributedOpEntries()).thenReturn(Map.of(\"tag\", attributed));\n+\n+        return packageOps;\n+    }\n+\n     private class TestHandler extends AppOpsControllerImpl.H {\n         TestHandler(Looper looper) {\n             mController.super(looper);\n",
    "added_lines": 217,
    "deleted_lines": 0,
    "changed_methods": "AppOpsControllerTest::startListening_fetchesCurrentActive_multipleAttributes, AppOpsControllerTest::addCallback_existingCallbacksNotifiedOfCurrentActive, AppOpsControllerTest::createPackageOp, AppOpsControllerTest::startListening_fetchesCurrentActive_oneActive, AppOpsControllerTest::startListening_fetchesCurrentActive_multiplePackages, AppOpsControllerTest::startListening_fetchesCurrentActive_multipleEntries, AppOpsControllerTest::startListening_fetchesCurrentActive_none"
   }
  ]
 },
 {
  "hash": "1e5b9954ad00d7de02b7b39854b72991ed20659f",
  "commit": "[SB][Privacy] Fetch current active appops on startup.\n\nThis also updates SysUI's chip animation scheduler to ignore an\n`isTooEarly` check if the chip animation is forced to be visible (which\nis true for privacy events).\n\nBug: 294104969\nTest: start recording, then kill systemui via adb-> verify privacy chip\nreappears after restart. Pull down shade and verify chip is correctly\nattributed. Stop recording and verify chip/dot disappears.\nTest: open camera, then kill systemui via adb -> verify privacy chip\nreappears after restart. Pull down shade and verify chip is correctly\nattributed. Close camera and verify chip/dot disappears.\nTest: smoke test of privacy chip and dot\nTest: atest AppOpsControllerTest SystemStatusAnimationSchedulerImplTest\n\n(cherry picked from commit 084a7afb4bb41e0cdfdbe67bdd60728d940b4331)\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:dac02d61f8cf755f733ef6c2fbd0f939ea13ee23)\nMerged-In: I664bb3003a2f6871113406e3257b7118bbdf2ab5\nChange-Id: I664bb3003a2f6871113406e3257b7118bbdf2ab5",
  "files": [
   {
    "filename": "AppOpsControllerImpl.java",
    "diff": "@@ -52,6 +52,7 @@ import java.io.FileDescriptor;\n import java.io.PrintWriter;\n import java.util.ArrayList;\n import java.util.List;\n+import java.util.Map;\n import java.util.Set;\n \n import javax.inject.Inject;\n@@ -144,6 +145,10 @@ public class AppOpsControllerImpl extends BroadcastReceiver implements AppOpsCon\n     protected void setListening(boolean listening) {\n         mListening = listening;\n         if (listening) {\n+            // System UI could be restarted while ops are active, so fetch the currently active ops\n+            // once System UI starts listening again.\n+            fetchCurrentActiveOps();\n+\n             mAppOps.startWatchingActive(OPS, this);\n             mAppOps.startWatchingNoted(OPS, this);\n             mAudioManager.registerAudioRecordingCallback(mAudioRecordingCallback, mBGHandler);\n@@ -176,6 +181,29 @@ public class AppOpsControllerImpl extends BroadcastReceiver implements AppOpsCon\n         }\n     }\n \n+    private void fetchCurrentActiveOps() {\n+        List<AppOpsManager.PackageOps> packageOps = mAppOps.getPackagesForOps(OPS);\n+        for (AppOpsManager.PackageOps op : packageOps) {\n+            for (AppOpsManager.OpEntry entry : op.getOps()) {\n+                for (Map.Entry<String, AppOpsManager.AttributedOpEntry> attributedOpEntry :\n+                        entry.getAttributedOpEntries().entrySet()) {\n+                    if (attributedOpEntry.getValue().isRunning()) {\n+                        onOpActiveChanged(\n+                                entry.getOpStr(),\n+                                op.getUid(),\n+                                op.getPackageName(),\n+                                /* attributionTag= */ attributedOpEntry.getKey(),\n+                                /* active= */ true,\n+                                // AppOpsManager doesn't have a way to fetch attribution flags or\n+                                // chain ID given an op entry, so default them to none.\n+                                AppOpsManager.ATTRIBUTION_FLAGS_NONE,\n+                                AppOpsManager.ATTRIBUTION_CHAIN_ID_NONE);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n     /**\n      * Adds a callback that will get notifified when an AppOp of the type the controller tracks\n      * changes\n",
    "added_lines": 28,
    "deleted_lines": 0,
    "changed_methods": "AppOpsControllerImpl::fetchCurrentActiveOps, AppOpsControllerImpl::setListening"
   },
   {
    "filename": "AppOpsControllerTest.java",
    "diff": "@@ -19,6 +19,8 @@ package com.android.systemui.appops;\n import static android.hardware.SensorPrivacyManager.Sensors.CAMERA;\n import static android.hardware.SensorPrivacyManager.Sensors.MICROPHONE;\n \n+import static com.google.common.truth.Truth.assertThat;\n+\n import static junit.framework.TestCase.assertFalse;\n \n import static org.junit.Assert.assertEquals;\n@@ -66,6 +68,7 @@ import org.mockito.MockitoAnnotations;\n \n import java.util.Collections;\n import java.util.List;\n+import java.util.Map;\n \n @SmallTest\n @RunWith(AndroidTestingRunner.class)\n@@ -157,6 +160,204 @@ public class AppOpsControllerTest extends SysuiTestCase {\n         verify(mSensorPrivacyController, times(1)).removeCallback(mController);\n     }\n \n+    @Test\n+    public void startListening_fetchesCurrentActive_none() {\n+        when(mAppOpsManager.getPackagesForOps(AppOpsControllerImpl.OPS))\n+                .thenReturn(List.of());\n+\n+        mController.setListening(true);\n+\n+        assertThat(mController.getActiveAppOps()).isEmpty();\n+    }\n+\n+    /** Regression test for b/294104969. */\n+    @Test\n+    public void startListening_fetchesCurrentActive_oneActive() {\n+        AppOpsManager.PackageOps packageOps = createPackageOp(\n+                \"package.test\",\n+                /* packageUid= */ 2,\n+                AppOpsManager.OPSTR_FINE_LOCATION,\n+                /* isRunning= */ true);\n+        when(mAppOpsManager.getPackagesForOps(AppOpsControllerImpl.OPS))\n+                .thenReturn(List.of(packageOps));\n+\n+        // WHEN we start listening\n+        mController.setListening(true);\n+\n+        // THEN the active list has the op\n+        List<AppOpItem> list = mController.getActiveAppOps();\n+        assertEquals(1, list.size());\n+        AppOpItem first = list.get(0);\n+        assertThat(first.getPackageName()).isEqualTo(\"package.test\");\n+        assertThat(first.getUid()).isEqualTo(2);\n+        assertThat(first.getCode()).isEqualTo(AppOpsManager.OP_FINE_LOCATION);\n+    }\n+\n+    @Test\n+    public void startListening_fetchesCurrentActive_multiplePackages() {\n+        AppOpsManager.PackageOps packageOps1 = createPackageOp(\n+                \"package.one\",\n+                /* packageUid= */ 1,\n+                AppOpsManager.OPSTR_FINE_LOCATION,\n+                /* isRunning= */ true);\n+        AppOpsManager.PackageOps packageOps2 = createPackageOp(\n+                \"package.two\",\n+                /* packageUid= */ 2,\n+                AppOpsManager.OPSTR_FINE_LOCATION,\n+                /* isRunning= */ false);\n+        AppOpsManager.PackageOps packageOps3 = createPackageOp(\n+                \"package.three\",\n+                /* packageUid= */ 3,\n+                AppOpsManager.OPSTR_FINE_LOCATION,\n+                /* isRunning= */ true);\n+        when(mAppOpsManager.getPackagesForOps(AppOpsControllerImpl.OPS))\n+                .thenReturn(List.of(packageOps1, packageOps2, packageOps3));\n+\n+        // WHEN we start listening\n+        mController.setListening(true);\n+\n+        // THEN the active list has the ops\n+        List<AppOpItem> list = mController.getActiveAppOps();\n+        assertEquals(2, list.size());\n+\n+        AppOpItem item0 = list.get(0);\n+        assertThat(item0.getPackageName()).isEqualTo(\"package.one\");\n+        assertThat(item0.getUid()).isEqualTo(1);\n+        assertThat(item0.getCode()).isEqualTo(AppOpsManager.OP_FINE_LOCATION);\n+\n+        AppOpItem item1 = list.get(1);\n+        assertThat(item1.getPackageName()).isEqualTo(\"package.three\");\n+        assertThat(item1.getUid()).isEqualTo(3);\n+        assertThat(item1.getCode()).isEqualTo(AppOpsManager.OP_FINE_LOCATION);\n+    }\n+\n+    @Test\n+    public void startListening_fetchesCurrentActive_multipleEntries() {\n+        AppOpsManager.PackageOps packageOps = mock(AppOpsManager.PackageOps.class);\n+        when(packageOps.getUid()).thenReturn(1);\n+        when(packageOps.getPackageName()).thenReturn(\"package.one\");\n+\n+        // Entry 1\n+        AppOpsManager.OpEntry entry1 = mock(AppOpsManager.OpEntry.class);\n+        when(entry1.getOpStr()).thenReturn(AppOpsManager.OPSTR_PHONE_CALL_MICROPHONE);\n+        AppOpsManager.AttributedOpEntry attributed1 = mock(AppOpsManager.AttributedOpEntry.class);\n+        when(attributed1.isRunning()).thenReturn(true);\n+        when(entry1.getAttributedOpEntries()).thenReturn(Map.of(\"tag\", attributed1));\n+        // Entry 2\n+        AppOpsManager.OpEntry entry2 = mock(AppOpsManager.OpEntry.class);\n+        when(entry2.getOpStr()).thenReturn(AppOpsManager.OPSTR_CAMERA);\n+        AppOpsManager.AttributedOpEntry attributed2 = mock(AppOpsManager.AttributedOpEntry.class);\n+        when(attributed2.isRunning()).thenReturn(true);\n+        when(entry2.getAttributedOpEntries()).thenReturn(Map.of(\"tag\", attributed2));\n+        // Entry 3\n+        AppOpsManager.OpEntry entry3 = mock(AppOpsManager.OpEntry.class);\n+        when(entry3.getOpStr()).thenReturn(AppOpsManager.OPSTR_FINE_LOCATION);\n+        AppOpsManager.AttributedOpEntry attributed3 = mock(AppOpsManager.AttributedOpEntry.class);\n+        when(attributed3.isRunning()).thenReturn(false);\n+        when(entry3.getAttributedOpEntries()).thenReturn(Map.of(\"tag\", attributed3));\n+\n+        when(packageOps.getOps()).thenReturn(List.of(entry1, entry2, entry3));\n+        when(mAppOpsManager.getPackagesForOps(AppOpsControllerImpl.OPS))\n+                .thenReturn(List.of(packageOps));\n+\n+        // WHEN we start listening\n+        mController.setListening(true);\n+\n+        // THEN the active list has the ops\n+        List<AppOpItem> list = mController.getActiveAppOps();\n+        assertEquals(2, list.size());\n+\n+        AppOpItem first = list.get(0);\n+        assertThat(first.getPackageName()).isEqualTo(\"package.one\");\n+        assertThat(first.getUid()).isEqualTo(1);\n+        assertThat(first.getCode()).isEqualTo(AppOpsManager.OP_PHONE_CALL_MICROPHONE);\n+\n+        AppOpItem second = list.get(1);\n+        assertThat(second.getPackageName()).isEqualTo(\"package.one\");\n+        assertThat(second.getUid()).isEqualTo(1);\n+        assertThat(second.getCode()).isEqualTo(AppOpsManager.OP_CAMERA);\n+    }\n+\n+    @Test\n+    public void startListening_fetchesCurrentActive_multipleAttributes() {\n+        AppOpsManager.PackageOps packageOps = mock(AppOpsManager.PackageOps.class);\n+        when(packageOps.getUid()).thenReturn(1);\n+        when(packageOps.getPackageName()).thenReturn(\"package.one\");\n+        AppOpsManager.OpEntry entry = mock(AppOpsManager.OpEntry.class);\n+        when(entry.getOpStr()).thenReturn(AppOpsManager.OPSTR_RECORD_AUDIO);\n+\n+        AppOpsManager.AttributedOpEntry attributed1 = mock(AppOpsManager.AttributedOpEntry.class);\n+        when(attributed1.isRunning()).thenReturn(false);\n+        AppOpsManager.AttributedOpEntry attributed2 = mock(AppOpsManager.AttributedOpEntry.class);\n+        when(attributed2.isRunning()).thenReturn(true);\n+        AppOpsManager.AttributedOpEntry attributed3 = mock(AppOpsManager.AttributedOpEntry.class);\n+        when(attributed3.isRunning()).thenReturn(true);\n+        when(entry.getAttributedOpEntries()).thenReturn(\n+                Map.of(\"attr1\", attributed1, \"attr2\", attributed2, \"attr3\", attributed3));\n+\n+        when(packageOps.getOps()).thenReturn(List.of(entry));\n+        when(mAppOpsManager.getPackagesForOps(AppOpsControllerImpl.OPS))\n+                .thenReturn(List.of(packageOps));\n+\n+        // WHEN we start listening\n+        mController.setListening(true);\n+\n+        // THEN the active list has the ops\n+        List<AppOpItem> list = mController.getActiveAppOps();\n+        // Multiple attributes get merged into one entry in the active ops\n+        assertEquals(1, list.size());\n+\n+        AppOpItem first = list.get(0);\n+        assertThat(first.getPackageName()).isEqualTo(\"package.one\");\n+        assertThat(first.getUid()).isEqualTo(1);\n+        assertThat(first.getCode()).isEqualTo(AppOpsManager.OP_RECORD_AUDIO);\n+    }\n+\n+    /** Regression test for b/294104969. */\n+    @Test\n+    public void addCallback_existingCallbacksNotifiedOfCurrentActive() {\n+        AppOpsManager.PackageOps packageOps1 = createPackageOp(\n+                \"package.one\",\n+                /* packageUid= */ 1,\n+                AppOpsManager.OPSTR_FINE_LOCATION,\n+                /* isRunning= */ true);\n+        AppOpsManager.PackageOps packageOps2 = createPackageOp(\n+                \"package.two\",\n+                /* packageUid= */ 2,\n+                AppOpsManager.OPSTR_RECORD_AUDIO,\n+                /* isRunning= */ true);\n+        AppOpsManager.PackageOps packageOps3 = createPackageOp(\n+                \"package.three\",\n+                /* packageUid= */ 3,\n+                AppOpsManager.OPSTR_PHONE_CALL_MICROPHONE,\n+                /* isRunning= */ true);\n+        when(mAppOpsManager.getPackagesForOps(AppOpsControllerImpl.OPS))\n+                .thenReturn(List.of(packageOps1, packageOps2, packageOps3));\n+\n+        // WHEN we start listening\n+        mController.addCallback(\n+                new int[]{AppOpsManager.OP_RECORD_AUDIO, AppOpsManager.OP_FINE_LOCATION},\n+                mCallback);\n+        mTestableLooper.processAllMessages();\n+\n+        // THEN the callback is notified of the current active ops it cares about\n+        verify(mCallback).onActiveStateChanged(\n+                AppOpsManager.OP_FINE_LOCATION,\n+                /* uid= */ 1,\n+                \"package.one\",\n+                true);\n+        verify(mCallback).onActiveStateChanged(\n+                AppOpsManager.OP_RECORD_AUDIO,\n+                /* uid= */ 2,\n+                \"package.two\",\n+                true);\n+        verify(mCallback, never()).onActiveStateChanged(\n+                AppOpsManager.OP_PHONE_CALL_MICROPHONE,\n+                /* uid= */ 3,\n+                \"package.three\",\n+                true);\n+    }\n+\n     @Test\n     public void addCallback_includedCode() {\n         mController.addCallback(\n@@ -673,6 +874,22 @@ public class AppOpsControllerTest extends SysuiTestCase {\n         assertEquals(AppOpsManager.OP_PHONE_CALL_CAMERA, list.get(cameraIdx).getCode());\n     }\n \n+    private AppOpsManager.PackageOps createPackageOp(\n+            String packageName, int packageUid, String opStr, boolean isRunning) {\n+        AppOpsManager.PackageOps packageOps = mock(AppOpsManager.PackageOps.class);\n+        when(packageOps.getPackageName()).thenReturn(packageName);\n+        when(packageOps.getUid()).thenReturn(packageUid);\n+        AppOpsManager.OpEntry entry = mock(AppOpsManager.OpEntry.class);\n+        when(entry.getOpStr()).thenReturn(opStr);\n+        AppOpsManager.AttributedOpEntry attributed = mock(AppOpsManager.AttributedOpEntry.class);\n+        when(attributed.isRunning()).thenReturn(isRunning);\n+\n+        when(packageOps.getOps()).thenReturn(Collections.singletonList(entry));\n+        when(entry.getAttributedOpEntries()).thenReturn(Map.of(\"tag\", attributed));\n+\n+        return packageOps;\n+    }\n+\n     private class TestHandler extends AppOpsControllerImpl.H {\n         TestHandler(Looper looper) {\n             mController.super(looper);\n",
    "added_lines": 217,
    "deleted_lines": 0,
    "changed_methods": "AppOpsControllerTest::startListening_fetchesCurrentActive_multipleAttributes, AppOpsControllerTest::addCallback_existingCallbacksNotifiedOfCurrentActive, AppOpsControllerTest::createPackageOp, AppOpsControllerTest::startListening_fetchesCurrentActive_oneActive, AppOpsControllerTest::startListening_fetchesCurrentActive_multiplePackages, AppOpsControllerTest::startListening_fetchesCurrentActive_multipleEntries, AppOpsControllerTest::startListening_fetchesCurrentActive_none"
   }
  ]
 },
 {
  "hash": "771669ad21217ad8a48ade48298e0f7276fd6bfb",
  "commit": "RESTRICT AUTOMERGE\nLog to detect usage of whitelistToken when sending non-PI target\n\nLog ActivityManagerService.sendIntentSender if the target is not a\nPendingIntent and a non-null whitelistToken is sent to the client.\nThis is simply to detect if there are real cases this would happen\nbefore we decide simply remove whitelistToken in that case.\n\nDo not pass  whitelistToken when sending non-PI target\n\nIn ActivityManagerService.sendIntentSender, if the target is not a\nPendingIntent, do not send whitelistToken to the client.\n\nBug: 279428283\nTest: Manual test\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:7a76717b61d8cb90a4987454f34e88417d68608b)\nMerged-In: I017486354a1ab2f14d0472c355583d53c27c4810\nChange-Id: I017486354a1ab2f14d0472c355583d53c27c4810",
  "files": [
   {
    "filename": "ActivityManagerService.java",
    "diff": "@@ -5035,7 +5035,20 @@ public class ActivityManagerService extends IActivityManager.Stub\n                 intent = new Intent(Intent.ACTION_MAIN);\n             }\n             try {\n-                target.send(code, intent, resolvedType, allowlistToken, null,\n+                if (allowlistToken != null) {\n+                    final int callingUid = Binder.getCallingUid();\n+                    final String packageName;\n+                    final long token = Binder.clearCallingIdentity();\n+                    try {\n+                        packageName = AppGlobals.getPackageManager().getNameForUid(callingUid);\n+                    } finally {\n+                        Binder.restoreCallingIdentity(token);\n+                    }\n+                    Slog.wtf(TAG, \"Send a non-null allowlistToken to a non-PI target.\"\n+                            + \" Calling package: \" + packageName + \"; intent: \" + intent\n+                            + \"; options: \" + options);\n+                }\n+                target.send(code, intent, resolvedType, null, null,\n                         requiredPermission, options);\n             } catch (RemoteException e) {\n             }\n",
    "added_lines": 14,
    "deleted_lines": 1,
    "changed_methods": "ActivityManagerService::sendIntentSender"
   }
  ]
 },
 {
  "hash": "3916fdc3cb4490fc828a633982c937da136fc791",
  "commit": "Fix vulnerability that allowed attackers to start arbitary activities\n\nTest: Flashed device and verified dream settings works as expected\nTest: Installed APK from bug and verified the dream didn't allow\nlaunching the inappropriate settings activity.\nFixes: 300090204\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:6926fd15fb16c51468dde270bd61ee68772b8c14)\nMerged-In: I573040df84bf98a493b39f96c8581e4303206bac\nChange-Id: I573040df84bf98a493b39f96c8581e4303206bac",
  "files": [
   {
    "filename": "DreamBackend.java",
    "diff": "@@ -351,7 +351,17 @@ public class DreamBackend {\n         if (cn != null && cn.indexOf('/') < 0) {\n             cn = resolveInfo.serviceInfo.packageName + \"/\" + cn;\n         }\n-        return cn == null ? null : ComponentName.unflattenFromString(cn);\n+        // Ensure that the component is from the same package as the dream service. If not,\n+        // treat the component as invalid and return null instead.\n+        final ComponentName result = cn != null ? ComponentName.unflattenFromString(cn) : null;\n+        if (result != null\n+                && !result.getPackageName().equals(resolveInfo.serviceInfo.packageName)) {\n+            Log.w(TAG,\n+                    \"Inconsistent package name in component: \" + result.getPackageName()\n+                            + \", should be: \" + resolveInfo.serviceInfo.packageName);\n+            return null;\n+        }\n+        return result;\n     }\n \n     private static void logd(String msg, Object... args) {\n",
    "added_lines": 11,
    "deleted_lines": 1,
    "changed_methods": "DreamBackend::getSettingsComponentName"
   }
  ]
 },
 {
  "hash": "a1e8ab5e0dbb34361cbd548abac2f8cf980faab9",
  "commit": "DO NOT MERGE: Fix ActivityManager#killBackgroundProcesses permissions\n\nIn the pevious CL, we incorrectly added the permission check in the\nkillBackgroundProcessesExcept. Now fix this issue.\n\nBug: 239423414\nBug: 223376078\nTest: atest CtsAppTestCases:ActivityManagerTest\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:140fce861944419a375c669010c6c47cd7ff5b37)\nMerged-In: I9471a77188ee63ec32cd0c81569193e4ccad885b\nChange-Id: I9471a77188ee63ec32cd0c81569193e4ccad885b",
  "files": [
   {
    "filename": "ActivityManagerService.java",
    "diff": "@@ -3690,6 +3690,22 @@ public class ActivityManagerService extends IActivityManager.Stub\n             throw new SecurityException(msg);\n         }\n \n+        final int callingUid = Binder.getCallingUid();\n+        final int callingPid = Binder.getCallingPid();\n+\n+        ProcessRecord proc;\n+        synchronized (mPidsSelfLocked) {\n+            proc = mPidsSelfLocked.get(callingPid);\n+        }\n+        if (callingUid >= FIRST_APPLICATION_UID\n+                && (proc == null || !proc.info.isSystemApp())) {\n+            final String msg = \"Permission Denial: killAllBackgroundProcesses() from pid=\"\n+                    + callingPid + \", uid=\" + callingUid + \" is not allowed\";\n+            Slog.w(TAG, msg);\n+            // Silently return to avoid existing apps from crashing.\n+            return;\n+        }\n+\n         final long callingId = Binder.clearCallingIdentity();\n         try {\n             synchronized (this) {\n@@ -3730,22 +3746,6 @@ public class ActivityManagerService extends IActivityManager.Stub\n             throw new SecurityException(msg);\n         }\n \n-        final int callingUid = Binder.getCallingUid();\n-        final int callingPid = Binder.getCallingPid();\n-\n-        ProcessRecord proc;\n-        synchronized (mPidsSelfLocked) {\n-            proc = mPidsSelfLocked.get(callingPid);\n-        }\n-        if (callingUid >= FIRST_APPLICATION_UID\n-                && (proc == null || !proc.info.isSystemApp())) {\n-            final String msg = \"Permission Denial: killAllBackgroundProcesses() from pid=\"\n-                    + callingPid + \", uid=\" + callingUid + \" is not allowed\";\n-            Slog.w(TAG, msg);\n-            // Silently return to avoid existing apps from crashing.\n-            return;\n-        }\n-\n         final long callingId = Binder.clearCallingIdentity();\n         try {\n             synchronized (this) {\n",
    "added_lines": 16,
    "deleted_lines": 16,
    "changed_methods": "ActivityManagerService::killAllBackgroundProcessesExcept, ActivityManagerService::killAllBackgroundProcesses"
   }
  ]
 }
]